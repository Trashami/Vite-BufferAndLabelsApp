/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{_ as e}from"../../chunks/tslib.es6.js";import t from"../../core/Accessor.js";import{getOrCreateMapValue as s}from"../../core/MapUtils.js";import{isSome as r}from"../../core/maybe.js";import{isAbortError as o,createResolver as a}from"../../core/promiseUtils.js";import{property as i}from"../../core/accessorSupport/decorators/property.js";import"../../core/arrayUtils.js";import"../../core/accessorSupport/ensureType.js";import{subclass as n}from"../../core/accessorSupport/decorators/subclass.js";const c="#JSAPI_FORM_EXPRESSIONS_MANAGER_GEOMETRY",l="esri.widgets.FeatureForm.FormExpressionsManager";let p=class extends t{constructor(e){super(e),this._fieldReferencesLookup=new Map,this._fieldsAffectedLookup=new Map,this._latestFieldValues={...e.feature.attributes}}initialize(){this._dependencyGraph=this._buildDependencyGraph()}get _baseContext(){const{editType:e,layer:t,map:s,originalFeature:o,spatialReference:a}=this.arcadeContextInfo,i="feature"===t?.type?t:"scene"===t?.type&&r(t.associatedLayer)?t.associatedLayer:void 0;return[{$originalfeature:o,$editcontext:{editType:e},$layer:i,$featureset:i,$datastore:t?.url,$map:s},{spatialReference:a}]}set feature(e){this._latestFieldValues={...e?.attributes},this._set("feature",e)}evaluateAll(){return this._evaluate(this.executors)}evaluateExpressions(e){return this._evaluate(e)}evaluateInvalidated(e){const{_fieldReferencesLookup:t,_latestFieldValues:s,feature:r}=this,o=new Set;for(const a of e)if(s[a]=r.getAttribute(a),t.has(a))for(const e of t.get(a))o.add(e);return this._evaluate([...o])}async evaluateInvalidatedByGeometry(){if(this._fieldReferencesLookup.has(c))return this._evaluate([...this._fieldReferencesLookup.get(c)])}resetExecutors(){for(const e of this.executors)e.reset()}_buildDependencyGraph(){const{_fieldReferencesLookup:e,_fieldsAffectedLookup:t,executors:o}=this,a=new Map(this.inputFields.map((e=>[e.name,e]))),i=new Map(o.map((e=>[e,new Array])));for(const n of o){for(const o of n.fieldsUsed){s(e,o,(()=>new Set)).add(n);const c=a.get(o),{valueExpressionExecutor:l,editableExpressionExecutor:p}=c;if(r(l)){i.get(l).push(n);s(t,l,(()=>new Set)).add(c)}if(r(p)){i.get(p).push(n);s(t,p,(()=>new Set)).add(c)}}if(n.geometryUsed){s(e,c,(()=>new Set)).add(n)}}return i}async _evaluate(e){const t=new Map,{_dependencyGraph:s,_fieldsAffectedLookup:r,_latestFieldValues:a}=this;for(const o of e)u(o,t,s);for(const[n,{resolver:c,dependencyPromises:l}]of t){Promise.all(l).then((async()=>{const[e,t]=this._makeContext(a);return n.executeAsync(e,t)})).then((()=>{if(r.has(n))for(const e of r.get(n))this._latestFieldValues[e.name]=e.value;c.resolve()}),(e=>{!e||o(e)||f(e)||n.markStale(),c.reject(e)}))}const i=(await Promise.allSettled(Array.from(t.values(),(({resolver:e})=>e.promise)))).filter((e=>"rejected"===e.status&&!(o(e.reason)||f(e.reason))));if(i.length>0)throw new AggregateError(i,"One or more expression executions failed")}_makeContext(e){const[t,s]=this._baseContext,r=this.feature.clone();return r.attributes=e,[{...t,$feature:r},s]}};e([i()],p.prototype,"_baseContext",null),e([i()],p.prototype,"feature",null),e([i()],p.prototype,"executors",void 0),e([i()],p.prototype,"inputFields",void 0),e([i()],p.prototype,"arcadeContextInfo",void 0),p=e([n(l)],p);const u=(e,t,s)=>{if(t.has(e))return;const r=a();t.set(e,{resolver:r,dependencyPromises:[]}),e.abort();const o=s.get(e);for(const a of o)u(a,t,s),t.get(a).dependencyPromises.push(r.promise)},f=e=>e&&"object"==typeof e&&"message"in e&&"Cancelled"===e.message;export{p as FormExpressionsManager};
