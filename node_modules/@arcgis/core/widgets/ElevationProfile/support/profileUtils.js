/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{splitIntoChunks as e}from"../../../core/arrayUtils.js";import{lerp as t}from"../../../core/mathUtils.js";import{isNone as r,none as o,forEachSome as s}from"../../../core/maybe.js";import{throwIfAborted as n,after as i,isAbortError as l,throwIfNotAbortError as a}from"../../../core/promiseUtils.js";import c from"../../../geometry/Multipoint.js";import{unnormalizedCoordinate as p}from"../../../geometry/support/coordsUtils.js";import{getInfo as u}from"../../../geometry/support/spatialReferenceUtils.js";import{QueueProcessor as m}from"../../../views/support/QueueProcessor.js";import{TaskPriority as f}from"../../../views/support/Scheduler.js";import{getConfig as d,ERROR_RESULT as h}from"./constants.js";import{isValidInputPath as y,countPoints as w,densifyPath as g}from"./geometryUtils.js";import{ProfileGenerationError as v,ProfileGenerationErrorCause as j}from"./ProfileGenerationError.js";import{getStatistics as P}from"./statisticsUtils.js";import{breadthFirstBinaryPartitioning as R}from"../../support/traversalUtils.js";async function*Z(e,t){const{view:l,geometry:a,elevationInfo:c,providers:p,options:u}=e,m=l.spatialReference;if(!m||r(a)||!y(a))throw new v(j.InvalidGeometry);const f=p.length;if(0===f)return o;const h=Math.round(u.maxTotalSamples/f);if(w(a)>h)throw new v(j.TooComplex);const P=await g(a,c,l,m,u,h,t);let R=0;const Z=new Array(f),E=new Array(f);for(let r=0;r<f;r++){const o=A(P);Z[r]=o,R+=o.samples.length;const s={...e,provider:p[r],result:o,densificationResult:P};E[r]=x(s,t)[Symbol.iterator]()}if(R>u.maxTotalSamples)throw new v(j.TooComplex);const O=await Promise.all(E.map((e=>{const t=e.next();return!0===t.done?Promise.resolve(null):t.value})));n(t);for(let r=0;r<f;r++)Z[r]=O[r];yield Z,await i(e.delayAfterPreview??d().delayAfterPreviewMillis,null,t.signal);const U=[];try{let e;do{e=!1;for(let t=0;t<f;t++){const r=E[t].next();!1===r.done&&(U.push({resultPromise:r.value,index:t}),e=!0)}}while(e)}finally{E.forEach((e=>e.return?.()))}for(const{resultPromise:r,index:o}of U)Z[o]=await r,n(t),yield Z;s(Z,(e=>{e.progress=1})),yield Z}function*x(t,r){const{densificationResult:o}=t,s={...t,abortOptions:r,densificationResult:o},n=R(0,s.result.samples.length),i=n.slice(0,s.provider.numSamplesForPreview);yield E(s,i,!0);const l=e(n,s.provider.numSamplesPerChunk);for(const e of l)yield E(s,e,!1)}async function E({densificationResult:e,result:t,provider:r,queue:o,abortOptions:s,cache:n},i,a){const{densifiedPath:p,pathLength:u}=e,m=t.spatialReference,{samples:f}=t,y=[];for(let l=0;l<i.length;l++){const e=f[i[l]];y[l]=e.coordinate}try{return await o.push({geometry:new c({spatialReference:m,points:y,hasZ:p.hasZ}),provider:r,indices:i,preview:a,result:t,queryOptions:{...d().defaultQueryOptions(),minDemResolution:a?Math.round(u/r.numSamplesForPreview):Math.round(u/f.length),cache:n}},s),{...t}}catch(w){return l(w)?null:h}}function O(e){return new m({priority:f.ELEVATION_PROFILE,concurrency:1,scheduler:e,process:async e=>{n(e.queryOptions);try{await U(e)}catch(t){a(t)}}})}async function U({geometry:e,provider:t,indices:r,preview:o,result:s,queryOptions:n}){if(0===r.length)return;const i=(await I(t,e,n)).geometry,{hasZ:l,points:a}=i,c=n.noDataValue,{samples:p}=s;for(let u=0;u<r.length;u++){const e=p[r[u]];if(e.isHole)continue;const t=l?a[u][2]:null;null===t||t===c?e.sampledZ=null:(s.hasZ=!0,e.sampledZ=t),e.sampled=!0}S(p),s.progress=o?0:s.progress+r.length/p.length,s.statistics=P(s.samples,s.spatialReference)}function S(e){const t=e.length-1;let r=0;for(let o=1;o<=t;o++){(e[o].sampled||o===t)&&(q(e,r,o),r=o)}}function q(e,o,s){if(s-o==1)return;const n=e[o],i=n.sampledZ,l=e[s],a=l.sampledZ;if(r(i)||r(a)){for(let t=o+1;t<s;t++)e[t].sampledZ=null;return}const c=n.distance,p=l.distance-c;for(let r=o+1;r<s;r++){const o=e[r],s=(o.distance-c)/p;o.sampledZ=t(i,a,s)}}function A({densifiedPath:e,distances:t}){const r=e.spatialReference,o=u(r),s=e.paths,n=s.length,i=[];let l=null,a=0;for(let c=0;c<n;c++){const e=s[c],r=e.length,n=t[c];for(let t=0;t<r;t++){const r=e[t],s=n[t];o&&(r[0]=p(r[0],o.valid[0],o.valid[1])),l&&0===t&&M(i,l,r,a,s),i.push(T(r,s)),l=r,a=s}}return{progress:0,samples:i,hasZ:!1,statistics:null,spatialReference:r}}function M(e,t,r,o,s){e.push(b(t,o)),e.push(b(r,s))}function T(e,t){return{coordinate:e,distance:t,sampledZ:null,sampled:!1,isHole:!1}}function b(e,t){return{coordinate:e,distance:t,sampledZ:null,sampled:!0,isHole:!0}}async function I(e,t,r){try{return await e.queryElevation(t,r)}catch(o){throw new v(j.ElevationQueryError)}}export{O as createProfileQueue,x as generateProfile,Z as generateProfiles,S as interpolateElevations};
