/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import e from"../../Color.js";import t from"../../request.js";import s from"../../core/Error.js";import o from"../../core/Logger.js";import i from"../../core/LRUCache.js";import{isSome as r,isNone as n}from"../../core/maybe.js";import{isAbortError as l}from"../../core/promiseUtils.js";import{numericHash as a}from"../../core/string.js";import{loadArcade as c,createDictionaryExpression as m}from"../../support/arcadeOnDemand.js";import f from"../../symbols/CIMSymbol.js";const h="esri.renderers.support.DictionaryLoader",y={type:"CIMSimpleLineCallout",lineSymbol:{type:"CIMLineSymbol",symbolLayers:[{type:"CIMSolidStroke",width:.5,color:[0,0,0,255]}]}};class u{constructor(e,t,s){this.config=null,this.fieldMap=null,this.url=null,this._ongoingRequests=new Map,this._symbolCache=new i(100),this._dictionaryPromise=null,this.url=e,this.config=t,this.fieldMap=s}getSymbolFields(){return this._symbolFields}async getSymbolAsync(t,s){let o;this._dictionaryPromise||(this._dictionaryPromise=this.fetchResources(s));try{o=await this._dictionaryPromise}catch(g){if(l(g))return this._dictionaryPromise=null,null}const i={};if(this.fieldMap)for(const e of this._symbolFields){const s=this.fieldMap[e];if(s&&null!=t.attributes[s]){const o=""+t.attributes[s];i[e]=o}else i[e]=""}const n=o?.(i,s);if(!n||"string"!=typeof n)return null;const c=a(n).toString(),m=this._symbolCache.get(c);if(m)return m.catch((()=>{this._symbolCache.pop(c)})),m;const f=n.split(";"),h=[],y=[];for(const r of f)if(r)if(r.includes("po:")){const t=r.substr(3).split("|");if(3===t.length){const s=t[0],o=t[1];let i=t[2];if("DashTemplate"===o)i=i.split(" ").map((e=>Number(e)));else if("Color"===o){const t=new e(i).toRgba();i=[t[0],t[1],t[2],255*t[3]]}else i=Number(i);y.push({primitiveName:s,propertyName:o,value:i})}}else if(r.includes("|")){for(const e of r.split("|"))if(this._itemNames.has(e)){h.push(e);break}}else this._itemNames.has(r)&&h.push(r);const u=!r(t.geometry)||!t.geometry.hasZ&&"point"===t.geometry.type,p=this._cimPartsToCIMSymbol(h,y,u,s);return this._symbolCache.put(c,p,1),p}async fetchResources(e){if(this._dictionaryPromise)return this._dictionaryPromise;if(!this.url)return void o.getLogger(h).error("no valid URL!");const i=t(this.url+"/resources/styles/dictionary-info.json",{responseType:"json",query:{f:"json"},signal:r(e)?e.signal:null}),[{data:l}]=await Promise.all([i,c()]);if(!l)throw this._dictionaryPromise=null,new s("esri.renderers.DictionaryRenderer","Bad dictionary data!");const a=l.expression,f=l.authoringInfo;this._refSymbolUrlTemplate=this.url+"/"+l.cimRefTemplateUrl,this._itemNames=new Set(l.itemsNames),this._symbolFields=f.symbol;const y={};if(this.config){const e=this.config;for(const t in e)y[t]=e[t]}if(f.configuration)for(const t of f.configuration)y.hasOwnProperty(t.name)||(y[t.name]=t.value);const u=[];if(r(e)&&e.fields&&this.fieldMap)for(const t of this._symbolFields){const s=this.fieldMap[t],o=e.fields.filter((e=>e.name===s));o.length>0&&u.push({...o[0],name:t})}const p=m(a,r(e)?e.spatialReference:null,u,y).then((e=>{const t={scale:0};return(s,o)=>{if(n(e))return null;const i=e.repurposeFeature({geometry:null,attributes:s});return t.scale=r(o)?o.scale:void 0,e.evaluate({$feature:i,$view:t})}})).catch((e=>(o.getLogger(h).error("Creating dictinoary expression failed:",e),null)));return this._dictionaryPromise=p,p}async _cimPartsToCIMSymbol(e,t,s,o){const i=new Array(e.length);for(let l=0;l<e.length;l++)i[l]=this._getSymbolPart(e[l],o);const r=await Promise.all(i),n=this.fieldMap;if(n)for(const l of r)p(l,n);return new f({data:this._combineSymbolParts(r,t,s)})}async _getSymbolPart(e,s){if(this._ongoingRequests.has(e))return this._ongoingRequests.get(e).then((e=>e.data));const o=this._refSymbolUrlTemplate.replace(/\{itemName\}/gi,e),i=t(o,{responseType:"json",query:{f:"json"},...s});this._ongoingRequests.set(e,i);try{return(await i).data}catch(r){throw this._ongoingRequests.delete(e),r}}_combineSymbolParts(e,t,s){if(!e||0===e.length)return null;const o={...e[0]};if(e.length>1){o.symbolLayers=[];for(const t of e){const e=t;o.symbolLayers.unshift(...e.symbolLayers)}}return s&&(o.callout=y),{type:"CIMSymbolReference",symbol:o,primitiveOverrides:t}}}function p(e,t){if(!e)return;const s=e.symbolLayers;if(!s)return;let o=s.length;for(;o--;){const e=s[o];if(e&&!1!==e.enable&&"CIMVectorMarker"===e.type)g(e,t)}}function g(e,t){const s=e.markerGraphics;if(s)for(const o of s){if(!o)continue;const e=o.symbol;if(e)switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":p(e,t);break;case"CIMTextSymbol":e.fieldMap=t}}}export{u as DictionaryLoader};
