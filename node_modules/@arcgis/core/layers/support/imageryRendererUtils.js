/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{clone as e}from"../../core/lang.js";import{isNone as t}from"../../core/maybe.js";import n from"./RasterFunction.js";import{schema as r}from"./rasterFunctionUtils.js";import{getRFxArgColorRampValue as o,convertColorRampToColormap as a,getColorRampName as i,rgbaConvertTo32Bit as s}from"../../renderers/support/colorRampUtils.js";import{stretchTypeJSONDict as u}from"../../renderers/support/stretchRendererUtils.js";import l from"../../renderers/visualVariables/SizeVariable.js";const c={u1:[0,1],u2:[0,3],u4:[0,15],u8:[0,255],s8:[-128,127],u16:[0,65535],s16:[-32768,32767]},m={simple_scalar:"Simple Scalar",wind_barb:"Wind Barb",single_arrow:"Single Arrow",beaufort_kn:"Beaufort Wind (Knots)",beaufort_m:"Beaufort Wind (MetersPerSecond)",ocean_current_m:"Ocean Current (MetersPerSecond)",ocean_current_kn:"Ocean Current (Knots)"},p=new Set(["raster-stretch","unique-value","class-breaks","raster-shaded-relief","vector-field","raster-colormap"]);function f(e){return p.has(e.type)}function g(t,n){if(!t||!n)return e(t||n);const r=e(t);if(n.rasterFunctionDefinition){const e=n.rasterFunctionDefinition;(e.thumbnail||e.thumbnailEx)&&(e.thumbnail=e.thumbnailEx=null),d(r.rasterFunctionDefinition.arguments,n)}else if("none"!==n.functionName.toLowerCase()){b(r.functionArguments).Raster=n}return r}function d(e,t){for(const n in e)"raster"===n.toLowerCase()&&("RasterFunctionVariable"===e[n].type?(e[n]=t.rasterFunctionDefinition,e[n].type="RasterFunctionTemplate"):"RasterFunctionTemplate"===e[n].type&&d(e[n].arguments,t))}function h(t){const n=e(r[t.functionName+"Function"]),o=t.functionArguments;for(const e in o)"raster"===e.toLowerCase()?(n.arguments[e]=h(o[e]),n.arguments[e].type="RasterFunctionTemplate"):"colormap"===e.toLowerCase()?(n.arguments[e].value=D(o[e]),n.arguments.ColorSchemeType.value=0):n.arguments[e].value=o[e];return n}function y(e,t){switch(t=t||{},e.type){case"raster-stretch":return v(e,t);case"class-breaks":return C(e,t);case"unique-value":return A(e,t);case"raster-colormap":return F(e,t);case"vector-field":return T(e,t);case"raster-shaded-relief":return w(e,t);case"flow":throw new Error("Unsupported rendering rule.")}}function b(e){const t=e?.Raster;return t&&"esri.layers.support.RasterFunction"===t.declaredClass?b(t.functionArguments):e}const R={none:0,standardDeviation:3,histogramEqualization:4,minMax:5,percentClip:6,sigmoid:9};function T(e,t){const r=new n;r.functionName="VectorFieldRenderer";const{dataType:o,bandProperties:a}=t,i="vector-uv"===o;let s,u;a&&2===a.length&&(s=a.map((e=>e.BandName.toLowerCase())).indexOf("magnitude"),u=a.map((e=>e.BandName.toLowerCase())).indexOf("direction")),-1!==s&&null!==s||(s=0,u=1);const c="arithmetic"===e.rotationType?1:2,p="flow-from"===e.flowRepresentation?0:1,f=e.visualVariables?e.visualVariables.find((e=>"Magnitude"===e.field)):new l,g={magnitudeBandID:s,directionBandID:u,isUVComponents:i,referenceSystem:c,massFlowAngleRepresentation:p,symbolTileSize:50,symbolTileSizeUnits:100,calculationMethod:"Vector Average",symbologyName:m[e.style.toLowerCase().replace("-","_")],minimumMagnitude:f.minDataValue,maximumMagnitude:f.maxDataValue,minimumSymbolSize:f.minSize,maximumSymbolSize:f.maxSize};return r.functionArguments=g,t.convertToRFT?new n({rasterFunctionDefinition:h(r)}):r}function w(e,t){const r=t.convertToRFT;if("elevation"!==t.dataType&&("generic"!==t.dataType||1!==t.bandCount||"s16"!==t.pixelType&&"s32"!==t.pixelType&&"f32"!==t.pixelType&&"f64"!==t.pixelType))return new n;const i=new n;i.functionName="Hillshade";const s="traditional"===e.hillshadeType?0:1,u="none"===e.scalingType?1:3,l={HillshadeType:s,SlopeType:u,ZFactor:e.zFactor};return 0===s&&(l.Azimuth=e.azimuth,l.Altitude=e.altitude),3===u&&(l.PSPower=e.pixelSizePower,l.PSZFactor=e.pixelSizeFactor),i.functionArguments=l,i.variableName="Raster",e.colorRamp&&(i.functionName="ShadedRelief",r?l.ColorRamp=o(e.colorRamp):l.Colormap=a(e.colorRamp,256)),r?new n({rasterFunctionDefinition:h(i)}):i}function v(e,t){const r=t.convertToRFT,s=new n;s.functionName="Stretch";const l=R[u.toJSON(e.stretchType)],c="u8",m={StretchType:l,Statistics:N(e.statistics),DRA:e.dynamicRangeAdjustment,UseGamma:e.useGamma,Gamma:e.gamma,ComputeGamma:e.computeGamma};if(null!=e.outputMin&&(m.Min=e.outputMin),null!=e.outputMax&&(m.Max=e.outputMax),l===R.standardDeviation?(m.NumberOfStandardDeviations=e.numberOfStandardDeviations,s.outputPixelType=c):l===R.percentClip?(m.MinPercent=e.minPercent,m.MaxPercent=e.maxPercent,s.outputPixelType=c):l===R.minMax?s.outputPixelType=c:l===R.sigmoid&&(m.SigmoidStrengthLevel=e.sigmoidStrengthLevel),s.functionArguments=m,s.variableName="Raster",e.colorRamp){const u=e.colorRamp,l=new n;if(r)l.functionArguments={ColorRamp:o(u)};else{const n=i(u);if(n)l.functionArguments={colorRamp:n};else if(!t.convertColorRampToColormap||"algorithmic"!==u.type&&"multipart"!==u.type){const t=e.colorRamp.toJSON();"algorithmic"===t.type?t.algorithm=t.algorithm||"esriCIELabAlgorithm":"multipart"===t.type&&t.colorRamps?.length&&t.colorRamps.forEach((e=>e.algorithm=e.algorithm||"esriCIELabAlgorithm")),l.functionArguments={colorRamp:t}}else l.functionArguments={Colormap:a(u,256)}}return l.variableName="Raster",l.functionName="Colormap",l.functionArguments.Raster=s,r?new n({rasterFunctionDefinition:h(l)}):l}return r?new n({rasterFunctionDefinition:h(s)}):s}function C(e,r){const o=[],a=[],i=[],s=[],u=1e-6,{pixelType:l,rasterAttributeTable:c}=r,m=t(c)?null:c.features,p=x(c);if(m&&Array.isArray(m)&&e.classBreakInfos){e.classBreakInfos.forEach(((t,n)=>{const r=t.symbol.color;let o;r.a&&m.forEach((a=>{o=a.attributes[e.field],(o>=t.minValue&&o<t.maxValue||n===e.classBreakInfos.length-1&&o>=t.minValue)&&s.push([a.attributes[p],r.r,r.g,r.b])}))}));const t=l?S(s,l):s,o=new n;return o.functionName="Colormap",o.functionArguments={},o.functionArguments.Colormap=t,o.variableName="Raster",r.convertToRFT?new n({rasterFunctionDefinition:h(o)}):o}e.classBreakInfos.forEach(((e,t)=>{const n=e.symbol&&e.symbol.color;n.a?(0===t?o.push(e.minValue,e.maxValue+u):o.push(e.minValue+u,e.maxValue+u),a.push(t),s.push([t,n.r,n.g,n.b])):i.push(e.minValue,e.maxValue)}));const f=l?S(s,l):s,g=new n;g.functionName="Remap",g.functionArguments={InputRanges:o,OutputValues:a,NoDataRanges:i},g.variableName="Raster";const d=new n;return d.functionName="Colormap",d.functionArguments={Colormap:f,Raster:g},r.convertToRFT?new n({rasterFunctionDefinition:h(d)}):d}function S(e,t){const n=c[String(t).toLowerCase()];return n&&e.push([Math.floor(n[0]-1),0,0,0],[Math.ceil(n[1]+1),0,0,0]),e}function x(e){if(t(e))return;const{fields:n}=e,r=n&&n.find((e=>e&&e.name&&"value"===e.name.toLowerCase()));return r&&r.name}function A(e,r){const o=[],{pixelType:a,rasterAttributeTable:i}=r,s=t(i)?null:i.features,u=x(i),l=e.defaultSymbol?.color?.toRgb(),c=e.uniqueValueInfos;if(c)if(s){const t=new Map;c.forEach((e=>{const n=e.value,r=e.symbol.color;null!=n&&r&&r.a&&t.set(String(n),r.toRgb())}));const n=e.field;s.forEach((({attributes:e})=>{const r=String(e[n]),a=e[u];if(t.has(r)){const e=t.get(r);o.push([a,...e])}else l&&o.push([a,...l])}))}else for(let t=0;t<c.length;t++){const e=c[t],n=e.symbol.color,r=+e.value;if(n?.a){if(isNaN(r))return null;o.push([r,n.r,n.g,n.b])}}const m=a&&o.length>0?S(o,a):o,p=new n;return p.functionName="Colormap",p.functionArguments={},p.functionArguments.Colormap=m,p.variableName="Raster",r.convertToRFT?new n({rasterFunctionDefinition:h(p)}):p}function F(e,t){const r=e.extractColormap();if(!r||0===r.length)return;const{pixelType:o}=t,a=o?S(r,o):r,i=new n;return i.functionName="Colormap",i.functionArguments={},i.functionArguments.Colormap=a,t.convertToRFT?new n({rasterFunctionDefinition:h(i)}):i}function N(e){const t=[];return e.forEach((e=>{const n=e;if(Array.isArray(n))t.push(n);else{if(null==n.min||null==n.max)return;const e=[n.min,n.max,n.avg||0,n.stddev||0];t.push(e)}})),t}function D(e){const t=[],n=[];return e.forEach((e=>{t.push(e[0]),n.push(s([...e.slice(1),255]))})),{type:"RasterColormap",values:t,colors:n}}export{g as combineRenderingRules,y as convertRendererToRenderingRule,h as convertRenderingRuleToRFT,f as isSupportedRendererType,c as pixelTypeRanges};
