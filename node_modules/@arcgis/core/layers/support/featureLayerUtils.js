/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import t from"../../core/Error.js";import has from"../../core/has.js";import{JSONMap as e}from"../../core/jsonMap.js";import{isSome as r}from"../../core/maybe.js";import{parseWhereClause as s}from"../../core/sql.js";import{parse as o,isHostedAgolService as a}from"./arcgisLayerUrl.js";import n from"../../rest/support/AttachmentQuery.js";import p from"../../rest/support/Query.js";import u from"../../rest/support/RelationshipQuery.js";const i=new e({esriGeometryPoint:"point",esriGeometryMultipoint:"multipoint",esriGeometryPolyline:"polyline",esriGeometryPolygon:"polygon",esriGeometryMultiPatch:"multipatch"}),c={name:"supportsName",size:"supportsSize",contentType:"supportsContentType",keywords:"supportsKeywords",exifInfo:"supportsExifInfo"};function l(t,e,r){return!!(t&&t.hasOwnProperty(e)?t[e]:r)}function d(t,e,r){return t&&t.hasOwnProperty(e)?t[e]:r}function y(t){const e=t?.supportedSpatialAggregationStatistics?.map((t=>t.toLowerCase()));return{envelope:!!e?.includes("envelopeaggregate"),centroid:!!e?.includes("centroidaggregate"),convexHull:!!e?.includes("convexhullaggregate")}}function m(t,e){const r=t?.supportedOperationsWithCacheHint?.map((t=>t.toLowerCase()));return!!r?.includes(e.toLowerCase())}function h(t,e,r){return{analytics:f(e),attachment:w(e),data:g(e),metadata:C(e),operations:b(e.capabilities||t,e,r),query:A(e,r),queryRelated:R(e),queryTopFeatures:S(e),editing:Q(e)}}function f(t){return{supportsCacheHint:m(t.advancedQueryCapabilities,"queryAnalytics")}}function w(t){const e=t.attachmentProperties,r={supportsName:!1,supportsSize:!1,supportsContentType:!1,supportsKeywords:!1,supportsExifInfo:!1,supportsCacheHint:m(t.advancedQueryCapabilities,"queryAttachments"),supportsResize:l(t,"supportsAttachmentsResizing",!1)};return e&&Array.isArray(e)&&e.forEach((t=>{const e=c[t.name];e&&(r[e]=!!t.isEnabled)})),r}function g(t){return{isVersioned:l(t,"isDataVersioned",!1),supportsAttachment:l(t,"hasAttachments",!1),supportsM:l(t,"hasM",!1),supportsZ:l(t,"hasZ",!1)}}function C(t){return{supportsAdvancedFieldProperties:l(t,"supportsFieldDescriptionProperty",!1)}}function b(t,e,s){const a=t?t.toLowerCase().split(",").map((t=>t.trim())):[],n=s?o(s):null,p=a.includes(r(n)&&"MapServer"===n.serverType?"data":"query"),u=a.includes("editing")&&!e.datesInUnknownTimezone;let i=u&&a.includes("create"),c=u&&a.includes("delete"),d=u&&a.includes("update");const y=a.includes("changetracking"),m=e.advancedQueryCapabilities;return u&&!(i||c||d)&&(i=c=d=!0),{supportsCalculate:l(e,"supportsCalculate",!1),supportsTruncate:l(e,"supportsTruncate",!1),supportsValidateSql:l(e,"supportsValidateSql",!1),supportsAdd:i,supportsDelete:c,supportsEditing:u,supportsChangeTracking:y,supportsQuery:p,supportsQueryAnalytics:l(m,"supportsQueryAnalytic",!1),supportsQueryAttachments:l(m,"supportsQueryAttachments",!1),supportsQueryTopFeatures:l(m,"supportsTopFeaturesQuery",!1),supportsResizeAttachments:l(e,"supportsAttachmentsResizing",!1),supportsSync:a.includes("sync"),supportsUpdate:d,supportsExceedsLimitStatistics:l(e,"supportsExceedsLimitStatistics",!1)}}function A(t,e){const r=t.advancedQueryCapabilities,s=t.ownershipBasedAccessControlForFeatures,o=t.archivingInfo,n=B(t),p=e?.includes("MapServer"),u=!has("mapserver-pbf-enabled")&&p&&(n??0)<10.81,i=a(e),c=(t.supportedQueryFormats||"").split(",").reduce(((t,e)=>{const r=e.toLowerCase().trim();return r&&t.add(r),t}),new Set);return{supportsStatistics:l(r,"supportsStatistics",t.supportsStatistics),supportsPercentileStatistics:l(r,"supportsPercentileStatistics",!1),supportsSpatialAggregationStatistics:l(r,"supportsSpatialAggregationStatistics",!1),supportedSpatialAggregationStatistics:y(r),supportsCentroid:l(r,"supportsReturningGeometryCentroid",!1),supportsDistance:l(r,"supportsQueryWithDistance",!1),supportsDistinct:l(r,"supportsDistinct",t.supportsAdvancedQueries),supportsExtent:l(r,"supportsReturningQueryExtent",!1),supportsGeometryProperties:l(r,"supportsReturningGeometryProperties",!1),supportsHavingClause:l(r,"supportsHavingClause",!1),supportsOrderBy:l(r,"supportsOrderBy",t.supportsAdvancedQueries),supportsPagination:l(r,"supportsPagination",!1),supportsQuantization:l(t,"supportsCoordinatesQuantization",!1),supportsQuantizationEditMode:l(t,"supportsQuantizationEditMode",!1),supportsQueryGeometry:l(t,"supportsReturningQueryGeometry",!1),supportsResultType:l(r,"supportsQueryWithResultType",!1),supportsMaxRecordCountFactor:l(r,"supportsMaxRecordCountFactor",!1),supportsSqlExpression:l(r,"supportsSqlExpression",!1),supportsStandardizedQueriesOnly:l(t,"useStandardizedQueries",!1),supportsTopFeaturesQuery:l(r,"supportsTopFeaturesQuery",!1),supportsQueryByOthers:l(s,"allowOthersToQuery",!0),supportsHistoricMoment:l(o,"supportsQueryWithHistoricMoment",!1),supportsFormatPBF:!u&&c.has("pbf"),supportsDisjointSpatialRelationship:l(r,"supportsDisjointSpatialRel",!1),supportsCacheHint:l(r,"supportsQueryWithCacheHint",!1)||m(r,"query"),supportsDefaultSpatialReference:l(r,"supportsDefaultSR",!1),supportsCompactGeometry:i,supportsFullTextSearch:l(r,"supportsFullTextSearch",!1),maxRecordCountFactor:d(t,"maxRecordCountFactor",void 0),maxRecordCount:d(t,"maxRecordCount",void 0),standardMaxRecordCount:d(t,"standardMaxRecordCount",void 0),tileMaxRecordCount:d(t,"tileMaxRecordCount",void 0)}}function R(t){const e=t.advancedQueryCapabilities,r=l(e,"supportsAdvancedQueryRelated",!1);return{supportsPagination:l(e,"supportsQueryRelatedPagination",!1),supportsCount:r,supportsOrderBy:r,supportsCacheHint:m(e,"queryRelated")}}function S(t){return{supportsCacheHint:m(t.advancedQueryCapabilities,"queryTopFilter")}}function Q(t){const e=t.ownershipBasedAccessControlForFeatures;return{supportsGeometryUpdate:l(t,"allowGeometryUpdates",!0),supportsGlobalId:l(t,"supportsApplyEditsWithGlobalIds",!1),supportsReturnServiceEditsInSourceSpatialReference:l(t,"supportsReturnServiceEditsInSourceSR",!1),supportsRollbackOnFailure:l(t,"supportsRollbackOnFailureParameter",!1),supportsUpdateWithoutM:l(t,"allowUpdateWithoutMValues",!1),supportsUploadWithItemId:l(t,"supportsAttachmentsByUploadId",!1),supportsDeleteByAnonymous:l(e,"allowAnonymousToDelete",!0),supportsDeleteByOthers:l(e,"allowOthersToDelete",!0),supportsUpdateByAnonymous:l(e,"allowAnonymousToUpdate",!0),supportsUpdateByOthers:l(e,"allowOthersToUpdate",!0)}}async function F(e,r,s,o){const{source:a}=await e.load();if(await q(e,r,o),!a.addAttachment)throw new t(o,"Layer source does not support addAttachment capability");return a.addAttachment(r,s)}function q(e,r,s){const{attributes:o}=r,{objectIdField:a}=e;return e.get("capabilities.data.supportsAttachment")?r?o?a&&o[a]?Promise.resolve():Promise.reject(new t(s,`feature is missing the identifying attribute ${a}`)):Promise.reject(new t(s,"'attributes' are required on a feature to query attachments")):Promise.reject(new t(s,"A feature is required to add/delete/update attachments")):Promise.reject(new t(s,"this layer doesn't support attachments"))}async function x(e,r,s,o,a){const{source:n}=await e.load();if(await q(e,r,a),!n.updateAttachment)throw new t(a,"Layer source does not support updateAttachment capability");return n.updateAttachment(r,s,o)}async function P(t,e,r){const s=await import("../graphics/editingSupport.js"),o=await t.load();return s.applyEdits(o,o.source,e,r)}async function O(e,r,s,o){const{source:a}=await e.load();if(await q(e,r,o),!a.deleteAttachments)throw new t(o,"Layer source does not support deleteAttachments capability");return a.deleteAttachments(r,s)}async function v(e,r,s){const{source:o}=await e.load({signal:r?.signal});if(!o.fetchRecomputedExtents)throw new t(s,"Layer source does not support fetchUpdates capability");return o.fetchRecomputedExtents(r)}async function E(e,r,s,o){r=n.from(r);const{source:a,capabilities:p}=await e.load();if(!p?.data?.supportsAttachment)throw new t(o,"this layer doesn't support attachments");const{attachmentTypes:u,objectIds:i,globalIds:c,num:l,size:d,start:y,where:m}=r;if(!p?.operations?.supportsQueryAttachments){const e=i&&i.length>1,s=u&&u.length,a=c&&c.length,n=d&&d.length;if(e||s||a||n||l||y||m)throw new t(o,"when 'supportsQueryAttachments' is false, only objectIds of length 1 are supported",r)}if(!i?.length&&!m)throw new t(o,"'objectIds' or 'where' are required to perform attachment query",r);if(!a.queryAttachments)throw new t(o,"Layer source does not support queryAttachments capability",r);return a.queryAttachments(r)}async function I(e,r,s,o){const{source:a}=await e.load();if(!a.queryObjectIds)throw new t(o,"Layer source does not support queryObjectIds capability");return a.queryObjectIds(p.from(r)??e.createQuery(),s)}async function T(e,r,s,o){const{source:a}=await e.load();if(!a.queryFeatureCount)throw new t(o,"Layer source does not support queryFeatureCount capability");return a.queryFeatureCount(p.from(r)??e.createQuery(),s)}async function j(e,r,s,o){const{source:a}=await e.load();if(!a.queryExtent)throw new t(o,"Layer source does not support queryExtent capability");return a.queryExtent(p.from(r)??e.createQuery(),s)}async function M(e,r,s,o){const{source:a}=await e.load();if(!a.queryRelatedFeatures)throw new t(o,"Layer source does not support queryRelatedFeatures capability");return a.queryRelatedFeatures(u.from(r),s)}async function D(e,r,s,o){const{source:a}=await e.load();if(!a.queryRelatedFeaturesCount)throw new t(o,"Layer source does not support queryRelatedFeaturesCount capability");return a.queryRelatedFeaturesCount(u.from(r),s)}async function G(t){const e=t.source;if(e?.refresh)try{const{dataChanged:s,updates:o}=await e.refresh();if(r(o)&&(t.sourceJSON={...t.sourceJSON,...o},t.read(o,{origin:"service",url:t.parsedUrl})),s)return!0}catch{}if(t.definitionExpression)try{return(await s(t.definitionExpression,t.fieldsIndex)).hasDateFunctions}catch{}return!1}function L(t){const e=new p,r=t.get("capabilities.data"),s=t.get("capabilities.query");e.historicMoment=t.historicMoment,e.gdbVersion=t.gdbVersion,e.returnGeometry=!0,s&&(e.compactGeometryEnabled=s.supportsCompactGeometry,e.defaultSpatialReferenceEnabled=s.supportsDefaultSpatialReference),r&&(r.supportsZ&&null!=t.returnZ&&(e.returnZ=t.returnZ),r.supportsM&&null!=t.returnM&&(e.returnM=t.returnM)),e.outFields=["*"];const{timeOffset:o,timeExtent:a}=t;return e.timeExtent=null!=o&&null!=a?a.offset(-o.value,o.unit):a||null,e.multipatchOption="multipatch"===t.geometryType?"xyFootprint":null,e}function z(t){const{globalIdField:e,fields:r}=t;if(e)return e;if(r)for(const s of r)if("esriFieldTypeGlobalID"===s.type)return s.name}function U(t){const{objectIdField:e,fields:r}=t;if(e)return e;if(r)for(const s of r)if("esriFieldTypeOID"===s.type)return s.name}function B(t){return t.currentVersion?t.currentVersion:t.hasOwnProperty("capabilities")||t.hasOwnProperty("drawingInfo")||t.hasOwnProperty("hasAttachments")||t.hasOwnProperty("htmlPopupType")||t.hasOwnProperty("relationships")||t.hasOwnProperty("timeInfo")||t.hasOwnProperty("typeIdField")||t.hasOwnProperty("types")?10:9.3}export{F as addAttachment,P as applyEdits,L as createQuery,O as deleteAttachments,v as fetchRecomputedExtents,i as geometryTypeKebabDict,h as getFeatureLayerCapabilities,G as hasDataChanged,E as queryAttachments,j as queryExtent,T as queryFeatureCount,I as queryObjectIds,M as queryRelatedFeatures,D as queryRelatedFeaturesCount,z as readGlobalIdField,U as readObjectIdField,B as readVersion,x as updateAttachment};
