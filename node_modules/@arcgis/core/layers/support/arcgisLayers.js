/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import e from"../../core/Error.js";import{isNone as r,isSome as a}from"../../core/maybe.js";import{getFilename as t,urlToObject as s}from"../../core/urlUtils.js";import{parse as n,parseNonStandardSublayerUrl as l}from"./arcgisLayerUrl.js";import{fetchService as o,fetchFeatureService as u}from"./fetchService.js";import{layerLookupMap as y}from"./lazyLayerLoader.js";async function c(e){const r=e.properties?.customParameters,a=await m(e.url,r),t={...e.properties,url:e.url};if(!a.sublayerIds)return null!=a.layerOrTableId&&(t.layerId=a.layerOrTableId,t.sourceJSON=a.sourceJSON),new a.Constructor(t);const s=new(0,(await import("../GroupLayer.js")).default)({title:a.parsedUrl.title});return d(s,a,t),s}function i(e,r){return e?e.find((e=>e.id===r)):null}function d(e,r,t){function s(e,s){const n={...t,layerId:e,sublayerTitleMode:"service-name"};return a(s)&&(n.sourceJSON=s),new r.Constructor(n)}r.sublayerIds.forEach((a=>{const t=s(a,i(r.sublayerInfos,a));e.add(t)})),r.tableIds.forEach((a=>{const t=s(a,i(r.tableInfos,a));e.tables.add(t)}))}async function m(a,t){let s=n(a);if(r(s)&&(s=await f(a,t)),r(s))throw new e("arcgis-layers:url-mismatch","The url '${url}' is not a valid arcgis resource",{url:a});const{serverType:l,sublayer:u}=s;let y;const c={FeatureServer:"FeatureLayer",StreamServer:"StreamLayer",VectorTileServer:"VectorTileLayer"};switch(l){case"MapServer":y=null!=u?"FeatureLayer":b(a,t).then((e=>e?"TileLayer":"MapImageLayer"));break;case"ImageServer":y=o(a,{customParameters:t}).then((e=>{const r=e.tileInfo&&e.tileInfo.format;return e.tileInfo?"LERC"!==r?.toUpperCase()||e.cacheType&&"elevation"!==e.cacheType.toLowerCase()?"ImageryTileLayer":"ElevationLayer":"ImageryLayer"}));break;case"SceneServer":y=o(s.url.path,{customParameters:t}).then((e=>{if(e){if("Voxel"===e?.layerType)return"VoxelLayer";if(e?.layers&&Array.isArray(e.layers)&&e.layers.length>0){const r={Point:"SceneLayer","3DObject":"SceneLayer",IntegratedMesh:"IntegratedMeshLayer",PointCloud:"PointCloudLayer",Building:"BuildingSceneLayer"},a=e.layers[0]?.layerType;if(null!=r[a])return r[a]}}return"SceneLayer"}));break;default:y=c[l]}const i={FeatureLayer:!0,SceneLayer:!0},d="FeatureServer"===l,m={parsedUrl:s,Constructor:null,layerOrTableId:d?u:null,sublayerIds:null,tableIds:null},p=await y;if(i[p]&&null==u){const e=await I(a,l,t);d&&(m.sublayerInfos=e.layerInfos,m.tableInfos=e.tableInfos);1!==e.layerIds.length+e.tableIds.length?(m.sublayerIds=e.layerIds,m.tableIds=e.tableIds):d&&(m.layerOrTableId=e.layerIds[0]??e.tableIds[0],m.sourceJSON=e.layerInfos[0]??e.tableInfos[0])}return m.Constructor=await S(p),m}async function f(e,r){const n=await o(e,{customParameters:r});let u=null,y=null;const c=n.type;if("Feature Layer"===c||"Table"===c?(u="FeatureServer",y=n.id):"indexedVector"===c?u="VectorTileServer":n.hasOwnProperty("mapName")?u="MapServer":n.hasOwnProperty("bandCount")&&n.hasOwnProperty("pixelSizeX")?u="ImageServer":n.hasOwnProperty("maxRecordCount")&&n.hasOwnProperty("allowGeometryUpdates")?u="FeatureServer":n.hasOwnProperty("streamUrls")?u="StreamServer":p(n)?(u="SceneServer",y=n.id):n.hasOwnProperty("layers")&&p(n.layers?.[0])&&(u="SceneServer"),!u)return null;const i=null!=y?l(e):null;return{title:a(i)&&n.name||t(e),serverType:u,sublayer:y,url:{path:a(i)?i.serviceUrl:s(e).path}}}function p(e){return e?.hasOwnProperty("store")&&e.hasOwnProperty("id")&&"number"==typeof e.id}async function I(e,r,a){let t,s=!1;if("FeatureServer"===r){const r=await u(e,{customParameters:a});s=!!r.layersJSON,t=r.layersJSON||r.serviceJSON}else t=await o(e,{customParameters:a});const n=t?.layers,l=t?.tables;return{layerIds:n?.map((e=>e.id)).reverse()||[],tableIds:l?.map((e=>e.id)).reverse()||[],layerInfos:s?n:[],tableInfos:s?l:[]}}async function S(e){return(0,y[e])()}async function b(e,r){return(await o(e,{customParameters:r})).tileInfo}export{c as fromUrl};
