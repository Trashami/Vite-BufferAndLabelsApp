/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{assertIsSome as e}from"../../../core/maybe.js";import{bytesToUTF8 as t}from"../rasterDatasets/byteStreamUtils.js";import{J as n}from"../../../chunks/Jpg.js";import{load as a,decode as i}from"./Lerc.js";import{decode as s}from"./Lzw.js";import r from"./TiffTags.js";import{isPlatformLittleEndian as l}from"./utils.js";import{Z as o}from"../../../chunks/Zlib.js";const f=[0,1,1,2,4,8,1,1,2,4,8,4,8,-1,-1,-1,8,8,8],u=4294967296,c=new Set([1,5,6,7,8,34712,34887]);function h(e,t){let n="unknown";return 3===e?n=64===t?"f64":"f32":1===e?1===t?n="u1":2===t?n="u2":4===t?n="u4":t<=8?n="u8":t<=16?n="u16":t<=32&&(n="u32"):2===e&&(t<=8?n="s8":t<=16?n="s16":t<=32&&(n="s32")),n}function g(e){let t=null;switch(e?e.toLowerCase():"f32"){case"u1":case"u2":case"u4":case"u8":t=Uint8Array;break;case"u16":t=Uint16Array;break;case"u32":t=Uint32Array;break;case"s8":t=Int8Array;break;case"s16":t=Int16Array;break;case"s32":t=Int32Array;break;case"f64":t=Float64Array;break;default:t=Float32Array}return t}function w(e,t){return{x:t[0]*e.x+t[1]*e.y+t[2],y:t[3]*e.x+t[4]*e.y+t[5]}}function p(e,t){return e.get(t)?.values}function d(e,t){return e.get(t)?.values}function I(e,t){return e.get(t)?.values?.[0]}function T(e,t){return e.get(t)?.values?.[0]}function E(e,t,n,a=0,i=r.TIFF_TAGS,s=4){const l=8===s,o=l?L(new DataView(e,n,8),0,t):new DataView(e,n,2).getUint16(0,t),f=4+2*s,u=l?8:2,c=u+o*f;if(n+c>e.byteLength)return{success:!1,ifd:null,nextIFD:null,requiredBufferSize:c};const h=n+c+4<=e.byteLength?k(new DataView(e,n+c,8===s?8:4),0,t,8===s):null,g=n+u,w=new Map;let p,d,I,T,E,y=0,m=0;for(let A=0;A<o;A++){d=new DataView(e,g+f*A,f),I=d.getUint16(0,t),E=d.getUint16(2,t),T=r.getTagName(I,i);const n=[];2===s?(y=d.getUint16(4,t),m=d.getUint16(6,t)):4===s?(y=d.getUint32(4,t),m=d.getUint32(8,t)):8===s&&(y=k(d,4,t,!0),m=k(d,12,t,!0),n.push(d.getUint32(12,t)),n.push(d.getUint32(16,t))),p={id:I,type:E,valueCount:y,valueOffset:m,valueOffsets:n,values:null},b(e,t,p,a,!1,s),w.set(T,p)}return{success:!0,ifd:w,nextIFD:h,requiredBufferSize:c}}const y=(e,t)=>i(e,{inputOffset:t}).pixels[0];async function m(t,i,r,f,u){const c=l===i,w=T(r,"BITSPERSAMPLE"),p=h(T(r,"SAMPLEFORMAT")??1,w),d=T(r,"COMPRESSION")??1,I=g(p);let E,m,A,S,M,x,b;if(34887===d)return await a(),y(t,f);if(1===d)b=t.slice(f,f+u),A=new Uint8Array(b);else if(8===d||32946===d)A=new Uint8Array(t,f,u),M=new o(A),x=M.getBytes(),b=new ArrayBuffer(x.length),A=new Uint8Array(b),A.set(x);else if(6===d){A=new Uint8Array(t,f,u);const e=new n;e.parse(A);const a=e.getData(e.width,e.height,!0);b=new ArrayBuffer(a.length),A=new Uint8Array(b),A.set(a)}else if(7===d){const e=r.get("JPEGTABLES").values,a=e.length-2;A=new Uint8Array(a+u-2);for(let t=0;t<a;t++)A[t]=e[t];const i=new Uint8Array(t,f+2,u-2);for(let t=0;t<i.length;t++)A[a+t]=i[t];const s=new n;s.parse(A);const l=s.getData(s.width,s.height,!0);b=new ArrayBuffer(l.length),A=new Uint8Array(b),A.set(l)}else 5===d&&(A=s(t,f,u,i),b=A.buffer);if("u8"===p||"s8"===p||c)m=new I(b);else{switch(e(A),b=new ArrayBuffer(A.length),S=new Uint8Array(b),p){case"u16":case"s16":for(E=0;E<A.length;E+=2)S[E]=A[E+1],S[E+1]=A[E];break;case"u32":case"s32":case"f32":for(E=0;E<A.length;E+=4)S[E]=A[E+3],S[E+1]=A[E+2],S[E+2]=A[E+1],S[E+3]=A[E]}m=new I(b)}return m}async function A(e,t,n){const a=d(n,"TILEOFFSETS");if(void 0===a)return null;const i=d(n,"TILEBYTECOUNTS"),{width:s,height:r,pixelType:l,tileWidth:o,tileHeight:f}=D([n]),u=O(n,t),c=t.planes,h=s*r,w=T(n,"BITSPERSAMPLE"),p=34887===(T(n,"COMPRESSION")??1),I=g(l),E=[];for(let g=0;g<c;g++)E.push(new I(h));let y,A,S,M,x,b,U,L,P,k,N,G,R;const C=Math.ceil(s/o);if(w%8==0)if(p&&u&&c>1){const l=Math.round(a.length/c);for(y=0;y<l;y++){b=Math.floor(y/C)*f,U=y%C*o,L=b*s+U;for(let l=0;l<c;l++){const u=y*c+l;if(0!==i[u])for(S=await m(e,t.littleEndian,n,a[u],i[u]),k=0,P=L,G=Math.min(o,s-U),N=Math.min(f,r-b),R=E[l],M=0;M<N;M++)for(P=L+M*s,k=M*o,x=0;x<G;x++,P++,k++)R[P]=S[k]}}}else for(y=0;y<a.length;y++)if(0!==i[y])for(b=Math.floor(y/C)*f,U=y%C*o,L=b*s+U,S=await m(e,t.littleEndian,n,a[y],i[y]),k=0,P=L,G=Math.min(o,s-U),N=Math.min(f,r-b),A=0;A<c;A++)if(R=E[A],u||p)for(M=0;M<N;M++)for(P=L+M*s,k=o*f*A+M*o,x=0;x<G;x++,P++,k++)R[P]=S[k];else for(M=0;M<N;M++)for(P=L+M*s,k=M*o*c+A,x=0;x<G;x++,P++,k+=c)R[P]=S[k];return{width:s,height:r,pixelType:l,pixels:E}}const S=(t,a,i)=>{const r=l===a.littleEndian,f=d(i,"STRIPOFFSETS");if(void 0===f)return null;const{width:u,height:c,pixelType:h}=D([i]),w=a.planes,p=u*c,I=T(i,"BITSPERSAMPLE"),E=g(h),y=new E(p*w),m=d(i,"STRIPBYTECOUNTS"),A=T(i,"ROWSPERSTRIP"),S=T(i,"COMPRESSION")??1;let M,x,b,O,U,L,P,k,N,G,R,C=A;if(I%8==0)for(M=0;M<f.length;M++){if(U=M*(A*u)*w,C=(M+1)*A>c?c-M*A:A,"u8"===h||"s8"===h||r){if(8===S||32946===S)P=new Uint8Array(t,f[M],m[M]),G=new o(P),R=G.getBytes(),L=new ArrayBuffer(R.length),P=new Uint8Array(L),P.set(R),P.length!==C*u*w*I/8&&console.log("strip byte counts is different than expected");else if(6===S){P=new Uint8Array(t,f[M],m[M]);const e=new n;e.parse(P);const a=e.getData(e.width,e.height,!0);L=new ArrayBuffer(a.length),P=new Uint8Array(L),P.set(a)}else 5===S?(P=s(t,f[M],m[M],a.littleEndian),L=P.buffer):(m[M]!==C*u*w*I/8&&console.log("strip byte counts is different than expected"),L=t.slice(f[M],f[M]+m[M]));O=new E(L)}else{switch(6===S||8===S||32946===S?(P=new Uint8Array(t,f[M],m[M]),G=new o(P),P=G.getBytes(),L=new ArrayBuffer(P.length),k=new Uint8Array(L),P.length!==C*u*w*I/8&&console.log("strip byte counts is different than expected")):(m[M]!==C*u*w*I/8&&console.log("strip byte counts is different than expected"),L=new ArrayBuffer(m[M]),P=new Uint8Array(t,f[M],m[M]),k=new Uint8Array(L)),h){case"u16":case"s16":for(b=0;b<P.length;b+=2)k[b]=P[b+1],k[b+1]=P[b];break;case"u32":case"s32":case"f32":for(b=0;b<P.length;b+=4)k[b]=P[b+3],k[b+1]=P[b+2],k[b+2]=P[b+1],k[b+3]=P[b]}e(L),O=new E(L)}y.set(O,U)}const F=[];if(1===w)F.push(y);else for(M=0;M<w;M++){for(N=new E(p),x=0;x<p;x++)N[x]=y[x*w+M];F.push(N)}return{width:u,height:c,pixelType:h,pixels:F}},M=(e,t,n)=>{if(!(e&&e.length>0&&t&&n))return null;let a,i,s;const r=e[0].length,l=e.length,o=new Uint8Array(r);for(let f=0;f<l;f++)if(a=e[f],i=t[f],s=n[f],0===f)for(let e=0;e<r;e++)o[e]=a[e]<i||a[e]>s?0:1;else for(let e=0;e<r;e++)o[e]&&(o[e]=a[e]<i||a[e]>s?0:1);return o},x=e=>{if(!e)return null;const t=e.match(/<Item(.*?)Item>/gi);if(!t||0===t.length)return null;const n=new Map;let a,i,s,r,l;for(let I=0;I<t.length;I++)a=t[I],i=a.slice("<Item ".length,a.indexOf(">")),r=a.indexOf("sample="),r>-1&&(l=a.slice(r+'sample="'.length,a.indexOf('"',r+'sample="'.length))),r=a.indexOf("name="),r>-1&&(i=a.slice(r+'name="'.length,a.indexOf('"',r+'name="'.length))),i&&(s=a.slice(a.indexOf(">")+1,a.indexOf("</Item>")).trim(),null!=l?n.has(i)?n.get(i)[l]=s:n.set(i,[s]):n.set(i,s)),l=null;const o=n.get("STATISTICS_MINIMUM"),f=n.get("STATISTICS_MAXIMUM"),u=n.get("STATISTICS_MEAN"),c=n.get("STATISTICS_STDDEV");let h=null;if(o&&f){h=[];for(let e=0;e<o.length;e++)h.push({min:parseFloat(o[e]),max:parseFloat(f[e]),avg:u&&parseFloat(u[e]),stddev:c&&parseFloat(c[e])})}const g=n.get("BandName"),w=n.get("WavelengthMin"),p=n.get("WavelengthMax");let d=null;if(g){d=[];for(let e=0;e<g.length;e++)d.push({BandName:g[e],WavelengthMin:w&&parseFloat(w[e]),WavelengthMax:p&&parseFloat(p[e])})}return{statistics:h,bandProperties:d,dataType:n.get("DataType"),rawMetadata:n}};function b(e,t,n,a=0,i=!1,s=4){if(n.values)return!0;const r=n.type,l=n.valueCount;let o=n.valueOffset,c=[];const h=f[r],g=8*h,w=l*h,p=l*f[r]*8;let d,I;const T=8===s?64:32,E=n.valueOffsets;if(p>T){if(w>(i?e.byteLength:e?e.byteLength-o+a:0))return n.offlineOffsetSize=[o,w],n.values=null,!1}if(p<=T){if(!t)if(T<=32)o>>>=32-p;else{const e=E?.length?E[0]:o>>>0,t=E?.length?E[1]:Math.round((o-e)/u);p<=32?(o=e>>>32-p,E[0]=o):(o=e*2**(32-p)+(t>>>32-p),E[0]=e,E[1]=t>>>32-p)}if(1===l&&g===T)c=[o];else if(64===T){const e=E?.length?E[0]:o>>>0,t=E?.length?E[1]:Math.round((o-e)/u);let n=e,a=32;for(I=1;I<=l;I++){const e=32-g*I%32;if(a<g){const i=n<<e>>>32-a,s=t<<32-a>>>32-a;n=t,c.push(i+s*2**(g-a)),a-=32-(g-a)}else c.push(n<<e>>>32-g),a-=g;0===a&&(a=32,n=t)}}else for(I=1;I<=l;I++){const e=32-g*I;c.push(o<<e>>>32-g)}}else{o-=a,i&&(o=0);for(let n=o;n<o+w;n+=h){switch(r){case 1:case 2:case 7:d=new DataView(e,n,1).getUint8(0);break;case 3:d=new DataView(e,n,2).getUint16(0,t);break;case 4:case 13:d=new DataView(e,n,4).getUint32(0,t);break;case 5:d=new DataView(e,n,4).getUint32(0,t)/new DataView(e,n+4,4).getUint32(0,t);break;case 6:d=new DataView(e,n,1).getInt8(0);break;case 8:d=new DataView(e,n,2).getInt16(0,t);break;case 9:d=new DataView(e,n,4).getInt32(0,t);break;case 10:d=new DataView(e,n,4).getInt32(0,t)/new DataView(e,n+4,4).getInt32(0,t);break;case 11:d=new DataView(e,n,4).getFloat32(0,t);break;case 12:d=new DataView(e,n,8).getFloat64(0,t);break;case 16:case 18:d=L(new DataView(e,n,8),0,t);break;case 17:d=P(new DataView(e,n,8),0,t);break;default:d=null}c.push(d)}}if(2===r){let e="";const t=c;for(c=[],I=0;I<t.length;I++)0===t[I]&&""!==e?(c.push(e),e=""):e+=String.fromCharCode(t[I]);""===e&&0!==c.length||c.push(e)}return n.values=c,!0}function D(e){const t=e[0],n=T(t,"TILEWIDTH"),a=T(t,"TILELENGTH"),i=T(t,"IMAGEWIDTH"),s=T(t,"IMAGELENGTH"),r=T(t,"BITSPERSAMPLE"),l=T(t,"SAMPLESPERPIXEL"),o=T(t,"SAMPLEFORMAT")??1,f=h(o,r),u=O(t),g=p(t,"GDAL_NODATA");let E=null;g?.length&&(E=g.map((e=>parseFloat(e))),E.some((e=>isNaN(e)))&&(E=null));const y=T(t,"COMPRESSION")??1;let m;switch(y){case 1:m="NONE";break;case 2:case 3:case 4:case 32771:m="CCITT";break;case 5:m="LZW";break;case 6:case 7:m="JPEG";break;case 32773:m="PACKBITS";break;case 8:case 32946:m="DEFLATE";break;case 34712:m="JPEG2000";break;case 34887:m="LERC";break;default:m=String(y)}let A=!0,S="";c.has(y)||(A=!1,S+="unsupported tag compression "+y),o>3&&(A=!1,S+="unsupported tag sampleFormat "+o),r%8!=0&&(A=!1,S+="unsupported tag bitsPerSample "+r);const M=I(t,"GEOASCIIPARAMS");let b;if(M){const e=M.split("|").find((e=>e.includes("ESRI PE String = "))),t=e?e.replace("ESRI PE String = ",""):"";b=t.startsWith("COMPD_CS")||t.startsWith("PROJCS")||t.startsWith("GEOGCS")?{wkid:null,wkt:t}:null}const D=d(t,"GEOTIEPOINTS"),U=d(t,"GEOPIXELSCALE"),L=d(t,"GEOTRANSMATRIX"),P=t.has("GEOKEYDIRECTORY")?t.get("GEOKEYDIRECTORY").data:null;let k,N,G=!1;if(P){G=2===T(P,"GTRasterTypeGeoKey");const e=T(P,"GTModelTypeGeoKey");if(2===e){const e=T(P,"GeographicTypeGeoKey");e>=1024&&e<=32766&&(b={wkid:e})}else if(1===e){const e=T(P,"ProjectedCSTypeGeoKey");e>=1024&&e<=32766&&(b={wkid:e})}}if(U&&D&&D.length>=6?(k=[U[0],0,D[3]-D[0]*U[0],0,-Math.abs(U[1]),D[4]-D[1]*U[1]],G&&(k[2]-=.5*k[0]+.5*k[1],k[5]-=.5*k[3]+.5*k[4])):L&&16===L.length&&(k=G?[L[0],L[1],L[3]-.5*L[0],L[4],L[5],L[7]-.5*L[5]]:[L[0],L[1],L[3],L[4],L[5],L[7]]),k){const e=[{x:0,y:s},{x:0,y:0},{x:i,y:s},{x:i,y:0}];let t,n=Number.POSITIVE_INFINITY,a=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY,l=Number.NEGATIVE_INFINITY;for(let i=0;i<e.length;i++)t=w(e[i],k),n=t.x>n?n:t.x,r=t.x<r?r:t.x,a=t.y>a?a:t.y,l=t.y<l?l:t.y;N={xmin:n,xmax:r,ymin:a,ymax:l,spatialReference:b}}else N={xmin:-.5,ymin:.5-s,xmax:i-.5,ymax:.5,spatialReference:b};const C=e.filter((e=>1===I(e,"NEWSUBFILETYPE")));let F,v,B,V,W;if(C.length>0){B=Math.round(Math.log(i/T(C[0],"IMAGEWIDTH"))/Math.LN2);const e=C[C.length-1];V=Math.round(Math.log(i/T(e,"IMAGEWIDTH"))/Math.LN2),F=T(e,"TILEWIDTH"),v=T(e,"TILELENGTH")}F=null!=V&&V>0?F||n:null,v=null!=V&&V>0?v||a:null,n&&(W=[{maxCol:Math.ceil(i/n)-1,maxRow:Math.ceil(s/a)-1,minRow:0,minCol:0}],C.forEach((e=>{W.push({maxCol:Math.ceil(T(e,"IMAGEWIDTH")/T(e,"TILEWIDTH"))-1,maxRow:Math.ceil(T(e,"IMAGELENGTH")/T(e,"TILELENGTH"))-1,minRow:0,minCol:0})})));const H=I(e[0],"GDAL_METADATA"),Y=x(H);return S+=" "+R({width:i,height:s,tileWidth:n,tileHeight:a,planes:l,ifds:e}),{width:i,height:s,tileWidth:n,tileHeight:a,planes:l,isBSQ:u,pixelType:f,compression:m,noData:E,isSupported:A,message:S,extent:N,affine:U?null:k,firstPyramidLevel:B,maximumPyramidLevel:V,pyramidBlockWidth:F,pyramidBlockHeight:v,tileBoundary:W,metadata:Y}}function O(e,t){const n=p(e,"PLANARCONFIGURATION");return n?2===n[0]:!!t&&t.isBSQ}function U(e){const{littleEndian:t,isBigTiff:n,firstIFDPos:a}=N(e);let i=a;const s=[];do{const a=G(e,t,i,0,r.TIFF_TAGS,n?8:4);if(!a.success)break;s.push(a.ifd),i=a.nextIFD}while(i>0);return{...D(s),littleEndian:t,isBigTiff:n,ifds:s}}function L(e,t,n){const a=e.getUint32(t,n),i=e.getUint32(t+4,n);return n?i*u+a:a*u+i}function P(e,t,n){let a=n?e.getInt32(t,n):e.getUint32(t,n),i=n?e.getUint32(t+4,n):e.getInt32(t+4,n);const s=(n?a:i)>=0?1:-1;n?a*=s:i*=s;return s*(n?i*u+a:a*u+i)}function k(e,t,n,a){return a?L(e,t,n):e.getUint32(t,n)}function N(e){const t=new DataView(e,0,16),n=t.getUint16(0,!1);let a=null;if(18761===n)a=!0;else{if(19789!==n)throw"unexpected endianess byte";a=!1}const i=t.getUint16(2,a);if(42!==i&&43!==i)throw"unexpected tiff identifier";let s=4;const r=43===i;if(r){const e=t.getUint16(s,a);if(s+=2,8!==e)throw"unsupported bigtiff version";if(0!==t.getUint16(s,a))throw"unsupported bigtiff version";s+=2}return{littleEndian:a,isBigTiff:r,firstIFDPos:k(t,s,a,r)}}function G(e,n,a,i=0,s=r.TIFF_TAGS,l=4){const o=E(e,n,a,i,s,l);let f;const u=o.ifd;if(u){if(r.ifdTags.forEach(((t,a)=>{u.has(a)&&(f=u.get(a),f.data=E(e,n,f.valueOffset-i,i,t).ifd)})),u.has("GEOKEYDIRECTORY")){f=u.get("GEOKEYDIRECTORY");const t=f.values;if(t&&t.length>4){const a=t[0]+"."+t[1]+"."+t[2];f.data=E(e,n,f.valueOffset+6-i,i,r.GEO_KEYS,2).ifd,f.data&&f.data.set("GEOTIFFVersion",{id:0,type:2,valueCount:1,valueOffset:null,values:[a]})}}if(u.has("XMP")){f=u.get("XMP");const e=f.values;"number"==typeof e[0]&&7===f.type&&(f.values=[t(new Uint8Array(e))])}}return o}function R(e){const{width:t,height:n,tileHeight:a,tileWidth:i}=e,s=e.planes,r=i?i*a:t*n,l=T(e.ifds[0],"BITSPERSAMPLE");let o="";return r*s>2**30/(l>8?l/8:1)&&(o=i?"tiled tiff exceeding 1 gigabits per tile is not supported":"scanline tiff exceeding 1 gigabits is not supported"),o}async function C(e,t){const{headerInfo:n,ifd:a,offsets:i,sizes:s}=t,r=[];for(let g=0;g<i.length;g++){const t=await m(e,n.littleEndian,a,i[g],s[g]||e.byteLength);r.push(t)}const l=O(a,n),{pixelType:o,planes:f}=n,u=g(o),c=T(a,"TILEWIDTH"),h=T(a,"TILELENGTH"),w=T(a,"COMPRESSION")??1,p=c*h;let d;const I=[];let E=r[0];const y=34887===w;for(let g=0;g<f;g++){if(d=new u(p),l&&y){if(E=r[g],E.length)for(let e=0;e<p;e++)d[e]=E[g][e+g]}else if(E.length)if(l||y&&!l)d=E.slice(p*g,p*(g+1));else for(let e=0;e<p;e++)d[e]=E[e*f+g];I.push(d)}const A=n.noData?n.noData[0]:t.noDataValue,S=n.metadata?n.metadata.statistics:null,x=S?S.map((e=>e.min)):null,b=S?S.map((e=>e.max)):null;let D,U=null;if(null!=A)if(U=new Uint8Array(p),Math.abs(A)>1e24)for(D=0;D<p;D++)Math.abs((I[0][D]-A)/A)<1e-6?U[D]=0:U[D]=1;else for(D=0;D<p;D++)I[0][D]===A?U[D]=0:U[D]=1;else x&&b&&t.applyMinMaxConstraint&&(U=M(I,x,b));return{pixelType:o,width:c,height:h,pixels:I,mask:U,noDataValue:A}}async function F(t,n={}){const a=n.pyramidLevel||0,i=n.headerInfo||U(t),{ifds:s,noData:r}=i;if(0===s.length)throw"no valid image file directory";const l=R(i);if(l)throw l;let o,f=null;const u=-1===a?s[s.length-1]:s[a],c=r?r[0]:n.noDataValue;if(f=i.tileWidth?await A(t,i,u):await S(t,i,u),null!=c){if(e(f),f.mask=new Uint8Array(f.width*f.height),Math.abs(c)>1e24)for(o=0;o<f.width*f.height;o++)Math.abs((f.pixels[0][o]-c)/c)<1e-6?f.mask[o]=0:f.mask[o]=1;else for(o=0;o<f.width*f.height;o++)f.pixels[0][o]===c?f.mask[o]=0:f.mask[o]=1;f.noDataValue=c}return f}export{F as decode,C as decodeTileOrStrip,D as getImageInfo,O as isBSQConfig,b as parseFieldValues,U as parseHeader,G as parseIFD,N as parseSignature};
