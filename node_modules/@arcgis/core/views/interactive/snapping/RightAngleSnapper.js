/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{unwrap as e}from"../../../core/maybe.js";import{a as t,h as r,v as i,w as s}from"../../../chunks/vec2.js";import{a as o}from"../../../chunks/vec2f64.js";import{s as n,z as h}from"../../../chunks/vec3.js";import{c}from"../../../chunks/vec3f64.js";import{absoluteHeightElevationInfo as d}from"../../../support/elevationInfoUtils.js";import{SnappingAlgorithm as a}from"./SnappingAlgorithm.js";import{VerticalHalfPlaneConstraint as g}from"./SnappingConstraint.js";import{convertPointElevation as p,editEdgeToSnappingEdge as f,squaredScreenDistance as l}from"./snappingUtils.js";import{RightAngleSnappingCandidate as m,OtherVertexType as x}from"./candidates/RightAngleSnappingCandidate.js";import{anyMapPointToScreenPoint as E}from"../support/viewUtils.js";class v extends a{snapNewVertex(e,t){const r=t.editGeometryOperations.data.components[0],i=r.vertices.length,s=[];if(i<2)return s;const{view:o}=this,n=E(e,t.coordinateHelper,d,o),h=r.vertices[i-1];if(this.edgeExceedsShortLineThreshold(h.leftEdge,t)){const r=p(h.pos,o,t),i=f(h.leftEdge,o,t);this._checkForSnappingCandidate(s,i,r,e,i.left,r,t,e,n)}const c=r.vertices[0];if(this.edgeExceedsShortLineThreshold(c.rightEdge,t)){const r=p(c.pos,o,t),i=f(c.rightEdge,o,t);this._checkForSnappingCandidate(s,i,r,e,i.right,r,t,e,n)}return s}snapExistingVertex(t,r){const i=[],s=e(r.vertexHandle),o=s.component,n=o.vertices.length;if(n<3)return i;const{view:h}=this,c=E(t,r.coordinateHelper,d,h),a=s.leftEdge,g=s.rightEdge,l=o.vertices[0],m=o.vertices[n-1];if(!a){const e=l.rightEdge.rightVertex.rightEdge;if(this.edgeExceedsShortLineThreshold(e,r)){const s=f(e,h,r),o=p(l.rightEdge.rightVertex.pos,h,r);this._checkForSnappingCandidate(i,s,o,t,s.right,o,r,t,c)}return i}if(!g){const e=m.leftEdge.leftVertex.leftEdge;if(this.edgeExceedsShortLineThreshold(e,r)){const s=f(e,h,r),o=p(m.leftEdge.leftVertex.pos,h,r);this._checkForSnappingCandidate(i,s,o,t,s.left,o,r,t,c)}return i}if(a&&a.leftVertex.leftEdge){const e=a.leftVertex.leftEdge;if(this.edgeExceedsShortLineThreshold(e,r)){const s=f(e,h,r),o=p(a.leftVertex.pos,h,r);this._checkForSnappingCandidate(i,s,o,t,s.left,o,r,t,c)}}if(g&&g.rightVertex.rightEdge){const e=g.rightVertex.rightEdge;if(this.edgeExceedsShortLineThreshold(e,r)){const s=f(e,h,r),o=p(g.rightVertex.pos,h,r);this._checkForSnappingCandidate(i,s,o,t,s.right,o,r,t,c)}}return i}_checkForSnappingCandidate(e,o,c,a,p,f,v,k,C){const{coordinateHelper:T,pointer:w}=v;t(u,o.right,o.left);const F=n(j,u[1],-u[0],0),_=r(F,t(u,a,c))/i(F),L=T.fromXYZ(s(u,f,F,_),T.getZ(k,0));if(l(C,E(L,T,d,this.view))<this.squaredProximityThreshold(w)){const t=T.toXYZ(f,S),r=h(V,t,F,Math.sign(_)),i=T.fromXYZ(r);e.push(new m({coordinateHelper:T,targetPoint:L,constraint:new g(T,f,i),previousVertex:p,otherVertex:f,otherVertexType:x.CENTER,elevationInfo:T.hasZ()?d:null}))}}}const u=o(),S=c(),V=c(),j=c();export{v as RightAngleSnapper};
