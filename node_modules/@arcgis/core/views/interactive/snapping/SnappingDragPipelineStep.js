/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{isNone as e,isSome as t,abortMaybe as n}from"../../../core/maybe.js";import{ignoreAbortErrors as a,debounce as o}from"../../../core/promiseUtils.js";import{pointEquals as i}from"../../../layers/graphics/dehydratedFeatureComparison.js";import{clonePoint as r}from"../../../layers/graphics/hydratedFeatures.js";import{EventPipeline as s}from"../dragEventPipeline.js";import{SnappingContext as p}from"./SnappingContext.js";import{TaskPriority as l,ImmediateTask as c}from"../../support/Scheduler.js";class u{constructor(){this.next=new s}createSnapDragEventPipelineStep({predicate:o=(()=>!0),cancel:i,snappingManager:r,snappingContext:p,updatingHandles:l,useZ:c=!0}){if(e(r))return e=>e;let u=null,d=null;const f=()=>{u=n(u),r.doneSnapping(),t(d)&&d.frameTask.remove(),d=null};i.next((e=>(f(),e))),this.next=new s;const m=this._createSnapFunction(r,c);let h=null,S=null,x=null;return n=>{if(!o(n))return n;if("start"===n.action){const e=this._createFrameTask(r.view);if(d=this._createSnappingInfo(p,n,e),d.context.selfSnappingZ=null,!c&&t(n.info)){const e=this._extractSelfSnappingZ(p.coordinateHelper,n.info.handle.component);t(e)&&(d.context.selfSnappingZ={value:e,elevationInfo:p.elevationInfo})}}if(t(d)){const{context:t,originalScenePos:o,originalPos:i}=d,{mapEnd:s,mapStart:p,action:f,scenePoints:P}=n,g=this._updatePosition(i,this._computeMapDelta(s,p)),_=this._computeMapDelta(p,i),y={...n,action:"update"},v=d.context,Z=this._updateScenePosition(o,P),T=r.update({point:g,scenePoint:Z,context:t});if(x=T,this._applySnappedUpdate(s,T,_,c),h=g,S=Z,"end"!==f){const{frameTask:t}=d;e(u)&&(u=new AbortController),l.addPromise(a(m({frameTask:t,event:y,context:v,point:g,scenePoint:Z,delta:_,lastPos:h,lastScenePos:S,lastUpdate:x},u.signal)))}}return"end"===n.action&&f(),n}}_createSnapFunction(e,n){return o((async({frameTask:a,point:o,scenePoint:r,context:s,event:p,delta:l,lastPos:c,lastScenePos:u,lastUpdate:d},f)=>{const m=await a.schedule((()=>e.snap({point:o,scenePoint:r,context:s,signal:f})),f);if(m.valid){let r=await a.schedule((()=>m.apply()),f);o!==c&&t(c)&&(r=e.update({point:c,scenePoint:u,context:s})),i(r,d)||(this._applySnappedUpdate(p.mapEnd,r,l,n),this.next.execute(p))}}))}_createFrameTask(e){return"3d"===e.type?e.resourceController.scheduler.registerTask(l.SNAPPING):c}_createSnappingInfo(e,n,a){return{context:new p({editGeometryOperations:e.editGeometryOperations,elevationInfo:e.elevationInfo,pointer:e.pointer,vertexHandle:t(n.info)?n.info.handle:null,excludeFeature:e.excludeFeature,visualizer:e.visualizer}),originalPos:t(n.snapOrigin)?e.coordinateHelper.vectorToDehydratedPoint(n.snapOrigin):n.mapStart,originalScenePos:t(n.scenePoints)?n.scenePoints.sceneStart:null,frameTask:a}}_updatePosition(e,[t,n,a]){const o=r(e);return o.x+=t,o.y+=n,o.hasZ&&(o.z+=a),o}_updateScenePosition(t,n){return e(t)||e(n)?null:this._updatePosition(t,this._computeMapDelta(n.sceneEnd,n.sceneStart))}_computeMapDelta(e,t){const n=e.hasZ&&t.hasZ?e.z-t.z:0;return[e.x-t.x,e.y-t.y,n]}_applySnappedUpdate(e,t,[n,a,o],i){e.x=t.x+n,e.y=t.y+a,i&&e.hasZ&&t.hasZ&&(e.z=t.z+o)}_extractSelfSnappingZ(n,a){if(!n.hasZ())return null;const o=a.vertices;let i=null;for(const r of o){const a=n.getZ(r.pos);if(t(i)&&Math.abs(a-i)>1e-6)return null;e(i)&&(i=a)}return i}}export{u as SnappingPipeline};
