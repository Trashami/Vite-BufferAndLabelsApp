/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../../chunks/tslib.es6.js";import{isNone as t,unwrapOr as s}from"../../../../../core/maybe.js";import{throwIfAborted as o}from"../../../../../core/promiseUtils.js";import"../../../../../core/Logger.js";import"../../../../../core/accessorSupport/ensureType.js";import"../../../../../core/arrayUtils.js";import"../../../../../core/Error.js";import"../../../../../core/has.js";import{subclass as n}from"../../../../../core/accessorSupport/decorators/subclass.js";import{a as i,i as r}from"../../../../../chunks/vec3.js";import{c as d,a as c}from"../../../../../chunks/vec3f64.js";import{create as a,fromPoints as p,projectPoint as m}from"../../../../../geometry/support/lineSegment.js";import{g as u,m as h}from"../../../../../chunks/sphere.js";import{SnappingTypes as g}from"../../../../../layers/graphics/data/QueryEngineResult.js";import l from"../../../../3d/webgl-engine/lib/Octree.js";import{extractComponentsEdgeLocationsLayout as f}from"../../../../3d/webgl-engine/lib/edgeRendering/edgeProcessing.js";import{MAX_CANDIDATE_COUNT as _,boundsFromEdge as b}from"./sceneLayerSnappingUtils.js";let j=class{constructor(){this._idToComponent=new Map,this._components=new l((e=>e.bounds)),this._edges=new l((e=>e.bounds)),this._tmpLineSegment=a(),this._tmpP1=d(),this._tmpP2=d(),this._tmpP3=d(),this.remoteClient=null}async fetchCandidates(e,t){await Promise.resolve(),o(t),await this._ensureEdgeLocations(e,t);const s=[];return this._edges.forEachNeighbor((t=>(this._addCandidates(e,t,s),s.length<_)),e.bounds),{result:{candidates:s}}}async _ensureEdgeLocations(e,o){const n=[];if(this._components.forEachNeighbor((e=>{if(t(e.info)){const{id:t,uid:s}=e;n.push({id:t,uid:s})}return!0}),e.bounds),!n.length)return;const i={components:n},r=await this.remoteClient.invoke("fetchAllEdgeLocations",i,s(o,{}));for(const t of r.components)this._setFetchEdgeLocations(t)}async add(e){const t=new E(e.id,e.bounds);return this._idToComponent.set(t.id,t),this._components.add([t]),{result:{}}}async remove(e){const t=this._idToComponent.get(e.id);if(t){const e=[];this._edges.forEachNeighbor((s=>(s.component===t&&e.push(s),!0)),t.bounds),this._edges.remove(e),this._components.remove([t]),this._idToComponent.delete(t.id)}return{result:{}}}_setFetchEdgeLocations(e){const s=this._idToComponent.get(e.id);if(t(s)||e.uid!==s.uid)return;const o=f.createView(e.locations),n=new Array(o.count),i=d(),r=d();for(let t=0;t<o.count;t++){o.position0.getVec(t,i),o.position1.getVec(t,r);const d=b(i,r,e.origin),c=new C(s,t,d);n[t]=c}this._edges.add(n);const{objectIds:c,origin:a}=e;s.info={locations:o,objectIds:c,origin:a}}_addCandidates(e,t,s){const{locations:o,origin:n,objectIds:r}=t.component.info,d=o.position0.getVec(t.index,this._tmpP1),c=o.position1.getVec(t.index,this._tmpP2);i(d,d,n),i(c,c,n);const a=r[o.componentIndex.get(t.index)];this._addEdgeCandidate(e,a,d,c,s),this._addVertexCandidate(e,a,d,s),this._addVertexCandidate(e,a,c,s)}_addEdgeCandidate(e,t,s,o,n){if(!(e.types&g.EDGE))return;const i=u(e.bounds),d=p(s,o,this._tmpLineSegment),a=m(d,i,this._tmpP3);if(!h(e.bounds,a))return null;n.push({type:"edge",objectId:t,target:c(a),distance:r(i,a),start:c(s),end:c(o)})}_addVertexCandidate(e,t,s,o){if(!(e.types&g.VERTEX))return;const n=u(e.bounds);if(!h(e.bounds,s))return null;o.push({type:"vertex",objectId:t,target:c(s),distance:r(n,s)})}};j=e([n("esri.views.interactive.snapping.featureSources.sceneLayerSource.SceneLayerSnappingSourceWorker")],j);const y=j;class E{constructor(e,t){this.id=e,this.bounds=t,this.info=null,this.uid=++E.uid}}E.uid=0;class C{constructor(e,t,s){this.component=e,this.index=t,this.bounds=s}}export{y as default};
