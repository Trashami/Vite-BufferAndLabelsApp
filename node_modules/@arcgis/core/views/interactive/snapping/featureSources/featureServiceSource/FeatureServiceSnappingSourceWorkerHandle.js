/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../../chunks/tslib.es6.js";import{HandleOwner as t}from"../../../../../core/HandleOwner.js";import{isNone as i,isSome as o}from"../../../../../core/maybe.js";import{whenOrAbort as a}from"../../../../../core/promiseUtils.js";import{property as n}from"../../../../../core/accessorSupport/decorators/property.js";import"../../../../../core/arrayUtils.js";import"../../../../../core/accessorSupport/ensureType.js";import{subclass as r}from"../../../../../core/accessorSupport/decorators/subclass.js";import{WorkerHandle as s}from"../../../../../core/workers/WorkerHandle.js";import{featureGeometryTypeKebabDictionary as d}from"../../../../../geometry/support/typeUtils.js";let l=class extends t{constructor(e){super(e),this.schedule=null,this.hasZ=!1,this.elevationAlignPointsInFeatures=async e=>{const t=[];for(const{points:i}of e)for(const{z:e}of i)t.push(e);return{elevations:t,drapedObjectIds:new Set,failedObjectIds:new Set}},this.queryForSymbologySnapping=async()=>({candidates:[],sourceCandidateIndices:[]}),this.availability=0,this._workerHandleUpdating=!0,this._editId=0}get updating(){return this.updatingHandles.updating||this._workerHandleUpdating}destroy(){this._workerHandle.destroy()}initialize(){this._workerHandle=new p(this.schedule,{alignElevation:async(e,{signal:t})=>({result:await this.elevationAlignPointsInFeatures(e.points,t)}),getSymbologyCandidates:async(e,{signal:t})=>({result:await this.queryForSymbologySnapping(e,t)})}),this.handles.add([this._workerHandle.on("notify-updating",(({updating:e})=>this._workerHandleUpdating=e)),this._workerHandle.on("notify-availability",(({availability:e})=>this._set("availability",e)))])}async setup(e,t){const o=this._serviceInfoFromLayer(e.layer);if(i(o))return;const a={configuration:this._convertConfiguration(e.configuration),serviceInfo:o,spatialReference:e.spatialReference.toJSON(),hasZ:this.hasZ,elevationInfo:e.layer.elevationInfo?.toJSON()};await this.updatingHandles.addPromise(this._workerHandle.invokeMethod("setup",a,t)),this.updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating",{},t))}async configure(e,t){const i=this._convertConfiguration(e);await this.updatingHandles.addPromise(this._workerHandle.invokeMethod("configure",i,t)),this.updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating",{},t))}async refresh(e){await this.updatingHandles.addPromise(this._workerHandle.invokeMethod("refresh",{},e)),this.updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating",{},e))}async fetchCandidates(e,t){const i={distance:e.distance,point:e.coordinateHelper.vectorToPoint(e.point).toJSON(),types:e.types,filter:o(e.filter)?e.filter.toJSON():null};return this._workerHandle.invoke(i,t)}async updateTiles(e,t){const i={tiles:e.tiles,tileInfo:o(e.tileInfo)?e.tileInfo.toJSON():null,tileSize:e.tileSize};await this.updatingHandles.addPromise(this._workerHandle.invokeMethod("updateTiles",i,t)),this.updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating",{},t))}async applyEdits(e,t){const i=this._editId++,n={id:i};await this.updatingHandles.addPromise(this._workerHandle.invokeMethod("beginApplyEdits",n,t));const r=await this.updatingHandles.addPromise(a(e.result,t)),s={id:i,edits:{addedFeatures:r.addedFeatures?.map((({objectId:e})=>e)).filter(o)??[],deletedFeatures:r.deletedFeatures?.map((({objectId:e,globalId:t})=>({objectId:e,globalId:t})))??[],updatedFeatures:r.updatedFeatures?.map((({objectId:e})=>e)).filter(o)??[]}};await this.updatingHandles.addPromise(this._workerHandle.invokeMethod("endApplyEdits",s,t)),this.updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating",{},t))}getDebugInfo(e){return this._workerHandle.invokeMethod("getDebugInfo",{},e)}async notifyElevationSourceChange(){await this._workerHandle.invokeMethod("notifyElevationSourceChange",{})}async notifySymbologyChange(){await this._workerHandle.invokeMethod("notifySymbologyChange",{})}async setSymbologySnappingSupported(e){await this._workerHandle.invokeMethod("setSymbologySnappingSupported",e)}_convertConfiguration(e){return{filter:o(e.filter)?e.filter.toJSON():null,customParameters:e.customParameters,viewType:e.viewType}}_serviceInfoFromLayer(e){return"multipatch"===e.geometryType||"mesh"===e.geometryType?null:{url:e.parsedUrl?.path??"",fields:e.fields.map((e=>e.toJSON())),geometryType:d.toJSON(e.geometryType),capabilities:e.capabilities,objectIdField:e.objectIdField,globalIdField:e.globalIdField,spatialReference:e.spatialReference.toJSON(),timeInfo:e.timeInfo?.toJSON()}}};e([n({constructOnly:!0})],l.prototype,"schedule",void 0),e([n({constructOnly:!0})],l.prototype,"hasZ",void 0),e([n({constructOnly:!0})],l.prototype,"elevationAlignPointsInFeatures",void 0),e([n({constructOnly:!0})],l.prototype,"queryForSymbologySnapping",void 0),e([n({readOnly:!0})],l.prototype,"updating",null),e([n({readOnly:!0})],l.prototype,"availability",void 0),e([n()],l.prototype,"_workerHandleUpdating",void 0),l=e([r("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceSnappingSourceWorkerHandle")],l);class p extends s{constructor(e,t){super("FeatureServiceSnappingSourceWorker","fetchCandidates",{},e,{strategy:"dedicated",client:t})}}export{l as FeatureServiceSnappingSourceWorkerHandle};
