/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{_ as t}from"../../../chunks/tslib.es6.js";import e from"../../../core/Evented.js";import{HandleOwner as n}from"../../../core/HandleOwner.js";import{clone as i}from"../../../core/lang.js";import{isNone as s,isSome as r}from"../../../core/maybe.js";import{isAborted as o}from"../../../core/promiseUtils.js";import{watch as a,sync as c,syncAndInitial as p}from"../../../core/reactiveUtils.js";import{property as d}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/accessorSupport/ensureType.js";import{subclass as h}from"../../../core/accessorSupport/decorators/subclass.js";import{project as l,initializeProjection as u}from"../../../geometry/projection.js";import{absoluteHeightElevationInfo as f,getConvertedElevation as _}from"../../../support/elevationInfoUtils.js";import{SnappingDomain as g}from"./SnappingDomain.js";import{defaultSnappingEnginesFactory as v}from"./snappingFactory.js";import S from"./SnappingOptions.js";import{sortCandidatesInPlace as m,squaredScreenDistance as y}from"./snappingUtils.js";import{IntersectionSnappingCandidate as P}from"./candidates/IntersectionSnappingCandidate.js";import{anyMapPointToScreenPoint as C}from"../support/viewUtils.js";let E=class extends(e.EventedMixin(n)){constructor(t){super(t),this.options=new S,this.snappingEnginesFactory=v,this._engines=[],this._currentMainCandidate=null,this._currentOtherActiveCandidates=[],this._currentSnappedType=T.MAIN}initialize(){this.handles.add([a((()=>{const{effectiveFeatureEnabled:t,effectiveSelfEnabled:e,touchSensitivityMultiplier:n,distance:i}=this.options;return{effectiveFeatureEnabled:t,effectiveSelfEnabled:e,touchSensitivityMultiplier:n,distance:i}}),(()=>{this.doneSnapping(),this.emit("changed")}),c),a((()=>this.options),(t=>{for(const e of this._engines)e.options=t}),c),a((()=>({viewReady:this.view.ready,viewSpatialReference:this.view.spatialReference,snappingEnginesFactory:this.snappingEnginesFactory})),(({viewReady:t,snappingEnginesFactory:e})=>this._recreateEngines(t,e)),p)])}destroy(){this._destroyEngines()}get updating(){return this._engines.some((t=>t.updating))}_recreateEngines(t,e){if(this._destroyEngines(),!t)return;const{view:n,options:i}=this;this._engines=e(n,i)}_destroyEngines(){for(const t of this._engines)t.destroy();this._engines=[]}get _squaredMouseProximityTreshold(){return this.options.distance*this.options.distance}get _squaredTouchProximityThreshold(){const{distance:t,touchSensitivityMultiplier:e}=this.options,n=t*e;return n*n}async snap(t){return I(t)?this._snapMultiPoint(t):this._snapSinglePoint(t)}update(t){const{point:e,context:n}=t;this._removeVisualization();const i=this._currentMainCandidate;if(s(i))return e;const o=this._selectUpdateInput(t);if(s(o))return e;const{coordinateHelper:{spatialReference:a}}=n,c=l(this._convertPointElevation(o,n),a);if(s(c))return e;const{view:p}=this,{coordinateHelper:d,elevationInfo:h,visualizer:u}=n,_=[],g=d.pointToVector(c),v=i.constraint.closestTo(g);if(!this._arePointsWithinScreenThreshold(g,v,n))return this._resetSnappingState(),e;i.targetPoint=v,_.push(...i.hints);for(const s of this._currentOtherActiveCandidates)s.targetPoint=v,_.push(...s.hints);r(u)&&this.handles.add(u.draw(_,{coordinateHelper:d,elevationInfo:M(n),view:p,selfSnappingZ:n.selfSnappingZ}),w);const S=d.vectorToDehydratedPoint(v);return this._convertPointElevation(S,n,f,h)}doneSnapping(){this._removeVisualization(),this._resetSnappingState()}_selectUpdateInput({point:t,scenePoint:e}){switch(this._currentSnappedType){case T.MAIN:return t;case T.SCENE:return e}}_resetSnappingState(){this._currentMainCandidate=null,this._currentOtherActiveCandidates=[],this._currentSnappedType=T.MAIN}_removeVisualization(){this.handles.remove(w)}async _snapSinglePoint({point:t,context:e,signal:n}){const{coordinateHelper:i}=e,{view:s}=this,r=this._convertPointElevation(t,e),o=i.pointToVector(r),a=await this._fetchCandidates(o,g.ALL,e,n);return this._createSnapResult(o,T.MAIN,a,s,e,n)}async _snapMultiPoint({point:t,scenePoint:e,context:n,signal:i}){const{view:s}=this,{coordinateHelper:r}=n,{spatialReference:o}=r;await u(e.spatialReference,o);const a=l(this._convertPointElevation(e,n),o),c=r.pointToVector(a),p=await this._fetchCandidates(c,g.FEATURE,n,i);if(p.length>0){const t=await this._fetchCandidates(c,g.SELF,n,i);return this._createSnapResult(c,T.SCENE,[...p,...t],s,n,i)}const d=this._convertPointElevation(t,n),h=r.pointToVector(d),f=await this._fetchCandidates(h,g.SELF,n,i);return this._createSnapResult(h,T.MAIN,f,s,n,i)}async _fetchCandidates(t,e,n,i){return(await Promise.all(this._engines.map((s=>s.fetchCandidates(t,e,n,i))))).flat()}_createSnapResult(t,e,n,i,s,a){return{get valid(){return!o(a)},apply:()=>{const{elevationInfo:o,coordinateHelper:a}=s,{snappedPoint:c,hints:p}=this._processCandidates(t,e,n,s);return this._removeVisualization(),r(s.visualizer)&&this.handles.add(s.visualizer.draw(p,{coordinateHelper:a,elevationInfo:M(s),view:i,selfSnappingZ:s.selfSnappingZ}),w),this._convertPointElevation(c,s,f,o)}}}_processCandidates(t,e,n,i){const{coordinateHelper:s}=i;if(n.length<1)return this.doneSnapping(),{snappedPoint:s.vectorToDehydratedPoint(t),hints:[]};this._currentSnappedType!==e&&this._resetSnappingState(),m(t,n,s);const o=this._currentMainCandidate;if(r(o)){const s=this._findOldConstraintInNewCandidates(o,n);if(s>=0){if(!(n[s]instanceof P))return this._intersectWithOtherCandidates(s,n,t,e,i);if(this._arePointsWithinScreenThreshold(t,o.targetPoint,i))return this._updateSnappingCandidate(o,e,n,i)}}return this._intersectWithOtherCandidates(0,n,t,e,i)}_findOldConstraintInNewCandidates(t,e){return t instanceof P?this._findOldCandidateIndex(e,t.first)>=0&&this._findOldCandidateIndex(e,t.second)>=0?0:-1:this._findOldCandidateIndex(e,t)}_intersectWithOtherCandidates(t,e,n,i,s){const{coordinateHelper:r}=s,o=e[t],a=[];for(let c=0;c<e.length;++c){if(c===t)continue;const i=e[c];for(const t of o.constraint.intersect(i.constraint)){const e=r.fromXYZ(t.closestTo(o.targetPoint),o.targetPoint[2]);a.push([new P(r,e,o,i,i.elevationInfo),this._squaredScreenDistance(n,e,r)])}}return a.length>0&&(a.sort(((t,e)=>t[1]-e[1])),a[0][1]<this._squaredPointProximityThreshold(s.pointer))?this._updateSnappingCandidate(a[0][0],i,e,s):this._updateSnappingCandidate(o,i,e,s)}_updateSnappingCandidate(t,e,n,i){this.doneSnapping(),this._currentMainCandidate=t,this._currentSnappedType=e;const s=this._currentMainCandidate.targetPoint,r=[];r.push(...t.hints);for(const o of n){if(t instanceof P){if(o.constraint.equals(t.first.constraint)||o.constraint.equals(t.second.constraint))continue}else if(o.constraint.equals(t.constraint))continue;o.constraint.check(s)&&(o.targetPoint=s,this._currentOtherActiveCandidates.push(o),r.push(...o.hints))}return{snappedPoint:i.coordinateHelper.vectorToDehydratedPoint(s),hints:r}}_squaredPointProximityThreshold(t){return"touch"===t?this._squaredTouchProximityThreshold:this._squaredMouseProximityTreshold}_arePointsWithinScreenThreshold(t,e,n){return this._squaredScreenDistance(t,e,n.coordinateHelper)<this._squaredPointProximityThreshold(n.pointer)}_squaredScreenDistance(t,e,n){return y(this._toScreen(t,n),this._toScreen(e,n))}_toScreen(t,e){return C(t,e,f,this.view)}_findOldCandidateIndex(t,e){let n=-1;for(let i=0;i<t.length;++i)if(e.constraint.equals(t[i].constraint)){n=i;break}return n}_convertPointElevation(t,e,n=e.elevationInfo,s=f){const{view:o}=this;if(!(r(t)&&e.coordinateHelper.hasZ()&&r(o)&&"3d"===o.type))return t;const a=i(t);return a.z=_(o,a,n,s),a}get test(){return{visualizationsActive:this.handles.has(w),engines:this._engines}}};var T;t([d({constructOnly:!0})],E.prototype,"view",void 0),t([d()],E.prototype,"options",void 0),t([d({readOnly:!0})],E.prototype,"updating",null),t([d()],E.prototype,"snappingEnginesFactory",void 0),t([d()],E.prototype,"_engines",void 0),t([d()],E.prototype,"_squaredMouseProximityTreshold",null),t([d()],E.prototype,"_squaredTouchProximityThreshold",null),E=t([h("esri.views.interactive.snapping.SnappingManager")],E),function(t){t[t.MAIN=0]="MAIN",t[t.SCENE=1]="SCENE"}(T||(T={}));const w="visualization-handle";function I(t){return r(t.scenePoint)}function M({coordinateHelper:t,elevationInfo:e}){return t.hasZ()?f:e}export{E as SnappingManager};
