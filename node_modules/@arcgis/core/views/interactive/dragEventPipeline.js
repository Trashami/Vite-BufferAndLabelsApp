/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import"../../geometry.js";import{handlesGroup as t}from"../../core/handleUtils.js";import{clone as n}from"../../core/lang.js";import{clamp as e}from"../../core/mathUtils.js";import{isSome as r,isNone as o,unwrap as a}from"../../core/maybe.js";import{createScreenPoint as s}from"../../core/screenUtils.js";import{f as c}from"../../chunks/vec3f64.js";import{project as i}from"../../geometry/projection.js";import{hydratedSpatialReference as l}from"../../layers/graphics/hydratedFeatures.js";import{getZForElevationMode as u}from"../../support/elevationInfoUtils.js";import{ViewingMode as m}from"../ViewingMode.js";import{move as f}from"../draw/support/drawUtils.js";import p from"../../geometry/Point.js";function y(t,n){let e=null,a=null;return s=>{if("cancel"===s.action)return void(r(a)&&(a.execute({action:"cancel"}),e=null,a=null));const c={action:s.action,screenStart:s.start,screenEnd:s.screenPoint};"start"===s.action&&o(e)&&(e=new G,a=new G,n(t,e,a,s.pointerType,c)),r(e)&&e.execute(c),"end"===s.action&&r(e)&&(e=null,a=null)}}function d(t,n){return t.events.on("drag",y(t,n))}function x(n,e){const r=[];for(const t of n)r.push(d(t,e));return t(r)}function g(t,n){const e=[t.x,t.y,t.z],r=n,o=[Math.cos(r),Math.sin(r)],a=Math.sqrt(o[0]*o[0]+o[1]*o[1]);if(0===a)return null;o[0]/=a,o[1]/=a;const s=t=>{const n=(t.x-e[0])*o[0]+(t.y-e[1])*o[1];t.x=e[0]+n*o[0],t.y=e[1]+n*o[1]};return t=>(s(t.mapStart),s(t.mapEnd),{...t,axis:o})}function h(t,n){let e=null;return r=>{if("start"===r.action&&(e=S(t,r.mapStart.spatialReference,n)),o(e))return null;const a=r.mapEnd.x-r.mapStart.x,s=r.mapEnd.y-r.mapStart.y,c=r.mapEnd.z-r.mapStart.z;return e.move(a,s,c),{...r,translationX:a,translationY:s,translationZ:c}}}function E(t,n){return o(t)?null:t.spatialReference.equals(n)?t.clone():i(t,n)}function S(t,n,e){const r=t.geometry,a=l(n);if(o(r))return null;if("mesh"===r.type)return j(t,r,a,e);const s=E(r,a),c=r.spatialReference;return o(s)?null:{move:(n,e,r)=>{const o=f(s.clone(),n,e,r);o.spatialReference.equals(c)?t.geometry=o:t.geometry=i(o,c)}}}function j(t,n,e,o){if(r(n.transform))return z(t,n,n.transform,e);if(!n.spatialReference.equals(e))return null;let a=0,s=0,c=0;return{move:(e,r,i)=>{const l=e-a,u=r-s,f=i-c;if(l||u||f){const y=new p(n.origin.x+l,n.origin.y+u,n.origin.z+f,n.origin.spatialReference);n.centerAt(y,{geographic:o===m.Global}),t.notifyGeometryChanged(),a=e,s=r,c=i}}}}function z(t,n,e,a){const s=E(e.getOriginPoint(n.spatialReference),a),l=n.spatialReference;return o(s)?null:{move:(n,o,a)=>{const u=f(s.clone(),n,o,a);if(u.spatialReference.equals(l))e.origin=c(u.x,u.y,u.z);else{const t=i(u,l);r(t)&&(e.origin=c(t.x,t.y,t.z))}t.notifyMeshTransformChanged(),t.notifyGeometryChanged()}}}function R(t,n=null,e){let a=null;const s=r(n)&&!t.spatialReference.equals(n)?t=>r(t)?i(t,n):t:t=>t,c={exclude:[],...e};return n=>{if("start"===n.action&&(a=s(t.toMap(n.screenStart,c))),o(a))return null;const e=s(t.toMap(n.screenEnd,c));return r(e)?{...n,mapStart:a,mapEnd:e}:null}}function v(t,n){const e=t.map((t=>a(h(t,n)))).filter((t=>r(t)));return t=>{const n=t.mapEnd.x-t.mapStart.x,r=t.mapEnd.y-t.mapStart.y,o=t.mapEnd.z-t.mapStart.z;return e.forEach((n=>n(t))),{...t,translationX:n,translationY:r,translationZ:o}}}function w(t,e){const r=new Map;for(const o of e)r.set(o,n(t[o]));return n=>(r.forEach(((n,e)=>{t[e]=n})),n)}function M(t){return r(t.geometry)&&"mesh"===t.geometry.type?q(t,t.geometry):w(t,["geometry"])}function q(t,n){const e=r(n.transform)?n.transform.clone():null,o=n.vertexAttributes.clonePositional();return r=>(n.transform=e,n.vertexAttributes=o,t.notifyGeometryChanged(),r)}function D(t){const n=t.map((t=>a(M(t)))).filter((t=>r(t)));return t=>(n.forEach((n=>n(t))),t)}function b(t){return w(t,["symbol"])}function P(){let t=0,n=0,e=0;return r=>{"start"===r.action&&(t=r.mapStart.x,n=r.mapStart.y,e=r.mapStart.z);const o=r.mapEnd.x-t,a=r.mapEnd.y-n,s=r.mapEnd.z-e;return t=r.mapEnd.x,n=r.mapEnd.y,e=r.mapEnd.z,{...r,mapDeltaX:o,mapDeltaY:a,mapDeltaZ:s,mapDeltaSpatialReference:r.mapStart.spatialReference}}}function U(){let t=0,n=0;return e=>{"start"===e.action&&(t=e.screenStart.x,n=e.screenStart.y);const r=e.screenEnd.x-t,o=e.screenEnd.y-n;return t=e.screenEnd.x,n=e.screenEnd.y,{...e,screenDeltaX:r,screenDeltaY:o}}}function C(t,n){let r=null,o=0,a=0;return c=>{if("start"===c.action&&(r=t.toScreen(n),r.x<0||r.x>t.width||r.y<0||r.y>t.height?r=null:(o=c.screenStart.x-r.x,a=c.screenStart.y-r.y)),null==r)return null;const i=e(c.screenEnd.x-o,0,t.width),l=e(c.screenEnd.y-a,0,t.height),u=s(i,l);return c.screenStart=r,c.screenEnd=u,c}}class G{constructor(){this.execute=()=>{}}next(t,n=new G){return r(t)&&(this.execute=e=>{const o=t(e);r(o)&&n.execute(o)}),n}}function X(t,n,e=[]){if("2d"===t.type)return t=>t;let o=null;return a=>{"start"===a.action&&(o=t.toMap(a.screenStart,{exclude:e}),r(o)&&(o.z=u(o,t,n)));const s=t.toMap(a.screenEnd,{exclude:e});r(s)&&(s.z=u(s,t,n));const c=r(o)&&r(s)?{sceneStart:o,sceneEnd:s}:null;return{...a,scenePoints:c}}}export{G as EventPipeline,P as addMapDelta,U as addScreenDelta,g as constrainToMapAxis,y as createDragEventPipelineCallback,d as createManipulatorDragEventPipeline,x as createManipulatorDragEventPipelineMany,C as dragAtLocation,h as dragGraphic,v as dragGraphicMany,M as resetGraphic,D as resetGraphicMany,w as resetProperties,b as resetSymbol,X as sceneSnappingAtLocation,R as screenToMap};
