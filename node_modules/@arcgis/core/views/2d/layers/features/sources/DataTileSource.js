/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import e from"../../../../../TimeExtent.js";import s from"../../../../../core/Evented.js";import has from"../../../../../core/has.js";import{isSome as t}from"../../../../../core/maybe.js";import{createResolver as r,ignoreAbortErrors as i,eachAlwaysValues as o,eachAlways as n}from"../../../../../core/promiseUtils.js";import{diff as c,hasDiff as u,hasDiffAny as h}from"../../../../../core/accessorSupport/diffUtils.js";import a from"../../../../../rest/support/Query.js";import{DataTileSubscription as d}from"./DataTileSubscription.js";import{UpdateToken as p}from"../support/UpdateToken.js";function l(e,s){const t=new Set;return e&&e.forEach((e=>t.add(e))),s&&s.forEach((e=>t.add(e))),t.has("*")?["*"]:Array.from(t)}class m{constructor(e){this.events=new s,this._resolver=r(),this._didEdit=!1,this._subscriptions=new Map,this._outSR=e.outSR,this._serviceInfo=e.serviceInfo,this._onTileUpdateMessage=e.onMessage}destroy(){}async _onMessage(e){const s=this._subscriptions.get(e.id);if(!s)return;const t={...e,remove:e.remove??[],status:e.status??p.empty()};return i(this._onTileUpdateMessage(t,s.options))}update(s,t){const r=t.fields.length;t.outFields=l(this._schema?.outFields,t.outFields),t.outFields=t.outFields.length>=.75*r?["*"]:t.outFields,t.outFields.sort();const i=c(this._schema,t);if(!i)return;has("esri-2d-update-debug")&&console.debug("Applying Update - Source:",i);const o="orderByFields"in this._serviceInfo&&this._serviceInfo.orderByFields?this._serviceInfo.orderByFields:this._serviceInfo.objectIdField+" ASC",n={returnCentroid:"esriGeometryPolygon"===this._serviceInfo.geometryType,returnGeometry:!0,timeReferenceUnknownClient:"stream"!==this._serviceInfo.type&&this._serviceInfo.timeReferenceUnknownClient,outFields:t.outFields,outSpatialReference:this._outSR,orderByFields:[o],where:t.definitionExpression||"1=1",gdbVersion:t.gdbVersion,historicMoment:t.historicMoment,timeExtent:e.fromJSON(t.timeExtent)},a=this._schema&&u(i,"outFields");this._schema&&h(i,["timeExtent","definitionExpression","gdbVersion","historicMoment","customParameters"])&&(s.why.mesh.push("Layer filter and/or custom parameters changed"),s.why.source.push("Layer filter and/or custom parameters changed"),s.mesh=!0,s.source=!0,s.queryFilter=!0),a&&(s.why.source.push("Layer required fields changed"),s.source=!0),c(n,this._queryInfo)&&(this._queryInfo=n),this._schema=t,this._resolver.resolve()}whenInitialized(){return this._resolver.promise}async applyUpdate(e){if(e.queryFilter||e.source&&this._didEdit)return this.refresh(e.version),void(this._didEdit=!1);this._subscriptions.forEach((s=>s.applyUpdate(e))),await this.resend()}refresh(e,s){for(const t of this._tiles())this.unsubscribe(t),this.subscribe(t,e)}subscribe(e,s){const t=new d(e,s);this._subscriptions.set(e.id,t)}unsubscribe(e){const s=this.get(e.id);t(s)&&s.abort(),this._subscriptions.delete(e.id)}createQuery(e={}){const s=this._queryInfo.historicMoment?new Date(this._queryInfo.historicMoment):null;return new a({...this._queryInfo,historicMoment:s,...e})}get(e){return this._subscriptions.has(e)?this._subscriptions.get(e):null}async queryLastEditDate(){throw new Error("Service does not support query type")}async query(e){throw new Error("Service does not support query")}*_tiles(){const e=Array.from(this._subscriptions.values());for(const s of e)yield s.tile}async edit(e,s){const t=Array.from(this._subscriptions.values()),r=t.map((({tile:e})=>e));for(const i of t)i.removeIds(s);if(e.length){const t=r.map((s=>{const t=this.createTileQuery(s);return t.objectIds=e,{tile:s,query:t}})).map((async({tile:e,query:s})=>({tile:e,result:await this.query(s),query:s}))),i=(await o(t)).map((async({tile:t,result:r})=>{if(!r.hasFeatures&&!s.length&&!e.length)return;const i=this._subscriptions.get(t.key.id);i&&i.edit(r,e)}));await n(i)}this._didEdit=!0}}export{m as DataTileSource};
