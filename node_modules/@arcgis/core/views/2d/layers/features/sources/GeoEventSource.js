/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import"../../../../../core/has.js";import{isSome as e}from"../../../../../core/maybe.js";import{watch as t}from"../../../../../core/reactiveUtils.js";import{r as s}from"../../../../../chunks/rbush.js";import{convertFromFeature as r,quantizeOptimizedGeometry as i,quantizeX as n,quantizeY as o}from"../../../../../layers/graphics/featureConversionUtils.js";import a from"../../../../../layers/graphics/OptimizedGeometry.js";import{StreamFeatureManager as d}from"../../../../../layers/graphics/data/StreamFeatureManager.js";import{createConnection as c}from"../../../../../layers/graphics/sources/connections/createConnection.js";import{DataTileSource as h}from"./DataTileSource.js";import{FeatureSetReaderJSON as u}from"../support/FeatureSetReaderJSON.js";import{UpdateToken as p}from"../support/UpdateToken.js";const l=2500;function m(t,s){const r=t.weakClone();if(e(t.geometry)){const e=n(s,t.geometry.coords[0]),i=o(s,t.geometry.coords[1]);r.geometry=new a([],[e,i])}return r}function _(e){return"esriGeometryPoint"===e?m:(t,s)=>{const r=t.weakClone(),n=new a,o=!1,d=!1,c=i(n,t.geometry,o,d,e,s,!1,!1);return r.geometry=c,r}}function f(t){return"esriGeometryPoint"===t?t=>e(t.geometry)?{minX:t.geometry.coords[0],minY:t.geometry.coords[1],maxX:t.geometry.coords[0],maxY:t.geometry.coords[1]}:{minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}:t=>{let s=1/0,r=1/0,i=-1/0,n=-1/0;return e(t.geometry)&&t.geometry.forEachVertex(((e,t)=>{s=Math.min(s,e),r=Math.min(r,t),i=Math.max(i,e),n=Math.max(n,t)})),{minX:s,minY:r,maxX:i,maxY:n}}}function v(e,t){const r=s(9,f(t));return r.load(e),r}function g(e,t){return e.search({minX:t.bounds[0],minY:t.bounds[1],maxX:t.bounds[2],maxY:t.bounds[3]})}class y{constructor(e,t){this.onUpdate=e,this._geometryType=t,this._objectIdToFeature=new Map}get _features(){const e=[];return this._objectIdToFeature.forEach((t=>e.push(t))),e}add(e){this._objectIdToFeature.set(e.objectId,e),this._index=null}get(e){return this._objectIdToFeature.has(e)?this._objectIdToFeature.get(e):null}forEach(e){this._objectIdToFeature.forEach(e)}search(e){return this._index||(this._index=v(this._features,this._geometryType)),g(this._index,e)}removeById(e){const t=this._objectIdToFeature.get(e);return t?(this._objectIdToFeature.delete(e),this._index=null,t):null}update(e,t){this.onUpdate(e,t)}get size(){return this._objectIdToFeature.size}}class b extends h{constructor(e){super(e),this.type="geoevent",this._dataReceiveEventEnabled=!1,this._level=0,this._updateInfo={websocket:0,client:0},this._inUpdate=!1;const{outSR:s}=e,{geometryType:r,objectIdField:i,timeInfo:n,purgeOptions:o,source:a,spatialReference:h,serviceFilter:u,maxReconnectionAttempts:p,maxReconnectionInterval:m,updateInterval:f,enableDataReceived:v,customParameters:g}=e.serviceInfo,b=new y(this._onUpdate.bind(this),r),I=new d(b,i,n,o),U=c(a,h,s,r,u,p,m,g);this._store=b,this._manager=I,this._connection=U,this._quantize=_(r),this._dataReceiveEventEnabled=v,this._handles=[this._connection.on("data-received",(e=>this._onFeature(e))),t((()=>U.connectionStatus),(e=>this.events.emit("connectionStatus",e))),t((()=>U.errorString),(e=>this.events.emit("errorString",e)))],this._initUpdateInterval=()=>{let t=performance.now();this._updateIntervalId=setInterval((()=>{const s=performance.now(),r=s-t;if(r>l){t=s;const e=Math.round(this._updateInfo.client/(r/1e3)),i=Math.round(this._updateInfo.websocket/(r/1e3));this._updateInfo.client=0,this._updateInfo.websocket=0,this.events.emit("updateRate",{client:e,websocket:i})}e.canAcceptRequest()&&!this._inUpdate&&this._manager.checkForUpdates()}),f)},this._initUpdateInterval()}destroy(){super.destroy(),this._clearUpdateInterval(),this._handles.forEach((e=>e.remove())),this._connection.destroy()}_fetchDataTile(){}pauseStream(){this._clearUpdateInterval()}resumeStream(){this._initUpdateInterval()}enableEvent(e,t){"data-received"===e&&(this._dataReceiveEventEnabled=t)}get updating(){return!1}subscribe(e,t){super.subscribe(e,t);const s=this._subscriptions.get(e.id);this._level=e.level;const r=this._getTileFeatures(e);this._onMessage({type:"append",id:e.key.id,addOrUpdate:r,end:!0}),s.didSend=!0}unsubscribe(e){super.unsubscribe(e)}*readers(t){const s=this._subscriptions.get(t),{tile:r}=s;yield this._getTileFeatures(r);for(const i of s.requests.stream.entries)e(i)&&e(i.addOrUpdate)&&(yield i.addOrUpdate)}createTileQuery(e){throw new Error("Service does not support tile  queries")}async resend(){this._subscriptions.forEach((e=>{const{tile:t}=e,s={type:"append",id:t.id,addOrUpdate:this._getTileFeatures(t),end:!0};this._onMessage(s)}))}_getTileFeatures(e){const t=this._store.search(e).map((t=>this._quantize(t,e.transform)));return u.fromOptimizedFeatures(t,this._serviceInfo,e.transform)}_onFeature(e){this._updateInfo.websocket++;try{this._dataReceiveEventEnabled&&this.events.emit("data-received",e);const t=r(e,this._serviceInfo.geometryType,!1,!1,this._serviceInfo.objectIdField);this._manager.add(t)}catch(t){}}_clearUpdateInterval(){clearInterval(this._updateIntervalId),this._updateIntervalId=0}async _onUpdate(t,s){this._inUpdate=!0;try{e(t)&&(this._updateInfo.client+=t.length),this._subscriptions.forEach(((e,t)=>{e.didSend&&e.tile.level===this._level&&this._onMessage({type:"append",id:t,addOrUpdate:null,clear:!0,end:!1})}));const s=[];this._subscriptions.forEach(((e,t)=>{if(!e.didSend||e.tile.level!==this._level)return;const r=e.tile,i={type:"append",id:t,addOrUpdate:this._getTileFeatures(r),remove:[],end:!1,status:p.empty()};e.requests.stream.enqueue(i),s.push(this._onMessage(i))})),await Promise.all(s),this._subscriptions.forEach(((e,t)=>{e.didSend&&e.tile.level===this._level&&this._onMessage({type:"append",id:t,addOrUpdate:null,end:!0})}))}catch{}this._inUpdate=!1}}export{b as GeoEventSource};
