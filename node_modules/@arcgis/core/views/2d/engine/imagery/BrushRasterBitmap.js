/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{isSome as e}from"../../../../core/maybe.js";import{hasSource as t}from"./RasterBitmap.js";import r from"../webgl/VertexStream.js";import s from"../webgl/brushes/WGLBrush.js";import{BlendFactor as a,CompareFunction as i}from"../../../webgl/enums.js";import{setTextures as o,getCommonUniforms as n,setUniforms as h,getColormapUniforms as l,getStretchUniforms as c,getShadedReliefUniforms as d,getUniformLocationInfos as p,getBasicGridUniforms as u}from"../../../webgl/rasterUtils.js";class m extends s{constructor(){super(...arguments),this._desc={lut:{vsPath:"raster/lut",fsPath:"raster/lut",attributes:new Map([["a_position",0],["a_texcoord",1]])},stretch:{vsPath:"raster/stretch",fsPath:"raster/stretch",attributes:new Map([["a_position",0],["a_texcoord",1]])},hillshade:{vsPath:"raster/hillshade",fsPath:"raster/hillshade",attributes:new Map([["a_position",0],["a_texcoord",1]])}},this._rendererUniformInfos=new Map}dispose(){this._quad&&this._quad.dispose()}prepareState({context:e}){e.setBlendingEnabled(!0),e.setBlendFunctionSeparate(a.ONE,a.ONE_MINUS_SRC_ALPHA,a.ONE,a.ONE_MINUS_SRC_ALPHA),e.setColorMask(!0,!0,!0,!0),e.setStencilWriteMask(0),e.setStencilTestEnabled(!0)}draw(e,r){if(!t(r)||r.suspended)return;const{timeline:s,context:a,painter:o}=e;s.begin(this.name),a.setStencilFunction(i.EQUAL,r.stencilRef,255);const n=!a.capabilities.textureFloat?.textureFloatLinear;r.updateTexture(e);const h=this._getShaderVariations(r,n),l=o.materialManager.getProgram(this._desc[r.symbolizerParameters.type],h);this._drawWithProgram(e,l,r),s.end(this.name)}_drawWithProgram({context:t,requestRender:s,allowDelayedRender:a},i,p,m=1,f=[0,0],_=!1){if(this._quad||(this._quad=new r(t,[0,0,1,0,0,1,1,1])),a&&e(s)&&!i.isCompiled)return void s();const{symbolizerParameters:g,transformGrid:b,width:P,height:w,opacity:S}=p,x=g.type;t.useProgram(i);const y=this._getShaderVariations(p),M=this._getUniformInfos(x,t,i,y),{names:U,textures:j}=p.getTextures();o(t,i,U,j);const I=u(m,f),E=n(b,[P,w],[p.source.width,p.source.height],S,_);if(h(i,M,{u_coordScale:p.coordScale,u_dvsMat3:p.transforms.dvs,...I,...E}),g.colormap){const{colormap:e,colormapOffset:t}=g,r=l(e,t);h(i,M,r)}if("stretch"===g.type){const e=c(g);h(i,M,e)}else if("hillshade"===g.type){const e=d(g);h(i,M,e)}this._quad.draw()}_getUniformInfos(e,t,r,s){const a=s.length>0?e+"-"+s.join("-"):e;if(this._rendererUniformInfos.has(a))return this._rendererUniformInfos.get(a);const i=p(t,r);return this._rendererUniformInfos.set(a,i),i}_getShaderVariations(e,t=!1){const r=[],{interpolation:s}=e,{type:a,colormap:i}=e.symbolizerParameters;return"cubic"===s?r.push("bicubic"):"bilinear"===s&&"stretch"===a&&null!=i?(r.push("bilinear"),r.push("nnedge")):t&&"bilinear"===s&&r.push("bilinear"),e.isRendereredSource?r.push("noop"):i&&r.push("applyColormap"),e.transformGrid&&(r.push("applyProjection"),1===e.transformGrid.spacing[0]&&r.push("lookupProjection")),r}}export{m as default};
