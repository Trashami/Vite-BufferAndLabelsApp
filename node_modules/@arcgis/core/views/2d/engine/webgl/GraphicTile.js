/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import t from"./DirtyMap.js";import s from"./DisplayRecordStore.js";import e from"./WGLBuffers.js";import{WGLTile as i}from"./WGLTile.js";class a extends i{constructor(){super(...arguments),this._data=null,this._displayList=null,this._lastCommitTime=0,this._hasData=!1,this._invalidated=!1,this._wglBuffers=null,this._dirtyMap=new t}destroy(){super.destroy(),this.clear()}get hasData(){return!!this._hasData}get displayObjects(){return this._displayObjects??[]}getGeometry(t){return this._wglBuffers&&this._wglBuffers.has(t)?this._wglBuffers.get(t):null}getDisplayList(){return this._displayList}patch(e){if(!0===e.clear)return this.clear(),void(this._hasData=!1);const i=e.addOrUpdate,a=e.remove;!this._data&&i&&i.tileDisplayData.displayObjects.length?(i.tileDisplayData.computeDisplayList(),this._dirtyMap=new t,this._dispRecStore=s.fromTileData(i,this._dirtyMap),this._data=i,this._dirtyMap.markAllDirty(),this._hasData=!0,e.end&&this.ready()):this._data&&(i&&i.tileDisplayData.displayObjects.length||a.length)?this._doPatchData(e):e.end&&this.ready(),e.end&&!this._data&&this.clear(),this.requestRender(),this.emit("change")}commit(t){t.time&&t.time===this._lastCommitTime||(this._lastCommitTime=t.time,this.visible&&this._data&&(this._wglBuffers||(this._wglBuffers=new e(t.context)),(this._dirtyMap.hasDirty()||this._invalidated)&&(this._invalidated=!1,this._wglBuffers.upload(this._data.tileBufferData,this._dirtyMap),this._displayList=this._data.tileDisplayData.displayList.clone(),this._displayObjects=this._data.tileDisplayData.displayObjects.slice(),this._dirtyMap.markAllClean())))}clear(){this._data=null,this._displayList=null,this._dispRecStore=null,this._wglBuffers&&(this._wglBuffers.dispose(),this._wglBuffers=null)}_doPatchData(t){this._invalidated=!0,this._patchData(t)||(this._dirtyMap.markAllDirty(),this._data.reshuffle(),this._dispRecStore=s.fromTileData(this._data,this._dirtyMap)),this.requestRender()}_patchData(t){let s=!0;const e=t.addOrUpdate&&t.addOrUpdate.tileDisplayData&&t.addOrUpdate.tileDisplayData.displayObjects||[],i=(t.remove||[]).slice();for(const l of e)null!=l.insertAfter&&i.push(l.id);let a;i.length>0&&(a=new Set(i));for(const l of i){const t=this._data.tileDisplayData.displayObjectRegistry.get(l);if(t){this._data.tileDisplayData.displayList.removeFromList(t.displayRecords);for(const s of t.displayRecords)this._dispRecStore.delete(s);this._data.tileDisplayData.displayObjectRegistry.delete(l)}}a&&a.size&&(this._data.tileDisplayData.displayObjects=this._data.tileDisplayData.displayObjects.filter((t=>!a.has(t.id))));for(const l of e){let e,i=this._data.tileDisplayData.displayObjectRegistry.get(l.id);if(i){const t=i.displayRecords;i.set(l),i.displayRecords=t;const s=i.displayRecords.length;for(let e=0;e<s;++e){const t=i.displayRecords[e],s=l.displayRecords[e];(e>=l.displayRecords.length||t.geometryType!==s.geometryType||t.symbolLevel!==s.symbolLevel||t.zOrder!==s.zOrder||t.materialKey!==s.materialKey)&&(this._dispRecStore.delete(i.displayRecords[e]),e<l.displayRecords.length&&(i.displayRecords[e]=void 0))}i.displayRecords.length=l.displayRecords.length}else{let t;i=l.copy(),i.displayRecords=[],this._data.tileDisplayData.displayObjectRegistry.set(l.id,i);const s=this._data.tileDisplayData.displayObjects;if(null!=i.insertAfter)if(e={},i.insertAfter>=0){const e=this._data.tileDisplayData.displayObjectRegistry.get(i.insertAfter);e?(t=s.indexOf(e)+1,t<s.length?s.splice(t,0,i):(s.push(i),t=s.length)):(s.push(i),t=s.length)}else s.unshift(i),t=0;else s.push(i),t=s.length;if(e){const i=l.displayRecords.length>0?1:0;let a=0;for(let l=t-1;l>=0&&a<i;--l)for(let t=s[l].displayRecords.length-1;t>=0&&a<i;--t){const i=s[l].displayRecords[t],d=this._data.tileDisplayData.displayList.getDPInfoType();e[d]||(e[d]=i,++a)}}}const a=l.displayRecords.length;for(let d=0;d<a;++d){const a=l.displayRecords[d];let r=i.displayRecords[d];r?(r.meshData=a.meshData,r.materialKey=a.materialKey):(r=a.copy(),r.vertexFrom=void 0,r.indexFrom=void 0,i.displayRecords[d]=r);const h=a.geometryType,p=this._data.tileDisplayData.displayList.getDPInfoType(),o=t.addOrUpdate.tileBufferData.geometries[h],y=o.vertexBuffer,c=o.indexBuffer;let n;e&&(n=e[p]?this._data.tileDisplayData.displayList.splitAfter(e[p]):-1),s=this._dispRecStore.setMeshData(r,a,y,c,n)&&s,e&&null!=r.indexFrom&&null!=r.indexFrom&&(e[p]=r)}}return s}}export{a as GraphicTile};
