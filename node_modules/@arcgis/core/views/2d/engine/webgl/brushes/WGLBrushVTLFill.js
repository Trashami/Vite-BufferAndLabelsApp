/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{isNone as t,isSome as e}from"../../../../../core/maybe.js";import{TranslateAnchor as i}from"../../vectorTiles/style/StyleDefinition.js";import{VTL_TEXTURE_BINDING_UNIT_SPRITES as r,VTL_HIGH_RES_CUTOFF as a}from"../definitions.js";import{WGLDrawPhase as n}from"../enums.js";import{u32to4Xu8 as o}from"../number.js";import l from"./WGLBrush.js";import{TextureSamplingMode as s,CompareFunction as f,PrimitiveType as u,DataType as d}from"../../../../webgl/enums.js";const c=1/65536;class m extends l{constructor(){super(...arguments),this._fillProgramOptions={id:!1,pattern:!1},this._outlineProgramOptions={id:!1}}dispose(){}drawMany(t,e){const{displayLevel:i,drawPhase:r,renderPass:a,spriteMosaic:l,styleLayerUID:s}=t;let f=!1;for(const n of e)if(n.layerData.has(s)){const t=n.layerData.get(s);if(t.fillIndexCount>0||t.outlineIndexCount>0){f=!0;break}}if(!f)return;const u=t.styleLayer,d=u.getPaintProperty("fill-pattern"),c=void 0!==d,m=c&&d.isDataDriven;let p;if(c&&!m){const t=d.getValue(i);p=l.getMosaicItemPosition(t,!0)}const y=!c&&u.getPaintValue("fill-antialias",i);let g=!0,_=1;if(!c){const t=u.getPaintProperty("fill-color"),e=u.getPaintProperty("fill-opacity");if(!t?.isDataDriven&&!e?.isDataDriven){const t=u.getPaintValue("fill-color",i);_=u.getPaintValue("fill-opacity",i)*t[3],_>=1&&(g=!1)}}if(g&&"opaque"===a)return;let E;r===n.HITTEST&&(E=o(s+1));const v=u.getPaintValue("fill-translate",i),M=u.getPaintValue("fill-translate-anchor",i);(g||"translucent"!==a)&&this._drawFill(t,s,u,e,v,M,c,p,m,E);const P=!u.hasDataDrivenOutlineColor&&u.outlineUsesFillColor&&_<1;y&&"opaque"!==a&&!P&&this._drawOutline(t,s,u,e,v,M,E)}_drawFill(o,l,m,p,y,g,_,E,v,M){if(_&&!v&&t(E))return;const{context:P,displayLevel:I,state:T,drawPhase:U,painter:x,pixelRatio:D,spriteMosaic:h,requestRender:S,allowDelayedRender:R}=o,w=m.fillMaterial,N=x.vectorTilesMaterialManager,L=D>a?2:1,A=U===n.HITTEST,C=this._fillProgramOptions;C.id=A,C.pattern=_;const V=N.getMaterialProgram(P,w,C);if(R&&e(S)&&!V.isCompiled)return void S();if(P.useProgram(V),e(E)){const{page:t}=E,i=h.getPageSize(t);e(i)&&(h.bind(P,s.LINEAR,t,r),V.setUniform2fv("u_mosaicSize",i),V.setUniform1i("u_texture",r))}V.setUniformMatrix3fv("u_displayMat3",g===i.VIEWPORT?T.displayMat3:T.displayViewMat3),V.setUniform2fv("u_fillTranslation",y),V.setUniform1f("u_depth",m.z+c),A&&V.setUniform4fv("u_id",M);let O=-1;for(const i of p){if(!i.layerData.has(l))continue;i.key.level!==O&&(O=i.key.level,w.setDataUniforms(V,I,m,O,h));const a=i.layerData.get(l);if(!a.fillIndexCount)continue;a.prepareForRendering(P);const n=a.fillVertexArrayObject;if(!t(n)){if(P.bindVAO(n),V.setUniformMatrix3fv("u_dvsMat3",i.transforms.dvs),P.setStencilFunction(f.EQUAL,i.stencilRef,255),_){const t=Math.max(2**(Math.round(I)-i.key.level),1),e=i.rangeX/(L*i.width*t);V.setUniform1f("u_patternFactor",e)}if(v){const t=a.patternMap;if(!t)continue;for(const[i,a]of t){const t=h.getPageSize(i);e(t)&&(h.bind(P,s.LINEAR,i,r),V.setUniform2fv("u_mosaicSize",t),V.setUniform1i("u_texture",r),P.drawElements(u.TRIANGLES,a[1],d.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*a[0]))}}else P.drawElements(u.TRIANGLES,a.fillIndexCount,d.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*a.fillIndexStart);i.triangleCount+=a.fillIndexCount/3}}}_drawOutline(r,a,o,l,s,m,p){const{context:y,displayLevel:g,state:_,drawPhase:E,painter:v,pixelRatio:M,spriteMosaic:P,requestRender:I,allowDelayedRender:T}=r,U=o.outlineMaterial,x=v.vectorTilesMaterialManager,D=.75/M,h=E===n.HITTEST,S=this._outlineProgramOptions;S.id=h;const R=x.getMaterialProgram(y,U,S);if(T&&e(I)&&!R.isCompiled)return void I();y.useProgram(R),R.setUniformMatrix3fv("u_displayMat3",m===i.VIEWPORT?_.displayMat3:_.displayViewMat3),R.setUniform2fv("u_fillTranslation",s),R.setUniform1f("u_depth",o.z+c),R.setUniform1f("u_outline_width",D),h&&R.setUniform4fv("u_id",p);let w=-1;for(const e of l){if(!e.layerData.has(a))continue;e.key.level!==w&&(w=e.key.level,U.setDataUniforms(R,g,o,w,P));const i=e.layerData.get(a);if(i.prepareForRendering(y),!i.outlineIndexCount)continue;const r=i.outlineVertexArrayObject;t(r)||(y.bindVAO(r),R.setUniformMatrix3fv("u_dvsMat3",e.transforms.dvs),y.setStencilFunction(f.EQUAL,e.stencilRef,255),y.drawElements(u.TRIANGLES,i.outlineIndexCount,d.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*i.outlineIndexStart),e.triangleCount+=i.outlineIndexCount/3)}}}export{m as WGLBrushVTLFill};
