/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import e from"../../../../core/CircularArray.js";import has from"../../../../core/has.js";import{isSome as t,unwrapOr as r,isNone as s}from"../../../../core/maybe.js";import{c as i}from"../../../../chunks/mat2df32.js";import{WGLGeometryType as a}from"./enums.js";import{forEachGeometryType as n}from"./Utils.js";import{WGLTile as h}from"./WGLTile.js";import{MetricReader as d}from"./collisions/MetricReader.js";import{Geometry as o}from"./cpuMapped/Geometry.js";const c=50,u=4,_=100;let p=0;class l extends h{constructor(t,r,s,a,n,h){super(t,r,s,a),this.instanceId=p++,this.patchCount=0,this._renderState={current:{geometry:new Map,metrics:null},next:null,swap:!1,swapFrames:0,locked:!1},this._patches=new e(_),this._bufferPatches=new e(_),this._lastCommitTime=0,this.transforms.labelMat2d=i(),this._store=n,this._requestLabelUpdate=h}destroy(){super.destroy(),this._renderState.current.geometry.forEach((e=>e.destroy())),t(this._renderState.next)&&this._renderState.next.geometry.forEach((e=>e.destroy())),this._renderState.current=null,this._renderState.next=null}get labelMetrics(){return this._renderState.current.metrics}get hasData(){return!!this._renderState.current.geometry.size}getGeometry(e){return this._renderState.current.geometry.get(e)}patch(e,t){this.patchCount++,e.clear&&this._patches.size>=c&&this._dropPatches();const r=e,s=r.addOrUpdate&&this.key.id!==r.addOrUpdate.tileKeyOrigin;t&&s?this._bufferPatches.enqueue(r):(r.sort=r.sort&&!t,this._patches.enqueue(r)),this.requestRender()}commit(e){if(this._lastCommitTime!==e.time){this._lastCommitTime=e.time;for(let e=0;e<u;e++)this._updateMesh(),this.isReady&&this._updateBufferMesh();this._renderState.swap&&(this._swapRenderStates(),this.requestRender())}}lock(){this._renderState.locked=!0}unlock(){this._renderState.locked=!1,this._flushUpdates(),this._swap()}_swapRenderStates(){if(this._renderState.next){if(this._renderState.locked)return this._renderState.swap=!0,void this.requestRender();this._renderState.swap=!0,this._swap()}}_swap(){this._renderState.swap&&(this._renderState.swap=!1,t(this._renderState.next)&&(this._renderState.current.geometry.forEach((e=>e.destroy())),this._renderState.current=this._renderState.next,this._renderState.next=null,this._requestLabelUpdate()))}_flushUpdates(){let e=this._patches.maxSize;for(;this._patches.size&&e--;)this._updateMesh(),this._swap()}_updateBufferMesh(){const e=this._bufferPatches.peek();if(!t(e)||!e.clear||null===this._renderState.next)for(;this._bufferPatches.size;){const e=this._bufferPatches.dequeue();t(e)&&this._patchBuffer(e)}}_updateMesh(){const e=this._patches.dequeue();if(t(e)){if(has("esri-2d-update-debug")){const t=e,r=t.addOrUpdate?.tileKeyOrigin,s=this.key.id===r?"SELF":r;let i="";for(let e=0;e<5;e++)i+=t.addOrUpdate?.data[e]?.records?.byteLength?1:0;console.debug(this.key.id,"FeatureTile:patch",`[clear: ${t.clear} origin: ${s}, end:${t.end} data:${i}]`)}!0===e.clear&&(t(this._renderState.next)&&(this._renderState.next.geometry.forEach((e=>e.destroy())),this._renderState.next=null),this._renderState.next={geometry:new Map,metrics:null},has("esri-2d-update-debug")&&console.debug(this.key.id,"FeatureTile:_updateMesh - Creating new renderState")),this.requestRender(),this._patch(e),e.end&&(has("esri-2d-update-debug")&&console.debug(this.key.id,"FeatureTile:_updateMesh - Encountered end message"),this.ready(),this._swapRenderStates())}}_patch(e){n((t=>{this._remove(t,e.remove),this._insert(t,e,!1)}))}_patchBuffer(e){n((t=>{this._insert(t,e,!0)}))}_insert(e,t,i){try{const n=r(this._renderState.next,this._renderState.current),h=t.addOrUpdate?.data[e],d=n.geometry;if(s(h))return;d.has(e)||(has("esri-2d-update-debug")&&console.debug(this.key.id,`FeatureTile:_insert - Creating geometry buffer ${e}`),d.set(e,new o(e,this.stage))),has("esri-2d-update-debug")&&console.debug(this.key.id,`FeatureTile:_insert - Inserting into ${e}, version=${t.addOrUpdate.version} stride=${h.stride}`),d.get(e).insert(h,t.sort,i),e===a.LABEL&&this._insertLabelMetrics(t.type,h.metrics,t.clear)}catch(n){}}_insertLabelMetrics(e,t,i){const a=r(this._renderState.next,this._renderState.current);if(s(t))return;const n=d.from(t);if(s(a.metrics))a.metrics=n;else{if("update"===e){const e=n.getCursor();for(;e.next();)a.metrics.delete(e.id)}a.metrics.link(n)}}_remove(e,t){const s=r(this._renderState.next,this._renderState.current).geometry.get(e);t&&t.length&&s&&(s.remove(t),this._removeLabelMetrics(t))}_removeLabelMetrics(e){const{metrics:t}=r(this._renderState.next,this._renderState.current);if(!s(t)&&e.length)for(const r of e)for(;t.delete(r););}_dropPatches(){const e=new Array;let t=!1;for(;this._patches.size;){const r=this._patches.dequeue();if(s(r))break;if(r.clear){if(t)break;t=!0}e.push(r)}this._patches.clear(),e.forEach((e=>this._patches.enqueue(e)))}}export{l as FeatureTile};
