/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{unpackFloatRGBA as n}from"../../core/floatRGBA.js";import{f as e}from"../../chunks/vec3f64.js";import{BufferObject as o}from"./BufferObject.js";import{encodeDoubleArray as t}from"./doublePrecisionUtils.js";import{TargetType as r,DepthStencilTargetType as i,TextureType as a,TextureWrapMode as c,PixelFormat as s,PixelType as l,TextureSamplingMode as v,Usage as p,DataType as u,PrimitiveType as f}from"./enums.js";import{FramebufferObject as m}from"./FramebufferObject.js";import{VertexArrayObject as A}from"./VertexArrayObject.js";import{VertexElementDescriptor as h}from"./VertexElementDescriptor.js";function d(t,d){t.resetState();const B=new m(t,{colorTarget:r.TEXTURE,depthStencilTarget:i.NONE},{target:a.TEXTURE_2D,wrapMode:c.CLAMP_TO_EDGE,pixelFormat:s.RGBA,dataType:l.UNSIGNED_BYTE,samplingMode:v.NEAREST,width:1,height:1}),E=o.createVertex(t,p.STATIC_DRAW,new Uint16Array([0,0,1,0,0,1,1,1])),g=new A(t,new Map([["position",0]]),{geometry:[new h("position",2,u.UNSIGNED_SHORT,0,4)]},{geometry:E}),T=e(5633261.287538229,2626832.878767164,1434988.0495278358),b=e(5633271.46742708,2626873.6381334523,1434963.231608387),F=_(t,T,b,d);t.bindFramebuffer(B),t.setViewport(0,0,1,1),t.bindVAO(g),t.drawArrays(f.TRIANGLE_STRIP,0,4);const U=new Uint8Array(4);B.readPixels(0,0,1,1,s.RGBA,l.UNSIGNED_BYTE,U),F.dispose(),g.dispose(!1),E.dispose(),B.dispose();const w=(T[2]-b[2])/25,O=n(U);return Math.abs(w-O)}function _(n,e,o,r){const i=`\n\n  precision highp float;\n\n  attribute vec2 position;\n\n  uniform vec3 u_highA;\n  uniform vec3 u_lowA;\n  uniform vec3 u_highB;\n  uniform vec3 u_lowB;\n\n  varying vec4 v_color;\n\n  ${r?"#define DOUBLE_PRECISION_REQUIRES_OBFUSCATION":""}\n\n  #ifdef DOUBLE_PRECISION_REQUIRES_OBFUSCATION\n\n  vec3 dpPlusFrc(vec3 a, vec3 b) {\n    return mix(a, a + b, vec3(notEqual(b, vec3(0))));\n  }\n\n  vec3 dpMinusFrc(vec3 a, vec3 b) {\n    return mix(vec3(0), a - b, vec3(notEqual(a, b)));\n  }\n\n  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\n    vec3 t1 = dpPlusFrc(hiA, hiB);\n    vec3 e = dpMinusFrc(t1, hiA);\n    vec3 t2 = dpMinusFrc(hiB, e) + dpMinusFrc(hiA, dpMinusFrc(t1, e)) + loA + loB;\n    return t1 + t2;\n  }\n\n  #else\n\n  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\n    vec3 t1 = hiA + hiB;\n    vec3 e = t1 - hiA;\n    vec3 t2 = ((hiB - e) + (hiA - (t1 - e))) + loA + loB;\n    return t1 + t2;\n  }\n\n  #endif\n\n  const float MAX_RGBA_FLOAT =\n    255.0 / 256.0 +\n    255.0 / 256.0 / 256.0 +\n    255.0 / 256.0 / 256.0 / 256.0 +\n    255.0 / 256.0 / 256.0 / 256.0 / 256.0;\n\n  const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);\n\n  vec4 float2rgba(const float value) {\n    // Make sure value is in the domain we can represent\n    float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);\n\n    // Decompose value in 32bit fixed point parts represented as\n    // uint8 rgba components. Decomposition uses the fractional part after multiplying\n    // by a power of 256 (this removes the bits that are represented in the previous\n    // component) and then converts the fractional part to 8bits.\n    vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);\n\n    // Convert uint8 values (from 0 to 255) to floating point representation for\n    // the shader\n    const float toU8AsFloat = 1.0 / 255.0;\n\n    return fixedPointU8 * toU8AsFloat;\n  }\n\n  void main() {\n    vec3 val = dpAdd(u_highA, u_lowA, -u_highB, -u_lowB);\n\n    v_color = float2rgba(val.z / 25.0);\n\n    gl_Position = vec4(position * 2.0 - 1.0, 0.0, 1.0);\n  }\n  `,a="\n  precision highp float;\n\n  varying vec4 v_color;\n\n  void main() {\n    gl_FragColor = v_color;\n  }\n  ",c=n.programCache.acquire(i,a,new Map([["position",0]])),s=new Float32Array(6);t(e,s,3);const l=new Float32Array(6);return t(o,l,3),n.useProgram(c),c.setUniform3f("u_highA",s[0],s[2],s[4]),c.setUniform3f("u_lowA",s[1],s[3],s[5]),c.setUniform3f("u_highB",l[0],l[2],l[4]),c.setUniform3f("u_lowB",l[1],l[3],l[5]),c}export{d as testDoublePrecisionArithmetic};
