/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import e from"../../../../Color.js";import"../../../../core/has.js";import{isSome as t,isNone as r,unwrapOr as a,get as o}from"../../../../core/maybe.js";import{f as s,t as n}from"../../../../chunks/mat3.js";import{c as i}from"../../../../chunks/mat3f64.js";import{f as l,m as u,a as c}from"../../../../chunks/mat4.js";import{b as m,c as h}from"../../../../chunks/mat4f64.js";import{a as f,g as p,e as d,n as g,b as x,f as _}from"../../../../chunks/vec3.js";import{Z as T,O as y,c as b}from"../../../../chunks/vec3f64.js";import{O as v}from"../../../../chunks/vec4f64.js";import{projectVectorToDehydratedPoint as C,projectBuffer as O,computeTranslationToOriginAndRotation as M,canProjectWithoutEngine as A}from"../../../../geometry/projection.js";import{create as w,empty as E,expandWithBuffer as N,intersectsClippingArea as j}from"../../../../geometry/support/aaBoundingBox.js";import R from"../../../../geometry/support/MeshComponent.js";import P from"../../../../geometry/support/MeshMaterialMetallicRoughness.js";import{BufferViewVec3f64 as I,BufferViewVec3f as B}from"../../../../geometry/support/buffer/BufferView.js";import{t as S,a as F}from"../../../../chunks/vec32.js";import{transformPosition as L,transformNormal as V,projectNormalToPCPF as U,transformTangent as G,projectTangentToPCPF as $}from"../../../../geometry/support/meshUtils/projection.js";import{makeDehydratedPoint as D}from"../../../../layers/graphics/dehydratedFeatures.js";import{ViewingMode as k}from"../../../ViewingMode.js";import{getTransformMatrix as z}from"../../glTF/internal/TextureTransformUtils.js";import{perObjectElevationAligner as q}from"./ElevationAligners.js";import{needsElevationUpdates3D as H}from"./elevationAlignmentUtils.js";import{ElevationContext as W}from"./ElevationContext.js";import{Graphics3DObject3DGraphicLayer as Y}from"./Graphics3DObject3DGraphicLayer.js";import{Graphics3DSymbolLayer as Z}from"./Graphics3DSymbolLayer.js";import{createMaterial as J}from"../support/edgeUtils.js";import{parseColorMixMode as K,encodeSymbolColor as Q}from"../support/symbolColorUtils.js";import X from"../../support/debugFlags.js";import{AlphaDiscardMode as ee,CullFaceOptions as te,PrimitiveType as re}from"../../webgl-engine/lib/basicInterfaces.js";import{Geometry as ae}from"../../webgl-engine/lib/Geometry.js";import{generateDefaultIndexArray as oe}from"../../webgl-engine/lib/Indices.js";import{Object3D as se}from"../../webgl-engine/lib/Object3D.js";import{Texture as ne}from"../../webgl-engine/lib/Texture.js";import{VertexAttribute as ie}from"../../webgl-engine/lib/VertexAttribute.js";import{DefaultMaterial as le}from"../../webgl-engine/materials/DefaultMaterial.js";import{NativeLineMaterial as ue}from"../../webgl-engine/materials/NativeLineMaterial.js";import{TextureWrapMode as ce}from"../../../webgl/enums.js";const me=["mesh"];class he extends Z{constructor(e,t,r,a){super(e,t,r,a),this._materials=new Map,this._textures=new Map,this.ensureDrapedStatus(!1)}async doLoad(){X.DRAW_MESH_GEOMETRY_NORMALS&&(this._debugVertexNormalMaterial=new ue({color:[1,0,1,1]}),this._debugFaceNormalMaterial=new ue({color:[0,1,1,1]}))}destroy(){super.destroy(),this._context.stage.removeMany(Array.from(this._materials.values(),(e=>e.material))),this._context.stage.removeMany(Array.from(this._textures.values())),this._materials.clear(),this._textures.clear()}createGraphics3DGraphic(e){const t=e.graphic;if(!this._validateGeometry(t.geometry,me,"fill on mesh-3d"))return null;const r=this.setGraphicElevationContext(t,new W),a=e.renderingInfo;return this._createAs3DShape(t,a,r,t.uid)}layerOpacityChanged(e,r){const a=this._getLayerOpacity();this._materials.forEach((e=>{e.material.setParameters({layerOpacity:a});const t=e.material.parameters;this._setMaterialTransparentParameter(t,e),e.material.setParameters({transparent:t.transparent})})),e.forEach((e=>{const o=r(e);t(o)&&o.layerOpacityChanged(a,this._context.isAsync)}))}layerElevationInfoChanged(e,t){return this.updateGraphics3DGraphicElevationInfo(e,t,H)}slicePlaneEnabledChanged(e,r){return this._materials.forEach((e=>{e.material.setParameters({hasSlicePlane:this._context.slicePlaneEnabled})})),e.forEach((e=>{const a=r(e);t(a)&&a.slicePlaneEnabledChanged(this._context.slicePlaneEnabled,this._context.isAsync)})),!0}physicalBasedRenderingChanged(){const e=this._usePBR();return this._materials.forEach((t=>t.material.setParameters({usePBR:e}))),!0}pixelRatioChanged(){return!0}_requiresSymbolVertexColors(){return this._drivenProperties.color||this._drivenProperties.opacity}_colorOrTextureUid(t){return r(t)?"-":t instanceof e?t.toHex():t.contentHash}_materialPropertiesDefault(e,t){const r=this._requiresSymbolVertexColors(),a=!!e.vertexAttributes.color,o=!!e.vertexAttributes.tangent;return{hasSymbolVertexColors:r,hasVertexColors:a,hasVertexTangents:o,uid:`vc:${a},vt:${o},vct${t},svc:${r}`}}_materialProperties(e,t,r){const a=this._materialPropertiesDefault(e,r);if(!t.material)return a;const{color:o,colorTexture:s,normalTexture:n,doubleSided:i,alphaCutoff:l,alphaMode:u}=t.material,c=this._colorOrTextureUid(o),m=this._colorOrTextureUid(s),h=this._colorOrTextureUid(n);if(a.color=o,a.colorTexture=s,a.normalTexture=n,a.uid=`${a.uid},cmuid:${c},ctmuid:${m},ntmuid:${h},ds:${i},ac:${l},am:${u}`,t.material instanceof P){const{metallic:e,roughness:r,metallicRoughnessTexture:o,emissiveColor:s,emissiveTexture:n,occlusionTexture:i}=t.material,l=this._colorOrTextureUid(o),u=this._colorOrTextureUid(s),c=this._colorOrTextureUid(n),m=this._colorOrTextureUid(i);a.metallic=e,a.roughness=r,a.metallicRoughnessTexture=o,a.emissiveColor=s,a.emissiveTexture=n,a.occlusionTexture=i,a.colorTextureTransform=t.material.colorTextureTransform,a.normalTextureTransform=t.material.normalTextureTransform,a.emissiveTextureTransform=t.material.emissiveTextureTransform,a.occlusionTextureTransform=t.material.occlusionTextureTransform,a.metallicRoughnessTextureTransform=t.material.metallicRoughnessTextureTransform,a.uid=`${a.uid},mrm:${e},mrr:${r},mrt:${l},emuid:${u},etmuid:${c},otmuid:${m}`}return a}_setInternalColorValueParameters(t,r){r.diffuse=e.toUnitRGB(t),r.opacity=t.a}_getLoadableTextureResource(e){return e.data?e.data:e.url}_getInternalTextureId(e){const r=this._getInternalTexture(e,ee.Opaque);return t(r)?r.id:null}_getInternalTexture(e,t){const r=this._getLoadableTextureResource(e);if(!r)return null;const a=`${e.contentHash}/${t}`;let o=this._textures.get(a);return o||(o=new ne(r,{mipmap:!0,wrap:this._castTextureWrap(e.wrap),noUnpackFlip:!0,preMultiplyAlpha:t!==ee.Opaque}),this._textures.set(a,o),this._context.stage.add(o),this._context.stage.loadImmediate(o)),o}_castTextureWrap(e="repeat"){if("string"==typeof e){const t=this._castTextureWrapIndividual(e);return{s:t,t}}return{s:this._castTextureWrapIndividual(e.horizontal),t:this._castTextureWrapIndividual(e.vertical)}}_castTextureWrapIndividual(e){switch(e){case"clamp":return ce.CLAMP_TO_EDGE;case"mirror":return ce.MIRRORED_REPEAT;default:return ce.REPEAT}}_setInternalMaterialParameters(r,a){if(t(r.color)&&this._setInternalColorValueParameters(r.color,a),t(r.colorTexture)){const e=this._getInternalTexture(r.colorTexture,a.textureAlphaMode);t(e)?(a.textureId=e.id,a.textureAlphaPremultiplied=!!e.params.preMultiplyAlpha):a.textureId=void 0}t(r.normalTexture)&&(a.normalTextureId=this._getInternalTextureId(r.normalTexture)),t(r.emissiveColor)&&(a.emissiveFactor=e.toUnitRGB(r.emissiveColor)),t(r.emissiveTexture)&&(a.emissiveTextureId=this._getInternalTextureId(r.emissiveTexture)),t(r.occlusionTexture)&&(a.occlusionTextureId=this._getInternalTextureId(r.occlusionTexture)),t(r.metallicRoughnessTexture)&&(a.metallicRoughnessTextureId=this._getInternalTextureId(r.metallicRoughnessTexture)),a.colorTextureTransformMatrix=z(r.colorTextureTransform),a.normalTextureTransformMatrix=z(r.normalTextureTransform),a.occlusionTextureTransformMatrix=z(r.occlusionTextureTransform),a.emissiveTextureTransformMatrix=z(r.emissiveTextureTransform),a.metallicRoughnessTextureTransformMatrix=z(r.metallicRoughnessTextureTransform)}_setExternalMaterialParameters(r){const a=this._drivenProperties.color;let o=t(this.symbolLayer.material)?this.symbolLayer.material.colorMixMode:null;if(a)r.externalColor=v;else{const a=t(this.symbolLayer.material)?this.symbolLayer.material.color:null;t(a)?r.externalColor=e.toUnitRGBA(a):(o=null,r.externalColor=v)}o&&(r.colorMixMode=o),r.castShadows=!!this.symbolLayer.castShadows}_hasTransparentVertexColors(e){const t=e.vertexAttributes.color;if(r(t))return!1;for(let r=3;r<t.length;r+=4)if(255!==t[r])return!0;return!1}_getOrCreateMaterial(e,r){const a=r.material?.color,o=r.material?.colorTexture,s=r.material?.alphaMode,n="blend"===s,i=!("opaque"===s)&&(this._hasTransparentVertexColors(e)||t(a)&&a.a<1||t(o)&&o.transparent||n),l=this._materialProperties(e,r,i),u=this._materials.get(l.uid);if(u)return u.material;const c={material:null,isComponentTransparent:i,alphaMode:r.material?r.material.alphaMode:"opaque"},m=null==l.metallicRoughnessTexture&&null==l.metallic&&null==l.roughness,h={usePBR:this._usePBR(),isSchematic:m,hasVertexColors:l.hasVertexColors,hasSymbolColors:l.hasSymbolVertexColors,hasVertexTangents:l.hasVertexTangents,ambient:T,diffuse:y,opacity:1,doubleSided:!0,doubleSidedType:"winding-order",cullFace:te.None,layerOpacity:this._getLayerOpacity(),hasSlicePlane:this._context.slicePlaneEnabled,initTextureTransparent:!0};m||(h.mrrFactors=[null!=l.metallic?l.metallic:1,null!=l.roughness?l.roughness:1,.5]),r.material&&(h.doubleSided=r.material.doubleSided,h.cullFace=r.material.doubleSided?te.None:te.Back,h.textureAlphaCutoff=r.material.alphaCutoff),this._setExternalMaterialParameters(h),this._setMaterialTransparentParameter(h,c),this._setInternalMaterialParameters(l,h);const f=new le(h);return c.material=f,this._materials.set(l.uid,c),this._context.stage.add(f),f}_usePBR(){return this._context.physicalBasedRenderingEnabled}_setMaterialTransparentParameter(e,t){e.transparent=this.needsDrivenTransparentPass||t.isComponentTransparent||e.layerOpacity<1||e.opacity<1||e.externalColor&&e.externalColor[3]<1,"auto"===t.alphaMode?e.textureAlphaMode=e.transparent?ee.MaskBlend:ee.Opaque:e.textureAlphaMode="opaque"===t.alphaMode?ee.Opaque:"mask"===t.alphaMode?ee.Mask:ee.Blend}_addDebugNormals(e,t,r,a){const o=t.length,s=e.spatialReference.isGeographic?20015077/180:1,n=.1*Math.max(e.extent.width*s,e.extent.height*s,e.extent.zmax-e.extent.zmin),i=[],l=[],u=[],c=[];for(let m=0;m<o;m++){const e=t[m],r=e.vertexAttributes.get(ie.POSITION),a=e.vertexAttributes.get(ie.NORMAL),o=e.indices.get(ie.POSITION),s=e.indices.get(ie.NORMAL),h=r.data,d=a.data;for(let t=0;t<o.length;t++){const e=3*o[t],r=3*s[t];for(let t=0;t<3;t++)i.push(h[e+t]);for(let t=0;t<3;t++)i.push(h[e+t]+d[r+t]*n);if(l.push(l.length),l.push(l.length),t%3==0){this._calculateFaceNormal(h,o,t,xe),this._getFaceVertices(h,o,t,pe,de,ge),f(pe,pe,de),f(pe,pe,ge),p(pe,pe,1/3);for(let e=0;e<3;e++)u.push(pe[e]);for(let e=0;e<3;e++)u.push(pe[e]+xe[e]*n);c.push(c.length),c.push(c.length)}}}const h=new ae([[ie.POSITION,{data:i,size:3,exclusive:!0}]],[[ie.POSITION,l]],re.Line);t.push(h),r.push(this._debugVertexNormalMaterial),a.push(m(a[0]));const d=new ae([[ie.POSITION,{data:u,size:3,exclusive:!0}]],[[ie.POSITION,c]],re.Line);t.push(d),r.push(this._debugFaceNormalMaterial),a.push(m(a[0]))}_createAs3DShape(e,r,a,o){const s=e.geometry;if("mesh"!==s.type)return null;const n=this._createGeometryInfo(s,r,o);if(!n)return null;const{geometries:i,materials:l,transformations:u,objectTransformation:c}=n;X.DRAW_MESH_GEOMETRY_NORMALS&&this._addDebugNormals(s,i,l,u);const m=new se({geometries:i,materials:l,transformations:u,metadata:{layerUid:this._context.layer.uid,graphicUid:o}});m.transformation=c;const h=this._createEdgeMaterial(),f=t(h)?{baseMaterial:l[0],edgeMaterials:[h],properties:{mergeGeometries:!0,hasSlicePlane:this._context.slicePlaneEnabled}}:null,p=new Y(this,m,i,null,null,q,a,f);return p.needsElevationUpdates=H(a.mode),p.useObjectOriginAsAttachmentOrigin=!0,p.elevationContext.centerPointInElevationSR=this._getCenterPointInElevationSR(m),p.alignedSampledElevation=q(p,p.elevationContext,this._context.elevationProvider,this._context.renderCoordsHelper),p}_getCenterPointInElevationSR(e){const r=D(0,0,0,t(this._context.elevationProvider.spatialReference)?this._context.elevationProvider.spatialReference:null);return C([e.transformation[12],e.transformation[13],e.transformation[14]],this._context.renderCoordsHelper.spatialReference,r),r}_createComponentNormals(e,t,r,a){switch(r.shading||"flat"){case"source":return this._createComponentNormalsSource(e,t,r,a);case"flat":return this._createComponentNormalsFlat(e,a);case"smooth":return this._createComponentNormalsSmooth(e,a);default:return}}_createComponentNormalsSource(e,t,a,o){if(r(t))return this._createComponentNormalsFlat(e,o);let s=!1;if(!a.trustSourceNormals)for(let r=0;r<o.length;r+=3){this._calculateFaceNormal(e,o,r,xe);for(let e=0;e<3;e++){const a=3*o[r+e];pe[0]=t[a+0],pe[1]=t[a+1],pe[2]=t[a+2],d(xe,pe)<0&&(t[a+0]=-t[a+0],t[a+1]=-t[a+1],t[a+2]=-t[a+2],s=!0)}}return{normals:t,indices:o,didFlipNormals:s}}_createComponentNormalsFlat(e,t){const r=new Float32Array(t.length),a=new Array(3*t.length);for(let o=0;o<t.length;o+=3){const s=this._calculateFaceNormal(e,t,o,xe);for(let e=0;e<3;e++)r[o+e]=s[e],a[o+e]=o/3}return{normals:r,indices:a,didFlipNormals:!1}}_createComponentNormalsSmooth(e,t){const r={};for(let s=0;s<t.length;s+=3){const a=this._calculateFaceNormal(e,t,s,xe);for(let e=0;e<3;e++){const o=t[s+e];let n=r[o];n||(n={normal:b(),count:0},r[o]=n),f(n.normal,n.normal,a),n.count++}}const a=new Float32Array(3*t.length),o=new Array(3*t.length);for(let s=0;s<t.length;s++){const e=r[t[s]];1!==e.count&&(g(e.normal,e.normal),e.count=1);for(let t=0;t<3;t++)a[3*s+t]=e.normal[t];o[s]=s}return{normals:a,indices:o,didFlipNormals:!1}}_getFaceVertices(e,t,r,a,o,s){const n=3*t[r+0],i=3*t[r+1],l=3*t[r+2];a[0]=e[n+0],a[1]=e[n+1],a[2]=e[n+2],o[0]=e[i+0],o[1]=e[i+1],o[2]=e[i+2],s[0]=e[l+0],s[1]=e[l+1],s[2]=e[l+2]}_calculateFaceNormal(e,t,r,a){return this._getFaceVertices(e,t,r,pe,de,ge),x(de,de,pe),x(ge,ge,pe),_(pe,de,ge),g(a,pe),a}_getOrCreateComponents(e){return a(e.components,be)}_createPositionBuffer(e,r){let a=e.vertexAttributes.position;const o=r.reprojection===ve.ECEF?r.transformBeforeProject:null;if(t(o)&&(a=L(a,new Float64Array(a.length),o)),r.reprojection===ve.NONE)return r.needsBufferCopy?new Float64Array(a):a;const s=t(o)?a:new Float64Array(a.length);return O(a,e.spatialReference,0,s,this._context.renderCoordsHelper.spatialReference,0,a.length/3),s}_createNormalBuffer(e,a,o){let s=e.vertexAttributes.normal;if(r(s))return null;const n=o.reprojection===ve.ECEF?o.transformBeforeProject:null;t(n)&&(s=V(s,new Float32Array(s.length),n));if("local"===this._context.graphicsCoreOwner.view.viewingMode||o.reprojection===ve.NONE)return o.needsBufferCopy&&e.vertexAttributes.normal===s?new Float32Array(s):s;const i=e.vertexAttributes.position,l=t(n)?s:new Float32Array(s.length);return U(s,i,a,e.spatialReference,l)}_createTangentBuffer(e,a,o){let s=e.vertexAttributes.tangent;if(r(s))return null;const n=o.reprojection===ve.ECEF?o.transformBeforeProject:null;t(n)&&(s=G(s,new Float32Array(s.length),n));if("local"===this._context.graphicsCoreOwner.view.viewingMode||o.reprojection===ve.NONE)return o.needsBufferCopy&&e.vertexAttributes.normal===s?new Float32Array(s):s;const i=e.vertexAttributes.position,l=t(n)?s:new Float32Array(s.length);return $(s,i,a,e.spatialReference,l)}_createColorBuffer(e){return e.vertexAttributes.color}_createSymbolColorBuffer(e){if(this._requiresSymbolVertexColors()){const t=this._getVertexOpacityAndColor(e),r=K(o(this.symbolLayer,"material","colorMixMode")),a=new Uint8Array(4);return Q(t,r,a),a}return null}_createBuffers(e,r){const a=e.vertexAttributes&&e.vertexAttributes.position;if(!a)return this.logger.warn("Mesh geometry must contain position vertex attributes"),null;const o=e.vertexAttributes.normal,s=e.vertexAttributes.uv,n=e.vertexAttributes.tangent;if(t(o)&&o.length!==a.length)return this.logger.warn("Mesh normal vertex buffer must contain the same number of elements as the position buffer"),null;if(t(n)&&n.length/4!=a.length/3)return this.logger.warn("Mesh tangent vertex buffer must contain the same number of elements as the position buffer"),null;if(t(s)&&s.length/2!=a.length/3)return this.logger.warn("Mesh uv vertex buffer must contain the same number of elements as the position buffer"),null;const i=this._computeReprojectionInfo(e),l=this._createPositionBuffer(e,i),u=this._createColorBuffer(e),c=this._createSymbolColorBuffer(r),m=this._createNormalBuffer(e,l,i),f=this._createTangentBuffer(e,l,i);return{positionBuffer:l,normalBuffer:m,tangentBuffer:f,uvBuffer:s,colorBuffer:u,symbolColorBuffer:c,objectTransformation:i.reprojection===ve.NONE&&t(i.objectTransformation)?i.objectTransformation:this._transformOriginLocal(e,l,m,f),geometryTransformation:i.reprojection===ve.NONE&&t(i.geometryTransformation)?i.geometryTransformation:h()}}_computeReprojectionInfo(e){const r=t(e.transform),a=r&&e.transform.geographic||this._context.renderCoordsHelper.viewingMode===k.Local?ve.NONE:ve.ECEF;if(r){if(a===ve.NONE){const t=h();M(e.spatialReference,e.transform.origin,t,this._context.renderCoordsHelper.spatialReference);return{reprojection:a,objectTransformation:t,geometryTransformation:m(e.transform.localMatrix),needsBufferCopy:!1}}const t=l(h(),e.transform.origin);return u(t,t,e.transform.localMatrix),{reprojection:a,transformBeforeProject:t,needsBufferCopy:!0}}return{reprojection:a,needsBufferCopy:!0}}_transformOriginLocal(e,r,a,o){const i=this._context.renderCoordsHelper.spatialReference,l=e.anchor;fe[0]=l.x,fe[1]=l.y,fe[2]=l.z;const u=h();M(e.spatialReference,fe,u,i);const m=I.fromTypedArray(r);if(c(_e,u),S(m,m,_e),t(a)||t(o)){if(s(Te,u),n(Te,Te),t(a)){const e=B.fromTypedArray(a);F(e,e,Te)}if(t(o)){const e=B.fromTypedArray(o,4*o.BYTES_PER_ELEMENT);F(e,e,Te)}}return u}_validateFaces(e,t){const r=e.vertexAttributes.position.length/3,a=t.faces;if(a){let e=-1;for(let t=0;t<a.length;t++){const r=a[t];r>e&&(e=r)}if(r<=e)return this.logger.warn(`Vertex index ${e} is out of bounds of the mesh position buffer`),!1}else if(r%3!=0)return this.logger.warn("Mesh position buffer length must be a multiple of 9 if no component faces are defined (3 values per vertex * 3 vertices per triangle)"),!1;return!0}_getOrCreateFaces(e,t){return t.faces?t.faces:oe(e.vertexAttributes.position.length/3)}_isOutsideClippingArea(e){if(!this._context.clippingExtent)return!1;const r=e.vertexAttributes&&e.vertexAttributes.position;if(!r)return!1;const a=this._context.elevationProvider.spatialReference;let o;const s=r.length/3;return t(a)&&!e.spatialReference.equals(a)?(o=new Float64Array(r.length),O(e.vertexAttributes.position,e.spatialReference,0,o,a,0,s)):o=r,E(ye),N(ye,o,0,s),!j(ye,this._context.clippingExtent)}_createGeometryInfo(e,a,o){if(!A(e.spatialReference,this._context.graphicsCoreOwner.view.spatialReference))return this.logger.warn("Geometry spatial reference is not compatible with the view"),null;if(this._isOutsideClippingArea(e))return null;const s=this._createBuffers(e,a);if(r(s))return null;const{positionBuffer:n,uvBuffer:i,colorBuffer:l,symbolColorBuffer:u,normalBuffer:c,tangentBuffer:m,objectTransformation:h,geometryTransformation:f}=s,p=this._getOrCreateComponents(e),d=[],g=[],x=[];let _=!1;for(const r of p){if(!this._validateFaces(e,r))return null;const a=this._getOrCreateFaces(e,r);if(0===a.length)continue;const s=this._createComponentNormals(n,c,r,a);s.didFlipNormals&&(_=!0);const h=[[ie.POSITION,{size:3,data:n,exclusive:!0}],[ie.NORMAL,{size:3,data:s.normals,exclusive:!0}]],p=[[ie.POSITION,a],[ie.NORMAL,s.indices]];t(l)&&(h.push([ie.COLOR,{size:4,data:l,exclusive:!0}]),p.push([ie.COLOR,a])),t(u)&&(h.push([ie.SYMBOLCOLOR,{size:4,data:u,exclusive:!0}]),p.push([ie.SYMBOLCOLOR,new Array(a.length).fill(0)])),t(i)&&(h.push([ie.UV0,{size:2,data:i,exclusive:!0}]),p.push([ie.UV0,a])),t(m)&&(h.push([ie.TANGENT,{size:4,data:m,exclusive:!0}]),p.push([ie.TANGENT,a]));const T=this._context.stage.renderView._getObjectAndLayerIdColor({graphicUid:o,layerUid:this._context.layer.uid}),y=new ae(h,p,re.Triangle,T);d.push(y),g.push(f),x.push(this._getOrCreateMaterial(e,r))}return _&&this.logger.warn("Normals have been automatically flipped to be consistent with the counter clock wise face winding order. It is better to generate mesh geometries that have consistent normals."),{geometries:d,transformations:g,materials:x,objectTransformation:h}}_createEdgeMaterial(){const e={opacity:this._getLayerOpacity()};return J(this.symbolLayer,e)}}const fe=b(),pe=b(),de=b(),ge=b(),xe=b(),_e=h(),Te=i(),ye=w(),be=[new R];var ve;!function(e){e[e.NONE=0]="NONE",e[e.ECEF=1]="ECEF"}(ve||(ve={}));export{he as Graphics3DMeshFillSymbolLayer};
