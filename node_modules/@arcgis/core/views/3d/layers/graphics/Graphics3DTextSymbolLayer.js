/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import e from"../../../../core/Error.js";import{isNone as t,isSome as r,get as n,unwrap as s}from"../../../../core/maybe.js";import{isPromiseLike as i}from"../../../../core/promiseUtils.js";import{pt2px as o}from"../../../../core/screenUtils.js";import{a,f as l}from"../../../../chunks/vec2f64.js";import{hasCalloutSupport as c,textSymbolLayerSupportsVerticalOffset as m}from"../../../../symbols/callouts/calloutUtils.js";import{perObjectElevationAligner as h}from"./ElevationAligners.js";import{SymbolUpdateType as f,needsElevationUpdates2D as d}from"./elevationAlignmentUtils.js";import{ElevationContext as p}from"./ElevationContext.js";import{Graphics3DObject3DGraphicLayer as u}from"./Graphics3DObject3DGraphicLayer.js";import{Graphics3DSymbolLayer as g}from"./Graphics3DSymbolLayer.js";import{validateSymbolLayerSize as y}from"./graphicUtils.js";import{verticalPlacementFromAlignment as x,textRenderAlignmentFromHorizontalPlacement as v,horizontalPlacementToAnchorX as b,anchorFromPlacements as P,namedAnchorToHUDMaterialAnchorPos as O}from"./placementUtils.js";import{placePointOnGeometry as w,createStageObjectForHUD as S,extendPointGraphicElevationContext as _}from"./pointUtils.js";import{createPointGeometry as j}from"../../webgl-engine/lib/GeometryUtil.js";import{TextRenderParameters as L}from"../../webgl-engine/lib/TextRenderParameters.js";import E from"../../webgl-engine/lib/TextTextureFactory.js";import{HUDMaterial as z}from"../../webgl-engine/materials/HUDMaterial.js";const C=[0,0,1];class R extends g{constructor(e,t,r,n){super(e,t,r,n),this._elevationOptions={supportsOffsetAdjustment:!0,supportsOnTheGround:!1},this.ensureDrapedStatus(!1)}async doLoad(){if(!this._drivenProperties.size){const t=y(this.symbolLayer.size);if(t)throw new e("graphics3dtextsymbollayer:invalid-size",t)}await this._createTextRenderParameters()}async _createTextRenderParameters(){const e=this._context.graphicsCoreOwner.view.state.pixelRatio;this._textRenderParameters=await L.fromSymbol(this.symbolLayer,e)}destroy(){super.destroy()}createGraphics3DGraphic(e){const n=e.graphic,s=w(n.geometry);if(t(s))return this.logger.warn(`unsupported geometry type for text symbol: ${n.geometry.type}`),null;const i=this.symbolLayer.text;if(t(i)||""===i)return null;const o=c(this.symbol)&&this.symbol.hasVisibleVerticalOffset()?this.symbol.verticalOffset:null;if(r(o)&&!m(this.symbolLayer))return this.logger.errorOncePerTick(`Callouts and vertical offset on text symbols are currently only supported with 'center' horizontal alignment (not with '${this.symbolLayer.horizontalAlignment}' alignment)`),null;const a={...A,verticalOffset:o,horizontalPlacement:this.symbolLayer.horizontalAlignment,verticalPlacement:x(this.symbolLayer.verticalAlignment)};return this._createAs3DShape(n,s,i,a)}createLabel(e,r,n,s){const i=e.graphic,o=w(i.geometry);if(t(o))return this.logger.warn(`unsupported geometry type for label: ${i.geometry.type}`),null;const a=r.text;return!a||/^\s+$/.test(a)?null:this._createAs3DShape(i,o,a,r,n,s)}setGraphicElevationContext(e,t,r=0){const n=super.setGraphicElevationContext(e,t);return n.addOffsetRenderUnits(r),n}layerOpacityChanged(){return this.logger.warn("layer opacity change not yet implemented in Graphics3DTextSymbolLayer"),!1}layerElevationInfoChanged(e,t){return U(e,t,((e,t)=>{this.updateGraphicElevationContext(t,e)})),f.UPDATE}slicePlaneEnabledChanged(e,t){return U(e,t,(e=>{for(const t of e.stageObject.geometryRecords)t.material.setParameters({hasSlicePlane:this._context.slicePlaneEnabled})})),!0}physicalBasedRenderingChanged(){return!0}pixelRatioChanged(){return!1}updateGraphicElevationContext(e,t){this.setGraphicElevationContext(e,t.elevationContext,t.metadata.elevationOffset),t.needsElevationUpdates=d(t.elevationContext.mode)||"absolute-height"===t.elevationContext.mode}_defaultElevationInfoNoZ(){return G}_createAs3DShape(e,l,c,m,f,g){const y=this.setGraphicElevationContext(e,new p,m.elevationOffset),x="polyline"===n(e.geometry,"type"),b=e.uid;let P=null,O=null;if(t(g)){const e=v(m.horizontalPlacement);P=new E(c,e,this._textRenderParameters);let n=null;if(r(this._context.sharedResources.textures)){O=this._context.sharedResources.textures.fromData(P.key,(()=>s(P).create()),(()=>{r(n)&&n.release()}));const e=this._context.stage.renderView.textureRepository.acquire(O.texture.id);if(t(e)||i(e))return O.release(),null;n=e}}const w=D(P,m),L={occlusionTest:!0,screenOffset:m.screenOffset,anchorPosition:w,polygonOffset:!0,color:[1,1,1,1],centerOffsetUnits:m.centerOffsetUnits,debugDrawLabelBorder:m.debugDrawLabelBorder,drawInSecondSlot:!0};if(r(O)&&(L.textureId=O.texture.id),r(g)&&(L.textureId=g.id),r(m.verticalOffset)){const{screenLength:e,minWorldLength:t,maxWorldLength:n}=m.verticalOffset;L.verticalOffset={screenLength:o(e),minWorldLength:t||0,maxWorldLength:r(n)?n:1/0}}if(this._context.screenSizePerspectiveEnabled){const{screenSizePerspectiveSettings:e,screenSizePerspectiveSettingsLabels:t}=this._context.sharedResources;L.screenSizePerspective=t.overridePadding(this._textRenderParameters.haloSize+this._textRenderParameters.definition.background.padding[0]),L.screenSizePerspectiveAlignment=e}let R;if(x&&(L.shaderPolygonOffset=1e-4),L.hasSlicePlane=this._context.slicePlaneEnabled,r(f)){const e=JSON.stringify(L);R=f.get(e),t(R)&&(R=new z(L),f.add(e,R))}else R=new z(L);const U=[R],G=m.translation,A=r(P)?[P.displayWidth,P.displayHeight]:[0,0],T=m.centerOffset,W=[j(C,G,null,A,T,[0,0],null)],I=this._context.layer.uid,k=S(this._context,l,W,U,y,I,b);if(null===k)return null;const B=new u(this,k.object,W,t(f)?U:null,O,h,y);B.alignedSampledElevation=k.sampledElevation,B.needsElevationUpdates=d(y.mode)||"absolute-height"===y.mode;const{displayWidth:H,displayHeight:$}=r(P)?P:m;B.getScreenSize=(e=a())=>(e[0]=H,e[1]=$,e);const V={labelText:c,elevationOffset:m.elevationOffset};return B.metadata=V,_(B,l,this._context.elevationProvider),B}}function U(e,t,n){e&&e.forEach((e=>{const s=t(e);r(s)&&n(s,e.graphic)}))}function D(e,t){if("baseline"===t.verticalPlacement){const n=b[t.horizontalPlacement],s=r(e)?e.baselineAnchorY:0;return l(n,s)}const n=P(t.horizontalPlacement,t.verticalPlacement);return O[n]}const G={mode:"relative-to-ground",offset:0},A={text:null,translation:[0,0,0],elevationOffset:0,centerOffset:[0,0,0,1],screenOffset:[0,0],horizontalPlacement:"center",verticalPlacement:"center",verticalOffset:null,centerOffsetUnits:null,debugDrawLabelBorder:!1,displayWidth:0,displayHeight:0};export{R as Graphics3DTextSymbolLayer};
