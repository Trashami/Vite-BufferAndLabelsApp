/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import r from"../../../Graphic.js";import"../../../symbols.js";import t from"../../../core/Accessor.js";import i from"../../../core/Handles.js";import{destroyMaybe as o,isNone as s,isSome as a}from"../../../core/maybe.js";import{watch as n}from"../../../core/reactiveUtils.js";import{property as p}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/arrayUtils.js";import"../../../core/accessorSupport/ensureType.js";import{subclass as l}from"../../../core/accessorSupport/decorators/subclass.js";import{diff as c}from"../../../core/accessorSupport/diffUtils.js";import{c as d}from"../../../chunks/vec3f64.js";import{makeDehydratedPoint as h}from"../../../layers/graphics/dehydratedFeatures.js";import{Graphics3DCore as g}from"./graphics/Graphics3DCore.js";import m from"./graphics/Graphics3DScaleVisibility.js";import{boundingBoxTop as y}from"./i3s/I3SGeometryUtil.js";import{LimitGraphicsMap as f}from"../support/LimitGraphicsMap.js";import{UpdatePolicy as u}from"../webgl-engine/lib/basicInterfaces.js";import b from"../../../symbols/PointSymbol3D.js";let v=class extends t{constructor(e){super(e),this.loadedGraphics=new f(5e4),this.slicePlaneEnabled=!1,this._renderingInfo={symbol:new b},this._handles=new i,this._graphicsByNode=new Map}get updating(){return this._graphicsCore?.updating??!1}initialize(){const e=this.view.basemapTerrain;this._graphicsCore=new g({owner:this,layer:this.layer,preferredUpdatePolicy:u.ASYNC,elevationFeatureExpressionEnabled:!1,graphicSymbolSupported:!1,getRenderingInfoWithoutRenderer:!0,hasZ:!0,hasM:!1,componentFactories:{deconflictor:e=>this.view.deconflictor.addGraphicsOwner(e),labeler:(e,r)=>this.view.labeler.addGraphicsOwner(e,r,{emptySymbolLabelSupported:!0,elevationInfoOverride:{mode:"absolute-height",offset:0},disablePlacement:{logEntityDescription:"3D Object Scene Layer features"}}),scaleVisibility:(r,t)=>new m({graphicsCoreOwner:this,layer:this.layer,queryGraphicUIDsInExtent:t,graphicsCore:r,basemapTerrain:e,layerScaleEnabled:!1})}}),this._graphicsCore.initializePromise.then((()=>this._graphicsCore.startCreateGraphics())).catch((()=>{})),this._handles.add(n((()=>this.layer.labelingInfo),((e,r)=>{c(e,r)&&this._graphicsCore.updateLabelingInfo()})))}destroy(){this._handles=o(this._handles),this._graphicsCore=o(this._graphicsCore),this.loadedGraphics=o(this.loadedGraphics),this.view=null}addNodeMeta(e,t){let i=0;const o=e.filteredIds,a=this.view.spatialReference,n=e.featureIds.map(((n,p)=>{y(p,this.collection,e.objectHandle,_);const l=h(0,0,0,a);this.view.renderCoordsHelper.fromRenderCoords(_,l);const c=t(p,e);let d=!1;return s(o)?d=!0:i<o.length&&n===o[i]&&(d=!0,i++),{objectId:n,uid:r.generateUID(),attributes:c,visible:d,geometry:l}}));this.loadedGraphics.addMany(n),this._graphicsByNode.set(e.node.index,n)}updateLabelPositions(e){const r=this._graphicsByNode.get(e.node.index);let t=0;const i=this.view.spatialReference,o=[];for(let s=0;s<e.featureIds.length;s++){const n=r[t];if(e.featureIds[s]===n.objectId){if(t++,y(s,this.collection,e.objectHandle,_),this.view.renderCoordsHelper.fromRenderCoords(_,_,i),a(n.geometry)&&"point"===n.geometry.type&&n.geometry.x===_[0]&&n.geometry.y===_[1]&&n.geometry.z===_[2])continue;a(n.geometry)&&"point"===n.geometry.type?(n.geometry.x=_[0],n.geometry.y=_[1],n.geometry.z=_[2]):n.geometry=h(_[0],_[1],_[2],i),o.push(n.uid)}}this._graphicsCore.updateLabelingInfo(o)}setNodeMetaAttributes(e,r){const t=this._graphicsByNode.get(e.node.index),i=new Array(t.length);for(let o=0;o<t.length;o++){const s=t[o];s.attributes=r(o,e),i[o]=s.uid}this._graphicsCore.updateLabelingInfo(i)}applyFilterChange(e){const r=this._graphicsByNode.get(e.node.index);if(r)if(s(e.filteredIds))for(const t of r)t.visible||(t.visible=!0,C.graphic=t,C.property="visible",C.oldValue=!1,C.newValue=!0,this._graphicsCore.graphicUpdateHandler(C));else{let t=0;for(const i of r){const r=i.visible;t<e.filteredIds.length&&i.objectId===e.filteredIds[t]?(i.visible=!0,t++):i.visible=!1,r!==i.visible&&(C.graphic=i,C.property="visible",C.oldValue=r,C.newValue=i.visible,this._graphicsCore.graphicUpdateHandler(C))}}}removeNodeMeta(e){this.loadedGraphics.removeManyByObjectId(e.featureIds)}getRenderingInfo(){return this._renderingInfo}notifyGraphicGeometryChanged(){}notifyGraphicVisibilityChanged(){}get updatePolicy(){return this._graphicsCore.effectiveUpdatePolicy}get usedMemory(){return this._graphicsCore.usedMemory}get unloadedMemoryEstimate(){return this._graphicsCore.unprocessedMemoryEstimate}get test(){return{graphicsCore:this._graphicsCore}}};e([p()],v.prototype,"view",void 0),e([p()],v.prototype,"layer",void 0),e([p()],v.prototype,"collection",void 0),e([p()],v.prototype,"loadedGraphics",void 0),e([p()],v.prototype,"updating",null),e([p()],v.prototype,"slicePlaneEnabled",void 0),e([p()],v.prototype,"_graphicsCore",void 0),v=e([l("esri.views.3d.layers.I3SMeshViewLabeler")],v);const C={graphic:null,property:null,oldValue:null,newValue:null},_=d(),j=v;export{j as default};
