/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{result as e,assertResult as t}from"../../../../core/asyncUtils.js";import has from"../../../../core/has.js";import{clone as r}from"../../../../core/lang.js";import{isNone as i,isSome as o}from"../../../../core/maybe.js";import{eachAlways as n,isAbortError as s}from"../../../../core/promiseUtils.js";import{makeAbsolute as a}from"../../../../core/urlUtils.js";import{TextureEncoding as u}from"./enums.js";import{readBinaryAttribute as l,createGeometryDescriptor as f}from"./I3SBinaryReader.js";import{getMaterialAndTextures as d,getMaterialAndTexturesFromShared as c,selectEncoding as m}from"./I3SMaterialUtil.js";class h{constructor(e,t,r,i,o,n){if(this._streamDataController=t,this._logger=r,this._defaultGeometrySchema=i,this._requiredAttributes=o,this._options=n,this._logLayer=e,this._layerUrl=e.parsedUrl.path,this._geometryDefinitions=e.geometryDefinitions,e.materialDefinitions){const t=e.textureSetDefinitions;this._materialAndTextures=e.materialDefinitions.map((e=>d(t,e)))}}_load(e,t,r){return this._streamDataController.request(e,t,r)}_loadAttribute(e,t,r){const i=`${this._layerUrl}/nodes/${e.resources.attributes}/attributes/${t.key}/0`;return this._load(i,"binary",r).then((e=>l(t,e)))}loadAttributes(e,t,r){return n(t.map((t=>this._loadAttribute(e,t.attributeStorageInfo,r)))).then((r=>{const i={};for(let o=0;o<t.length;++o){const n=r[o].value;if(n)i[t[o].name]=n;else{if(s(r[o].error))throw r[o].error;this._logger.error("#loadAttributes",this._logLayer,`Failed to load attributeData for '${t[o].name}' on node '${e.id}'`,r[o].error)}}return i}))}async loadNodeData(r,n){const s=null!=this._requiredAttributes&&r.resources.attributes?e(this.loadAttributes(r,this._requiredAttributes,n)):null,{bufferDefinition:a,bufferIndex:u}=D(this._geometryDefinitions,r),l=!!r.resources.geometry,d=l?e(this._loadGeometry(r.resources.geometry,u,n)):null,m=r.resources.hasSharedResource?await this._loadShared(r,n):null,h=this._materialAndTextures&&r.resources.materialDefinition>=0?this._materialAndTextures[r.resources.materialDefinition]:null!=m?c(m):null,p=h&&h.material,x=h&&h.textures,A=`${r.id}`,w=!l&&this._options.loadFeatureData,T=w?await this._loadFeatureData(A,n):null,$=w?_(T):g(p),j=i($)&&y(T),I=null!=x&&x.length>0?e(this.loadTextures(r,x,n)):null;let U=null,S=null;if(d){U=t(await d);const e=b(this._defaultGeometrySchema,m);S=f(a,e)}const q=I?t(await I):null,B=s?t(await s):{},C=B?{attributeData:B,loadedAttributes:this._requiredAttributes}:null;if(o($))return{geometryData:$,attributeDataInfo:C,geometryBuffer:U,geometryDescriptor:S,requiredTextures:x,textureData:q};if(o(j))return{pointData:j,attributeDataInfo:C,geometryBuffer:U,geometryDescriptor:S,requiredTextures:x,textureData:q};throw new Error}static _addAbsoluteHrefTexture(e,t){const r=e.textureDefinitions;if(null!=r)for(const i of Object.keys(r))for(const e of r[i].images)Array.isArray(e.href)?e.hrefConcat=e.href.map((e=>a(e,t))):e.hrefConcat=a(e.href,t)}static _fixTextureEncodings(e){const t=e.textureDefinitions;if(null!=t)for(const r in t){const e=t[r];if(Array.isArray(e.encoding))for(let t=0;t<e.encoding.length;t++){const r=e.encoding[t];"data:"===r.substring(0,5)&&(e.encoding[t]=r.substring(5))}else{const t=e.encoding;"data:"===t.substring(0,5)&&(e.encoding=t.substring(5))}}}_loadShared(e,t){const r=`${this._layerUrl}/nodes/${e.resources.geometry}/shared`;return this._load(r,"json",t).then((e=>(h._fixTextureEncodings(e),h._addAbsoluteHrefTexture(e,r),e)))}_loadTexture(e,t,r,i,o,n){let s=!1;return o===u.DDS_S3TC||o===u.KTX2||o===u.Basis?this._load(e,"binary",n).then((e=>({id:t,usage:r,data:e,encoding:o,downsampled:s}))):this._load(e,"image",n).then((e=>{let n=e;const a=4096,u=2;if(i&&e.width*e.height>=a){const t=Math.ceil(e.width/u),r=Math.ceil(e.height/u),i=document.createElement("canvas");i.width=t,i.height=r;i.getContext("2d").drawImage(e,0,0,t,r),n=i,s=!0}return{id:t,usage:r,data:n,encoding:o,downsampled:s}}))}loadTextures(e,t,r){const i=this._options.uncompressedTextureDownsamplingEnabled,o=this._options.textureUsageMask;return Promise.all(t.map((t=>{if(0==(t.usage&o))return null;const n=m(t.encodings,this._options.textureEncodings);if(null==n)return this._logger.error("#loadTextures",this._logLayer,`No known encoding for texture found on node ${e.id}`),Promise.reject();const s=e.resources.texture||e.id,a=`${this._layerUrl}/nodes/${s}/textures/${n.name}`;return this._loadTexture(a,t.id,t.usage,i,n.encoding,r)})))}_loadFeatureData(e,t){const r=`${this._layerUrl}/nodes/${e}/features/0`;return this._load(r,"json",t)}_loadGeometry(e,t,r){const i=`${this._layerUrl}/nodes/${e}/geometries/${t}`;return this._load(i,"binary",r)}}function g(e){return{featureIds:[],geometries:[{type:"ArrayBufferView",params:{material:e}}],featureDataPosition:[0,0,0]}}function _(e){for(const t of e.featureData){const e=t.geometries;if(null!=e)for(const r of e)return{featureIds:[t.id],featureDataPosition:t.position,geometries:[r]}}return null}function y(e){const t=new Array;for(const r of e.featureData)null!=r.position&&t.push({featureIds:[r.id],featureDataPosition:r.position,geometries:null});return t}function b(e,t){if(!e||!t||!t.materialDefinitions)return e;const i=Object.keys(t.materialDefinitions)[0];return!t.materialDefinitions[i].params.vertexRegions&&e.vertexAttributes.region&&delete(e=r(e)).vertexAttributes.region,e}function D(e,t){const r={bufferDefinition:null,bufferIndex:0};if(null==e||t.resources.geometryDefinition<0)return r;const i=t.resources.geometryDefinition>=0?e[t.resources.geometryDefinition].geometryBuffers:null;if(null==i)return r;for(let o=0;o<i.length;o++){const e=i[o];if(null==e.compressedAttributes)r.bufferIndex=o,r.bufferDefinition=i[o];else if("draco"===e.compressedAttributes.encoding&&!has("disable-feature:i3s-draco"))return r.bufferIndex=o,r.bufferDefinition=e,r}return r}export{h as default};
