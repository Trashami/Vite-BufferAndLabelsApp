/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{isNone as e,unwrap as t,disposeMaybe as s,isSome as i}from"../../../../core/maybe.js";import r from"../../../../core/PooledArray.js";import{b as n,l as o,g as a,o as h,e as l,p as c}from"../../../../chunks/vec3.js";import{c as d}from"../../../../chunks/vec3f64.js";import{s as u}from"../../../../chunks/vec4.js";import{create as p,offset as g,contains as m,containsPoint as _,set as f,POSITIVE_INFINITY as P,equals as b}from"../../../../geometry/support/aaBoundingBox.js";import{create as S}from"../../../../geometry/support/plane.js";import{fromPoints as x}from"../../../../geometry/support/ray.js";import{PointHighlights as z}from"./PointHighlights.js";import{minimumDistancePlane as R,maximumDistancePlane as q,intersectLine as w,toAaBoundingBox as y}from"../../support/orientedBoundingBox.js";import{ShaderOutput as A}from"../../webgl-engine/core/shaderLibrary/ShaderOutput.js";import{Default3D as j}from"../../webgl-engine/lib/DefaultVertexAttributeLocations.js";import{newIntersectorResult as I}from"../../webgl-engine/lib/Intersector.js";import{IntersectorType as F,StoreResults as v}from"../../webgl-engine/lib/IntersectorInterfaces.js";import{VertexArrayObject as C}from"../../webgl-engine/lib/VertexArrayObject.js";import{VertexAttribute as E}from"../../webgl-engine/lib/VertexAttribute.js";import{P as H,a as N,g as O}from"../../../../chunks/PointRenderer.glsl.js";import{PointRendererTechnique as T}from"../../webgl-engine/shaders/PointRendererTechnique.js";import{PointRendererTechniqueConfiguration as L}from"../../webgl-engine/shaders/PointRendererTechniqueConfiguration.js";import{BufferObject as B}from"../../../webgl/BufferObject.js";import{DataType as D,PrimitiveType as M,Usage as U}from"../../../webgl/enums.js";import{VertexElementDescriptor as V}from"../../../webgl/VertexElementDescriptor.js";const W={positions:[new V(E.POSITION,3,D.FLOAT,0,12)],colors:[new V(E.COLOR,3,D.UNSIGNED_BYTE,0,3,!0)]};class k{constructor(e){this._params=e,this.type=F.PCL,this.isGround=!1,this._passParameters=new H,this._highlights=new z({forEachNode:e=>this.forEachNode(e),addHighlight:(e,t,s)=>this._addHighlight(e,t,s),removeHighlight:(e,t)=>this._removeHighlight(e,t)}),this.canRender=!0,this.layerUid="",this._slicePlaneEnabled=!1,this._techniqueConfig=new L,this._nodes=new r}get needsHighlight(){return this._highlights.hasHighlights}initializeRenderContext(e){this._context=e,this._techniqueRep=this._context.shaderTechniqueRepository,e.requestRender()}uninitializeRenderContext(){}intersect(e,t,s,i){const r=d(),f=d(),P=d(),b=d(),z=S(),A=e.camera.perScreenPixelRatio/2,j=e.camera.near;n(f,i,s);const F=1/o(f);a(f,f,F),h(P,f),u(z,f[0],f[1],f[2],-l(f,s));const C=new ee,E=new ee,H=new Array,N=p(),O=p(this._passParameters.clipBox);g(O,-s[0],-s[1],-s[2],O),this._nodes.forAll((o=>{const a=o.splatSize*this._passParameters.scaleFactor;let h=R(o.obb,z),d=q(o.obb,z);h-=K(a,h+j,this._passParameters,A,o.isLeaf),d-=K(a,d+j,this._passParameters,A,o.isLeaf);const u=d<0,p=null!=C.dist&&null!=E.dist&&C.dist<h*F&&E.dist>d*F;if(u||p)return;const S=J(a,d+j,this._passParameters,A,o.isLeaf);if(!w(o.obb,s,f,S))return;const x=S*S;y(o.obb,N),g(N,-s[0],-s[1],-s[2],N);const I=!m(O,N);n(b,o.origin,s);const T=o.coordinates.length/3;for(let n=0;n<T;n++){if(r[0]=b[0]+o.coordinates[3*n],r[1]=b[1]+o.coordinates[3*n+1],r[2]=b[2]+o.coordinates[3*n+2],I&&!_(O,r))continue;const h=l(r,f),d=c(r)-h*h;if(d>x)continue;let u=h+j;const p=K(a,u,this._passParameters,A,o.isLeaf);if(h-p<0)continue;u-=p;const g=J(a,u,this._passParameters,A,o.isLeaf);if(d>g*g)continue;const m=(h-p)*F,S=e=>(e.point=Q(o,n,e.point),e.dist=m,e.normal=P,e.node=o,e.pointId=n,e.layerUid=this.layerUid,e);if((null==C.dist||m<C.dist)&&(null==t||t(s,i,m))&&S(C),e.options.store!==v.MIN&&(null==E.dist||m>E.dist)&&(null==t||t(s,i,m))&&S(E),e.options.store===v.ALL&&(null==t||t(s,i,m))){const e=new ee;H.push(S(e))}}}));const T=e=>{const{layerUid:t,node:s,pointId:i}=e;return{point:e.point,layerUid:t,graphicUid:i,createGraphic:()=>this._params.createGraphic(s,i,e.point)}},L=(e,t)=>{const s=T(t);e.set(this.type,s,t.dist,t.normal)};if(te(C)){const t=e.results.min;(null==t.dist||C.dist<t.dist)&&L(t,C)}if(te(E)&&e.options.store!==v.MIN){const t=e.results.max;(null==t.dist||E.dist>t.dist)&&L(t,E)}if(e.options.store===v.ALL){const t=x(s,i);for(const s of H){const i=I(t);L(i,s),e.results.all.push(i)}}}prepareTechnique(e){return 0===this._nodes.length||e.output!==A.Color&&e.output!==A.Depth&&e.output!==A.Highlight?null:(this._nodes.forAll((t=>{null==t.vao&&this._initNode(e,t)})),this._techniqueConfig.drawScreenSize=this._passParameters.drawScreenSpace,this._techniqueConfig.useFixedSizes=this._passParameters.useFixedSizes,this._techniqueConfig.hasSlicePlane=this._slicePlaneEnabled,this._techniqueConfig.hasOccludees=e.bindParameters.hasOccludees,this._techniqueConfig.clippingEnabled=this._clippingEnabled,this._techniqueConfig.output=e.output===A.Depth?A.Depth:e.output===A.Highlight?A.Highlight:A.Color,this._techniqueRep.releaseAndAcquire(T,this._techniqueConfig,this._technique))}render(e,t){const s=e.rctx,i=s.bindTechnique(t,this._passParameters,e.bindParameters),r=e.output===A.Highlight;this._nodes.forAll((t=>{0===t.coordinates.length||r&&!t.highlights||(i.bindDraw(t,e.bindParameters,this._passParameters),s.bindVAO(t.vao),r?this._renderHighlightFragments(s,t):s.drawArrays(M.POINTS,0,t.coordinates.length/3))}))}_renderHighlightFragments(s,i){const r=i.highlights;if(e(r))return;let n=t(r[0].component),o=n+1;for(let e=1;e<r.length;e++){const i=t(r[e].component);if(i!==o){const e=o-n;e>0&&s.drawArrays(M.POINTS,n,e),n=i}o=i+1}const a=o-n;a>0&&s.drawArrays(M.POINTS,n,a)}set useFixedSizes(e){this._passParameters.useFixedSizes!==e&&(this._passParameters.useFixedSizes=e,this._requestRender())}get useFixedSizes(){return this._passParameters.useFixedSizes}set scaleFactor(e){this._passParameters.scaleFactor!==e&&(this._passParameters.scaleFactor=e,this._requestRender())}get scaleFactor(){return this._passParameters.scaleFactor}set minSizePx(e){this._passParameters.minSizePx!==e&&(this._passParameters.minSizePx=e,this._requestRender())}get minSizePx(){return this._passParameters.minSizePx}set useRealWorldSymbolSizes(e){this._passParameters.useRealWorldSymbolSizes!==e&&(this._passParameters.useRealWorldSymbolSizes=e,this._requestRender())}get useRealWorldSymbolSizes(){return this._passParameters.useRealWorldSymbolSizes}set size(e){this._passParameters.size!==e&&(this._passParameters.size=e,this._requestRender())}get size(){return this._passParameters.size}set sizePx(e){this._passParameters.sizePx!==e&&(this._passParameters.sizePx=e,this._requestRender())}get sizePx(){return this._passParameters.sizePx}set clippingBox(e){f(this._passParameters.clipBox,e||P)}get _clippingEnabled(){return!b(this._passParameters.clipBox,P,((e,t)=>e===t))}get slicePlaneEnabled(){return this._slicePlaneEnabled}set slicePlaneEnabled(e){this._slicePlaneEnabled!==e&&(this._slicePlaneEnabled=e,this._requestRender())}addNode(e){this._nodes.push(e),this._highlights.nodeAdded(e),this._requestRender()}removeNode(e){let t=null;return this._nodes.filterInPlace((i=>i.id!==e||(t=i,i.vao=s(i.vao),this._highlights.nodeRemoved(i),!1))),this._requestRender(),t}forEachNode(e){this._nodes.forAll(e)}removeAll(){this._nodes.forAll((e=>e.vao=s(e.vao))),this._highlights.removeAll(),this._nodes.clear(),this._requestRender()}highlight(e){return this._highlights.add(e)}_addHighlight(e,t,s){e.highlights=Z(e.highlights,t,s),this._requestRender()}_removeHighlight(e,t){e.highlights=$(e.highlights,t),this._requestRender()}_initNode(e,t){const s=e.rctx;t.vao=new C(s,j,W,{positions:B.createVertex(s,U.STATIC_DRAW,t.coordinates),colors:B.createVertex(s,U.STATIC_DRAW,t.rgb)})}_requestRender(){this._context&&this._context.requestRender()}}class G extends N{constructor(e,t,s,i,r,n,o,a,h=null,l=null){super(s,r,t),this.id=e,this.obb=i,this.coordinates=n,this.rgb=o,this.attributes=a,this.pointIdFilterMap=h,this.highlights=l}}function Y(e){return e.hasOwnProperty("splatSize")}function J(e,t,s,i,r){if(s.drawScreenSpace)return s.fixedSize*t*i;const n=O(r)*t*i;return s.useFixedSizes?Math.min(s.fixedSize/2,n):s.screenMinSize>0?Math.min(Math.max(s.screenMinSize*t*i,e/2),n):Math.min(e/2,n)}function K(e,t,s,i,r){return s.drawScreenSpace?0:J(e,t,s,i,r)}function Q(t,s,i){return e(i)&&(i=d()),i[0]=t.origin[0]+t.coordinates[3*s],i[1]=t.origin[1]+t.coordinates[3*s+1],i[2]=t.origin[2]+t.coordinates[3*s+2],i}function X(e){return i(e.component)?e.component:-1}function Z(t,s,i){e(t)&&(t=[]);const r={component:s,id:i};t.push(r);const n=X(r);let o=t.length-1;for(;o>0&&n<X(t[o-1]);)[t[o-1],t[o]]=[t[o],t[o-1]],--o;return t}function $(t,s){if(e(t))return t;const i=t.filter((e=>e.id!==s));return 0===i.length?null:i}class ee{constructor(){this.node=null,this.pointId=null,this.point=null,this.dist=null,this.normal=null,this.layerUid=""}}function te(e){return i(e.dist)&&i(e.point)&&i(e.pointId)&&i(e.node)}export{k as PointRenderer,G as PointRendererNode,Y as isInstanceOfNode};
