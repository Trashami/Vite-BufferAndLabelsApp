/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import e from"../../../Camera.js";import"../../../geometry.js";import t from"../../../Graphic.js";import n from"../../../Viewpoint.js";import{result as r}from"../../../core/asyncUtils.js";import"../../../core/has.js";import{cyclicalDegrees as a}from"../../../core/Cyclical.js";import o from"../../../core/Error.js";import{isSome as i,isNone as s,unwrapOr as c,unwrap as l}from"../../../core/maybe.js";import{eachAlways as m}from"../../../core/promiseUtils.js";import{f,t as u}from"../../../chunks/mat3.js";import{c as p}from"../../../chunks/mat3f64.js";import{c as g}from"../../../chunks/mat4f64.js";import{g as h,a as y,i as d,c as x,b as w,s as v,t as b}from"../../../chunks/vec3.js";import{c as j}from"../../../chunks/vec3f64.js";import{projectVectorToPoint as R,projectPointToVector as G,projectBuffer as z,computeTranslationToOriginAndRotation as S,projectVectorToVector as B}from"../../../geometry/projection.js";import{create as k,empty as M,center as Z,toRect as A,isPoint as F,expandWithVec3 as T,expandWithAABB as E,width as U,height as D,depth as O}from"../../../geometry/support/aaBoundingBox.js";import{create as C,isPoint as P}from"../../../geometry/support/aaBoundingRect.js";import{intersectsPoint as I}from"../../../geometry/support/frustum.js";import{getResolutionInMetersForScale as J}from"../../../geometry/support/scaleUtils.js";import{project as K,canProject as L}from"../../../geometry/support/webMercatorUtils.js";import{cameraOnContentAlongViewDirection as N}from"../camera/intersectionUtils.js";import{internalToExternal as V,OrientationMode as W,scaleToDistance as Y,fromCenterDistance as $,fromExtent as q,externalToInternal as X,computeScale as _,AsyncContext as H,distanceToScale as Q,fromCenterScale as ee,directionToHeadingTilt as te,zoomToScale as ne}from"./cameraUtils.js";import{getElevationAtPoint as re}from"./ElevationProvider.js";import ae from"../../../geometry/Point.js";import oe from"../../../geometry/SpatialReference.js";import ie from"../../../geometry/Extent.js";import se from"../../../geometry/Geometry.js";const ce=.66;function le(e){return 360-a.normalize(e)}function me(e){return a.normalize(360-e)}function fe(e){return i(e)&&e.resolver&&e.resolver.reject(),null}function ue(e,t){return i(e)&&e.resolver&&e.resolver.resolve(t),t}function pe(e,t,n,r=null){if(!t)return fe(r);const a=e.spatialReference||oe.WGS84;if(i(t.camera)){const e=K(t.camera.position,a);if(s(e))return fe(r);const n=t.camera.clone();return n.position=e,ue(r,n)}if(s(t.targetGeometry))return fe(r);const o=t.get("targetGeometry.spatialReference");if(o&&!L(o,a))return fe(r);const c=V(e,e.state.camera);let l=W.ADJUST;if(null!=t.rotation&&(c.heading=le(t.rotation),l=W.LOCKED),null!=n&&(c.tilt=n),"point"===t.targetGeometry.type){const n=t.targetGeometry;let a;const o=t.targetGeometry.clone();return a=null!=t.scale?Y(e,t.scale,n.latitude):e.state.camera.distance,$(e,o,a,c,l,r)}const m=t.targetGeometry.extent;return q(e,m,c.heading,c.tilt,l,r)}function ge(e,t,r=null){return s(r)&&(r=new n),we(e,null,t.clone(),r)}async function he(t,r,a){const i=Fe(t,r);if(!i)throw new o("viewpointutils-create:no-target","Missing target for creating viewpoint");const s=new e({fov:t.camera.fov}),c=new n({camera:s});if(i.target instanceof n){return Te(await Re(t,i.target,i,a,c))}if(i.target instanceof e)return Te(Ge(t,i.target,c));const l=null!=i.scale||null!=i.zoom;if(i.target instanceof ie){const e=i.target.xmin===i.target.xmax||i.target.ymin===i.target.ymax;return Te(l||e?await Se(t,i,i.target.center,s,a,c):await Me(t,i,i.target,s,a,c))}const m={boundingBox:M(),hasZ:!1,screenSpaceObjects:[]},f=l?de(t,i):void 0;if(await je(t,i.target,f,m),isFinite(m.boundingBox[0])){let e;if(Z(m.boundingBox,Ue),Ne.x=Ue[0],Ne.y=Ue[1],Ne.z=Ue[2],Ne.spatialReference=t.spatialReference,isFinite(Ne.z)&&m.hasZ?e=F(m.boundingBox):(Ne.z=void 0,e=P(A(m.boundingBox,Pe))),l||e)return Te(await Se(t,i,Ne,s,a,c));const n=Ee(t,m.screenSpaceObjects);return Te(await Ae(t,i,Ne,m.boundingBox,n,s,a,c))}return i.position?Te(Be(t,i,s,c)):Te(await ke(t,i,s,a,c))}function ye(e,t){return null==t.scale&&null!=t.zoom?ne(e,t.zoom):t.scale}function de(e,t){return J(ye(e,t))}function xe(e,t){let n=!1;return null!=t.heading?(e.heading=t.heading,n=!0):null!=t.rotation&&(e.heading=le(t.rotation),n=!0),null!=t.tilt&&(e.tilt=t.tilt,n=!0),null!=t.fov&&(e.fov=t.fov),n}function we(e,t,n,r){const a=e.spatialReference||oe.WGS84;return t=i(t)?t:X(e,n),s(t)||(r.targetGeometry=R(t.center,e.renderSpatialReference,a),r.scale=_(e,t),r.rotation=me(n.heading),r.camera=n),r}function ve(e,t,n){const r=()=>new o("viewpointutils:invalid-geometry","The target is missing a valid geometry");if(!t)throw r();if(!L(t.spatialReference,e.spatialReference))throw new o("viewpointutils:incompatible-spatialreference",`Spatial reference (${t.spatialReference?t.spatialReference.wkid:"unknown"}) is incompatible with the view (${e.spatialReference.wkid})`,{geometry:t});const a=[];if(!t.hasZ&&e.basemapTerrain){let n;switch(t.type){case"point":n=t;break;case"multipoint":case"polyline":n=t.extent?.center;break;case"mesh":n=t.origin;break;case"extent":n=t.center;break;case"polygon":n=t.centroid}n&&i(e.basemapTerrain.spatialReference)&&L(n,e.basemapTerrain.spatialReference)?Ue[2]=c(re(e.elevationProvider,n),0):Ue[2]=0}(0,Ve[t.type])(t,(e=>{a.push(e[0],e[1],e[2])}),Ue);const s=a.length/3;if(0===s)throw r();const l=new Array(a.length);if(z(a,t.spatialReference,0,l,e.spatialReference,0,s)){t.hasZ&&(n.hasZ=!0);for(let e=0;e<l.length;e+=3)t.hasZ?(Ue[0]=l[e+0],Ue[1]=l[e+1],Ue[2]=l[e+2]):(Ue[0]=l[e+0],Ue[1]=l[e+1]),T(n.boundingBox,Ue)}}async function be(e,t,n,a){const o=await r(e.whenViewForGraphic(t));if(!1===o.ok||s(o.value)||!("whenGraphicBounds"in o.value))return void ve(e,t.geometry,a);const i=o.value,c=await r(i.whenGraphicBounds(t,{minDemResolution:n}));if(!1===c.ok)return void ve(e,t.geometry,a);const{screenSpaceObjects:l,boundingBox:m}=c.value;E(a.boundingBox,m),l&&l.forEach((e=>{a.screenSpaceObjects.push(e)})),isFinite(m[2])&&(a.hasZ=!0)}async function je(e,n,r,a){if(Array.isArray(n)&&2===n.length){const t=n[0],r=n[1];if("number"==typeof t&&"number"==typeof r)return Ne.x=t,Ne.y=r,Ne.z=void 0,Ne.spatialReference=e.spatialReference.isGeographic?e.spatialReference:oe.WGS84,void ve(e,Ne,a)}n&&"function"==typeof n.map?await m(n.map((t=>je(e,t,r,a)))):n instanceof se?ve(e,n,a):n instanceof t&&await be(e,n,r,a)}async function Re(e,t,n,r,a){if(i(t.camera))return Ge(e,t.camera,a);a.scale=t.scale,a.rotation=t.rotation,a.targetGeometry=i(t.targetGeometry)?t.targetGeometry.clone():null,a.camera=null,null!=n.heading?a.rotation=me(n.heading):null!=n.rotation&&(a.rotation=n.rotation);const o=ye(e,n);null!=o&&(a.scale=o);const s=new H(r);return pe(e,a,n.tilt,s),a.camera=await s.resolver.promise,a}function Ge(e,t,n){const r=e.spatialReference,a=K(t.position,r);return s(a)?null:((t=t.clone()).fov=e.camera.fov,t.position=a,we(e,null,t,n))}function ze(e,t,n,r,a,o){const i=e.renderSpatialReference;return G(n.position,Je,i),G(t,Ke,i),o.targetGeometry=new ae(t),a.position=new ae(n.position),w(Ie,Ke,Je),te(e,Je,Ie,r.up,a),o.scale=Q(e,d(Je,Ke),o.targetGeometry.latitude),o.rotation=me(a.heading),o.camera=a,o}async function Se(e,t,n,r,a,i){if(s(n))throw new o("createfromcenter","invalid point");i.targetGeometry=n.clone();const c=N(e);if(t.position)return ze(e,i.targetGeometry,t,c,r,i);if(t.zoomFactor){const r=c.distance/t.zoomFactor,a=h(Ue,c.viewForward,-r);c.eye=y(Ue,c.center,a),i.scale=Q(e,r,n.latitude)}V(e,c,r);const l=xe(r,t)?W.LOCKED:W.ADJUST;if(!t.zoomFactor){i.scale=ye(e,t),null==i.scale&&(G(n,Ue,e.renderSpatialReference),I(c.frustum,Ue)?i.scale=Q(e,d(c.eye,Ue),n.latitude):i.scale=_(e,c));const o=new H(a);ee(e,i.targetGeometry,i.scale,r,l,o),i.camera=await o.resolver.promise}return i}function Be(e,t,n,r){const a=N(e);return x(Ie,a.viewForward),te(e,a.eye,Ie,a.up,Le),n.position=new ae(t.position),n.heading=null!=t.heading?t.heading:Le.heading,n.tilt=null!=t.tilt?t.tilt:Le.tilt,we(e,null,n,r)}async function ke(e,t,n,r,a){const o=N(e);return Se(e,t,R(o.center,e.renderSpatialReference,e.spatialReference),n,r,a)}async function Me(e,t,n,r,a,o){o.targetGeometry=n.clone();const i=N(e);V(e,i,r);const s=xe(r,t)?W.LOCKED:W.ADJUST,c=new H(a);return q(e,n,r.heading,r.tilt,s,c),o.camera=await c.resolver.promise,o}function Ze(e,t,n,r,a){let o=0;n.hasZ?o=n.z:e.basemapTerrain&&(o=l(re(e.elevationProvider,n))),v(Ue,n.x,n.y,o),S(e.spatialReference,Ue,De,e.renderSpatialReference),f(Oe,De),u(Oe,Oe),M(Ce);const i=[[0,1,2],[3,1,2],[0,4,2],[3,4,2],[0,1,5],[3,1,5],[0,4,5],[3,4,5]];for(let l=0;l<i.length;l++){const t=i[l];let n=r[t[2]];isFinite(n)||(n=o),v(Ue,r[t[0]],r[t[1]],n),B(Ue,e.spatialReference,Ue,e.renderSpatialReference),T(Ce,b(Ue,Ue,Oe))}const s=U(Ce),c=D(Ce),m=O(Ce),p=1/Math.tan(t.fovX/2),g=1/Math.tan(t.fovY/2),h=.5*Math.sqrt(s*s+m*m)*Math.max(g,p)+.5*c,y=.5*c*g+.5*Math.max(s,m);return Math.max(h,y)/a}async function Ae(e,t,n,r,a,o,i,s){s.targetGeometry=n.clone();const c=N(e),l=Ze(e,c,n,r,a);V(e,c,o);const m=xe(o,t)?W.LOCKED:W.ADJUST;s.scale=Q(e,l,s.targetGeometry.latitude);const f=new H(i);return ee(e,s.targetGeometry,s.scale,o,m,f),s.camera=await f.resolver.promise,s}function Fe(e,t){if(!t||!e.spatialReference)return null;const n={target:null};if("declaredClass"in t||Array.isArray(t))n.target=t;else{for(const e in t)n[e]=t[e];t.center&&!n.target&&(n.target=t.center)}return n}function Te(e){return e&&i(e.camera)&&(e.rotation=me(e.camera.heading)),e}function Ee(e,t){const n=ce;if(!t.length)return n;let r=Number.NEGATIVE_INFINITY;for(let a=0;a<t.length;a++){const e=t[a].screenSpaceBoundingRect;r=Math.max(r,Math.abs(e[0]),Math.abs(e[1]),Math.abs(e[2]),Math.abs(e[3]))}return n-r/Math.min(e.width,e.height)*2}const Ue=j(),De=g(),Oe=p(),Ce=k(),Pe=C(),Ie=j(),Je=j(),Ke=j(),Le={heading:0,tilt:0},Ne=new ae,Ve={point(e,t,n){n[0]=e.x,n[1]=e.y,e.hasZ&&(n[2]=e.z),t(n)},polygon(e,t,n){const r=e.hasZ;for(let a=0;a<e.rings.length;a++){const o=e.rings[a];for(let e=0;e<o.length;e++)n[0]=o[e][0],n[1]=o[e][1],r&&(n[2]=o[e][2]),t(n)}},polyline(e,t,n){const r=e.hasZ;for(let a=0;a<e.paths.length;a++){const o=e.paths[a];for(let e=0;e<o.length;e++)n[0]=o[e][0],n[1]=o[e][1],r&&(n[2]=o[e][2]),t(n)}},multipoint(e,t,n){const r=e.points,a=e.hasZ;for(let o=0;o<r.length;o++)n[0]=r[o][0],n[1]=r[o][1],a&&(n[2]=r[o][2]),t(n)},extent(e,t,n){e.hasZ?(t(v(n,e.xmin,e.ymin,e.zmin)),t(v(n,e.xmax,e.ymin,e.zmin)),t(v(n,e.xmin,e.ymax,e.zmin)),t(v(n,e.xmax,e.ymax,e.zmin)),t(v(n,e.xmin,e.ymin,e.zmax)),t(v(n,e.xmax,e.ymin,e.zmax)),t(v(n,e.xmin,e.ymax,e.zmax)),t(v(n,e.xmax,e.ymax,e.zmax))):(t(v(n,e.xmin,e.ymin,n[2])),t(v(n,e.xmax,e.ymin,n[2])),t(v(n,e.xmin,e.ymax,n[2])),t(v(n,e.xmax,e.ymax,n[2])))},mesh(e,t,n){const r=e.vertexAttributes&&e.vertexAttributes.position;if(r)for(let a=0;a<r.length;a+=3)t(v(n,r[a+0],r[a+1],r[a+2]))}};export{he as create,ge as fromCamera,me as headingToRotation,le as rotationToHeading,pe as toCamera};
