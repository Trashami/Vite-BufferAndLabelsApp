/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{LengthDimensionMeasureType as e}from"../../../../analysis/dimensionUtils.js";import{deg2rad as t}from"../../../../core/mathUtils.js";import{isNone as n,isSome as r,unwrapOr as i}from"../../../../core/maybe.js";import{toUnit as o}from"../../../../core/quantityUtils.js";import{preferredVerticalLengthUnit as a,preferredLengthUnit as s}from"../../../../core/unitUtils.js";import{d}from"../../../../chunks/mat4.js";import{c}from"../../../../chunks/mat4f64.js";import{c as l,z as p,y as m,F as u,e as S,E as f,m as g,f as v,n as R,p as A}from"../../../../chunks/vec3.js";import{c as P,Z as y}from"../../../../chunks/vec3f64.js";import{Axis as E}from"../../../../geometry/support/Axis.js";import{sv3d as j}from"../../../../geometry/support/vectorStacks.js";import{makeDehydratedPoint as h}from"../../../../layers/graphics/dehydratedFeatures.js";import{clonePoint as x}from"../../../../layers/graphics/hydratedFeatures.js";import{EuclideanSegment as T}from"../../interactive/visualElements/support/Segment.js";import{euclideanDirectDistance as C,euclideanDirectDistanceBetweenPoints as H}from"../../../support/euclideanLengthMeasurementUtils.js";function w(t,r,i){if(n(t))return null;const d=t.dimensionSegment.startRenderSpace,c=t.dimensionSegment.endRenderSpace,l=C(d,c,t.spatialReference);if(n(l))return null;const p=r===e.Vertical?a(l.value,l.unit,i):s(l.value,l.unit,i);return o(l,p)}function z(e){const{elevationAlignedStartPoint:t,elevationAlignedEndPoint:n,dimension:{offset:r,measureType:i,orientation:o}}=e;return{elevationAlignedStartPoint:t,elevationAlignedEndPoint:n,offset:r,measureType:i,orientation:o}}function k({elevationAlignedStartPoint:t,elevationAlignedEndPoint:i,offset:o,measureType:a,orientation:s},d,c=null){if(n(t)||n(i))return null;const p=D(r(c)?c.directSegment:new T,{elevationAlignedStartPoint:t,elevationAlignedEndPoint:i},d),m=r(c)?c.primaryOffsetAxis:P();L(m,{measureType:a,elevationAlignedStartPoint:t,elevationAlignedEndPoint:i,directSegment:p,orientation:s,renderCoordsHelper:d});const u=r(c)?c.dimensionSegment:new T;return Z({elevationAlignedStartPoint:t,elevationAlignedEndPoint:i})&&a===e.Vertical?(l(u.startRenderSpace,p.startRenderSpace),l(u.endRenderSpace,p.endRenderSpace)):G(u,{offsetAxis:m,offset:o,relativeToSegment:p,renderCoordsHelper:d}),{directSegment:p,dimensionSegment:u,primaryOffsetAxis:m,spatialReference:d.spatialReference}}function U(e,t,n,r){return t===b.Start?(l(e.startRenderSpace,n.startRenderSpace),l(e.endRenderSpace,r.startRenderSpace)):(l(e.startRenderSpace,n.endRenderSpace),l(e.endRenderSpace,r.endRenderSpace)),e}var b;function M(e,t,n,r){p(e.startRenderSpace,t.startRenderSpace,n,r),p(e.endRenderSpace,t.endRenderSpace,n,r)}function V(t,n,r,i){switch(n){case e.Direct:return D(t,r,i);case e.Horizontal:case e.Vertical:{const{elevationAlignedStartPoint:o,elevationAlignedEndPoint:a,dimension:s,geometry:d}=r;let c;if(s.measureType===e.Direct){c=F(d,i)===o.z>a.z,n===e.Horizontal&&(c=!c)}else c=!O(d);const[l,p]=c?[o,a]:[a,o],m=x(p,I);return n===e.Horizontal?m.z=l.z:(m.x=l.x,m.y=l.y),i.toRenderCoords(l,t.startRenderSpace),i.toRenderCoords(m,t.endRenderSpace),t}}}function D(e,t,n){return n.toRenderCoords(t.elevationAlignedStartPoint,e.startRenderSpace),n.toRenderCoords(t.elevationAlignedEndPoint,e.endRenderSpace),e}function F(e,t){const n=e.directSegment.eval(.5,j.get()),r=t.worldUpAtPosition(n,j.get()),i=e.dimensionSegment.eval(.5,j.get()),o=m(j.get(),i,n);return!u(o,y)&&S(o,r)>0}function O(e){const{startRenderSpace:t,endRenderSpace:n}=e.dimensionSegment,{startRenderSpace:r,endRenderSpace:i}=e.directSegment;return f(r,t)<f(i,n)}!function(e){e[e.Start=0]="Start",e[e.End=1]="End"}(b||(b={}));const I=h(0,0,0,null);function q(e,t,n,r){const{directSegment:i}=n,o=L(j.get(),{measureType:t,directSegment:i,renderCoordsHelper:r}),a=G(B,{offsetAxis:o,offset:0,relativeToSegment:i,renderCoordsHelper:r}).eval(.5,j.get()),s=m(j.get(),e,a);return S(s,o)*r.unitInMeters}const B=new T;function L(n,r){const{measureType:o,elevationAlignedStartPoint:a,elevationAlignedEndPoint:s,directSegment:{startRenderSpace:c,endRenderSpace:p},directSegment:f,renderCoordsHelper:A}=r,P=f.eval(.5,j.get()),h=A.worldUpAtPosition(P,j.get()),x=A.worldBasisAtPosition(P,E.Y,j.get());switch(o){case e.Horizontal:l(n,h);break;case e.Vertical:S(c,h)<S(p,h)?m(n,p,c):m(n,c,p),v(n,n,h),v(n,n,h);break;case e.Direct:{const e=i(r.orientation,0);if(Z({elevationAlignedStartPoint:a,elevationAlignedEndPoint:s}))d(Y,-t(e),h),g(n,x,Y);else{const r=m(j.get(),p,c),i=v(j.get(),r,h);v(i,i,r),d(Y,t(e),r),g(n,i,Y)}break}}return u(n,y)?l(n,x):R(n,n)}const Y=c();function Z({elevationAlignedStartPoint:e,elevationAlignedEndPoint:t}){return r(e)&&r(t)&&e.x===t.x&&e.y===t.y}function G(e,t){const{offsetAxis:n,offset:r,relativeToSegment:{startRenderSpace:i,endRenderSpace:o},relativeToSegment:a,renderCoordsHelper:s}=t,d=r/s.unitInMeters,[c,l]=J(i,o,n,d);return p(e.startRenderSpace,a.startRenderSpace,n,c),p(e.endRenderSpace,a.endRenderSpace,n,l),e}function J(e,t,n,r=0){const i=S(t,n),o=S(e,n),a=Math.abs(i-o)+r;return i>o?[a,r]:[r,a]}function K(e,t,n){const r=t.directSegment.eval(.5,j.get());return n.worldUpAtPosition(r,e)}function N(e,t){const{startRenderSpace:n,endRenderSpace:r}=t.directSegment;return m(e,r,n)}function Q(e,t,n={invert:!1}){const{startRenderSpace:r,endRenderSpace:i}=t.dimensionSegment;return n.invert?m(e,r,i):m(e,i,r)}function W(e,t){const n=e.directSegment.eval(.5,j.get());return t.headingAtPosition(n,e.primaryOffsetAxis)}function X(e,t){return A(Q($,e))/t**2}const $=P();function _(e){const{elevationAlignedStartPoint:t,elevationAlignedEndPoint:i}=e;if(n(t)||n(i))return!1;const a=H(t,i);return r(a)&&o(a,"meters").value>ee}const ee=1e5;function te(e){return r(e.geometry)}export{ee as GEODESIC_DISTANCE_THRESHOLD,b as OffsetSegmentLocation,Z as arePointsVerticallyAligned,z as computationToGeometryDependencies,k as computeGeometryFromDimension,w as computeLength,L as computeOffsetAxis,q as computeOffsetForPoint,V as computeSegmentForMeasureType,U as computeSpanningSegment,Q as dimensionStartToEnd,N as directStartToEnd,K as directUp,W as headingFromGeometry,_ as isGeodesicDimension,te as isValidComputation,X as maxScreenLengthSquaredFromGeometry,M as offsetSegment};
