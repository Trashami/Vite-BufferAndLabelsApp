/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../chunks/tslib.es6.js";import i from"../../../../analysis/SlicePlane.js";import a from"../../../../core/Accessor.js";import t from"../../../../core/Handles.js";import s from"../../../../core/Logger.js";import{isNone as l,isSome as n}from"../../../../core/maybe.js";import{watch as r}from"../../../../core/reactiveUtils.js";import{property as o}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/arrayUtils.js";import"../../../../core/accessorSupport/ensureType.js";import{subclass as c}from"../../../../core/accessorSupport/decorators/subclass.js";import{a as h}from"../../../../chunks/boundedPlane.js";import d from"../../../../layers/Layer.js";import u from"../../../../layers/buildingSublayers/BuildingComponentSublayer.js";import{isIBuildingSceneLayerView3D as p,projectAndElevationAlignShape as y,projectedShapeToPlane as w,planeToShape as v}from"./sliceToolUtils.js";import{logFailedGeometryProjectionError as f}from"../support/projectionUtils.js";import{isTerrainSurfaceLayer as m}from"../../terrain/isTerrainSurfaceLayer.js";const _="esri.views.3d.analysis.Slice.SliceController",V=s.getLogger(_);let g=class extends a{constructor(e){super(e),this._handles=new t,this._internalChange=!1,this._currentSlicePlane=null}initialize(){this._handles.add(this.analysis.excludedLayers.on("before-add",(e=>{const i=e.item;null!=i&&(i instanceof d||i instanceof u)?i instanceof d&&m(i)?(V.error("excludedLayers",`Layer '${i.title}, id:${i.id}' of type '${i.type}' can not be individually excluded from slicing. Use 'excludeGroundSurface' instead.`),e.preventDefault()):this.analysis.excludedLayers.includes(i)&&e.preventDefault():(V.error("excludedLayers","Invalid layer type, layer must derive from Layer or BuildingComponentSublayer"),e.preventDefault())}))),L(this.view,this),this._handles.add([r((()=>this.analysisViewData.plane),(()=>{this._internalChange||this._updateSlicePlaneFromBoundedPlane(),this._updateLayerViews()}),{sync:!0}),r((()=>this.analysis.excludeGroundSurface),(()=>this._updateLayerViews()),{sync:!0}),this.analysis.excludedLayers.on("change",(()=>this._updateLayerViews())),r((()=>[this.analysisViewData.active,this.analysisViewData.visible]),(()=>{this._updateActiveController(),this._updateViewSlicePlane()}),{sync:!0}),r((()=>this._allLayerAndSubLayerViews),(()=>this._updateLayerViews()))]),this._handles.add([r((()=>this.analysis.shape),(()=>{this._internalChange||(this._updateBoundedPlaneFromSlicePlane(),this._updateViewSlicePlane())}),{sync:!0})],"analysis"),this._updateActiveController(),this._updateBoundedPlaneFromSlicePlane(),this._updateViewSlicePlane()}destroy(){this.analysisViewData.active&&(this.analysisViewData.active=!1,this.view.slicePlane=null),D(this.view,this),this._handles.destroy(),this.set("view",null)}get _allLayerAndSubLayerViews(){const e=this.view.allLayerViews.items;return e.concat(e.filter(p).flatMap((({sublayerViews:e})=>e.items)))}_updateBoundedPlaneFromSlicePlane(){const e=this.analysis.shape,i=this._currentSlicePlane;if(l(i)&&l(e)||n(i)&&n(e)&&e.equals(i))return;let a=null,t=null;if(n(e)&&n(e.position)){const i=e.position.spatialReference,s=y(e,this.view);l(s)&&f(this.analysis,i,V),a=w(s,this.view,{tiltEnabled:this.analysis.tiltEnabled},h()),n(a)&&(t={heading:e.heading,tilt:e.tilt,position:e.position,width:e.width,height:e.height})}this._currentSlicePlane=t,this._internalChange=!0,this.analysisViewData.plane=a,this._internalChange=!1}_updateSlicePlaneFromBoundedPlane(){const e=this.analysisViewData.plane,a=v(e,this.view,this.view.spatialReference,new i);let t=null;n(a)&&(t={heading:a.heading,tilt:a.tilt,position:a.position,width:a.width,height:a.height}),this._currentSlicePlane=t,this._internalChange=!0,this.analysis.shape=a,this._internalChange=!1,this._updateViewSlicePlane()}_updateActiveController(){if(S)return;const e=C(this.view);if(this.analysisViewData.active)n(e.activeController)&&e.activeController!==this?(S=!0,e.activeController.analysisViewData.active=!1,S=!1):n(e.activeController)&&e.activeController,this._updateLayerViews(),e.activeController=this;else{if(n(e.activeController)&&e.activeController!==this)return;n(e.activeController)&&e.activeController===this&&(e.activeController=null,this._updateLayerViews())}}_updateViewSlicePlane(){P(this.view)}_updateLayerViews(){const e=n(this.analysisViewData.plane)&&this.analysisViewData.visible&&this.analysisViewData.active,i=[],a=e=>{"layers"in e?e.layers.forEach(a):i.push(e)};this.analysis.excludedLayers.forEach(a),this.view.allLayerViews.forEach((a=>{a.destroyed||("slicePlaneEnabled"in a&&(a.slicePlaneEnabled=e&&!i.includes(a.layer)),"sublayerViews"in a&&a.sublayerViews.forEach((a=>{a.slicePlaneEnabled=e&&!i.includes(a.sublayer)})))})),null!=this.view.basemapTerrain&&(this.view.basemapTerrain.slicePlaneEnabled=e&&!this.analysis.excludeGroundSurface)}};e([o()],g.prototype,"view",void 0),e([o()],g.prototype,"analysis",void 0),e([o()],g.prototype,"analysisViewData",void 0),e([o()],g.prototype,"_allLayerAndSubLayerViews",null),g=e([c(_)],g);const b=new Map;let S=!1;function P(e){const i=C(e).activeController;n(i)&&n(i.analysisViewData.plane)&&i.analysisViewData.visible?e.slicePlane=i.analysisViewData.plane:e.slicePlane=null}function L(e,i){b.has(e)||b.set(e,{all:[],activeController:null}),b.get(e).all.push(i)}function C(e){return b.get(e)}function D(e,i){if(!b.has(e))throw new Error("view expected in global slice register");const a=b.get(e),t=a.all.lastIndexOf(i);if(-1===t)throw new Error("controller expected in global slice register");a.all.splice(t,1),0===a.all.length&&b.delete(e)}export{g as SliceController};
