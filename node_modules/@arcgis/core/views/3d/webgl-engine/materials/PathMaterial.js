/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{clamp as e}from"../../../../core/mathUtils.js";import{isNone as t}from"../../../../core/maybe.js";import{fromValues as r}from"../../../../geometry/support/aaBoundingBox.js";import{BufferViewVec4f as i}from"../../../../geometry/support/buffer/BufferView.js";import{newLayout as a}from"../../support/buffer/InterleavedLayout.js";import{ShaderOutput as s}from"../core/shaderLibrary/ShaderOutput.js";import{NormalsDoubleSidedMode as o}from"../core/shaderLibrary/shading/Normals.glsl.js";import{computeAttachmentOriginLines as n}from"../lib/geometryDataUtils.js";import h from"../lib/GLMaterial.js";import{Material as u}from"../lib/Material.js";import{isPathGeometry as c}from"../lib/PathGeometry.js";import{RenderSlot as l}from"../lib/RenderSlot.js";import{assert as d}from"../lib/Util.js";import{VertexAttribute as p}from"../lib/VertexAttribute.js";import{vertexAttributeLocations as m,PathTechniqueConfiguration as f,PathTechnique as b,PathPassParameters as v}from"./PathTechnique.js";import{writeDefaultAttributes as S,writeBufferVec4 as g}from"./internal/bufferWriterUtils.js";import{intersectAabbInvDir as A}from"./internal/MaterialUtil.js";class E extends u{constructor(e){super(e,new _),this.supportsEdges=!0,this._vertexAttributeLocations=m,this._configuration=new f,this._vertexBufferLayout=E.getVertexBufferLayout(this.parameters)}getConfiguration(e,t){return this._configuration.output=e,this._configuration.vvSize=this.parameters.vvSizeEnabled,this._configuration.vvColor=this.parameters.vvColorEnabled,this._configuration.vvOpacity=this.parameters.vvOpacityEnabled,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.transparent=this.parameters.transparent,this._configuration.hasOccludees=this.parameters.hasOccludees,e!==s.Color&&e!==s.Alpha||(this._configuration.doubleSidedMode=this.parameters.doubleSided&&"normal"===this.parameters.doubleSidedType?o.View:this.parameters.doubleSided&&"winding-order"===this.parameters.doubleSidedType?o.WindingOrder:o.None,this._configuration.receiveShadows=this.parameters.receiveShadows,this._configuration.receiveAmbientOcclusion=!!t.ssaoHelper.ready&&this.parameters.receiveSSAO),this._configuration.transparencyPassType=t.transparencyPassType,this._configuration.hasMultipassTerrain=t.multipassTerrain.enabled,this._configuration.cullAboveGround=t.multipassTerrain.cullAboveGround,this._configuration}isVisibleForOutput(e){return e!==s.Shadow&&e!==s.ShadowExludeHighlight&&e!==s.ShadowHighlight||this.parameters.castShadows}isVisible(){return super.isVisible()&&this.parameters.opacity>0}intersect(i,a,s,o,n,h,u){const l=i;if(!c(l))return;const d=l.path,p=[this.parameters.size[0],this.parameters.size[1]];if(this.parameters.vvSizeEnabled){const t=this.parameters.vvSizeOffset,r=this.parameters.vvSizeFactor,i=this.parameters.vvSizeMinSize,a=this.parameters.vvSizeMaxSize,s=d.sizeAttributeValue;p[0]*=e(t[0]+s*r[0],i[0],a[0]),p[1]*=e(t[2]+s*r[2],i[2],a[2])}const m=Math.max(p[0],p[1]),f=i.boundingInfo;if(t(f))return void this._intersectTriangles(d,p,n,h,u);const b=r(f.bbMin[0]-m,f.bbMin[1]-m,f.bbMin[2]-m,f.bbMax[0]+m,f.bbMax[1]+m,f.bbMax[2]+m),v=[h[0]-n[0],h[1]-n[1],h[2]-n[2]],S=Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]),g=[S/v[0],S/v[1],S/v[2]];A(b,n,g,o.tolerance)&&this._intersectTriangles(d,p,n,h,u)}_intersectTriangles(e,t,r,i,a){e.baked.size&&e.baked.size[0]===t[0]&&e.baked.size[1]===t[1]||e.baked.bake(t),e.baked.intersect(r,i,a)}computeAttachmentOrigin(e,t){const r=e.vertexAttributes;if(!r)return null;const i=r.get(p.POSITION);return n(i,null,!1,t)}createBufferWriter(){return new w(this._vertexBufferLayout)}requiresSlot(e,t){switch(t){case s.Shadow:case s.ShadowHighlight:case s.ShadowExludeHighlight:if(!this.parameters.castShadows)return!1;case s.Color:case s.Alpha:case s.Depth:case s.Normal:case s.Highlight:case s.ObjectAndLayerIdColor:return e===(this.parameters.transparent?l.TRANSPARENT_MATERIAL:l.OPAQUE_MATERIAL)||e===l.DRAPED_MATERIAL;default:return!1}}createGLMaterial(e){return new O(e)}static getVertexBufferLayout(e){const t=a().vec3f(p.POSITION).vec4f(p.PROFILERIGHT).vec4f(p.PROFILEUP).vec4f(p.PROFILEVERTEXANDNORMAL);return(e.vvColorEnabled||e.vvSizeEnabled||e.vvOpacityEnabled)&&t.vec4f(p.FEATUREVALUE),t}}class O extends h{_updateOccludeeState(e){e.hasOccludees!==this._material.parameters.hasOccludees&&this._material.setParameters({hasOccludees:e.hasOccludees})}_updateShadowState(e){(t(this.technique)||e.shadowMap.enabled!==this.technique.configuration.receiveShadows)&&this._material.setParameters({receiveShadows:e.shadowMap.enabled})}beginSlot(e){return this._output!==s.Color&&this._output!==s.Alpha||(this._updateShadowState(e),this._updateOccludeeState(e)),this.ensureTechnique(b,e)}}class _ extends v{constructor(){super(...arguments),this.doubleSided=!1,this.doubleSidedType="normal",this.receiveSSAO=!0,this.receiveShadows=!1,this.castShadows=!0,this.hasSlicePlane=!1,this.transparent=!1,this.hasOccludees=!1}}class w{constructor(e){this.vertexBufferLayout=e}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return e.indices.get(p.POSITION).length}write(e,t,r,i,a){y(p.PROFILERIGHT,r,i,a),y(p.PROFILEUP,r,i,a),y(p.PROFILEVERTEXANDNORMAL,r,i,a),this.vertexBufferLayout.hasField(p.FEATUREVALUE)&&y(p.FEATUREVALUE,r,i,a),S(r,this.vertexBufferLayout,e,t,i,a)}}function y(e,t,r,a){if(t.vertexAttributes.has(e)){const s=t.vertexAttributes.get(e),o=t.indices.get(e);d(4===s.size);const n=r.getField(e,i);if(!n)throw new Error("unable to acquire view for "+e);g(o,s.data,n,a)}}export{E as PathMaterial,_ as PathMaterialParameters};
