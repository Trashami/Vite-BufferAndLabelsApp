/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import has from"../../../../core/has.js";import{clamp as e}from"../../../../core/mathUtils.js";import{isSome as t,unwrapOr as r}from"../../../../core/maybe.js";import{f as s}from"../../../../chunks/mat3.js";import{c as i}from"../../../../chunks/mat3f64.js";import{a}from"../../../../chunks/mat4.js";import{c as n}from"../../../../chunks/mat4f64.js";import{c as o}from"../../../../chunks/vec2.js";import{a as c,f as l}from"../../../../chunks/vec2f64.js";import{s as f,m as u,n as h,b as p,g as d,c as m,l as g,i as O,t as S,e as v,a as A}from"../../../../chunks/vec3.js";import{c as b,f as P}from"../../../../chunks/vec3f64.js";import{c as x,f as y}from"../../../../chunks/vec4f64.js";import{isMat4 as I}from"../../../../core/libs/gl-matrix-2/types/mat4.js";import{create as _}from"../../../../geometry/support/aaBoundingRect.js";import{BufferViewVec4u8 as C}from"../../../../geometry/support/buffer/BufferView.js";import{newLayout as j}from"../../support/buffer/InterleavedLayout.js";import{ShaderOutput as z}from"../core/shaderLibrary/ShaderOutput.js";import{HUDSpace as T}from"../core/shaderLibrary/hud/HUD.glsl.js";import{computeAttachmentOriginPoints as L}from"../lib/geometryDataUtils.js";import{GLTextureMaterial as M,GLTextureMaterialBindParameters as D}from"../lib/GLTextureMaterial.js";import{Material as U,RenderOccludedFlag as E}from"../lib/Material.js";import{RenderSlot as w}from"../lib/RenderSlot.js";import{applyScaleFactor as R,applyPrecomputedScaleFactor as N,precomputeScaleFactor as V}from"../lib/screenSizePerspectiveUtils.js";import{assert as B}from"../lib/Util.js";import{VertexAttribute as G}from"../lib/VertexAttribute.js";import{writePosition as H,writeNormal as X,writeColor as k,writeBufferVec4 as F,writeObjectAndLayerIdColor as q}from"./internal/bufferWriterUtils.js";import{verticalOffsetAtDistance as W}from"./internal/MaterialUtil.js";import{isInstanceHidden as Z}from"./renderers/utils.js";import{c as J}from"../../../../chunks/HUDMaterial.glsl.js";import{HUDMaterialTechnique as Y}from"../shaders/HUDMaterialTechnique.js";import{HUDMaterialTechniqueConfiguration as K}from"../shaders/HUDMaterialTechniqueConfiguration.js";class Q extends U{constructor(e){super(e,new Ae),this._configuration=new K}getConfiguration(e,t){return this._configuration.output=e,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVerticalOffset=!!this.parameters.verticalOffset,this._configuration.hasScreenSizePerspective=!!this.parameters.screenSizePerspective,this._configuration.screenCenterOffsetUnitsEnabled="screen"===this.parameters.centerOffsetUnits?T.Screen:T.World,this._configuration.hasPolygonOffset=this.parameters.polygonOffset,this._configuration.isDraped=this.parameters.isDraped,this._configuration.occlusionTestEnabled=this.parameters.occlusionTest,this._configuration.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this._configuration.signedDistanceFieldEnabled=this.parameters.textureIsSignedDistanceField,this._configuration.vvSize=!!this.parameters.vvSizeEnabled,this._configuration.vvColor=!!this.parameters.vvColorEnabled,this._configuration.occlusionPass=t.slot===w.OCCLUSION_PIXELS&&this.parameters.occlusionTest&&(e===z.Color||e===z.Alpha),e===z.Color&&(this._configuration.debugDrawLabelBorder=!!this.parameters.debugDrawLabelBorder),e===z.Highlight&&(this._configuration.binaryHighlightOcclusionEnabled=this.parameters.binaryHighlightOcclusion),this._configuration.depthEnabled=this.parameters.depthEnabled,this._configuration.transparencyPassType=t.transparencyPassType,this._configuration.hasMultipassGeometry=t.multipassGeometry.enabled,this._configuration.hasMultipassTerrain=t.multipassTerrain.enabled,this._configuration.cullAboveGround=t.multipassTerrain.cullAboveGround,this._configuration}intersect(e,r,s,i,a,n,o,c,l){t(l)?this._intersectDrapedHudGeometry(e,n,o,c,l):this._intersectHudGeometry(e,r,s,i,o,c)}_intersectDrapedHudGeometry(e,r,s,i,a){const n=e.vertexAttributes.get(G.POSITION),o=e.vertexAttributes.get(G.SIZE),c=this.parameters,l=J(c);let f=1,u=1;if(t(i)){const e=i(me);f=e[0],u=e[5]}f*=e.screenToWorldRatio,u*=e.screenToWorldRatio;const h=Oe*e.screenToWorldRatio;for(let t=0;t<n.data.length/n.size;t++){const i=t*n.size,p=n.data[i],d=n.data[i+1],m=t*o.size;let g;Se[0]=o.data[m]*f,Se[1]=o.data[m+1]*u,c.textureIsSignedDistanceField&&(g=c.outlineSize*e.screenToWorldRatio/2),re(r,p,d,Se,h,g,c,l)&&s(a.dist,a.normal,-1,!1)}}_intersectHudGeometry(e,r,i,n,o,c){if(!n.options.selectionMode||!n.options.hud||Z(r))return;const l=this.parameters;let S=1,v=1;if(s(fe,i),t(c)){const e=c(me);S=e[0],v=e[5],te(fe)}const A=e.vertexAttributes.get(G.POSITION),P=e.vertexAttributes.get(G.SIZE),x=e.vertexAttributes.get(G.NORMAL),y=e.vertexAttributes.get(G.AUXPOS1);B(A.size>=3);const I=n.point,_=n.camera,C=J(l);S*=_.pixelRatio,v*=_.pixelRatio;const j="screen"===this.parameters.centerOffsetUnits;for(let t=0;t<A.data.length/A.size;t++){const e=t*A.size;f(ae,A.data[e],A.data[e+1],A.data[e+2]),u(ae,ae,i);const r=t*P.size;Se[0]=P.data[r]*S,Se[1]=P.data[r+1]*v,u(ae,ae,_.viewMatrix);const s=t*y.size;if(f(pe,y.data[s+0],y.data[s+1],y.data[s+2]),!j&&(ae[0]+=pe[0],ae[1]+=pe[1],0!==pe[2])){const e=pe[2];h(pe,ae),p(ae,ae,d(pe,pe,e))}const c=t*x.size;if(f(ne,x.data[c],x.data[c+1],x.data[c+2]),this._normalAndViewAngle(ne,fe,_,de),this._applyVerticalOffsetTransformationView(ae,de,_,se),_.applyProjection(ae,oe),oe[0]>-1){oe[0]=Math.floor(oe[0]),oe[1]=Math.floor(oe[1]),j&&(pe[0]||pe[1])&&(oe[0]+=pe[0],0!==pe[1]&&(oe[1]+=R(pe[1],se.factorAlignment)),_.unapplyProjection(oe,ae)),oe[0]+=this.parameters.screenOffset[0],oe[1]+=this.parameters.screenOffset[1],N(Se,se.factor,Se);const e=ge*_.pixelRatio;let t;if(l.textureIsSignedDistanceField&&(t=l.outlineSize*_.pixelRatio/2),re(I,oe[0],oe[1],Se,e,t,l,C)){const e=n.ray;if(u(le,ae,a(he,_.viewMatrix)),oe[0]=I[0],oe[1]=I[1],_.unprojectFromRenderScreen(oe,ae)){const t=b();m(t,e.direction);const r=1/g(t);d(t,t,r);o(O(e.origin,ae)*r,t,-1,!0,1,le)}}}}}computeAttachmentOrigin(e,t){const r=e.vertexAttributes;if(!r)return!1;const s=r.get(G.POSITION),i=e.indices.get(G.POSITION);return L(s,i,t)}createBufferWriter(){return new xe(this)}_normalAndViewAngle(e,t,r,i){return I(t)&&(t=s(ue,t)),S(i.normal,e,t),u(i.normal,i.normal,r.viewInverseTransposeMatrix),i.cosAngle=v(ce,ve),i}_updateScaleInfo(e,r,s){const i=this.parameters;t(i.screenSizePerspective)?V(s,r,i.screenSizePerspective,e.factor):(e.factor.scale=1,e.factor.factor=0,e.factor.minPixelSize=0,e.factor.paddingPixels=0),t(i.screenSizePerspectiveAlignment)?V(s,r,i.screenSizePerspectiveAlignment,e.factorAlignment):(e.factorAlignment.factor=e.factor.factor,e.factorAlignment.scale=e.factor.scale,e.factorAlignment.minPixelSize=e.factor.minPixelSize,e.factorAlignment.paddingPixels=e.factor.paddingPixels)}applyShaderOffsetsView(e,t,r,s,i,a,n){const o=this._normalAndViewAngle(t,r,i,de);return this._applyVerticalGroundOffsetView(e,o,i,n),this._applyVerticalOffsetTransformationView(n,o,i,a),this._applyPolygonOffsetView(n,o,s[3],i,n),this._applyCenterOffsetView(n,s,n),n}applyShaderOffsetsNDC(e,r,s,i,a){return this._applyCenterOffsetNDC(e,r,s,i),t(a)&&m(a,i),this._applyPolygonOffsetNDC(i,r,s,i),i}_applyPolygonOffsetView(t,r,s,i,a){const n=i.aboveGround?1:-1;let o=Math.sign(s);0===o&&(o=n);const c=n*o;if(this.parameters.shaderPolygonOffset<=0)return m(a,t);const l=e(Math.abs(r.cosAngle),.01,1),f=1-Math.sqrt(1-l*l)/l/i.viewport[2];return d(a,t,c>0?f:1/f),a}_applyVerticalGroundOffsetView(e,t,r,s){const i=g(e),a=r.aboveGround?1:-1,n=.5*r.computeRenderPixelSizeAtDist(i),o=d(ae,t.normal,a*n);return A(s,e,o),s}_applyVerticalOffsetTransformationView(e,t,s,i){const a=this.parameters;if(!a.verticalOffset||!a.verticalOffset.screenLength){if(a.screenSizePerspective||a.screenSizePerspectiveAlignment){const r=g(e);this._updateScaleInfo(i,r,t.cosAngle)}else i.factor.scale=1,i.factorAlignment.scale=1;return e}const n=g(e),o=r(a.screenSizePerspectiveAlignment,a.screenSizePerspective),c=W(s,n,a.verticalOffset,t.cosAngle,o);return this._updateScaleInfo(i,n,t.cosAngle),d(t.normal,t.normal,c),A(e,e,t.normal)}_applyCenterOffsetView(e,t,r){const s="screen"!==this.parameters.centerOffsetUnits;return r!==e&&m(r,e),s&&(r[0]+=t[0],r[1]+=t[1],t[2]&&(h(ne,r),A(r,r,d(ne,ne,t[2])))),r}_applyCenterOffsetNDC(e,t,r,s){const i="screen"!==this.parameters.centerOffsetUnits;return s!==e&&m(s,e),i||(s[0]+=t[0]/r.fullWidth*2,s[1]+=t[1]/r.fullHeight*2),s}_applyPolygonOffsetNDC(e,t,r,s){const i=this.parameters.shaderPolygonOffset;if(e!==s&&m(s,e),i){const e=r.aboveGround?1:-1,a=e*Math.sign(t[3]);s[2]-=(a||e)*i}return s}requiresSlot(e,t){if(t===z.Color||t===z.Alpha||t===z.Highlight||t===z.ObjectAndLayerIdColor){if(e===w.DRAPED_MATERIAL)return!0;const{drawInSecondSlot:t,occlusionTest:r}=this.parameters;return e===(t?w.LABEL_MATERIAL:w.HUD_MATERIAL)||r&&e===w.OCCLUSION_PIXELS}return!1}createGLMaterial(e){return new $(e)}calculateRelativeScreenBounds(e,t,r=_()){return ee(this.parameters,e,t,r),r[2]=r[0]+e[0],r[3]=r[1]+e[1],r}}class $ extends M{constructor(e){super({...e,...e.material.parameters})}selectProgram(e){return this.ensureTechnique(Y,e)}beginSlot(e){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.selectProgram(e)}}function ee(e,t,r,s=ie){return o(s,e.anchorPosition),s[0]*=-t[0],s[1]*=-t[1],s[0]+=e.screenOffset[0]*r,s[1]+=e.screenOffset[1]*r,s}function te(e){const t=e[0],r=e[1],s=e[2],i=e[3],a=e[4],n=e[5],o=e[6],c=e[7],l=e[8],f=1/Math.sqrt(t*t+r*r+s*s),u=1/Math.sqrt(i*i+a*a+n*n),h=1/Math.sqrt(o*o+c*c+l*l);return e[0]=t*f,e[1]=r*f,e[2]=s*f,e[3]=i*u,e[4]=a*u,e[5]=n*u,e[6]=o*h,e[7]=c*h,e[8]=l*h,e}function re(e,r,s,i,a,n,o,c){let l=r-a-(c[0]>0?i[0]*c[0]:0),f=l+i[0]+2*a,u=s-a-(c[1]>0?i[1]*c[1]:0),h=u+i[1]+2*a;const p=o.distanceFieldBoundingBox;return o.textureIsSignedDistanceField&&t(p)&&(l+=i[0]*p[0],u+=i[1]*p[1],f-=i[0]*(1-p[2]),h-=i[1]*(1-p[3]),l-=n,f+=n,u-=n,h+=n),e[0]>l&&e[0]<f&&e[1]>u&&e[1]<h}const se={factor:{scale:0,factor:0,minPixelSize:0,paddingPixels:0},factorAlignment:{scale:0,factor:0,minPixelSize:0,paddingPixels:0}},ie=c(),ae=b(),ne=b(),oe=x(),ce=b(),le=b(),fe=i(),ue=i(),he=n(),pe=b(),de={normal:ce,cosAngle:0},me=n(),ge=1,Oe=2,Se=[0,0],ve=P(0,0,1);class Ae extends D{constructor(){super(...arguments),this.renderOccluded=E.Occlude,this.color=y(1,1,1,1),this.texCoordScale=[1,1],this.polygonOffset=!1,this.anchorPosition=l(.5,.5),this.screenOffset=[0,0],this.shaderPolygonOffset=1e-5,this.textureIsSignedDistanceField=!1,this.outlineColor=y(1,1,1,1),this.outlineSize=0,this.vvSizeEnabled=!1,this.vvSizeMinSize=[1,1,1],this.vvSizeMaxSize=[100,100,100],this.vvSizeOffset=[0,0,0],this.vvSizeFactor=[1,1,1],this.vvColorEnabled=!1,this.vvColorValues=[0,0,0,0,0,0,0,0],this.vvColorColors=[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],this.hasSlicePlane=!1,this.pixelSnappingEnabled=!0,this.occlusionTest=!0,this.binaryHighlightOcclusion=!0,this.debugDrawLabelBorder=!1,this.centerOffsetUnits="world",this.drawInSecondSlot=!1,this.depthEnabled=!0,this.isDraped=!1}}const be=j().vec3f(G.POSITION).vec3f(G.NORMAL).vec2f(G.UV0).vec4u8(G.COLOR).vec2f(G.SIZE).vec4f(G.AUXPOS1).vec4f(G.AUXPOS2),Pe=be.clone().vec4u8(G.OBJECTANDLAYERIDCOLOR);class xe{constructor(e){this._material=e,this.vertexBufferLayout=has("enable-feature:objectAndLayerId-rendering")?Pe:be}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return 6*e.indices.get(G.POSITION).length}write(e,r,s,i,a){H(s.indices.get(G.POSITION),s.vertexAttributes.get(G.POSITION).data,e,i.position,a,6),X(s.indices.get(G.NORMAL),s.vertexAttributes.get(G.NORMAL).data,r,i.normal,a,6);{const e=s.vertexAttributes.get(G.UV0).data;let t,r,n,o;if(null==e||e.length<4){const e=this._material.parameters;t=0,r=0,n=e.texCoordScale[0],o=e.texCoordScale[1]}else t=e[0],r=e[1],n=e[2],o=e[3];n=Math.min(1.99999,n+1),o=Math.min(1.99999,o+1);const c=s.indices.get(G.POSITION).length,l=i.uv0;let f=a;for(let s=0;s<c;++s)l.set(f,0,t),l.set(f,1,r),f+=1,l.set(f,0,n),l.set(f,1,r),f+=1,l.set(f,0,n),l.set(f,1,o),f+=1,l.set(f,0,n),l.set(f,1,o),f+=1,l.set(f,0,t),l.set(f,1,o),f+=1,l.set(f,0,t),l.set(f,1,r),f+=1}k(s.indices.get(G.COLOR),s.vertexAttributes.get(G.COLOR).data,4,i.color,a,6);{const e=s.indices.get(G.SIZE),t=s.vertexAttributes.get(G.SIZE).data,r=e.length,n=i.size;let o=a;for(let s=0;s<r;++s){const r=t[2*e[s]],i=t[2*e[s]+1];for(let e=0;e<6;++e)n.set(o,0,r),n.set(o,1,i),o+=1}}if(s.indices.get(G.AUXPOS1)&&s.vertexAttributes.get(G.AUXPOS1)&&F(s.indices.get(G.AUXPOS1),s.vertexAttributes.get(G.AUXPOS1).data,i.auxpos1,a,6),s.indices.get(G.AUXPOS2)&&s.vertexAttributes.get(G.AUXPOS2)&&F(s.indices.get(G.AUXPOS2),s.vertexAttributes.get(G.AUXPOS2).data,i.auxpos2,a,6),t(s.objectAndLayerIdColor)&&4===s.objectAndLayerIdColor.length){if(s.indices.get(G.POSITION)){const e=s.indices.get(G.POSITION).length,t=i.getField(G.OBJECTANDLAYERIDCOLOR,C);q(s.objectAndLayerIdColor,t,e,a,6)}}}}export{Q as HUDMaterial,Ae as Parameters};
