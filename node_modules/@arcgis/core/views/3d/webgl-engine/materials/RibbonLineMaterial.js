/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import has from"../../../../core/has.js";import e from"../../../../core/Logger.js";import{clamp as t}from"../../../../core/mathUtils.js";import{isSome as r}from"../../../../core/maybe.js";import{createRenderScreenPointArray3 as i}from"../../../../core/screenUtils.js";import{c as s}from"../../../../chunks/vec2.js";import{s as a,b as n,e as o,g as l,a as c,c as h,l as u,i as p,m}from"../../../../chunks/vec3.js";import{c as f}from"../../../../chunks/vec3f64.js";import{O as T}from"../../../../chunks/vec4f64.js";import{PlaneIndex as d}from"../../../../geometry/support/frustum.js";import{create as _,distance2 as A,fromPoints as E,closestLineSegmentPoint as v}from"../../../../geometry/support/lineSegment.js";import{create as S,fromPoints as I,signedDistance as R,normal as g}from"../../../../geometry/support/plane.js";import{newLayout as O}from"../../support/buffer/InterleavedLayout.js";import{ShaderOutput as b}from"../core/shaderLibrary/ShaderOutput.js";import{computeAttachmentOriginLines as L}from"../lib/geometryDataUtils.js";import P from"../lib/GLMaterial.js";import{Material as N,RenderOccludedFlag as C}from"../lib/Material.js";import{RenderSlot as y}from"../lib/RenderSlot.js";import{isTranslationMatrix as j}from"../lib/Util.js";import{VertexAttribute as D}from"../lib/VertexAttribute.js";import{VisualVariablePassParameters as U}from"./VisualVariablePassParameters.js";import{isInstanceHidden as x}from"./renderers/utils.js";import{LineMarkerAnchor as F}from"../shaders/LineMarkerTechniqueConfiguration.js";import{N as w}from"../../../../chunks/RibbonLine.glsl.js";import{vertexAttributeLocations as M,RibbonLineTechnique as J}from"../shaders/RibbonLineTechnique.js";import{RibbonLineTechniqueConfiguration as G,CapType as B}from"../shaders/RibbonLineTechniqueConfiguration.js";var z;!function(e){e[e.LEFT_JOIN_START=-2]="LEFT_JOIN_START",e[e.LEFT_JOIN_END=-1]="LEFT_JOIN_END",e[e.LEFT_CAP_START=-4]="LEFT_CAP_START",e[e.LEFT_CAP_END=-5]="LEFT_CAP_END",e[e.RIGHT_JOIN_START=2]="RIGHT_JOIN_START",e[e.RIGHT_JOIN_END=1]="RIGHT_JOIN_END",e[e.RIGHT_CAP_START=4]="RIGHT_CAP_START",e[e.RIGHT_CAP_END=5]="RIGHT_CAP_END"}(z||(z={}));class H extends N{constructor(e){super(e,new W),this._configuration=new G,this._vertexAttributeLocations=M,this._layout=this.createLayout()}isClosed(e,t){return X(this.parameters,e,t)}getConfiguration(e,t){this._configuration.output=e,this._configuration.draped=t.slot===y.DRAPED_MATERIAL;const i=r(this.parameters.stipplePattern)&&e!==b.Highlight;return this._configuration.stippleEnabled=i,this._configuration.stippleOffColorEnabled=i&&r(this.parameters.stippleOffColor),this._configuration.stippleScaleWithLineWidth=i&&this.parameters.stippleScaleWithLineWidth,this._configuration.stipplePreferContinuous=i&&this.parameters.stipplePreferContinuous,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasOccludees=this.parameters.hasOccludees,this._configuration.roundJoins="round"===this.parameters.join,this._configuration.capType=this.parameters.cap,this._configuration.applyMarkerOffset=!!r(this.parameters.markerParameters)&&Y(this.parameters.markerParameters),this._configuration.hasPolygonOffset=this.parameters.hasPolygonOffset,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.vvColor=this.parameters.vvColorEnabled,this._configuration.vvOpacity=this.parameters.vvOpacityEnabled,this._configuration.vvSize=this.parameters.vvSizeEnabled,this._configuration.innerColorEnabled=this.parameters.innerWidth>0&&r(this.parameters.innerColor),this._configuration.falloffEnabled=this.parameters.falloff>0,this._configuration.occluder=this.parameters.renderOccluded===C.OccludeAndTransparentStencil,this._configuration.transparencyPassType=t.transparencyPassType,this._configuration.hasMultipassTerrain=t.multipassTerrain.enabled,this._configuration.cullAboveGround=t.multipassTerrain.cullAboveGround,this._configuration.wireframe=this.parameters.wireframe,this._configuration}intersect(e,t,i,s,a,n,o,l,c){r(c)?this._intersectDrapedLineGeometry(e,s,c,n,o):this._intersectLineGeometry(e,t,i,s,o)}_intersectDrapedLineGeometry(e,r,i,s,a){if(!r.options.selectionMode)return;const n=e.vertexAttributes.get(D.POSITION).data,o=e.vertexAttributes.get(D.SIZE);let l=this.parameters.width;if(this.parameters.vvSizeEnabled){const r=e.vertexAttributes.get(D.SIZEFEATUREATTRIBUTE).data[0];l*=t(this.parameters.vvSizeOffset[0]+r*this.parameters.vvSizeFactor[0],this.parameters.vvSizeMinSize[0],this.parameters.vvSizeMaxSize[0])}else o&&(l*=o.data[0]);const c=s[0],h=s[1],u=(l/2+4)*e.screenToWorldRatio;let p=Number.MAX_VALUE,m=0;for(let f=0;f<n.length-5;f+=3){const e=n[f],r=n[f+1],i=c-e,s=h-r,a=n[f+3]-e,o=n[f+4]-r,l=t((a*i+o*s)/(a*a+o*o),0,1),u=a*l-i,T=o*l-s,d=u*u+T*T;d<p&&(p=d,m=f/3)}p<u*u&&a(i.dist,i.normal,m,!1)}_intersectLineGeometry(r,i,m,f,T){if(!f.options.selectionMode||x(i))return;if(!j(m))return void e.getLogger("esri.views.3d.webgl-engine.materials.RibbonLineMaterial").error("intersection assumes a translation-only matrix");const _=r.vertexAttributes,S=_.get(D.POSITION).data;let O=this.parameters.width;if(this.parameters.vvSizeEnabled){const e=_.get(D.SIZEFEATUREATTRIBUTE).data[0];O*=t(this.parameters.vvSizeOffset[0]+e*this.parameters.vvSizeFactor[0],this.parameters.vvSizeMinSize[0],this.parameters.vvSizeMaxSize[0])}else _.has(D.SIZE)&&(O*=_.get(D.SIZE).data[0]);const b=f.camera,L=te;s(L,f.point);const P=O*b.pixelRatio/2+4*b.pixelRatio;a(ue[0],L[0]-P,L[1]+P,0),a(ue[1],L[0]+P,L[1]+P,0),a(ue[2],L[0]+P,L[1]-P,0),a(ue[3],L[0]-P,L[1]-P,0);for(let e=0;e<4;e++)if(!b.unprojectFromRenderScreen(ue[e],pe[e]))return;I(b.eye,pe[0],pe[1],me),I(b.eye,pe[1],pe[2],fe),I(b.eye,pe[2],pe[3],Te),I(b.eye,pe[3],pe[0],de);let N=Number.MAX_VALUE,C=0;const y=q(this.parameters,_,r.indices)?S.length-2:S.length-5;for(let e=0;e<y;e+=3){Q[0]=S[e]+m[12],Q[1]=S[e+1]+m[13],Q[2]=S[e+2]+m[14];const t=(e+3)%S.length;if(K[0]=S[t]+m[12],K[1]=S[t+1]+m[13],K[2]=S[t+2]+m[14],R(me,Q)<0&&R(me,K)<0||R(fe,Q)<0&&R(fe,K)<0||R(Te,Q)<0&&R(Te,K)<0||R(de,Q)<0&&R(de,K)<0)continue;if(b.projectToRenderScreen(Q,re),b.projectToRenderScreen(K,ie),re[2]<0&&ie[2]>0){n($,Q,K);const e=b.frustum,t=-R(e[d.NEAR],Q)/o($,g(e[d.NEAR]));l($,$,t),c(Q,Q,$),b.projectToRenderScreen(Q,re)}else if(re[2]>0&&ie[2]<0){n($,K,Q);const e=b.frustum,t=-R(e[d.NEAR],K)/o($,g(e[d.NEAR]));l($,$,t),c(K,K,$),b.projectToRenderScreen(K,ie)}else if(re[2]<0&&ie[2]<0)continue;re[2]=0,ie[2]=0;const r=A(E(re,ie,ne),L);r<N&&(N=r,h(se,Q),h(ae,K),C=e/3)}const U=f.rayBegin,F=f.rayEnd;if(N<P*P){let e=Number.MAX_VALUE;if(v(E(se,ae,ne),E(U,F,oe),ee)){n(ee,ee,U);const t=u(ee);l(ee,ee,1/t),e=t/p(U,F)}T(e,ee,C,!1)}}computeAttachmentOrigin(e,t){const r=e.vertexAttributes;if(!r)return!1;const i=e.indices,s=r.get(D.POSITION);return L(s,i?i.get(D.POSITION):null,i&&q(this.parameters,r,i),t)}createLayout(){const e=O().vec3f(D.POSITION).f32(D.SUBDIVISIONFACTOR).vec2f(D.UV0).vec3f(D.AUXPOS1).vec3f(D.AUXPOS2);return this.parameters.vvSizeEnabled?e.f32(D.SIZEFEATUREATTRIBUTE):e.f32(D.SIZE),this.parameters.vvColorEnabled?e.f32(D.COLORFEATUREATTRIBUTE):e.vec4f(D.COLOR),this.parameters.vvOpacityEnabled&&e.f32(D.OPACITYFEATUREATTRIBUTE),has("enable-feature:objectAndLayerId-rendering")&&e.vec4u8(D.OBJECTANDLAYERIDCOLOR),e}createBufferWriter(){return new V(this._layout,this.parameters)}requiresSlot(e,t){if(t===b.Color||t===b.Alpha||t===b.Highlight||t===b.Depth||t===b.ObjectAndLayerIdColor){if(e===y.DRAPED_MATERIAL)return!0;if(this.parameters.renderOccluded===C.OccludeAndTransparentStencil)return e===y.OPAQUE_MATERIAL||e===y.OCCLUDER_MATERIAL||e===y.TRANSPARENT_OCCLUDER_MATERIAL;if(t===b.Color||t===b.Alpha){return e===(this.parameters.writeDepth?y.TRANSPARENT_MATERIAL:y.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL)}return e===y.OPAQUE_MATERIAL}return!1}createGLMaterial(e){return new k(e)}validateParameters(e){"miter"!==e.join&&(e.miterLimit=0),r(e.markerParameters)&&(e.markerScale=e.markerParameters.width/e.width)}}class k extends P{constructor(){super(...arguments),this._stipplePattern=null}dispose(){super.dispose(),this._stippleTextureRepository.release(this._stipplePattern),this._stipplePattern=null}_updateOccludeeState(e){e.hasOccludees!==this._material.parameters.hasOccludees&&this._material.setParameters({hasOccludees:e.hasOccludees})}beginSlot(e){this._output!==b.Color&&this._output!==b.Alpha||this._updateOccludeeState(e);const t=this._material.parameters.stipplePattern;return this._stipplePattern!==t&&(this._material.setParameters(this._stippleTextureRepository.swap(this._stipplePattern,t)),this._stipplePattern=t),this.ensureTechnique(J,e)}}class W extends U{constructor(){super(...arguments),this.width=0,this.color=T,this.join="miter",this.cap=B.BUTT,this.miterLimit=5,this.writeDepth=!0,this.hasPolygonOffset=!1,this.stippleTexture=null,this.stippleScaleWithLineWidth=!1,this.stipplePreferContinuous=!0,this.markerParameters=null,this.markerScale=1,this.hasSlicePlane=!1,this.vvFastUpdate=!1,this.isClosed=!1,this.falloff=0,this.innerWidth=0,this.hasOccludees=!1,this.wireframe=!1}}class V{constructor(e,t){this._parameters=t,this.numJoinSubdivisions=0,this.vertexBufferLayout=e;const r=t.stipplePattern?1:0;switch(this._parameters.join){case"miter":case"bevel":this.numJoinSubdivisions=r;break;case"round":this.numJoinSubdivisions=w+r}}_isClosed(e){return q(this._parameters,e.vertexAttributes,e.indices)}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){const t=2,r=e.indices.get(D.POSITION).length/2+1,i=this._isClosed(e);let s=i?2:2*t;return s+=((i?r:r-1)-(i?0:1))*(2*this.numJoinSubdivisions+4),s+=2,this._parameters.wireframe&&(s=2+4*(s-2)),s}write(e,t,i,s,n){const o=le,l=ce,c=he,u=i.vertexAttributes.get(D.POSITION).data,f=i.indices&&i.indices.get(D.POSITION),T=i.vertexAttributes.get(D.DISTANCETOSTART)?.data;f&&f.length!==2*(u.length/3-1)&&console.warn("RibbonLineMaterial does not support indices");let d=1,_=0;this._parameters.vvSizeEnabled?_=i.vertexAttributes.get(D.SIZEFEATUREATTRIBUTE).data[0]:i.vertexAttributes.has(D.SIZE)&&(d=i.vertexAttributes.get(D.SIZE).data[0]);let A=[1,1,1,1],E=0;this._parameters.vvColorEnabled?E=i.vertexAttributes.get(D.COLORFEATUREATTRIBUTE).data[0]:i.vertexAttributes.has(D.COLOR)&&(A=i.vertexAttributes.get(D.COLOR).data);let v=null;has("enable-feature:objectAndLayerId-rendering")&&(v=i.objectAndLayerIdColor);let S=0;this._parameters.vvOpacityEnabled&&(S=i.vertexAttributes.get(D.OPACITYFEATUREATTRIBUTE).data[0]);const I=u.length/3,R=new Float32Array(s.buffer),g=has("enable-feature:objectAndLayerId-rendering")?new Uint8Array(s.buffer):null,O=this.vertexBufferLayout.stride/4;let b=n*O;const L=b;let P=0;const N=T?(e,t,r)=>P=T[r]:(e,t,r)=>P+=p(e,t),C=(e,t,i,s,a,n,o)=>{if(R[b++]=t[0],R[b++]=t[1],R[b++]=t[2],R[b++]=s,R[b++]=o,R[b++]=a,R[b++]=e[0],R[b++]=e[1],R[b++]=e[2],R[b++]=i[0],R[b++]=i[1],R[b++]=i[2],this._parameters.vvSizeEnabled?R[b++]=_:R[b++]=d,this._parameters.vvColorEnabled)R[b++]=E;else{const e=Math.min(4*n,A.length-4);R[b++]=A[e+0],R[b++]=A[e+1],R[b++]=A[e+2],R[b++]=A[e+3]}this._parameters.vvOpacityEnabled&&(R[b++]=S),has("enable-feature:objectAndLayerId-rendering")&&(r(v)&&(g[4*b+0]=v[0],g[4*b+1]=v[1],g[4*b+2]=v[2],g[4*b+3]=v[3]),b++)};b+=O,a(l,u[0],u[1],u[2]),e&&m(l,l,e);const y=this._isClosed(i);if(y){const t=u.length-3;a(o,u[t],u[t+1],u[t+2]),e&&m(o,o,e)}else a(c,u[3],u[4],u[5]),e&&m(c,c,e),C(l,l,c,1,z.LEFT_CAP_START,0,0),C(l,l,c,1,z.RIGHT_CAP_START,0,0),h(o,l),h(l,c);const j=y?0:1,U=y?I:I-1;for(let r=j;r<U;r++){const t=(r+1)%I*3;a(c,u[t+0],u[t+1],u[t+2]),e&&m(c,c,e),N(o,l,r),C(o,l,c,0,z.LEFT_JOIN_END,r,P),C(o,l,c,0,z.RIGHT_JOIN_END,r,P);const i=this.numJoinSubdivisions;for(let e=0;e<i;++e){const t=(e+1)/(i+1);C(o,l,c,t,z.LEFT_JOIN_END,r,P),C(o,l,c,t,z.RIGHT_JOIN_END,r,P)}C(o,l,c,1,z.LEFT_JOIN_START,r,P),C(o,l,c,1,z.RIGHT_JOIN_START,r,P),h(o,l),h(l,c)}y?(a(c,u[3],u[4],u[5]),e&&m(c,c,e),P=N(o,l,U),C(o,l,c,0,z.LEFT_JOIN_END,j,P),C(o,l,c,0,z.RIGHT_JOIN_END,j,P)):(P=N(o,l,U),C(o,l,l,0,z.LEFT_CAP_END,U,P),C(o,l,l,0,z.RIGHT_CAP_END,U,P)),Z(R,L+O,R,L,O);b=Z(R,b-O,R,b,O),this._parameters.wireframe&&this._addWireframeVertices(s,L,b,O)}_addWireframeVertices(e,t,r,i){const s=new Float32Array(e.buffer,r*Float32Array.BYTES_PER_ELEMENT),a=new Float32Array(e.buffer,t*Float32Array.BYTES_PER_ELEMENT,r-t);let n=0;const o=e=>n=Z(a,e,s,n,i);for(let l=0;l<a.length-1;l+=2*i)o(l),o(l+2*i),o(l+1*i),o(l+2*i),o(l+1*i),o(l+3*i)}}function Z(e,t,r,i,s){for(let a=0;a<s;a++)r[i++]=e[t++];return i}function q(e,t,r){return X(e,t.get(D.POSITION).data,r?r.get(D.POSITION):null)}function X(e,t,r){return!!e.isClosed&&(r?r.length>2:t.length>6)}function Y(e){return e.anchor===F.Tip&&e.hideOnShortSegments&&"begin-end"===e.placement&&e.worldSpace}const Q=f(),K=f(),$=f(),ee=f(),te=f(),re=i(),ie=i(),se=f(),ae=f(),ne=_(),oe=_(),le=f(),ce=f(),he=f(),ue=[i(),i(),i(),i()],pe=[f(),f(),f(),f()],me=S(),fe=S(),Te=S(),de=S();export{W as Parameters,H as RibbonLineMaterial};
