/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{s as e,n as t,b as r,f as s,i as o,m as i}from"../../../../chunks/vec3.js";import{c as n}from"../../../../chunks/vec3f64.js";import{f as a}from"../../../../chunks/vec4f64.js";import{newLayout as c}from"../../support/buffer/InterleavedLayout.js";import{ShaderOutput as u}from"../core/shaderLibrary/ShaderOutput.js";import f from"../lib/GLMaterial.js";import{Material as l,MaterialParameters as p}from"../lib/Material.js";import{RenderSlot as h}from"../lib/RenderSlot.js";import{VertexAttribute as m}from"../lib/VertexAttribute.js";import{MeasurementArrowTechniqueConfiguration as d,MeasurementArrowTechnique as g}from"../shaders/MeasurementArrowTechnique.js";class O extends l{constructor(e){super(e,new b),this._configuration=new d}getConfiguration(e,t){return this._configuration.polygonOffsetEnabled=this.parameters.polygonOffset,this._configuration.transparent=this.parameters.stripeEvenColor[3]<1||this.parameters.stripeOddColor[3]<1||this.parameters.outlineColor[3]<1,this._configuration.transparencyPassType=t.transparencyPassType,this._configuration}dispose(){}intersect(){}requiresSlot(e,t){return t===u.Color&&e===h.OPAQUE_MATERIAL}createGLMaterial(e){return new v(e)}createBufferWriter(){return new S}}class v extends f{beginSlot(e){return this.ensureTechnique(g,e)}}class b extends p{constructor(){super(...arguments),this.width=32,this.outlineSize=.2,this.outlineColor=a(1,.5,0,1),this.stripeEvenColor=a(1,1,1,1),this.stripeOddColor=a(1,.5,0,1),this.stripeLength=1,this.polygonOffset=!1}}const y=c().vec3f(m.POSITION).vec3f(m.NORMAL).vec2f(m.UV0).f32(m.AUXPOS1),A=n(),j=n(),x=n(),I=n(),L=n();class S{constructor(){this.vertexBufferLayout=y}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return 2*(e.indices.get(m.POSITION).length/2+1)}write(n,a,c,u,f){const l=c.vertexAttributes.get(m.POSITION).data,p=c.vertexAttributes.get(m.NORMAL).data,h=l.length/3,d=c&&c.indices&&c.indices.get(m.POSITION);d&&d.length!==2*(h-1)&&console.warn("MeasurementArrowMaterial does not support indices");const g=A,O=j,v=x,b=I,y=L,S=u.position,w=u.normal,C=u.uv0;let M=0;for(let m=0;m<h;++m){const c=3*m;if(e(g,l[c],l[c+1],l[c+2]),m<h-1){const o=3*(m+1);e(O,l[o],l[o+1],l[o+2]),e(y,p[o],p[o+1],p[o+2]),t(y,y),r(v,O,g),t(v,v),s(b,y,v),t(b,b)}const u=o(g,O);n&&a&&(i(g,g,n),i(O,O,n),i(b,b,a));const d=f+2*m,A=d+1;S.setVec(d,g),S.setVec(A,g),w.setVec(d,b),w.setVec(A,b),C.set(d,0,M),C.set(d,1,-1),C.set(A,0,M),C.set(A,1,1),m<h-1&&(M+=u)}const T=u.auxpos1;for(let e=0;e<2*h;++e)T.set(f+e,M)}}export{O as MeasurementArrowMaterial,b as Parameters};
