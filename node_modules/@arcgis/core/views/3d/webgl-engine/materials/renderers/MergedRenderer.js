/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{someMap as e}from"../../../../../core/MapUtils.js";import{isNone as t,isSome as r}from"../../../../../core/maybe.js";import s from"../../../../../core/PooledArray.js";import{m as a,a as i,t as o}from"../../../../../chunks/mat4.js";import{c as n}from"../../../../../chunks/mat4f64.js";import{glLayout as h}from"../../../support/buffer/glUtil.js";import{ShaderOutput as d}from"../../core/shaderLibrary/ShaderOutput.js";import{GLMaterials as l}from"../../lib/GLMaterials.js";import{RenderOccludedFlag as m}from"../../lib/Material.js";import{DirtyState as c}from"../../lib/ModelDirtyTypes.js";import{assert as f,setMatrixTranslation3 as u}from"../../lib/Util.js";import{DrawParameters as g}from"../DrawParameters.js";import{WaterMaterial as y}from"../WaterMaterial.js";import{sortInstancesByRange as w,BufferRange as _,Instance as p,DrawCommand as b,addOrMerge as C}from"./Instance.js";import{MergedGeometryBuffer as v,BLOCK_SIZE as O}from"./MergedGeometryBuffer.js";import{MergedGeometryBufferPool as H}from"./MergedGeometryBufferPool.js";import{calculateTransformRelativeToOrigin as B}from"./utils.js";class S{constructor(e,t,r){this._rctx=e,this._materialRepository=t,this._material=r,this.type="MergedRenderer",this._dataByOrigin=new Map,this._renderCommandData=new s,this._hasHighlights=!1,this._hasOccludees=!1,this._glMaterials=new l(this._material,this._materialRepository),this._bufferWriter=r.createBufferWriter(),this._bufferPool=new H(e,r.vertexAttributeLocations,h(this._bufferWriter.vertexBufferLayout))}dispose(){this._glMaterials.destroy(),this._dataByOrigin.forEach((e=>e.geometry.dispose())),this._dataByOrigin.clear(),this._bufferPool.dispose()}get isEmpty(){return 0===this._dataByOrigin.size}get hasHighlights(){return this._hasHighlights}get hasOccludees(){return this._hasOccludees}get hasWater(){return!this.isEmpty&&this._material instanceof y}get rendersOccluded(){return!this.isEmpty&&this._material.renderOccluded!==m.Occlude}modify(e){this._updateGeometries(e.updates),this._addAndRemoveGeometries(e.adds,e.removes),this._updateDrawCommands()}_addAndRemoveGeometries(e,t){const r=this._bufferWriter,s=r.vertexBufferLayout.stride/4,a=this._dataByOrigin,i=D(e,t);i.forEach(((e,t)=>{i.delete(t);const o=e.add.reduce(((e,t)=>e+r.elementCount(t.data)),0);let n=a.get(t);if(null==n)f(0===e.remove.length),n=new R(e.origin,new v(this._bufferPool,o*s)),a.set(t,n);else if(0===e.add.length&&n.instances.size===e.remove.length)return n.geometry.dispose(),void a.delete(t);let h=0;n.instances.forEach((e=>h+=e.to-e.from));const d=e.remove.reduce(((e,t)=>e+r.elementCount(t.data)),0),l=n.geometry.size,m=(h+o-d)*s,c=P;if(m>O&&(m<l/2||l-m>1048576)?this._removeAndRebuild(n,e.remove,s,m,c):e.remove.length>0&&this._remove(n,e.remove,s,c),e.add.length>0){const t=L;u(t,-e.origin[0],-e.origin[1],-e.origin[2]),this._add(n,e.add,s,t,c)}const g=n.geometry.buffer.vao.vertexBuffers.geometry;j(c),c.forAll((({from:e,to:t})=>{if(e<t){const r=n.geometry.buffer.array;g.setSubData(r,e,e,t)}})),c.clear(),n.drawCommandsDirty=!0}))}_updateGeometries(e){const t=this._bufferWriter,r=t.vertexBufferLayout.stride/4;for(const s of e){const e=s.renderGeometry,a=this._dataByOrigin.get(e.origin.id),i=a&&a.instances.get(e.id);if(!i)return;const o=s.updateType;if(o&c.VISIBILITIES&&(i.isVisible=e.instanceParameters.visible),o&(c.HIGHLIGHTS|c.VISIBILITIES)){const t=e.instanceParameters.visible;i.hasHighlights=!!e.instanceParameters.highlights&&t}if(o&c.OCCLUDEES&&(i.hasOccludees=!!e.instanceParameters.occludees),o&(c.VERTEXATTRS|c.TRANSFORMATION)){const{array:s,vao:o}=a.geometry.buffer;B(e,T,G),t.write(T,G,e.data,t.vertexBufferLayout.createView(s.buffer),i.from),f(i.from+t.elementCount(e.data)===i.to,"material VBO layout has changed"),o.vertexBuffers.geometry.setSubData(s,i.from*r,i.from*r,i.to*r)}a.drawCommandsDirty=!0}}_updateDrawCommands(){this._hasHighlights=!1,this._hasOccludees=!1,this._dataByOrigin.forEach((t=>{t.hasHiddenInstances=!1,t.hasHighlights=!1,t.hasOccludees=!1,e(t.instances,(e=>(e.isVisible?(e.hasHighlights&&(this._hasHighlights=!0,t.hasHighlights=!0),e.hasOccludees&&(this._hasOccludees=!0,t.hasOccludees=!0)):t.hasHiddenInstances=!0,t.hasHiddenInstances&&t.hasHighlights&&t.hasOccludees)))}));const t=e=>{if(e.drawCommandsDefault.clear(),e.drawCommandsHighlight.clear(),e.drawCommandsOccludees.clear(),e.drawCommandsShadowHighlightRest.clear(),0===e.instances.size)return;if(!M(e)){const t=e.drawCommandsDefault.pushNew();return t.first=1/0,t.count=0,e.instances.forEach((e=>{t.first=Math.min(t.first,e.from),t.count=Math.max(t.count,e.to)})),void(t.count-=t.first)}const t=w(e.instances);for(const r of t)r.isVisible&&(r.hasOccludees?C(e.drawCommandsOccludees,r):C(e.drawCommandsDefault,r),r.hasHighlights?C(e.drawCommandsHighlight,r):C(e.drawCommandsShadowHighlightRest,r))};this._dataByOrigin.forEach((e=>{e.drawCommandsDirty&&(t(e),e.drawCommandsDirty=!1)}))}updateAnimation(e){return this._material.update(e)}requiresSlot(e,t){return this._material.requiresSlot(e,t)}render(e,s){if(!this.requiresSlot(s.slot,e))return!1;const a=e===d.Highlight||e===d.ShadowHighlight;if(a&&!this._hasHighlights)return!1;const i=e===d.ShadowExludeHighlight,o=!(a||i);if(this._dataByOrigin.forEach((e=>{if(a&&!e.hasHighlights)return;const t=(a?e.drawCommandsHighlight:i&&M(e)?e.drawCommandsShadowHighlightRest:e.drawCommandsDefault)||null,r=o&&e.drawCommandsOccludees||null;(t?.length||r?.length)&&this._renderCommandData.push(new x(e.origin,e.geometry,t,r))})),0===this._renderCommandData.length)return!1;const n=this._rctx,h=this._glMaterials.load(n,s.slot,e);if(t(h))return this._renderCommandData.clear(),!1;const l=h.beginSlot(s),m=n.bindTechnique(l,this._material.parameters,s);return this._renderCommandData.forAll((e=>{m.bindDraw(e,s,this._material.parameters);const{geometry:t,renderCommands:a,occludeeCommands:i}=e;l.ensureAttributeLocations(t.buffer.vao),n.bindVAO(t.buffer.vao);const o=l.primitiveType;r(a)&&a.length>0&&(l.bindPipelineState(n,s.slot,!1),a.forAll((e=>n.drawArrays(o,e.first,e.count)))),r(i)&&i.length>0&&(l.bindPipelineState(n,s.slot,!0),i.forAll((e=>n.drawArrays(o,e.first,e.count))))})),this._renderCommandData.clear(),!0}_removeAndRebuild(e,t,r,s,a){for(const d of t)e.instances.delete(d.id);const i=w(e.instances);e.instances.clear();const o=e.geometry.size,n=e.geometry.allocate(s);let h=0;for(const d of i){const t=d.from*r,s=d.to*r;n.copy(h,t,s),d.from=h/r,h+=s-t,d.to=h/r,e.instances.set(d.id,d)}a.push(new _(0,n.hasNewBuffer?e.geometry.buffer.array.length:o)),n.dispose(),e.geometry.erase(h,a.back().to),e.holes.clear()}_remove(e,t,r,s){for(const a of t){const t=a.id,i=e.instances.get(t),o=i.from*r,n=i.to*r;e.geometry.erase(o,n),e.holes.push(new _(i.from,i.to)),e.instances.delete(t),s.push(new _(o,n))}j(e.holes)}_add(e,s,n,h,d){if(0===s.length)return;const l=this._bufferWriter;let m=l.vertexBufferLayout.createView(e.geometry.buffer.array.buffer);const c=e.holes.length>0;let u=Number.MAX_SAFE_INTEGER,g=Number.MIN_SAFE_INTEGER;for(const y of s){const s=r(y.transformation)?a(T,h,y.transformation):h;i(G,s);const w=o(G,G),b=l.elementCount(y.data),C=b*n;let v=I(e.holes,b);t(v)&&(v=e.geometry.size/n,e.geometry.grow(C),m=l.vertexBufferLayout.createView(e.geometry.buffer.array.buffer)),l.write(s,w,y.data,m,v);const O=y.instanceParameters.visible,H=!!y.instanceParameters.highlights&&O,B=!!y.instanceParameters.occludees,S=new p(y.id,v,v+b,O,H,B);f(null==e.instances.get(y.id)),e.instances.set(y.id,S),c?d.push(new _(S.from*n,S.to*n)):(u=Math.min(S.from,u),g=Math.max(S.to,g))}c||d.push(new _(u*n,g*n))}get test(){return{material:this._material,glMaterials:this._glMaterials,dataByOrigin:this._dataByOrigin}}}class A{constructor(e){this.origin=e,this.add=new Array,this.remove=new Array}}function D(e,t){const r=new Map;for(const s of e)E(r,s,!0);for(const s of t)E(r,s,!1);return r}function E(e,r,s){const a=r.origin;if(t(a))return;let i=e.get(a.id);null==i&&(i=new A(a.vec3),e.set(a.id,i)),s?i.add.push(r):i.remove.push(r)}function M(e){return e.hasOccludees||e.hasHighlights||e.hasHiddenInstances}function I(e,t){let r;if(!e.some((e=>!(e.to-e.from<t)&&(r=e,!0))))return null;const s=r.from;return r.from+=t,r.from>=r.to&&e.removeUnordered(r),s}function j(e){const t=new Map;e.forAll((e=>t.set(e.from,e)));let r=!0;for(;r;)r=!1,e.forEach((s=>{const a=t.get(s.to);a&&(s.to=a.to,t.delete(a.from),e.removeUnordered(a),r=!0)}))}class R{constructor(e,t){this.origin=e,this.geometry=t,this.instances=new Map,this.holes=new s({deallocator:null}),this.hasHiddenInstances=!1,this.hasHighlights=!1,this.hasOccludees=!1,this.drawCommandsDirty=!1,this.drawCommandsDefault=new s({allocator:e=>e||new b,deallocator:e=>e}),this.drawCommandsHighlight=new s({allocator:e=>e||new b,deallocator:e=>e}),this.drawCommandsOccludees=new s({allocator:e=>e||new b,deallocator:e=>e}),this.drawCommandsShadowHighlightRest=new s({allocator:e=>e||new b,deallocator:e=>e})}}class x extends g{constructor(e,t,r,s){super(e),this.geometry=t,this.renderCommands=r,this.occludeeCommands=s}}const P=new s({deallocator:null}),L=n(),T=n(),G=n();export{S as MergedRenderer};
