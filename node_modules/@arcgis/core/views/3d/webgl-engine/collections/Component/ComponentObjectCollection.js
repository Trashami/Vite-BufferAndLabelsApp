/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import has from"../../../../../core/has.js";import e from"../../../../../core/Logger.js";import{isNone as t,isSome as o,unwrap as r,applySome as n}from"../../../../../core/maybe.js";import i from"../../../../../core/PooledArray.js";import{e as s,t as a}from"../../../../../chunks/mat3.js";import{c}from"../../../../../chunks/mat3f32.js";import{d as m,y as l,t as f}from"../../../../../chunks/vec3.js";import{a as p,c as h}from"../../../../../chunks/vec3f64.js";import{c as b}from"../../../../../chunks/vec4f32.js";import{a as u}from"../../../../../chunks/vec32.js";import{c as d}from"../../../../../chunks/vec33.js";import{ViewingMode as g}from"../../../../ViewingMode.js";import{computeOffsetObb as y}from"../../../layers/i3s/I3SUtil.js";import{ColorMixModeEnum as j,encodeSymbolColor as C}from"../../../layers/support/symbolColorUtils.js";import{clone as v,radius as _}from"../../../support/orientedBoundingBox.js";import{glLayout as w}from"../../../support/buffer/glUtil.js";import{newLayout as M}from"../../../support/buffer/InterleavedLayout.js";import O from"./ComponentData.js";import{State as x,ComponentObject as A}from"./ComponentObject.js";import D from"./IntersectionGeometry.js";import{Renderable as S}from"./Renderable.js";import{RenderGeometry as I}from"./RenderGeometry.js";import{RenderSubmitSystem as P}from"./RenderSubmitSystem.js";import{createVertexBufferLayout as E}from"./SourceGeometry.js";import{ComponentParametersVarying as L,ComponentParametersUniform as R,ComponentParameterSummary as U,ComponentMaterial as k}from"./Material/ComponentMaterial.js";import{attributeLocations as T}from"./Material/ComponentTechnique.js";import{encodeElevationOffset as B}from"./Material/shader/ComponentData.glsl.js";import{getVisibility as V,updateVisibilityWithCount as G}from"../../lib/ComponentUtils.js";import{assert as N}from"../../lib/Util.js";import{VertexAttribute as q}from"../../lib/VertexAttribute.js";import{getVerticalOffsetI3S as H}from"../../lib/verticalOffsetUtils.js";import{EdgeInputBufferLayout as z}from"../../lib/edgeRendering/bufferLayouts.js";import{extractComponentsEdgeLocationsLayout as W}from"../../lib/edgeRendering/edgeProcessing.js";import{BufferManager as X}from"../../lib/TextureBackedBuffer/BufferManager.js";import{BufferObject as Y}from"../../../../webgl/BufferObject.js";import{Usage as F,PrimitiveType as J}from"../../../../webgl/enums.js";import{VertexArrayObject as K}from"../../../../webgl/VertexArrayObject.js";const Q=e.getLogger("esri.views.3d.webgl-engine.collections.Component.ComponentObjectCollection");class Z{constructor(e,t){this._renderManager=e,this._viewingMode=t,this._objects=[new i,new i],this._renderSubmit=new P(this),this._renderManager.register(this._renderSubmit),this._hasObjectAndLayerId=has("enable-feature:objectAndLayerId-rendering"),this._componentBufferManager=new X(e.rctx,2+(this._hasObjectAndLayerId?1:0))}dispose(){N(0===this._objects[x.Hidden].length&&0===this._objects[x.Visible].length,"ObjectCollection should be empty upon disposal"),this._componentBufferManager.destroy()}createObject(e){const t=new A;return t.toMapSpace=e.toMapSpace,t.transform=e.transform,t.obb=v(e.obb),t.components=new O(this._componentBufferManager,e.geometry.componentOffsets),t.renderable=this._createRenderable(e,t.components),t.intersectionGeometry=new D(e.geometry.positionData,t.components),this._objects[t.visible].push(t),t}destroyObject(e){const t=e;this._objects[t.visible].removeUnordered(t),t.dispose(),this._notifyDirty()}setObjectVisibility(e,t){const o=e;t!==o.visible&&(this._objects[o.visible].removeUnordered(o),this._objects[t].push(o),o.visible=t,this._notifyDirty())}preSubmit(e){const t=e.camera.eye;this.visibleObjects.forAll((e=>e.renderable.meta.cameraDepthSquared=m(t,e.obb.center)))}getMaterial(e){return e.renderable.material}updateMaterial(e,t){const o=e.renderable.material;t(o),o.dirty&&this._notifyDirty()}setAllComponentVisibilities(e,t){const o=e;o.components.visibility.reset(t),o.components.visibilityDirty(),this._notifyDirty()}forEachVisibleComponent(e,t){return e.components.visibility.forEachComponent(t)}getComponentCount(e){const t=e,o=t.components.visibility.componentCount();return{visible:o,invisible:t.components.count-o}}setComponentData(e,r){const n=e,i=n.renderable.material,s=n.components,a=s.materialDataBuffer,c=s.materialDataIndices,m={castShadows:!0,pickable:!0,externalColor:b(),externalColorMixMode:j.Multiply,elevationOffset:0,objectAndLayerIdColor:this._hasObjectAndLayerId?b():null},l=a.textureBuffer,f=new Uint8Array(4),p=new Uint32Array(f.buffer);let h=0,u=0,d=0,g=s.verticalOffsets,_=1/0,w=-1/0,M=!1,O=!1,x=0;for(let b=0;b<s.count;b++){if(r(b,m),h+=+(m.externalColor[3]<1),u+=+(m.externalColorMixMode===j.Replace&&1===m.externalColor[3]),d+=+m.castShadows,C(m.externalColor,m.externalColorMixMode,f),f[2]=254&f[2]|+m.castShadows,l.setData(c[b],0,f[0],f[1],f[2],f[3]),M||(M=b>0&&x!==p[0]),x=p[0],O||(O=0!==m.elevationOffset),O&&t(g)&&(g=new Array(b).fill(0)),o(g)&&(g[b]=m.elevationOffset),_=Math.min(_,m.elevationOffset),w=Math.max(w,m.elevationOffset),B(m.elevationOffset,f),l.setData(c[b],1,f[0],f[1],f[2],f[3]),this._hasObjectAndLayerId){const e=m.objectAndLayerIdColor;l.setData(c[b],2,e[0],e[1],e[2],e[3])}m.pickable!==V(s.pickability,b)&&(s.pickability=G(s.pickability,s.count,b,m.pickable))}s.verticalOffsets=O?g:null,n.offsetObb=O?y(n.obb,_,w,this._viewingMode,o(n.offsetObb)?n.offsetObb:v(n.obb)):null,M||O||this._hasObjectAndLayerId?(i.componentParameters=new L,i.componentParameters.castShadows=ee(d,s.count),i.componentParameters.transparent=ee(h,s.count),i.componentParameters.opaqueOverride=ee(u,s.count),i.componentParameters.texture=l,l.updateTexture()):(i.componentParameters=new R,i.componentParameters.castShadows=m.castShadows?U.All:U.None,i.componentParameters.externalColor=m.externalColor,i.componentParameters.externalColorMixMode=m.externalColorMixMode),this._notifyDirty()}getComponentAabb(e,o,n,i=!1){e.intersectionGeometry.getComponentAabb(o,n);const s=e,a=s.components.verticalOffsets;if(i||t(a))return n;const c=a[o];if(this._viewingMode===g.Local||0===c)return n[2]+=c,n[5]+=c,n;const m=r(H(c));return m.localOrigin=s.transform.position,m.applyToAabb(n)}getComponentObb(e){return e.obb}getObjectTransform(e){return e.transform}getComponentPositions(e,t,o){return e.intersectionGeometry.getComponentPositions(t,o)}intersect(e,t,r,n,i,c){const m=e;o(i)&&(i.localOrigin=m.transform.position);const p=s(te,m.transform.rotationScale);l(oe,t,m.transform.position),l(re,r,m.transform.position),f(oe,oe,p),f(re,re,p);const h=a(te,p);return m.intersectionGeometry.intersect(oe,re,n,h,i,m.components.verticalOffsets,c)}addEdges(e,t,o,r){const n=e,{indices:i,positions:s}=n.intersectionGeometry,a=n.components.offsets;return t.addComponentObject(e,n.transform,{center:n.obb.center,radius:_(n.obb)},s,i,a,o,r)}async extractEdgeInformation(e,t,o){const r=e,n=r.components.visibility;if(n.allInvisible())return{buffer:W.createBuffer(0),origin:[0,0,0]};const{indices:i,positions:s}=r.intersectionGeometry,a=r.components.offsets,c=z.createBuffer(s.count);d(c.position,s),u(c.position,c.position,r.transform.rotationScale),this._setComponentIndices(c.componentIndex,i,a);const m=c.count,l=this._computeVisibilityIndices(i,n,a,m);return{origin:p(r.transform.position),buffer:await t.extractComponentsEdgeLocations({indices:l,indicesLength:l.length,skipDeduplicate:!0,data:c,writerSettings:{reducedPrecision:!1,variants:0}},o)}}_setComponentIndices(e,t,o){let r=0;for(let n=0;n<o.length-1;n++){const i=o[n],s=o[n+1];for(let o=i;o<s;o++){const n=t?t[o]:o;e.set(n,r)}r++}}_computeVisibilityIndices(e,t,o,r){if(e&&t.allVisible())return e;let n=0;t.forEachComponentRange(((e,t)=>(n+=o[t]-o[e],!0)));const i=Array.isArray(e)?new Array(n):2===e?.BYTES_PER_ELEMENT||r<=65536?new Uint16Array(n):new Uint32Array(n);let s=0;return t.forEachComponentRange(((t,r)=>{const n=o[t],a=o[r];for(let o=n;o<a;o++)i[s++]=e?e[o]:o;return!0})),i}addComponentHighlight(e,o){const r=e.components;t(r.highlightCounts)&&(r.highlightCounts=new Uint32Array(r.count+1));0===r.highlightCounts[o]++&&(r.highlightsDirty(),this._notifyDirty()),r.highlightCounts[r.count]++}removeComponentHighlight(e,o){const r=e.components;if(t(r.highlightCounts))return void Q.warn("Removing non-existing highlight.");const n=r.highlightCounts[o],i=r.highlightCounts[r.count];if(0!==n){if(n>1)return r.highlightCounts[o]=n-1,void(r.highlightCounts[r.count]=i-1);r.highlightCounts[o]=0,r.highlightsDirty(),this._notifyDirty(),1===i?r.highlightCounts=null:r.highlightCounts[r.count]=i-1}else Q.warn("Removing non-existing highlight.")}clearHighlights(e){const t=e.components;o(t.highlightCounts)&&(t.highlightCounts=null,t.highlightsDirty(),this._notifyDirty())}getObjectGPUMemoryUsage(e){return e.renderable.meta.gpuMemoryEstimate}get visibleObjects(){return this._objects[x.Visible]}_createRenderable(e,t){const i=this._renderManager.rctx,s=e.geometry,a=s.vertices.layoutParameters,c=Y.createVertex(i,F.STATIC_DRAW,s.vertices.data),m=n(s.indices,(e=>Y.createIndex(i,F.STATIC_DRAW,e))),l=w(E(a)),f=new Uint16Array(s.vertices.count);for(let r=0;r<t.count;r++){const e=t.offsets[r],n=t.offsets[r+1],i=t.materialDataIndices[r];if(o(s.indices))for(let t=e;t<n;t++){f[s.indices[t]]=i}else for(let t=e;t<n;t++)f[t]=i}const p=Y.createVertex(i,F.STATIC_DRAW,f.buffer),h=new k(e.transform,e.toMapSpace),b=new K(i,T,{data:l,componentIndices:$},{data:c,componentIndices:p},r(m)),u=new I(b,J.TRIANGLES,a,o(m)),d={cameraDepthSquared:.5,gpuMemoryEstimate:c.byteSize+p.byteSize+(o(m)?m.byteSize:0)};return new S(h,u,d)}_notifyDirty(){this._renderManager.notifyDirty()}}const $=w(M().u16(q.COMPONENTINDEX));function ee(e,t){return e===t?U.All:0===e?U.None:U.Some}const te=c(),oe=h(),re=h();export{Z as ComponentObjectCollection};
