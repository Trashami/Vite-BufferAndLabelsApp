/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import e from"../../../../../core/Error.js";import r from"../../../../../core/Logger.js";import{isSome as t,isNone as n}from"../../../../../core/maybe.js";const s=r.getLogger("esri.views.3d.webgl-engine.core.shaderModules.shaderBuilder");class i{constructor(){this._includedModules=new Map}include(e,r){if(this._includedModules.has(e)){const t=this._includedModules.get(e);if(t!==r){s.error("Trying to include shader module multiple times with different sets of options.");const r=new Set;for(const n of Object.keys(t))t[n]!==e[n]&&r.add(n);for(const n of Object.keys(e))t[n]!==e[n]&&r.add(n);r.forEach((r=>console.error(`  ${r}: current ${t[r]} new ${e[r]}`)))}}else this._includedModules.set(e,r),e(this.builder,r)}}class o extends i{constructor(){super(...arguments),this.vertex=new u,this.fragment=new u,this.attributes=new m,this.varyings=new h,this.extensions=new d,this.constants=new l}get fragmentUniforms(){return this.fragment.uniforms.entries}get builder(){return this}generate(e){const r=this.extensions.generateSource(e),t=this.attributes.generateSource(e),n=this.varyings.generateSource(),s="vertex"===e?this.vertex:this.fragment,i=s.uniforms.generateSource(),o=s.code.generateSource(),a="vertex"===e?f:_,c=this.constants.generateSource().concat(s.constants.generateSource());return`\n${r.join("\n")}\n\n${a}\n\n${c.join("\n")}\n\n${i.join("\n")}\n\n${t.join("\n")}\n\n${n.join("\n")}\n\n${o.join("\n")}`}generateBind(e,r){const n=new Map;this.vertex.uniforms.entries.forEach((r=>{const s=r.bind[e];t(s)&&n.set(r.name,s)})),this.fragment.uniforms.entries.forEach((r=>{const s=r.bind[e];t(s)&&n.set(r.name,s)}));const s=Array.from(n.values()),i=s.length;return(e,t,n)=>{for(let o=0;o<i;++o)s[o](r,e,t,n)}}}class a{constructor(){this._entries=new Map}add(e){if(!Array.isArray(e))return this._add(e);for(const r of e)this._add(r)}get(e){return this._entries.get(e)}_add(r){if(n(r))s.error(`Trying to add null Uniform from ${(new Error).stack}.`);else{if(this._entries.has(r.name)&&!this._entries.get(r.name).equals(r))throw new e(`Duplicate uniform name ${r.name} for different uniform type`);this._entries.set(r.name,r)}}generateSource(){return Array.from(this._entries.values()).map((e=>t(e.arraySize)?`uniform ${e.type} ${e.name}[${e.arraySize}];`:`uniform ${e.type} ${e.name};`))}get entries(){return Array.from(this._entries.values())}}class c{constructor(){this._entries=new Array}add(e){this._entries.push(e)}generateSource(){return this._entries}}class u extends i{constructor(){super(...arguments),this.uniforms=new a,this.code=new c,this.constants=new l}get builder(){return this}}class m{constructor(){this._entries=new Array}add(e,r){this._entries.push([e,r])}generateSource(e){return"fragment"===e?[]:this._entries.map((e=>`attribute ${e[1]} ${e[0]};`))}}class h{constructor(){this._entries=new Array}add(e,r){this._entries.push([e,r])}generateSource(){return this._entries.map((e=>`varying ${e[1]} ${e[0]};`))}}class d{constructor(){this._entries=new Set}add(e){this._entries.add(e)}generateSource(e){const r="vertex"===e?d.ALLOWLIST_VERTEX:d.ALLOWLIST_FRAGMENT;return Array.from(this._entries).filter((e=>r.includes(e))).map((e=>`#extension ${e} : enable`))}}d.ALLOWLIST_FRAGMENT=["GL_EXT_shader_texture_lod","GL_OES_standard_derivatives"],d.ALLOWLIST_VERTEX=[];class l{constructor(){this._entries=new Set}add(e,r,t){let n="ERROR_CONSTRUCTOR_STRING";switch(r){case"float":n=l._numberToFloatStr(t);break;case"int":n=l._numberToIntStr(t);break;case"bool":n=t.toString();break;case"vec2":n=`vec2(${l._numberToFloatStr(t[0])},                            ${l._numberToFloatStr(t[1])})`;break;case"vec3":n=`vec3(${l._numberToFloatStr(t[0])},                            ${l._numberToFloatStr(t[1])},                            ${l._numberToFloatStr(t[2])})`;break;case"vec4":n=`vec4(${l._numberToFloatStr(t[0])},                            ${l._numberToFloatStr(t[1])},                            ${l._numberToFloatStr(t[2])},                            ${l._numberToFloatStr(t[3])})`;break;case"ivec2":n=`ivec2(${l._numberToIntStr(t[0])},                             ${l._numberToIntStr(t[1])})`;break;case"ivec3":n=`ivec3(${l._numberToIntStr(t[0])},                             ${l._numberToIntStr(t[1])},                             ${l._numberToIntStr(t[2])})`;break;case"ivec4":n=`ivec4(${l._numberToIntStr(t[0])},                             ${l._numberToIntStr(t[1])},                             ${l._numberToIntStr(t[2])},                             ${l._numberToIntStr(t[3])})`;break;case"mat2":case"mat3":case"mat4":n=`${r}(${Array.prototype.map.call(t,(e=>l._numberToFloatStr(e))).join(", ")})`}return this._entries.add(`const ${r} ${e} = ${n};`),this}static _numberToIntStr(e){return e.toFixed(0)}static _numberToFloatStr(e){return Number.isInteger(e)?e.toFixed(1):e.toString()}generateSource(){return Array.from(this._entries)}}const _="#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  precision highp sampler2D;\n#else\n  precision mediump float;\n  precision mediump sampler2D;\n#endif",f="precision highp float;\nprecision highp sampler2D;";export{c as Code,i as Includes,o as ShaderBuilder,u as Stage,a as Uniforms};
