/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{getOrCreateMapValue as e}from"../../../../core/MapUtils.js";import{eachAlwaysValues as t}from"../../../../core/promiseUtils.js";import{isDataProtocol as r,dataComponents as s,dataToArrayBuffer as n,makeAbsolute as o}from"../../../../core/urlUtils.js";import{Version as a}from"../../../../core/Version.js";import{y as i,m as u,v as c,e as f,k as d}from"../../../../chunks/mat4.js";import{c as p,b as m}from"../../../../chunks/mat4f64.js";import{g as l}from"../../../../chunks/quat.js";import{a as h}from"../../../../chunks/quatf64.js";import{BufferViewUint32 as y,BufferViewUint16 as b,BufferViewUint8 as T,BufferViewVec3f as _,BufferViewVec4f as x,BufferViewVec2f as w,BufferViewVec4u8 as O,BufferViewVec4u16 as N,BufferViewVec3u8 as g,BufferViewVec3u16 as C,BufferViewVec2u32 as S,BufferViewVec2u16 as U,BufferViewVec2i16 as I,BufferViewVec2u8 as L,BufferViewVec2i8 as A}from"../../../../geometry/support/buffer/BufferView.js";import{m as E}from"../../../../chunks/scalar.js";import{BinaryStreamReader as R}from"./BinaryStreamReader.js";import{AttributeType as v}from"./enums.js";import{material as B,textureSampler as D}from"./fillDefaults.js";import{splitURI as G}from"./pathUtils.js";import{DataType as j}from"../../../webgl/enums.js";const M={MAGIC:1179937895,CHUNK_TYPE_JSON:1313821514,CHUNK_TYPE_BIN:5130562,MIN_HEADER_LENGTH:20};class F{constructor(e,t,r,s,n){this._context=e,this._errorContext=t,this.uri=r,this.json=s,this._glbBuffer=n,this._bufferLoaders=new Map,this._textureLoaders=new Map,this._textureCache=new Map,this._materialCache=new Map,this._nodeParentMap=new Map,this._nodeTransformCache=new Map,this._baseUri=G(this.uri).dirPart,this._checkVersionSupported(),this._checkRequiredExtensionsSupported(),t.errorUnsupportedIf(null==s.scenes,"Scenes must be defined."),t.errorUnsupportedIf(null==s.meshes,"Meshes must be defined"),t.errorUnsupportedIf(null==s.nodes,"Nodes must be defined."),this._computeNodeParents()}static async load(e,t,o,a){if(r(o)){const r=s(o);if(r&&"model/gltf-binary"!==r.mediaType)try{const s=JSON.parse(r.isBase64?atob(r.data):r.data);return new F(e,t,o,s)}catch{}const a=n(o);if(F._isGLBData(a))return this._fromGLBData(e,t,o,a)}if(o.endsWith(".gltf")){const r=await e.loadJSON(o,a);return new F(e,t,o,r)}const i=await e.loadBinary(o,a);if(F._isGLBData(i))return this._fromGLBData(e,t,o,i);const u=await e.loadJSON(o,a);return new F(e,t,o,u)}static _isGLBData(e){if(null==e)return!1;const t=new R(e);return t.remainingBytes()>=4&&t.readUint32()===M.MAGIC}static async _fromGLBData(e,t,r,s){const n=await F._parseGLBData(t,s);return new F(e,t,r,n.json,n.binaryData)}static async _parseGLBData(e,t){const r=new R(t);e.assert(r.remainingBytes()>=12,"GLB binary data is insufficiently large.");const s=r.readUint32(),n=r.readUint32(),o=r.readUint32();e.assert(s===M.MAGIC,"Magic first 4 bytes do not fit to expected GLB value."),e.assert(t.byteLength>=o,"GLB binary data is smaller than header specifies."),e.errorUnsupportedIf(2!==n,"An unsupported GLB container version was detected. Only version 2 is supported.");let a,i,u=0;for(;r.remainingBytes()>=8;){const t=r.readUint32(),s=r.readUint32();0===u?(e.assert(s===M.CHUNK_TYPE_JSON,"First GLB chunk must be JSON."),e.assert(t>=0,"No JSON data found."),a=await K(r.readUint8Array(t))):1===u?(e.errorUnsupportedIf(s!==M.CHUNK_TYPE_BIN,"Second GLB chunk expected to be BIN."),i=r.readUint8Array(t)):e.warnUnsupported("More than 2 GLB chunks detected. Skipping."),u+=1}return a||e.error("No GLB JSON chunk detected."),{json:a,binaryData:i}}async getBuffer(e,t){const r=this.json.buffers[e],s=this._errorContext;if(null==r.uri)return s.assert(null!=this._glbBuffer,"GLB buffer not present"),this._glbBuffer;const n=await this._getBufferLoader(e,t);return s.assert(n.byteLength===r.byteLength,"Buffer byte lengths should match."),n}async _getBufferLoader(e,t){const r=this._bufferLoaders.get(e);if(r)return r;const s=this.json.buffers[e].uri,n=this._context.loadBinary(this._resolveUri(s),t).then((e=>new Uint8Array(e)));return this._bufferLoaders.set(e,n),n}async getAccessor(e,t){const r=this._errorContext;r.errorUnsupportedIf(!this.json.accessors,"Accessors missing.");const s=this.json.accessors[e];r.errorUnsupportedIf(null==s?.bufferView,"Some accessor does not specify a bufferView."),r.errorUnsupportedIf(s.type in[v.MAT2,v.MAT3,v.MAT4],`AttributeType ${s.type} is not supported`);const n=this.json.bufferViews[s.bufferView],o=await this.getBuffer(n.buffer,t),a=V[s.type],i=Y[s.componentType],u=a*i,c=n.byteStride||u;return{raw:o.buffer,byteStride:c,byteOffset:o.byteOffset+(n.byteOffset||0)+(s.byteOffset||0),entryCount:s.count,isDenselyPacked:c===u,componentCount:a,componentByteSize:i,componentType:s.componentType,min:s.min,max:s.max,normalized:!!s.normalized}}async getIndexData(e,t){if(null==e.indices)return;const r=await this.getAccessor(e.indices,t);if(r.isDenselyPacked)switch(r.componentType){case j.UNSIGNED_BYTE:return new Uint8Array(r.raw,r.byteOffset,r.entryCount);case j.UNSIGNED_SHORT:return new Uint16Array(r.raw,r.byteOffset,r.entryCount);case j.UNSIGNED_INT:return new Uint32Array(r.raw,r.byteOffset,r.entryCount)}else switch(r.componentType){case j.UNSIGNED_BYTE:return E(this._wrapAccessor(T,r));case j.UNSIGNED_SHORT:return E(this._wrapAccessor(b,r));case j.UNSIGNED_INT:return E(this._wrapAccessor(y,r))}}async getPositionData(e,t){const r=this._errorContext;r.errorUnsupportedIf(null==e.attributes.POSITION,"No POSITION vertex data found.");const s=await this.getAccessor(e.attributes.POSITION,t);return r.errorUnsupportedIf(s.componentType!==j.FLOAT,"Expected type FLOAT for POSITION vertex attribute, but found "+j[s.componentType]),r.errorUnsupportedIf(3!==s.componentCount,"POSITION vertex attribute must have 3 components, but found "+s.componentCount.toFixed()),this._wrapAccessor(_,s)}async getNormalData(e,t){const r=this._errorContext;r.assert(null!=e.attributes.NORMAL,"No NORMAL vertex data found.");const s=await this.getAccessor(e.attributes.NORMAL,t);return r.errorUnsupportedIf(s.componentType!==j.FLOAT,"Expected type FLOAT for NORMAL vertex attribute, but found "+j[s.componentType]),r.errorUnsupportedIf(3!==s.componentCount,"NORMAL vertex attribute must have 3 components, but found "+s.componentCount.toFixed()),this._wrapAccessor(_,s)}async getTangentData(e,t){const r=this._errorContext;r.assert(null!=e.attributes.TANGENT,"No TANGENT vertex data found.");const s=await this.getAccessor(e.attributes.TANGENT,t);return r.errorUnsupportedIf(s.componentType!==j.FLOAT,"Expected type FLOAT for TANGENT vertex attribute, but found "+j[s.componentType]),r.errorUnsupportedIf(4!==s.componentCount,"TANGENT vertex attribute must have 4 components, but found "+s.componentCount.toFixed()),new x(s.raw,s.byteOffset,s.byteStride,s.byteOffset+s.byteStride*s.entryCount)}async getTextureCoordinates(e,t){const r=this._errorContext;r.assert(null!=e.attributes.TEXCOORD_0,"No TEXCOORD_0 vertex data found.");const s=await this.getAccessor(e.attributes.TEXCOORD_0,t);return r.errorUnsupportedIf(2!==s.componentCount,"TEXCOORD_0 vertex attribute must have 2 components, but found "+s.componentCount.toFixed()),s.componentType===j.FLOAT?this._wrapAccessor(w,s):(r.errorUnsupportedIf(!s.normalized,"Integer component types are only supported for a normalized accessor for TEXCOORD_0."),J(s))}async getVertexColors(e,t){const r=this._errorContext;r.assert(null!=e.attributes.COLOR_0,"No COLOR_0 vertex data found.");const s=await this.getAccessor(e.attributes.COLOR_0,t);if(r.errorUnsupportedIf(4!==s.componentCount&&3!==s.componentCount,"COLOR_0 attribute must have 3 or 4 components, but found "+s.componentCount.toFixed()),4===s.componentCount){if(s.componentType===j.FLOAT)return this._wrapAccessor(x,s);if(s.componentType===j.UNSIGNED_BYTE)return this._wrapAccessor(O,s);if(s.componentType===j.UNSIGNED_SHORT)return this._wrapAccessor(N,s)}else if(3===s.componentCount){if(s.componentType===j.FLOAT)return this._wrapAccessor(_,s);if(s.componentType===j.UNSIGNED_BYTE)return this._wrapAccessor(g,s);if(s.componentType===j.UNSIGNED_SHORT)return this._wrapAccessor(C,s)}r.errorUnsupported("Unsupported component type for COLOR_0 attribute: "+j[s.componentType])}hasPositions(e){return void 0!==e.attributes.POSITION}hasNormals(e){return void 0!==e.attributes.NORMAL}hasVertexColors(e){return void 0!==e.attributes.COLOR_0}hasTextureCoordinates(e){return void 0!==e.attributes.TEXCOORD_0}hasTangents(e){return void 0!==e.attributes.TANGENT}async getMaterial(e,t,r){let s=e.material?this._materialCache.get(e.material):void 0;if(!s){const n=null!=e.material?B(this.json.materials[e.material]):B(),o=n.pbrMetallicRoughness,a=this.hasVertexColors(e),i=this.getTexture(o.baseColorTexture,t),u=this.getTexture(n.normalTexture,t),c=r?this.getTexture(n.occlusionTexture,t):void 0,f=r?this.getTexture(n.emissiveTexture,t):void 0,d=r?this.getTexture(o.metallicRoughnessTexture,t):void 0,p=null!=e.material?e.material:-1;s={alphaMode:n.alphaMode,alphaCutoff:n.alphaCutoff,color:o.baseColorFactor,doubleSided:!!n.doubleSided,colorTexture:await i,normalTexture:await u,name:n.name,id:p,occlusionTexture:await c,emissiveTexture:await f,emissiveFactor:n.emissiveFactor,metallicFactor:o.metallicFactor,roughnessFactor:o.roughnessFactor,metallicRoughnessTexture:await d,hasVertexColors:a,ESRI_externalColorMixMode:n.extras.ESRI_externalColorMixMode,colorTextureTransform:o?.baseColorTexture?.extensions?.KHR_texture_transform,normalTextureTransform:n.normalTexture?.extensions?.KHR_texture_transform,occlusionTextureTransform:n.occlusionTexture?.extensions?.KHR_texture_transform,emissiveTextureTransform:n.emissiveTexture?.extensions?.KHR_texture_transform,metallicRoughnessTextureTransform:o?.metallicRoughnessTexture?.extensions?.KHR_texture_transform}}return s}async getTexture(t,r){if(!t)return;this._errorContext.errorUnsupportedIf(0!==(t.texCoord||0),"Only TEXCOORD with index 0 is supported.");const s=t.index,n=this._errorContext,o=this.json.textures[s],a=D(null!=o.sampler?this.json.samplers[o.sampler]:{});n.errorUnsupportedIf(null==o.source,"Source is expected to be defined for a texture.");const i=this.json.images[o.source],u=await this._loadTextureImageData(s,o,r);return e(this._textureCache,s,(()=>{const e=e=>33071===e||33648===e||10497===e,t=e=>(n.error(`Unexpected TextureSampler WrapMode: ${e}. Using default REPEAT(10497).`),10497);return{data:u,wrapS:e(a.wrapS)?a.wrapS:t(a.wrapS),wrapT:e(a.wrapT)?a.wrapT:t(a.wrapT),minFilter:a.minFilter,name:i.name,id:s}}))}getNodeTransform(e){if(void 0===e)return k;let t=this._nodeTransformCache.get(e);if(!t){const r=this.getNodeTransform(this._getNodeParent(e)),s=this.json.nodes[e];s.matrix?t=u(p(),r,s.matrix):s.translation||s.rotation||s.scale?(t=m(r),s.translation&&c(t,t,s.translation),s.rotation&&(H[3]=l(H,s.rotation),f(t,t,H[3],H)),s.scale&&d(t,t,s.scale)):t=r,this._nodeTransformCache.set(e,t)}return t}_wrapAccessor(e,t){return new e(t.raw,t.byteOffset,t.byteStride,t.byteOffset+t.byteStride*(t.entryCount-1)+t.componentByteSize*t.componentCount)}_resolveUri(e){return o(e,this._baseUri)}_getNodeParent(e){return this._nodeParentMap.get(e)}_checkVersionSupported(){const e=a.parse(this.json.asset.version,"glTF");P.validate(e)}_checkRequiredExtensionsSupported(){const e=this.json,t=this._errorContext;e.extensionsRequired&&0!==e.extensionsRequired.length&&t.errorUnsupported("gltf loader was not able to load unsupported feature. Required extensions: "+e.extensionsRequired.join(", "))}_computeNodeParents(){this.json.nodes.forEach(((e,t)=>{e.children&&e.children.forEach((e=>{this._nodeParentMap.set(e,t)}))}))}async _loadTextureImageData(e,t,r){const s=this._textureLoaders.get(e);if(s)return s;const n=this._createTextureLoader(t,r);return this._textureLoaders.set(e,n),n}async _createTextureLoader(e,t){const r=this.json.images[e.source];if(r.uri)return this._context.loadImage(this._resolveUri(r.uri),t);const s=this._errorContext;s.errorUnsupportedIf(null==r.bufferView,"Image bufferView must be defined."),s.errorUnsupportedIf(null==r.mimeType,"Image mimeType must be defined.");const n=this.json.bufferViews[r.bufferView],o=await this.getBuffer(n.buffer,t);return s.errorUnsupportedIf(null!=n.byteStride,"byteStride not supported for image buffer"),q(new Uint8Array(o.buffer,o.byteOffset+(n.byteOffset||0),n.byteLength),r.mimeType)}async getLoadedBuffersSize(){if(this._glbBuffer)return this._glbBuffer.byteLength;const e=await t(Array.from(this._bufferLoaders.values())),r=await t(Array.from(this._textureLoaders.values()));return e.reduce(((e,t)=>e+(t?.byteLength??0)),0)+r.reduce(((e,t)=>e+(t?t.width*t.height*4:0)),0)}}const P=new a(2,0,"glTF"),k=i(p(),Math.PI/2),H=h(),V={SCALAR:1,VEC2:2,VEC3:3,VEC4:4},Y={[j.BYTE]:1,[j.UNSIGNED_BYTE]:1,[j.SHORT]:2,[j.UNSIGNED_SHORT]:2,[j.FLOAT]:4,[j.UNSIGNED_INT]:4};function J(e){switch(e.componentType){case j.BYTE:return new A(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount);case j.UNSIGNED_BYTE:return new L(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount);case j.SHORT:return new I(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount);case j.UNSIGNED_SHORT:return new U(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount);case j.UNSIGNED_INT:return new S(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount);case j.FLOAT:return new w(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount)}}async function K(e){return new Promise(((t,r)=>{const s=new Blob([e]),n=new FileReader;n.onload=()=>{const e=n.result;t(JSON.parse(e))},n.onerror=e=>{r(e)},n.readAsText(s)}))}async function q(e,t){return new Promise(((r,s)=>{const n=new Blob([e],{type:t}),o=URL.createObjectURL(n),a=new Image,i=()=>{URL.revokeObjectURL(o),"decode"in a?a.decode().then((()=>r(a)),(()=>r(a))).then(c):(r(a),c())},u=e=>{URL.revokeObjectURL(o),s(e),c()},c=()=>{a.removeEventListener("load",i),a.removeEventListener("error",u)};a.addEventListener("load",i),a.addEventListener("error",u),a.src=o}))}export{F as GLTFResource};
