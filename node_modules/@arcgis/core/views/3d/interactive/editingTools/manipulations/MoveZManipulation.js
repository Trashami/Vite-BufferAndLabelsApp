/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{darken as t}from"../../../../../core/colorUtils.js";import e from"../../../../../core/Evented.js";import{clamp as r}from"../../../../../core/mathUtils.js";import{unwrap as a}from"../../../../../core/maybe.js";import{v as i,r as o,k as s}from"../../../../../chunks/mat4.js";import{c as n}from"../../../../../chunks/mat4f64.js";import{j as l,b as m,n as p,e as u,f as c,g as d}from"../../../../../chunks/vec3.js";import{c as h,f}from"../../../../../chunks/vec3f64.js";import{Manipulator3D as M}from"../../Manipulator3D.js";import{createManipulatorMaterial as _}from"../../manipulatorUtils.js";import{screenToZConstrained as g}from"../dragEventPipeline3D.js";import{ManipulatorType as j}from"../ManipulatorType.js";import{settings as v}from"../settings.js";import{DISC_RADIUS as y}from"./config.js";import{Manipulation as w}from"./Manipulation.js";import{createGraphicMoveDragPipeline as k}from"./moveUtils.js";import{createTubeGeometry as b,createConeGeometry as z}from"../../../webgl-engine/lib/GeometryUtil.js";import{RenderOccludedFlag as U}from"../../../webgl-engine/lib/Material.js";import{createManipulatorDragEventPipeline as P,addScreenDelta as E}from"../../../../interactive/dragEventPipeline.js";import{ManipulatorStateFlags as O}from"../../../../interactive/interfaces.js";class T extends w{constructor(t){super(),this._radius=y,this.events=new e,this._tool=t.tool,this._view=t.view,null!=t.radius&&(this._radius=t.radius),this._createManipulator(),this.forEachManipulator((t=>this._tool.manipulators.add(t)))}destroy(){this.forEachManipulator((t=>{this._tool.manipulators.remove(t),t.destroy()}))}forEachManipulator(t){t(this._manipulator,j.TRANSLATE_Z)}createGraphicDragPipeline(t,e,r){const i=a(e.graphic.geometry).spatialReference;return k(e,r,(e=>this.createDragPipeline(((r,a,i,o,s)=>e(r,t(r,a,i,o,s),i)),i)),this._view.state.viewingMode)}createDragPipeline(t,e){const r=this._view;return P(this._manipulator,((a,i,o,s,n)=>{const l=i.next((t=>({...t,manipulatorType:j.TRANSLATE_Z}))).next(g(r,a.renderLocation,e)).next(E());t(a,l,o,s,n)}))}get radius(){return this._radius}set radius(t){t!==this._radius&&(this._radius=t,this._updateManipulator())}_updateManipulator(){const e=this._radius/y,r=v.zManipulator.height*e,a=v.zManipulator.coneHeight*e,l=v.zManipulator.coneWidth*e,m=v.zManipulator.width*e,p=[f(0,0,0),f(0,0,r)],u=b(p,m/2,16,!1),c=z(a,l/2,16,!1),d=[f(0,0,0),f(0,0,r+a)],h=t=>{const e=n();if(i(e,e,[0,0,r]),o(e,e,Math.PI/2),t){const r=1+2*t/l;s(e,e,[r,r,r])}return e},M=h(0),g=(e,r)=>{const a=t(v.zManipulator.color,r);return[a.r/255,a.g/255,a.b/255,v.zManipulator.color.a*e]},j=_(g(1,.25),U.Occlude),w=_(g(1,0),U.Occlude),k=_(g(.7,0),v.zManipulator.renderOccluded),P=_(g(.85,0),v.zManipulator.renderOccluded);this._manipulator.renderObjects=[{geometry:c,transform:M,material:j,stateMask:O.Unfocused},{geometry:u,material:j,stateMask:O.Unfocused},{geometry:c,transform:M,material:w,stateMask:O.Focused},{geometry:u,material:w,stateMask:O.Focused},{geometry:c,transform:M,material:k,stateMask:O.Unfocused},{geometry:u,material:k,stateMask:O.Unfocused},{geometry:c,transform:M,material:P,stateMask:O.Focused},{geometry:u,material:P,stateMask:O.Focused}],this._manipulator.radius=m/2+2,this._manipulator.collisionType={type:"line",paths:[d]}}_createManipulator(){const t=new M({view:this._view,autoScaleRenderObjects:!1,worldSized:!1,selectable:!1,cursor:"ns-resize",elevationInfo:this.elevationInfo,worldOriented:!0,collisionPriority:1.6});t.applyObjectTransform=t=>{const e=this._view.state.camera,a=A;this._view.renderCoordsHelper.toRenderCoords(this._manipulator.elevationAlignedLocation,a);const i=l(e.eye,a),o=e.computeRenderPixelSizeAtDist(i),s=m(x,a,e.eye);p(s,s);const n=D;this._view.renderCoordsHelper.worldUpAtPosition(A,n);const h=Math.abs(u(s,n)),f=c(x,s,n),M=c(x,f,n),_=r(h,.01,1),g=1-Math.sqrt(1-_*_)/_/e.fullWidth,j=this._radius/y,w=v.zManipulator.width*j;d(M,p(M,M),(1/g-1)*i+o*w),t[12]-=x[0],t[13]-=x[1],t[14]-=x[2]},this._manipulator=t,this._updateManipulator()}get test(){return{manipulator:this._manipulator}}}const A=h(),x=h(),D=h();export{T as MoveZManipulation};
