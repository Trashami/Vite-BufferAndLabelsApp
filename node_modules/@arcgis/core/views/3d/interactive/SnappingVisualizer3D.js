/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import e from"../../../Color.js";import"../../../core/has.js";import{destroyHandle as n}from"../../../core/handleUtils.js";import{unwrapOr as i,isNone as t,isSome as o,unwrap as r}from"../../../core/maybe.js";import{h as a}from"../../../chunks/vec3.js";import{c as l}from"../../../chunks/vec3f64.js";import s from"../../../geometry/Point.js";import{ExtendedLineVisualElement as p,ExtensionType as c}from"./visualElements/ExtendedLineVisualElement.js";import{ParallelLineVisualElement as d}from"./visualElements/ParallelLineVisualElement.js";import{PointVisualElement as m}from"./visualElements/PointVisualElement.js";import{RightAngleQuadVisualElement as g}from"./visualElements/RightAngleQuadVisualElement.js";import{RenderOccludedFlag as u}from"../webgl-engine/lib/Material.js";import{defaults as f}from"../../interactive/snapping/Settings.js";import{SnappingDomain as v}from"../../interactive/snapping/SnappingDomain.js";import{LineSegmentHintType as h}from"../../interactive/snapping/snappingUtils.js";import{SnappingVisualizer as E}from"../../interactive/snapping/SnappingVisualizer.js";import{anyMapPointToRender as S,anyMapPointsToRenderWithEqualRelativeZ as w}from"../../interactive/support/viewUtils.js";class _ extends E{visualizeIntersectionPoint(t,o){const{coordinateHelper:r,view:a}=o;return n(new m({view:a,primitive:"circle",geometry:r.vectorToPoint(t.intersectionPoint),elevationInfo:i(t.elevationInfo,o.elevationInfo),size:20,outlineSize:2,color:[0,0,0,0],outlineColor:e.toUnitRGBA(f.orange),pixelSnappingEnabled:!1}))}visualizePoint(i,t){const{view:o,coordinateHelper:r}=t,a=this._alignPoint(i.point,i.domain,t);return n(new m({view:o,primitive:"circle",geometry:r.vectorToPoint(a),elevationInfo:this._hintElevationInfo(i,t),size:20,outlineSize:2,color:[0,0,0,0],outlineColor:e.toUnitRGBA(f.orange),pixelSnappingEnabled:!1}))}visualizeLine(e,i){const{view:t,coordinateHelper:o}=i,r=this._alignPoint(e.lineStart,e.domain,i),a=this._alignPoint(e.lineEnd,e.domain,i);return n(this._createLineSegmentHintFromMap(e.type,r,a,o,this._hintElevationInfo(e,i),t,e.fadeLeft,e.fadeRight))}visualizeParallelSign(i,t){const{view:o,coordinateHelper:r}=t,l=this._hintElevationInfo(i,t),s=this._alignPoint(i.lineStart,i.domain,t),p=this._alignPoint(i.lineEnd,i.domain,t),c=S(s,r,l,o),m=S(p,r,l,o),g=a(m,c,m,.5),v=new d({view:o,attached:!1,offset:f.parallelLineHintOffset,length:f.parallelLineHintLength,width:f.parallelLineHintWidth,color:e.toUnitRGBA(f.orange),location:g,renderOccluded:u.Opaque});return v.setDirectionFromPoints(c,g),v.attached=!0,n(v)}visualizeRightAngleQuad(i,t){const{view:o,coordinateHelper:r}=t,a=this._hintElevationInfo(i,t),l=this._alignPoint(i.previousVertex,i.domain,t),s=this._alignPoint(i.centerVertex,i.domain,t),p=this._alignPoint(i.nextVertex,i.domain,t);return n(new g({view:o,attached:!0,color:e.toUnitRGBA(f.orange),renderOccluded:u.Transparent,outlineRenderOccluded:u.Opaque,outlineColor:e.toUnitRGBA(f.orange),outlineSize:f.rightAngleHintOutlineSize,size:f.rightAngleHintSize,geometry:{previous:S(l,r,a,o),center:S(s,r,a,o),next:S(p,r,a,o)}}))}_createLineSegmentHintFromMap(e,n,i,t,o,r,a=!0,s=!0){const p=l(),c=l();return w(n,i,t,o,r,p,c),this._createLineSegmentHint(e,r,p,c,a,s)}_createLineSegmentHint(n,i,t,o,r=!0,a=!0){const l=new p({view:i,extensionType:c.FADED,start:t,end:o,color:e.toUnitRGBA(f.orange),renderOccluded:u.Opaque});switch(n){case h.TARGET:l.width=f.lineHintWidthTarget,l.fadedExtensions={start:0,end:f.lineHintFadedExtensions};break;case h.REFERENCE_EXTENSION:l.width=f.lineHintWidthReference,l.fadedExtensions={start:0,end:0};break;case h.REFERENCE:l.width=f.lineHintWidthReference,l.fadedExtensions={start:r?f.lineHintFadedExtensions:0,end:a?f.lineHintFadedExtensions:0}}return l.attached=!0,l}_alignPoint(e,n,i){const o=this._getSelfSnappingZ(n,i);if(t(o))return e;const r=i.coordinateHelper,a=r.vectorToPoint(e,H);return a.z=o,r.pointToVector(a)}_hintElevationInfo(e,n){return o(this._getSelfSnappingZ(e.domain,n))?r(n.selfSnappingZ).elevationInfo:i(e.elevationInfo,n.elevationInfo)}_getSelfSnappingZ(e,{selfSnappingZ:n}){return e===v.SELF&&o(n)?n.value:null}}const H=new s;export{_ as SnappingVisualizer3D};
