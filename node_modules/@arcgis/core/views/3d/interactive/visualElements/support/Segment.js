/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{h as t,b as e,n as s,g as r,a as i,c as n}from"../../../../../chunks/vec3.js";import{c as o,a as p}from"../../../../../chunks/vec3f64.js";import{canProjectWithoutEngine as c,projectVectorToVector as a}from"../../../../../geometry/projection.js";import{getSphericalPCPF as h}from"../../../../../geometry/projectionEllipsoid.js";import{sv3d as d}from"../../../../../geometry/support/vectorStacks.js";import{slerpTangent as _,slerp as f}from"../../../support/mathUtils.js";class l{constructor(t=o(),e=o()){this.startRenderSpace=t,this.endRenderSpace=e,this.type="euclidean"}eval(r,i,n){return t(i,this.startRenderSpace,this.endRenderSpace,r),n&&(e(n,this.endRenderSpace,this.startRenderSpace),s(n,n)),i}createRenderGeometry(t,s){const r=[],i=[],n=(s,n)=>{const o=u;e(o,s,t),r.push([o[0],o[1],o[2]]),i.push([n[0],n[1],n[2]])},o=s.worldUpAtPosition(this.eval(.5,R),d.get());return n(this.startRenderSpace,o),n(this.endRenderSpace,o),{points:r,normals:i}}static fromPositionAndVector(t,e,s=1){return r(R,e,s),i(R,t,R),new l(p(t),p(R))}}class m{constructor(t,e,s){this.startRenderSpace=t,this.endRenderSpace=e,this.renderSpatialReference=s,this.type="geodesic",this._start=o(),this._end=o(),this._pcpf=h(s),this._project=c(s,this._pcpf),this._projectIn(t,this._start),this._projectIn(e,this._end)}_projectIn(t,e){this._project?a(t,this.renderSpatialReference,e,this._pcpf):n(e,t)}eval(r,n,o){if(this._project)if(o){const t=u;_(this._start,this._end,r,n,t),i(S,n,t),a(n,this._pcpf,n,this.renderSpatialReference),a(S,this._pcpf,S,this.renderSpatialReference),e(o,S,n),s(o,o)}else f(this._start,this._end,r,n),a(n,this._pcpf,n,this.renderSpatialReference);else t(n,this._start,this._end,r),o&&(e(o,this._end,this._start),s(o,o));return n}createRenderGeometry(t,s){const r=[],i=[],n=(s,n)=>{const o=S;e(o,s,t),r.push([o[0],o[1],o[2]]),i.push([n[0],n[1],n[2]])},o=128+1&-2;for(let e=0;e<o;++e){const t=e/(o-1),r=R,i=u;this.eval(t,r),s.worldUpAtPosition(r,i),n(r,i)}return{points:r,normals:i}}}const R=o(),u=o(),S=o();export{l as EuclideanSegment,m as GeodesicSegment};
