/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../../chunks/tslib.es6.js";import{asinClamped as i}from"../../../../../core/mathUtils.js";import{isSome as e}from"../../../../../core/maybe.js";import{createScreenPointArray as n,screenPointObjectToArray as o}from"../../../../../core/screenUtils.js";import"../../../../../core/Logger.js";import"../../../../../core/accessorSupport/ensureType.js";import"../../../../../core/arrayUtils.js";import"../../../../../core/Error.js";import"../../../../../core/has.js";import{subclass as s}from"../../../../../core/accessorSupport/decorators/subclass.js";import{d as r}from"../../../../../chunks/vec2.js";import{o as a,c as m,e as h,g as c,b as l,n as p,l as _,a as u}from"../../../../../chunks/vec3.js";import{c as d,f as C}from"../../../../../chunks/vec3f64.js";import{wrapAxisAngle as g}from"../../../../../geometry/support/axisAngle.js";import{create as M,fromNormalAndOffset as v,setOffsetFromPoint as f,negate as b,normal as w}from"../../../../../geometry/support/plane.js";import{pixelDistanceToInteractionFactor as j,applyAll as E}from"../../../camera/constraintUtils.js";import{ConstraintTypes as P}from"../../../camera/constraintUtils/ConstraintTypes.js";import{InteractionType as S}from"../../../camera/constraintUtils/InteractionType.js";import{TiltMode as V}from"../../../camera/constraintUtils/TiltMode.js";import{ExponentialFalloff as z}from"../../../input/util.js";import{InteractiveController as H}from"../InteractiveController.js";import{PanPlanarMomentumController as O}from"../momentum/PanPlanarMomentumController.js";import{RotationMomentumController as y}from"../momentum/RotationMomentumController.js";import{ZoomPlanarMomentumController as T}from"../momentum/ZoomPlanarMomentumController.js";import{NavigationMode as L,centroid as A,applyZoomToPoint as F,applyPanPlanar as U,normalizeRotationDelta as x,applyRotation as R,intersectPlaneFromScreenPointAtEye as D}from"../../utils/navigationUtils.js";import{Camera as N}from"../../../webgl-engine/lib/Camera.js";import{PanPlanarMomentumEstimator as k}from"../../../../navigation/PanPlanarMomentumEstimator.js";import{RotationMomentumEstimator as I}from"../../../../navigation/RotationMomentumEstimator.js";import{ZoomMomentumEstimator as G}from"../../../../navigation/ZoomMomentumEstimator.js";const Z=C(0,0,1),B={ELEVATION_THRESHOLD:3e4,ANGLE_THRESHOLD:16/180*Math.PI},W=80;let q=class extends H{constructor(){super(...arguments),this._rotationValueSmooth=new z(.05),this._scalingValueSmooth=new z(.05),this._planeHorizontal=M(),this._planeVertical=M(),this._rotationMomentumEstimator=new I,this._panMomentumEstimator=new k(300,12,.9),this._zoomMomentumEstimator=new G,this._beginCenter=d(),this._tmpPoints=[],this._beginCenterScreen=n(),this._tmpCentroid3d=d(),this._tmpCentroid2d=n(),this._tmp2d=n(),this._constraintOptions={selection:P.ALL,interactionType:S.NONE,interactionFactor:0,interactionStartCamera:new N,interactionDirection:null,tiltMode:V.TUMBLE}}begin(t){if(!this.active)return;const n=this.view.navigation.momentumEnabled;this._zoomMomentumEstimator.enabled=n,this._rotationMomentumEstimator.enabled=n,this._panMomentumEstimator.enabled=n,this._beginRadius=t.radius,this._pointerCount=t.pointers.size,this._beginAngle=t.angle,this._rotationValueSmooth.reset(),this._scalingValueSmooth.reset(),o(t.center,this._beginCenterScreen),v(Z,0,this._planeHorizontal);const s=d(),r=this._intersectionHelper.intersectScreenFreePointFallback(this._beginCenterScreen,s),C=d();a(C,this.startCamera.viewForward);const g=d();m(g,Z);const M=h(C,g),w=i(M<0?-M:M);if(this._panMode=w>=B.ANGLE_THRESHOLD?L.Horizontal:L.Vertical,f(this._planeHorizontal,this._planeHorizontal,s),this.startCamera.aboveGround||b(this._planeHorizontal,this._planeHorizontal),this._panMode===L.Vertical){c(g,g,M),l(this._planeVertical,C,g),p(this._planeVertical,this._planeVertical),f(this._planeVertical,this._planeVertical,s);const i=d(),n=d(),o=d();l(i,s,this.currentCamera.eye);const a=_(i);p(i,i);const v=5*Math.max(Math.abs(this.view.camera.position.z),50),b=this.view._stage.renderView.getMinimalDepthForArea(this.view.voxelWasm,this._beginCenterScreen[0],this._beginCenterScreen[1],this.view.state.camera,W);let w=e(b)?Math.min(b,v):v;w=r?Math.min(w,a):w,m(o,u(n,this.currentCamera.eye,c(n,i,w))),this._planeVertical[3]=-h(this._planeVertical,o),this._computePlanePoints(t.pointers,this._planeVertical,this.startCamera,this._tmpPoints),A(this._tmpPoints,this._beginCenter)}else this._computePlanePoints(t.pointers,this._planeHorizontal,this.startCamera,this._tmpPoints),A(this._tmpPoints,this._beginCenter);this._constraintOptions.interactionStartCamera.copyFrom(this.startCamera)}update(t){if(!this.active)return;this.currentCamera.copyFrom(this.startCamera);const i=t.pointers.size>1,e=this._panMode===L.Horizontal?this._planeHorizontal:this._planeVertical,n=this._beginCenter;if(i){const i=this._beginRadius/t.radius,e=.001875*Math.min(Math.max(t.radius,40),120);this._scalingValueSmooth.gain=e,this._scalingValueSmooth.update(i),F(this.currentCamera,n,this._scalingValueSmooth.value,this.view.state.constraints.minimumPoiDistance),this._zoomMomentumEstimator.add(this._scalingValueSmooth.value,.001*t.timestamp),this._constraintOptions.interactionType=S.ZOOM,this._constraintOptions.interactionFactor=j(Math.abs(t.radius-this._beginRadius)),E(this.view,this.currentCamera,this._constraintOptions)}if(this._computePlanePoints(t.pointers,e,this.currentCamera,this._tmpPoints),A(this._tmpPoints,this._tmpCentroid3d),o(t.center,this._tmpCentroid2d),U(this.currentCamera,n,this._tmpCentroid3d),this._panMomentumEstimator.add(this._tmpCentroid2d,this._tmpCentroid3d,.001*t.timestamp),this._constraintOptions.interactionType=S.PAN,this._constraintOptions.interactionFactor=j(r(this._beginCenterScreen,this._tmpCentroid2d)),E(this.view,this.currentCamera,this._constraintOptions),i){const i=this._planeHorizontal,e=n,o=this._rotationValueSmooth.value,s=o+x(t.angle-o),r=.00125*Math.min(Math.max(t.radius,40),120);this._rotationValueSmooth.gain=r,this._rotationValueSmooth.update(s);const a=this._rotationValueSmooth.value-this._beginAngle;this._rotationMomentumEstimator.add(a,.001*t.timestamp),R(this.currentCamera,e,g(i,a)),this._constraintOptions.interactionType=S.TUMBLE,this._constraintOptions.interactionFactor=j(Math.abs(t.radius*a)),E(this.view,this.currentCamera,this._constraintOptions)}this.commitCamera()}end(t){t.pointers.size===this._pointerCount&&this.update(t),this.finishController();const i=this._zoomMomentumEstimator.evaluateMomentum();if(i)return new T({view:this.view,momentum:i,zoomCenter:this._beginCenter});const e=this._rotationMomentumEstimator.evaluateMomentum();if(e)return new y({view:this.view,momentum:e,center:this._beginCenter,axis:w(this._planeHorizontal)});const n=this._panMomentumEstimator.evaluateMomentum();return n?new O({view:this.view,momentum:n}):null}_computePlanePoints(t,i,e,n){n.length=t.size;const o=this._tmp2d;let s=0;return t.forEach((t=>{o[0]=t.x,o[1]=t.y,void 0===n[s]&&(n[s]=d()),D(i,e,o,n[s]),s+=1})),n}get _intersectionHelper(){return this.view.sceneIntersectionHelper}};q=t([s("esri.views.3d.state.controllers.local.PinchAndPanController")],q);export{q as PinchAndPanController};
