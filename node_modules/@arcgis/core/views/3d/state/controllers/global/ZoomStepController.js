/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../../chunks/tslib.es6.js";import{isSome as i}from"../../../../../core/maybe.js";import{Milliseconds as e}from"../../../../../core/time.js";import"../../../../../core/Logger.js";import"../../../../../core/accessorSupport/ensureType.js";import"../../../../../core/arrayUtils.js";import"../../../../../core/Error.js";import"../../../../../core/has.js";import{subclass as r}from"../../../../../core/accessorSupport/decorators/subclass.js";import{c as s,n as o,g as a,e as n,l as m,b as c,a as h,d as p}from"../../../../../chunks/vec3.js";import{c as l}from"../../../../../chunks/vec3f64.js";import{getReferenceEllipsoid as _}from"../../../../../geometry/projectionEllipsoid.js";import{c as y}from"../../../../../chunks/sphere.js";import{applyAll as f}from"../../../camera/constraintUtils.js";import{ConstraintTypes as w}from"../../../camera/constraintUtils/ConstraintTypes.js";import{InteractionType as g}from"../../../camera/constraintUtils/InteractionType.js";import{applySurfaceCollisionConstraint as d}from"../../../camera/constraintUtils/surfaceCollision.js";import{TiltMode as j}from"../../../camera/constraintUtils/TiltMode.js";import{PointToPointAnimationController as u}from"../PointToPointAnimationController.js";import{decideNavigationMode as C,NavigationMode as D,panToPosition as v}from"../../utils/navigationUtils.js";import{fromScreenAtEye as b}from"../../../support/geometryUtils/ray.js";import{intersectScreen as M}from"../../../support/geometryUtils/sphere.js";import{Camera as R}from"../../../webgl-engine/lib/Camera.js";import{newIntersector as S}from"../../../webgl-engine/lib/Intersector.js";import{TERRAIN_ID as L}from"../../../webgl-engine/lib/verticalOffsetUtils.js";import{outExpo as O}from"../../../../animation/easing.js";const U=.6,z=4,V=12,T=60,x=200;let E=class extends u{constructor(){super(...arguments),this._zoomLocation=l(),this._tmpCamera=new R,this._tmpViewDir=l(),this._tmpRayDir={origin:l(),direction:l()},this._targetOnSphere=l(),this._tmpCenter=l(),this._constraintOptions={selection:w.ALL_EXCEPT_COLLISION,interactionType:g.ZOOM,interactionFactor:null,interactionStartCamera:new R,interactionDirection:null,tiltMode:j.TUMBLE},this._sphere=y()}initialize(){this._intersector=S(this.view.state.viewingMode)}zoomStep(t,i){if(!this.active)return;const e=this.view.state,{interactionStartCamera:r}=this._constraintOptions;this.animation.finished?r.copyFrom(e.camera):this.animation.cameraAt(1,r);let o=!1,a=!1;this.intersectionHelper.intersectScreen(i,this._zoomLocation,0===this.view.map.ground.opacity?A:{})&&(o=t>0,a=!0),this._tmpCamera.copyFrom(e.camera),o?this.intersectionHelper.intersectRay(this._tmpCamera.ray,this._intersector,this._tmpCenter)&&(this._tmpCamera.center=this._tmpCenter):this.intersectionHelper.intersectRay(this._tmpCamera.ray,this._intersector,this._zoomLocation)?this._tmpCamera.center=this._zoomLocation:s(this._zoomLocation,this._tmpCamera.center),this._updateCamera(this._tmpCamera,t,this._zoomLocation,i,a),this.begin(this._tmpCamera)}animationSettings(){return{apex:null,duration:e(600),easing:O}}_updateCamera(t,e,r,s,l){const y=_(this.view.spatialReference),w=C(t,s,l,y);let g;this.view.camera.position.hasZ&&(g=Math.abs(this.view.camera.position.z)),o(k,t.eye),a(k,k,-1),b(t,s,this._tmpRayDir),o(this._tmpRayDir.direction,this._tmpRayDir.direction);const j=Math.max(Math.min(V,1/Math.abs(n(k,this._tmpRayDir.direction)))*g,x);if(w===D.Horizontal){let i=U**e;this._sphere[3]=m(r),c(this._tmpViewDir,t.center,t.eye);const o=Math.min(m(this._tmpViewDir),j);let n=o*i;if(i<=1&&n<z&&(n=z,i=n/o),Math.abs(o-n)<1e-6)return;const l=m(t.center);if(this._sphere[3]!==l){const e=this._sphere[3]+i*(l-this._sphere[3]);t.center=a(F,t.center,e/l)}a(this._tmpViewDir,this._tmpViewDir,-i),t.eye=h(F,t.center,this._tmpViewDir),f(this.view,t,this._constraintOptions),p(r,t.center)>1e-12&&M(this._sphere,t,s,this._targetOnSphere)&&v(this._sphere,t,r,this._targetOnSphere,this.view.camera.heading,this.view.camera.tilt,!0)}else{let o=U**Math.abs(e);const n=e>0?1:-1;c(this._tmpViewDir,r,t.eye);const p=m(this._tmpViewDir),_=this.view._stage.renderView.getMinimalDepthForArea(null,s[0],s[1],this.view.state.camera,T);let y=i(_)?Math.min(j,_):j;y=l?Math.min(y,p):y,a(this._tmpRayDir.direction,this._tmpRayDir.direction,y),h(r,this._tmpRayDir.origin,this._tmpRayDir.direction);let f=y*o;const w=Math.max(z,1.01*t.nearFar[0]);if(e>0&&f<w&&(f=w,o=f/y),Math.abs(y-f)<1e-6)return;a(this._tmpRayDir.direction,this._tmpRayDir.direction,n*(1-o)),t.eye=h(F,t.eye,this._tmpRayDir.direction),t.center=h(F,t.center,this._tmpRayDir.direction)}d(this.view,t)}};E=t([r("esri.views.3d.state.controllers.global.ZoomStepController")],E);const F=l(),k=l(),A={exclude:new Set([L])};export{E as ZoomStepController};
