/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../../chunks/tslib.es6.js";import{cyclicalPI as i}from"../../../../../core/Cyclical.js";import{deg2rad as e}from"../../../../../core/mathUtils.js";import{isNone as n,isSome as s}from"../../../../../core/maybe.js";import{createScreenPointArray as o,screenPointObjectToArray as r,createRenderScreenPointArray3 as a}from"../../../../../core/screenUtils.js";import"../../../../../core/Logger.js";import"../../../../../core/accessorSupport/ensureType.js";import"../../../../../core/arrayUtils.js";import"../../../../../core/Error.js";import"../../../../../core/has.js";import{subclass as m}from"../../../../../core/accessorSupport/decorators/subclass.js";import{c as h,d as c}from"../../../../../chunks/vec2.js";import{c as _,o as p,l,b as u,n as P,a as d,g,e as v}from"../../../../../chunks/vec3.js";import{c as C}from"../../../../../chunks/vec3f64.js";import{getReferenceEllipsoid as M}from"../../../../../geometry/projectionEllipsoid.js";import{wrapAxisAngle as S}from"../../../../../geometry/support/axisAngle.js";import{create as w,fromPositionAndNormal as b,normal as f}from"../../../../../geometry/support/plane.js";import{c as j}from"../../../../../chunks/sphere.js";import{pixelDistanceToInteractionFactor as E,applyAll as y}from"../../../camera/constraintUtils.js";import{ConstraintTypes as O}from"../../../camera/constraintUtils/ConstraintTypes.js";import{InteractionType as k}from"../../../camera/constraintUtils/InteractionType.js";import{TiltMode as A}from"../../../camera/constraintUtils/TiltMode.js";import{ExponentialFalloff as z}from"../../../input/util.js";import{InteractiveController as R}from"../InteractiveController.js";import{PanPlanarMomentumController as x}from"../momentum/PanPlanarMomentumController.js";import{PanSphericalMomentumController as T}from"../momentum/PanSphericalMomentumController.js";import{RotationMomentumController as H}from"../momentum/RotationMomentumController.js";import{ZoomPlanarMomentumController as F}from"../momentum/ZoomPlanarMomentumController.js";import{ZoomSphericalMomentumController as U}from"../momentum/ZoomSphericalMomentumController.js";import{NavigationMode as D,pickPointAndInitSphere as I,SpherePickPointFallback as L,decideNavigationMode as Z,sphereOrPlanePointFromScreenPoint as N,intersectPlaneFromScreenPointAtEye as B,applyZoomOnSphere as G,preserveHeadingThreshold as V,applyPanSphericalPreserveHeading as q,applyPanSphericalDirectRotation as J,normalizeRotationDelta as K,applyRotation as Q,applyPanPlanar as W,applyZoomToPoint as X}from"../../utils/navigationUtils.js";import{Camera as Y}from"../../../webgl-engine/lib/Camera.js";import{PanPlanarMomentumEstimator as $}from"../../../../navigation/PanPlanarMomentumEstimator.js";import{PanSphericalMomentumEstimator as tt}from"../../../../navigation/PanSphericalMomentumEstimator.js";import{RotationMomentumEstimator as it}from"../../../../navigation/RotationMomentumEstimator.js";import{ZoomMomentumEstimator as et}from"../../../../navigation/ZoomMomentumEstimator.js";let nt=class extends R{constructor(){super(...arguments),this._smoothRotation=new z(.05),this._rotationAxis=C(),this._panningPlane=w(),this._smoothScaling=new z(.05),this._zoomCenterScreen=o(),this._zoomMomentumEstimator=new et,this._rotationMomentumEstimator=new it,this._panSphericalMomentumEstimator=new tt,this._panPlanarMomentumEstimator=new $,this._adjustedSphere=j(),this._tmp3d=C(),this._tmpScreenPointArray=o(),this._beginScreenPoint=o(),this._beginScenePoint=C(),this._screenPickPoint=o(),this._mode=D.Horizontal,this._tmpInteractionDirection=C(),this._constraintOptions={selection:O.ALL,interactionType:k.NONE,interactionFactor:0,interactionStartCamera:new Y,interactionDirection:null,tiltMode:A.TUMBLE}}get _intersectionHelper(){return this.view.sceneIntersectionHelper}begin(t){if(!this.active)return;const s=this.view.navigation.momentumEnabled;this._zoomMomentumEstimator.enabled=s,this._rotationMomentumEstimator.enabled=s,this._panPlanarMomentumEstimator.enabled=s,this._panSphericalMomentumEstimator.enabled=s,this._beginHeading=-i.normalize(e(this.view.camera.heading)),this._beginRadius=t.radius,this._pointerCount=t.pointers.size,this._beginAngle=t.angle,this._smoothRotation.reset(),r(t.center,this._screenPickPoint),h(this._beginScreenPoint,this._screenPickPoint);const o=M(this.view.spatialReference),a=I(this._intersectionHelper,this.startCamera,this._screenPickPoint,o,L.Silhouette);n(a.scenePickPoint)||(this._scenePickPoint=a.scenePickPoint,this._sphere=a.sphere,_(this._beginScenePoint,this._scenePickPoint),this._mode=Z(this.startCamera,this._screenPickPoint,a.hasGeometryIntersection,o),this._mode===D.Vertical&&this._preparePlanarPanMode(t),this._constraintOptions.interactionStartCamera.copyFrom(this.startCamera))}update(t){if(!this.active)return;this.currentCamera.copyFrom(this.startCamera);const i=t.pointers.size>1;this._mode===D.Horizontal?(i&&this._zoomSpherical(t),this._panningSpherical(t),i&&this._rotateSpherical(t)):(i&&this._zoomPlanar(t),this._panningPlanar(t),i&&this._rotatePlanar(t)),this.commitCamera()}end(t){t.pointers.size===this._pointerCount&&this.update(t),this.finishController();const i=this._zoomMomentumEstimator.evaluateMomentum();if(i)return this._mode===D.Horizontal?new U({view:this.view,momentum:i,screenCenter:this._zoomCenterScreen,sceneCenter:this._beginScenePoint,radius:this._sphere[3]}):new F({view:this.view,momentum:i,zoomCenter:this._beginScenePoint});const e=this._rotationMomentumEstimator.evaluateMomentum();if(e)return new H({view:this.view,momentum:e,center:this._sphere,axis:this._rotationAxis});if(this._mode===D.Horizontal){const t=this._panSphericalMomentumEstimator.evaluateMomentum();if(t)return new T({view:this.view,momentum:t})}else{const t=this._panPlanarMomentumEstimator.evaluateMomentum();if(t)return new x({view:this.view,momentum:t})}return null}_preparePlanarPanMode(t){const i=p(this._tmp3d,this.startCamera.viewForward);b(this._scenePickPoint,i,this._panningPlane);const e=o(this._screenPickPoint[0],0),n=C(),m=l(this.startCamera.eye);this._adjustedSphere[3]=m<this._sphere[3]?m-100:this._sphere[3],N(this._adjustedSphere,this.startCamera,e,n);const h=a();this.startCamera.projectToRenderScreen(n,h);const c=.9*h[1];this._screenPickPoint[1]=Math.min(this._screenPickPoint[1],c);const M=this._intersectionHelper.intersectScreen(this._screenPickPoint,this._scenePickPoint);M&&b(this._scenePickPoint,f(this._panningPlane),this._panningPlane);const S=C(),w=C(),j=C(),E=80,y=5,O=50;u(S,this._scenePickPoint,this.currentCamera.eye);const k=l(S);P(S,S);const A=y*Math.max(Math.abs(this.view.camera.position.z),O),z=this.view._stage.renderView.getMinimalDepthForArea(null,this._screenPickPoint[0],this._screenPickPoint[1],this.view.state.camera,E);let R=s(z)?Math.min(z,A):A;R=M?Math.min(R,k):R,_(j,d(w,this.currentCamera.eye,g(w,S,R))),this._panningPlane[3]=-v(this._panningPlane,j),this.startCamera.center=d(w,this.startCamera.eye,g(w,this.startCamera.viewForward,R));const x=r(t.center,this._tmpScreenPointArray);B(this._panningPlane,this.startCamera,x,this._beginScenePoint)}_zoomSpherical(t){const i=this._beginRadius/t.radius,e=.001875*Math.min(Math.max(t.radius,40),120);this._smoothScaling.gain=e,this._smoothScaling.update(i),G(this._sphere,this.currentCamera,this._smoothScaling.value),r(t.center,this._zoomCenterScreen),this._zoomMomentumEstimator.add(this._smoothScaling.value,.001*t.timestamp),this._constraintOptions.interactionType=k.ZOOM,this._constraintOptions.interactionFactor=E(t.radius-this._beginRadius),y(this.view,this.currentCamera,this._constraintOptions)}_panningSpherical(t){const i=r(t.center,this._tmpScreenPointArray);N(this._sphere,this.currentCamera,i,this._tmp3d),V(this._beginScenePoint,v(this.currentCamera.up,this._beginScenePoint),this._sphere[3],this._beginHeading,this.view.camera.tilt,this.startCamera)?(q(this._sphere,this.currentCamera,this._beginScenePoint,this._tmp3d,this._beginHeading,this.view.camera.tilt,!1),this._panSphericalMomentumEstimator.addMomentumPreserveHeading(i,this._tmp3d,.001*t.timestamp,this.startCamera,this._sphere,this._beginHeading,this.view.camera.tilt)):(J(this._sphere,this.currentCamera,this._beginScenePoint,this._tmp3d,this.view.camera.tilt,!1),this._panSphericalMomentumEstimator.addMomentumDirectRotation(i,this._tmp3d,.001*t.timestamp,this.startCamera,this._sphere[3],this.view.camera.tilt)),this._constraintOptions.interactionType=k.PAN,this._constraintOptions.interactionFactor=E(c(this._screenPickPoint,i)),y(this.view,this.currentCamera,this._constraintOptions)}_rotateSpherical(t){P(this._rotationAxis,this._scenePickPoint),this.currentCamera.aboveGround||p(this._rotationAxis,this._rotationAxis);const i=this._smoothRotation.value,e=i+K(t.angle-i),n=.00125*Math.min(Math.max(t.radius,40),120);this._smoothRotation.gain=n,this._smoothRotation.update(e);const s=this._smoothRotation.value-this._beginAngle;this._rotationMomentumEstimator.add(s,.001*t.timestamp),Q(this.currentCamera,this._sphere,S(this._rotationAxis,s)),this._constraintOptions.interactionType=k.TUMBLE,this._constraintOptions.interactionFactor=E(t.radius*e),y(this.view,this.currentCamera,this._constraintOptions)}_panningPlanar(t){const i=r(t.center,this._tmpScreenPointArray);B(this._panningPlane,this.currentCamera,i,this._tmp3d)&&(W(this.currentCamera,this._beginScenePoint,this._tmp3d),this._panPlanarMomentumEstimator.add(i,this._tmp3d,.001*t.timestamp),this._constraintOptions.interactionType=k.PAN,this._constraintOptions.interactionFactor=E(c(this._beginScreenPoint,i)),this._constraintOptions.interactionDirection=this.view.renderCoordsHelper.worldUpAtPosition(this.currentCamera.eye,this._tmpInteractionDirection),y(this.view,this.currentCamera,this._constraintOptions),this._constraintOptions.interactionDirection=null)}_zoomPlanar(t){const i=this._beginRadius/t.radius,e=.001875*Math.min(Math.max(t.radius,40),120);this._smoothScaling.gain=e,this._smoothScaling.update(i),this._zoomMomentumEstimator.add(this._smoothScaling.value,.001*t.timestamp),X(this.currentCamera,this._beginScenePoint,this._smoothScaling.value,this.view.state.constraints.minimumPoiDistance),this._constraintOptions.interactionType=k.ZOOM,this._constraintOptions.interactionFactor=E(t.radius-this._beginRadius),y(this.view,this.currentCamera,this._constraintOptions)}_rotatePlanar(t){_(this._rotationAxis,this._beginScenePoint),this.currentCamera.aboveGround||p(this._rotationAxis,this._rotationAxis);const i=this._smoothRotation.value;let e=t.angle-i;e=K(e);const n=i+e,s=.00125*Math.min(Math.max(t.radius,40),120);this._smoothRotation.gain=s,this._smoothRotation.update(n);const o=this._smoothRotation.value-this._beginAngle;this._rotationMomentumEstimator.add(o,.001*t.timestamp),Q(this.currentCamera,this._sphere,S(this._rotationAxis,o)),this._constraintOptions.interactionType=k.TUMBLE,this._constraintOptions.interactionFactor=E(t.radius*o),y(this.view,this.currentCamera,this._constraintOptions)}};nt=t([m("esri.views.3d.state.controllers.global.PinchAndPanController")],nt);export{nt as PinchAndPanController};
