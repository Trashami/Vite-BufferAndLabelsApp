/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../chunks/tslib.es6.js";import{acosClamped as i,clamp as s}from"../../../../core/mathUtils.js";import{isSome as r,unwrapOr as o,isNone as e}from"../../../../core/maybe.js";import{createScreenPointArray as a}from"../../../../core/screenUtils.js";import{property as n}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/arrayUtils.js";import"../../../../core/accessorSupport/ensureType.js";import{subclass as p}from"../../../../core/accessorSupport/decorators/subclass.js";import{d as h,e as c}from"../../../../chunks/mat4.js";import{c as m}from"../../../../chunks/mat4f64.js";import{c as l}from"../../../../chunks/vec2.js";import{a as _}from"../../../../chunks/vec2f64.js";import{c as v,b as u,l as f,n as C,a as P,g as E,e as T,f as d,m as w}from"../../../../chunks/vec3.js";import{c as R}from"../../../../chunks/vec3f64.js";import{getReferenceEllipsoid as j}from"../../../../geometry/projectionEllipsoid.js";import{applyAll as y}from"../../camera/constraintUtils.js";import{ConstraintTypes as U}from"../../camera/constraintUtils/ConstraintTypes.js";import{InteractionType as M}from"../../camera/constraintUtils/InteractionType.js";import{TiltMode as O}from"../../camera/constraintUtils/TiltMode.js";import{TiltDefault as D}from"../Constraints.js";import{InteractiveController as x}from"./InteractiveController.js";import{normalizeCoordinate as N,decideNavigationMode as g,NavigationMode as k}from"../utils/navigationUtils.js";var A;!function(t){t[t.CENTER=0]="CENTER",t[t.EYE=1]="EYE"}(A||(A={}));const b=7,L=90;let V=class extends x{constructor(t){super(t),this.pivot=A.CENTER,this._lastPoint=_(),this._tmpWorldUp=R(),this._tmpViewDir=R(),this._tmpRotCurPoint=_(),this._tmpTransf=m(),this._tmpAxis=R(),this._tmpPivotPoint=R(),this._pivotPos=R(),this._constraintOptions={selection:U.ALL,interactionType:M.TUMBLE,interactionFactor:0,interactionStartCamera:null,interactionDirection:null,tiltMode:O.TUMBLE}}get _intersectionHelper(){return this.view.sceneIntersectionHelper}initialize(){this._rotScale=this.pivot===A.CENTER?3:1.5}begin(t){if(this.active){switch(this.pivot){case A.EYE:v(this._pivotPos,this.startCamera.eye),this._constraintOptions.interactionType=M.LOOK_AROUND,this._constraintOptions.tiltMode=O.LOOK_AROUND,this._constraintOptions.selection=U.NONE;break;case A.CENTER:{const i=this._intersectionHelper.intersectRayFreePointFallback(this.startCamera.ray,this._pivotPos);i||v(this._pivotPos,this.startCamera.center),this._constrainPivotPoint(t,i),this.startCamera.center=this._pivotPos,this._constraintOptions.interactionType=M.TUMBLE,this._constraintOptions.tiltMode=O.TUMBLE,this._constraintOptions.selection=U.ALL&~U.DISTANCE;break}}this._constraintOptions.interactionStartCamera=this.startCamera,N(this.startCamera,t,this._lastPoint)}}_constrainPivotPoint(t,i){const s=this.startCamera,n=R();u(n,this._pivotPos,s.eye);const p=f(n);let h=Math.min(p,b*Math.abs(this.view.camera.position.z));const c=j(this.view.spatialReference),m=a(s.width/s.pixelRatio*.5,s.height/s.pixelRatio*.5),l=g(this.startCamera,m,!0,c);let _=this.view._stage.renderView.getMinimalDepthForArea(this.view.voxelWasm,s.fullWidth/s.pixelRatio*.5,s.fullHeight/s.pixelRatio*.5,s,2.5*L,L),T=this.view._stage.renderView.getMinimalDepthForArea(this.view.voxelWasm,t[0],t[1],s,L);(r(_)||r(T))&&(_=o(_,T),T=e(T)||l===k.Horizontal?_:T,h=_>T?T:_,h=i?Math.min(h,p):h),C(n,n),v(this._pivotPos,P(this._tmpPivotPoint,s.eye,E(this._tmpPivotPoint,n,h)))}update(t){if(this.active){switch(this.pivot){case A.EYE:this.currentCamera.center=this._applyRotation(this.currentCamera,t,this.currentCamera.center,this._pivotPos);break;case A.CENTER:this.currentCamera.center=this._pivotPos,this.currentCamera.eye=this._applyRotation(this.currentCamera,t,this.currentCamera.eye,this._pivotPos)}y(this.view,this.currentCamera,this._constraintOptions),this.commitCamera()}}end(){this.active&&this.finishController()}_applyRotation(t,r,o,e){this.view.renderCoordsHelper.worldUpAtPosition(e,this._tmpWorldUp),N(t,r,this._tmpRotCurPoint);let a=(this._lastPoint[1]-this._tmpRotCurPoint[1])*this._rotScale,n=(this._tmpRotCurPoint[0]-this._lastPoint[0])*this._rotScale;u(this._tmpViewDir,o,e);const p=f(this._tmpViewDir),m=i(T(this._tmpViewDir,this._tmpWorldUp)/p);if(this.pivot===A.EYE){a*=-.5;const t=.5*Math.PI-m,i=.5*Math.PI*.99;a=t-Math.max(-i,Math.min(i,t+a))}return a=s(a+m,D.min,D.max)-m,d(this._tmpAxis,t.up,this._tmpViewDir),this.pivot===A.CENTER&&(n=-n),h(this._tmpTransf,n,this._tmpWorldUp),c(this._tmpTransf,this._tmpTransf,a,this._tmpAxis),w(this._tmpViewDir,this._tmpViewDir,this._tmpTransf),t.up=w(S,t.up,this._tmpTransf),P(S,e,this._tmpViewDir),l(this._lastPoint,this._tmpRotCurPoint),S}};t([n()],V.prototype,"pivot",void 0),V=t([p("esri.views.3d.state.controllers.RotateController")],V);const S=R();export{A as PivotPoint,V as RotateController};
