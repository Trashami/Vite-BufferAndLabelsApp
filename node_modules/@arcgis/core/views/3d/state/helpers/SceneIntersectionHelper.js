/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{isNone as e,isSome as t,unwrapOr as r}from"../../../../core/maybe.js";import i from"../../../../core/PooledArray.js";import{castRenderScreenPointArray3 as n,createRenderScreenPointArray3 as s}from"../../../../core/screenUtils.js";import{a as o,n as a,l as c,g as l}from"../../../../chunks/vec3.js";import{c as h}from"../../../../chunks/vec3f64.js";import{create as u,copy as m,NEGATIVE_INFINITY as d,width as p,height as y,expandPointInPlace as g}from"../../../../geometry/support/aaBoundingRect.js";import{create as f}from"../../../../geometry/support/ray.js";import{sv3d as _}from"../../../../geometry/support/vectorStacks.js";import{ViewingMode as R}from"../../../ViewingMode.js";import{fromRenderAtEye as v,fromScreen as x}from"../../support/geometryUtils/ray.js";import{DEFAULT_TOLERANCE as w,newIntersector as b}from"../../webgl-engine/lib/Intersector.js";import{StoreResults as I,IntersectorType as M}from"../../webgl-engine/lib/IntersectorInterfaces.js";import{isValidIntersectorResult as P,sliceFilterPredicate as j}from"../../webgl-engine/lib/intersectorUtils.js";class E{constructor(e,t,r){this.viewingMode=e,this._forEachLayer=t,this._view=r,this._externalIntersectionHandlers=new i,this._tolerance=w,this._tmpRay=f(),this._tmpRegion=u(),this._validateHUDIntersector=b(this.viewingMode),this._validateHUDIntersector.options.hud=!1}intersectScreen(e,t,r){return this.intersectRay(this._getPickRay(e,this._tmpRay),k(this.viewingMode),t,r)}intersectScreenFreePointFallback(e,t,r){return this.intersectRayFreePointFallback(this._getPickRay(e,this._tmpRay),t,r)}intersectRayFreePointFallback(e,t,r){return this.intersectRay(e,k(this.viewingMode),t,r)||this._intersectRayFreePointLocal(e,t)}intersectRay(e,t,r,i){return t.options.selectionMode=!1,t.options.store=I.MIN,this.computeIntersection(e,t,i),!!t.results.min&&t.results.min.getIntersectionPoint(r)}getCenterRayWithSubpixelOffset(e,t,r=.5,i=.5){return e.getRenderCenter(N,r,i),N[0]+=.0466,N[1]-=.0123,v(e,N,t)}intersectIntersectorScreen(e,t,r){this.computeIntersection(this._getPickRay(e,this._tmpRay),t,r)}intersectToolIntersectorScreen(e,t,r){const i=this._getPickRay(e,this._tmpRay);this.intersectToolIntersectorRay(i,t,r)}intersectToolIntersectorRay(e,t,r){t.options.selectionMode=!0,this.computeIntersection(e,t,r);const i=t.results.min;!!this._view.basemapTerrain&&this._view.basemapTerrain.opaque||P(i)&&i.intersector!==M.TERRAIN||(t.options.selectionMode=!1,this.computeIntersection(e,t,r))}setTolerance(e=w){this._tolerance=e}addIntersectionHandler(e){this._externalIntersectionHandlers.push(e),this._externalIntersectionHandlers.sort(((e,t)=>e.type===M.TERRAIN?1:t.type===M.TERRAIN?-1:0))}removeIntersectionHandler(e){null!=this._externalIntersectionHandlers.removeUnordered(e)&&this._externalIntersectionHandlers.sort(((e,t)=>e.type===M.TERRAIN?1:t.type===M.TERRAIN?-1:0))}_getPickRay(e,t){const r=this._view.state.camera;return x(r,e,t)}_intersectRayFreePointLocal(t,r){if(this.viewingMode!==R.Local||e(t))return!1;const i=this._view.renderDataExtent;if(e(i))return o(r,t.origin,a(_.get(),t.direction)),!0;const n={x:i.xmax-i.xmin,y:i.ymax-i.ymin,z:8*Math.max(i.xmax-i.xmin,i.ymax-i.ymin)},s=Math.max(n.x,n.y,n.z);if(0===s)return o(r,t.origin,a(_.get(),t.direction)),!0;const h=this._view.state.camera,u=Math.max(0,i.xmin-h.eye[0],h.eye[0]-i.xmax),m=Math.max(0,i.ymin-h.eye[1],h.eye[1]-i.ymax),d=Math.sqrt(u*u+m*m),p=Math.abs(h.relativeElevation)+Number.MIN_VALUE,y=Math.max(0,Math.log(s/p))**2;let g=s/Math.max(1,y);g=Math.max(g,Math.min(d,s));const f=c(t.direction),v=l(_.get(),t.direction,0===f?g:g/f);return o(r,t.origin,v),!0}intersectElevationFromScreen(e,t,r=0,i=null){return this._intersectElevation(this._getPickRay(e,this._tmpRay),t,r,i)}_intersectElevation(i,s,a=0,c=null){if(e(i))return null;const l=t(s)?s.mode:"absolute-height",h=t(s)?r(s.offset,0):0,u="on-the-ground"!==l?h+a:0,m=u/this._view.renderCoordsHelper.unitInMeters;if("absolute-height"===l){if(this._view.renderCoordsHelper.intersectInfiniteManifold(i,u,S)){const e=this._view.computeMapPointFromVec3d(S);return e.z-=h,e}return null}const d=this._view.state.camera,p=n(_.get());d.projectToRenderScreen(i.origin,p);const y=new A(null,this._forEachLayer),g=this._view.slicePlane,f=t(g)?j(g):null,R=b(this.viewingMode);R.options.store=I.MIN,R.options.verticalOffset=m;const v=i.origin,x=o(_.get(),v,i.direction);R.reset(v,x,d),R.point=p;const w=t(c)?"type"in c&&"graphics"===c.type?e=>e.metadata.layerUid!==c.uid:e=>e.metadata.graphicUid!==c.uid:null;switch(l){case"relative-to-scene":{const t=t=>(e(w)||w(t))&&t.metadata&&t.metadata.isElevationSource;R.intersect(y.layers,p,this._tolerance,null,t),this._externalIntersectionHandlers.forAll((e=>{if(e.type===M.I3S||e.type===M.TERRAIN){const t=e.slicePlaneEnabled?f:null;e.intersect(R,t,R.rayBegin,R.rayEnd,p)}}))}break;case"on-the-ground":case"relative-to-ground":this._externalIntersectionHandlers.forAll((e=>{if(e.isGround){const t=e.slicePlaneEnabled?f:null;e.intersect(R,t,R.rayBegin,R.rayEnd,p)}}))}if(R.results.min.getIntersectionPoint(S)){const e=this._view.computeMapPointFromVec3d(S);return e.z=a,e}return null}computeIntersection(i,s,a){if(e(i))return;const c=this._view.state.camera,l=n(_.get());c.projectToRenderScreen(i.origin,l);const h=new A(a,this._forEachLayer);s.options.selectOpaqueTerrainOnly=!a||!("include"in a||"exclude"in a);const u=i.origin,m=o(_.get(),i.origin,i.direction);s.reset(u,m,c),s.intersect(h.layers,l,this._tolerance);const d=this._view.slicePlane,p=t(d)?j(d):null;s.intersect(h.sliceableLayers,l,this._tolerance,p);const y=a&&(a.requiresGroundFeedback||a.enableDraped);this._externalIntersectionHandlers.forAll((e=>{if(s.options.isFiltered=!h.filterLayerUid(e.layerUid),e.isGround&&y||!s.options.isFiltered){const t=e.slicePlaneEnabled?p:null;e.intersect(s,t,u,m,l)}}));const g=_.get(),f=this._view.basemapTerrain;if(a&&a.enableDraped&&t(f.spatialReference)&&s.results.ground.getIntersectionPoint(g)){const e=f.overlayManager.renderer,t=this._view.renderCoordsHelper.spatialReference,i=_.get();this._view.renderCoordsHelper.fromRenderCoords(g,i,f.spatialReference),i[2]=r(this._view.elevationProvider.getElevation(g[0],g[1],g[2],t,"ground"),0),e.intersect(s,i,s.results.ground,(e=>h.filterRenderGeometry(e)))}s.sortResults(),this._processHUDResults(s)}_processHUDResults(r){const i=r.results.hud;m(this._tmpRegion,d);const n=this._view.state.camera,s=[],o=this._tmpRegion,a=e=>{const t=new L(e);n.projectToRenderScreen(e.target.center,t.screenPoint),t.screenPoint[0]=Math.floor(t.screenPoint[0]),t.screenPoint[1]=Math.floor(t.screenPoint[1]),s.push(t),g(o,t.screenPoint)};r.sortResults(i.all),t(i.min.dist)&&a(i.min);for(const e of i.all)i.min.target.object!==e.target.object&&i.max.target.object!==e.target.object&&a(e);if(t(i.max.dist)&&i.max.target.object!==i.min.target.object&&a(i.max),!s.length)return;o[0]===o[2]&&(o[2]+=1),o[1]===o[3]&&(o[3]+=1);const c=n.fullWidth,l=n.fullHeight,h=Math.max(0,o[0]-H),u=Math.max(0,o[1]-H),f=Math.min(p(o)+2*H,c-h),_=Math.min(y(o)+2*H,l-u),R=new Uint8Array(f*_*4);this._view._stage.renderView.readHUDVisibility(h,u,f,_,R);let v=!0;const x=e(r.results.max.dist);let w=0;for(const e of s)for(const t of U){if(R[4*(Math.min(e.screenPoint[0]+t[0],c)-o[0]+(Math.min(e.screenPoint[1]+t[1],l)-o[1])*f)]){v&&(r.results.min.copy(e.result),v=!1),x&&r.results.max.copy(e.result),r.options.store===I.ALL&&r.results.all.splice(w++,0,e.result);break}}}}const H=1,U=(()=>{const e=[],t=H;for(let r=-t;r<=t;r++)for(let i=-t;i<=t;i++)e.push([i+t,r+t]);return e})();class L{constructor(e){this.result=e,this.screenPoint=s()}}let T;function k(e){return T&&T.viewingMode===e||(T=b(e)),T}class A{constructor(e,t){this.layers=new Array,this.sliceableLayers=new Array,this.include=e?.include,this.exclude=e?.exclude,t((e=>{e.isPickable&&this.filterLayerUid(e.apiLayerUid)&&(e.isSliceable?this.sliceableLayers:this.layers).push(e)}))}filterLayerUid(t){const{include:r,exclude:i}=this;return e(t)?null==r&&null==i:(null==r||r.has(t))&&(null==i||!i.has(t))}filterRenderGeometry(e){return this.filterLayerUid(e.layerUid)}}function F(e){return"object"==typeof e&&"intersect"in e}const S=h(),N=s();export{E as SceneIntersectionHelper,F as isIntersectionHandler};
