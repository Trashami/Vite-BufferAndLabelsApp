/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{lerp as e,clamp as t}from"../../../core/mathUtils.js";import{removeMaybe as s,disposeMaybe as r,isNone as i}from"../../../core/maybe.js";import{watch as a,syncAndInitial as o}from"../../../core/reactiveUtils.js";import{q as n}from"../../../chunks/mat4.js";import{c as h}from"../../../chunks/mat4f64.js";import{s as m}from"../../../chunks/vec2.js";import{l as c,g as u,a as p,i as _,f as d,p as l}from"../../../chunks/vec3.js";import{c as f}from"../../../chunks/vec3f64.js";import{getReferenceEllipsoid as g}from"../../../geometry/projectionEllipsoid.js";import{isMars as R}from"../../../geometry/support/spatialReferenceUtils.js";import{AtmosphereType as x}from"./AtmosphereType.js";import{computeInnerAltitudeFade as j,innerAtmosphereDepth as b}from"./atmosphereUtils.js";import{S as T}from"../../../chunks/SimpleAtmosphere.glsl.js";import{SimpleAtmosphereTechnique as V}from"./SimpleAtmosphereTechnique.js";import{SimpleAtmosphereTechniqueConfiguration as y,SimpleAtmosphereGeometry as q}from"./SimpleAtmosphereTechniqueConfiguration.js";import{marsAtmosphereTextureSimple as A}from"./resources/MarsAtmosphereTexture.js";import{earthAtmosphereTextureSimple as w}from"./resources/SimpleAtmosphereTexture.js";import{makePiecewiseLinearFunction as P}from"../support/mathUtils.js";import{glLayout as v}from"../support/buffer/glUtil.js";import{newLayout as C}from"../support/buffer/InterleavedLayout.js";import{Default3D as S}from"../webgl-engine/lib/DefaultVertexAttributeLocations.js";import{createQuadVAO as F}from"../webgl-engine/lib/glUtil3D.js";import{project as M}from"../webgl-engine/lib/Util.js";import{VertexArrayObject as U}from"../webgl-engine/lib/VertexArrayObject.js";import{VertexAttribute as I}from"../webgl-engine/lib/VertexAttribute.js";import{BufferObject as O}from"../../webgl/BufferObject.js";import{PixelFormat as E,PixelType as W,TextureWrapMode as k,TextureSamplingMode as L,PrimitiveType as N,Usage as D}from"../../webgl/enums.js";import{Texture as G}from"../../webgl/Texture.js";import{vertexCount as B}from"../../webgl/Util.js";const H=128,z=-b,Y=0,J=50,K=()=>1-511/512,Q=P([[50,.1015625],[500,.21875],[5e3,1-250/512],[5e4,.4140625]]);class X{constructor(e){this.view=e,this.type=x.Simple,this._passParameters=new T,this._fadeVaoCount=0,this._texV1=1,this._isOnMars=R(e.spatialReference);const t=g(e.spatialReference);this._planetRadius=t.radius,this._outerRimWidth=t.outerAtmosphereRimWidth,this._innerRimFactor=(this._planetRadius+z)/this._planetRadius,this._middleRimFactor=(this._planetRadius+Y)/this._planetRadius,this._outerRimFactor=(this._planetRadius+this._outerRimWidth)/this._planetRadius,this._texV0=Y/this._outerRimWidth,this._texVScale=this._texV1-this._texV0}destroy(){this._cameraChangeHandle=s(this._cameraChangeHandle),this._passParameters.texture=r(this._passParameters.texture),this._fadeVao=r(this._fadeVao),this._vao=r(this._vao)}async initializeRenderContext(e){this._shaderTechniqueRepository=e.shaderTechniqueRepository;const t=e.renderContext.rctx;this._cameraChangeHandle=a((()=>this.view.state?.camera),(()=>e.requestRender()),o),this._vao=this._createRibbon(t),this._vaoCount=B(this._vao,"geometry"),this._fadeVao=F(t),this._fadeVaoCount=B(this._fadeVao,"geometry");const s=this._isOnMars?A:w;this._passParameters.texture=new G(t,{pixelFormat:E.RGBA,dataType:W.UNSIGNED_BYTE,wrapMode:k.CLAMP_TO_EDGE,samplingMode:L.LINEAR,flipped:!0,width:1,height:512},s),e.requestRender()}get _coneTechnique(){if(i(this._coneTechniqueCached)){const e=new y;e.geometry=q.Cone,this._coneTechniqueCached=this._shaderTechniqueRepository.acquire(V,e)}return this._coneTechniqueCached}get _undergroundTechnique(){if(i(this._undergroundTechniqueCached)){const e=new y;e.geometry=q.Underground,this._undergroundTechniqueCached=this._shaderTechniqueRepository.acquire(V,e)}return this._undergroundTechniqueCached}render(e){if(i(this._vao)||i(this._passParameters.texture))return;const t=e.bindParameters.camera;this._update(t);const s=e.rctx;this._passParameters.undergroundFadeAlpha<1&&(s.bindTechnique(this._coneTechnique,this._passParameters,e.bindParameters),s.bindVAO(this._vao),s.drawArrays(N.TRIANGLES,0,this._vaoCount)),this._passParameters.undergroundFadeAlpha>0&&(s.bindTechnique(this._undergroundTechnique,this._passParameters,e.bindParameters),s.bindVAO(this._fadeVao),s.drawArrays(N.TRIANGLE_STRIP,0,this._fadeVaoCount))}renderHaze(){}_update(s){const r=f(),i=this._planetRadius,a=c(s.eye),o=a-i;if(o<0){const e=Math.min(-o/5e3,1);this._passParameters.undergroundFadeAlpha=e}else this._passParameters.undergroundFadeAlpha=0;const n=Math.max(J,o),h=i+z;this._passParameters.innerScale=se(i+n,i,h)-1,this._passParameters.altitudeFade=j(o),u(r,s.eye,(i+J)/a),Z(r,s.center,s.up,i,this._passParameters.silhouette);const p=this._computeScreenRimWidth(s,r,s.up,this._passParameters.silhouette),_=K(),d=Q(o);let l=this._texV0+_*this._texVScale,g=this._texV0+p*d*this._texVScale;if(o>J){Z(s.eye,s.center,s.up,i,this._passParameters.silhouette);const r=this._computeScreenRimWidth(s,s.eye,s.up,this._passParameters.silhouette),a=t((r-1.5)/(p-1.5),0,1);l=this._texV0+a*_*this._texVScale,g=this._texV0+e(this._texV1,p*d,a)*this._texVScale}m(this._passParameters.texV,l,g)}_createRibbon(e){const t=new Float32Array(3+3*H*3),s=new Uint32Array(3*H*5);t[0]=0,t[1]=0,t[2]=-1;for(let a=0;a<H;a++){const e=9*a+3;t[e+0]=a,t[e+1]=this._innerRimFactor,t[e+2]=-1,t[e+3]=a,t[e+4]=this._middleRimFactor,t[e+5]=0,t[e+6]=a,t[e+7]=this._outerRimFactor,t[e+8]=1;const r=3*a+1,i=a===H-1?1:r+3,o=15*a;s[o+0]=r,s[o+1]=r+1,s[o+2]=i+1,s[o+3]=i+1,s[o+4]=i,s[o+5]=r,s[o+6]=r+1,s[o+7]=r+2,s[o+8]=i+2,s[o+9]=i+2,s[o+10]=i+1,s[o+11]=r+1,s[o+12]=r,s[o+13]=i,s[o+14]=0}const r=re.createBuffer(s.length),i=r.position;for(let a=0;a<s.length;++a){const e=3*s[a];i.set(a,0,t[e]),i.set(a,1,t[e+1]),i.set(a,2,t[e+2])}return new U(e,S,{geometry:v(re)},{geometry:O.createVertex(e,D.STATIC_DRAW,r.buffer)})}_computeScreenRimWidth(e,t,s,r){return p(ee,r.center,r.v2),u(te,ee,this._outerRimFactor),n($,t,ee,s),M(ee,$,e.projectionMatrix,e.viewport),M(te,$,e.projectionMatrix,e.viewport),_(ee,te)/e.height}}function Z(e,t,s,r,i){const a=c(e),o=r*Math.sqrt(a*a-r*r)/a,n=Math.sqrt(r*r-o*o),h=i.v1,m=i.v2;return u(i.center,e,n/a),d(h,e,t),l(h)<1&&d(h,e,s),u(h,h,o/c(h)),d(m,h,e),u(m,m,o/c(m)),o}const $=h(),ee=f(),te=f();function se(e,t,s){return e*e/(Math.sqrt(e*e-t*t)*Math.sqrt(e*e-s*s)+t*s)}const re=C().vec3f(I.POSITION);export{X as default};
