/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{clamp as t}from"../../../core/mathUtils.js";import{a as e}from"../../../chunks/vec2f64.js";import{a as s,n as i}from"../../../chunks/vec3.js";import{empty as r}from"../../../geometry/support/aaBoundingBox.js";import{BufferPool as n}from"../../../geometry/support/buffer/BufferPool.js";import{newLayout as o}from"../support/buffer/InterleavedLayout.js";import{internalAssert as u}from"./terrainUtils.js";import{VertexAttribute as a}from"../webgl-engine/lib/VertexAttribute.js";class l{constructor(){this.indices=null,this.vertexAttributes=null,this.boundingBox=r(),this.indexCount=0,this.numVerticesPerSide=0,this.uvRange=[0,0,1,1],this.outerEdges=[null,null,null,null],this.innerEdges=[null,null,null,null]}}class h{constructor(t,e,s,i,r){this.attributes=t,this.localOrigin=e,this.index0=s,this.stride=i,this.count=r}getVertexIndex(t){return this.getAttributeIndex(t)}getAttributeIndex(t){return u(0<=t&&t<this.count),this.index0+this.stride*t}_getVertexRaw(t,e){this.attributes.position.getVec(t,e)}_getNormalRaw(t,e){this.attributes.normalCompressed.getVec(t,e)}getVertexPos(t,e){this._getVertexRaw(this.getAttributeIndex(e),t),s(t,t,this.localOrigin)}getNormal(t,s){const i=e();this._getNormalRaw(this.getAttributeIndex(s),i),x(t,i)}_setNormal(t,e,s,i){d(this.attributes.normalCompressed,t,e,s,i)}_setUV(t,e,s){p(this.attributes.uv0,t,e,s)}setNormalFromValues(t,e,s,i){this._setNormal(this.getAttributeIndex(t),e,s,i)}setVertexFromValuesRawPositionUV(t,e,s,i,r,n){const o=this.getAttributeIndex(t);this.attributes.position.setValues(o,e,s,i),this._setUV(o,r,n)}setVertexFromValuesRawPositionUVNormal(t,e,s,i,r,n,o,u,a){const l=this.getAttributeIndex(t);this.attributes.position.setValues(l,e,s,i),this._setUV(l,r,n),this._setNormal(l,o,u,a)}}const c=o().vec3f(a.POSITION).vec2i16(a.UV0).vec2i16(a.NORMALCOMPRESSED,{glNormalized:!0}),m=new n((t=>c.createBuffer(t)),(t=>t.count));function b(){m.clear()}function g(t){return m.acquire(t)}function f(t){m.release(t.vertexAttributes),t.vertexAttributes=null,t.indices=null}function d(t,e,s,i,r){const n=1/(Math.abs(s)+Math.abs(i)+Math.abs(r)),o=s*n,u=i*n,a=r<=0?(o>=0?1:-1)*(1-Math.abs(u)):o,l=r<=0?(u>=0?1:-1)*(1-Math.abs(o)):u;t.setValues(e,A(a),A(l))}function x(t,e){const s=M(e[0]),r=M(e[1]),n=1-Math.abs(s)-Math.abs(r);t[2]=n,n<0?(t[0]=(s>=0?1:-1)*(1-Math.abs(r)),t[1]=(r>=0?1:-1)*(1-Math.abs(s))):(t[0]=s,t[1]=r),i(t,t)}const V=16384;function p(t,e,s,i){t.setValues(e,s*V,i*V)}function A(e){return t(Math.round(32767*e),-32767,32767)}function M(e){return t(e/32767,-1,1)}function v(t,e,s,i){t<i[0]?i[0]=t:t>i[3]&&(i[3]=t),e<i[1]?i[1]=e:e>i[4]&&(i[4]=e),s<i[2]?i[2]=s:s>i[5]&&(i[5]=s)}export{h as EdgeDescriptor,l as PatchGeometry,g as acquireTerrainAttributes,b as clearCaches,M as decodeInt16,x as decodeNormal,A as encodeInt16,d as encodeNormalToBufferFromValues,p as encodeUVInBuffer,v as minMaxBoundingBox,f as releaseGeometry};
