/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{isPowerOfTwo as t,clamp as e}from"../../../core/mathUtils.js";import{isNone as n,isSome as o}from"../../../core/maybe.js";import{s}from"../../../chunks/vec4.js";import{empty as i}from"../../../geometry/support/aaBoundingBox.js";import{fromValues as r}from"../../../geometry/support/aaBoundingRect.js";import{sampleElevation as a}from"./ElevationData.js";import{PatchType as c,NeighborIndex as l}from"./interfaces.js";import{acquireTerrainAttributes as u,minMaxBoundingBox as f,encodeUVInBuffer as d,encodeNormalToBufferFromValues as g,EdgeDescriptor as m}from"./PatchGeometry.js";import{PatchGeometryLUT as p}from"./PatchGeometryLUT.js";import{neighborTileIfLoadedOrSelf as h}from"./PatchRenderData.js";import{ENABLE_TERRAIN_INTERNAL_CHECKS as M,internalAssert as x,neighborEdgeIndices as y,almostEquals as S}from"./terrainUtils.js";import{isCornerNeighbor as b}from"./Tile.js";import{compareTilesByLij as v}from"./tileUtils.js";const L=65536;function R(t,e){const n=t.tile,{extent:o,extentInRadians:s,surface:r}=n,a=t.localOrigin,l=t.geometryState,m=r.isWebMercator,p=r.shading||rt,h=l.numVerticesPerSide,y=h-1,S=(h-2)**2,b=m&&(e===c.HAS_SOUTH_POLE||e===c.HAS_BOTH_POLES),v=m&&(e===c.HAS_NORTH_POLE||e===c.HAS_BOTH_POLES),L=6,R=((b?1:0)+(v?1:0))*L*(y+1),O=l.neighborData,T=O.edgeResolutions.reduce(((t,e)=>t+e+1),0),P=u(S+R+T),D=t.geometryInfo;D.numVerticesPerSide=l.numVerticesPerSide,D.vertexAttributes=P;const I=D.boundingBox;i(I);const U=j(t);nt.update(y,s,U),B(t),X(t,S),V(t);const E=[];if((()=>{let t=S+T;const e=a[0],s=a[1],i=a[2],r=n.ellipsoid.radius,c=o[1],l=o[3],u=(n,o)=>{const a=o*h;f(-e,-s,n*r-i,I),E.push({connectedRowOffset:a,connectedOuterEdgeOffset:1===n?0:2,rowOffset:t,latitudeResolution:L});const u=A(-1===n?c:l,r),m=n*Math.PI/2-u,M=.99*(1===n?1:-1),x=r+0,S=P.position,b=P.uv0,v=P.normalCompressed;for(let r=1;r<=L;++r){const n=u+m*(r/L),o=Math.cos(n),a=Math.sin(n);for(let r=0;r<=y;r++){const n=r/y,c=nt.sinLonLUT[r],l=nt.cosLonLUT[r]*o,u=c*o,m=a,h=l*x-e,L=u*x-s,R=m*x-i;f(h,L,R,I),S.setValues(t,h,L,R),d(b,t,n,M),p&&g(v,t,l,u,m),++t}}};b&&u(-1,0),v&&u(1,y)})(),Q(D,l.numVerticesPerSide,E,[0,h-1],[0,h-1],l.wireframe),t.intersectionData=null,M)for(let i=0;i<4;++i)x(D.outerEdges[i].count===O.edgeResolutions[i]+1)}function B(t){const e=t.tile;e.intersectsClippingArea&&(e.surface.shading||rt?T(t):O(t))}function O(t){const e=t.geometryState,n=e.numVerticesPerSide,o=n-2,s=n-1,i=t.geometryInfo,r=i.vertexAttributes,c=r.position,l=r.uv0,u=t.tile,g=u.extent,m=g[0],p=g[2],h=g[1],M=g[3],x=u.ellipsoid.radius,y=e.samplerData,S=t.localOrigin,b=S[0],v=S[1],L=S[2],R=i.boundingBox,B=c.typedBuffer,O=c.typedBufferStride;let T=0;for(let P=1;P<=o;P++){const t=P/s,e=h*(1-t)+M*t,n=nt.sinLatLUT[P],i=nt.cosLatLUT[P];for(let r=1;r<=o;r++){const o=r/s,c=m*(1-o)+p*o,u=nt.sinLonLUT[r],g=nt.cosLonLUT[r],h=x+a(c,e,y),M=g*i*h-b,S=u*i*h-v,P=n*h-L;f(M,S,P,R);const D=T*O;B[D+0]=M,B[D+1]=S,B[D+2]=P,d(l,T,o,t),++T}}}function T(t){const e=t.geometryState,n=e.numVerticesPerSide,o=n-2,s=n-1,i=t.geometryInfo,r=i.vertexAttributes,c=r.position,l=r.uv0,u=r.normalCompressed,m=t.tile,p=m.extent,h=p[0],M=p[2],x=p[1],y=p[3],S=m.ellipsoid.radius,b=e.samplerData,v=t.localOrigin,L=v[0],R=v[1],B=v[2],O=c.typedBuffer,T=c.typedBufferStride,P=1/s,D=i.boundingBox;let V=0;if(1<=o){const t=P,e=x*(1-t)+y*t,n=nt.sinLatLUT[1],s=nt.cosLatLUT[1];for(let i=1;i<=o;i++){const o=i*P,r=h*(1-o)+M*o,c=nt.sinLonLUT[i],u=nt.cosLonLUT[i],g=S+a(r,e,b),m=g*u*s-L,p=g*c*s-R,x=g*n-B;f(m,p,x,D);const y=(i-1)*T;O[y+0]=m,O[y+1]=p,O[y+2]=x,d(l,i-1,o,t)}}for(let I=1;I<=o;I++){const t=I*P,e=x*(1-t)+y*t,n=nt.sinLatLUT[I],i=nt.cosLatLUT[I],r=I+1,c=r*P,m=x*(1-c)+y*c,p=nt.sinLatLUT[r],v=nt.cosLatLUT[r],U=nt.sinLonLUT[0],A=nt.cosLonLUT[0],E=S+a(h,e,b);let C=A*i*E-L,j=U*i*E-R,w=n*E-B;const N=V*T;let H=O[N+0],_=O[N+1],W=O[N+2];for(let y=1;y<=o;y++){const t=y*P,r=h*(1-t)+M*t,U=nt.sinLonLUT[y],A=nt.cosLonLUT[y],E=A*i,N=U*i,q=n;let F=0,z=0,G=0;{let t=0,r=0,c=0;if(y<o){const e=(V+1)*T;t=O[e+0],r=O[e+1],c=O[e+2]}else{const o=nt.sinLonLUT[s],l=nt.cosLonLUT[s],u=S+a(M,e,b);t=l*i*u-L,r=o*i*u-R,c=n*u-B}const l=C,u=j,f=w;C=H,j=_,w=W,H=t,_=r,W=c;const d=t-l,g=r-u,m=c-f,p=g*q-m*N,h=m*E-d*q,x=d*N-g*E;F=h*m-x*g,z=x*d-p*m,G=p*g-h*d}{let e=0,n=0,s=0;if(I>1){const t=(V-o)*T;e=O[t+0],n=O[t+1],s=O[t+2]}else{const t=nt.sinLatLUT[0],o=nt.cosLatLUT[0],i=S+a(r,x,b);e=A*o*i-L,n=U*o*i-R,s=t*i-B}{const i=S+a(r,m,b),u=A*v*i-L,g=U*v*i-R,h=p*i-B;if(I<o){const e=V+o,n=e*T;O[n+0]=u,O[n+1]=g,O[n+2]=h,f(u,g,h,D),d(l,e,t,c)}const M=e-u,x=n-g,y=s-h,P=x*q-y*N,C=y*E-M*q,j=M*N-x*E;F+=C*y-j*x,z+=j*M-P*y,G+=P*x-C*M}}const k=1/Math.sqrt(F*F+z*z+G*G);g(u,V,F*k,z*k,G*k),++V}}}function P(t){t.tile.intersectsClippingArea&&(V(t),tt(t))}function D(t){t.tile.intersectsClippingArea&&(U(t),I(t,!0),tt(t))}function V(t){t.tile.intersectsClippingArea&&(U(t),I(t))}function I(e,s=!1){const i=e.geometryState,r=e.geometryInfo,c=i.neighborData,l=e.tile,u=l.level,g=l.extent,m=l.ellipsoid.radius,p=l.extentInRadians,b=p[0],L=p[2],R=p[1],B=p[3],O=i.samplerData,T=g[0],P=g[2],D=g[1],V=g[3],I=j(e),U=r.boundingBox,A=e.localOrigin,E=A[0],C=A[1],w=A[2],N=l.surface.shading||rt,H=r.vertexAttributes,_=H.position,W=_.typedBuffer,q=_.typedBufferStride,F=H.uv0;for(let j=0;j<4;++j){const i=1===j||3===j,p=c.edgeResolutions[j];x(t(p));const A=p+1,H=h(l,c.edgePeerNeighbors[j]);if(it(l,H,j)){Y(e,j);continue}const _=o(H);x(!_||H.level===l.level),x(!_||v(l,H)<=0);const z=H?.renderData,G=z?.geometryState;if(M){const t=l.surface;if(!H&&t&&!t.updatingRootTiles){const e=y[j],o=l.findNeighborTile(e,(t=>t.isLoaded||t.isLeaf||t.level===l.level));o?o.intersectsClippingArea&&(x(!o.isLoaded),x(!o.isLeaf),x(o.level===u)):x(n(t?.rootTiles)||!l.shouldHaveNeighbor(e))}}const k=1===j?g[2]:g[0],J=H?.extent,K=_&&i?1===j?J[0]:J[2]:k,Q=0===j?g[3]:g[1],X=1===j?1:0,Z=0===j?1:0,$=1===j?L:b,tt=0===j?B:R,et=Math.sin($),nt=Math.cos($),ot=Math.sin(tt),st=Math.cos(tt),rt=G?.samplerData,at=(t,e,n)=>a(t,e,O),ct=(t,e,n)=>.5*(a(t,e,O)+a(n,e,rt)),lt=_?ct:at,ut=r.outerEdges[j],ft=s&&A>3?A-3:1,dt=o(O)&&O.some((t=>null!=t)),gt=o(rt)&&rt.some((t=>null!=t)),mt=dt||gt,pt=1/p,ht=ut.index0;if(N){x(!_||S(J[2]-J[0],g[2]-g[0]));(()=>{const t=1===j?-1:3===j?1:0,e=0===j?-1:2===j?1:0,n=(g[2]-g[0])*pt,o=t*n,s=e*n,r=i?t*((L-b)*pt):0,c=i?0:e*pt,l=Z,u=i?$+r:$,p=i?Math.sin(u):et,h=i?Math.cos(u):nt,M=i?$-r:$,x=i?Math.sin(M):et,y=i?Math.cos(M):nt,S=i?tt:I(l+c),v=i?ot:Math.sin(S),R=i?st:Math.cos(S),B=i?tt:I(l-c),N=i?ot:Math.sin(B),H=i?st:Math.cos(B),z=(ht+0)*q;let G=W[z+0]+E,J=W[z+1]+C,Y=W[z+2]+w,it=0,at=0,ct=0;{const t=1*pt,e=i?k:T*(1-t)+P*t,n=i?K:e,o=i?D*(1-t)+V*t:Q,s=i?$:b*(1-t)+L*t,r=i?et:Math.sin(s),a=i?nt:Math.cos(s),c=i?I(t):tt,l=i?Math.sin(c):ot,u=i?Math.cos(c):st,f=m+lt(e,o,n);it=a*u*f,at=r*u*f,ct=l*f}for(let g=1;g<A-1;g+=ft){let t=0,e=0,n=0;{const o=(ht+g+1)*q;if(g<A-2){const o=(g+1)*pt,s=i?k:T*(1-o)+P*o,r=i?K:s,a=i?D*(1-o)+V*o:Q,c=i?$:b*(1-o)+L*o,l=i?et:Math.sin(c),u=i?nt:Math.cos(c),f=i?I(o):tt,d=i?Math.sin(f):ot,p=i?Math.cos(f):st,h=m+lt(s,a,r);t=u*p*h,e=l*p*h,n=d*h}else t=W[o+0]+E,e=W[o+1]+C,n=W[o+2]+w}const r=t,c=e,l=n,u=it,M=at,S=ct;it=r,at=c,ct=l;{const t=ht+g,e=t*q,n=u-E,o=M-C,s=S-w;W[e+0]=n,W[e+1]=o,W[e+2]=s,f(n,o,s,U);const r=g*pt;d(F,t,i?X:r,i?r:Z)}const B=G,j=J,z=Y;G=u,J=M,Y=S;const ft=u,dt=M,gt=S;let Mt=0,xt=0,yt=0;if(mt){const t=1/Math.sqrt(ft*ft+dt*dt+gt*gt),e=ft*t,n=dt*t,u=gt*t;{const t=r-B,o=c-j,s=l-z,i=o*u-s*n,a=s*e-t*u,f=t*n-o*e;Mt+=a*s-f*o,xt+=f*t-i*s,yt+=i*o-a*t}{const t=g*pt,r=i?k:T*(1-t)+P*t,c=i?K:r,l=i?D*(1-t)+V*t:Q,f=i?$:b*(1-t)+L*t,d=i?et:Math.sin(f),M=i?nt:Math.cos(f),S=i?I(t):tt,B=i?Math.sin(S):ot,U=i?Math.cos(S):st;let A=ft,E=dt,C=gt;if(_){const t=m+a(c-o,l-s,rt),e=i?U:H;A=(i?y:M)*e*t,E=(i?x:d)*e*t,C=(i?B:N)*t}{const t=m+a(r+o,l+s,O),c=i?U:R,f=(i?h:M)*c*t,g=(i?p:d)*c*t,x=(i?B:v)*t;_||(A=2*ft-f,E=2*dt-g,C=2*gt-x);const y=A-f,S=E-g,b=C-x,L=S*u-b*n,T=b*e-y*u,P=y*n-S*e;Mt+=T*b-P*S,xt+=P*y-L*b,yt+=L*S-T*y}}}else Mt=ft,xt=dt,yt=gt;const St=1/Math.sqrt(Mt*Mt+xt*xt+yt*yt);ut.setNormalFromValues(g,Mt*St,xt*St,yt*St)}})()}else{(()=>{for(let t=1;t<A-1;t+=ft){const e=t*pt,n=i?X:e,o=i?e:Z,s=i?k:T*(1-e)+P*e,r=i?D*(1-e)+V*e:Q,a=i?K:s,c=i?$:b*(1-e)+L*e,l=i?et:Math.sin(c),u=i?nt:Math.cos(c),g=i?I(e):tt,p=i?Math.sin(g):ot,h=i?Math.cos(g):st,M=lt(s,r,a),x=m+M,y=u*h*x-E,S=l*h*x-C,v=p*x-w;f(y,S,v,U);const R=ht+t,B=R*q;W[B+0]=y,W[B+1]=S,W[B+2]=v,d(F,R,n,o)}})()}}}function U(t){Z(t)}function A(t,e){return Math.PI/2-2*Math.atan(Math.exp(-t/e))}function E(t,e,n,o){return A(t*(1-o)+e*o,n)}function C(t,e,n){return t*(1-n)+e*n}function j(t){const e=t.tile;if(e.surface.isWebMercator){const t=e.extent,n=e.ellipsoid.radius;return e=>E(t[1],t[3],n,e)}const n=e.extentInRadians;return t=>C(n[1],n[3],t)}function w(t,e){const n=t.tile.extent,r=t.geometryState,a=n[0],c=n[1],l=n[2]-a,f=n[3]-c,d=r.clippingArea,g=o(d)?Math.max(0,(d[0]-a)/l):0,m=o(d)?Math.max(0,(d[1]-c)/f):0,p=o(d)?Math.min(1,(d[2]-a)/l):1,h=o(d)?Math.min(1,(d[3]-c)/f):1,M=r.numVerticesPerSide,x=(M-2)**2,y=r.neighborData.edgeResolutions.reduce(((t,e)=>t+e+1),0),S=u(x+y),b=t.geometryInfo,v=b.boundingBox;i(v),b.numVerticesPerSide=r.numVerticesPerSide,b.vertexAttributes=S,s(b.uvRange,g,m,p,h),N(t),X(t,x),F(t),Q(b,r.numVerticesPerSide,[],[0,M-1],[0,M-1],r.wireframe),t.intersectionData=null}function N(t){const e=t.tile;e.intersectsClippingArea&&(e.surface.shading?_(t):H(t))}function H(t){const n=t.geometryState,s=n.samplerData,i=t.tile,r=i.surface,c=t.localOrigin,l=r.isWebMercatorOnPlateeCarree,u=n.clippingArea,g=o(u)?u:ot,m=i.extent,p=m[0],h=m[1],M=m[2],x=m[3],y=Math.max(p,g[0]),S=Math.min(M,g[2]),b=Math.max(h,g[1]),v=Math.min(x,g[3]),L=c[0],R=c[1],B=c[2],O=i.ellipsoid.radius,T=i.horizontalScale,P=K(l,O,T),D=n.numVerticesPerSide,V=D-1,I=D-2,U=t.geometryInfo,A=U.uvRange,E=A[0],C=A[1],j=A[2],w=A[3],N=U.boundingBox,H=U.vertexAttributes,_=H.position,W=H.uv0;let q=0;for(let o=1;o<=I;o++){const t=o/V,n=e(h*(1-t)+x*t,b,v),i=e(t,C,w),r=P(n)-R;for(let o=1;o<=I;o++){const t=o/V,c=e(p*(1-t)+M*t,y,S),l=e(t,E,j),u=c*T-L,g=a(c,n,s)-B;f(u,r,g,N),_.setValues(q,u,r,g),d(W,q,l,i),++q}}}function _(t){const n=t.tile,s=n.surface;if(!(s.shading||rt))return;const i=t.geometryState,r=i.samplerData,c=t.localOrigin,l=s.isWebMercatorOnPlateeCarree,u=i.clippingArea,m=o(u)?u:ot,p=n.extent,h=p[0],M=p[1],x=p[2],y=p[3],S=Math.max(h,m[0]),b=Math.min(x,m[2]),v=Math.max(M,m[1]),L=Math.min(y,m[3]),R=n.ellipsoid.radius,B=n.horizontalScale,O=i.numVerticesPerSide,T=O-1,P=O-2,D=t.geometryInfo,V=D.vertexAttributes,I=V.position,U=V.uv0,A=V.normalCompressed,E=D.uvRange,C=E[0],j=E[1],w=E[2],N=E[3],H=D.boundingBox,_=c[0],W=c[1],q=c[2],F=I.typedBuffer,z=I.typedBufferStride;let G=0;const k=e(M,v,L),J=l?(Math.PI/2-2*Math.atan(Math.exp(-k/R)))*R:k*B,K=1/T,Q=e(M*(1-K)+y*K,v,L);let X=J,Y=l?(Math.PI/2-2*Math.atan(Math.exp(-Q/R)))*R:Q*B;for(let o=1;o<=P;o++){const t=o/T,n=e(M*(1-t)+y*t,v,L),s=e(t,j,N),i=Y,c=(o-1)/T,u=e(M*(1-c)+y*c,v,L),m=X,p=(o+1)/T,O=e(M*(1-p)+y*p,v,L),D=l?(Math.PI/2-2*Math.atan(Math.exp(-O/R)))*R:O*B,V=e(p,j,N);X=Y,Y=D;const I=e(h,S,b);let E=I*B,k=a(I,n,r);const J=1/T,K=e(J,C,w),Q=e(h*(1-K)+x*K,S,b);let Z=K,$=Q,tt=Q*B,et=a(Q,n,r);if(1===o){const t=tt-_,n=X-W,o=et-q,i=0*z;F[i+0]=t,F[i+1]=n,F[i+2]=o,f(t,n,o,H);const r=e(J,C,w);d(U,G,r,s)}for(let l=1;l<=P;l++){const t=tt,c=et,p=(l+1)/T,M=e(p,C,w),y=e(h*(1-p)+x*p,S,b),v=$;$=y;{const t=G+1,e=t*z;if(1===o||l===P){const c=y*B,u=i,g=a(y,n,r);if(1===o&&l<P){const n=c-_,o=u-W,i=g-q;F[e+0]=n,F[e+1]=o,F[e+2]=i,f(n,o,i,H),d(U,t,M,s)}tt=c,et=g}else tt=F[e+0]+_,et=F[e+2]+q}const L=tt,R=et,I=E,j=k;E=t,k=c;const N=(G-P)*z,J=1===o?a(v,u,r):F[N+2]+q,K=a(v,O,r);if(o<P){const e=G+P,n=e*z,o=t-_,s=D-W,i=K-q;F[n+0]=o,F[n+1]=s,F[n+2]=i,f(o,s,i,H);const r=Z;Z=M,d(U,e,r,V)}{const t=L-I,e=-t*(R-j),n=m-D,o=-n*(J-K),s=t*t+n*n,i=e*e+o*o+s*s;if(0===i)g(A,G,0,0,1);else{const t=1/Math.sqrt(i);g(A,G,e*t,o*t,s*t)}}++G}}}function W(t,e){t.tile.intersectsClippingArea&&(G(t),z(t,!0),tt(t))}function q(t,e){t.tile.intersectsClippingArea&&(F(t),tt(t))}function F(t,e){t.tile.intersectsClippingArea&&(G(t),z(t,!1))}function z(s,i){const r=s.geometryState,c=r.neighborData,l=s.tile,u=l.surface,d=u.shading||rt,g=l.extent,m=r.clippingArea,p=o(m)?m:ot,S=g[0],b=g[2],L=g[1],R=g[3],B=[R>p[3],b>p[2],L<p[1],S<p[0]],O=s.geometryInfo,T=l.horizontalScale,P=K(u.isWebMercatorOnPlateeCarree,l.ellipsoid.radius,T),D=O.boundingBox,V=O.uvRange[0],I=O.uvRange[1],U=O.uvRange[2],A=O.uvRange[3],E=Math.max(S,p[0]),C=Math.min(b,p[2]),j=Math.max(L,p[1]),w=Math.min(R,p[3]),N=s.localOrigin,H=N[0],_=N[1],W=N[2],q=r.samplerData;for(let F=0;F<4;++F){const r=1===F||3===F,g=c.edgeResolutions[F];x(t(g));const m=g+1,p=B[F],N=h(l,c.edgePeerNeighbors[F]);if(!p&&it(l,N,F)){Y(s,F);continue}const z=o(N)&&!p,G=N?.renderData,k=G?.geometryState;if(M&&(x(!z||N.level===l.level),x(!z||v(l,N)<=0),l&&!N&&!u.updatingRootTiles)){const t=y[F],e=l.findNeighborTile(t,(t=>t.isLoaded||t.isLeaf||t.level===l.level));u.updatingRootTiles||(e?e.intersectsClippingArea&&(x(!e.isLoaded),x(!e.isLeaf),x(e.level===l.level)):x(n(u?.rootTiles)||!l.shouldHaveNeighbor(t)))}const J=e(1===F?b:S,E,C),K=e(0===F?R:L,j,w),Q=k?.samplerData,X=O.outerEdges[F],Z=i&&m>3?m-3:1,$=e(1===F?1:0,V,U),tt=e(0===F?1:0,I,A),et=(t,e)=>a(t,e,q),nt=(t,e)=>.5*(a(t,e,Q)+a(t,e,q)),ot=z?nt:et;if(d){const t=(b-S)/g,n=r?1===F?t:-t:0,o=r?0:0===F?t:-t,s=-n,i=-o,c=X.attributes.position.typedBuffer,l=X.attributes.position.typedBufferStride,u=X.index0,d=X.stride,p=u*l;let h=c[p+0]+H,M=c[p+1]+_,x=c[p+2]+W,y=0,v=0,B=0;{const t=1/g,n=r?J:e(S*(1-t)+b*t,E,C),o=r?e(L*(1-t)+R*t,j,w):K,s=ot(n,o),i=n*T,a=P(o);y=i,v=a,B=s}for(let O=1;O<m-1;O+=Z){const t=O/g,p=y,N=v,F=B;{const n=r?$:e(t,V,U),o=r?e(t,I,A):tt,s=p-H,i=N-_,a=F-W;f(p,i,a,D),X.setVertexFromValuesRawPositionUV(O,s,i,a,n,o)}const G=O+1;if(O===m-1){const t=(u+G*d)*l;y=c[t+0]+H,v=c[t+1]+_,B=c[t+2]+W}else{const t=G/g,n=r?J:e(S*(1-t)+b*t,E,C),o=r?e(L*(1-t)+R*t,j,w):K,s=ot(n,o);y=n*T,v=P(o),B=s}const k=y,Y=v,Z=B,et=h,nt=M,st=x;h=p,M=N,x=F;let it=0,rt=0,at=0;if(r){{const t=Y-N,e=nt-N;rt-=e*(st-F)+t*(Z-F),at+=e*e+t*t}{const o=e(L*(1-t)+R*t,j,w),i=J+s,r=i*T-p;if(it-=r*(a(i,o,q)-F),at+=r*r,z){const t=J+n,e=t*T-p;it-=e*(a(t,o,Q)-F),at+=e*e}}}else{{const t=k-p,e=et-p;it-=t*(Z-F)+e*(st-F),at+=t*t+e*e}{const n=e(S*(1-t)+b*t,E,C),s=K+i,r=a(n,s,q)-F,c=P(s)-N;if(rt-=c*r,at+=c*c,z){const t=n,e=K+o,s=P(e)-N;rt-=s*(a(t,e,Q)-F),at+=s*s}}}const ct=1/Math.sqrt(it*it+rt*rt+at*at);X.setNormalFromValues(O,it*ct,rt*ct,at*ct)}}else for(let t=1;t<m-1;t+=Z){const n=t/g,o=r?J:e(S*(1-n)+b*n,E,C),s=r?e(L*(1-n)+R*n,j,w):K,i=r?$:e(n,V,U),a=r?e(n,I,A):tt,c=ot(o,s),l=o*T-H,u=P(s)-_,d=c-W;f(l,u,d,D),X.setVertexFromValuesRawPositionUV(t,l,u,d,i,a)}}}function G(t,e){Z(t)}function k(t,e){return(Math.PI/2-2*Math.atan(Math.exp(-t/e)))*e}function J(t,e){return t*e}function K(t,e,n){return t?t=>k(t,e):t=>J(t,n)}function Q(t,e,n,o,s,i){const r=e-1,a=t.vertexAttributes.count,c=2*(Math.min(e-2,o[1])-Math.max(1,o[0]))*(Math.min(e-2,s[1])-Math.max(1,s[0])),l=y.map(((t,n)=>0===n&&s[1]<e-2||1===n&&o[1]<e-2||2===n&&s[0]>1||3===n&&o[0]>1)),u=t.outerEdges.reduce(((t,e,n)=>t+(l[n]?0:r-2+e.count-1)),0),f=n.reduce(((t,e)=>t+r*(2*(e.latitudeResolution-1)+1)),0),d=i?2:1,g=3*(c+u+f)*d,m=a>=L?new Uint32Array(g):new Uint16Array(g);let p=0;const h=e-2,S=r-2;if(x(S>=0),i){const i=(t,e,n)=>{m[p++]=t,m[p++]=e,m[p++]=e,m[p++]=n,m[p++]=n,m[p++]=t,M&&(x(t<a),x(e<a),x(n<a),x(p<=g))};(()=>{for(let t=Math.max(s[0],1)-1;t<Math.min(s[1],e-2)-1;++t)for(let n=Math.max(o[0],1)-1;n<Math.min(o[1],e-2)-1;++n){const e=t*h+n,o=e+1,s=o+h,r=s-1;i(e,o,s),i(s,r,e)}})(),x(p===3*c*d);(()=>{for(let e=0;e<4;++e){const n=p;if(l[e])continue;const o=t.outerEdges[e],s=t.innerEdges[e];let a=0,c=0;const u=o.count,f=s.count;x(f===r-1);let g=0;const m=1===e||2===e?(t,e,n)=>i(t,e,n):(t,e,n)=>i(t,n,e);for(;a<u-1||c<f-1;){const t=s.getVertexIndex(c),e=o.getVertexIndex(a),n=a<u-1,i=c<f-1,l=n?0+r*(a+.5)/(u-1):0,d=i?1+S*(c+.5)/(f-1):0;if(n&&(!i||l<=d)){++a,M&&x(a<u);m(t,e,o.getVertexIndex(a)),g++}else{++c,M&&x(c<f);m(t,e,s.getVertexIndex(c)),g++}}M&&(x(a===u-1),x(c===f-1),x(g===u+f-2),x(g===r-2+o.count-1),x(p===n+3*g*d))}})(),x(p===3*(c+u)*d);const f=n=>{const o=t.outerEdges[n.connectedOuterEdgeOffset];let s=o.getVertexIndex(0),a=o.stride;for(let t=0;t<n.latitudeResolution;++t){const o=0===t?n.rowOffset:s+e;for(let e=0;e<r;e++)i(s,s+1,o+e),t<n.latitudeResolution-1&&i(s+1,o+e+1,o+e),s+=a;s=o,a=1}};(()=>n.forEach(f))()}else{(()=>{const t=Math.max(s[0],1)-1,n=Math.min(s[1],e-2)-1,i=Math.max(o[0],1)-1,r=Math.min(o[1],e-2)-1;for(let e=t;e<n;++e){const t=e*h;for(let e=i;e<r;++e){const n=t+e,o=n+1,s=o+h,i=s-1;m[p+0]=n,m[p+1]=o,m[p+2]=s,m[p+3]=s,m[p+4]=i,m[p+5]=n,p+=6}}})(),x(p===3*c*d);(()=>{for(let e=0;e<4;++e){if(l[e])continue;const n=t.outerEdges[e],o=t.innerEdges[e];let s=0,i=0;const a=n.count,c=o.count;x(c===r-1);const u=1===e||2===e,f=u?1:2,d=u?2:1,g=n.index0,h=n.stride,M=o.index0,y=o.stride;for(;s<a-1||i<c-1;){const t=M+i*y,e=g+s*h,n=s<a-1,o=i<c-1,l=n?0+r*(s+.5)/(a-1):0,u=o?1+S*(i+.5)/(c-1):0,x=n&&(!o||l<=u);x?++s:++i;const b=x?e+h:t+y;m[p+0]=t,m[p+f]=e,m[p+d]=b,p+=3}}})(),x(p===3*(c+u)*d);const i=n=>{const o=t.outerEdges[n.connectedOuterEdgeOffset];let s=o.getVertexIndex(0),i=o.stride;for(let t=0;t<n.latitudeResolution;++t){const o=0===t?n.rowOffset:s+e;for(let e=0;e<r;e++){const r=o+e;m[p+0]=s,m[p+1]=s+1,m[p+2]=r,t<n.latitudeResolution-1?(m[p+3]=s+1,m[p+4]=r+1,m[p+5]=r,p+=6):p+=3,s+=i}s=o,i=1}};(()=>n.forEach(i))()}x(p===g),t.indices=m,t.indexCount=g}function X(t,e){const n=t.localOrigin,o=t.geometryInfo,s=t.geometryState.neighborData.edgeResolutions,i=o.numVerticesPerSide-2,r=o.vertexAttributes;let a=e;for(let c=0;c<4;++c){{const t=0===c||2===c,e=(0===c?i-1:0)*i+(1===c?i-1:0),s=(t?0:1)*i+(t?1:0);o.innerEdges[c]=new m(r,n,e,s,i)}{const t=a,e=s[c]+1;o.outerEdges[c]=new m(r,n,t,1,e),a+=e}}}function Y(n,o){const s=(o+2)%4,i=n.geometryState,r=n.tile,a=i.neighborData,c=h(r,a.edgePeerNeighbors[o]),l=r.level-c.level,u=1===o||3===o,g=a.edgeResolutions[o];x(t(g));const m=g+1,p=n.geometryInfo,M=p.boundingBox,y=p.outerEdges[o],S=p.uvRange[0],b=p.uvRange[1],v=p.uvRange[2],L=p.uvRange[3],R=e(1===o?1:0,S,v),B=e(0===o?1:0,b,L),O=c.renderData,T=O.geometryState,P=O.geometryInfo.outerEdges[s],D=r.getNeighborEdgeStartVertexIndex(o,c)*g,V=g*2**l;x(T.neighborData.edgeResolutions[s]===V),x(P.count-1===V);const I=O.localOrigin[0]-n.localOrigin[0],U=O.localOrigin[1]-n.localOrigin[1],A=O.localOrigin[2]-n.localOrigin[2],E=y.attributes,C=y.index0,j=y.stride,w=E.position.typedBuffer,N=E.position.typedBufferStride,H=E.normalCompressed.typedBuffer,_=E.normalCompressed.typedBufferStride,W=E.uv0,q=P.attributes,F=P.index0,z=P.stride,G=q.position.typedBuffer,k=q.position.typedBufferStride,J=q.normalCompressed.typedBuffer,K=q.normalCompressed.typedBufferStride;for(let t=1;t<m-1;++t){const n=C+j*t,o=F+z*(D+t),s=n*N,i=o*k,r=G[i+0]+I,a=G[i+1]+U,c=G[i+2]+A;w[s+0]=r,w[s+1]=a,w[s+2]=c,f(r,a,c,M);const l=n*_,m=o*K;H[l+0]=J[m+0],H[l+1]=J[m+1];const p=t/g,h=u?R:e(p,S,v),x=u?e(p,b,L):B;d(W,n,h,x)}}function Z(t){const n=t.geometryState,s=n.neighborData,i=t.localOrigin,r=s.cornerNeighborData,c=t.geometryInfo,l=c.outerEdges,u=c.boundingBox,g=t.tile,m="local"===t.tile.surface.view?.viewingMode,p=g.ellipsoid.radius,h=g.extentInRadians,M=g.horizontalScale;let y=0,S=0,b=0,L=0,R=0,B=0;const O=(t,e,n)=>{const o=h[0===e?1:3],s=h[0===t?0:2],i=Math.cos(o),r=Math.sin(o),a=Math.sin(s),c=Math.cos(s),l=p+n;y=c*i*l,S=a*i*l,b=r*l},T=m?(()=>{const n=t.geometryState.clippingArea,s=g.extent,i=o(n)&&(s[3]>n[3]||s[2]>n[2]||s[1]<n[1]||s[0]<n[0]),r=K(g.surface.isWebMercatorOnPlateeCarree,g.ellipsoid.radius,M);return(t,o,s)=>{const a=0===t?A[0]:A[2],c=0===o?A[1]:A[3],l=i?e(a,n[0],n[2]):a,u=i?e(c,n[1],n[3]):c,f=s;y=l*M,S=r(u),b=f}})():O;let P=0,D=0,V=0;const I=m&&t.tile.surface.isWebMercatorOnPlateeCarree,U=(t,e,n,o)=>{if(m){const t=e*M,s=I?(Math.PI/2-2*Math.atan(Math.exp(-n/p)))*p:n*M,i=t-y,r=s-S,a=o-b;P+=-i*a,D+=-r*a,V+=i*i+r*r}else{const s=j(t),i=t.tile,r=i.extent,a=i.extentInRadians,c=(e-r[0])/(r[2]-r[0]),l=(n-r[1])/(r[3]-r[1]),u=a[0]*(1-c)+a[2]*c,f=s(l),d=Math.cos(f),g=Math.sin(f),m=Math.sin(u),h=Math.cos(u),M=p+o,x=h*d*M-y,v=m*d*M-S,O=g*M-b,T=v*B-O*R,I=O*L-x*B,U=x*R-v*L;P+=I*O-U*v,D+=U*x-T*O,V+=T*v-I*x}},A=g.extent,E=n.clippingArea,C=o(E)?E:ot,w=A[0],N=A[2],H=A[1],_=A[3],W=[_>C[3],N>C[2],H<C[1],w<C[0]],q=Math.max(w,C[0]),F=Math.min(N,C[2]),z=Math.max(H,C[1]),G=Math.min(_,C[3]),k=c.uvRange[0],J=c.uvRange[1],Q=c.uvRange[2],X=c.uvRange[3],Y=g.surface.shading||rt,Z=t=>{if(!m){const t=1/Math.sqrt(y*y+S*S+b*b);L=y*t,R=S*t,B=b*t}const e=r[t].cornerTiles;P=0,D=0,V=0;let n=1/0;for(let r=0;r<4;++r)n=Math.min(n,e[r]?.level??1/0);for(let r=0;r<4;++r){const t=e[r];st[r]=t?.level===n?t:null}let o=1,s=0;for(let r=0;r<4;++r){const t=st[r];t&&(o=Math.max(o,t?.renderData.geometryState.numVerticesPerSide),s=t.extent[2]-t.extent[0])}const i=s,c=o;x(c>1);const l=i/c;for(let r=0;r<4;++r){const t=st[(r+3)%4],e=st[(r+0)%4];if(!t&&!e)continue;const n=0===r?1:1===r?2:2===r?3:0,o=0===r?2:1===r?3:2===r?0:1;if(t&&e){const s=et[r][0]*l,i=et[r][1]*l,c=t.extent,u=c[0===n||1===n?2:0]+s,f=c[0===n||3===n?3:1]+i,d=e.extent,g=d[0===o||1===o?2:0]+s,m=d[0===o||3===o?3:1]+i,p=t.renderData,h=e.renderData,M=a(u,f,p.geometryState.samplerData),x=a(g,m,h.geometryState.samplerData);U(p,u,f,.5*(M+x))}else{const s=t??e,i=t?n:o,c=s.extent,u=et[r],f=c[0===i||1===i?2:0]+u[0]*l,d=c[0===i||3===i?3:1]+u[1]*l,g=s.renderData,m=a(f,d,g.geometryState.samplerData);U(g,f,d,m)}}const u=1/Math.sqrt(P*P+D*D+V*V);P*=u,D*=u,V*=u};for(let o=0;o<4;++o){const s=o,c=(o+1)%4,m=0===o||1===o?1:0,p=0===o||3===o?1:0,h=e(m,k,Q),M=e(p,J,X),L=l[s],R=0===o||3===o?L.count-1:0,B=l[c],O=0===o||1===o?B.count-1:0,I=r[o].cornerTiles;let U=-1;for(let t=0;t<4;++t){const e=I[t];e&&(-1===U||v(I[U],e)>0)&&(U=t)}const A=U,E=I[A];if(P=0,D=0,V=1,E!==g){const e=g.level-E.level,n=2**e,s=[E.lij[0]+e,E.lij[1]*n,E.lij[2]*n],i=[s[1]+n===g.lij[1],0===o&&(1===A||0===A&&E!==I[3])||1===o&&(0===A||1===A&&E!==I[2]),s[1]===g.lij[1]+1,2===o&&(3===A||2===A&&E!==I[1])||3===o&&(2===A||3===A&&E!==I[0])],r=i.reduce(((t,e)=>t+(e?1:0)),0);x(1===r||2===r);let a=-1,c=-1;const l=E.renderData;if(1===r){const e=i.findIndex((t=>t));x(0<=e&&e<=3),a=(e+2)%4;const n=t.geometryState.neighborData.edgeResolutions[e];c=g.getNeighborEdgeStartVertexIndex(e,E)*n+n*(0===e&&0===o||1===e&&0===o||2===e&&1===o||3===e&&3===o?1:0)}else{x(i[1]||i[3]),a=i[1]?3:1;const t=l.geometryState.neighborData.edgeResolutions[a];c=0===o||3===o?0:t}const m=l.geometryInfo.outerEdges[a];{const e=L.index0+R*L.stride,n=B.index0+O*B.stride,o=m.index0+c*m.stride;{const s=m.attributes.position,i=s.typedBuffer,r=o*s.typedBufferStride,a=t.localOrigin,c=m.localOrigin,l=i[r+0]+c[0]-a[0],d=i[r+1]+c[1]-a[1],g=i[r+2]+c[2]-a[2];f(l,d,g,u);{const t=L.attributes.position,n=t.typedBuffer,o=e*t.typedBufferStride;n[o+0]=l,n[o+1]=d,n[o+2]=g}{const t=B.attributes.position,e=t.typedBuffer,o=n*t.typedBufferStride;e[o+0]=l,e[o+1]=d,e[o+2]=g}}d(L.attributes.uv0,e,h,M),d(B.attributes.uv0,n,h,M);{const t=m.attributes.normalCompressed.typedBuffer,s=o*m.attributes.normalCompressed.typedBufferStride;{const n=L.attributes.normalCompressed,o=n.typedBuffer,i=e*n.typedBufferStride;o[i+0]=t[s+0],o[i+1]=t[s+1]}{const e=B.attributes.normalCompressed,o=e.typedBuffer,i=n*e.typedBufferStride;o[i+0]=t[s+0],o[i+1]=t[s+1]}}}}else{const t=W[s],r=W[c];let l;if(t||r){const t=e(w*(1-m)+N*m,q,F),o=e(H*(1-p)+_*p,z,G),s=n.samplerData;l=a(t,o,s)}else l=$(I);T(m,p,l),(Y||rt)&&Z(o);const d=y-i[0],g=S-i[1],x=b-i[2];f(d,g,x,u),L.setVertexFromValuesRawPositionUVNormal(R,d,g,x,h,M,P,D,V),B.setVertexFromValuesRawPositionUVNormal(O,d,g,x,h,M,P,D,V)}}for(let e=0;e<4;++e)st[e]=null}function $(t){const e=t.reduce(((t,e)=>Math.min(t,e?.level??1/0)),1/0);M&&(x(!t[0]||!t[2]||b(t[0],t[2],l.SOUTH_WEST)),x(!t[1]||!t[3]||b(t[1],t[3],l.NORTH_WEST)));let n=0,o=0;for(let i=0;i<4;++i){const s=t[i];if(s&&s.level===e){const t=0===i||1===i,e=0===i||3===i,r=s.extent,c=r[t?0:2],l=r[e?1:3],u=s.renderData?.geometryState?.samplerData;o+=a(c,l,u),n++}}const s=n?o/n:0;return x(null!=s),s}function tt(t){const e=t.vao,n=t.geometryInfo.vertexAttributes.position.typedBuffer;e.vertexBuffers.geometry.setSubData(n,0,0,n.length)}const et=[[0,1],[1,0],[0,-1],[-1,0]],nt=new p,ot=r(-1/0,-1/0,1/0,1/0),st=[null,null,null,null];function it(t,e,n){if(!e)return!1;const o=v(t,e);return o>0||0===o&&n<2}const rt=!0;export{O as createInternalVerticesPositionsSpherical,w as createPlanarGlobePatch,R as createSphericalGlobePatch,D as updateCornerSpherical,W as updateCornersPlanar,q as updateEdgesAndCornersPlanar,P as updateEdgesAndCornersSpherical};
