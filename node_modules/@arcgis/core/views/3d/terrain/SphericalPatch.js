/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{lerp as t}from"../../../core/mathUtils.js";import{n as e,s as i,d as s}from"../../../chunks/vec3.js";import{c as r,d as a}from"../../../chunks/vec3f64.js";import{lonLatToSphericalPCPF as o}from"../../../geometry/projection.js";import{getReferenceEllipsoid as n}from"../../../geometry/projectionEllipsoid.js";import{intersectsSphere as h,NumPlanes as l,PlaneIndex as d}from"../../../geometry/support/frustum.js";import{TileFrustumVisibility as u,PatchType as c}from"./interfaces.js";import{createSphericalGlobePatch as p,updateCornerSpherical as _,updateEdgesAndCornersSpherical as m}from"./PatchGeometryFactory.js";import{Tile as f}from"./Tile.js";class E extends f{constructor(t,e,i){super(),this._obb=new Array(8);for(let s=0;s<8;s++)this._obb[s]=r();void 0!==t&&this.init(t,e,i)}init(i,s,r){super.init(i,s,r);const n=this.ellipsoid.radius,h=this.extentInRadians[0],l=this.extentInRadians[1],d=this.extentInRadians[2],u=this.extentInRadians[3],c=i[0],p=t(l,u,.5),_=t(h,d,.5),m=0===c?0:Math.min(Math.abs(l),Math.abs(u));this._edgeLen=(d-h)*Math.cos(m)*n,this._edgeLen2=this._edgeLen*this._edgeLen,this._curvatureHeight=n-Math.sqrt(n*n-this._edgeLen2/4),o(this.centerAtSeaLevel,_,p,this.ellipsoid.radius);const f=a(this.centerAtSeaLevel);e(f,f),this.up=f,this._updateOBB(),this.updateRadiusAndCenter()}updateRadiusAndCenter(){if(0===this.lij[0])i(this._center[O.MIDDLE],0,0,0),i(this._center[O.TOP],0,0,0),i(this._center[O.BOTTOM],0,0,0),this.ellipsoid||(this.ellipsoid=n(this.surface.spatialReference)),this._center[O.MIDDLE][3]=this.ellipsoid.radius+this.elevationBounds[1];else{this._updateCenter();const t=Math.max(s(this._center[O.MIDDLE],this._obb[0]),s(this._center[O.MIDDLE],this._obb[1]));this._center[O.MIDDLE][3]=Math.sqrt(t)}}_calculateFrustumVisibilityStatus(t){if(!h(t,this._center[O.MIDDLE]))return u.OUTSIDE;if(this.lij[0]<10)return u.INTERSECTS;const e=this._obb,i=this.surface.view.state.camera.near;let s=!0;for(let r=0;r<l.NUM;r++){const a=r===d.NEAR,o=t[r],n=o[0],h=o[1],l=o[2],c=o[3]-(a?i:0);let p=!1;for(let t=0;t<8;++t){const i=e[t];if(n*i[0]+h*i[1]+l*i[2]+c<0){if(p=!0,!s)break}else s=!1}if(!p)return u.OUTSIDE}return s?u.INSIDE:u.INTERSECTS}computeElevationBounds(){super.computeElevationBounds(),this._updateOBB()}createGeometry(){const t=this._getPatchType(this.lij[1],this.lij[0]);p(this.renderData,t),this.setMemoryDirty()}_updateOBB(){const t=this.extentInRadians,e=this._obb;for(let i=0;i<2;i++){const s=this.elevationBounds[i];let r=4*i;o(e[r++],t[0],t[1],this.ellipsoid.radius+s),o(e[r++],t[0],t[3],this.ellipsoid.radius+s),o(e[r++],t[2],t[3],this.ellipsoid.radius+s),o(e[r++],t[2],t[1],this.ellipsoid.radius+s)}if(this.surface.isWebMercator)switch(this._getPatchType(this.lij[1],this.lij[0])){case c.HAS_NORTH_POLE:i(e[1],0,0,this.ellipsoid.radius),i(e[2],0,0,this.ellipsoid.radius),i(e[5],0,0,this.ellipsoid.radius),i(e[6],0,0,this.ellipsoid.radius);break;case c.HAS_SOUTH_POLE:i(e[0],0,0,-this.ellipsoid.radius),i(e[3],0,0,-this.ellipsoid.radius),i(e[4],0,0,-this.ellipsoid.radius),i(e[7],0,0,-this.ellipsoid.radius)}}_getPatchType(t,e){return t===(1<<e)-1?0===t?c.HAS_BOTH_POLES:c.HAS_SOUTH_POLE:0===t?c.HAS_NORTH_POLE:c.REGULAR}intersectsRay(t,e,i,s){const r=this._center[O.MIDDLE],a=r[3]+i,o=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],n=r[0]-t[0],h=r[1]-t[1],l=r[2]-t[2],d=(n*e[0]+h*e[1]+l*e[2])/o,u=e[0]*d-n,c=e[1]*d-h,p=e[2]*d-l;return u*u+c*c+p*p<a*a}getDefaultVerticesPerRowOnLevel(){return this.level<D.length?D[this.level]+1:2}updateCornerElevations(){_(this.renderData)}updateEdgeElevations(){m(this.renderData)}}const D=[128,64,32,16,16,8,8,4];var O;!function(t){t[t.TOP=0]="TOP",t[t.MIDDLE=1]="MIDDLE",t[t.BOTTOM=2]="BOTTOM"}(O||(O={}));export{O as CenterPosition,E as SphericalPatch};
