/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{equals as e}from"../../../core/arrayUtils.js";import{isPowerOfTwo as t}from"../../../core/mathUtils.js";import{isSome as r,isNone as i,mapOr as s}from"../../../core/maybe.js";import{i as a,j as n,u as o,b as l,n as h,e as d,y as g,F as c}from"../../../chunks/vec3.js";import{c as u,a as m}from"../../../chunks/vec3f64.js";import{empty as p}from"../../../geometry/support/aaBoundingBox.js";import{containsXY as f}from"../../../geometry/support/aaBoundingRect.js";import{earth as y}from"../../../geometry/support/Ellipsoid.js";import{glLayout as _}from"../support/buffer/glUtil.js";import{GeometryState as x}from"./GeometryState.js";import{NeighborIndex as D}from"./interfaces.js";import{LayerClass as v}from"./LayerClass.js";import{PatchGeometry as C,releaseGeometry as S}from"./PatchGeometry.js";import{ENABLE_TERRAIN_INTERNAL_CHECKS as $,internalAssert as E,neighborEdgeIndices as b,oppositeEdge as T,neighborCornerIndices as j,v32s as A,lij2s as V}from"./terrainUtils.js";import{TextureFader as R,ActivationTime as L}from"./TextureFader.js";export{ActivationTime}from"./TextureFader.js";import{isEdgeNeighbor as w}from"./Tile.js";import P from"./TileOverlayData.js";import{fallsWithinLayer as N}from"./tileUtils.js";import{VertexArrayObject as I}from"../webgl-engine/lib/VertexArrayObject.js";import{terrainVertexAttributeLocations as G}from"../webgl-engine/shaders/TerrainTechnique.js";import{BufferObject as M}from"../../webgl/BufferObject.js";class O{constructor(){this.geometryInfo=new C,this.intersectionData=null,this.geometryState=null,this._textureRef=new R((()=>this.tile.surface.textureFadeDuration)),this.overlay=new P,this._geometryStateChangedSinceLastUpdate=!0,this._hasGeometry=!1,this._numVerticesPerSideChanged=!1,this._samplerDataChanged=!1,this._clippingAreaChanged=!1,this._wireframeChanged=!1,this._shadingChanged=!1,this._dirtyEdgeResolutions=15,this._dirtyEdges=15,this._dirtyCorners=15}get tile(){return this._tile}init(e){this.clear(),this._tile=e;const t=this.geometryInfo;t.indices=null,t.vertexAttributes=null,p(t.boundingBox),t.indexCount=0,t.numVerticesPerSide=0,this.intersectionData=null,this.geometryState=new x,this.localOrigin=null,this.overlay.clear()}clear(){this._releaseGeometry(),this.releaseTexture(),this._textureRef.clear(),this._tile=null,this.intersectionData=null,this.geometryState=null}updateGeometryIfNeeded(e){if((!this._vao||this._geometryStateChangedSinceLastUpdate||this._wireframeChanged||this._shadingChanged||this._clippingAreaChanged||this._samplerDataChanged||this._numVerticesPerSideChanged||this._dirtyCorners||this._dirtyEdgeResolutions||this._dirtyEdges)&&(this._updateGeometry(e),this._geometryStateChangedSinceLastUpdate=!1),$&&this.tile.intersectsClippingArea)for(let t=0;t<4;++t)E(this.geometryInfo.outerEdges[t].count===this.geometryState.neighborData.edgeResolutions[t]+1)}_calculateEdgeResolution(e,t){const s=this.tile,a=this.geometryState.numVerticesPerSide-1;if(!s.surface.isGlobal){const t=s.surface.extent;if(r(t)&&(0===e&&s.extent[3]>t[3]||1===e&&s.extent[2]>t[2]||2===e&&s.extent[1]<t[1]||3===e&&s.extent[0]<t[0]))return a}const n=s.level,o=b[e];if(!t)return E(i(s.surface?.rootTiles)||s.surface.updatingRootTiles||!s.shouldHaveNeighbor(o)),a;if(t.isLoaded){const r=t,i=r.renderData.geometryState,s=n-r.level;if(E(s>=0),0===s){const e=i.numVerticesPerSide-1;return Math.max(e,a)}const o=2**s,l=i.neighborData.edgeResolutions[(e+2)%4]/o;return Math.max(1,l)}E(!t.isLeaf);let l=a;return t.forAllSubtreeOnSide(T(o),(e=>e===s||(e.isLoaded?(l=Math.max(l,2**(e.level-n)),!0):(E(!e.isLeaf),!1)))),l}updateNeighborData(){const e=this.tile;if(!e.intersectsClippingArea)return;const r=e.renderData.geometryState.neighborData,i=t=>(t.isLoaded||t.level===e.level)&&t?.intersectsClippingArea,s=r.edgePeerNeighbors,a=r.edgePeerNeighborSamplerVersions;for(let o=0;o<4;++o){const n=e.findNeighborTile(b[o],i),l=z(e,n),h=l?.renderData?.geometryState.samplerDataVersion??-1,d=s[o],g=l!==z(e,d),c=a[o]!==h;s[o]=n,(g||c)&&(a[o]=h,this._markEdgeDirty(o));const u=r.edgeResolutions[o],m=this._calculateEdgeResolution(o,n);E(t(m)),E(m>=1),r.edgeResolutions[o]=m,u!==m&&this._markEdgeResolutionDirty(o)}const n=r.cornerPeerNeighbors;for(let t=0;t<4;++t){const a=e.findNeighborTile(j[t],i);n[t]=a;const o=z(e,s[t]),l=z(e,s[(t+1)%4]),h=z(e,a);q[t]=h,q[(t+1)%4]=l,q[(t+2)%4]=e,q[(t+3)%4]=o,E(q.some((t=>t?.isLoaded||t===e)));const d=q.reduce(((e,t)=>Math.min(e,t?.level??1/0)),1/0);q.forEach(((e,t)=>{e?.level>d&&(q[t]=null)})),E(q.some((t=>t?.isLoaded||t===e)));const g=r.cornerNeighborData[t].cornerTiles,c=r.cornerNeighborData[t].cornerTileSamplerVersions;for(let e=0;e<4;++e){const r=q[e],i=r?.renderData.geometryState.samplerDataVersion??-1,s=g[e]!==r,a=!s&&c[e]!==i;(s||a)&&(g[e]=r,c[e]=i,this._markCornerDirty(t))}E(g.some((t=>t?.isLoaded||t===e)))}$&&E(this.geometryState.neighborData.edgeResolutions.every((e=>e>0)));for(let t=0;t<4;++t)q[t]=null}_updateGeometry(e){if(!this.tile.intersectsClippingArea)return;$&&E(!this.tile.intersectsClippingArea||this.geometryState.neighborData.edgeResolutions.every((e=>e>0))),this.intersectionData=null;const t=this.tile,r=this._vao,i=this.geometryInfo.vertexAttributes,s=!r||!i||this._wireframeChanged||this._shadingChanged||this._numVerticesPerSideChanged||this._samplerDataChanged||this._clippingAreaChanged||this._dirtyEdgeResolutions,a=!s&&(0!==this._dirtyEdges||0!==this._dirtyEdgeResolutions),n=!a&&0!==this._dirtyCorners;s?(this._releaseGeometry(),this._createGeometry(e)):a||n?t.updateEdgeElevations():n?t.updateCornerElevations():console.warn("Update for no reason?"),this._numVerticesPerSideChanged=!1,this._samplerDataChanged=!1,this._dirtyEdgeResolutions=0,this._dirtyEdges=0,this._dirtyCorners=0,this._clippingAreaChanged=!1,this._wireframeChanged=!1}releaseGeometry(){return this._releaseGeometry()}get hasGeometry(){return this._hasGeometry}ensureTexture(e,t){return r(this._texture)&&this._texture.descriptor.width!==e&&this.releaseTexture(),i(this._texture)&&(this._texture=t(),this.tile.setMemoryDirty()),this._texture}releaseTexture(){r(this._texture)&&(this._texture.release(),this._texture=null,this.tile.setMemoryDirty())}_markCornerDirty(e){const t=1<<e;this._dirtyCorners|=t}_markEdgeDirty(e){const t=1<<e;this._dirtyEdges|=t}_markEdgeResolutionDirty(e){const t=1<<e;this._dirtyEdgeResolutions|=t,this._dirtyEdges|=t}_markAllEdgesAndCornersDirty(){this._dirtyCorners=15,this._dirtyEdges=15,this._dirtyEdgeResolutions=15}updateGeometryState(){const t=this._getElevationInfo(),r=this.tile,i=t.samplerData?r.getElevationBasedVerticesPerSide(t.maxTileLevel):r.getDefaultVerticesPerRowOnLevel(),s=Math.max(i,5);let a=r.clippingArea;r.intersectsClippingArea&&!r.isWithinClippingArea||(a=null);const n=this.geometryState;let o=!1;n.numVerticesPerSide!==s&&(this._numVerticesPerSideChanged=!0,n.numVerticesPerSide=s,n.samplerDataVersion++,o=!0),t.changed&&(this._samplerDataChanged=!0,n.samplerData=t.samplerData,n.samplerDataVersion++,o=!0),e(n.clippingArea,a)||(this._clippingAreaChanged=!0,n.clippingArea=a,o=!0);const l=r.surface,h=l.wireframe;n.wireframe!==h&&(this._wireframeChanged=!0,n.wireframe=h,o=!0);const d=l.shading;return n.shading!==d&&(this._shadingChanged=d,n.shading=d,o=d),this._geometryStateChangedSinceLastUpdate||(this._geometryStateChangedSinceLastUpdate=o),o&&this._markAllEdgesAndCornersDirty(),this._hasGeometry=!0,this._geometryStateChangedSinceLastUpdate}_createGeometry(e){this.tile.createGeometry();const t=this.geometryInfo.vertexAttributes,r=this.geometryInfo.indices,i=e.gl;this._vao=new I(e,G,{geometry:_(t.layout)},{geometry:M.createVertex(e,i.STATIC_DRAW,t.buffer)},M.createIndex(e,i.STATIC_DRAW,r)),this._hasGeometry=!0}_releaseGeometry(){return this._hasGeometry=!1,this.intersectionData=null,!!this._vao&&(this._vao.dispose(),this._vao=null,S(this.geometryInfo),!0)}get vao(){return this._vao}setTextureReference(e,t=L.Immediate){r(e)&&e.texture!==this._texture&&this.releaseTexture(),this._textureRef.push(e,t)}get textureReference(){return this._textureRef.current}get nextTextureReference(){return this._textureRef.next}get textureFadeFactor(){return this._textureRef.fadeFactor}get textureIsFading(){return this._textureRef.isFading}_getElevationInfo(){const e=this.geometryState.samplerData,t=this.tile.layerInfo[v.ELEVATION],i=t.length;let s=new Array(i),a=0,n=0,o=!1;for(let l=0;l<i;l++){const i=t[l];if(r(i.upsampleInfo)){const t=i.upsampleInfo.tile,r=t.layerInfo[v.ELEVATION][l].data,h=r&&r.samplerData;e&&e[a]===h||(o=!0),s[a++]=h,n=Math.max(n,t.lij[0])}else if(i.data){const t=this.tile.surface.layerViewByIndex(l,v.ELEVATION);if(N(this.tile,t.layer,!1)){const t=i.data;e&&e[a]===t.samplerData||(o=!0),s[a++]=t.samplerData,n=this.tile.level}}}return r(e)&&e.length!==a&&(o=!0),a>0?s.length=a:s=null,{changed:o,samplerData:s,maxTileLevel:n}}get estimatedGeometryMemoryUsage(){const e=s(this.intersectionData,0,(e=>e.estimatedMemoryUsage));return(this.geometryInfo.indices?.byteLength??0)+(this.geometryInfo.vertexAttributes?.byteLength??0)+e}get textureDescriptor(){return r(this._texture)?this._texture.descriptor:null}get test(){return{hasTexture:null!=this._texture}}checkGeometryWaterproofness(){if(!$)return;const e=this.tile;if(E(e?.isLoaded),!e.isLoaded||!e.intersectsClippingArea)return;if(0===e.level)return;const s=e.surface.extent;if(r(s)&&!e.intersectsExtent(s))return;const p=b.map(((t,i)=>!!r(s)&&(i<2?-1:1)*(e.extent[3-i]-s[3-i])<0)),_=e.level;E(0===this._dirtyCorners),E(0===this._dirtyEdges),E(0===this._dirtyEdgeResolutions),E(!this._numVerticesPerSideChanged),E(!this._samplerDataChanged),E(!this._clippingAreaChanged),E(!this._wireframeChanged);const x=j.map((t=>e.findNeighborCornerTileExact(t,(t=>!t.intersectsClippingArea||t.isLoaded||t.level===e.level))??null)).map((e=>e?.intersectsClippingArea?e:null)),v=this.geometryState.neighborData;for(let t=0;t<4;++t){const r=v.cornerPeerNeighbors[t],i=x[t];E(i===r,`Tile[${e.lij}].corner[${t}] out of date: cur=[${r?.lij}] exp=[${i?.lij}]`)}b.forEach(((s,x)=>{if(p[x])return;const v=e.findNeighborTile(s,(e=>(e.level===_||e?.isLoaded)&&e?.intersectsClippingArea));if(!v){const t=!e.surface.updatingRootTiles&&r(e.surface.rootTiles)&&e.surface.rootTiles.length>0&&e.shouldHaveNeighbor(s);return void E(!t)}E(v.isLoaded||v.level===e.level),E(v===this.geometryState.neighborData.edgePeerNeighbors[x]);const C=_-v.level;if(!v.isLoaded)return E(!v.isLeaf),void E(0===C);E(w(e,v,s)),E(C>=0);const S=2**C;if(C<0)return void E(!1);const $=e.renderData.geometryInfo,b=$.outerEdges[x],T=$.numVerticesPerSide-1,j=v.renderData.geometryInfo;if(!j)return void E(!1);{const t=this.geometryState.neighborData.edgePeerNeighbors[x];(t?.isLoaded||t.isLoaded)&&(E(t==t),E(e.renderData.geometryState.neighborData.edgePeerNeighborSamplerVersions[x]===t.renderData.geometryState.samplerDataVersion),E(this.geometryState.neighborData.edgePeerNeighborSamplerVersions[x]===t.renderData.geometryState.samplerDataVersion))}const R=(x+2)%4,L=j.outerEdges[R],P=b.count-1,N=L.count-1;E(P*S===N,`Tile[${e.lij}]:e${x},res=${P} edgeRes mismatch with Neighbor[${v.lij}]:e${R},res=${N} (expected:${P*S})`);const I=e.extent,G=s===D.NORTH||s===D.SOUTH,M=L.count-1,O=M/2**C,q=b.count-1;if(O<1)return void E(1===q);E(O===q),E(t(O));const z=j.numVerticesPerSide-1;E(C>0||O===Math.max(z,T));const J=e.getNeighborEdgeStartVertexIndex(x,v);E(0<=J&&J<S);const K=J*O;E(0<=K&&K<=M-O);let Q=0,Y=K;b.getVertexPos(U,0),b.getVertexPos(k,b.count-1);const Z=a(U,k),ee=Math.max(W,1e-4*Z);for(let t=0;t<=O;++t){b.getVertexPos(U,Q),L.getVertexPos(k,Y);const a=t/O,p=G?I[0]+a*(I[2]-I[0]):s===D.WEST?I[0]:I[2],_=G?s===D.SOUTH?I[1]:I[3]:I[1]+a*(I[3]-I[1]),C=e.surface.extent;if(i(C)||f(C,p,_)){const t=n(U,k),i=o(U)-y.radius,s=o(k)-y.radius,a=t<ee;if(!a){console.warn(`Tile edge vertex position mismatch: between [${e.lij}].edge${x}[${Q}/${b.count}] and [${v.lij}].edge${R}[${Y}/${L.count}]`),r(C)&&console.warn("  surface extent= ",C," x,y=",p,",",_);const n=u();l(n,e.renderData.localOrigin,v.renderData.localOrigin),o(n)>0&&console.warn(`   localOrigins: ${e.renderData.localOrigin} vs ${v.renderData.localOrigin} d=${o(n)} [${n}]`);(()=>{const t=m(U),r=m(k);e.updateEdgeElevations(),v.updateEdgeElevations(),b.getVertexPos(U,Q),L.getVertexPos(k,Y);const i=u();g(i,U,t),o(i)>0&&console.warn(`  XXX Tile[${e.lij}] edge out of date: ${t} vs ${U} d=${o(i)} [${i}]`),g(i,k,r),o(i)>0&&console.warn(`  XXX Neighbor[${v.lij}] edge out of date: ${r} vs ${k} d=${o(i)} [${i}]`)})(),E(a,`Mismatch in tile [${e.lij}].edge[${x}][${Q}/${b.count}] vs neighbor [${v.lij}].edge[${R}][${Y}/${L.count}] ${A(U)} vs ${A(k)}  dist=${t} h(t|n|d)=${i}|${s}|${s-i}`)}if(e.surface.shading){b.getNormal(F,Q),L.getNormal(B,Y),h(X,F),h(H,B);const t=d(X,H),r=!1,i=1-t<.01||r||e===v;if(!i){const r=u();g(r,F,B);const s=()=>`Mismatch in tile edge normal ${V(e.lij)} (${Q}/${b.count-1}) edge ${x} vs neighbor ${V(v.lij)}  (${Y}/${L.count-1}) nedge ${R} :${A(F)} vs ${A(B)}  dot = ${t} : ${A(r)}`;console.warn("Mismatch in tile edge normal: ",s());{e.updateEdgeElevations(),v.updateEdgeElevations();const t=u(),r=u();b.getNormal(t,Q),L.getNormal(r,Y),c(F,t)||console.warn("Missing update in tile normal: ",A(F)," => ",A(t)),c(B,r)||console.warn("Missing update in neighbor normal: ",A(B)," => ",A(r))}E(i,s())}}}Q+=1,Y+=1}}))}}const U=u(),k=u(),F=u(),B=u(),X=u(),H=u(),W=1,q=[null,null,null,null];function z(e,t){return t?.isLoaded||t===e?t:null}export{O as PatchRenderData,z as neighborTileIfLoadedOrSelf};
