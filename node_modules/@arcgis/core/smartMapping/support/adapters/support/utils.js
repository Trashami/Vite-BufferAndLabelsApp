/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{throwIfAborted as e}from"../../../../core/promiseUtils.js";import"../../../../core/has.js";import n from"../../../../layers/support/CodedValueDomain.js";import"../../../../layers/support/Domain.js";import"../../../../layers/support/InheritedDomain.js";import"../../../../layers/support/RangeDomain.js";import t from"../../../../layers/support/Field.js";import{noDominantCategoryField as o}from"../../../statistics/support/predominanceUtils.js";import{isIntegerField as i,getDateDiffSQL as l,castIntegerFieldToFloat as r}from"../../utils.js";import{getEqualIntervalBins as a,processNullValue as s}from"../../../../statistics/utils.js";const u=/_value$/i,c=Math.LOG10E;function f(e){return e.map((e=>e.toJSON()))}function m(e,n){const t=[],o="featureReduction"in e.layer&&e.layer.featureReduction;if(!("binning"===o?.type)||!n)return t;const i="fields"in o?o.fields?.map((e=>e.name?.toLowerCase())).filter(Boolean):null;for(const l of n)i.includes(l.toLowerCase())||t.push(l);return t}function d(e,n,t){const o=[];if(n)for(const i of n){const n=e.getField(i);"availableFields"in t&&!t.availableFields.includes(n.name)&&o.push(n.name)}return o}function p(e,n){const t=e&&e.features,o=t&&t[0]&&t[0].attributes,i={};for(const l in o)i[l.replace(u,"").toLowerCase()]=o[l];return null!=i.totalcount&&i.totalcount>=i.count&&(i.nullcount=i.totalcount-i.count),delete i.totalcount,i.min===i.max&&null!=i.min&&null==i.stddev&&(i.stddev=i.variance=0),n&&(["min","max","avg","stddev","sum","variance"].forEach((e=>{null!=i[e]&&(i[e]=Math.ceil(i[e]))})),i.min===i.max&&null!=i.min&&(i.avg=i.min,i.stddev=i.variance=0)),i}function g(e){const n=[],t=e.classBreaks,o=t[0].minValue,i=t[t.length-1].maxValue;t.forEach((e=>{n.push([e.minValue,e.maxValue])}));const l={field:e.field,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,layer:e.layer};return{min:o,max:i,intervals:n,sqlExpr:y(l),excludeZerosExpr:e.where,normTotal:e.normalizationTotal}}function y(e){const{field:n,normalizationType:t,normalizationField:o,normalizationTotal:l,layer:a}=e,s=i(a,n);let u=n;return"percent-of-total"===t?u=`((${s?r(n):n} / ${l}) * 100)`:"log"===t?u=`(log(${n}) * ${c})`:"field"===t?u=`(${s?r(n):n} / ${o})`:"natural-log"===t?u=`(log(${s?r(n):n}))`:"square-root"===t&&(u=`(power(${s?r(n):n}, 0.5))`),u}function v(e,n){let t;if(n=n.toLowerCase(),e)for(const o in e)if(o.toLowerCase()!==n){t=e[o];break}return t}function h(e,n){let t;if(n=n.toLowerCase(),e)for(const o in e)if(o.toLowerCase()===n){t=e[o];break}return t}function w(e,n,t,o,i){const l={},r="countOFExpr";e&&e.features&&e.features.forEach((e=>{const n=e.attributes,t=v(n,r),o=h(n,r);0!==t&&(l[t]=o)}));const s=[];return a(n,t,o).forEach(((e,n)=>{const t=(n+1).toString();s.push({minValue:e[0],maxValue:e[1],count:l.hasOwnProperty(t)?l[t]:0})})),{bins:s,minValue:n,maxValue:t,normalizationTotal:i}}function x(n,t){const o=n&&n.features,{field:i,field2:l,field3:r,fieldDelimiter:a,layer:u,view:c,signal:f,labels:m}=t,d=`countOF${!(!i||!l)?"Expr":i||"Expr"}`,p={};let g=!1;if(o.forEach((e=>{const n=e.attributes,t=h(n,d);let o=i?h(n,i):v(n,d),u=l?h(n,l):null,c=r?h(n,r):null;null===o&&0===t&&(g=!0),(null==o||"string"==typeof o&&""===o.trim())&&(o=null),l&&(null==u||"string"==typeof u&&""===u.trim())&&(u=null),r&&(null==c||"string"==typeof c&&""===c.trim())&&(c=null);let f=o;l&&(f=`${s(f)}${a}${s(u)}`,r&&(f=`${f}${a}${s(c)}`)),null==p[f]?p[f]={count:t,data:f}:p[f].count=p[f].count+t})),i&&g){const n=i+" is NULL";return u.queryFeatureCount({whereClause:n,view:c,signal:f}).then((e=>(e=e||0,p.null.count=p.null.count+e,F(p,m)))).catch((()=>(e(f),F(p,m))))}return Promise.resolve(F(p,m))}function F(e,n){if(n)for(const t in e)e[t].label=n[t];return{count:e}}async function E(e,t,o){const i=e?o.getField(e):null,l=i?o.getFieldDomain(i.name):null;if(l)return l;const{uniqueValueInfos:r}=await o.uniqueValues({field:e,sqlWhere:t.sqlWhere,features:t.features,useFeaturesInView:t.useFeaturesInView,view:t.view,signal:t.signal}),a=r.map((e=>({code:e.value})));return new n({codedValues:a})}async function $(e,n){if(!e.returnAllCodedValues)return[];const{field:t,field2:o,field3:i}=e;if(t&&!o){const e=t?n.getField(t):null,o=e?n.getFieldDomain(e.name):null;return o?[o]:[]}const l=[];return t&&(l.push(E(t,e,n)),o&&(l.push(E(o,e,n)),i&&l.push(E(i,e,n)))),Promise.all(l)}function V(e,n){return l(e,new Date(0),n,"milliseconds").sqlExpression}function b(e){return{viewingMode:"2d"===e.type?"map":e.viewingMode,scale:e.scale,spatialReference:e.spatialReference?.toJSON()}}function C(e,n){const t=e.map((e=>e.value)),i=n.filter((e=>!t.includes(e)));for(const o of i)e.push({value:o,count:0});e.sort(((e,t)=>n.indexOf(e.value)-n.indexOf(t.value)));for(const l of e)l.value===o&&(l.value=null);return{predominantCategoryInfos:e}}function T(e){const n="featureReduction"in e&&e.featureReduction;return("fields"in n&&n.fields||[]).map((n=>{const o=z(n,e.fieldsIndex);return o?new t({type:o,name:n.name,alias:n.alias}):null})).filter(Boolean)}function z(e,n){switch(e.statisticType){case"avg":case"avg_angle":return"double";case"count":return"integer";case"min":case"max":case"sum":return e.onStatisticField?n.get(e.onStatisticField)?.type??null:e.onStatisticExpression?"string"===e.onStatisticExpression.returnType?null:"double":null;case"mode":return e.onStatisticField?n.get(e.onStatisticField)?.type??null:e.onStatisticExpression?"string"===e.onStatisticExpression.returnType?"string":"double":null;default:return null}}export{f as ensureFeaturesJSON,g as generateBinParams,z as getAggregateFieldType,$ as getDomainsForFields,T as getFeatureReductionFields,y as getFieldExpr,w as getHistogramFromFeatureSet,d as getMissingFields,m as getMissingFieldsForBinning,C as getPredominantCategoriesFromUVInfos,p as getSummaryStatisticsFromFeatureSet,x as getUniqueValuesFromFeatureSet,b as getViewInfoParams,V as msSinceUnixEpochSQL};
