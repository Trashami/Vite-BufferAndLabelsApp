/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import{pickRandom as t}from"../../../core/arrayUtils.js";import a from"../../../core/Error.js";import{unwrap as r}from"../../../core/maybe.js";import{throwIfAborted as i}from"../../../core/promiseUtils.js";import"../../../core/Logger.js";import"../../../core/accessorSupport/ensureType.js";import"../../../core/has.js";import{subclass as s}from"../../../core/accessorSupport/decorators/subclass.js";import{kebabDict as n}from"../../../layers/support/fieldType.js";import{isDateField as o}from"../../../layers/support/fieldUtils.js";import{getArcadeForPredominantCategory as l}from"../../statistics/support/predominanceUtils.js";import{summaryStatistics as u,uniqueValues as m,histogram as p,classBreaks as y}from"../../statistics/support/statsWorker.js";import{mergeWhereClauses as g}from"../../statistics/support/utils.js";import{WorkerClient as d}from"../../statistics/support/WorkerClient.js";import{getFieldsList as f,FIELD_DELIMITER as c}from"../utils.js";import h from"./FeatureLayerAdapter.js";import{getMissingFieldsForBinning as w,getFeatureReductionFields as F,getViewInfoParams as v,getDomainsForFields as S,getPredominantCategoriesFromUVInfos as q}from"./support/utils.js";let V=class extends h{constructor(e){super(e)}async _getNormalizationTotalFromMemory(e,t,r){const{featuresJSON:i,graphics:s,layerView:n,query:o}=t,l=(!i&&!s&&n&&"queryAggregateSummaryStatistics"in n?await n.queryAggregateSummaryStatistics(o,{field:e},{signal:r}):i?await this.workerClient.summaryStatistics({field:e},i):await u({attribute:{field:e},features:s})).sum;if(null==l)throw new a("feature-layer-binning-adapter:invalid","invalid normalizationTotal");return l}async _processStatsFromMemoryParams(e){const{features:t,filter:r}=e;if(t?.length)return this._getFilteredFeatures(t,r);const{view:i,field:s,field2:n,field3:o,normalizationField:l,valueExpression:u,returnGeometry:m,layerViewFunc:p,signal:y}=e;let g=null,d=null,c=null,h=null,v=null;if(i)try{if(g=await i.whenLayerView(this.layer),d=p in g&&"function"==typeof g[p],d){await this._waitForLayerViewUpdate(g);const e=await f({field:s,field2:n,field3:o,normalizationField:l,valueExpression:u});w(this,e).length?d=!1:(c="createAggregateQuery"in g&&g.createAggregateQuery(),c?(c.outFields=e,c.returnGeometry=!1,this._updateQueryWithFeatureFilter(c,r)):d=!1),g.suspended&&(d=!1)}}catch{d=!1}if(!d&&(v=F(this.layer).map((e=>e.toJSON())),h=await this._fetchFeaturesForStats({field:s,field2:n,field3:o,valueExpression:u,normalizationField:l,returnGeometry:m,filter:r,view:i,signal:y},"json"),!h?.length))throw new a("feature-layer-binning-adapter:insufficient-data","No features are available to calculate statistics");return{layerView:g,query:c,featuresJSON:h,fieldInfos:v}}async _summaryStatsFromMemory(e,t){const{view:a,field:r,valueExpression:i,normalizationType:s,signal:o}=e,l={field:r,valueExpression:i,normalizationType:s,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue},{featuresJSON:m,graphics:p,layerView:y,query:g,fieldInfos:d}=await this._processStatsFromMemoryParams({...e,layerViewFunc:"queryAggregateSummaryStatistics"});return i&&a&&(m||p)&&(l.fieldType=t?.type?n.toJSON(t.type):null,l.viewInfoParams=v(a),l.fieldInfos=d),"percent-of-total"===s&&null==e.normalizationTotal&&(l.normalizationTotal=await this._getNormalizationTotalFromMemory(r,{featuresJSON:m,graphics:p,layerView:y,query:g},o)),!m&&!p&&y&&"queryAggregateSummaryStatistics"in y?y.queryAggregateSummaryStatistics(g,l,{signal:o}):m?this.workerClient.summaryStatistics(l,m):u({attribute:l,features:p})}async _uvFromMemory(e,t){const{view:a,field:r,valueExpression:i,returnAllCodedValues:s,signal:n}=e,{featuresJSON:o,graphics:l,layerView:u,query:p,fieldInfos:y}=await this._processStatsFromMemoryParams({...e,layerViewFunc:"queryAggregateUniqueValues"}),g={field:r,field2:e.field2,field3:e.field3,fieldDelimiter:c,valueExpression:i,domains:t,returnAllCodedValues:s};return i&&a&&(o||l)&&(g.viewInfoParams=v(a),g.fieldInfos=y),!o&&!l&&u&&"queryAggregateUniqueValues"in u?u.queryAggregateUniqueValues(p,g,{signal:n}):o?this.workerClient.uniqueValues(g,o):m({attribute:g,features:l})}async _histogramFromMemory(e){const{view:t,field:a,valueExpression:r,signal:i}=e,{featuresJSON:s,graphics:n,layerView:o,query:l,fieldInfos:u}=await this._processStatsFromMemoryParams({...e,layerViewFunc:"queryAggregateHistogram"}),m={field:a,valueExpression:r,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,standardDeviationInterval:e.standardDeviationInterval,classificationMethod:e.classificationMethod,numBins:e.numBins};return r&&t&&(s||n)&&(m.viewInfoParams=v(t),m.fieldInfos=u),"percent-of-total"===e.normalizationType&&null==e.normalizationTotal&&(m.normalizationTotal=await this._getNormalizationTotalFromMemory(a,{featuresJSON:s,graphics:n,layerView:o,query:l},i)),!s&&!n&&o&&"queryAggregateHistogram"in o?o.queryAggregateHistogram(l,m,{signal:i}):s?this.workerClient.histogram(m,s):p({attribute:m,features:n})}async _classBreaksFromMemory(e){const{view:t,field:a,valueExpression:r,signal:i}=e,{featuresJSON:s,graphics:n,layerView:o,query:l,fieldInfos:u}=await this._processStatsFromMemoryParams({...e,layerViewFunc:"queryAggregateClassBreaks"}),m={field:a,valueExpression:r,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,standardDeviationInterval:e.standardDeviationInterval,classificationMethod:e.classificationMethod,numClasses:e.numClasses};return r&&t&&(s||n)&&(m.viewInfoParams=v(t),m.fieldInfos=u),"percent-of-total"===e.normalizationType&&null==e.normalizationTotal&&(m.normalizationTotal=await this._getNormalizationTotalFromMemory(a,{featuresJSON:s,graphics:n,layerView:o,query:l},i)),!s&&!n&&o&&"queryAggregateClassBreaks"in o?o.queryAggregateClassBreaks(l,m,{signal:i}):s?this.workerClient.classBreaks(m,s):y({attribute:m,features:n})}getField(e=""){return F(this.layer)?.find((t=>t.name.toLowerCase()===e?.toLowerCase()))}getFieldUsageInfo(e){return this.getField(e)?{supportsLabelingInfo:!0,supportsRenderer:!0,supportsPopupTemplate:!0,supportsLayerQuery:!1,supportsStatistics:!0}:null}getFieldDomain(e,t){return null}async summaryStatistics(e){const{field:t}=e,r=t?this.getField(t):null,i=o(r),s=e.sqlExpression&&!e.valueExpression&&!t;if(i||s)throw new a("feature-layer-binning-adapter:not-supported","Date field and sqlExpression are not supported");return this._summaryStatsFromMemory(e,r)}async uniqueValues(e){const t=await S(e,this);return this._uvFromMemory(e,t)}async histogram(e){const{field:t}=e,r=t?this.getField(t):null,i=o(r),s=e.sqlExpression&&!e.valueExpression&&!t;if(i||s)throw new a("feature-layer-binning-adapter:not-supported","Date field and sqlExpression are not supported");return this._histogramFromMemory(e)}async classBreaks(e){return(!1!==e.analyzeData?this._classBreaksFromMemory(e):this._classBreaksFromInterpolation(e)).catch((()=>(i(e.signal),this._classBreaksFromMemory(e))))}async queryFeatureCount(e){const t=await e.view.whenLayerView(this.layer);if(!("queryAggregateCount"in t)||!t.queryAggregateCount)throw new a("feature-layer-binning-adapter:not-supported","LayerView is not supported.");await this._waitForLayerViewUpdate(t);const r=t.createAggregateQuery();return r.where=g(r.where,e.whereClause),this._updateQueryWithFeatureFilter(r,e.filter),t.queryAggregateCount(r,{signal:e.signal})}generateRenderer(e,t){throw new a("feature-layer-binning-adapter:not-supported","'generateRenderer' is not supported.")}heatmapStatistics(e){throw new a("feature-layer-binning-adapter:not-supported","'heatmapStatistics' is not supported.")}async predominantCategories(e){const{fields:t,view:a,signal:r}=e,i=l(t),s=await this._uvFromMemory({valueExpression:i,view:a,signal:r});return q(s.uniqueValueInfos,t)}async getSampleFeatures(e,r){const{view:i,sampleSize:s,requiredFields:n,returnGeometry:o,filter:l,signal:u}=e;if(!i)throw new a("feature-layer-binning-adapter:not-supported","'view' is required to get sample features for binning.");if("3d"===i.type)throw new a("feature-layer-binning-adapter:not-supported","3d 'view' is not supported to get sample features for binning.");const m=await i.whenLayerView(this.layer);if(!("queryAggregateJSON"in m&&m.queryAggregateJSON&&"queryAggregates"in m&&m.queryAggregates))throw new a("feature-layer-binning-adapter:not-supported","LayerView is not supported.");await this._waitForLayerViewUpdate(m);if(w(this,n).length)throw new a("feature-layer-binning-adapter:insufficient-data","Layer does not have required fields");const p=1,y="json"===r,g=m.createAggregateQuery();g.outSpatialReference=e.spatialReference||i&&i.spatialReference,g.returnGeometry=!!o,g.outFields=n,this._updateQueryWithFeatureFilter(g,l);const{features:d}=y?await m.queryAggregateJSON(g,{signal:u}):await m.queryAggregates(g,{signal:u});return d.length&&s>0&&s<=d.length?t(d,s,p):d}load(e){const t=this.layer.load(e).then((async t=>{if(this.geometryType="polygon",this.objectIdField=null,this.supportsSQLExpression=!1,this._hasLocalSource=!1,this.hasQueryEngine=!0,this.minScale=t.minScale,this.maxScale=t.maxScale,this.fullExtent=t.fullExtent,"geometryType"in t&&"point"!==t.geometryType)throw new a("feature-layer-binning-adapter:invalid-parameters","Only 'point' geometry type is supported");const i="featureReduction"in t&&t.featureReduction;if("binning"!==i?.type&&"cluster"!==i?.type)throw new a("feature-layer-binning-adapter:invalid-parameters",`Feature reduction type ${i?.type} is not supported`);this.workerClient=d.getInstance(),await this.workerClient.open(r(r(e).signal))}));return this.addResolvingPromise(t),Promise.resolve(this)}};V=e([s("esri.smartMapping.support.adapters.FeatureLayerBinningAdapter")],V);const z=V;export{z as default};
