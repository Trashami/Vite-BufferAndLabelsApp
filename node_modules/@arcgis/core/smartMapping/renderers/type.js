/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import"../../renderers/PointCloudClassBreaksRenderer.js";import"../../renderers/PointCloudRenderer.js";import"../../renderers/PointCloudRGBRenderer.js";import"../../renderers/PointCloudStretchRenderer.js";import e from"../../renderers/PointCloudUniqueValueRenderer.js";import"../../renderers/ClassBreaksRenderer.js";import"../../renderers/DictionaryRenderer.js";import"../../renderers/DotDensityRenderer.js";import"../../renderers/HeatmapRenderer.js";import"../../renderers/PieChartRenderer.js";import"../../renderers/Renderer.js";import"../../renderers/SimpleRenderer.js";import r from"../../renderers/UniqueValueRenderer.js";import"../../renderers/support/jsonUtils.js";import i from"../../core/Error.js";import{clone as l}from"../../core/lang.js";import{isSome as s}from"../../core/maybe.js";import{fetchMessageBundle as n}from"../../intl/messages.js";import{LegendOptions as o}from"../../renderers/support/LegendOptions.js";import{createUniqueValueLabel as t,calculateDateFormatInterval as a}from"../../renderers/support/utils.js";import u from"../heuristics/outline.js";import p from"../heuristics/sizeRange.js";import{getPointSizeAlgorithm as d,verifyBasicFieldValidity as m,isValidPointSize as c,createColors as y,getSymbolSizeFromScheme as f,getSymbolOutlineFromScheme as b,createSymbol as h,getBasemapInfo as v}from"./support/utils.js";import g from"../statistics/uniqueValues.js";import{verifyBinningParams as w}from"../support/binningUtils.js";import{getFieldsList as T,FIELD_DELIMITER as j}from"../support/utils.js";import{binningCapableLayerTypes as E,featureCapableLayerTypes as x,createLayerAdapter as I,getLayerTypeLabels as V,LayerType as z}from"../support/adapters/support/layerUtils.js";import{cloneScheme as M,getSchemes as S}from"../symbology/type.js";const C="date";function R(e){if(e.name?.toLowerCase()?.includes(":insufficient-info"))return null;throw e}async function q(e){if(!e||!e.layer||!e.field&&!e.valueExpression)throw new i("type-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(e.valueExpression&&!e.view)throw new i("type-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&w(e,"type-renderer");const r={...e};r.symbolType=r.symbolType||"2d",r.numTypes=null==r.numTypes?10:r.numTypes,r.defaultSymbolEnabled=null==r.defaultSymbolEnabled||r.defaultSymbolEnabled,r.sortBy=null==r.sortBy?"count":r.sortBy,r.sortEnabled=null==r.sortEnabled||r.sortEnabled,r.statistics=l(r.statistics);const n=e.forBinning?E:x,o=I(r.layer,n,e.forBinning);if(r.layer=o,!o)throw new i("type-renderer:invalid-parameters","'layer' must be one of these types: "+V(n).join(", "));const t=s(r.signal)?{signal:r.signal}:null;await o.load(t);const a=o.geometryType;if(r.outlineOptimizationEnabled="polygon"===a&&r.outlineOptimizationEnabled,r.sizeOptimizationEnabled=("point"===a||"multipoint"===a||"polyline"===a)&&r.sizeOptimizationEnabled,"mesh"===a)r.symbolType="3d-volumetric",r.colorMixMode=r.colorMixMode||"replace",r.edgesType=r.edgesType||"none";else{if("3d-volumetric-uniform"===r.symbolType&&"point"!==a)throw new i("type-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(r.symbolType.includes("3d-volumetric")&&(!r.view||"3d"!==r.view.type))throw new i("type-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const u=await T({field:r.field,field2:r.field2,field3:r.field3,valueExpression:r.valueExpression}),p=m(o,u,"type-renderer:invalid-parameters");if(p)throw p;return r}async function B(e){if(!(e&&e.layer&&e.field))throw new i("type-point-cloud-class-renderer:missing-parameters","'layer' and 'field' parameters are required");const r={...e};r.statistics=l(r.statistics);const n=[z.PointCloudLayer],o=I(r.layer,n);if(r.layer=o,r.density=r.density||25,r.size=r.size||"100%",!c(r.size))throw new i("type-point-cloud-class-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'");if(!o)throw new i("type-point-cloud-class-renderer:invalid-parameters","'layer' must be one of these types: "+V(n).join(", "));const t=s(r.signal)?{signal:r.signal}:null;await o.load(t);const a=await T({field:r.field}),u=m(o,a,"type-point-cloud-class-renderer:invalid-parameters");if(u)throw u;return r}async function O(e){let r=e.typeScheme,i=null,l=null;const n=await v(e.basemap,e.view);if(i=s(n.basemapId)?n.basemapId:null,l=s(n.basemapTheme)?n.basemapTheme:null,r)return{scheme:M(r),basemapId:i,basemapTheme:l};const o=S({basemap:i,basemapTheme:l,geometryType:e.geometryType,theme:e.theme,worldScale:e.worldScale,view:e.view});return o&&(r=o.primaryScheme,i=o.basemapId,l=o.basemapTheme),{scheme:r,basemapId:i,basemapTheme:l}}function P(e,r){let i;return i=e.label<r.label?-1:e.label>r.label?1:0,i}function U(e,r){let i;return i=e.value<r.value?-1:e.value>r.value?1:0,i}function D(e,r){let i=r.count-e.count;return 0===i&&(i=P(e,r)),i}function L(e,r){let i=r.count-e.count;return 0===i&&(i=U(e,r)),i}function A(e,r,i){let l;"count"===r?(l=L,i&&i.codedValues&&(l=D)):"value"===r&&(l=U,i&&i.codedValues&&(l=P)),l&&e.sort(l)}async function F(e,i,l,s){const u=await n("esri/smartMapping/t9n/smartMapping"),{field:p,field2:d,field3:m}=i,c=e.uniqueValueInfos,v=i.layer,g=p?v.getField(p):null,w=g?v.getFieldDomain(g.name):null,T=-1===i.numTypes?c.length:i.numTypes,E=v.geometryType,x=await O({basemap:i.basemap,geometryType:E,typeScheme:i.typeScheme,worldScale:i.symbolType.includes("3d-volumetric"),view:i.view}),I=x.scheme,V=new r({field:p,field2:d,field3:m,fieldDelimiter:p&&d?j:null}),z=[],S=[],R={value:null,domain:w,fieldInfo:g};c.forEach(((e,r)=>{R.value=e.value,e.label=t(R);const i=e.value;(null===i||"string"==typeof i&&i.toLowerCase().includes("<null>"))&&z.unshift(r)}));for(const r of z)S.unshift(c.splice(r,1)[0]);if(!1!==i.sortEnabled&&A(c,i.sortBy,w),g&&g.type===C){const e=c.filter(((e,r)=>r<T)).map((e=>e.value));R.dateFormatInterval=a(e)}const q=l&&l.opacity;let B=y(I.colors,c.length);const P=f(I,E),U=b(I,E,q);c.forEach(((e,r)=>{R.value=e.value,e.label=t(R),e.symbol=h(E,{type:i.symbolType,color:B[r],size:P,outline:U,meshInfo:{colorMixMode:i.colorMixMode,edgesType:i.edgesType}})})),i.valueExpression&&(V.valueExpression=i.valueExpression,V.valueExpressionTitle=i.valueExpressionTitle),i.legendOptions&&(V.legendOptions=new o(i.legendOptions)),B=y(I.colors,T);for(let r=0;r<T;r++){const e=c[r];e&&V.addUniqueValueInfo({value:e.value,label:e.label,symbol:h(E,{type:i.symbolType,color:B[r],size:P,outline:U,meshInfo:{colorMixMode:i.colorMixMode,edgesType:i.edgesType}})})}i.defaultSymbolEnabled&&(V.defaultSymbol=h(E,{type:i.symbolType,color:I.noDataColor,size:P,outline:U,meshInfo:{colorMixMode:i.colorMixMode,edgesType:i.edgesType}}),V.defaultLabel=u.other);for(const r of S)r.symbol=h(E,{type:i.symbolType,color:I.noDataColor,size:P,outline:U,meshInfo:{colorMixMode:i.colorMixMode,edgesType:i.edgesType}}),c.push(r);const D=[],L=V.uniqueValueInfos.length===c.length?-1:V.uniqueValueInfos.length;if(L>-1)for(let r=L;r<c.length;r++)D.push({...c[r]});return l&&l.visualVariables&&l.visualVariables.length&&(V.visualVariables=l.visualVariables.map((e=>e.clone()))),s&&s.minSize&&(V.visualVariables?V.visualVariables.push(s.minSize):V.visualVariables=[s.minSize]),{renderer:V,uniqueValueInfos:c,excludedUniqueValueInfos:D,typeScheme:M(I),basemapId:x.basemapId,basemapTheme:x.basemapTheme}}async function k(e,r){const i=e.uniqueValueInfos,l=await O({basemap:"gray",theme:"point-cloud-class",geometryType:"point",typeScheme:r}),s=l&&l.scheme,n="point-cloud-class"===s.theme,o=n?s.colors:y(s.colors,i.length);return A(i,"value"),i.map(((e,r)=>{const i=e.value;let l=null;return n?(l=o[i],l||(l=o[o.length-1])):l=o[r],{values:[i],color:l,label:e.label}}))}async function G(e){const r=await q(e),{layer:i,view:l,signal:s}=r,n={layer:i,field:r.field,field2:r.field2,field3:r.field3,valueExpression:r.valueExpression,returnAllCodedValues:r.returnAllCodedValues,view:l,signal:s},[o,t,a]=await Promise.all([null!=r.statistics?r.statistics:g(n),r.outlineOptimizationEnabled?u({layer:i,view:l,signal:s}).catch(R):null,r.sizeOptimizationEnabled?p({layer:i,view:l,signal:s}).catch(R):null]);return F(o,r,t,a)}async function H(r){const i=await B(r),l=null!=i.statistics?i.statistics:await g({layer:i.layer,field:i.field,signal:i.signal});return{renderer:new e({field:i.field,pointsPerInch:i.density,pointSizeAlgorithm:d(i.size),colorUniqueValueInfos:await k(l,i.typeScheme)})}}export{H as createPCClassRenderer,G as createRenderer};
