/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import"../../renderers/PointCloudClassBreaksRenderer.js";import"../../renderers/PointCloudRenderer.js";import e from"../../renderers/PointCloudRGBRenderer.js";import o from"../../renderers/PointCloudStretchRenderer.js";import"../../renderers/PointCloudUniqueValueRenderer.js";import i from"../../renderers/ClassBreaksRenderer.js";import"../../renderers/DictionaryRenderer.js";import"../../renderers/DotDensityRenderer.js";import"../../renderers/HeatmapRenderer.js";import"../../renderers/PieChartRenderer.js";import"../../renderers/Renderer.js";import"../../renderers/SimpleRenderer.js";import"../../renderers/UniqueValueRenderer.js";import"../../renderers/support/jsonUtils.js";import r from"../../core/Error.js";import{isSome as a}from"../../core/maybe.js";import{fetchMessageBundle as n}from"../../intl/messages.js";import{substitute as l}from"../../intl/substitute.js";import s from"../../renderers/support/AuthoringInfo.js";import t from"../../renderers/support/AuthoringInfoVisualVariable.js";import{createColorStops as m,setLabelsForClassBreaks as d}from"../../renderers/support/utils.js";import u from"../../renderers/visualVariables/ColorVariable.js";import p from"../heuristics/ageUnit.js";import c from"../heuristics/outline.js";import y from"../heuristics/sizeRange.js";import{getSummaryStatistics as f,getClassBreaks as b,getPointSizeAlgorithm as h,formatDate as v,updateAgeRendererAuthoringInfoVV as w,createError as g,verifyBasicFieldValidity as T,isValidPointSize as x,createColors as E,getDefaultDataRange as V,createDefaultStopValues as z,createStopValues as S,getDataRange as M,createDataValues as j,createSymbol as I,getSymbolSizeFromScheme as q,getSymbolOutlineFromScheme as C,getBasemapInfo as O}from"./support/utils.js";import{getAgeExpressions as B,verifyDates as P,supportedAgeUnits as k}from"../statistics/support/ageUtils.js";import{verifyBinningParams as U}from"../support/binningUtils.js";import{getFieldsList as F,getNormalizationType as R}from"../support/utils.js";import{binningCapableLayerTypes as D,featureCapableLayerTypes as L,createLayerAdapter as A,getLayerTypeLabels as G,LayerType as W}from"../support/adapters/support/layerUtils.js";import{cloneScheme as $,getSchemes as H,getSchemeById as _}from"../symbology/color.js";const J="date",K="high-to-low",N=2**53-1,Q=5;async function X(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new r("color-visual-variable:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new r("color-visual-variable:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&U(e,"color-visual-variable");const o={...e};if("90-10"===o.theme)throw new r("color-visual-variable:not-supported","Only 'high-to-low', 'above-and-below', 'centered-on', 'extremes', 'above', 'below' themes are supported.");const i=e.forBinning?D:L,n=A(o.layer,i,e.forBinning);if(o.layer=n,!n)throw new r("color-visual-variable:invalid-parameters","'layer' must be one of these types: "+G(i).join(", "));const l=a(o.signal)?{signal:o.signal}:null;await n.load(l);if("mesh"!==n.geometryType&&o.worldScale&&(!o.view||"3d"!==o.view.type))throw g("color-visual-variable:invalid-parameters","'view' parameter should be an instance of SceneView when 'worldScale' parameter is true");const s=await F({field:o.field,normalizationField:o.normalizationField,valueExpression:o.valueExpression}),t=T(n,s,"color-visual-variable:invalid-parameters");if(t)throw t;return o}async function Y(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new r("color-continuous-renderer:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new r("color-continuous-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&U(e,"color-continuous-renderer");const o={...e};o.symbolType=o.symbolType||"2d",o.defaultSymbolEnabled=null==o.defaultSymbolEnabled||o.defaultSymbolEnabled;const i=e.forBinning?D:L,n=A(o.layer,i,e.forBinning);if(o.layer=n,!n)throw new r("color-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+G(i).join(", "));const l=a(o.signal)?{signal:o.signal}:null;await n.load(l);const s=n.geometryType;if(o.outlineOptimizationEnabled="polygon"===s&&o.outlineOptimizationEnabled,o.sizeOptimizationEnabled=("point"===s||"multipoint"===s||"polyline"===s)&&o.sizeOptimizationEnabled,"mesh"===s)o.symbolType="3d-volumetric",o.colorMixMode=o.colorMixMode||"replace",o.edgesType=o.edgesType||"none";else{if("3d-volumetric-uniform"===o.symbolType&&"point"!==s)throw new r("color-continuous-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(o.symbolType.includes("3d-volumetric")&&(!o.view||"3d"!==o.view.type))throw new r("color-continuous-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const t=await F({field:o.field,normalizationField:o.normalizationField,valueExpression:o.valueExpression}),m=T(n,t,"color-continuous-renderer:invalid-parameters");if(m)throw m;return o}async function Z(e){if(!e||!e.layer||!e.field&&!e.valueExpression)throw new r("color-class-breaks-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(e.valueExpression&&!e.view)throw new r("color-class-breaks-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&U(e,"color-class-breaks-renderer");const o={...e};o.symbolType=o.symbolType||"2d",o.defaultSymbolEnabled=null==o.defaultSymbolEnabled||o.defaultSymbolEnabled,o.classificationMethod=o.classificationMethod||"equal-interval",o.normalizationType=R(o);const i=e.forBinning?D:L,n=A(o.layer,i,e.forBinning);if(o.layer=n,!n)throw new r("color-class-breaks-renderer:invalid-parameters","'layer' must be one of these types: "+G(i).join(", "));if(!(null!=o.minValue&&null!=o.maxValue)&&(null!=o.minValue||null!=o.maxValue))throw new r("color-class-breaks-renderer:missing-parameters","Both 'minValue' and 'maxValue' are required when specifying custom data range");const l=a(o.signal)?{signal:o.signal}:null;await n.load(l);const s=n.geometryType;if(o.outlineOptimizationEnabled="polygon"===s&&o.outlineOptimizationEnabled,"mesh"===s)o.symbolType="3d-volumetric",o.colorMixMode=o.colorMixMode||"replace",o.edgesType=o.edgesType||"none";else{if("3d-volumetric-uniform"===o.symbolType&&"point"!==s)throw new r("color-continuous-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(o.symbolType.includes("3d-volumetric")&&(!o.view||"3d"!==o.view.type))throw new r("color-class-breaks-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const t=await F({field:o.field,normalizationField:o.normalizationField}),m=T(n,t,"color-class-breaks-renderer:invalid-parameters");if(m)throw m;return o}function ee(e){const o={...e};delete o.basemap,delete o.colorScheme,delete o.legendOptions,delete o.symbolType,delete o.defaultSymbolEnabled,delete o.colorMixMode,delete o.edgesType;const i=o;return i.analyzeData=!(null!=o.minValue&&null!=o.maxValue),i}function oe(e){if(!e||!e.layer)return Promise.reject(g("color-point-cloud-true-color-renderer:missing-parameters","'layer' parameter is required"));const o={...e},i=[W.PointCloudLayer],r=A(o.layer,i);if(o.layer=r,o.density=o.density||25,o.size=o.size||"100%",!x(o.size))return Promise.reject(g("color-point-cloud-true-color-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'"));if(!r)return Promise.reject(g("color-point-cloud-true-color-renderer:invalid-parameters","'layer' must be one of these types: "+G(i).join(", ")));const n=a(o.signal)?{signal:o.signal}:null;return r.load(n).then((()=>o))}function ie(e){if(!(e&&e.layer&&e.field))return Promise.reject(g("color-point-cloud-continuous-renderer:missing-parameters","'layer' and 'field' parameters are required"));const o=e.field.toLowerCase();if("intensity"!==o&&"elevation"!==o)return Promise.reject(g("color-point-cloud-continuous-renderer:invalid-parameters","'field' should be either 'intensity' or 'elevation'"));const i={...e},r=[W.PointCloudLayer],n=A(i.layer,r);if(i.layer=n,i.density=i.density||25,i.size=i.size||"100%",!x(i.size))return Promise.reject(g("color-point-cloud-continuous-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'"));if(!n)return Promise.reject(g("color-point-cloud-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+G(r).join(", ")));const l=a(i.signal)?{signal:i.signal}:null;return n.load(l).then((()=>i))}function re(e){const o={...e},i=o.symbolType.includes("3d-volumetric");delete o.symbolType,delete o.defaultSymbolEnabled,delete o.colorMixMode,delete o.edgesType;const r=o;return r.worldScale=i,r}async function ae(e){if(!(e&&e.layer&&e.view&&e.startTime&&e.endTime))throw new r("color-age-renderer:missing-parameters","'layer', 'view', startTime', 'endTime' parameters are required");const o={...e};o.symbolType=o.symbolType||"2d",o.defaultSymbolEnabled=null==o.defaultSymbolEnabled||o.defaultSymbolEnabled;const i=A(o.layer,L);if(o.layer=i,!i)throw new r("color-age-renderer:invalid-parameters","'layer' must be one of these types: "+G(L).join(", "));const n=a(o.signal)?{signal:o.signal}:null;await i.load(n);const l=i.geometryType;if(o.outlineOptimizationEnabled="polygon"===l&&o.outlineOptimizationEnabled,o.sizeOptimizationEnabled=("point"===l||"multipoint"===l||"polyline"===l)&&o.sizeOptimizationEnabled,"mesh"===l)o.symbolType="3d-volumetric",o.colorMixMode=o.colorMixMode||"replace",o.edgesType=o.edgesType||"none";else if("3d-volumetric-uniform"===o.symbolType&&"point"!==l)throw new r("color-continuous-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(o.symbolType.includes("3d-volumetric")&&(!o.view||"3d"!==o.view.type))throw new r("color-age-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'");const s=P(i,o.startTime,o.endTime,"color-age-renderer:invalid-parameters");if(s)throw s;if(o.unit&&!k.includes(o.unit))throw new r("color-age-renderer:invalid-unit",`Supported units are: ${k.join(", ")}`);return o}async function ne(e,o){let i=e.colorScheme,r=null,n=null;const l=await O(e.basemap,e.view);if(r=a(l.basemapId)?l.basemapId:null,n=a(l.basemapTheme)?l.basemapTheme:null,i)return{scheme:$(i),basemapId:r,basemapTheme:n};const s=o||e.theme||K,t=H({theme:s,basemap:r,basemapTheme:n,geometryType:e.geometryType,worldScale:e.worldScale,view:e.view});if(t)if(r=t.basemapId,n=t.basemapTheme,e.schemeId){const o=s+"/"+r+"/"+e.schemeId;i=_({id:o,geometryType:e.geometryType})}else i=t.primaryScheme;return{scheme:i,basemapId:r,basemapTheme:n}}async function le(e,o){const i=o.layer,r=await ne({basemap:o.basemap,colorScheme:o.colorScheme,geometryType:i.geometryType,schemeId:"elevation"===o.field.toLowerCase()?"point-cloud-elevation-scheme":"point-cloud-intensity-scheme"}),a=r.scheme;if(!a)throw g("color-point-cloud-continuous-renderer:insufficient-info","Unable to find color scheme");const n=E(a.colors,Q);if(n.length<Q)throw g("color-point-cloud-continuous-renderer:insufficient-info","Color scheme does not have enough colors");const l=V(e,!1,!0),s=l?z(l[0],l[1],5):S(e);return{stops:m({values:s,isDate:!1,dateFormatOptions:null,colors:n,labelIndexes:[0,2,4]}),basemapId:r.basemapId,basemapTheme:r.basemapTheme,statistics:e,defaultValuesUsed:!!l,colorScheme:$(a)}}async function se(e,o,i,r,a){const{field:n,theme:l}=e,m=await ne({basemap:e.basemap,theme:e.theme,geometryType:r,colorScheme:e.colorScheme,worldScale:e.worldScale,view:e.view}),d=m.scheme;if(!d)throw g("color-visual-variable:insufficient-info","Unable to find color scheme");const p=E(d.colors,Q);if(p.length<Q)throw g("color-visual-variable:insufficient-info","Color scheme does not have enough colors");const c=d.id.includes("seq-"),y=M(o,i,l,a,"90-10"!==l),f=j(y,o,l,c),b=E(p,Q),h=new u({field:n,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,normalizationField:e.normalizationField,stops:f.map(((e,o)=>({value:e,color:b[o]}))),legendOptions:e.legendOptions}),v=new t({type:"color",minSliderValue:null!=e.minValue?e.minValue:o.min,maxSliderValue:null!=e.maxValue?e.maxValue:o.max,theme:d.theme}),w=new s({visualVariables:[v]});return{basemapId:m.basemapId,basemapTheme:m.basemapTheme,visualVariable:h,statistics:o,defaultValuesUsed:y.defaultValuesUsed,colorScheme:$(d),authoringInfo:w}}async function te(e,o,r,a,l,s,t){const m=await n("esri/smartMapping/t9n/smartMapping"),{field:d,defaultSymbolEnabled:u}=t,p=$(e.colorScheme),c=o&&o.opacity,y=[e.visualVariable.clone()];o&&o.visualVariables&&o.visualVariables.length&&y.push(...o.visualVariables.map((e=>e.clone()))),r&&r.minSize&&y.push(r.minSize);return{renderer:new i({classBreakInfos:[{minValue:-N,maxValue:N,symbol:I(s,{type:t.symbolType,color:p.noDataColor,size:q(p,s),outline:C(p,s,c),meshInfo:{colorMixMode:t.colorMixMode,edgesType:t.edgesType}})}],defaultLabel:u?m.other:null,defaultSymbol:u?I(s,{type:t.symbolType,color:p.noDataColor,size:q(p,s),outline:C(p,s,c),meshInfo:{colorMixMode:t.colorMixMode,edgesType:t.edgesType}}):null,field:d,normalizationType:a,normalizationField:l,valueExpression:t.valueExpression,valueExpressionTitle:t.valueExpressionTitle,visualVariables:y,authoringInfo:e.authoringInfo&&e.authoringInfo.clone()}),visualVariable:e.visualVariable.clone(),statistics:e.statistics,defaultValuesUsed:e.defaultValuesUsed,colorScheme:$(e.colorScheme),basemapId:e.basemapId,basemapTheme:e.basemapTheme}}async function me(e){const o=await X(e),{view:i,field:r,valueExpression:a,minValue:n,maxValue:l,layer:s,normalizationField:t,signal:m,statistics:d}=o,u=t?"field":void 0,[p,c]=await Promise.all([d||f({layer:s,field:r,valueExpression:a,sqlExpression:o.sqlExpression,sqlWhere:o.sqlWhere,normalizationType:u,normalizationField:t,minValue:n,maxValue:l,view:i,signal:m}),"90-10"===o.theme?b({layer:s,field:r,normalizationField:t,valueExpression:a,classificationMethod:"quantile",minValue:n,maxValue:l,view:i,numClasses:10,signal:m}):null]),y=s,h=r&&"function"!=typeof r?y.getField(r):null,v=h&&h.type===J;return se(o,p,c?.result,y.geometryType,v)}function de(e,o){const i=e.colorsForClassBreaks;let r;if(i&&i.length>0&&(i.some((e=>(e.numClasses===o&&(r=e.colors),!!r))),!r)){const e=i[i.length-1],a=o-e.numClasses;if(a>0){const o=e.colors[e.numClasses-1];r=e.colors.splice(0);for(let e=1;e<=a;e++)r.push(o)}}return r&&(r=E(r,r.length)),r}async function ue(e,o){const a=await n("esri/smartMapping/t9n/smartMapping"),l=e.layer,t=e.defaultSymbolEnabled,m=l.geometryType,u=e.classificationMethod,p="standard-deviation"===u,c=await ne({basemap:e.basemap,geometryType:m,theme:p?"above-and-below":null,colorScheme:e.colorScheme,worldScale:e.symbolType.includes("3d-volumetric"),view:e.view}),y=c.scheme,{result:f,outlineResult:b}=o,h=f.classBreakInfos,v=e.normalizationType;if(!y)throw new r("color-class-breaks-renderer:insufficient-info","Unable to find color scheme");const w=de(y,h.length);if(!w||w.length!==h.length)throw new r("color-class-breaks-renderer:insufficient-info","Color scheme does not have enough colors");const g=b&&b.opacity,T=new i({classBreakInfos:h.map(((o,i)=>({minValue:o.minValue,maxValue:o.maxValue,symbol:I(m,{type:e.symbolType,color:w[i],size:q(y,m),outline:C(y,m,g),meshInfo:{colorMixMode:e.colorMixMode,edgesType:e.edgesType}}),label:o.label}))),defaultLabel:t?a.other:null,defaultSymbol:t?I(m,{type:e.symbolType,color:y.noDataColor,size:q(y,m),outline:C(y,m,g),meshInfo:{colorMixMode:e.colorMixMode,edgesType:e.edgesType}}):null,field:e.field,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,normalizationType:v,normalizationField:e.normalizationField,normalizationTotal:"percent-of-total"===v?f.normalizationTotal:void 0,legendOptions:e.legendOptions,authoringInfo:new s({type:"class-breaks-color",classificationMethod:u,standardDeviationInterval:e.standardDeviationInterval})});return p||d({classBreakInfos:T.classBreakInfos,classificationMethod:u,normalizationType:v,round:!0}),b&&b.visualVariables&&b.visualVariables.length&&(T.visualVariables=b.visualVariables.map((e=>e.clone()))),{renderer:T,colorScheme:$(y),classBreaksResult:f,defaultValuesUsed:o.defaultValuesUsed,basemapId:c.basemapId,basemapTheme:c.basemapTheme}}async function pe(e){const o=await Y(e),{layer:i,view:r,signal:a}=o,[n,l,s]=await Promise.all([me(re(o)),o.outlineOptimizationEnabled?c({layer:i,view:r,signal:a}):null,o.sizeOptimizationEnabled?y({layer:i,view:r,signal:a}):null]),t=o.normalizationField;return te(n,l,s,t?"field":void 0,t,i.geometryType,o)}async function ce(e){const o=await Z(e);return ue(o,await b(ee(o),o.outlineOptimizationEnabled))}function ye(o){return oe(o).then((o=>({renderer:new e({field:"RGB",pointsPerInch:o.density,pointSizeAlgorithm:h(o.size)})})))}async function fe(e){const i=await ie(e),r=i.statistics?i.statistics:await f({layer:i.layer,field:i.field,signal:i.signal}),a=await le(r,i);return{renderer:new o({field:i.field,pointsPerInch:i.density,pointSizeAlgorithm:h(i.size),stops:a.stops}),basemapId:a.basemapId,basemapTheme:a.basemapTheme,statistics:a.statistics,defaultValuesUsed:a.defaultValuesUsed,colorScheme:a.colorScheme}}async function be(e){const o=await n("esri/smartMapping/t9n/smartMapping"),i=await ae(e),{defaultSymbolEnabled:r,view:a,startTime:s,endTime:t,symbolType:m,colorMixMode:d,edgesType:u,minValue:f,maxValue:b,signal:h}=i,g=i.layer,[T,x,E]=await Promise.all([i.unit?{unit:i.unit,statistics:null}:p({view:a,layer:g,startTime:s,endTime:t,minValue:f,maxValue:b,signal:h}),i.outlineOptimizationEnabled?c({layer:g,view:a,signal:h}):null,i.sizeOptimizationEnabled?y({layer:g,view:a,signal:h}):null]),{unit:V,statistics:z}=T,S=B({layer:g,startTime:s,endTime:t,unit:V}).valueExpression,M=l(o[`ageInfo_${V}`],{unit:V,startTime:v(s,V,g),endTime:v(t,V,g)}),j=await me(re({layer:g,basemap:i.basemap,valueExpression:S,symbolType:m,statistics:z,legendOptions:{title:M},colorScheme:i.colorScheme,theme:i.theme,view:a,minValue:i.minValue,maxValue:i.maxValue,signal:h})),I={layer:g,valueExpression:S,defaultSymbolEnabled:r,symbolType:m,colorMixMode:d,edgesType:u},q=await te(j,x,E,null,null,g.geometryType,I);return q.renderer.authoringInfo.visualVariables.forEach((e=>w(e,s,t,V))),{...q,unit:V}}export{be as createAgeRenderer,ce as createClassBreaksRenderer,pe as createContinuousRenderer,fe as createPCContinuousRenderer,ye as createPCTrueColorRenderer,me as createVisualVariable};
