/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import"../../renderers/ClassBreaksRenderer.js";import"../../renderers/DictionaryRenderer.js";import e from"../../renderers/DotDensityRenderer.js";import"../../renderers/HeatmapRenderer.js";import"../../renderers/PieChartRenderer.js";import"../../renderers/Renderer.js";import"../../renderers/SimpleRenderer.js";import"../../renderers/UniqueValueRenderer.js";import"../../renderers/support/jsonUtils.js";import t from"../../core/Error.js";import{isSome as r}from"../../core/maybe.js";import{getResolutionForScale as i}from"../../geometry/support/scaleUtils.js";import a from"../../renderers/support/AuthoringInfo.js";import s from"../heuristics/outline.js";import{roundValue as n}from"./support/dotDensityUtils.js";import{createColors as o,getSymbolOutlineFromScheme as l,verifyBasicFieldValidity as d,getBasemapInfo as m}from"./support/utils.js";import u from"../statistics/spatialStatistics.js";import p from"../statistics/summaryStatisticsForAttributes.js";import y from"../statistics/support/attributeDensity.js";import{verifyBinningParams as c}from"../support/binningUtils.js";import{getFieldsList as f}from"../support/utils.js";import{LayerType as b,binningCapableLayerTypes as g,createLayerAdapter as w,getLayerTypeLabels as v}from"../support/adapters/support/layerUtils.js";import{cloneScheme as h,getSchemes as S}from"../symbology/dotDensity.js";const j=500;async function V(e){if(!(e&&e.layer&&e.view&&e.attributes&&e.attributes.length))throw new t("dot-density-renderer:missing-parameters","'layer', 'view' and 'attributes' parameters are required");if(e.attributes.length>8)throw new t("dot-density-renderer:invalid-parameters","Dot density renderer does not support more than 8 attributes");e.forBinning&&c(e,"dot-density-renderer");const i={...e},a=[b.FeatureLayer,b.OGCFeatureLayer,b.GeoJSONLayer,b.WFSLayer],s=e.forBinning?g:a,n=w(i.layer,s,e.forBinning);if(i.layer=n,i.dotBlendingEnabled=null==i.dotBlendingEnabled||i.dotBlendingEnabled,i.dotValueOptimizationEnabled=null==i.dotValueOptimizationEnabled||i.dotValueOptimizationEnabled,!n)throw new t("dot-density-renderer:invalid-parameters","'layer' must be one of these types: "+v(s).join(", "));const o=r(i.signal)?{signal:i.signal}:null;await Promise.all([i.view.when(),n.load(o)]);if("polygon"!==n.geometryType)throw new t("dot-density-renderer:not-supported","Dot density renderer is supported for polygon layers only");const l=[],m=i.attributes;for(const t of m){const e=await f({field:t.field,valueExpression:t.valueExpression});l.push(...e)}const u=d(n,l.filter(Boolean),"dot-density-renderer:invalid-parameters");if(u)throw u;return i}async function E(e){let t=e.dotDensityScheme,i=null,a=null;const s=await m(e.basemap,e.view);if(i=r(s.basemapId)?s.basemapId:null,a=r(s.basemapTheme)?s.basemapTheme:null,t)return{scheme:h(t),basemapId:i,basemapTheme:a};const n=S({basemap:i,numColors:e.attributes.length,basemapTheme:a});return n&&(t=n.primaryScheme,i=n.basemapId,a=n.basemapTheme),{scheme:t,basemapId:i,basemapTheme:a}}async function D(e){const{view:r,layer:a,attributes:s,signal:o}=e,l=await a.getSampleFeatures({view:r,sampleSize:j,returnGeometry:!0,signal:o}),[d,m]=await Promise.all([u({features:l,geometryType:a.geometryType}),p({layer:a,attributes:s,includeZeros:!1,includeNegatives:!1,view:r,signal:o})]),y="avgSize"in d&&d.avgSize,c=m.avg;if(!y)throw new t("dot-density-renderer:insufficient-info","Average polygon size is invalid");if(!c)throw new t("dot-density-renderer:insufficient-info","Average attribute value is invalid");const f=i(r.scale,r.spatialReference);return{dotValue:n(c/(y*y/(f*f)*.1))||1,referenceScale:r.scale,minSliderValue:1,maxSliderValue:n(c)}}async function x(e){const{view:r,layer:a,attributes:s,signal:o}=e,l=[];for(const t of s){const e=await f({field:t.field,valueExpression:t.valueExpression});l.push(...e)}const d=await a.getSampleFeatures({view:r,sampleSize:j,requiredFields:l,returnGeometry:!0,signal:o}),m=await y({features:d,attributes:s,includeZeros:!1,includeNegatives:!1,view:r});if(!m.avgDensity||!m.minDensity||!m.maxDensity)throw new t("dot-density-renderer:insufficient-info","Invalid density values");const u=i(r.scale,r.spatialReference),p=u*u,c=n(m.minDensity*p),b=n(m.maxDensity*p),g=10;let w=n(m.avgDensity*p*g)||1;return w>b&&(w=b),{dotValue:w,referenceScale:r.scale,minSliderValue:c,maxSliderValue:b}}async function T(r){const i=await V(r),n=i.layer,d=n.geometryType,m=await E(i),u=m&&m.scheme;if(!u)throw new t("dot-density-renderer:insufficient-info","Unable to find dot-density scheme");const p={layer:n,view:i.view,attributes:i.attributes,signal:i.signal},y={layer:i.layer,view:i.view,signal:i.signal},[c,f]=await Promise.all([i.trueDensity?x(p):D(p),i.outlineOptimizationEnabled?s(y):null]),{dotValue:b,referenceScale:g,minSliderValue:w,maxSliderValue:v}=c,h=o(u.colors,i.attributes.length),S=i.attributes.map(((e,t)=>({field:e.field,valueExpression:e.valueExpression,label:e.label,valueExpressionTitle:e.valueExpressionTitle,color:h[t]}))),j=new e({attributes:S,dotBlendingEnabled:i.dotBlendingEnabled,outline:f?l(u,d,f.opacity):null,dotValue:b,referenceScale:i.dotValueOptimizationEnabled?g:null,legendOptions:i.legendOptions});return f&&f.visualVariables&&f.visualVariables.length&&(j.visualVariables=f.visualVariables.map((e=>e.clone()))),j.authoringInfo=new a({type:"dot-density",minSliderValue:w,maxSliderValue:v}),{renderer:j,dotDensityScheme:u,basemapId:m.basemapId,basemapTheme:m.basemapTheme}}export{T as createRenderer};
