/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import"../../renderers/ClassBreaksRenderer.js";import"../../renderers/DictionaryRenderer.js";import"../../renderers/DotDensityRenderer.js";import"../../renderers/HeatmapRenderer.js";import"../../renderers/PieChartRenderer.js";import"../../renderers/Renderer.js";import e from"../../renderers/SimpleRenderer.js";import"../../renderers/UniqueValueRenderer.js";import"../../renderers/support/jsonUtils.js";import r from"../../core/Error.js";import{isSome as i}from"../../core/maybe.js";import o from"../heuristics/outline.js";import n from"../heuristics/sizeRange.js";import{createSymbol as a,getSymbolSizeFromScheme as s,getSymbolOutlineFromScheme as t,getBasemapInfo as l}from"./support/utils.js";import{verifyBinningParams as m}from"../support/binningUtils.js";import{binningCapableLayerTypes as p,featureCapableLayerTypes as d,createLayerAdapter as c,getLayerTypeLabels as u}from"../support/adapters/support/layerUtils.js";import{cloneScheme as y,getSchemes as b}from"../symbology/location.js";async function f(e){if(!e||!e.layer)throw new r("location-renderer:missing-parameters","'layer' parameter is required");e.forBinning&&m(e,"location-renderer");const o={...e};o.symbolType=o.symbolType||"2d";const n=e.forBinning?p:d,a=c(o.layer,n,e.forBinning);if(o.layer=a,!a)throw new r("location-renderer:invalid-parameters","'layer' must be one of these types: "+u(n).join(", "));const s=i(o.signal)?{signal:o.signal}:null;await a.load(s);const t=a.geometryType;if(o.outlineOptimizationEnabled="polygon"===t&&o.outlineOptimizationEnabled,o.sizeOptimizationEnabled=("point"===t||"multipoint"===t||"polyline"===t)&&o.sizeOptimizationEnabled,"mesh"===t)o.symbolType="3d-volumetric",o.colorMixMode=o.colorMixMode||"replace",o.edgesType=o.edgesType||"none";else{if("3d-volumetric-uniform"===o.symbolType&&"point"!==t)throw new r("location-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(o.symbolType.includes("3d-volumetric")&&(!o.view||"3d"!==o.view.type))throw new r("location-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}return o}async function h(e,r){let o=e.locationScheme,n=null,a=null;const s=await l(e.basemap,e.view);if(n=i(s.basemapId)?s.basemapId:null,a=i(s.basemapTheme)?s.basemapTheme:null,o)return{scheme:y(o),basemapId:n,basemapTheme:a};const t=b({basemap:n,basemapTheme:a,geometryType:r,worldScale:e.symbolType.includes("3d-volumetric"),view:e.view});return t&&(o=t.primaryScheme,n=t.basemapId,a=t.basemapTheme),{scheme:o,basemapId:n,basemapTheme:a}}async function w(i){const l=await f(i),m=l.layer.geometryType,p=await h(l,m),d=p.scheme;if(!d)throw new r("location-renderer:insufficient-info","Unable to find location scheme");const{view:c,layer:u,signal:b}=l,[w,v]=await Promise.all([l.outlineOptimizationEnabled?o({view:c,layer:u,signal:b}):null,l.sizeOptimizationEnabled?n({view:c,layer:u,signal:b}):null]),T=w&&w.opacity,g=new e({symbol:a(m,{type:l.symbolType,color:d.color,size:s(d,m),outline:t(d,m,T),meshInfo:{colorMixMode:l.colorMixMode,edgesType:l.edgesType}})});return w&&w.visualVariables&&w.visualVariables.length&&(g.visualVariables=w.visualVariables.map((e=>e.clone()))),v&&v.minSize&&(g.visualVariables?g.visualVariables.push(v.minSize):g.visualVariables=[v.minSize]),{renderer:g,locationScheme:y(d),basemapId:p.basemapId,basemapTheme:p.basemapTheme}}export{w as createRenderer};
