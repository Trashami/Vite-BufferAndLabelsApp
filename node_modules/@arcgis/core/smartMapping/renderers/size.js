/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import e from"../../renderers/ClassBreaksRenderer.js";import"../../renderers/DictionaryRenderer.js";import"../../renderers/DotDensityRenderer.js";import"../../renderers/HeatmapRenderer.js";import"../../renderers/PieChartRenderer.js";import"../../renderers/Renderer.js";import"../../renderers/SimpleRenderer.js";import"../../renderers/UniqueValueRenderer.js";import"../../renderers/support/jsonUtils.js";import i from"../../core/Error.js";import{isSome as a}from"../../core/maybe.js";import{toPt as n}from"../../core/screenUtils.js";import{fetchMessageBundle as s}from"../../intl/messages.js";import{substitute as l}from"../../intl/substitute.js";import r from"../../renderers/support/AuthoringInfo.js";import o from"../../renderers/support/AuthoringInfoVisualVariable.js";import{setLabelsForClassBreaks as t}from"../../renderers/support/utils.js";import m from"../../renderers/visualVariables/SizeVariable.js";import{TransformationType as u}from"../../renderers/visualVariables/support/sizeVariableUtils.js";import p from"../heuristics/ageUnit.js";import d from"../heuristics/outline.js";import y from"../heuristics/sizeRange.js";import{getSummaryStatistics as c,getClassBreaks as b,formatDate as f,updateAgeRendererAuthoringInfoVV as w,verifyBasicFieldValidity as v,getDataRange as h,getSizeRangeForAxis as z,createSymbol as g,getSymbolOutlineFromScheme as T,getSymbolSizeFromScheme as x,getBasemapInfo as S}from"./support/utils.js";import{getAgeExpressions as E,verifyDates as V,supportedAgeUnits as j}from"../statistics/support/ageUtils.js";import{verifyBinningParams as k}from"../support/binningUtils.js";import{getFieldsList as I,getNormalizationType as q}from"../support/utils.js";import{binningCapableLayerTypes as O,featureCapableLayerTypes as F,createLayerAdapter as B,getLayerTypeLabels as U}from"../support/adapters/support/layerUtils.js";import{cloneScheme as D,getSchemes as M}from"../symbology/size.js";const R="date",C=2**53-1;async function A(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new i("size-visual-variable:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new i("size-visual-variable:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&k(e,"size-visual-variable");const n={...e};if("90-10"===n.theme)throw new i("size-visual-variable:not-supported","Only 'high-to-low', 'above', 'below' themes are supported.");const s=e.forBinning?O:F,l=B(n.layer,s,e.forBinning);if(n.layer=l,!l)throw new i("size-visual-variable:invalid-parameters","'layer' must be one of these types: "+U(s).join(", "));"height"===n.axis&&(n.sizeOptimizationEnabled=!1);const r=a(n.signal)?{signal:n.signal}:null;await l.load(r);const o=l.geometryType;if("mesh"===o)throw new i("size-visual-variable:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(n.worldScale){if("polyline"===o||"polygon"===o)throw new i("size-visual-variable:not-supported","'worldScale' sizing is not supported for polyline and polygon layers");if(!n.view||"3d"!==n.view.type)throw new i("size-visual-variable:invalid-parameters","'view' parameter should be an instance of SceneView when 'worldScale' parameter is true")}const t=await I({field:n.field,normalizationField:n.normalizationField,valueExpression:n.valueExpression}),m=v(l,t,"size-visual-variable:invalid-parameters");if(m)throw m;return n}async function P(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new i("size-continuous-renderer:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new i("size-continuous-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&k(e,"size-continuous-renderer");const n={...e};n.symbolType=n.symbolType||"2d",n.defaultSymbolEnabled=null==n.defaultSymbolEnabled||n.defaultSymbolEnabled;const s=e.forBinning?O:F,l=B(n.layer,s,e.forBinning);if(n.layer=l,!l)throw new i("size-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+U(s).join(", "));const r=a(n.signal)?{signal:n.signal}:null;await l.load(r);const o=l.geometryType,t=n.symbolType.includes("3d");if(n.outlineOptimizationEnabled="polygon"===o&&n.outlineOptimizationEnabled,"mesh"===o)throw new i("size-continuous-renderer:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(t&&("polyline"===o||"polygon"===o))throw new i("size-continuous-renderer:not-supported","3d symbols are not supported for polyline and polygon layers");if(n.symbolType.includes("3d-volumetric")&&(!n.view||"3d"!==n.view.type))throw new i("size-continuous-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or 3d-volumetric-uniform");const m=await I({field:n.field,normalizationField:n.normalizationField,valueExpression:n.valueExpression}),u=v(l,m,"size-continuous-renderer:invalid-parameters");if(u)throw u;return n}async function W(e){if(!e||!e.layer||!e.field&&!e.valueExpression)throw new i("size-class-breaks-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(e.valueExpression&&!e.view)throw new i("size-class-breaks-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&k(e,"size-class-breaks-renderer");const n={...e};n.symbolType=n.symbolType||"2d",n.defaultSymbolEnabled=null==n.defaultSymbolEnabled||n.defaultSymbolEnabled,n.classificationMethod=n.classificationMethod||"equal-interval",n.normalizationType=q(n);const s=e.forBinning?O:F,l=B(n.layer,s,e.forBinning);if(n.layer=l,!l)throw new i("size-class-breaks-renderer:invalid-parameters","'layer' must be one of these types: "+U(s).join(", "));if(!(null!=n.minValue&&null!=n.maxValue)&&(null!=n.minValue||null!=n.maxValue))throw new i("size-class-breaks-renderer:missing-parameters","Both 'minValue' and 'maxValue' are required when specifying custom data range");const r=a(n.signal)?{signal:n.signal}:null;await l.load(r);const o=l.geometryType,t=n.symbolType.includes("3d");if(n.outlineOptimizationEnabled="polygon"===o&&n.outlineOptimizationEnabled,"mesh"===o)throw new i("size-class-breaks-renderer:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(t&&("polyline"===o||"polygon"===o))throw new i("size-class-breaks-renderer:not-supported","3d symbols are not supported for polyline and polygon layers");if(n.symbolType.includes("3d-volumetric")&&(!n.view||"3d"!==n.view.type))throw new i("size-class-breaks-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or 3d-volumetric-uniform");const m=await I({field:n.field,normalizationField:n.normalizationField}),u=v(l,m,"size-class-breaks-renderer:invalid-parameters");if(u)throw u;return n}function L(e){const i={...e};delete i.basemap,delete i.sizeScheme,delete i.legendOptions,delete i.symbolType,delete i.defaultSymbolEnabled;const a=i;return a.analyzeData=!(null!=i.minValue&&null!=i.maxValue),a}function $(e){const i={...e},a=i.symbolType.includes("3d-volumetric"),n=i;return n.worldScale=a,a&&(n.axis="3d-volumetric-uniform"===i.symbolType?"all":"height"),delete i.symbolType,delete i.defaultSymbolEnabled,n}async function H(e){if(!(e&&e.layer&&e.view&&e.startTime&&e.endTime))throw new i("size-age-renderer:missing-parameters","'layer', 'view', 'startTime', 'endTime' parameters are required");const n={...e};n.symbolType=n.symbolType||"2d",n.defaultSymbolEnabled=null==n.defaultSymbolEnabled||n.defaultSymbolEnabled;const s=B(n.layer,F);if(n.layer=s,!s)throw new i("size-age-renderer:invalid-parameters","'layer' must be one of these types: "+U(F).join(", "));const l=a(n.signal)?{signal:n.signal}:null;await s.load(l);const r=s.geometryType,o=n.symbolType.includes("3d");if(n.outlineOptimizationEnabled="polygon"===r&&n.outlineOptimizationEnabled,"mesh"===r)throw new i("size-age-renderer:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(o&&("polyline"===r||"polygon"===r))throw new i("size-age-renderer:not-supported","3d symbols are not supported for polyline and polygon layers");if(n.symbolType.includes("3d-volumetric")&&(!n.view||"3d"!==n.view.type))throw new i("size-age-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or 3d-volumetric-uniform");const t=V(s,n.startTime,n.endTime,"size-age-renderer:invalid-parameters");if(t)throw t;if(n.unit&&!j.includes(n.unit))throw new i("size-age-renderer:invalid-unit",`Supported units are: ${j.join(", ")}`);return n}async function _(e){let i=e.sizeScheme,n=null,s=null;const l=await S(e.basemap,e.view);if(n=a(l.basemapId)?l.basemapId:null,s=a(l.basemapTheme)?l.basemapTheme:null,i)return{scheme:D(i),basemapId:n,basemapTheme:s};const r=M({basemap:n,basemapTheme:s,geometryType:e.geometryType,worldScale:e.worldScale,view:e.view});return r&&(i=r.primaryScheme,n=r.basemapId,s=r.basemapTheme),{scheme:i,basemapId:n,basemapTheme:s}}function G(e,i){let a;switch(i){case"point":case"multipoint":{const i=e;a=[i.minSize,i.maxSize];break}case"polyline":{const i=e;a=[i.minWidth,i.maxWidth];break}case"polygon":{const i=e;a=[i.marker.minSize,i.marker.maxSize];break}}return a}function J(e,i){e.transformationType===u.ClampedLinear&&"below"===i&&e.flipSizes()}async function K(e,a,n,s){const{theme:l,field:t,normalizationField:u,minValue:p,maxValue:d,axis:y}=e,c=e.layer,b=t&&!("function"==typeof t)?c.getField(t):null,f=b&&b.type===R,w=c.geometryType,v=await _({basemap:e.basemap,geometryType:w,sizeScheme:e.sizeScheme,worldScale:e.worldScale,view:e.view}),g=v.scheme;if(!g)throw new i("size-visual-variable:insufficient-info","Unable to find size scheme");const T=s&&[s.minSize,s.maxSize]||G(g,w),{minDataValue:x,maxDataValue:S,defaultValuesUsed:E}=h(a,n,l,f,"above"===l||"below"===l),V=[],j="height"===y,k=j?y:void 0,I=T[0];let q=T[1];if(j&&"number"==typeof I&&"number"==typeof q){const e=z({minSize:I,maxSize:q},k);V.push(new m({axis:"width-and-depth",minSize:e.minSize})),q=e.maxSize}const O=new m({field:t,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,valueUnit:"unknown",normalizationField:u,axis:k,minSize:I,maxSize:q,minDataValue:x,maxDataValue:S,legendOptions:e.legendOptions});J(O,l),V.unshift(O);const F=new o({type:"size",theme:l,minSliderValue:null!=p?p:a.min,maxSliderValue:null!=d?d:a.max}),B=new r({visualVariables:[F]});return{basemapId:v.basemapId,basemapTheme:v.basemapTheme,visualVariables:V,statistics:a,defaultValuesUsed:E,sizeScheme:D(g),authoringInfo:B}}async function N(i,a,n,l,r){const o=await s("esri/smartMapping/t9n/smartMapping"),t=r.layer,m=r.field,u=t.geometryType,p=r.defaultSymbolEnabled,d=D(i.sizeScheme),y="polygon"===u,c=y?d.marker:d,b=y?d.background:null,f=y?"point":u,w=a&&a.opacity,v=i.visualVariables.map((e=>e.clone()));a&&a.visualVariables&&a.visualVariables.length&&v.push(...a.visualVariables.map((e=>e.clone())));return{renderer:new e({backgroundFillSymbol:b&&g(u,{type:r.symbolType,color:b.color,outline:T(b,u,w)}),classBreakInfos:[{minValue:-C,maxValue:C,symbol:g(f,{type:r.symbolType,color:c.color,size:x(c,f),outline:T(c,f,w)})}],defaultLabel:p?o.other:null,defaultSymbol:p?g(f,{type:r.symbolType,color:c.noDataColor,size:x(c,f,!0),outline:T(c,f,w)}):null,field:m,normalizationField:l,normalizationType:n,valueExpression:r.valueExpression,valueExpressionTitle:r.valueExpressionTitle,visualVariables:v,authoringInfo:i.authoringInfo&&i.authoringInfo.clone()}),visualVariables:i.visualVariables.map((e=>e.clone())),statistics:i.statistics,defaultValuesUsed:i.defaultValuesUsed,sizeScheme:D(i.sizeScheme),basemapId:i.basemapId,basemapTheme:i.basemapTheme}}function Q(e,i){const a=n(e.minSize),s=(n(e.maxSize)-a)/(i>=4?i-1:i),l=[];for(let n=0;n<i;n++)l.push(a+s*n);return l}async function X(i,a){const n=await s("esri/smartMapping/t9n/smartMapping"),l=i.layer,o=i.defaultSymbolEnabled,m=l.geometryType,u="polygon"===m,p=i.symbolType.includes("3d-volumetric"),d=await _({basemap:i.basemap,geometryType:m,sizeScheme:i.sizeScheme,worldScale:p,view:i.view}),y=d.scheme,{result:c,outlineResult:b}=a,f=c.classBreakInfos,w=i.classificationMethod,v=i.normalizationType,h=u?y.marker:y,S=u?y.background:null,E=u?"point":m,V=G(h,E),j=p&&z({minSize:V[0],maxSize:V[1]},"height"),k=Q({minSize:V[0],maxSize:p?j.maxSize:V[1]},f.length),I=b&&b.opacity,q=new e({backgroundFillSymbol:S&&g(m,{type:i.symbolType,color:S.color,outline:T(S,m,I)}),classBreakInfos:f.map(((e,a)=>({minValue:e.minValue,maxValue:e.maxValue,symbol:g(E,{type:i.symbolType,color:h.color,size:k[a],widthAndDepth:j&&j.minSize,outline:T(h,E,I)}),label:e.label}))),defaultLabel:o?n.other:null,defaultSymbol:o?g(E,{type:i.symbolType,color:h.noDataColor,size:x(h,E,!0),widthAndDepth:j&&j.minSize,outline:T(h,E,I)}):null,field:i.field,valueExpression:i.valueExpression,valueExpressionTitle:i.valueExpressionTitle,normalizationType:v,normalizationField:i.normalizationField,normalizationTotal:"percent-of-total"===v?c.normalizationTotal:void 0,legendOptions:i.legendOptions,authoringInfo:new r({type:"class-breaks-size",classificationMethod:w,standardDeviationInterval:i.standardDeviationInterval})});return"standard-deviation"!==w&&t({classBreakInfos:q.classBreakInfos,classificationMethod:w,normalizationType:v,round:!0}),b&&b.visualVariables&&b.visualVariables.length&&(q.visualVariables=b.visualVariables.map((e=>e.clone()))),{renderer:q,sizeScheme:D(y),classBreaksResult:c,defaultValuesUsed:a.defaultValuesUsed,basemapId:d.basemapId,basemapTheme:d.basemapTheme}}async function Y(e){const i=await A(e),{view:a,field:n,valueExpression:s,minValue:l,maxValue:r,layer:o,normalizationField:t,signal:m,statistics:u}=i,p=t?"field":void 0,[d,f,w]=await Promise.all([u||c({layer:o,field:n,valueExpression:s,sqlExpression:i.sqlExpression,sqlWhere:i.sqlWhere,normalizationType:p,normalizationField:t,minValue:l,maxValue:r,view:a,signal:m}),"90-10"===i.theme?b({layer:o,field:n,normalizationField:t,valueExpression:s,classificationMethod:"quantile",minValue:l,maxValue:r,view:a,numClasses:10,signal:m}):null,i.sizeOptimizationEnabled?y({view:a,layer:o,signal:m}):null]);return K(i,d,f?.result,w)}async function Z(e){const i=await P(e),a={layer:i.layer,view:i.view,signal:i.signal},[n,s]=await Promise.all([Y($(i)),i.outlineOptimizationEnabled?d(a):null]),l=i.normalizationField;return N(n,s,l?"field":void 0,l,i)}async function ee(e){const i=await W(e);return X(i,await b(L(i),i.outlineOptimizationEnabled))}async function ie(e){const i=await H(e),{defaultSymbolEnabled:a,view:n,startTime:r,endTime:o,symbolType:t,minValue:m,maxValue:u,signal:y}=i,c=i.layer,b={layer:i.layer,view:i.view,signal:y},[v,h]=await Promise.all([i.unit?{unit:i.unit,statistics:null,valueExpression:null}:await p({view:n,layer:c,startTime:r,endTime:o,minValue:m,maxValue:u,signal:y}),i.outlineOptimizationEnabled?d(b):null]),{unit:z,statistics:g}=v,T=E({layer:c,startTime:r,endTime:o,unit:z}).valueExpression,x=await s("esri/smartMapping/t9n/smartMapping"),S=l(x[`ageInfo_${z}`],{unit:z,startTime:f(r,z,c),endTime:f(o,z,c)}),V=await Y($({layer:c,basemap:i.basemap,valueExpression:T,symbolType:t,statistics:g,legendOptions:{title:S},theme:i.theme,sizeScheme:i.sizeScheme,sizeOptimizationEnabled:i.sizeOptimizationEnabled,view:i.view,minValue:m,maxValue:u,signal:y})),j={layer:c,valueExpression:T,defaultSymbolEnabled:a,symbolType:t},k=await N(V,h,null,null,j);return k.renderer.authoringInfo.visualVariables.forEach((e=>w(e,r,o,z))),{...k,unit:z}}export{ie as createAgeRenderer,ee as createClassBreaksRenderer,Z as createContinuousRenderer,Y as createVisualVariables};
