/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import e from"../../core/Error.js";import{isSome as a}from"../../core/maybe.js";import{getScaleForResolution as t}from"../../geometry/support/scaleUtils.js";import n from"../statistics/spatialStatistics.js";import{verifyBinningParams as i}from"../support/binningUtils.js";import{binningCapableLayerTypes as s,featureCapableLayerTypes as r,createLayerAdapter as l,getLayerTypeLabels as o}from"../support/adapters/support/layerUtils.js";const c=500,p=1e8,m=1280,f=12,u=30,g=15;async function y(t){const{view:n,sampleSize:p}=t;if(!(t&&n&&t.layer))throw new e("scale-range:missing-parameters","'view' and 'layer' parameters are required");t.forBinning&&i(t,"scale-range");const{layer:m,...f}=t,u=t.forBinning?s:r,g=l(m,u,t.forBinning),y={layerAdapter:g,...f};if(y.sampleSize=p||c,!g)throw new e("scale-range:invalid-parameters","'layer' must be one of these types: "+o(u).join(", "));await n.when();const S=a(y.signal)?{signal:y.signal}:null;return await g.load(S),y}function S(e,a){const t=f,n=m/4,i=u,s=m/4,r=g,l=m/2;let o=null,c=null,p=null,y=null;switch(e){case"point":case"multipoint":{const e=a;o=e.avgMinDistance,c=t,p=e.minDistance,y=n;break}case"polyline":{const e=a;o=e.avgLength,c=i,p=e.minLength,y=s;break}case"polygon":{const e=a;o=e.avgSize,c=r,p=e.minSize,y=l;break}}return{resolutionForMinScale:o>0?o/c:null,resolutionForMaxScale:p>0?p/y:null}}function w(e,a,n){const i=S(e.geometryType,a);return{minScale:t(i.resolutionForMinScale,n.spatialReference),maxScale:t(i.resolutionForMaxScale,n.spatialReference)}}function h(e,a,t=!0){if(e.constraints&&"effectiveLODs"in e.constraints){const n=e.constraints.effectiveLODs,i=t?n:n.slice(0).reverse();let s=null;for(const e of i)if(!(t?e.scale>a:e.scale<a)){s=e;break}return s}}function v(a,t,n,i){const{view:s,snapToLOD:r,layerAdapter:l}=a;if(r){const e=h(s,t),a=h(s,n,!1);t=e?e.scale:t,n=a?a.scale:n}if(t<n)throw new e("scale-range:invalid","calculated minScale is less than maxScale.");return n>t/2&&(n=Math.floor(n/2)),t>p&&(t=0),"polygon"!==l.geometryType&&(n=0),{minScale:Math.ceil(t),maxScale:Math.floor(n),spatialStatistics:i}}async function d(a){const t=await y(a),{view:i,sampleSize:s,layerAdapter:r,signal:l}=t,o=await r.getSampleFeatures({view:i,sampleSize:s,returnGeometry:!0,signal:l});if(!o?.length)throw new e("scale-range:insufficient-info","No features are available to calculate statistics");const c=await n({features:o,geometryType:r.geometryType}),{minScale:p,maxScale:m}=w(r,c,i);return v(t,p,m,c)}export{d as default};
