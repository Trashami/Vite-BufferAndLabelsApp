/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import"../../../geometry.js";import e from"../../../core/Error.js";import{unwrap as t,isSome as n}from"../../../core/maybe.js";import{pt2px as r}from"../../../core/screenUtils.js";import i from"../../../geometry/SpatialReference.js";import{quantizePoint as o}from"../../../geometry/support/quantizationUtils.js";import{isWrappable as s,getInfo as l}from"../../../geometry/support/spatialReferenceUtils.js";import{isNumericField as a,numericTypes as u}from"../../../layers/support/fieldUtils.js";import{evaluateDensityKernel as f,createValueFunction as c}from"../../../renderers/support/heatmapUtils.js";import{processNullValue as m,getNormalizedValue as d}from"../../../statistics/utils.js";import{loadArcade as p}from"../../../support/arcadeOnDemand.js";import h from"../../../geometry/Point.js";let y=null;function $(e,t,n){return e.x<0?e.x+=t:e.x>n&&(e.x-=t),e}function I(e,n,r,i){const a=s(r)?l(r):null,u=a?Math.round((a.valid[1]-a.valid[0])/n.scale[0]):null;return e.map((e=>{const r=new h(t(e.geometry));return o(n,r,r,r.hasZ,r.hasM),e.geometry=a?$(r,u,i[0]):r,e}))}function g(e,t=18,n,i,o,s){const l=new Float64Array(o*s);t=Math.round(r(t));let a=Number.POSITIVE_INFINITY,u=Number.NEGATIVE_INFINITY,m=0,d=0,p=0,h=0;const y=c(i,n);for(const{geometry:r,attributes:c}of e){const{x:e,y:n}=r,i=Math.max(0,e-t),$=Math.max(0,n-t),I=Math.min(s,n+t),g=Math.min(o,e+t),j=+y(c);for(let r=$;r<I;r++)for(let s=i;s<g;s++){const i=r*o+s,c=f(s-e,r-n,t),y=l[i];m=l[i]+=c*j;const $=m-y;d+=$,p+=$*$,m<a&&(a=m),m>u&&(u=m),h++}}if(!h)return{mean:0,stddev:0,min:0,max:0,mid:0,count:0};const $=(u-a)/2;return{mean:d/h,stdDev:Math.sqrt((p-d*d/h)/h),min:a,max:u,mid:$,count:h}}async function j(e,t){if(!t)return[];const{field:n,field2:r,field3:o,fieldDelimiter:s}=e,l=e.valueExpression,a=e.normalizationType,u=e.normalizationField,f=e.normalizationTotal,c=[],h=e.viewInfoParams;let $=null,I=null;if(l){if(!y){const{arcadeUtils:e}=await p();y=e}$=y.createFunction(l),I=h&&y.getViewInfo({viewingMode:h.viewingMode,scale:h.scale,spatialReference:new i(h.spatialReference)})}const g=e.fieldInfos,j=!(t[0]&&"declaredClass"in t[0]&&"esri.Graphic"===t[0].declaredClass)&&g?{fields:g}:null;return t.forEach((e=>{const t=e.attributes;let i;if(l){const t=j?{...e,layer:j}:e,n=y.createExecContext(t,I);i=y.executeFunction($,n)}else t&&(i=t[n],r&&(i=`${m(i)}${s}${m(t[r])}`,o&&(i=`${i}${s}${m(t[o])}`)));if(a&&"number"==typeof i&&isFinite(i)){const e=t&&parseFloat(t[u]);i=d(i,a,e,f)}c.push(i)})),c}function x(e){const t=e.field,n=e.normalizationType,r=e.normalizationField;let i;return"field"===n?i="(NOT "+r+" = 0)":"log"!==n&&"natural-log"!==n&&"square-root"!==n||(i=`(${t} > 0)`),i}function F(t,n){return new e(t,n)}function b(e,t,n){const r=null!=t?e+" >= "+t:"",i=null!=n?e+" <= "+n:"";let o="";return o=r&&i?N(r,i):r||i,o?"("+o+")":""}function v(e,t,n,r){let i=null;return t?t.name!==e.objectIdField&&r.includes(t.type)||(i=F(n,"'field' should be one of these types: "+r.join(","))):i=F(n,"'field' is not defined in the layer schema"),i}function E(e,t,n){let r;return t?t.name!==e.objectIdField&&a(t)||(r=F(n,"'field' should be one of these numeric types: "+u.join(","))):r=F(n,"'field' is not defined in the layer schema"),r}function N(e,t){let r=n(e)?e:"";return n(t)&&t&&(r=r?"("+r+") AND ("+t+")":t),r}function w(e,t){if(e&&"intersects"!==e.spatialRelationship)return F(t,"Only 'intersects' spatialRelationship is supported for featureFilter")}function M(e,t,n){const r=U({layer:e,fields:t});if(r.length)return F(n,"Unknown fields: "+r.join(", ")+". You can only use fields defined in the layer schema");const i=T({layer:e,fields:t});return i.length?F(n,"Unsupported fields: "+i.join(", ")+". You can only use fields that can be fetched i.e. AdapterFieldUsageInfo.supportsStatistics must be true"):void 0}function U(e){const t=e.layer;return e.fields.filter((e=>!t.getField(e)))}function T(e){const t=e.layer;return e.fields.filter((e=>{const n=t.getFieldUsageInfo(e);return!n||!n.supportsStatistics}))}function z(e,t,n){const r=[],i=[],o=[],s=[],l=[];e.forEach(((e,t)=>{const a=e.field?"field":"expression",u=e.field||e.valueExpression;e.field?(l.push(u),i.push(`var ${a}${t} = Number($feature["${u}"]);`)):(r.push(`function getValueForExpr${t}() {\n  ${u} \n}`),i.push(`var ${a}${t} = Number(getValueForExpr${t}());`)),n||o.push(`${a}${t} = IIf(${a}${t} < 0, 0, ${a}${t});`),s.push(`${a}${t}`)}));let a="return sum;";const u=r.length?null:l.reduce(((e,t)=>`${e} + ${t}`));let f=null;t||n?t?n||(a="return IIf(sum >= 0, sum, null);",u&&(f=`(( ${u} ) >= 0)`)):(a="return IIf(sum != 0, sum, null);",u&&(f=`(( ${u} ) <> 0)`)):(a="return IIf(sum > 0, sum, null);",u&&(f=`(( ${u} ) > 0)`));return{valueExpression:[r.length?r.join("\n"):"",i.join("\n"),o.join("\n"),`var sum = ${s.join(" + ")};`,a].filter(Boolean).join("\n\n"),sqlExpression:u,sqlWhere:f}}export{g as calculateHeatmapStats,F as createError,j as getDataValues,b as getRangeExpr,x as getSQLFilterForNormalization,z as getSumOfAttributesExpr,N as mergeWhereClauses,I as quantizeFeatures,M as verifyBasicFieldValidity,v as verifyFieldType,w as verifyFilterValidty,E as verifyNumericField};
