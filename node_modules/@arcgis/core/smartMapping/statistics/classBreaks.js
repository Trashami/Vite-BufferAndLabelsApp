/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import a from"../../core/Error.js";import{isSome as e}from"../../core/maybe.js";import{verifyBasicFieldValidity as s,verifyNumericField as i,verifyFilterValidty as r}from"./support/utils.js";import{verifyBinningParams as n}from"../support/binningUtils.js";import{getNormalizationType as l,getFieldsList as t}from"../support/utils.js";import{binningCapableLayerTypes as o,featureCapableLayerTypes as m,createLayerAdapter as p,getLayerTypeLabels as u}from"../support/adapters/support/layerUtils.js";const f=5;async function d(d){if(!d||!d.layer||!d.field&&!d.valueExpression)throw new a("class-breaks:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(d.valueExpression&&!d.view)throw new a("class-breaks:missing-parameters","View is required when 'valueExpression' is specified");d.forBinning&&n(d,"class-breaks");const{layer:c,...w}=d,h=d.forBinning?o:m,y=p(c,h,d.forBinning),b={layerAdapter:y,...w};if(b.normalizationType=l(b),b.numClasses=b.numClasses||f,!y)throw new a("class-breaks:invalid-parameters","'layer' must be one of these types: "+u(h).join(", "));const v=e(b.signal)?{signal:b.signal}:null;await y.load(v);const z=b.field,k=b.minValue,g=b.maxValue,x=null!=k||null!=g,V=b.classificationMethod,E="percent-of-total"===b.normalizationType,T=!1!==b.analyzeData,q=z?y.getField(z):null,j=await t({field:b.field,normalizationField:b.normalizationField,valueExpression:b.valueExpression}),B=s(y,j,"class-breaks:invalid-parameters");if(B)throw B;if(q){const a=i(y,q,"class-breaks:invalid-parameters");if(a)throw a}if(b.valueExpression&&b.normalizationType)throw new a("class-breaks:invalid-parameters","Normalization is not allowed when 'valueExpression' is specified");if(x)if(T){if(E&&null==b.normalizationTotal)throw new a("class-breaks:missing-parameters","'normalizationTotal' is required when 'normalizationType' is 'precent-of-total' and 'minValue', 'maxValue' are specified")}else{if(null==k||null==g)throw new a("class-breaks:missing-parameters","Both 'minValue' and 'maxValue' are required when 'analyzeData' is false");if(k>=g)throw new a("class-breaks:invalid-parameters","'minValue' should be less than 'maxValue'");if(V&&"equal-interval"!==V)throw new a("class-breaks:invalid-parameters","'classificationMethod' other than 'equal-interval' is not allowed when 'analyzeData' is false");if(E&&null==b.normalizationTotal)throw new a("class-breaks:missing-parameters","'normalizationTotal' is required when 'normalizationType' is 'precent-of-total' and 'analyzeData' is false")}else if(!T)throw new a("class-breaks:missing-parameters","Both 'minValue' and 'maxValue' are required when 'analyzeData' is false");const D=r(b.filter,"class-breaks:invalid-parameters");if(D)throw D;return b}async function c(a){const{layerAdapter:e,...s}=await d(a);return e.classBreaks(s)}export{c as default};
