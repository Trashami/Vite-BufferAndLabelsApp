/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{_ as e}from"../chunks/tslib.es6.js";import t from"../core/Error.js";import{HandleOwnerMixin as r}from"../core/HandleOwner.js";import o from"../core/Loadable.js";import n from"../core/Logger.js";import{isNone as s,isSome as i}from"../core/maybe.js";import{EsriPromiseMixin as a}from"../core/Promise.js";import{whenOrAbort as l}from"../core/promiseUtils.js";import{watch as c}from"../core/reactiveUtils.js";import{property as p}from"../core/accessorSupport/decorators/property.js";import"../core/arrayUtils.js";import"../core/accessorSupport/ensureType.js";import{subclass as m}from"../core/accessorSupport/decorators/subclass.js";import{f as h,c as f}from"../chunks/vec3f64.js";import u from"./Extent.js";import d from"./Geometry.js";import g from"./Point.js";import x from"./Polygon.js";import{fromAxisAndAngle as y,compose as b,create as j}from"./support/axisAngleDegrees.js";import w from"./support/MeshComponent.js";import v from"./support/MeshTransform.js";import{MeshVertexAttributes as M}from"./support/MeshVertexAttributes.js";import{triangulate as P}from"./support/triangulationUtils.js";import{centerAt as L}from"./support/meshUtils/centerAt.js";import{loadExternal as R}from"./support/meshUtils/loadExternal.js";import{offset as C}from"./support/meshUtils/offset.js";import{convertUnitGeometry as A,createUnitSizeBox as z,extractSingleFaceOfBox as F,createUnitSizeSphere as O,createUnitSizeCylinder as U,convertPlaneSizeParameter as E,createUnitSizePlane as S}from"./support/meshUtils/primitives.js";import{rotate as T}from"./support/meshUtils/rotate.js";import{scale as _}from"./support/meshUtils/scale.js";var G;const I="esri.geometry.Mesh";let B=G=class extends(r(o.LoadableMixin(a(d)))){constructor(e){super(e),this.components=null,this.transform=null,this.external=null,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new M,this.type="mesh"}initialize(){(s(this.external)||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when((()=>{this.handles.add(c((()=>({vertexAttributes:this.vertexAttributes,components:this.components?.map((e=>e.clone()))})),(()=>this._set("external",null)),{once:!0,sync:!0}))}))}get hasExtent(){return!this.loaded&&i(this.external)&&i(this.external.extent)||this.loaded&&this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0)}get _boundingInfo(){const e=this.vertexAttributes.position,t=this.spatialReference;if(0===e.length||this.components&&0===this.components.length)return{extent:new u({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:t}),center:new g({x:0,y:0,z:0,spatialReference:t})};const r=i(this.transform)?this.transform.project(e,t):e;let o=1/0,n=1/0,s=1/0,a=-1/0,l=-1/0,c=-1/0,p=0,m=0,h=0;const f=r.length,d=1/(f/3);let x=0;for(;x<f;){const e=r[x++],t=r[x++],i=r[x++];o=Math.min(o,e),n=Math.min(n,t),s=Math.min(s,i),a=Math.max(a,e),l=Math.max(l,t),c=Math.max(c,i),p+=d*e,m+=d*t,h+=d*i}return{extent:new u({xmin:o,ymin:n,zmin:s,xmax:a,ymax:l,zmax:c,spatialReference:t}),center:new g({x:p,y:m,z:h,spatialReference:t})}}get anchor(){if(i(this.transform))return this.transform.getOriginPoint(this.spatialReference);const e=this._boundingInfo;return new g({x:e.center.x,y:e.center.y,z:e.extent.zmin,spatialReference:this.spatialReference})}get origin(){return i(this.transform)?this.transform.getOriginPoint(this.spatialReference):this._boundingInfo.center}get extent(){return!this.loaded&&i(this.external)&&i(this.external.extent)?this.external.extent.clone():this._boundingInfo.extent}addComponent(e){this.loaded?(this.components||(this.components=[]),this.components.push(w.from(e)),this.notifyChange("components")):n.getLogger(this.declaredClass).error("addComponent()","Mesh must be loaded before applying operations")}removeComponent(e){if(this.loaded){if(this.components){const t=this.components.indexOf(e);if(-1!==t)return this.components.splice(t,1),void this.notifyChange("components")}n.getLogger(this.declaredClass).error("removeComponent()","Provided component is not part of the list of components")}else n.getLogger(this.declaredClass).error("removeComponent()","Mesh must be loaded before applying operations")}rotate(e,t,r,o){return y(k.x,e,D),y(k.y,t,W),y(k.z,r,Z),b(D,W,D),b(D,Z,D),T(this,D,o),this}offset(e,t,r,o){return this.loaded?(H[0]=e,H[1]=t,H[2]=r,C(this,H,o),this):(n.getLogger(this.declaredClass).error("offset()","Mesh must be loaded before applying operations"),this)}scale(e,t){return this.loaded?(_(this,e,t),this):(n.getLogger(this.declaredClass).error("scale()","Mesh must be loaded before applying operations"),this)}centerAt(e,t){return this.loaded?(L(this,e,t),this):(n.getLogger(this.declaredClass).error("centerAt()","Mesh must be loaded before applying operations"),this)}load(e){return i(this.external)&&this.addResolvingPromise(R(this,this.external.source,e)),Promise.resolve(this)}updateExternalSource(e){this._set("external",e)}clone(){let e=null;if(this.components){const t=new Map,r=new Map;e=this.components.map((e=>e.cloneWithDeduplication(t,r)))}const t={components:e,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),transform:i(this.transform)?this.transform.clone():null,external:i(this.external)?{source:this.external.source,extent:i(this.external.extent)?this.external.extent.clone():null}:null};return new G(t)}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(e){const t=import("./support/meshUtils/exporters/gltf/gltfexport.js"),r=this.load(),o=await Promise.all([t,r]),{toBinaryGLTF:n}=o[0];return n(this,e)}static createBox(e,t){if(!(e instanceof g))return n.getLogger(I).error(".createBox()","expected location to be a Point instance"),null;const r=new G(A(z(),e,t));return t&&t.imageFace&&"all"!==t.imageFace?F(r,t.imageFace):r}static createSphere(e,t){return e instanceof g?new G(A(O(t&&t.densificationFactor||0),e,t)):(n.getLogger(I).error(".createSphere()","expected location to be a Point instance"),null)}static createCylinder(e,t){return e instanceof g?new G(A(U(t&&t.densificationFactor||0),e,t)):(n.getLogger(I).error(".createCylinder()","expected location to be a Point instance"),null)}static createPlane(e,t){if(!(e instanceof g))return n.getLogger(I).error(".createPlane()","expected location to be a Point instance"),null;const r=t?.facing??"up",o=E(r,t?.size);return new G(A(S(r),e,{...t,size:o}))}static createFromPolygon(e,t){if(!(e instanceof x))return n.getLogger(I).error(".createFromPolygon()","expected polygon to be a Polygon instance"),null;const r=P(e);return new G({vertexAttributes:new M({position:r.position}),components:[new w({faces:r.faces,shading:"flat",material:t?.material??null})],spatialReference:e.spatialReference})}static async createFromGLTF(e,r,o){if(!(e instanceof g))throw n.getLogger(I).error(".createfromGLTF()","expected location to be a Point instance"),new t("invalid-input","Expected location to be a Point instance");const{loadGLTFMesh:s}=await l(import("./support/meshUtils/loadGLTFMesh.js"),o);return new G(await s(e,r,o))}static createWithExternalSource(e,t,r){const o=r?.extent??null,n=r?.transform?.clone()??new v;n.origin=[e.x,e.y,e.z??0];const s=e.spatialReference;return new G({external:{source:t,extent:o},transform:n,spatialReference:s})}static createIncomplete(e,r){const o=r?.transform?.clone()??new v;o.origin=[e.x,e.y,e.z??0];const n=e.spatialReference,s=new G({transform:o,spatialReference:n});return s.addResolvingPromise(Promise.reject(new t("mesh-incomplete","Mesh resources are not complete"))),s}};e([p({type:[w],json:{write:!0}})],B.prototype,"components",void 0),e([p({type:v,json:{write:!0}})],B.prototype,"transform",void 0),e([p({constructOnly:!0})],B.prototype,"external",void 0),e([p({readOnly:!0})],B.prototype,"hasExtent",null),e([p({readOnly:!0})],B.prototype,"_boundingInfo",null),e([p({readOnly:!0})],B.prototype,"anchor",null),e([p({readOnly:!0})],B.prototype,"origin",null),e([p({readOnly:!0,json:{read:!1}})],B.prototype,"extent",null),e([p({readOnly:!0,json:{read:!1,write:!0,default:!0}})],B.prototype,"hasZ",void 0),e([p({readOnly:!0,json:{read:!1,write:!0,default:!1}})],B.prototype,"hasM",void 0),e([p({type:M,nonNullable:!0,json:{write:!0}})],B.prototype,"vertexAttributes",void 0),B=G=e([m(I)],B);const k={x:h(1,0,0),y:h(0,1,0),z:h(0,0,1)},D=j(),W=j(),Z=j(),H=f(),N=B;export{N as default};
