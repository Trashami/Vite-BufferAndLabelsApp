/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{_ as r}from"../../chunks/tslib.es6.js";import{JSONSupport as o}from"../../core/JSONSupport.js";import{isSome as t}from"../../core/maybe.js";import{property as s}from"../../core/accessorSupport/decorators/property.js";import"../../core/arrayUtils.js";import"../../core/accessorSupport/ensureType.js";import{subclass as e}from"../../core/accessorSupport/decorators/subclass.js";import{g as i,a,m as n,h as l,j as c}from"../../chunks/mat4.js";import{c as p,I as m}from"../../chunks/mat4f64.js";import{s as h}from"../../chunks/quat.js";import{a as u}from"../../chunks/quatf64.js";import{m as g,k as f}from"../../chunks/vec3.js";import{c as j,f as y,a as x}from"../../chunks/vec3f64.js";import v from"../Point.js";import{computeTranslationToOriginAndRotation as b,projectBuffer as d}from"../projection.js";import{getSphericalPCPF as M}from"../projectionEllipsoid.js";import{create as k,angleRad as N,axis as w}from"./axisAngleDegrees.js";import{BufferViewVec3f64 as I}from"./buffer/BufferView.js";import{t as S}from"../../chunks/vec32.js";import{c as A}from"../../chunks/vec33.js";var T;let q=T=class extends o{constructor(r){super(r),this.origin=j(),this.translation=j(),this.rotation=k(),this.scale=y(1,1,1),this.geographic=!0}get localMatrix(){const r=p();return h(B,w(this.rotation),N(this.rotation)),i(r,B,this.translation,this.scale),r}get localMatrixInverse(){return a(p(),this.localMatrix)}applyLocal(r,o){return g(o,r,this.localMatrix)}applyLocalInverse(r,o){return g(o,r,this.localMatrixInverse)}project(r,o){const t=new Float64Array(r.length),s=I.fromTypedArray(t),e=I.fromTypedArray(r);if(this.geographic){const r=M(o),i=p();return b(o,this.origin,i,r),n(i,i,this.localMatrix),S(s,e,i),d(t,r,0,t,o,0,t.length/3),t}const{localMatrix:i,origin:a}=this;l(i,m)?A(s,e):S(s,e,i);for(let n=0;n<t.length;n+=3)t[n+0]+=a[0],t[n+1]+=a[1],t[n+2]+=a[2];return t}getOriginPoint(r){const[o,t,s]=this.origin;return new v({x:o,y:t,z:s,spatialReference:r})}equals(r){return t(r)&&this.geographic===r.geographic&&f(this.origin,r.origin)&&c(this.localMatrix,r.localMatrix)}clone(){const r={origin:x(this.origin),translation:x(this.translation),rotation:k(this.rotation),scale:x(this.scale),geographic:this.geographic};return new T(r)}};r([s({type:[Number],nonNullable:!0,json:{write:!0}})],q.prototype,"origin",void 0),r([s({type:[Number],nonNullable:!0,json:{write:!0}})],q.prototype,"translation",void 0),r([s({type:[Number],nonNullable:!0,json:{write:!0}})],q.prototype,"rotation",void 0),r([s({type:[Number],nonNullable:!0,json:{write:!0}})],q.prototype,"scale",void 0),r([s({type:Boolean,nonNullable:!0,json:{write:!0}})],q.prototype,"geographic",void 0),r([s()],q.prototype,"localMatrix",null),r([s()],q.prototype,"localMatrixInverse",null),q=T=r([e("esri.geometry.support.MeshTransform")],q);const B=u(),L=q;export{L as default};
