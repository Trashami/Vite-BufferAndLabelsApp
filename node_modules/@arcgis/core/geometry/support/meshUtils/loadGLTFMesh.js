/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import e from"../../../Color.js";import t from"../../../request.js";import{getOrCreateMapValue as r}from"../../../core/MapUtils.js";import{hasScaling as o}from"../../../core/mathUtils.js";import{isSome as n,unwrap as s,applySome as i,isNone as a}from"../../../core/maybe.js";import{b as c}from"../../../chunks/mat3.js";import{c as u}from"../../../chunks/mat3f64.js";import{f as l}from"../../../chunks/vec3f64.js";import{f}from"../../../chunks/vec4f64.js";import m from"../MeshComponent.js";import p from"../MeshMaterialMetallicRoughness.js";import d from"../MeshTexture.js";import{MeshVertexAttributes as g}from"../MeshVertexAttributes.js";import{BufferViewVec4f as x,BufferViewVec4u8 as T,BufferViewVec4u16 as h,BufferViewVec3u8 as v,BufferViewVec3f as w,BufferViewVec3u16 as b,BufferViewVec3f64 as j,BufferViewVec2f as y}from"../buffer/BufferView.js";import{t as A,a as M,n as C,s as R,b as E}from"../../../chunks/vec32.js";import{t as k,n as B,s as F,a as I}from"../../../chunks/vec42.js";import{createBuffer as $}from"../buffer/utils.js";import{georeferenceByTransform as L}from"./georeference.js";import{DefaultLoadingContext as S}from"../../../views/3d/glTF/DefaultLoadingContext.js";import{loadGLTF as N}from"../../../views/3d/glTF/loader.js";import{triangleFanToTriangles as O,triangleStripToTriangles as _,trianglesToTriangles as D}from"../../../views/3d/glTF/internal/indexUtils.js";import{generateIndexArray as G}from"../../../views/3d/webgl-engine/lib/Indices.js";import{COLOR_GAMMA as P}from"../../../views/3d/webgl-engine/materials/DefaultMaterial_COLOR_GAMMA.js";import{PrimitiveType as U,TextureWrapMode as V}from"../../../views/webgl/enums.js";import{f as q,c as z}from"../../../chunks/vec33.js";import{f as K,c as Q}from"../../../chunks/vec43.js";import{n as H,f as J}from"../../../chunks/vec22.js";async function W(e,t,r){const o=new S(X(r)),s=(await N(o,t,r,!0)).model,i=s.lods.shift(),a=new Map,c=new Map;s.textures.forEach(((e,t)=>a.set(t,te(e)))),s.materials.forEach(((e,t)=>c.set(t,re(e,a))));const u=ee(i);for(const n of u.parts)oe(u,n,c);const{position:l,normal:f,tangent:m,color:p,texCoord0:d}=u.vertexAttributes,x={position:l.typedBuffer,normal:n(f)?f.typedBuffer:null,tangent:n(m)?m.typedBuffer:null,uv:n(d)?d.typedBuffer:null,color:n(p)?p.typedBuffer:null},T=L(x,e,r);return{transform:T.transform,components:u.components,spatialReference:e.spatialReference,vertexAttributes:new g({position:T.vertexAttributes.position,normal:T.vertexAttributes.normal,tangent:T.vertexAttributes.tangent,color:x.color,uv:x.uv})}}function X(e){const r=e?.resolveFile;return r?{busy:!1,request:async(e,o,s)=>{const i=r(e),a="image"===o?"image":"binary"===o?"array-buffer":"json";return(await t(i,{responseType:a,signal:n(s)?s.signal:null})).data}}:null}function Y(e,t){if(a(e))return"-";const o=e.typedBuffer;return`${r(t,o.buffer,(()=>t.size))}/${o.byteOffset}/${o.byteLength}`}function Z(e){return n(e)?e.toString():"-"}function ee(e){let t=0;const has={color:!1,tangent:!1,normal:!1,texCoord0:!1},o=new Map,n=new Map,s=[];for(const i of e.parts){const{attributes:{position:e,normal:a,color:c,tangent:u,texCoord0:l}}=i,f=`\n      ${Y(e,o)}/\n      ${Y(a,o)}/\n      ${Y(c,o)}/\n      ${Y(u,o)}/\n      ${Y(l,o)}/\n      ${Z(i.transform)}\n    `;let m=!1;const p=r(n,f,(()=>(m=!0,{start:t,length:e.count})));m&&(t+=e.count),a&&(has.normal=!0),c&&(has.color=!0),u&&(has.tangent=!0),l&&(has.texCoord0=!0),s.push({gltf:i,writeVertices:m,region:p})}return{vertexAttributes:{position:$(j,t),normal:has.normal?$(w,t):null,tangent:has.tangent?$(x,t):null,color:has.color?$(T,t):null,texCoord0:has.texCoord0?$(y,t):null},parts:s,components:[]}}function te(e){return new d({data:e.data,wrap:ae(e.parameters.wrap)})}function re(t,r){const o=new e(le(t.color,t.opacity)),n=t.emissiveFactor?new e(fe(t.emissiveFactor)):null;return new p({color:o,colorTexture:s(i(t.textureColor,(e=>r.get(e)))),normalTexture:s(i(t.textureNormal,(e=>r.get(e)))),emissiveColor:n,emissiveTexture:s(i(t.textureEmissive,(e=>r.get(e)))),occlusionTexture:s(i(t.textureOcclusion,(e=>r.get(e)))),alphaMode:ie(t.alphaMode),alphaCutoff:t.alphaCutoff,doubleSided:t.doubleSided,metallic:t.metallicFactor,roughness:t.roughnessFactor,metallicRoughnessTexture:s(i(t.textureMetallicRoughness,(e=>r.get(e)))),colorTextureTransform:t.colorTextureTransform,normalTextureTransform:t.normalTextureTransform,occlusionTextureTransform:t.occlusionTextureTransform,emissiveTextureTransform:t.emissiveTextureTransform,metallicRoughnessTextureTransform:t.metallicRoughnessTextureTransform})}function oe(e,t,r){t.writeVertices&&ne(e,t);const o=t.gltf,n=se(o.indices||o.attributes.position.count,o.primitiveType),s=t.region.start;if(s)for(let i=0;i<n.length;i++)n[i]+=s;e.components.push(new m({faces:n,material:r.get(o.material),trustSourceNormals:!0}))}function ne(e,t){const{position:r,normal:s,tangent:i,color:a,texCoord0:l}=e.vertexAttributes,f=t.region.start,{attributes:m,transform:p}=t.gltf,d=m.position.count;if(A(r.slice(f,d),m.position,p),n(m.normal)&&n(s)){const e=c(u(),p),t=s.slice(f,d);M(t,m.normal,e),o(e)&&C(t,t)}else n(s)&&q(s,0,0,1,{dstIndex:f,count:d});if(n(m.tangent)&&n(i)){const e=c(u(),p),t=i.slice(f,d);k(t,m.tangent,e),o(e)&&B(t,t)}else n(i)&&K(i,0,0,1,1,{dstIndex:f,count:d});if(n(m.texCoord0)&&n(l)?H(l.slice(f,d),m.texCoord0):n(l)&&J(l,0,0,{dstIndex:f,count:d}),n(m.color)&&n(a)){const e=m.color,t=a.slice(f,d);if(4===e.elementCount)e instanceof x?F(t,e,255):e instanceof T?Q(t,e):e instanceof h&&I(t,e,8);else{K(t,255,255,255,255);const r=v.fromTypedArray(t.typedBuffer,t.typedBufferStride);e instanceof w?R(r,e,255):e instanceof v?z(r,e):e instanceof b&&E(r,e,8)}}else n(a)&&K(a.slice(f,d),255,255,255,255)}function se(e,t){switch(t){case U.TRIANGLES:return D(e,G);case U.TRIANGLE_STRIP:return _(e);case U.TRIANGLE_FAN:return O(e)}}function ie(e){switch(e){case"OPAQUE":return"opaque";case"MASK":return"mask";case"BLEND":return"blend"}}function ae(e){return{horizontal:ce(e.s),vertical:ce(e.t)}}function ce(e){switch(e){case V.CLAMP_TO_EDGE:return"clamp";case V.MIRRORED_REPEAT:return"mirror";case V.REPEAT:return"repeat"}}function ue(e){return e**(1/P)*255}function le(e,t){return f(ue(e[0]),ue(e[1]),ue(e[2]),t)}function fe(e){return l(ue(e[0]),ue(e[1]),ue(e[2]))}export{W as loadGLTFMesh};
