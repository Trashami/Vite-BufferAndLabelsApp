/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import"../../../geometry.js";import e from"../../../Ground.js";import t from"../../../core/Logger.js";import{unwrapOr as o}from"../../../core/maybe.js";import{eachAlways as r}from"../../../core/promiseUtils.js";import{getMetersPerUnitForSR as n}from"../../../core/unitUtils.js";import i from"../../Mesh.js";import{project as a}from"../../projection.js";import s from"../MeshComponent.js";import{MeshVertexAttributes as l}from"../MeshVertexAttributes.js";import m from"../../Point.js";async function c(o,r,n){let i;if(f(o)||o instanceof e){const e=await u(o);return i=await e.createElevationSampler(r,{demResolution:n?.demResolution??"finest-contiguous"}),p(i,r,{material:n?.material})}return"string"==typeof n?.demResolution?(t.getLogger("esri.geometry.support.meshUtils.elevation").error("create()","demResolution must be a number when used directly with a sampler"),null):p(o,r,{material:n?.material,demResolution:n?.demResolution})}function p(e,t,r){const m=n(t.spatialReference),c=(r.demResolution??e.demResolution.min)/m,p=Math.round(t.width/c),u=Math.round(t.height/c),f=p+1,y=u+1,h=new Float64Array(f*y*3),R=new Float32Array(f*y*2);let w=0,g=0;const j=new Uint32Array(p*u*2*3);let v=0,A=0;const b=!e.spatialReference.equals(t.spatialReference);d.spatialReference=t.spatialReference;const{xmin:x,ymin:M,height:U,width:F}=t;for(let n=0;n<y;n++){const t=M+U*(n/u);for(let r=0;r<f;r++){const i=x+F*(r/p);if(h[w++]=i,h[w++]=t,b){d.x=i,d.y=t;const r=a(d,e.spatialReference);h[w++]=o(e.elevationAt(r.x,r.y),0)}else h[w++]=o(e.elevationAt(i,t),0);const s=r/p,l=n/u;R[g++]=s,R[g++]=l,n!==u&&r!==p&&(j[A++]=v+1,j[A++]=v+f+1,j[A++]=v+f,j[A++]=v,j[A++]=v+1,j[A++]=v+f),v++}}return new i({vertexAttributes:new l({position:h,uv:R}),components:[new s({faces:j,shading:"smooth",material:r?.material??null})],spatialReference:t.spatialReference})}async function u(e){return f(e)?e.load():(await e.load(),await r(e.layers.map((e=>e.load()))),e)}function f(e){return"type"in e&&("elevation"===e.type||"base-elevation"===e.type)}const d=new m;export{c as create};
