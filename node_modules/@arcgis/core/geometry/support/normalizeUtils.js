/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import e from"../../config.js";import t from"../../core/Error.js";import n from"../../core/Logger.js";import{isNone as o,isSome as s}from"../../core/maybe.js";import r from"../Polygon.js";import i from"../Polyline.js";import{getGeometryParts as l,cutParams as f,offsetMagnitude as c,updatePolyGeometry as p}from"./normalizeUtilsCommon.js";import{getInfo as u}from"./spatialReferenceUtils.js";import{geographicToWebMercator as a,webMercatorToGeographic as h}from"./webMercatorUtils.js";import{cut as m}from"../../rest/geometryService/cut.js";import{simplify as g}from"../../rest/geometryService/simplify.js";const y=n.getLogger("esri.geometry.support.normalizeUtils");function x(e){return"polygon"===e.type}function d(e){return"polygon"===e[0].type}function w(e){return"polyline"===e[0].type}function j(e){const t=[];let n=0,o=0;for(let s=0;s<e.length;s++){const r=e[s];let i=null;for(let e=0;e<r.length;e++)i=r[e],t.push(i),0===e?(n=i[0],o=n):(n=Math.min(n,i[0]),o=Math.max(o,i[0]));i&&t.push([(n+o)/2,0])}return t}function M(e,n){if(!(e instanceof i||e instanceof r)){const e="straightLineDensify: the input geometry is neither polyline nor polygon";throw y.error(e),new t(e)}const o=l(e),s=[];for(const t of o){const e=[];s.push(e),e.push([t[0][0],t[0][1]]);for(let o=0;o<t.length-1;o++){const s=t[o][0],r=t[o][1],i=t[o+1][0],l=t[o+1][1],f=Math.sqrt((i-s)*(i-s)+(l-r)*(l-r)),c=(l-r)/f,p=(i-s)/f,u=f/n;if(u>1){for(let l=1;l<=u-1;l++){const t=l*n,o=p*t+s,i=c*t+r;e.push([o,i])}const t=(f+Math.floor(u-1)*n)/2,o=p*t+s,i=c*t+r;e.push([o,i])}e.push([i,l])}}return x(e)?new r({rings:s,spatialReference:e.spatialReference}):new i({paths:s,spatialReference:e.spatialReference})}function R(e,t,n){if(t){const t=M(e,1e6);e=h(t,!0)}return n&&(e=p(e,n)),e}function b(e,t,n){if(Array.isArray(e)){const o=e[0];if(o>t){const n=c(o,t);e[0]=o+n*(-2*t)}else if(o<n){const t=c(o,n);e[0]=o+t*(-2*n)}}else{const o=e.x;if(o>t){const n=c(o,t);e=e.clone().offset(n*(-2*t),0)}else if(o<n){const t=c(o,n);e=e.clone().offset(t*(-2*n),0)}}return e}function P(e,t){let n=-1;for(let o=0;o<t.cutIndexes.length;o++){const s=t.cutIndexes[o],r=t.geometries[o],i=l(r);for(let e=0;e<i.length;e++){const t=i[e];t.some((n=>{if(n[0]<180)return!0;{let n=0;for(let e=0;e<t.length;e++){const o=t[e][0];n=o>n?o:n}n=Number(n.toFixed(9));const o=-360*c(n,180);for(let s=0;s<t.length;s++){const t=r.getPoint(e,s);r.setPoint(e,s,t.clone().offset(o,0))}return!0}}))}if(s===n){if(d(e))for(const t of l(r))e[s]=e[s].addRing(t);else if(w(e))for(const t of l(r))e[s]=e[s].addPath(t)}else n=s,e[s]=r}return e}async function v(t,n,l){if(!Array.isArray(t))return v([t],n);n&&"string"!=typeof n&&y.warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const h="string"==typeof n?n:n?.url??e.geometryServiceUrl;let x,d,w,j,M,L,U,z,A=0;const S=[],k=[];for(const e of t)if(o(e))k.push(e);else if(x||(x=e.spatialReference,d=u(x),w=x.isWebMercator,L=w?102100:4326,j=f[L].maxX,M=f[L].minX,U=f[L].plus180Line,z=f[L].minus180Line),d)if("mesh"===e.type)k.push(e);else if("point"===e.type)k.push(b(e.clone(),j,M));else if("multipoint"===e.type){const t=e.clone();t.points=t.points.map((e=>b(e,j,M))),k.push(t)}else if("extent"===e.type){const t=e.clone()._normalize(!1,!1,d);k.push(t.rings?new r(t):t)}else if(e.extent){const t=e.extent,n=c(t.xmin,M)*(2*j);let o=0===n?e.clone():p(e.clone(),n);t.offset(n,0),t.intersects(U)&&t.xmax!==j?(A=t.xmax>A?t.xmax:A,o=R(o,w),S.push(o),k.push("cut")):t.intersects(z)&&t.xmin!==M?(A=t.xmax*(2*j)>A?t.xmax*(2*j):A,o=R(o,w,360),S.push(o),k.push("cut")):k.push(o)}else k.push(e.clone());else k.push(e);let C=c(A,j),I=-90;const X=C,q=new i;for(;C>0;){const e=360*C-180;q.addPath([[e,I],[e,-1*I]]),I*=-1,C--}if(S.length>0&&X>0){const e=P(S,await m(h,S,q,l)),n=[],o=[];for(let l=0;l<k.length;l++){const r=k[l];if("cut"!==r)o.push(r);else{const r=e.shift(),i=t[l];s(i)&&"polygon"===i.type&&i.rings&&i.rings.length>1&&r.rings.length>=i.rings.length?(n.push(r),o.push("simplify")):o.push(w?a(r):r)}}if(!n.length)return o;const r=await g(h,n,l),i=[];for(let t=0;t<o.length;t++){const e=o[t];"simplify"!==e?i.push(e):i.push(w?a(r.shift()):r.shift())}return i}const D=[];for(let e=0;e<k.length;e++){const t=k[e];if("cut"!==t)D.push(t);else{const e=S.shift();D.push(!0===w?a(e):e)}}return D}function L(e){if(!e)return null;const t=e.extent;if(!t)return null;const n=e.spatialReference&&u(e.spatialReference);if(!n)return t;const[o,s]=n.valid,r=2*s,{width:i}=t;let l,{xmin:f,xmax:c}=t;if([f,c]=[c,f],"extent"===e.type||0===i||i<=s||i>r||f<o||c>s)return t;switch(e.type){case"polygon":if(!(e.rings.length>1))return t;l=j(e.rings);break;case"polyline":if(!(e.paths.length>1))return t;l=j(e.paths);break;case"multipoint":l=e.points}const p=t.clone();for(let u=0;u<l.length;u++){let e=l[u][0];e<0?(e+=s,c=Math.max(e,c)):(e-=s,f=Math.min(e,f))}return p.xmin=f,p.xmax=c,p.width<i?(p.xmin-=s,p.xmax-=s,p):t}function U(e,t){const n=u(t);if(n){const[t,o]=n.valid,s=o-t;if(e<t)for(;e<t;)e+=s;if(e>o)for(;e>o;)e-=s}return e}export{L as getDenormalizedExtent,v as normalizeCentralMeridian,U as normalizeMapX,M as straightLineDensify};
