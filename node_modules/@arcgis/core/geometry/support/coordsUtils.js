/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import{equals as n}from"../../core/arrayUtils.js";import{getInfo as t}from"./spatialReferenceUtils.js";function r(n){if(!n)return null;if(Array.isArray(n))return n;const t=n.hasZ,r=n.hasM;if("point"===n.type)return r&&t?[n.x,n.y,n.z,n.m]:t?[n.x,n.y,n.z]:r?[n.x,n.y,n.m]:[n.x,n.y];if("polygon"===n.type)return n.rings.slice(0);if("polyline"===n.type)return n.paths.slice(0);if("multipoint"===n.type)return n.points.slice(0);if("extent"===n.type){const t=n.clone().normalize();if(!t)return null;let r=!1,e=!1;return t.forEach((n=>{n.hasZ&&(r=!0),n.hasM&&(e=!0)})),t.map((n=>{const t=[[n.xmin,n.ymin],[n.xmin,n.ymax],[n.xmax,n.ymax],[n.xmax,n.ymin],[n.xmin,n.ymin]];if(r&&n.hasZ){const r=.5*(n.zmax-n.zmin);for(let n=0;n<t.length;n++)t[n].push(r)}if(e&&n.hasM){const r=.5*(n.mmax-n.mmin);for(let n=0;n<t.length;n++)t[n].push(r)}return t}))}return null}function e(n,t){const r=t[0]-n[0],e=t[1]-n[1];if(n.length>2&&t.length>2){const o=n[2]-t[2];return Math.sqrt(r*r+e*e+o*o)}return Math.sqrt(r*r+e*e)}function o(n,t,r){const e=n[0]+r*(t[0]-n[0]),o=n[1]+r*(t[1]-n[1]);return n.length>2&&t.length>2?[e,o,n[2]+r*(t[2]-n[2])]:[e,o]}function i(n,t,r,e){const[o,i]=t,[s,l]=r[e],[f,c]=r[e+1],u=f-s,h=c-l,a=u*u+h*h,g=(o-s)*u+(i-l)*h,m=Math.min(1,Math.max(0,g/a));return n[0]=s+u*m,n[1]=l+h*m,n}function s(n,t,r){const e=r.rings;let o,i,s=!1,f=1/0;for(let c=0;c<e.length;c++){const r=e[c];for(let e=0,c=r.length-1;e<r.length;c=e++)o=r[e],i=r[c],o[1]>t!=i[1]>t&&n<(i[0]-o[0])*(t-o[1])/(i[1]-o[1])+o[0]&&(s=!s),f=Math.min(f,l(n,t,o,i))}return 0===f?0:(s?1:-1)*Math.sqrt(f)}function l(n,t,r,e){let o=r[0],i=r[1],s=e[0]-o,l=e[1]-i;if(0!==s||0!==l){const r=((n-o)*s+(t-i)*l)/(s*s+l*l);r>1?(o=e[0],i=e[1]):r>0&&(o+=s*r,i+=l*r)}return s=n-o,l=t-i,s*s+l*l}function f(n,t){return o(n,t,.5)}function c(n){const t=n.length;let r=0;for(let o=0;o<t-1;++o)r+=e(n[o],n[o+1]);return r}function u(n,t){if(t<=0)return n[0];const r=n.length;let i=0;for(let s=0;s<r-1;++s){const r=e(n[s],n[s+1]);if(t-i<r){const e=(t-i)/r;return o(n[s],n[s+1],e)}i+=r}return n[r-1]}function h(n,t,r){const e=n.length;let o=0,i=0,s=0;for(let l=0;l<e;l++){const f=n[l],c=n[(l+1)%e];let u=2;o+=f[0]*c[1]-c[0]*f[1],f.length>2&&c.length>2&&r&&(i+=f[0]*c[2]-c[0]*f[2],u=3),f.length>u&&c.length>u&&t&&(s+=f[0]*c[u]-c[0]*f[u])}return o<=0&&i<=0&&s<=0}function a(t){const r=t.length;return r>2&&n(t[0],t[r-1])}function g(n){if("rings"in n&&(m(n),n.rings.length>0&&!h(n.rings[0],n.hasM??!1,n.hasZ??!1)))for(const t of n.rings)t.reverse()}function m(n){if("rings"in n)for(const t of n.rings)a(t)||t.push(t[0].slice())}function p(n){if("polygon"!==n.type&&"polyline"!==n.type)return n;return y("polygon"===n.type?n.rings:n.paths,n.spatialReference),n}function y(n,r){const e=t(r);if(!e)return;const o=e.valid[0],i=e.valid[1],s=i-o;for(const t of n){let n=1/0,r=-1/0;for(const s of t){const t=x(s[0],o,i);n=Math.min(n,t),r=Math.max(r,t),s[0]=t}const e=r-n;s-e<e&&t.forEach((n=>{n[0]<0&&(n[0]+=s)}))}}function x(n,t,r){const e=r-t;return n<t?r-(t-n)%e:n>r?t+(n-t)%e:n}function M(n){if(!n||n.length<3)return 0;let t=0;const r=n.length-1;for(let e=0;e<r;e++)t+=(n[e][0]-n[e+1][0])*(n[e][1]+n[e+1][1]);return t+=(n[r][0]-n[0][0])*(n[r][1]+n[0][1]),-.5*t}export{m as closeRings,g as closeRingsAndFixWinding,s as distanceFromPointToPolygon,l as distanceToSegmentSquared,r as geometryToCoordinates,e as getLength,f as getMidpoint,c as getPathLength,u as getPointOnPath,M as getRingArea,h as isClockwise,a as isClosed,i as projectPointOnLine,p as unnormalizeGeometryOnDatelineCrossing,y as unnormalizeVerticesOnDatelineCrossing,x as unnormalizedCoordinate};
