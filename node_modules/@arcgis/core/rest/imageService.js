/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.25/esri/copyright.txt for details.
*/
import"../geometry.js";import e from"../request.js";import{isSome as t}from"../core/maybe.js";import{normalizeCentralMeridian as n}from"../geometry/support/normalizeUtils.js";import{parseUrl as o,encode as a,asValidOptions as s}from"./utils.js";import i from"./support/ImageAngleResult.js";import r from"./support/ImageIdentifyResult.js";import m from"./support/ImagePixelLocationResult.js";import c from"./support/ImageSampleResult.js";import l from"../geometry/SpatialReference.js";function u(e){const t=e?.time;if(t&&(null!=t.start||null!=t.end)){const n=[];null!=t.start&&n.push(t.start),null==t.end||n.includes(t.end)||n.push(t.end),e.time=n.join(",")}}async function p(e,i,r){const m=o(e),c=i.geometry?[i.geometry]:[],l=await n(c),p=i.toJSON();u(p);const f=l&&l[0];t(f)&&(p.geometry=f.toJSON());const g=a({...m.query,f:"json",...p});return s(g,r)}async function f(n,r,m){const c=r.toJSON();t(c.angleName)&&(c.angleName=c.angleName.join(",")),t(r.point)&&r.point.spatialReference?.imageCoordinateSystem&&(c.point.spatialReference=h(r.point.spatialReference)),t(r.spatialReference)&&r.spatialReference.imageCoordinateSystem&&(c.spatialReference=R(r.spatialReference));const u=o(n),p=a({...u.query,f:"json",...c}),f=s(p,m),{data:g}=await e(`${u.path}/computeAngles`,f);return g.spatialReference=g.spatialReference?null!=g.spatialReference.geodataXform?new l({wkid:0,imageCoordinateSystem:g.spatialReference}):l.fromJSON(g.spatialReference):null,"NaN"===g.north&&(g.north=null),"NaN"===g.up&&(g.up=null),new i(g)}async function g(t,n,i){const r=n.toJSON(),{geometries:c}=n;if(c)for(let e=0;e<c.length;e++)c[e].spatialReference?.imageCoordinateSystem&&(r.geometries.geometries[e].spatialReference=h(c[e].spatialReference));const l=o(t),u=a({...l.query,f:"json",...r}),p=s(u,i),{data:f}=await e(`${l.path}/computePixelLocation`,p);return m.fromJSON(f)}async function y(t,n,a){const s=await p(t,n,a),i=o(t),{data:r}=await e(`${i.path}/computeStatisticsHistograms`,s),{statistics:m}=r;return m?.length&&m.forEach((e=>{e.avg=e.mean,e.stddev=e.standardDeviation})),{statistics:m,histograms:r.histograms}}async function d(t,n,a){const s=await p(t,n,a),i=o(t),{data:r}=await e(`${i.path}/computeHistograms`,s);return{histograms:r.histograms}}async function N(i,r,m){const l=r.toJSON();u(l),l.outFields?.length&&(l.outFields=l.outFields.join(","));const p=(await n(r.geometry))?.[0];t(p)&&(l.geometry=p.toJSON());const f=o(i),g=a({...f.query,f:"json",...l}),y=s(g,m),{data:d}=await e(`${f.path}/getSamples`,y),N=d?.samples?.map((e=>{const t="NaN"===e.value||""===e.value?null:e.value.split(" ").map((e=>Number(e)));return{...e,pixelValue:t}}));return c.fromJSON({samples:N})}async function S(i,m,c){const l=o(i),u=m.geometry?[m.geometry]:[];return n(u).then((n=>{const o=m.toJSON(),i=n&&n[0];t(i)&&(o.geometry=JSON.stringify(i.toJSON()));const r=a({...l.query,f:"json",...o}),u=s(r,c);return e(l.path+"/identify",u)})).then((e=>r.fromJSON(e.data)))}function h(e){const{imageCoordinateSystem:t}=e;if(t){const{id:e,referenceServiceName:n}=t;return null!=e?n?{icsid:e,icsns:n}:{icsid:e}:{ics:t}}return e.toJSON()}function R(e,t){const n=h(e),{icsid:o,icsns:a,wkid:s}=n;return null!=o?null==a||t?.toLowerCase().includes("/"+a.toLowerCase()+"/")?`0:${o}`:JSON.stringify(n):s?s.toString():JSON.stringify(n)}export{f as computeAngles,d as computeHistograms,g as computePixelSpaceLocations,y as computeStatisticsHistograms,h as getImageSpatialReferenceJSON,R as getImageSpatialReferenceQueryParameter,N as getSamples,S as identify};
