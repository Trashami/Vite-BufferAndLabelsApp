import {
  o,
  r,
  t as t2
} from "./chunk-C6HDWDWX.js";
import {
  T,
  i
} from "./chunk-67RD6CZ4.js";
import {
  e as e2
} from "./chunk-IVLBGTXL.js";
import {
  e
} from "./chunk-GHN7C53L.js";
import {
  B,
  a,
  g,
  o as o2
} from "./chunk-ZNRXLY4R.js";
import {
  Zn,
  xn
} from "./chunk-FFVIDMFN.js";
import {
  O
} from "./chunk-WJCI2CGX.js";
import {
  S,
  z
} from "./chunk-3LR5O4WA.js";
import {
  n
} from "./chunk-D4V6J5BT.js";
import {
  c
} from "./chunk-UWG37XSU.js";
import {
  P,
  s as s2,
  u
} from "./chunk-LNZAOBFW.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";
import {
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/geometry/support/meshUtils/projection.js
var g2 = s.getLogger("esri.geometry.support.meshUtils.normalProjection");
function j(r2, e3, o3, t3, n2) {
  return B2(t3) ? (b(Y.TO_PCPF, i.fromTypedArray(r2), T.fromTypedArray(e3), T.fromTypedArray(o3), t3, i.fromTypedArray(n2)), n2) : (g2.error("Cannot convert spatial reference to PCPF"), n2);
}
function h(r2, e3, o3, t3, n2) {
  return B2(t3) ? (b(Y.FROM_PCPF, i.fromTypedArray(r2), T.fromTypedArray(e3), T.fromTypedArray(o3), t3, i.fromTypedArray(n2)), n2) : (g2.error("Cannot convert to spatial reference from PCPF"), n2);
}
function M(r2, e3, o3) {
  return xn(r2, e3, 0, o3, O(e3), 0, r2.length / 3), o3;
}
function O2(r2, e3, o3) {
  return xn(r2, O(o3), 0, e3, o3, 0, r2.length / 3), e3;
}
function R(r2, o3, t3) {
  if (t(r2))
    return o3;
  const n2 = T.fromTypedArray(r2), f = T.fromTypedArray(o3);
  return t2(f, n2, t3), o3;
}
function v(r2, n2, f) {
  if (t(r2))
    return n2;
  g(x, f);
  const a2 = i.fromTypedArray(r2), c2 = i.fromTypedArray(n2);
  return r(c2, a2, x), B(x) || o(c2, c2), n2;
}
function V(r2, n2, f) {
  if (t(r2))
    return n2;
  g(x, f);
  const a2 = i.fromTypedArray(r2, 4 * Float32Array.BYTES_PER_ELEMENT), c2 = i.fromTypedArray(n2, 4 * Float32Array.BYTES_PER_ELEMENT);
  if (r(c2, a2, x), B(x) || o(c2, c2), r2 !== n2)
    for (let e3 = 3; e3 < r2.length; e3 += 4)
      n2[e3] = r2[e3];
  return n2;
}
function k(r2, e3, o3, t3, n2) {
  if (!B2(t3))
    return g2.error("Cannot convert spatial reference to PCPF"), n2;
  b(Y.TO_PCPF, i.fromTypedArray(r2, 4 * Float32Array.BYTES_PER_ELEMENT), T.fromTypedArray(e3), T.fromTypedArray(o3), t3, i.fromTypedArray(n2, 4 * Float32Array.BYTES_PER_ELEMENT));
  for (let f = 3; f < r2.length; f += 4)
    n2[f] = r2[f];
  return n2;
}
function L(r2, e3, o3, t3, n2) {
  if (!B2(t3))
    return g2.error("Cannot convert to spatial reference from PCPF"), n2;
  b(Y.FROM_PCPF, i.fromTypedArray(r2, 16), T.fromTypedArray(e3), T.fromTypedArray(o3), t3, i.fromTypedArray(n2, 16));
  for (let f = 3; f < r2.length; f += 4)
    n2[f] = r2[f];
  return n2;
}
function b(r2, e3, o3, t3, a2, c2) {
  if (!e3)
    return;
  const i2 = o3.count, y = O(a2);
  if (S2(a2))
    for (let s3 = 0; s3 < i2; s3++)
      t3.getVec(s3, U), e3.getVec(s3, w), Zn(y, U, W, y), a(x, W), r2 === Y.FROM_PCPF && o2(x, x), S(w, w, x), c2.setVec(s3, w);
  else
    for (let u2 = 0; u2 < i2; u2++) {
      t3.getVec(u2, U), e3.getVec(u2, w), Zn(y, U, W, y), a(x, W);
      const a3 = c(o3.get(u2, 1));
      let i3 = Math.cos(a3);
      r2 === Y.TO_PCPF && (i3 = 1 / i3), x[0] *= i3, x[1] *= i3, x[2] *= i3, x[3] *= i3, x[4] *= i3, x[5] *= i3, r2 === Y.FROM_PCPF && o2(x, x), S(w, w, x), z(w, w), c2.setVec(u2, w);
    }
  return c2;
}
function B2(r2) {
  return S2(r2) || N(r2);
}
function S2(r2) {
  return r2.isWGS84 || u(r2) || P(r2) || s2(r2);
}
function N(r2) {
  return r2.isWebMercator;
}
var Y;
!function(r2) {
  r2[r2.TO_PCPF = 0] = "TO_PCPF", r2[r2.FROM_PCPF = 1] = "FROM_PCPF";
}(Y || (Y = {}));
var U = n();
var w = n();
var W = e2();
var x = e();

export {
  j,
  h,
  M,
  O2 as O,
  R,
  v,
  V,
  k,
  L
};
//# sourceMappingURL=chunk-AQS2GDHU.js.map
