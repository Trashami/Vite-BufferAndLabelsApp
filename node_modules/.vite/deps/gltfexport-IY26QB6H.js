import {
  g,
  i,
  o as o3,
  s as s2
} from "./chunk-OS7L4DDX.js";
import {
  C as C2,
  D
} from "./chunk-3OFVLRSL.js";
import {
  c
} from "./chunk-L3EXV6PG.js";
import {
  M
} from "./chunk-EWDJAAMQ.js";
import "./chunk-4M35HEAB.js";
import "./chunk-AQS2GDHU.js";
import "./chunk-C6HDWDWX.js";
import "./chunk-67RD6CZ4.js";
import {
  K,
  k
} from "./chunk-NGFMX3UT.js";
import {
  e as e2,
  o as o2,
  r as r3
} from "./chunk-XFDO4CMR.js";
import "./chunk-IVLBGTXL.js";
import "./chunk-GHN7C53L.js";
import "./chunk-6FXLJAMI.js";
import "./chunk-ZNRXLY4R.js";
import "./chunk-75RMBUYZ.js";
import "./chunk-FFVIDMFN.js";
import "./chunk-ZWUEORSX.js";
import "./chunk-ZPYDYUP5.js";
import "./chunk-RT3T2K4S.js";
import "./chunk-WJCI2CGX.js";
import "./chunk-X2S4RQJ4.js";
import "./chunk-6M2AHKYV.js";
import "./chunk-JUVQV3R3.js";
import "./chunk-RAX2HD42.js";
import "./chunk-ZYRIJWLX.js";
import "./chunk-C5H57NTD.js";
import {
  F,
  _,
  e,
  o,
  z
} from "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import {
  f,
  l,
  n,
  t as t2
} from "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import "./chunk-3MNMDUQZ.js";
import {
  w
} from "./chunk-UWG37XSU.js";
import "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import "./chunk-HLM6QCL2.js";
import "./chunk-RXYULINL.js";
import "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import {
  it
} from "./chunk-KAN4HXCG.js";
import "./chunk-VWYWOOPX.js";
import "./chunk-M5VHU5LK.js";
import "./chunk-7QMMKGW4.js";
import "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import {
  E
} from "./chunk-MJXQTGI2.js";
import "./chunk-LIZHLHNA.js";
import {
  r as r2
} from "./chunk-BTUHYGXO.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";
import "./chunk-HVKDYDPP.js";
import {
  C
} from "./chunk-6QC7MLLS.js";
import {
  r,
  t
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/glb.js
var t3;
!function(t4) {
  t4[t4.JSON = 1313821514] = "JSON", t4[t4.BIN = 5130562] = "BIN";
}(t3 || (t3 = {}));
var e3 = class {
  constructor(i3, r6) {
    if (!i3)
      throw new Error("GLB requires a JSON gltf chunk");
    this._length = e3.HEADER_SIZE, this._length += e3.CHUNK_HEADER_SIZE;
    const n2 = this._textToArrayBuffer(i3);
    if (this._length += this._alignTo(n2.byteLength, 4), r6 && (this._length += e3.CHUNK_HEADER_SIZE, this._length += r6.byteLength, r6.byteLength % 4))
      throw new Error("Expected BIN chunk length to be divisible by 4 at this point");
    this.buffer = new ArrayBuffer(this._length), this._outView = new DataView(this.buffer), this._writeHeader();
    const h2 = this._writeChunk(n2, 12, t3.JSON, 32);
    r6 && this._writeChunk(r6, h2, t3.BIN);
  }
  _writeHeader() {
    this._outView.setUint32(0, e3.MAGIC, true), this._outView.setUint32(4, e3.VERSION, true), this._outView.setUint32(8, this._length, true);
  }
  _writeChunk(t4, e4, i3, r6 = 0) {
    const n2 = this._alignTo(t4.byteLength, 4);
    for (this._outView.setUint32(e4, n2, true), this._outView.setUint32(e4 += 4, i3, true), this._writeArrayBuffer(this._outView.buffer, t4, e4 += 4, 0, t4.byteLength), e4 += t4.byteLength; e4 % 4; )
      r6 && this._outView.setUint8(e4, r6), e4++;
    return e4;
  }
  _writeArrayBuffer(t4, e4, i3, r6, n2) {
    new Uint8Array(t4, i3, n2).set(new Uint8Array(e4, r6, n2), 0);
  }
  _textToArrayBuffer(t4) {
    return new TextEncoder().encode(t4).buffer;
  }
  _alignTo(t4, e4) {
    return e4 * Math.ceil(t4 / e4);
  }
};
e3.HEADER_SIZE = 12, e3.CHUNK_HEADER_SIZE = 8, e3.MAGIC = 1179937895, e3.VERSION = 2;

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/types.js
var E2;
var A;
var R;
var L;
var o4;
var I;
var N;
!function(E3) {
  E3[E3.External = 0] = "External", E3[E3.DataURI = 1] = "DataURI", E3[E3.GLB = 2] = "GLB";
}(E2 || (E2 = {})), function(E3) {
  E3[E3.External = 0] = "External", E3[E3.DataURI = 1] = "DataURI", E3[E3.GLB = 2] = "GLB";
}(A || (A = {})), function(E3) {
  E3[E3.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", E3[E3.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER";
}(R || (R = {})), function(E3) {
  E3.SCALAR = "SCALAR", E3.VEC2 = "VEC2", E3.VEC3 = "VEC3", E3.VEC4 = "VEC4", E3.MAT2 = "MAT2", E3.MAT3 = "MAT3", E3.MAT4 = "MAT4";
}(L || (L = {})), function(E3) {
  E3[E3.POINTS = 0] = "POINTS", E3[E3.LINES = 1] = "LINES", E3[E3.LINE_LOOP = 2] = "LINE_LOOP", E3[E3.LINE_STRIP = 3] = "LINE_STRIP", E3[E3.TRIANGLES = 4] = "TRIANGLES", E3[E3.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", E3[E3.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
}(o4 || (o4 = {})), function(E3) {
  E3.OPAQUE = "OPAQUE", E3.MASK = "MASK", E3.BLEND = "BLEND";
}(I || (I = {})), function(E3) {
  E3[E3.NoColor = 0] = "NoColor", E3[E3.FaceColor = 1] = "FaceColor", E3[E3.VertexColor = 2] = "VertexColor";
}(N || (N = {}));

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/bufferview.js
var r4 = class {
  constructor(e4, s5, i3, r6, n2) {
    this._buffer = e4, this._componentType = i3, this._dataType = r6, this._data = [], this._isFinalized = false, this._accessorIndex = -1, this._accessorAttribute = null, this._accessorMin = null, this._accessorMax = null, s5.bufferViews || (s5.bufferViews = []), this.index = s5.bufferViews.length, this._bufferView = { buffer: e4.index, byteLength: -1, target: n2 };
    const a2 = this._getElementSize();
    a2 >= 4 && n2 !== R.ELEMENT_ARRAY_BUFFER && (this._bufferView.byteStride = a2), s5.bufferViews.push(this._bufferView), this._numComponentsForDataType = this._calculateNumComponentsForDataType();
  }
  push(e4) {
    const t4 = this._data.length;
    if (this._data.push(e4), this._accessorIndex >= 0) {
      const s5 = t4 % this._numComponentsForDataType, i3 = this._accessorMin[s5];
      this._accessorMin[s5] = "number" != typeof i3 ? e4 : Math.min(i3, e4);
      const r6 = this._accessorMax[s5];
      this._accessorMax[s5] = "number" != typeof r6 ? e4 : Math.max(r6, e4);
    }
  }
  get dataSize() {
    return this._data.length * this._sizeComponentType();
  }
  get byteSize() {
    function e4(e5, t4) {
      return t4 * Math.ceil(e5 / t4);
    }
    return e4(this.dataSize, 4);
  }
  getByteOffset() {
    if (!this._isFinalized)
      throw new Error("Cannot get BufferView offset until it is finalized");
    return this._buffer.getByteOffset(this);
  }
  get byteOffset() {
    if (!this._isFinalized)
      throw new Error("Cannot get BufferView offset until it is finalized");
    return this._buffer.getByteOffset(this);
  }
  _createTypedArray(e4, t4) {
    switch (this._componentType) {
      case C2.BYTE:
        return new Int8Array(e4, t4);
      case C2.FLOAT:
        return new Float32Array(e4, t4);
      case C2.SHORT:
        return new Int16Array(e4, t4);
      case C2.UNSIGNED_BYTE:
        return new Uint8Array(e4, t4);
      case C2.UNSIGNED_INT:
        return new Uint32Array(e4, t4);
      case C2.UNSIGNED_SHORT:
        return new Uint16Array(e4, t4);
    }
  }
  writeOutToBuffer(e4, t4) {
    this._createTypedArray(e4, t4).set(this._data);
  }
  writeAsync(e4) {
    if (this._asyncWritePromise)
      throw new Error("Can't write multiple bufferView values asynchronously");
    return this._asyncWritePromise = e4.then((e5) => {
      const t4 = new Uint8Array(e5);
      for (let s5 = 0; s5 < t4.length; ++s5)
        this._data.push(t4[s5]);
      delete this._asyncWritePromise;
    }), this._asyncWritePromise;
  }
  startAccessor(e4) {
    if (this._accessorIndex >= 0)
      throw new Error("Accessor was started without ending the previous one");
    this._accessorIndex = this._data.length, this._accessorAttribute = e4;
    const t4 = this._numComponentsForDataType;
    this._accessorMin = new Array(t4), this._accessorMax = new Array(t4);
  }
  endAccessor() {
    if (this._accessorIndex < 0)
      throw new Error("An accessor was not started, but was attempted to be ended");
    const e4 = this._getElementSize(), t4 = this._numComponentsForDataType, s5 = (this._data.length - this._accessorIndex) / t4;
    if (s5 % 1)
      throw new Error("An accessor was ended with missing component values");
    for (let i3 = 0; i3 < this._accessorMin.length; ++i3)
      "number" != typeof this._accessorMin[i3] && (this._accessorMin[i3] = 0), "number" != typeof this._accessorMax[i3] && (this._accessorMax[i3] = 0);
    const r6 = { byteOffset: e4 * (this._accessorIndex / t4), componentType: this._componentType, count: s5, type: this._dataType, min: this._accessorMin, max: this._accessorMax, name: this._accessorAttribute };
    switch (this._accessorAttribute) {
      case "TEXCOORD_0":
      case "TEXCOORD_1":
      case "COLOR_0":
      case "WEIGHTS_0":
        switch (this._componentType) {
          case C2.UNSIGNED_BYTE:
          case C2.UNSIGNED_SHORT:
            r6.normalized = true;
        }
    }
    return this._accessorIndex = -1, this._accessorAttribute = null, this._accessorMin = null, this._accessorMax = null, r6;
  }
  get finalized() {
    return this._finalizedPromise ? this._finalizedPromise : this._isFinalized ? this._finalizedPromise = Promise.resolve() : this._finalizedPromise = new Promise((e4) => this._finalizedPromiseResolve = e4);
  }
  finalize() {
    const t4 = this._bufferView;
    return new Promise((t5) => {
      const s5 = this._buffer.getViewFinalizePromises(this);
      this._asyncWritePromise && s5.push(this._asyncWritePromise), t5(E(s5));
    }).then(() => {
      this._isFinalized = true, t4.byteOffset = this.getByteOffset(), t4.byteLength = this.dataSize, this._finalizedPromiseResolve && this._finalizedPromiseResolve();
    });
  }
  _getElementSize() {
    return this._sizeComponentType() * this._numComponentsForDataType;
  }
  _sizeComponentType() {
    switch (this._componentType) {
      case C2.BYTE:
      case C2.UNSIGNED_BYTE:
        return 1;
      case C2.SHORT:
      case C2.UNSIGNED_SHORT:
        return 2;
      case C2.UNSIGNED_INT:
      case C2.FLOAT:
        return 4;
    }
  }
  _calculateNumComponentsForDataType() {
    switch (this._dataType) {
      case L.SCALAR:
        return 1;
      case L.VEC2:
        return 2;
      case L.VEC3:
        return 3;
      case L.VEC4:
      case L.MAT2:
        return 4;
      case L.MAT3:
        return 9;
      case L.MAT4:
        return 16;
    }
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/buffer.js
var r5 = class {
  constructor(e4) {
    this._gltf = e4, this._bufferViews = [], this._isFinalized = false, e4.buffers || (e4.buffers = []), this.index = e4.buffers.length;
    const i3 = { byteLength: -1 };
    e4.buffers.push(i3), this._buffer = i3;
  }
  addBufferView(e4, r6, t4) {
    if (this._finalizePromise)
      throw new Error("Cannot add buffer view after fiinalizing buffer");
    const f5 = new r4(this, this._gltf, e4, r6, t4);
    return this._bufferViews.push(f5), f5;
  }
  getByteOffset(e4) {
    let i3 = 0;
    for (const r6 of this._bufferViews) {
      if (r6 === e4)
        return i3;
      i3 += r6.byteSize;
    }
    throw new Error("Given bufferView was not present in this buffer");
  }
  getViewFinalizePromises(e4) {
    const i3 = [];
    for (const r6 of this._bufferViews) {
      if (e4 && r6 === e4)
        return i3;
      i3.push(r6.finalized);
    }
    return i3;
  }
  getArrayBuffer() {
    if (!this._isFinalized)
      throw new Error("Cannot get ArrayBuffer from Buffer before it is finalized");
    const e4 = this._getTotalSize(), i3 = new ArrayBuffer(e4);
    let r6 = 0;
    for (const t4 of this._bufferViews)
      t4.writeOutToBuffer(i3, r6), r6 += t4.byteSize;
    return i3;
  }
  finalize() {
    var _a;
    if (this._finalizePromise)
      throw new Error(`Buffer ${this.index} was already finalized`);
    return this._finalizePromise = new Promise((i3) => {
      i3(E(this.getViewFinalizePromises()));
    }).then(() => {
      this._isFinalized = true;
      const e4 = this.getArrayBuffer();
      this._buffer.byteLength = e4.byteLength, this._buffer.uri = e4;
    }), (_a = this._gltf.extras) == null ? void 0 : _a.promises.push(this._finalizePromise), this._finalizePromise;
  }
  _getTotalSize() {
    let e4 = 0;
    for (const i3 of this._bufferViews)
      e4 += i3.byteSize;
    return e4;
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/geometry.js
function f2(t4, n2) {
  if (t4.components)
    for (const e4 of t4.components)
      e4.faces && "smooth" === e4.shading && c2(e4, n2);
}
function c2(n2, a2) {
  t(a2.normal) && (a2.normal = new Float32Array(a2.position.length));
  const i3 = n2.faces, { position: f5, normal: c3 } = a2, m3 = i3.length / 3;
  for (let t4 = 0; t4 < m3; ++t4) {
    const n3 = 3 * i3[3 * t4 + 0], s5 = 3 * i3[3 * t4 + 1], a3 = 3 * i3[3 * t4 + 2], m4 = o(l2, f5[n3 + 0], f5[n3 + 1], f5[n3 + 2]), h2 = o(p, f5[s5 + 0], f5[s5 + 1], f5[s5 + 2]), g2 = o(x, f5[a3 + 0], f5[a3 + 1], f5[a3 + 2]), u = e(h2, h2, m4), j = e(g2, g2, m4), y = _(u, u, j);
    c3[n3 + 0] += y[0], c3[n3 + 1] += y[1], c3[n3 + 2] += y[2], c3[s5 + 0] += y[0], c3[s5 + 1] += y[1], c3[s5 + 2] += y[2], c3[a3 + 0] += y[0], c3[a3 + 1] += y[1], c3[a3 + 2] += y[2];
  }
  for (let t4 = 0; t4 < c3.length; t4 += 3)
    o(h, c3[t4], c3[t4 + 1], c3[t4 + 2]), z(h, h), c3[t4 + 0] = h[0], c3[t4 + 1] = h[1], c3[t4 + 2] = h[2];
}
function m(t4) {
  if (r(t4.transform))
    return t4.transform.getOriginPoint(t4.spatialReference);
  const e4 = t4.extent.xmax - t4.extent.width / 2, o5 = t4.extent.ymax - t4.extent.height / 2, r6 = t4.extent.zmin;
  return new w({ x: e4, y: o5, z: r6, spatialReference: t4.extent.spatialReference });
}
var l2 = n();
var p = n();
var x = n();
var h = n();

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/gltf.js
var O = s.getLogger("gltf");
var w2 = class {
  constructor(e4, t4, s5) {
    this.params = {}, this._materialMap = new Array(), this._imageMap = /* @__PURE__ */ new Map(), this._textureMap = /* @__PURE__ */ new Map(), this.gltf = { asset: { version: "2.0", copyright: e4.copyright, generator: e4.generator }, extras: { options: t4, binChunkBuffer: null, promises: [] } }, s5 && (this.params = s5), this._addScenes(e4);
  }
  _addScenes(e4) {
    this.gltf.scene = e4.defaultScene;
    const t4 = this.gltf.extras, s5 = t4.options.bufferOutputType === E2.GLB || t4.options.imageOutputType === A.GLB;
    s5 && (t4.binChunkBuffer = new r5(this.gltf)), e4.forEachScene((e5) => {
      this._addScene(e5);
    }), s5 && t4.binChunkBuffer.finalize();
  }
  _addScene(e4) {
    this.gltf.scenes || (this.gltf.scenes = []);
    const t4 = {};
    e4.name && (t4.name = e4.name), e4.forEachNode((e5) => {
      t4.nodes || (t4.nodes = []);
      const s5 = this._addNode(e5);
      t4.nodes.push(s5);
    }), this.gltf.scenes.push(t4);
  }
  _addNode(e4) {
    this.gltf.nodes || (this.gltf.nodes = []);
    const t4 = {};
    e4.name && (t4.name = e4.name);
    const s5 = e4.translation;
    F(s5, f) || (t4.translation = t2(s5));
    const i3 = e4.rotation;
    K(i3, o2) || (t4.rotation = r3(i3));
    const u = e4.scale;
    F(u, l) || (t4.scale = t2(u)), e4.mesh && e4.mesh.vertexAttributes.position ? t4.mesh = this._addMesh(e4.mesh) : e4.forEachNode((e5) => {
      t4.children || (t4.children = []);
      const s6 = this._addNode(e5);
      t4.children.push(s6);
    });
    const f5 = this.gltf.nodes.length;
    return this.gltf.nodes.push(t4), f5;
  }
  _addMesh(e4) {
    this.gltf.meshes || (this.gltf.meshes = []);
    const t4 = { primitives: [] }, i3 = this.gltf.extras, r6 = i3.options.bufferOutputType === E2.GLB;
    let a2;
    a2 = r6 ? i3.binChunkBuffer : new r5(this.gltf), this.params.origin || (this.params.origin = m(e4));
    const o5 = M(e4.vertexAttributes, e4.transform, this.params.origin, { geographic: this.params.geographic, unit: "meters" });
    f2(e4, o5), this._flipYZAxis(o5);
    const n2 = a2.addBufferView(C2.FLOAT, L.VEC3, R.ARRAY_BUFFER);
    let l3, c3, h2, u;
    o5.normal && (l3 = a2.addBufferView(C2.FLOAT, L.VEC3, R.ARRAY_BUFFER)), e4.vertexAttributes.uv && (c3 = a2.addBufferView(C2.FLOAT, L.VEC2, R.ARRAY_BUFFER)), o5.tangent && (h2 = a2.addBufferView(C2.FLOAT, L.VEC4, R.ARRAY_BUFFER)), e4.vertexAttributes.color && (u = a2.addBufferView(C2.UNSIGNED_BYTE, L.VEC4, R.ARRAY_BUFFER)), n2.startAccessor("POSITION"), l3 && l3.startAccessor("NORMAL"), c3 && c3.startAccessor("TEXCOORD_0"), h2 && h2.startAccessor("TANGENT"), u && u.startAccessor("COLOR_0");
    const _2 = o5.position.length / 3, { position: R2, normal: T, tangent: E3 } = o5, { color: M2, uv: O2 } = e4.vertexAttributes;
    for (let f5 = 0; f5 < _2; ++f5)
      n2.push(R2[3 * f5 + 0]), n2.push(R2[3 * f5 + 1]), n2.push(R2[3 * f5 + 2]), l3 && r(T) && (l3.push(T[3 * f5 + 0]), l3.push(T[3 * f5 + 1]), l3.push(T[3 * f5 + 2])), c3 && r(O2) && (c3.push(O2[2 * f5 + 0]), c3.push(O2[2 * f5 + 1])), h2 && r(E3) && (h2.push(E3[4 * f5 + 0]), h2.push(E3[4 * f5 + 1]), h2.push(E3[4 * f5 + 2]), h2.push(E3[4 * f5 + 3])), u && r(M2) && (u.push(M2[4 * f5 + 0]), u.push(M2[4 * f5 + 1]), u.push(M2[4 * f5 + 2]), u.push(M2[4 * f5 + 3]));
    const w3 = n2.endAccessor(), N2 = this._addAccessor(n2.index, w3);
    let C3, B, L2, y, I2;
    if (l3) {
      const e5 = l3.endAccessor();
      C3 = this._addAccessor(l3.index, e5);
    }
    if (c3) {
      const e5 = c3.endAccessor();
      B = this._addAccessor(c3.index, e5);
    }
    if (h2) {
      const e5 = h2.endAccessor();
      L2 = this._addAccessor(h2.index, e5);
    }
    if (u) {
      const e5 = u.endAccessor();
      y = this._addAccessor(u.index, e5);
    }
    e4.components && e4.components.length > 0 && e4.components[0].faces ? (I2 = a2.addBufferView(C2.UNSIGNED_INT, L.SCALAR, R.ELEMENT_ARRAY_BUFFER), this._addMeshVertexIndexed(I2, e4.components, t4, N2, C3, B, L2, y)) : this._addMeshVertexNonIndexed(e4.components, t4, N2, C3, B, L2, y), n2.finalize(), l3 && l3.finalize(), c3 && c3.finalize(), h2 && h2.finalize(), I2 && I2.finalize(), u && u.finalize(), r6 || a2.finalize();
    const S = this.gltf.meshes.length;
    return this.gltf.meshes.push(t4), S;
  }
  _flipYZAxis({ position: e4, normal: t4, tangent: s5 }) {
    this._flipYZBuffer(e4, 3), this._flipYZBuffer(t4, 3), this._flipYZBuffer(s5, 4);
  }
  _flipYZBuffer(e4, t4) {
    if (!t(e4))
      for (let s5 = 1, i3 = 2; s5 < e4.length; s5 += t4, i3 += t4) {
        const t5 = e4[s5], r6 = e4[i3];
        e4[s5] = r6, e4[i3] = -t5;
      }
  }
  _addMaterial(e4) {
    if (null === e4)
      return;
    const t4 = this._materialMap.indexOf(e4);
    if (-1 !== t4)
      return t4;
    this.gltf.materials || (this.gltf.materials = []);
    const i3 = {};
    switch (e4.alphaMode) {
      case "mask":
        i3.alphaMode = I.MASK;
        break;
      case "auto":
      case "blend":
        i3.alphaMode = I.BLEND;
    }
    0.5 !== e4.alphaCutoff && (i3.alphaCutoff = e4.alphaCutoff), e4.doubleSided && (i3.doubleSided = e4.doubleSided), i3.pbrMetallicRoughness = {};
    const r6 = (e5) => e5 ** 2.1, a2 = (e5) => {
      const t5 = e5.toRgba();
      return t5[0] = r6(t5[0] / 255), t5[1] = r6(t5[1] / 255), t5[2] = r6(t5[2] / 255), t5;
    };
    if (r(e4.color) && (i3.pbrMetallicRoughness.baseColorFactor = a2(e4.color)), r(e4.colorTexture) && (i3.pbrMetallicRoughness.baseColorTexture = { index: this._addTexture(e4.colorTexture) }), r(e4.normalTexture) && (i3.normalTexture = { index: this._addTexture(e4.normalTexture) }), e4 instanceof c) {
      if (r(e4.emissiveTexture) && (i3.emissiveTexture = { index: this._addTexture(e4.emissiveTexture) }), r(e4.emissiveColor)) {
        const t5 = a2(e4.emissiveColor);
        i3.emissiveFactor = [t5[0], t5[1], t5[2]];
      }
      r(e4.occlusionTexture) && (i3.occlusionTexture = { index: this._addTexture(e4.occlusionTexture) }), r(e4.metallicRoughnessTexture) && (i3.pbrMetallicRoughness.metallicRoughnessTexture = { index: this._addTexture(e4.metallicRoughnessTexture) }), i3.pbrMetallicRoughness.metallicFactor = e4.metallic, i3.pbrMetallicRoughness.roughnessFactor = e4.roughness;
    } else
      i3.pbrMetallicRoughness.metallicFactor = 1, i3.pbrMetallicRoughness.roughnessFactor = 1, O.warnOnce("Meshes exported to GLTF without MeshMaterialMetallicRoughness material will appear different when imported back.");
    const o5 = this.gltf.materials.length;
    return this.gltf.materials.push(i3), this._materialMap.push(e4), o5;
  }
  _addTexture(e4) {
    var _a;
    const s5 = (_a = this.gltf.textures) != null ? _a : [];
    return this.gltf.textures = s5, r2(this._textureMap, e4, () => {
      const t4 = { sampler: this._addSampler(e4), source: this._addImage(e4) }, i3 = s5.length;
      return s5.push(t4), i3;
    });
  }
  _addImage(e4) {
    const t4 = this._imageMap.get(e4);
    if (null != t4)
      return t4;
    this.gltf.images || (this.gltf.images = []);
    const s5 = {};
    if (e4.url)
      s5.uri = e4.url;
    else {
      const t5 = e4.data;
      s5.extras = t5;
      for (let e5 = 0; e5 < this.gltf.images.length; ++e5)
        if (t5 === this.gltf.images[e5].extras)
          return e5;
      const i4 = this.gltf.extras;
      switch (i4.options.imageOutputType) {
        case A.GLB: {
          const e5 = i4.binChunkBuffer.addBufferView(C2.UNSIGNED_BYTE, L.SCALAR), r6 = o3(t5).then(({ data: e6, type: t6 }) => (s5.mimeType = t6, e6));
          e5.writeAsync(r6).then(() => {
            e5.finalize();
          }), s5.bufferView = e5.index;
          break;
        }
        case A.DataURI:
          s5.uri = i(t5);
          break;
        default:
          i4.promises.push(o3(t5).then(({ data: e5, type: t6 }) => {
            s5.uri = e5, s5.mimeType = t6;
          }));
      }
    }
    const i3 = this.gltf.images.length;
    return this.gltf.images.push(s5), this._imageMap.set(e4, i3), i3;
  }
  _addSampler(e4) {
    this.gltf.samplers || (this.gltf.samplers = []);
    let t4 = D.REPEAT, s5 = D.REPEAT;
    if ("string" == typeof e4.wrap)
      switch (e4.wrap) {
        case "clamp":
          t4 = D.CLAMP_TO_EDGE, s5 = D.CLAMP_TO_EDGE;
          break;
        case "mirror":
          t4 = D.MIRRORED_REPEAT, s5 = D.MIRRORED_REPEAT;
      }
    else {
      switch (e4.wrap.vertical) {
        case "clamp":
          s5 = D.CLAMP_TO_EDGE;
          break;
        case "mirror":
          s5 = D.MIRRORED_REPEAT;
      }
      switch (e4.wrap.horizontal) {
        case "clamp":
          t4 = D.CLAMP_TO_EDGE;
          break;
        case "mirror":
          t4 = D.MIRRORED_REPEAT;
      }
    }
    const i3 = { wrapS: t4, wrapT: s5 };
    for (let a2 = 0; a2 < this.gltf.samplers.length; ++a2)
      if (JSON.stringify(i3) === JSON.stringify(this.gltf.samplers[a2]))
        return a2;
    const r6 = this.gltf.samplers.length;
    return this.gltf.samplers.push(i3), r6;
  }
  _addAccessor(e4, t4) {
    this.gltf.accessors || (this.gltf.accessors = []);
    const s5 = { bufferView: e4, byteOffset: t4.byteOffset, componentType: t4.componentType, count: t4.count, type: t4.type, min: t4.min, max: t4.max, name: t4.name };
    t4.normalized && (s5.normalized = true);
    const i3 = this.gltf.accessors.length;
    return this.gltf.accessors.push(s5), i3;
  }
  _addMeshVertexIndexed(e4, t4, s5, i3, r6, a2, o5, n2) {
    for (const l3 of t4) {
      e4.startAccessor("INDICES");
      for (let s6 = 0; s6 < l3.faces.length; ++s6)
        e4.push(l3.faces[s6]);
      const t5 = e4.endAccessor(), c3 = { attributes: { POSITION: i3 }, indices: this._addAccessor(e4.index, t5), material: this._addMaterial(l3.material) };
      r6 && "flat" !== l3.shading && (c3.attributes.NORMAL = r6), a2 && (c3.attributes.TEXCOORD_0 = a2), o5 && "flat" !== l3.shading && (c3.attributes.TANGENT = o5), n2 && (c3.attributes.COLOR_0 = n2), s5.primitives.push(c3);
    }
  }
  _addMeshVertexNonIndexed(e4, t4, s5, i3, r6, a2, o5) {
    const n2 = { attributes: { POSITION: s5 } };
    i3 && (n2.attributes.NORMAL = i3), r6 && (n2.attributes.TEXCOORD_0 = r6), a2 && (n2.attributes.TANGENT = a2), o5 && (n2.attributes.COLOR_0 = o5), e4 && (n2.material = this._addMaterial(e4[0].material)), t4.primitives.push(n2);
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/asset.js
var s3 = class {
  constructor() {
    this.copyright = "", this.defaultScene = 0, this.generator = "", this._scenes = [];
  }
  addScene(e4) {
    if (this._scenes.includes(e4))
      throw new Error("Scene already added");
    this._scenes.push(e4);
  }
  removeScene(s5) {
    C(this._scenes, s5);
  }
  forEachScene(e4) {
    this._scenes.forEach(e4);
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/scene.js
var d = class {
  constructor() {
    this.name = "", this._nodes = [];
  }
  addNode(d2) {
    if (this._nodes.includes(d2))
      throw new Error("Node already added");
    this._nodes.push(d2);
  }
  forEachNode(d2) {
    this._nodes.forEach(d2);
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/node.js
var i2 = class {
  constructor(s5) {
    this.mesh = s5, this.name = "", this.translation = n(), this.rotation = e2(), this.scale = t2(l), this._nodes = [];
  }
  addNode(s5) {
    if (this._nodes.includes(s5))
      throw new Error("Node already added");
    this._nodes.push(s5);
  }
  forEachNode(s5) {
    this._nodes.forEach(s5);
  }
  set rotationAngles(t4) {
    k(this.rotation, t4[0], t4[1], t4[2]);
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/index.js
var f3 = "model.gltf";
var p2 = "model.glb";
function a(a2, m3, c3) {
  var _a, _b;
  const l3 = new w2(a2, m3 = m3 || {}, c3);
  let g2 = l3.params;
  g2 ? g2.origin || (g2.origin = new w({ x: -1, y: -1, z: -1 })) : g2 = { origin: new w({ x: -1, y: -1, z: -1 }) };
  const y = g2.origin, d2 = l3.gltf, j = (_b = (_a = d2.extras) == null ? void 0 : _a.promises) != null ? _b : [];
  let x2 = 1, b = 1, B = null;
  return E(j).then(() => {
    const e4 = { origin: y };
    delete d2.extras;
    const t4 = "number" == typeof m3.jsonSpacing ? m3.jsonSpacing : 4, o5 = JSON.stringify(d2, (t5, r6) => {
      if ("extras" !== t5) {
        if (r6 instanceof ArrayBuffer) {
          if (g(r6))
            switch (m3.imageOutputType) {
              case A.DataURI:
              case A.GLB:
                break;
              case A.External:
              default: {
                const t6 = `img${b}.png`;
                return b++, e4[t6] = r6, t6;
              }
            }
          switch (m3.bufferOutputType) {
            case E2.DataURI:
              return s2(r6);
            case E2.GLB:
              if (B)
                throw new Error("Already encountered an ArrayBuffer, there should only be one in the GLB format.");
              return void (B = r6);
            case E2.External:
            default: {
              const t6 = `data${x2}.bin`;
              return x2++, e4[t6] = r6, t6;
            }
          }
        }
        return r6;
      }
    }, t4);
    return m3.bufferOutputType === E2.GLB || m3.imageOutputType === A.GLB ? e4[p2] = new e3(o5, B).buffer : e4[f3] = o5, e4;
  });
}
function m2(e4, t4) {
  return a(e4, { bufferOutputType: E2.GLB, imageOutputType: A.GLB, jsonSpacing: 0 }, t4);
}

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/gltfexport.js
var s4 = class {
  constructor(e4, o5) {
    this._file = { type: "model/gltf-binary", data: e4 }, this.origin = o5;
  }
  buffer() {
    return Promise.resolve(this._file);
  }
  download(o5) {
    it(new Blob([this._file.data], { type: this._file.type }), o5);
  }
};
function f4(e4, f5) {
  const d2 = new s3(), l3 = new d();
  return d2.addScene(l3), l3.addNode(new i2(e4)), m2(d2, f5).then((e5) => new s4(e5[p2], e5.origin));
}
export {
  f4 as toBinaryGLTF
};
//# sourceMappingURL=gltfexport-IY26QB6H.js.map
