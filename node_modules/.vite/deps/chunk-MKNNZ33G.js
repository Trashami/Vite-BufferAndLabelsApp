import {
  e
} from "./chunk-QWNKYSI4.js";
import {
  v as v2
} from "./chunk-OOLCFNXJ.js";
import {
  A,
  C,
  a,
  d,
  v
} from "./chunk-MJXQTGI2.js";
import {
  r,
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/views/support/QueueProcessor.js
var u = class {
  constructor(e2, s) {
    this.item = e2, this.controller = s, this.promise = null;
  }
};
var l = class {
  constructor(s) {
    this._deferreds = /* @__PURE__ */ new Map(), this._controllers = /* @__PURE__ */ new Map(), this._processingItems = /* @__PURE__ */ new Map(), this._isPaused = false, this._schedule = null, this._task = null, this.concurrency = 1, s.concurrency && (this.concurrency = s.concurrency), this._queue = new e(s.peeker), this.process = s.process;
    const t2 = s.scheduler;
    s.priority && r(t2) && (this._task = t2.registerTask(s.priority, this));
  }
  destroy() {
    this.clear(), this._schedule && (this._schedule.remove(), this._schedule = null), this._task && (this._task.remove(), this._task = null);
  }
  get length() {
    return this._processingItems.size + this._queue.length;
  }
  abort(e2) {
    const s = this._controllers.get(e2);
    s && s.abort();
  }
  clear() {
    this._queue.clear();
    const e2 = [];
    this._controllers.forEach((s) => e2.push(s)), this._controllers.clear(), e2.forEach((e3) => e3.abort()), this._processingItems.clear(), this._cancelNext();
  }
  forEach(e2) {
    this._deferreds.forEach((s, t2) => e2(t2));
  }
  get(e2) {
    const s = this._deferreds.get(e2);
    return s ? s.promise : void 0;
  }
  isOngoing(e2) {
    return this._processingItems.has(e2);
  }
  has(e2) {
    return this._deferreds.has(e2);
  }
  pause() {
    this._isPaused || (this._isPaused = true, this._cancelNext());
  }
  push(s, h) {
    const c = this.get(s);
    if (c)
      return c;
    const n = new AbortController();
    let u2 = null;
    h && (u2 = v(h, () => n.abort()));
    const l2 = () => {
      const e2 = this._processingItems.get(s);
      e2 && e2.controller.abort(), _(), a2.reject(a());
    }, _ = () => {
      p.remove(), r(u2) && u2.remove(), this._deferreds.delete(s), this._controllers.delete(s), this._queue.remove(s), this._processingItems.delete(s), this._scheduleNext();
    }, p = d(n.signal, l2), a2 = A();
    return this._deferreds.set(s, a2), this._controllers.set(s, n), a2.promise.then(_, _), this._queue.push(s), this._scheduleNext(), a2.promise;
  }
  last() {
    return this._queue.last();
  }
  peek() {
    return this._queue.peek();
  }
  popLast() {
    return this._queue.popLast();
  }
  reset() {
    const e2 = [];
    this._processingItems.forEach((s) => e2.push(s)), this._processingItems.clear();
    for (const s of e2)
      this._queue.push(s.item), s.controller.abort();
    this._scheduleNext();
  }
  resume() {
    this._isPaused && (this._isPaused = false, this._scheduleNext());
  }
  takeAll() {
    const e2 = [];
    for (; this._queue.length; )
      e2.push(this._queue.pop());
    return this.clear(), e2;
  }
  get running() {
    return !this._isPaused && this._queue.length > 0 && this._processingItems.size < this.concurrency;
  }
  runTask(e2) {
    for (; !e2.done && this._queue.length > 0 && this._processingItems.size < this.concurrency; )
      this._process(this._queue.pop()), e2.madeProgress();
  }
  _scheduleNext() {
    this._task || this._isPaused || this._schedule || (this._schedule = v2(() => {
      this._schedule = null, this._next();
    }));
  }
  _next() {
    for (; this._queue.length > 0 && this._processingItems.size < this.concurrency; )
      this._process(this._queue.pop());
  }
  _cancelNext() {
    this._schedule && (this._schedule.remove(), this._schedule = null);
  }
  _processResult(e2, s) {
    this._canProcessFulfillment(e2) && (this._scheduleNext(), this._deferreds.get(e2.item).resolve(s));
  }
  _processError(e2, s) {
    this._canProcessFulfillment(e2) && (this._scheduleNext(), this._deferreds.get(e2.item).reject(s));
  }
  _canProcessFulfillment(e2) {
    return !!this._deferreds.get(e2.item) && this._processingItems.get(e2.item) === e2;
  }
  _process(e2) {
    if (t(e2))
      return;
    let t2;
    const r2 = new AbortController(), i = new u(e2, r2);
    this._processingItems.set(e2, i);
    try {
      t2 = this.process(e2, r2.signal);
    } catch (o) {
      this._processError(i, o);
    }
    C(t2) ? (i.promise = t2, t2.then((e3) => this._processResult(i, e3), (e3) => this._processError(i, e3))) : this._processResult(i, t2);
  }
  get test() {
    return { update: (e2) => this.runTask(e2) };
  }
};

export {
  l
};
//# sourceMappingURL=chunk-MKNNZ33G.js.map
