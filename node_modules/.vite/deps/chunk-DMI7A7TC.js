import {
  s as s3
} from "./chunk-ZHAW7FZS.js";
import {
  A,
  Bt,
  D,
  E,
  F,
  H,
  I,
  J,
  St,
  V,
  W,
  X,
  b,
  j as j2,
  mt,
  z
} from "./chunk-KAN4HXCG.js";
import {
  a,
  j,
  p,
  v
} from "./chunk-MJXQTGI2.js";
import {
  s as s2
} from "./chunk-LIZHLHNA.js";
import {
  s
} from "./chunk-UA3YPL2R.js";
import {
  has,
  y
} from "./chunk-HVKDYDPP.js";
import {
  e,
  r
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/portal/support/urlUtils.js
var e2 = /^https:\/\/([a-z\d-]+)(\.maps([^.]*))?\.arcgis\.com/i;
var s4 = { devext: { customBaseUrl: "mapsdevext.arcgis.com", portalHostname: "devext.arcgis.com" }, qaext: { customBaseUrl: "mapsqa.arcgis.com", portalHostname: "qaext.arcgis.com" }, www: { customBaseUrl: "maps.arcgis.com", portalHostname: "www.arcgis.com" } };
function a2(a4) {
  const t3 = a4 == null ? void 0 : a4.match(e2);
  if (!t3)
    return null;
  const [, r3, o, l] = t3;
  if (!r3)
    return null;
  let c2 = null, m2 = null, n = null;
  const { devext: u2, qaext: i, www: p2 } = s4;
  if (o)
    if (c2 = r3, l)
      switch (l.toLowerCase()) {
        case "devext":
          ({ customBaseUrl: m2, portalHostname: n } = u2);
          break;
        case "qa":
          ({ customBaseUrl: m2, portalHostname: n } = i);
          break;
        default:
          return null;
      }
    else
      ({ customBaseUrl: m2, portalHostname: n } = p2);
  else
    switch (r3.toLowerCase()) {
      case "devext":
        ({ customBaseUrl: m2, portalHostname: n } = u2);
        break;
      case "qaext":
        ({ customBaseUrl: m2, portalHostname: n } = i);
        break;
      case "www":
        ({ customBaseUrl: m2, portalHostname: n } = p2);
        break;
      default:
        return null;
    }
  return { customBaseUrl: m2, isPortal: false, portalHostname: n, urlKey: c2 };
}
function t(e3) {
  return /\/(sharing|usrsvcs)\/(appservices|servers)\//i.test(e3);
}

// node_modules/@arcgis/core/support/apiKeyUtils.js
var t2 = ["elevation3d.arcgis.com", "js.arcgis.com", "jsdev.arcgis.com", "jsqa.arcgis.com", "static.arcgis.com"];
function r2(c2) {
  const r3 = H(c2, true);
  return !!r3 && (r3.endsWith(".arcgis.com") && !t2.includes(r3) && !c2.endsWith("/sharing/rest/generateToken"));
}

// node_modules/@arcgis/core/support/requestUtils.js
function c(r3, t3, n = false, s5) {
  return new Promise((i, c2) => {
    if (p(s5))
      return void c2(a3());
    let m2 = () => {
      f(), c2(new Error(`Unable to load ${t3}`));
    }, u2 = () => {
      const e3 = r3;
      f(), i(e3);
    }, d2 = () => {
      if (!r3)
        return;
      const e3 = r3;
      f(), e3.src = "", c2(a3());
    };
    const f = () => {
      has("esri-image-decode") || (r3.removeEventListener("error", m2), r3.removeEventListener("load", u2)), m2 = null, u2 = null, r3 = null, r(s5) && s5.removeEventListener("abort", d2), d2 = null, n && URL.revokeObjectURL(t3);
    };
    r(s5) && s5.addEventListener("abort", d2), has("esri-image-decode") ? r3.decode().then(u2, m2) : (r3.addEventListener("error", m2), r3.addEventListener("load", u2));
  });
}
function a3() {
  try {
    return new DOMException("Aborted", "AbortError");
  } catch {
    const r3 = new Error();
    return r3.name = "AbortError", r3;
  }
}
function m(e3) {
  var _a, _b, _c;
  s.request.crossOriginNoCorsDomains || (s.request.crossOriginNoCorsDomains = {});
  const o = s.request.crossOriginNoCorsDomains;
  for (let r3 of e3)
    r3 = r3.toLowerCase(), /^https?:\/\//.test(r3) ? o[(_a = H(r3)) != null ? _a : ""] = 0 : (o[(_b = H("http://" + r3)) != null ? _b : ""] = 0, o[(_c = H("https://" + r3)) != null ? _c : ""] = 0);
}
function u(e3) {
  const o = s.request.crossOriginNoCorsDomains;
  if (o) {
    let r3 = H(e3);
    if (r3)
      return r3 = r3.toLowerCase(), !z(r3, b()) && o[r3] < Date.now() - 36e5;
  }
  return false;
}
async function d(e3) {
  var _a;
  const o = s.request.crossOriginNoCorsDomains, n = H(e3);
  o && n && (o[n.toLowerCase()] = Date.now());
  const s5 = j2(e3);
  e3 = s5.path, "json" === ((_a = s5.query) == null ? void 0 : _a.f) && (e3 += "?f=json");
  try {
    await fetch(e3, { mode: "no-cors", credentials: "include" });
  } catch {
  }
}

// node_modules/@arcgis/core/request.js
async function U(e3, r3) {
  var _a;
  const t3 = X(e3), s5 = V(e3);
  s5 || t3 || (e3 = F(e3));
  const n = { url: e3, requestOptions: { ...e(r3) } };
  let i = W(e3);
  if (i) {
    const e4 = await G(i, n);
    if (null != e4)
      return { data: e4, getHeader: M, requestOptions: n.requestOptions, url: n.url };
    i.after || i.error || (i = null);
  }
  if (e3 = n.url, "image" === (r3 = n.requestOptions).responseType) {
    if (has("host-webworker") || has("host-node"))
      throw N("request:invalid-parameters", new Error("responseType 'image' is not supported in Web Workers or Node environment"), n);
  } else if (t3)
    throw N("request:invalid-parameters", new Error("Data URLs are not supported for responseType = " + r3.responseType), n);
  if ("head" === r3.method) {
    if (r3.body)
      throw N("request:invalid-parameters", new Error("body parameter cannot be set when method is 'head'"), n);
    if (t3 || s5)
      throw N("request:invalid-parameters", new Error("data and blob URLs are not supported for method 'head'"), n);
  }
  if (await B(), j3)
    return j3.execute(e3, r3);
  const l = new AbortController();
  v(r3, () => l.abort());
  const m2 = { controller: l, credential: void 0, credentialToken: void 0, fetchOptions: void 0, hasToken: false, interceptor: i, params: n, redoRequest: false, useIdentity: P.useIdentity, useProxy: false, useSSL: false, withCredentials: false }, h = await Q(m2);
  return (_a = i == null ? void 0 : i.after) == null ? void 0 : _a.call(i, h), h;
}
var j3;
var P = s.request;
var D2 = "FormData" in globalThis;
var _ = [499, 498, 403, 401];
var F2 = ["COM_0056", "COM_0057", "SB_0008"];
var I2 = [/\/arcgis\/tokens/i, /\/sharing(\/rest)?\/generatetoken/i, /\/rest\/info/i];
var M = () => null;
var R = Symbol();
function A2(e3) {
  const r3 = H(e3);
  r3 && !U._corsServers.includes(r3) && U._corsServers.push(r3);
}
function H2(e3) {
  const r3 = H(e3);
  return !r3 || r3.endsWith(".arcgis.com") || U._corsServers.includes(r3) || D(r3);
}
function N(e3, r3, o, a4) {
  let l = "Error";
  const u2 = { url: o.url, requestOptions: o.requestOptions, getHeader: M, ssl: false };
  if (r3 instanceof s2)
    return r3.details ? (r3.details = y(r3.details), r3.details.url = o.url, r3.details.requestOptions = o.requestOptions) : r3.details = u2, r3;
  if (r3) {
    const e4 = a4 && ((e5) => a4.headers.get(e5)), t3 = a4 && a4.status, s5 = r3.message;
    s5 && (l = s5), e4 && (u2.getHeader = e4), u2.httpStatus = (null != r3.httpCode ? r3.httpCode : r3.code) || t3 || 0, u2.subCode = r3.subcode, u2.messageCode = r3.messageCode, "string" == typeof r3.details ? u2.messages = [r3.details] : u2.messages = r3.details, u2.raw = R in r3 ? r3[R] : r3;
  }
  return j(r3) ? a() : new s2(e3, l, u2);
}
async function B() {
  has("host-webworker") ? j3 || (j3 = await import("./request-MBAKQFXA.js")) : U._abortableFetch || (U._abortableFetch = globalThis.fetch.bind(globalThis));
}
async function $() {
  s3 || await import("./IdentityManager-V3VLR2T2.js");
}
async function z2(t3) {
  var _a;
  const s5 = t3.params.url, o = t3.params.requestOptions, a4 = t3.controller.signal, n = o.body;
  let i = null, u2 = null;
  if (D2 && "HTMLFormElement" in globalThis && (n instanceof FormData ? i = n : n instanceof HTMLFormElement && (i = new FormData(n))), "string" == typeof n && (u2 = n), t3.fetchOptions = { cache: o.cacheBust && !U._abortableFetch.polyfill ? "no-cache" : "default", credentials: "same-origin", headers: o.headers || {}, method: "head" === o.method ? "HEAD" : "GET", mode: "cors", priority: P.priority, redirect: "follow", signal: a4 }, (i || u2) && (t3.fetchOptions.body = i || u2), "anonymous" === o.authMode && (t3.useIdentity = false), t3.hasToken = !!(/token=/i.test(s5) || ((_a = o.query) == null ? void 0 : _a.token) || (i == null ? void 0 : i.get("token"))), !t3.hasToken && s.apiKey && r2(s5) && (o.query || (o.query = {}), o.query.token = s.apiKey, t3.hasToken = true), t3.useIdentity && !t3.hasToken && !t3.credentialToken && !K(s5) && !p(a4)) {
    let e3;
    "immediate" === o.authMode ? (await $(), e3 = await s3.getCredential(s5, { signal: a4 }), t3.credential = e3) : "no-prompt" === o.authMode ? (await $(), e3 = await s3.getCredential(s5, { prompt: false, signal: a4 }).catch(() => {
    }), t3.credential = e3) : s3 && (e3 = s3.findCredential(s5)), e3 && (t3.credentialToken = e3.token, t3.useSSL = !!e3.ssl);
  }
}
function K(e3) {
  return I2.some((r3) => r3.test(e3));
}
async function W2(e3) {
  var _a, _b;
  let t3 = e3.params.url;
  const s5 = e3.params.requestOptions, o = (_a = e3.fetchOptions) != null ? _a : {}, a4 = V(t3) || X(t3), n = s5.responseType || "json", l = a4 ? 0 : null != s5.timeout ? s5.timeout : P.timeout;
  let d2 = false;
  if (!a4) {
    e3.useSSL && (t3 = mt(t3)), s5.cacheBust && "default" === o.cache && (t3 = St(t3, "request.preventCache", Date.now()));
    let a5 = { ...s5.query };
    e3.credentialToken && (a5.token = e3.credentialToken);
    let n2 = I(a5);
    has("esri-url-encodes-apostrophe") && (n2 = n2.replace(/'/g, "%27"));
    const i = t3.length + 1 + n2.length;
    let l2;
    d2 = "delete" === s5.method || "post" === s5.method || "put" === s5.method || !!s5.body || i > P.maxUrlLength;
    const u2 = s5.useProxy || !!J(t3);
    if (u2) {
      const e4 = A(t3);
      l2 = e4.path, !d2 && l2.length + 1 + i > P.maxUrlLength && (d2 = true), e4.query && (a5 = { ...e4.query, ...a5 });
    }
    if ("HEAD" === o.method && (d2 || u2)) {
      if (d2) {
        if (i > P.maxUrlLength)
          throw N("request:invalid-parameters", new Error("URL exceeds maximum length"), e3.params);
        throw N("request:invalid-parameters", new Error("cannot use POST request when method is 'head'"), e3.params);
      }
      if (u2)
        throw N("request:invalid-parameters", new Error("cannot use proxy when method is 'head'"), e3.params);
    }
    if (d2 ? (o.method = "delete" === s5.method ? "DELETE" : "put" === s5.method ? "PUT" : "POST", s5.body ? t3 = Bt(t3, a5) : (o.body = I(a5), o.headers || (o.headers = {}), o.headers["Content-Type"] = "application/x-www-form-urlencoded")) : t3 = Bt(t3, a5), u2 && (e3.useProxy = true, t3 = `${l2}?${t3}`), a5.token && D2 && o.body instanceof FormData && !t(t3) && o.body.set("token", a5.token), s5.hasOwnProperty("withCredentials"))
      e3.withCredentials = s5.withCredentials;
    else if (!z(t3, b())) {
      if (D(t3))
        e3.withCredentials = true;
      else if (s3) {
        const s6 = s3.findServerInfo(t3);
        s6 && s6.webTierAuth && (e3.withCredentials = true);
      }
    }
    e3.withCredentials && (o.credentials = "include", u(t3) && await d(d2 ? Bt(t3, a5) : t3));
  }
  let p2, v2, C = 0, L = false;
  l > 0 && (C = setTimeout(() => {
    L = true, e3.controller.abort();
  }, l));
  try {
    if ("native-request-init" === s5.responseType)
      v2 = o, v2.url = t3;
    else if ("image" !== s5.responseType || "default" !== o.cache || "GET" !== o.method || d2 || J2(s5.headers) || !a4 && !e3.useProxy && P.proxyUrl && !H2(t3)) {
      if (p2 = await U._abortableFetch(t3, o), e3.useProxy || A2(t3), "native" === s5.responseType)
        v2 = p2;
      else if ("HEAD" !== o.method)
        if (p2.ok) {
          switch (n) {
            case "array-buffer":
              v2 = await p2.arrayBuffer();
              break;
            case "blob":
            case "image":
              v2 = await p2.blob();
              break;
            default:
              v2 = await p2.text();
          }
          if (C && (clearTimeout(C), C = 0), "json" === n || "xml" === n || "document" === n)
            if (v2)
              switch (n) {
                case "json":
                  v2 = JSON.parse(v2);
                  break;
                case "xml":
                  v2 = X2(v2, "application/xml");
                  break;
                case "document":
                  v2 = X2(v2, "text/html");
              }
            else
              v2 = null;
          if (v2) {
            if ("array-buffer" === n || "blob" === n) {
              const e4 = p2.headers.get("Content-Type");
              if (e4 && /application\/json|text\/plain/i.test(e4) && v2["blob" === n ? "size" : "byteLength"] <= 750)
                try {
                  const e5 = await new Response(v2).json();
                  e5.error && (v2 = e5);
                } catch {
                }
            }
            "image" === n && v2 instanceof Blob && (v2 = await Y(URL.createObjectURL(v2), e3, true));
          }
        } else
          v2 = await p2.text();
    } else
      v2 = await Y(t3, e3);
  } catch (j4) {
    if ("AbortError" === j4.name) {
      if (L)
        throw new Error("Timeout exceeded");
      throw a("Request canceled");
    }
    if (!(!p2 && j4 instanceof TypeError && P.proxyUrl) || s5.body || "delete" === s5.method || "head" === s5.method || "post" === s5.method || "put" === s5.method || e3.useProxy || H2(t3))
      throw j4;
    e3.redoRequest = true, E({ proxyUrl: P.proxyUrl, urlPrefix: (_b = H(t3)) != null ? _b : "" });
  } finally {
    C && clearTimeout(C);
  }
  return [p2, v2];
}
async function G(e3, r3) {
  if (null != e3.responseData)
    return e3.responseData;
  if (e3.headers && (r3.requestOptions.headers = { ...r3.requestOptions.headers, ...e3.headers }), e3.query && (r3.requestOptions.query = { ...r3.requestOptions.query, ...e3.query }), e3.before) {
    let o, a4;
    try {
      a4 = await e3.before(r3);
    } catch (s5) {
      o = N("request:interceptor", s5, r3);
    }
    if ((a4 instanceof Error || a4 instanceof s2) && (o = N("request:interceptor", a4, r3)), o)
      throw e3.error && e3.error(o), o;
    return a4;
  }
}
function J2(e3) {
  if (e3) {
    for (const r3 of Object.getOwnPropertyNames(e3))
      if (e3[r3])
        return true;
  }
  return false;
}
function X2(e3, r3) {
  let t3;
  try {
    t3 = new DOMParser().parseFromString(e3, r3);
  } catch {
  }
  if (!t3 || t3.getElementsByTagName("parsererror").length)
    throw new SyntaxError("XML Parse error");
  return t3;
}
async function Q(e3) {
  var _a;
  let t3, s5;
  await z2(e3);
  try {
    do {
      [t3, s5] = await W2(e3);
    } while (!await V2(e3, t3, s5));
  } catch (n) {
    const r3 = N("request:server", n, e3.params, t3);
    throw r3.details.ssl = e3.useSSL, e3.interceptor && e3.interceptor.error && e3.interceptor.error(r3), r3;
  }
  const o = e3.params.url;
  if (s5 && /\/sharing\/rest\/(accounts|portals)\/self/i.test(o)) {
    if (!e3.hasToken && !e3.credentialToken && ((_a = s5.user) == null ? void 0 : _a.username) && !D(o)) {
      const e4 = H(o, true);
      e4 && P.trustedServers.push(e4);
    }
    Array.isArray(s5.authorizedCrossOriginNoCorsDomains) && m(s5.authorizedCrossOriginNoCorsDomains);
  }
  const a4 = e3.credential;
  if (a4 && s3) {
    const e4 = s3.findServerInfo(a4.server);
    let t4 = e4 && e4.owningSystemUrl;
    if (t4) {
      t4 = t4.replace(/\/?$/, "/sharing");
      const e5 = s3.findCredential(t4, a4.userId);
      e5 && -1 === s3._getIdenticalSvcIdx(t4, e5) && e5.resources.unshift(t4);
    }
  }
  return { data: s5, getHeader: t3 ? (e4) => t3 == null ? void 0 : t3.headers.get(e4) : M, requestOptions: e3.params.requestOptions, ssl: e3.useSSL, url: e3.params.url };
}
async function V2(e3, t3, s5) {
  if (e3.redoRequest)
    return e3.redoRequest = false, false;
  const o = e3.params.requestOptions;
  if (!t3 || "native" === o.responseType || "native-request-init" === o.responseType)
    return true;
  let a4, n;
  if (!t3.ok)
    throw a4 = new Error(`Unable to load ${t3.url} status: ${t3.status}`), a4[R] = s5, a4;
  s5 && (s5.error ? a4 = s5.error : "error" === s5.status && Array.isArray(s5.messages) && (a4 = { ...s5 }, a4[R] = s5, a4.details = s5.messages));
  let i, l = null;
  a4 && (n = Number(a4.code), l = a4.hasOwnProperty("subcode") ? Number(a4.subcode) : null, i = a4.messageCode, i = i && i.toUpperCase());
  const u2 = o.authMode;
  if (403 === n && (4 === l || a4.message && a4.message.toLowerCase().includes("ssl") && !a4.message.toLowerCase().includes("permission"))) {
    if (!e3.useSSL)
      return e3.useSSL = true, false;
  } else if (!e3.hasToken && e3.useIdentity && ("no-prompt" !== u2 || 498 === n) && void 0 !== n && _.includes(n) && !K(e3.params.url) && (403 !== n || i && !F2.includes(i) && (null == l || 2 === l && e3.credentialToken))) {
    await $();
    try {
      const t4 = await s3.getCredential(e3.params.url, { error: N("request:server", a4, e3.params), prompt: "no-prompt" !== u2, signal: e3.controller.signal, token: e3.credentialToken });
      return e3.credential = t4, e3.credentialToken = t4.token, e3.useSSL = e3.useSSL || t4.ssl, false;
    } catch (c2) {
      if ("no-prompt" === u2)
        return e3.credential = void 0, e3.credentialToken = void 0, false;
      a4 = c2;
    }
  }
  if (a4)
    throw a4;
  return true;
}
function Y(e3, r3, t3 = false) {
  const s5 = r3.controller.signal, o = new Image();
  return r3.withCredentials ? o.crossOrigin = "use-credentials" : o.crossOrigin = "anonymous", o.alt = "", o.fetchPriority = P.priority, o.src = e3, c(o, e3, t3, s5);
}
U._abortableFetch = null, U._corsServers = ["https://server.arcgisonline.com", "https://services.arcgisonline.com"];

export {
  a2 as a,
  t,
  r2 as r,
  c,
  U
};
//# sourceMappingURL=chunk-DMI7A7TC.js.map
