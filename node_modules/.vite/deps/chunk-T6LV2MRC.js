import {
  g,
  u2
} from "./chunk-5OCDKMG5.js";
import {
  e as e2
} from "./chunk-QFWDN2OM.js";
import {
  a
} from "./chunk-372DRRBO.js";
import {
  r
} from "./chunk-X7GQR2IY.js";
import {
  t
} from "./chunk-RNRS2JL4.js";
import {
  h
} from "./chunk-SBPLVEUA.js";
import {
  u
} from "./chunk-3IISYLTT.js";
import {
  v
} from "./chunk-7QNA4ADD.js";
import {
  e
} from "./chunk-C6PUUIY2.js";
import {
  o as o2
} from "./chunk-735C75BI.js";
import {
  n,
  o
} from "./chunk-ZLTZ3KAT.js";
import {
  O
} from "./chunk-RUM3DXFX.js";

// node_modules/@arcgis/core/chunks/NativeLine.glsl.js
function u3(u4) {
  const v3 = new o(), { vertex: h2, fragment: w } = v3;
  return v3.include(r, u4), v3.include(e2, u4), v3.include(u2, u4), v(h2, u4), u4.stippleEnabled && (v3.attributes.add(O.UV0, "vec2"), v3.attributes.add(O.AUXPOS1, "vec3"), h2.uniforms.add(new e("viewport", (e3, o3) => o3.camera.fullViewport))), v3.attributes.add(O.POSITION, "vec3"), v3.varyings.add("vpos", "vec3"), h2.code.add(n`void main(void) {
vpos = position;
forwardNormalizedVertexColor();
gl_Position = transformPosition(proj, view, vpos);`), u4.stippleEnabled && (h2.code.add(n`vec4 vpos2 = transformPosition(proj, view, auxpos1);
vec2 ndcToPixel = viewport.zw * 0.5;
float lineSegmentPixelSize = length((vpos2.xy / vpos2.w - gl_Position.xy / gl_Position.w) * ndcToPixel);`), u4.draped ? h2.uniforms.add(new o2("worldToScreenRatio", (e3, o3) => 1 / o3.screenToPCSRatio)) : h2.code.add(n`vec3 segmentCenter = (position + auxpos1) * 0.5;
float worldToScreenRatio = computeWorldToScreenRatio(segmentCenter);`), h2.code.add(n`float discreteWorldToScreenRatio = discretizeWorldToScreenRatio(worldToScreenRatio);`), u4.draped ? h2.code.add(n`float startPseudoScreen = uv0.y * discreteWorldToScreenRatio - mix(0.0, lineSegmentPixelSize, uv0.x);
float segmentLengthPseudoScreen = lineSegmentPixelSize;`) : h2.code.add(n`float segmentLengthRender = length(position - auxpos1);
float startPseudoScreen = mix(uv0.y, uv0.y - segmentLengthRender, uv0.x) * discreteWorldToScreenRatio;
float segmentLengthPseudoScreen = segmentLengthRender * discreteWorldToScreenRatio;`), h2.uniforms.add(new o2("stipplePatternPixelSize", (e3) => g(e3))), h2.code.add(n`vec2 stippleDistanceLimits = computeStippleDistanceLimits(startPseudoScreen, segmentLengthPseudoScreen, lineSegmentPixelSize, stipplePatternPixelSize);
vStippleDistance = mix(stippleDistanceLimits.x, stippleDistanceLimits.y, uv0.x);
vStippleDistance *= gl_Position.w;`)), h2.code.add(n`}`), u4.output === h.Highlight && v3.include(a, u4), v3.include(u, u4), w.uniforms.add(new o2("alphaCoverage", (e3, o3) => Math.min(1, e3.width * o3.camera.pixelRatio))), u4.hasVertexColors || w.uniforms.add(new e("constantColor", (e3) => e3.color)), w.code.add(n`
  void main() {
    discardBySlice(vpos);

    vec4 color = ${u4.hasVertexColors ? "vColor" : "constantColor"};

    float stippleAlpha = getStippleAlpha();
    discardByStippleAlpha(stippleAlpha, stippleAlphaColorDiscard);

    vec4 finalColor = blendStipple(vec4(color.rgb, color.a * alphaCoverage), stippleAlpha);

    if (finalColor.a < ${n.float(t)}) {
      discard;
    }

    ${u4.output === h.Color ? n`gl_FragColor = highlightSlice(finalColor, vpos);` : ""}
    ${u4.output === h.Highlight ? n`outputHighlight();` : ""}
  }
  `), v3;
}
var v2 = Object.freeze(Object.defineProperty({ __proto__: null, build: u3 }, Symbol.toStringTag, { value: "Module" }));

export {
  u3 as u,
  v2 as v
};
//# sourceMappingURL=chunk-T6LV2MRC.js.map
