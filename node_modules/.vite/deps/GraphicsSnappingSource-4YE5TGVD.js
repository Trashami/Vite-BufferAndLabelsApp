import {
  a as a3,
  r as r4
} from "./chunk-RU3WEQBN.js";
import "./chunk-GQHKPMYA.js";
import "./chunk-YBAOLQVA.js";
import {
  p
} from "./chunk-6TQO4FJO.js";
import {
  n as n2,
  r as r2,
  r2 as r3
} from "./chunk-77Z3U5HZ.js";
import {
  u
} from "./chunk-UFNJIQA6.js";
import "./chunk-Z5PNFOTJ.js";
import {
  Y
} from "./chunk-EQTVTD33.js";
import "./chunk-3XRZHFYO.js";
import "./chunk-IOZMLQTF.js";
import "./chunk-P5Y67HOZ.js";
import "./chunk-OP2HNSVZ.js";
import "./chunk-VRX4W75V.js";
import {
  a as a2,
  h as h2
} from "./chunk-2J2YGTXG.js";
import "./chunk-O5HVKKEP.js";
import "./chunk-IPJF6OUC.js";
import "./chunk-NWERINOI.js";
import "./chunk-OEFH2SLX.js";
import "./chunk-K3WMIXIE.js";
import "./chunk-I4YZGF7W.js";
import "./chunk-65ZBTSJX.js";
import {
  E,
  y as y3
} from "./chunk-C6BDJNUQ.js";
import "./chunk-FZSI6IGI.js";
import "./chunk-36RXM3AP.js";
import "./chunk-IIAN3QNN.js";
import {
  B
} from "./chunk-O7LTV6XN.js";
import "./chunk-4TWWY75O.js";
import "./chunk-SQSR6K2M.js";
import "./chunk-75RMBUYZ.js";
import {
  nt
} from "./chunk-TJ2I6XQT.js";
import "./chunk-EDHROVWI.js";
import {
  s
} from "./chunk-34YPGGJT.js";
import "./chunk-TWJNUVV2.js";
import "./chunk-NCXAKZRR.js";
import "./chunk-DUCSW4OU.js";
import "./chunk-WVDA5Z37.js";
import "./chunk-LT5KLTS5.js";
import "./chunk-SERWCSJG.js";
import "./chunk-RW4M3CI3.js";
import "./chunk-ZEEU5HOK.js";
import {
  An,
  _n,
  rn
} from "./chunk-FFVIDMFN.js";
import "./chunk-7Q5M7ANT.js";
import "./chunk-E52E6T7N.js";
import "./chunk-W62B63EU.js";
import "./chunk-N43PI2UO.js";
import {
  j
} from "./chunk-HUQX7WZO.js";
import "./chunk-ZWUEORSX.js";
import "./chunk-ZPYDYUP5.js";
import "./chunk-22F6X66Z.js";
import "./chunk-AIDV7EKX.js";
import "./chunk-FZQZIM7U.js";
import "./chunk-QEYOWTXD.js";
import "./chunk-CZBRZ6SU.js";
import "./chunk-KDO6J2FO.js";
import "./chunk-RT3T2K4S.js";
import "./chunk-WJCI2CGX.js";
import {
  a
} from "./chunk-REIQNAQW.js";
import "./chunk-OD3FDQCI.js";
import "./chunk-J2PJNRU7.js";
import "./chunk-56SPM3WK.js";
import "./chunk-XMZAPOBR.js";
import "./chunk-BLJKKR5D.js";
import "./chunk-ZGNCYHMZ.js";
import "./chunk-X2S4RQJ4.js";
import "./chunk-376OPXM4.js";
import "./chunk-DER356EU.js";
import "./chunk-TQEOEDAZ.js";
import "./chunk-SHFHZMHO.js";
import "./chunk-NRP45AHD.js";
import "./chunk-IWQ7452U.js";
import "./chunk-NAN5J6QS.js";
import "./chunk-B4DKBAM3.js";
import "./chunk-6M2AHKYV.js";
import "./chunk-SZIJNKCV.js";
import "./chunk-6O43OEU5.js";
import "./chunk-J2K7ZDSV.js";
import "./chunk-2UML3WQZ.js";
import "./chunk-KXVMEIWT.js";
import "./chunk-UDND2Z3V.js";
import "./chunk-JUVQV3R3.js";
import "./chunk-RAX2HD42.js";
import "./chunk-ZYRIJWLX.js";
import "./chunk-C5H57NTD.js";
import "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import "./chunk-YWAQYJRC.js";
import {
  i
} from "./chunk-B356PXLT.js";
import "./chunk-EHPBHJYZ.js";
import {
  v2
} from "./chunk-3MNMDUQZ.js";
import "./chunk-UWG37XSU.js";
import "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import "./chunk-HLM6QCL2.js";
import "./chunk-RXYULINL.js";
import {
  h,
  l
} from "./chunk-5NXILPDI.js";
import "./chunk-THVR7IAM.js";
import "./chunk-ZWJJTUFL.js";
import "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import "./chunk-KAN4HXCG.js";
import "./chunk-4FEGON7M.js";
import "./chunk-VWYWOOPX.js";
import "./chunk-M5VHU5LK.js";
import "./chunk-7QMMKGW4.js";
import {
  e,
  m,
  n2 as n,
  y
} from "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import {
  L,
  f,
  y as y2
} from "./chunk-MJXQTGI2.js";
import "./chunk-LIZHLHNA.js";
import "./chunk-BTUHYGXO.js";
import "./chunk-UA3YPL2R.js";
import "./chunk-HVKDYDPP.js";
import {
  v
} from "./chunk-6QC7MLLS.js";
import {
  r,
  t
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/GraphicsSnappingSource.js
var U = "graphics-collections";
var x = class extends a(m) {
  constructor(e2) {
    super(e2), this.availability = 1, this._sources = { multipoint: null, point: null, polygon: null, polyline: null }, this._loadedWkids = /* @__PURE__ */ new Set(), this._loadedWkts = /* @__PURE__ */ new Set(), this._pendingAdds = [], this._extrudedPolygonSymbolsCount = 0;
  }
  get updating() {
    return this.updatingHandles.updating;
  }
  get _hasZ() {
    const e2 = this.view;
    return r(e2) && "3d" === e2.type && "map-notes" !== this.layerSource.layer.type;
  }
  get _snappingElevationAligner() {
    const { view: e2 } = this, { layer: t2 } = this.layerSource, o = r(e2) && "3d" === e2.type;
    if (!o || "map-notes" === t2.type)
      return r2();
    const r5 = async (o2, r6) => (await y2(e2.whenLayerView(t2), r6)).elevationAlignPointsInFeatures(o2, r6);
    return r2(o, { elevationInfo: t2.elevationInfo, alignPointsInFeatures: r5, spatialReference: e2.spatialReference });
  }
  get _snappingElevationFilter() {
    const { view: e2 } = this, t2 = r(e2) && "3d" === e2.type && "map-notes" !== this.layerSource.layer.type;
    return r3(t2);
  }
  get _symbologySnappingFetcher() {
    const { view: e2 } = this, { layer: t2 } = this.layerSource, o = r(e2) && "3d" === e2.type, r5 = this._extrudedPolygonSymbolsCount > 0;
    return o && "map-notes" !== t2.type && r5 ? n2(r5, async (o2, r6) => {
      const s2 = await e2.whenLayerView(t2);
      return f(r6), s2.queryForSymbologySnapping({ candidates: o2, spatialReference: e2.spatialReference }, r6);
    }) : n2();
  }
  destroy() {
    for (const e2 of this._pendingAdds)
      e2.task.abort();
    this._pendingAdds.length = 0, this._mapSources((e2) => this._destroySource(e2));
  }
  initialize() {
    this.updatingHandles.add(() => this.getGraphicsLayers(), (e3) => {
      this.updatingHandles.removeHandles(U);
      for (const t3 of e3)
        this._addMany(t3.graphics.toArray()), this.handles.add([t3.on("graphic-update", (e4) => this._onGraphicUpdate(e4)), this.updatingHandles.addOnCollectionChange(() => t3.graphics, (e4) => this._onGraphicsChanged(e4))], U);
    }, h);
    const { view: e2 } = this, { layer: t2 } = this.layerSource;
    r(e2) && "3d" === e2.type && "map-notes" !== t2.type && this.addHandles([e2.elevationProvider.on("elevation-change", ({ context: e3 }) => {
      y3(e3, t2.elevationInfo) && this._snappingElevationAligner.notifyElevationSourceChange();
    }), l(() => t2.elevationInfo, () => this._snappingElevationAligner.notifyElevationSourceChange(), h)]);
  }
  async fetchCandidates(e2, t2) {
    const { point: o, coordinateHelper: r5, elevationInfo: s2 } = e2, i2 = await L(this._mapSources((o2) => this._fetchCandidatesForSource(o2, e2, t2)));
    f(t2);
    const n3 = r5.hasZ() ? E : s2, l2 = this._getGroundElevation, c = i2.flat().map((e3) => r4(e3, r5, n3, l2));
    return a2(o, c, r5), c;
  }
  get _getGroundElevation() {
    return a3(this.view);
  }
  async _fetchCandidatesForSource(e2, t2, o) {
    const r5 = h2(t2), s2 = await e2.queryEngine.executeQueryForSnapping(r5, o);
    f(o);
    const i2 = await this._snappingElevationAligner.alignCandidates(s2.candidates, o);
    f(o);
    const n3 = await this._symbologySnappingFetcher.fetch(i2, o);
    f(o);
    const a4 = 0 === n3.length ? i2 : [...i2, ...n3];
    return this._snappingElevationFilter.filter(r5, a4);
  }
  refresh() {
  }
  _onGraphicUpdate(e2) {
    if (this.getGraphicsLayers().some((t2) => t2.graphics.includes(e2.graphic)))
      switch (e2.property) {
        case "geometry":
        case "visible":
          this._remove(e2.graphic), this._addMany([e2.graphic]);
      }
  }
  _onGraphicsChanged(e2) {
    for (const t2 of e2.removed)
      this._remove(t2);
    this._addMany(e2.added);
  }
  _addMany(e2) {
    const t2 = [], o = /* @__PURE__ */ new Map();
    for (const r5 of e2)
      t(r5.geometry) || (this._needsInitializeProjection(r5.geometry.spatialReference) ? (t2.push(r5.geometry.spatialReference), o.set(r5.uid, r5)) : this._add(r5));
    this._createPendingAdd(t2, o);
  }
  _createPendingAdd(e2, t2) {
    if (!e2.length)
      return;
    const s2 = j(async (o) => {
      await _n(e2.map((e3) => ({ source: e3, dest: this.spatialReference })), { signal: o }), this._markLoadedSpatialReferences(e2);
      for (const [, e3] of t2)
        this._add(e3);
    });
    this.updatingHandles.addPromise(s2.promise);
    const i2 = { task: s2, graphics: t2 }, n3 = () => v(this._pendingAdds, i2);
    s2.promise.then(n3, n3), this._pendingAdds.push(i2);
  }
  _markLoadedSpatialReferences(e2) {
    for (const t2 of e2)
      null != t2.wkid && this._loadedWkids.add(t2.wkid), null != t2.wkt && this._loadedWkts.add(t2.wkt);
  }
  _add(e2) {
    if (t(e2.geometry) || !e2.visible)
      return;
    let t2 = e2.geometry;
    if ("mesh" === t2.type)
      return;
    "extent" === t2.type && (t2 = v2.fromExtent(t2));
    const o = this._ensureSource(t2.type);
    if (t(o))
      return;
    const r5 = this._createOptimizedFeature(e2.uid, t2);
    t(r5) || (o.featureStore.add(r5), B(e2.symbol) && this._extrudedPolygonSymbolsCount++);
  }
  _needsInitializeProjection(e2) {
    return (null == e2.wkid || !this._loadedWkids.has(e2.wkid)) && ((null == e2.wkt || !this._loadedWkts.has(e2.wkt)) && !An(e2, this.spatialReference));
  }
  _createOptimizedFeature(e2, t2) {
    const o = rn(p(t2), this.spatialReference);
    if (!o)
      return null;
    const r5 = this._ensureGeometryHasZ(o), s2 = nt(r5, this._hasZ, false);
    return new s(s2, { [H]: e2 }, null, e2);
  }
  _ensureGeometryHasZ(e2) {
    var _a;
    if (!this._hasZ)
      return e2;
    const t2 = (e3) => {
      for (; e3.length < 3; )
        e3.push(0);
    }, o = e2.clone();
    switch (o.hasZ = true, o.type) {
      case "point":
        o.z = (_a = o.z) != null ? _a : 0;
        break;
      case "multipoint":
        o.points.forEach(t2);
        break;
      case "polyline":
        o.paths.forEach((e3) => e3.forEach(t2));
        break;
      case "polygon":
        o.rings.forEach((e3) => e3.forEach(t2));
    }
    return o;
  }
  _ensureSource(e2) {
    const t2 = this._sources[e2];
    if (r(t2))
      return t2;
    const o = this._createSource(e2);
    return this._sources[e2] = o, o;
  }
  _createSource(e2) {
    const t2 = i.toJSON(e2), o = this._hasZ, r5 = new u({ geometryType: t2, hasZ: o, hasM: false });
    return { featureStore: r5, queryEngine: new Y({ featureStore: r5, fields: [{ name: H, type: "esriFieldTypeOID", alias: H }], geometryType: t2, hasM: false, hasZ: o, objectIdField: H, spatialReference: this.spatialReference, scheduler: r(this.view) && "3d" === this.view.type ? this.view.resourceController.scheduler : null }), type: e2 };
  }
  _remove(e2) {
    this._mapSources((t2) => this._removeFromSource(t2, e2));
    for (const t2 of this._pendingAdds)
      t2.graphics.delete(e2.uid), 0 === t2.graphics.size && t2.task.abort();
  }
  _removeFromSource(e2, t2) {
    const o = t2.uid;
    e2.featureStore.has(o) && (e2.featureStore.removeById(t2.uid), B(t2.symbol) && this._extrudedPolygonSymbolsCount--);
  }
  _destroySource(e2) {
    e2.queryEngine.destroy(), this._sources[e2.type] = null;
  }
  _mapSources(e2) {
    const { point: t2, polygon: o, polyline: r5, multipoint: s2 } = this._sources, n3 = [];
    return r(t2) && n3.push(e2(t2)), r(o) && n3.push(e2(o)), r(r5) && n3.push(e2(r5)), r(s2) && n3.push(e2(s2)), n3;
  }
};
e([y()], x.prototype, "getGraphicsLayers", void 0), e([y({ constructOnly: true })], x.prototype, "layerSource", void 0), e([y({ constructOnly: true })], x.prototype, "spatialReference", void 0), e([y({ constructOnly: true })], x.prototype, "view", void 0), e([y({ readOnly: true })], x.prototype, "updating", null), e([y({ readOnly: true })], x.prototype, "availability", void 0), e([y()], x.prototype, "_hasZ", null), e([y()], x.prototype, "_snappingElevationAligner", null), e([y()], x.prototype, "_snappingElevationFilter", null), e([y()], x.prototype, "_symbologySnappingFetcher", null), e([y()], x.prototype, "_extrudedPolygonSymbolsCount", void 0), e([y()], x.prototype, "_getGroundElevation", null), x = e([n("esri.views.interactive.snapping.featureSources.GraphicsSnappingSource")], x);
var H = "OBJECTID";
export {
  x as GraphicsSnappingSource
};
//# sourceMappingURL=GraphicsSnappingSource-4YE5TGVD.js.map
