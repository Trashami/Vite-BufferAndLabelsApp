import {
  O
} from "./chunk-RUM3DXFX.js";
import {
  s as s2
} from "./chunk-LIZHLHNA.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";
import {
  y
} from "./chunk-HVKDYDPP.js";

// node_modules/@arcgis/core/chunks/quatf32.js
function e() {
  const e2 = new Float32Array(4);
  return e2[3] = 1, e2;
}
function r(e2) {
  const r3 = new Float32Array(4);
  return r3[0] = e2[0], r3[1] = e2[1], r3[2] = e2[2], r3[3] = e2[3], r3;
}
function t(e2, r3, t3, n3) {
  const o3 = new Float32Array(4);
  return o3[0] = e2, o3[1] = r3, o3[2] = t3, o3[3] = n3, o3;
}
function n(e2, r3) {
  return new Float32Array(e2, r3, 4);
}
var o = Object.freeze(Object.defineProperty({ __proto__: null, create: e, clone: r, fromValues: t, createView: n }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/views/3d/layers/i3s/LEPCC.js
var t2 = true;
var o2 = { identifierOffset: 0, identifierLength: 10, versionOffset: 10, checksumOffset: 12, byteCount: 16 };
function r2(e2, r3, n3) {
  return { identifier: String.fromCharCode.apply(null, new Uint8Array(e2, n3 + o2.identifierOffset, o2.identifierLength)), version: r3.getUint16(n3 + o2.versionOffset, t2), checksum: r3.getUint32(n3 + o2.checksumOffset, t2) };
}
var n2 = { sizeLo: 0, sizeHi: 4, minX: 8, minY: 16, minZ: 24, maxX: 32, maxY: 40, maxZ: 48, errorX: 56, errorY: 64, errorZ: 72, count: 80, reserved: 84, byteCount: 88 };
function i(e2, o3) {
  return { sizeLo: e2.getUint32(o3 + n2.sizeLo, t2), sizeHi: e2.getUint32(o3 + n2.sizeHi, t2), minX: e2.getFloat64(o3 + n2.minX, t2), minY: e2.getFloat64(o3 + n2.minY, t2), minZ: e2.getFloat64(o3 + n2.minZ, t2), maxX: e2.getFloat64(o3 + n2.maxX, t2), maxY: e2.getFloat64(o3 + n2.maxY, t2), maxZ: e2.getFloat64(o3 + n2.maxZ, t2), errorX: e2.getFloat64(o3 + n2.errorX, t2), errorY: e2.getFloat64(o3 + n2.errorY, t2), errorZ: e2.getFloat64(o3 + n2.errorZ, t2), count: e2.getUint32(o3 + n2.count, t2), reserved: e2.getUint32(o3 + n2.reserved, t2) };
}
function c(t3) {
  const c3 = new DataView(t3, 0);
  let d3 = 0;
  const { identifier: l3, version: a3 } = r2(t3, c3, d3);
  if (d3 += o2.byteCount, "LEPCC     " !== l3)
    throw new s2("lepcc-decode-error", "Bad identifier");
  if (a3 > 1)
    throw new s2("lepcc-decode-error", "Unknown version");
  const u3 = i(c3, d3);
  d3 += n2.byteCount;
  if (u3.sizeHi * 2 ** 32 + u3.sizeLo !== t3.byteLength)
    throw new s2("lepcc-decode-error", "Bad size");
  const f3 = new Float64Array(3 * u3.count), h3 = [], w2 = [], g2 = [], p = [];
  if (d3 = s3(t3, d3, h3), d3 = s3(t3, d3, w2), d3 = s3(t3, d3, g2), d3 = s3(t3, d3, p), d3 !== t3.byteLength)
    throw new s2("lepcc-decode-error", "Bad length");
  let m2 = 0, U = 0;
  for (let e2 = 0; e2 < h3.length; e2++) {
    U += h3[e2];
    let t4 = 0;
    for (let o3 = 0; o3 < w2[e2]; o3++) {
      t4 += g2[m2];
      const e3 = p[m2];
      f3[3 * m2] = Math.min(u3.maxX, u3.minX + 2 * u3.errorX * t4), f3[3 * m2 + 1] = Math.min(u3.maxY, u3.minY + 2 * u3.errorY * U), f3[3 * m2 + 2] = Math.min(u3.maxZ, u3.minZ + 2 * u3.errorZ * e3), m2++;
    }
  }
  return { errorX: u3.errorX, errorY: u3.errorY, errorZ: u3.errorZ, result: f3 };
}
function s3(e2, t3, o3) {
  const r3 = [];
  t3 = d(e2, t3, r3);
  const n3 = [];
  for (let i2 = 0; i2 < r3.length; i2++) {
    n3.length = 0, t3 = d(e2, t3, n3);
    for (let e3 = 0; e3 < n3.length; e3++)
      o3.push(n3[e3] + r3[i2]);
  }
  return t3;
}
function d(o3, r3, n3) {
  const i2 = new DataView(o3, r3), c3 = i2.getUint8(0), s5 = 31 & c3, d3 = !!(32 & c3), l3 = (192 & c3) >> 6;
  let a3 = 0;
  if (0 === l3)
    a3 = i2.getUint32(1, t2), r3 += 5;
  else if (1 === l3)
    a3 = i2.getUint16(1, t2), r3 += 3;
  else {
    if (2 !== l3)
      throw new s2("lepcc-decode-error", "Bad count type");
    a3 = i2.getUint8(1), r3 += 2;
  }
  if (d3)
    throw new s2("lepcc-decode-error", "LUT not implemented");
  const u3 = Math.ceil(a3 * s5 / 8), f3 = new Uint8Array(o3, r3, u3);
  let h3 = 0, w2 = 0, g2 = 0;
  const p = -1 >>> 32 - s5;
  for (let e2 = 0; e2 < a3; e2++) {
    for (; w2 < s5; )
      h3 |= f3[g2] << w2, w2 += 8, g2 += 1;
    n3[e2] = h3 & p, h3 >>>= s5, w2 -= s5, w2 + s5 > 32 && (h3 |= f3[g2 - 1] >> 8 - w2);
  }
  return r3 + g2;
}
var l = { sizeLo: 0, sizeHi: 4, count: 8, colorMapCount: 12, lookupMethod: 14, compressionMethod: 15, byteCount: 16 };
function a(e2, o3) {
  return { sizeLo: e2.getUint32(o3 + l.sizeLo, t2), sizeHi: e2.getUint32(o3 + l.sizeHi, t2), count: e2.getUint32(o3 + l.count, t2), colorMapCount: e2.getUint16(o3 + l.colorMapCount, t2), lookupMethod: e2.getUint8(o3 + l.lookupMethod), compressionMethod: e2.getUint8(o3 + l.compressionMethod) };
}
function u(t3) {
  const n3 = new DataView(t3, 0);
  let i2 = 0;
  const { identifier: c3, version: s5 } = r2(t3, n3, i2);
  if (i2 += o2.byteCount, "ClusterRGB" !== c3)
    throw new s2("lepcc-decode-error", "Bad identifier");
  if (s5 > 1)
    throw new s2("lepcc-decode-error", "Unknown version");
  const d3 = a(n3, i2);
  i2 += l.byteCount;
  if (d3.sizeHi * 2 ** 32 + d3.sizeLo !== t3.byteLength)
    throw new s2("lepcc-decode-error", "Bad size");
  if ((2 === d3.lookupMethod || 1 === d3.lookupMethod) && 0 === d3.compressionMethod) {
    if (3 * d3.colorMapCount + d3.count + i2 !== t3.byteLength || d3.colorMapCount > 256)
      throw new s2("lepcc-decode-error", "Bad count");
    const o3 = new Uint8Array(t3, i2, 3 * d3.colorMapCount), r3 = new Uint8Array(t3, i2 + 3 * d3.colorMapCount, d3.count), n4 = new Uint8Array(3 * d3.count);
    for (let e2 = 0; e2 < d3.count; e2++) {
      const t4 = r3[e2];
      n4[3 * e2] = o3[3 * t4], n4[3 * e2 + 1] = o3[3 * t4 + 1], n4[3 * e2 + 2] = o3[3 * t4 + 2];
    }
    return n4;
  }
  if (0 === d3.lookupMethod && 0 === d3.compressionMethod) {
    if (3 * d3.count + i2 !== t3.byteLength || 0 !== d3.colorMapCount)
      throw new s2("lepcc-decode-error", "Bad count");
    return new Uint8Array(t3, i2).slice();
  }
  if (d3.lookupMethod <= 2 && 1 === d3.compressionMethod) {
    if (i2 + 3 !== t3.byteLength || 1 !== d3.colorMapCount)
      throw new s2("lepcc-decode-error", "Bad count");
    const o3 = n3.getUint8(i2), r3 = n3.getUint8(i2 + 1), c4 = n3.getUint8(i2 + 2), s6 = new Uint8Array(3 * d3.count);
    for (let e2 = 0; e2 < d3.count; e2++)
      s6[3 * e2] = o3, s6[3 * e2 + 1] = r3, s6[3 * e2 + 2] = c4;
    return s6;
  }
  throw new s2("lepcc-decode-error", "Bad method " + d3.lookupMethod + "," + d3.compressionMethod);
}
var f = { sizeLo: 0, sizeHi: 4, count: 8, scaleFactor: 12, bitsPerPoint: 14, reserved: 15, byteCount: 16 };
function h(e2, o3) {
  return { sizeLo: e2.getUint32(o3 + f.sizeLo, t2), sizeHi: e2.getUint32(o3 + f.sizeHi, t2), count: e2.getUint32(o3 + f.count, t2), scaleFactor: e2.getUint16(o3 + f.scaleFactor, t2), bitsPerPoint: e2.getUint8(o3 + f.bitsPerPoint), reserved: e2.getUint8(o3 + f.reserved) };
}
function w(t3) {
  const n3 = new DataView(t3, 0);
  let i2 = 0;
  const { identifier: c3, version: s5 } = r2(t3, n3, i2);
  if (i2 += o2.byteCount, "Intensity " !== c3)
    throw new s2("lepcc-decode-error", "Bad identifier");
  if (s5 > 1)
    throw new s2("lepcc-decode-error", "Unknown version");
  const l3 = h(n3, i2);
  i2 += f.byteCount;
  if (l3.sizeHi * 2 ** 32 + l3.sizeLo !== t3.byteLength)
    throw new s2("lepcc-decode-error", "Bad size");
  const a3 = new Uint16Array(l3.count);
  if (8 === l3.bitsPerPoint) {
    if (l3.count + i2 !== t3.byteLength)
      throw new s2("lepcc-decode-error", "Bad size");
    const o3 = new Uint8Array(t3, i2, l3.count);
    for (let e2 = 0; e2 < l3.count; e2++)
      a3[e2] = o3[e2] * l3.scaleFactor;
  } else if (16 === l3.bitsPerPoint) {
    if (2 * l3.count + i2 !== t3.byteLength)
      throw new s2("lepcc-decode-error", "Bad size");
    const o3 = new Uint16Array(t3, i2, l3.count);
    for (let e2 = 0; e2 < l3.count; e2++)
      a3[e2] = o3[e2] * l3.scaleFactor;
  } else {
    const o3 = [];
    if (d(t3, i2, o3) !== t3.byteLength)
      throw new s2("lepcc-decode-error", "Bad size");
    for (let e2 = 0; e2 < l3.count; e2++)
      a3[e2] = o3[e2] * l3.scaleFactor;
  }
  return a3;
}

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SBinaryReader.js
var u2 = s.getLogger("esri.views.3d.layers.i3s.I3SBinaryReader");
function a2(t3, n3, r3) {
  let o3 = "", i2 = 0;
  for (; i2 < r3; ) {
    const u3 = t3[n3 + i2];
    if (u3 < 128)
      o3 += String.fromCharCode(u3), i2++;
    else if (u3 >= 192 && u3 < 224) {
      if (i2 + 1 >= r3)
        throw new s2("utf8-decode-error", "UTF-8 Decode failed. Two byte character was truncated.");
      const a3 = (31 & u3) << 6 | 63 & t3[n3 + i2 + 1];
      o3 += String.fromCharCode(a3), i2 += 2;
    } else if (u3 >= 224 && u3 < 240) {
      if (i2 + 2 >= r3)
        throw new s2("utf8-decode-error", "UTF-8 Decode failed. Multi byte character was truncated.");
      const a3 = (15 & u3) << 12 | (63 & t3[n3 + i2 + 1]) << 6 | 63 & t3[n3 + i2 + 2];
      o3 += String.fromCharCode(a3), i2 += 3;
    } else {
      if (!(u3 >= 240 && u3 < 248))
        throw new s2("utf8-decode-error", "UTF-8 Decode failed. Invalid multi byte sequence.");
      {
        if (i2 + 3 >= r3)
          throw new s2("utf8-decode-error", "UTF-8 Decode failed. Multi byte character was truncated.");
        const a3 = (7 & u3) << 18 | (63 & t3[n3 + i2 + 1]) << 12 | (63 & t3[n3 + i2 + 2]) << 6 | 63 & t3[n3 + i2 + 3];
        if (a3 >= 65536) {
          const e2 = 55296 + (a3 - 65536 >> 10), t4 = 56320 + (1023 & a3);
          o3 += String.fromCharCode(e2, t4);
        } else
          o3 += String.fromCharCode(a3);
        i2 += 4;
      }
    }
  }
  return o3;
}
function s4(e2, t3) {
  const n3 = { byteOffset: 0, byteCount: 0, fields: /* @__PURE__ */ Object.create(null) };
  let r3 = 0;
  for (let o3 = 0; o3 < t3.length; o3++) {
    const i2 = t3[o3], u3 = i2.valueType || i2.type, a3 = h2[u3];
    n3.fields[i2.property] = a3(e2, r3), r3 += m[u3].BYTES_PER_ELEMENT;
  }
  return n3.byteCount = r3, n3;
}
function c2(t3, n3, r3) {
  const o3 = [];
  let i2, u3, s5 = 0;
  for (u3 = 0; u3 < t3; u3 += 1) {
    if (i2 = n3[u3], i2 > 0) {
      if (o3.push(a2(r3, s5, i2 - 1)), 0 !== r3[s5 + i2 - 1])
        throw new s2("string-array-error", "Invalid string array: missing null termination.");
    } else
      o3.push(null);
    s5 += i2;
  }
  return o3;
}
function f2(e2, t3) {
  return new (0, m[t3.valueType])(e2, t3.byteOffset, t3.count * t3.valuesPerElement);
}
function l2(e2, t3) {
  return new Uint8Array(e2, t3.byteOffset, t3.byteCount);
}
function b(n3, r3, o3) {
  const i2 = null != r3.header ? s4(n3, r3.header) : { byteOffset: 0, byteCount: 0, fields: { count: o3 } }, u3 = { header: i2, byteOffset: i2.byteCount, byteCount: 0, entries: /* @__PURE__ */ Object.create(null) };
  let a3 = i2.byteCount;
  for (let s5 = 0; s5 < r3.ordering.length; s5++) {
    const n4 = r3.ordering[s5], o4 = y(r3[n4]);
    if (o4.count = i2.fields.count, "String" === o4.valueType) {
      if (o4.byteOffset = a3, o4.byteCount = i2.fields[n4 + "ByteCount"], "UTF-8" !== o4.encoding)
        throw new s2("unsupported-encoding", "Unsupported String encoding.", { encoding: o4.encoding });
    } else {
      if (!A(o4.valueType))
        throw new s2("unsupported-value-type", "Unsupported binary valueType", { valueType: o4.valueType });
      {
        const e2 = O2(o4.valueType);
        a3 += a3 % e2 != 0 ? e2 - a3 % e2 : 0, o4.byteOffset = a3, o4.byteCount = e2 * o4.valuesPerElement * o4.count;
      }
    }
    a3 += o4.byteCount, u3.entries[n4] = o4;
  }
  return u3.byteCount = a3 - u3.byteOffset, u3;
}
function d2(t3, n3, r3) {
  if (n3 !== t3 && u2.error(`Invalid ${r3} buffer size
 expected: ${t3}, actual: ${n3})`), n3 < t3)
    throw new s2("buffer-too-small", "Binary buffer is too small", { expectedSize: t3, actualSize: n3 });
}
function g(e2, t3) {
  const n3 = s4(e2, t3 && t3.header);
  let r3 = n3.byteCount;
  const o3 = { isDraco: false, header: n3, byteOffset: n3.byteCount, byteCount: 0, vertexAttributes: {} }, i2 = n3.fields, u3 = null != i2.vertexCount ? i2.vertexCount : i2.count;
  for (const s5 of t3.ordering) {
    if (!t3.vertexAttributes[s5])
      continue;
    const e3 = { ...t3.vertexAttributes[s5], byteOffset: r3, count: u3 }, n4 = C[s5] ? C[s5] : "_" + s5;
    o3.vertexAttributes[n4] = e3, r3 += O2(e3.valueType) * e3.valuesPerElement * u3;
  }
  const a3 = i2.faceCount;
  if (t3.faces && a3) {
    o3.faces = {};
    for (const e3 of t3.ordering) {
      if (!t3.faces[e3])
        continue;
      const n4 = { ...t3.faces[e3], byteOffset: r3, count: a3 };
      o3.faces[e3] = n4, r3 += O2(n4.valueType) * n4.valuesPerElement * a3;
    }
  }
  const c3 = i2.featureCount;
  if (t3.featureAttributes && t3.featureAttributeOrder && c3) {
    o3.featureAttributes = {};
    for (const e3 of t3.featureAttributeOrder) {
      if (!t3.featureAttributes[e3])
        continue;
      const n4 = { ...t3.featureAttributes[e3], byteOffset: r3, count: c3 };
      o3.featureAttributes[e3] = n4;
      r3 += ("UInt64" === n4.valueType ? 8 : O2(n4.valueType)) * n4.valuesPerElement * c3;
    }
  }
  return d2(r3, e2.byteLength, "geometry"), o3.byteCount = r3 - o3.byteOffset, o3;
}
var C = { position: O.POSITION, normal: O.NORMAL, color: O.COLOR, uv0: O.UV0, region: O.UVREGION };
function I(t3, n3, i2) {
  if ("lepcc-rgb" === t3.encoding)
    return u(n3);
  if ("lepcc-intensity" === t3.encoding)
    return w(n3);
  if (null != t3.encoding && "" !== t3.encoding)
    throw new s2("unknown-attribute-storage-info-encoding", "Unknown Attribute Storage Info Encoding");
  t3["attributeByteCounts "] && !t3.attributeByteCounts && (u2.warn("Warning: Trailing space in 'attributeByteCounts '."), t3.attributeByteCounts = t3["attributeByteCounts "]), "ObjectIds" === t3.ordering[0] && t3.hasOwnProperty("objectIds") && (u2.warn("Warning: Case error in objectIds"), t3.ordering[0] = "objectIds");
  const a3 = b(n3, t3, i2);
  d2(a3.byteOffset + a3.byteCount, n3.byteLength, "attribute");
  const s5 = a3.entries.attributeValues || a3.entries.objectIds;
  if (s5) {
    if ("String" === s5.valueType) {
      const e2 = a3.entries.attributeByteCounts, t4 = f2(n3, e2), r3 = l2(n3, s5);
      return c2(e2.count, t4, r3);
    }
    return f2(n3, s5);
  }
  throw new s2("bad-attribute-storage-info", "Bad attributeStorageInfo specification.");
}
var m = { Float32: Float32Array, Float64: Float64Array, UInt8: Uint8Array, Int8: Int8Array, UInt16: Uint16Array, Int16: Int16Array, UInt32: Uint32Array, Int32: Int32Array };
var h2 = { Float32: (e2, t3) => new DataView(e2, 0).getFloat32(t3, true), Float64: (e2, t3) => new DataView(e2, 0).getFloat64(t3, true), UInt8: (e2, t3) => new DataView(e2, 0).getUint8(t3), Int8: (e2, t3) => new DataView(e2, 0).getInt8(t3), UInt16: (e2, t3) => new DataView(e2, 0).getUint16(t3, true), Int16: (e2, t3) => new DataView(e2, 0).getInt16(t3, true), UInt32: (e2, t3) => new DataView(e2, 0).getUint32(t3, true), Int32: (e2, t3) => new DataView(e2, 0).getInt32(t3, true) };
function A(e2) {
  return m.hasOwnProperty(e2);
}
function O2(e2) {
  return A(e2) ? m[e2].BYTES_PER_ELEMENT : 0;
}

export {
  e,
  r,
  c,
  f2 as f,
  g,
  I
};
//# sourceMappingURL=chunk-FSTECXRH.js.map
