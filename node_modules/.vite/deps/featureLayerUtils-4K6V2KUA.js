import {
  r as r2
} from "./chunk-3XUZDMLH.js";
import {
  o as o2
} from "./chunk-PQLPA2XZ.js";
import {
  i as i2
} from "./chunk-LX2NI53X.js";
import "./chunk-IZUZZJS7.js";
import {
  a,
  c,
  f,
  i
} from "./chunk-BWNO4YZY.js";
import {
  l,
  o
} from "./chunk-RLIJP6DT.js";
import "./chunk-FFVIDMFN.js";
import {
  Ze
} from "./chunk-53VWTVL2.js";
import "./chunk-6CR2FXC5.js";
import "./chunk-VYG3YGZX.js";
import "./chunk-65SMURZR.js";
import "./chunk-VGNX3TFX.js";
import "./chunk-TZTENXCS.js";
import "./chunk-RQPDRERN.js";
import "./chunk-MBLYC2KR.js";
import "./chunk-XGEPEYGB.js";
import "./chunk-6BYMCM5A.js";
import "./chunk-BR5PSTJI.js";
import "./chunk-2T7LFOXQ.js";
import "./chunk-NCONZRBI.js";
import "./chunk-76CXRT5P.js";
import "./chunk-LZKCWJVH.js";
import "./chunk-7Q5M7ANT.js";
import "./chunk-LPRQBCQL.js";
import "./chunk-QR4K7IDQ.js";
import "./chunk-7N45W3EA.js";
import "./chunk-MQVQXXLV.js";
import "./chunk-YTOF4Z6B.js";
import "./chunk-HAVCYBU2.js";
import "./chunk-4HXPP4EA.js";
import "./chunk-M3NPSHCI.js";
import "./chunk-SBKKCBDN.js";
import "./chunk-MLVV3H5S.js";
import "./chunk-A4HIS5ZJ.js";
import "./chunk-AMLHWG76.js";
import "./chunk-OFQYIOO7.js";
import "./chunk-ZJZBAYFU.js";
import "./chunk-G3HEFWHV.js";
import "./chunk-3GENFQBG.js";
import "./chunk-FX6IXM55.js";
import "./chunk-QFFP6A5Q.js";
import "./chunk-O5PXWHV2.js";
import {
  m
} from "./chunk-J5VTDQTQ.js";
import "./chunk-YF2CRSQX.js";
import "./chunk-JP3KAUQB.js";
import "./chunk-INL7BDTP.js";
import "./chunk-PDEVQZ7U.js";
import "./chunk-7XXQ7762.js";
import "./chunk-DVGM5RQS.js";
import "./chunk-R6OA44DQ.js";
import "./chunk-QTYVDCOW.js";
import "./chunk-YGVY4EIZ.js";
import "./chunk-HSDU7DIL.js";
import "./chunk-FWRLW4G5.js";
import "./chunk-JNNRJ7GQ.js";
import "./chunk-E52E6T7N.js";
import "./chunk-UK3I5WXR.js";
import "./chunk-GLGOVVCK.js";
import "./chunk-BUVDI6S7.js";
import "./chunk-6Z6ZAVRA.js";
import "./chunk-PK4W65H4.js";
import "./chunk-GY2AJLN6.js";
import "./chunk-W62B63EU.js";
import "./chunk-N43PI2UO.js";
import "./chunk-O6VYMEIX.js";
import "./chunk-NDQ5FHGV.js";
import "./chunk-HUQX7WZO.js";
import {
  x as x2
} from "./chunk-BYSA56OH.js";
import "./chunk-ZWUEORSX.js";
import "./chunk-US2IWMHE.js";
import "./chunk-ZL4T4NIV.js";
import "./chunk-NAKEKTIK.js";
import "./chunk-QWNKYSI4.js";
import "./chunk-FMJZBZWF.js";
import "./chunk-GOYVJTGW.js";
import "./chunk-ZPYDYUP5.js";
import "./chunk-TDV3ZXCQ.js";
import "./chunk-XJCUKRCO.js";
import "./chunk-SOEQPPQP.js";
import "./chunk-22F6X66Z.js";
import "./chunk-AIDV7EKX.js";
import "./chunk-FZQZIM7U.js";
import "./chunk-YM6PUX7G.js";
import "./chunk-QEYOWTXD.js";
import "./chunk-CZBRZ6SU.js";
import "./chunk-KDO6J2FO.js";
import "./chunk-RT3T2K4S.js";
import "./chunk-WJCI2CGX.js";
import "./chunk-REIQNAQW.js";
import "./chunk-J6LQZWZI.js";
import "./chunk-OD3FDQCI.js";
import "./chunk-J2PJNRU7.js";
import "./chunk-56SPM3WK.js";
import "./chunk-XMZAPOBR.js";
import "./chunk-BLJKKR5D.js";
import "./chunk-ZGNCYHMZ.js";
import "./chunk-X2S4RQJ4.js";
import "./chunk-FUPLN7UM.js";
import "./chunk-376OPXM4.js";
import "./chunk-DER356EU.js";
import "./chunk-MZIWIEIR.js";
import "./chunk-TQEOEDAZ.js";
import "./chunk-SHFHZMHO.js";
import "./chunk-NRP45AHD.js";
import "./chunk-IWQ7452U.js";
import "./chunk-NAN5J6QS.js";
import "./chunk-B4DKBAM3.js";
import "./chunk-6M2AHKYV.js";
import {
  j
} from "./chunk-SZIJNKCV.js";
import "./chunk-6O43OEU5.js";
import "./chunk-J2K7ZDSV.js";
import "./chunk-2UML3WQZ.js";
import "./chunk-KXVMEIWT.js";
import "./chunk-UDND2Z3V.js";
import "./chunk-23Y3DIC6.js";
import "./chunk-JUVQV3R3.js";
import "./chunk-RAX2HD42.js";
import "./chunk-ZYRIJWLX.js";
import "./chunk-C5H57NTD.js";
import "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import "./chunk-YWAQYJRC.js";
import "./chunk-B356PXLT.js";
import "./chunk-EHPBHJYZ.js";
import "./chunk-3MNMDUQZ.js";
import "./chunk-UWG37XSU.js";
import "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import "./chunk-HLM6QCL2.js";
import "./chunk-RXYULINL.js";
import "./chunk-5NXILPDI.js";
import "./chunk-THVR7IAM.js";
import "./chunk-ZWJJTUFL.js";
import "./chunk-XQN7F674.js";
import "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import "./chunk-KAN4HXCG.js";
import "./chunk-4FEGON7M.js";
import "./chunk-VWYWOOPX.js";
import "./chunk-M5VHU5LK.js";
import "./chunk-CXFRNDG4.js";
import "./chunk-7QMMKGW4.js";
import "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import {
  E,
  x
} from "./chunk-MJXQTGI2.js";
import {
  s as s3
} from "./chunk-LIZHLHNA.js";
import "./chunk-BTUHYGXO.js";
import {
  s2
} from "./chunk-UA3YPL2R.js";
import "./chunk-HVKDYDPP.js";
import {
  s
} from "./chunk-6QC7MLLS.js";
import {
  r,
  t
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/layers/save/featureLayerUtils.js
var I = s2.getLogger("esri.layers.FeatureLayer");
var S = "Feature Service";
function g(e, t2) {
  return `Layer (title: ${e.title}, id: ${e.id}) of type '${e.declaredClass}' ${t2}`;
}
function j2(e, r3) {
  if (r3.type !== S)
    throw new s3("feature-layer:portal-item-wrong-type", g(e, `should have portal item of type "${S}"`));
}
async function L(e) {
  if (await e.load(), l(e))
    throw new s3("feature-layer:save", g(e, "using an in-memory source cannot be saved to a portal item"));
}
function P(e, r3) {
  var _a;
  let a2 = ((_a = e.messages) != null ? _a : []).filter(({ type: e2 }) => "error" === e2).map(({ name: e2, message: r4, details: a3 }) => new s3(e2, r4, a3));
  if ((r3 == null ? void 0 : r3.ignoreUnsupported) && (a2 = a2.filter(({ name: e2 }) => "layer:unsupported" !== e2 && "symbol:unsupported" !== e2 && "symbol-layer:unsupported" !== e2 && "property:unsupported" !== e2 && "url:unsupported" !== e2)), a2.length > 0)
    throw new s3("feature-layer:save", "Failed to save feature layer due to unsupported or invalid content. See 'details.errors' for more detailed information", { errors: a2 });
}
async function J(e, t2, r3) {
  "beforeSave" in e && "function" == typeof e.beforeSave && await e.beforeSave();
  const a2 = e.write({}, t2);
  return P(t2, r3), a2;
}
function N(e) {
  const { layer: t2, layerJSON: r3 } = e;
  return t2.isTable ? { layers: [], tables: [r3] } : { layers: [r3], tables: [] };
}
function O(e) {
  i(e, f.JSAPI), e.typeKeywords && (e.typeKeywords = e.typeKeywords.filter((e2, t2, r3) => r3.indexOf(e2) === t2));
}
function E2(e) {
  const r3 = e.portalItem;
  if (!r3)
    throw I.error("save: requires the portalItem property to be set"), new s3("feature-layer:portal-item-not-set", g(e, "requires the portalItem property to be set"));
  if (!r3.loaded)
    throw new s3("feature-layer:portal-item-not-loaded", g(e, "cannot be saved to a portal item that does not exist or is inaccessible"));
  j2(e, r3);
}
async function T(e, t2) {
  var _a;
  return /\/\d+\/?$/.test((_a = e.url) != null ? _a : "") ? N(t2[0]) : $(e, t2);
}
async function $(e, t2) {
  const { layer: { url: r3, customParameters: a2, apiKey: o3 } } = t2[0];
  let s4 = await e.fetchData("json");
  s4 && null != s4.layers && null != s4.tables || (s4 = await x3(s4, { url: r3 != null ? r3 : "", customParameters: a2, apiKey: o3 }, t2.map((e2) => e2.layer.layerId)));
  for (const l2 of t2)
    K(l2.layer, l2.layerJSON, s4);
  return s4;
}
async function x3(e, t2, r3) {
  var a2, o3;
  e || (e = {}), (a2 = e).layers || (a2.layers = []), (o3 = e).tables || (o3.tables = []);
  const { url: s4, customParameters: l2, apiKey: i3 } = t2, { serviceJSON: n, layersJSON: u } = await r2(s4, { customParameters: l2, apiKey: i3 }), c2 = A(e.layers, n.layers, r3), y = A(e.tables, n.tables, r3);
  e.layers = c2.itemResources, e.tables = y.itemResources;
  const d = [...c2.added, ...y.added], m2 = u ? [...u.layers, ...u.tables] : [];
  return await U(e, d, s4, m2), e;
}
function A(t2, r3, a2) {
  const o3 = s(t2, r3, (e, t3) => e.id === t3.id);
  t2 = t2.filter((e) => !o3.removed.some((t3) => t3.id === e.id));
  const s4 = o3.added.map(({ id: e }) => ({ id: e }));
  return s4.forEach(({ id: e }) => {
    t2.push({ id: e });
  }), { itemResources: t2, added: s4.filter(({ id: e }) => !a2.includes(e)) };
}
async function U(e, t2, r3, o3) {
  const s4 = t2.map(({ id: e2 }) => new Ze({ url: r3, layerId: e2, sourceJSON: o3.find(({ id: t3 }) => t3 === e2) }));
  await E(s4.map((e2) => e2.load())), s4.forEach((t3) => {
    const { layerId: r4, loaded: o4, defaultPopupTemplate: s5 } = t3;
    if (!o4 || t(s5))
      return;
    K(t3, { id: r4, popupInfo: s5.toJSON() }, e);
  });
}
function K(e, t2, r3) {
  e.isTable ? F(r3.tables, t2) : F(r3.layers, t2);
}
function F(e, t2) {
  if (!e)
    return;
  const r3 = e.findIndex(({ id: e2 }) => e2 === t2.id);
  -1 === r3 ? e.push(t2) : e[r3] = t2;
}
function R(e) {
  const { portalItem: t2 } = e;
  return o(e) && !e.dynamicDataSource && !!(t2 == null ? void 0 : t2.loaded) && t2.type === S;
}
async function D(e) {
  if (!(e == null ? void 0 : e.length))
    throw new s3("feature-layer-utils-saveall:missing-parameters", "'layers' array should contain at least one feature layer");
  await Promise.all(e.map((e2) => e2.load()));
  for (const o3 of e)
    if (!R(o3))
      throw new s3("feature-layer-utils-saveall:invalid-parameters", `'layers' array should only contain layers or tables in a feature service loaded from 'Feature Service' item. ${g(o3, "does not conform")}`, { layer: o3 });
  const r3 = e.map((e2) => e2.portalItem.id);
  if (new Set(r3).size > 1)
    throw new s3("feature-layer-utils-saveall:invalid-parameters", "All layers in the 'layers' array should be loaded from the same portal item");
  const a2 = e.map((e2) => e2.layerId);
  if (new Set(a2).size !== a2.length)
    throw new s3("feature-layer-utils-saveall:invalid-parameters", "'layers' array should contain only one instance each of layer or table in a feature service");
}
function _(e, t2) {
  var _a, _b;
  var r3, a2;
  let o3 = x2.from(t2);
  return o3.id && (o3 = o3.clone(), o3.id = null), (_a = (r3 = o3).type) != null ? _a : r3.type = S, (_b = (a2 = o3).portal) != null ? _b : a2.portal = j.getDefault(), j2(e, o3), o3;
}
async function q(e, t2) {
  const { url: r3, layerId: a2, title: s4, fullExtent: l2, isTable: i3 } = e, n = m(r3), p = r(n) && "FeatureServer" === n.serverType;
  t2.url = p ? r3 : `${r3}/${a2}`, t2.title || (t2.title = s4), t2.extent = null, !i3 && r(l2) && (t2.extent = await a(l2)), c(t2, f.METADATA), c(t2, f.MULTI_LAYER), i(t2, f.SINGLE_LAYER), i3 && i(t2, f.TABLE), O(t2);
}
async function z(e, t2, r3) {
  var _a;
  const a2 = e.portal;
  await (a2 == null ? void 0 : a2._signIn()), await ((_a = a2 == null ? void 0 : a2.user) == null ? void 0 : _a.addItem({ item: e, data: t2, folder: r3 == null ? void 0 : r3.folder }));
}
var C = x(M);
async function M(e, t2) {
  await L(e), E2(e);
  const r3 = e.portalItem, a2 = o2(r3), o3 = await J(e, a2, t2), s4 = await T(r3, [{ layer: e, layerJSON: o3 }]);
  return O(r3), await r3.update({ data: s4 }), i2(a2), r3;
}
var Y = x(async (e, t2) => {
  await D(e);
  const r3 = e[0].portalItem, a2 = o2(r3), o3 = await Promise.all(e.map((e2) => J(e2, a2, t2))), s4 = await T(r3, e.map((e2, t3) => ({ layer: e2, layerJSON: o3[t3] })));
  return O(r3), await r3.update({ data: s4 }), await Promise.all(e.slice(1).map((e2) => e2.portalItem.reload())), i2(a2), r3.clone();
});
var B = x(G);
async function G(e, t2, r3) {
  await L(e);
  const a2 = _(e, t2), o3 = o2(a2), s4 = N({ layer: e, layerJSON: await J(e, o3, r3) });
  return await q(e, a2), await z(a2, s4, r3), e.portalItem = a2, i2(o3), a2;
}
export {
  C as save,
  Y as saveAll,
  B as saveAs
};
//# sourceMappingURL=featureLayerUtils-4K6V2KUA.js.map
