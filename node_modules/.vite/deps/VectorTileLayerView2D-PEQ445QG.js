import {
  i as i2,
  r as r6
} from "./chunk-QXJIQKLY.js";
import "./chunk-GRWIJKD6.js";
import "./chunk-WGK2FJEK.js";
import "./chunk-CNTOSDAN.js";
import {
  y as y4
} from "./chunk-L4LV52OG.js";
import {
  u as u3
} from "./chunk-PCWW275T.js";
import {
  r as r5
} from "./chunk-7N2Z7KNR.js";
import {
  e as e7
} from "./chunk-YNUWEZ4E.js";
import {
  c,
  e as e6,
  t as t4
} from "./chunk-DBT4KOKX.js";
import "./chunk-DWAZ7HI7.js";
import "./chunk-EPMXCACW.js";
import {
  t as t3
} from "./chunk-KFLNKWNF.js";
import "./chunk-KG5RWWIW.js";
import "./chunk-27YO3FKC.js";
import "./chunk-6TBB7UXB.js";
import "./chunk-UO3LS2M5.js";
import {
  I as I3
} from "./chunk-EQNT4A7P.js";
import {
  l as l3
} from "./chunk-2XVZ2CO6.js";
import {
  I as I2,
  L
} from "./chunk-L553EHL3.js";
import {
  a as a3,
  i,
  l as l2,
  n as n4,
  r as r4
} from "./chunk-2GP5D74I.js";
import "./chunk-R24MO4IV.js";
import "./chunk-YQBYWPBD.js";
import "./chunk-QISOH77W.js";
import "./chunk-XO5VJRK4.js";
import "./chunk-OAXPH6DL.js";
import {
  E2 as E5,
  a as a2
} from "./chunk-O4DPVR3F.js";
import {
  E as E4
} from "./chunk-MATM5L52.js";
import {
  t as t2
} from "./chunk-4OM3EX6P.js";
import {
  C,
  D as D2,
  E as E3,
  F,
  G,
  I,
  O,
  P,
  R
} from "./chunk-3OFVLRSL.js";
import "./chunk-UWKVAZQ6.js";
import "./chunk-FV3CMB37.js";
import {
  y as y3
} from "./chunk-FERTI5PU.js";
import {
  h as h3
} from "./chunk-VWCRJ6R6.js";
import "./chunk-MKNNZ33G.js";
import {
  l as l4
} from "./chunk-JQUWFKNU.js";
import "./chunk-5FHRTN6L.js";
import {
  e as e5
} from "./chunk-TFHLTN6F.js";
import "./chunk-UDYHZLTE.js";
import {
  e as e4,
  r as r3
} from "./chunk-IQBIGNPU.js";
import "./chunk-4JNOVZUK.js";
import {
  M,
  f,
  h as h2,
  r as r2
} from "./chunk-ZNRXLY4R.js";
import {
  n as n3
} from "./chunk-5MBCFCGH.js";
import "./chunk-UAJ2SDPQ.js";
import "./chunk-75RMBUYZ.js";
import "./chunk-TJ2I6XQT.js";
import "./chunk-EDHROVWI.js";
import "./chunk-34YPGGJT.js";
import {
  j as j2
} from "./chunk-OOOPZLJE.js";
import "./chunk-U2WD23Z5.js";
import "./chunk-ZEEU5HOK.js";
import "./chunk-INL7BDTP.js";
import {
  a,
  m
} from "./chunk-DVGM5RQS.js";
import {
  e as e3
} from "./chunk-E52E6T7N.js";
import "./chunk-N43PI2UO.js";
import "./chunk-NDQ5FHGV.js";
import {
  u as u2
} from "./chunk-ZL4T4NIV.js";
import "./chunk-NAKEKTIK.js";
import "./chunk-QWNKYSI4.js";
import "./chunk-FMJZBZWF.js";
import "./chunk-GOYVJTGW.js";
import "./chunk-ZPYDYUP5.js";
import "./chunk-AIDV7EKX.js";
import "./chunk-FZQZIM7U.js";
import "./chunk-CZBRZ6SU.js";
import "./chunk-RT3T2K4S.js";
import "./chunk-WJCI2CGX.js";
import "./chunk-REIQNAQW.js";
import {
  g
} from "./chunk-J6LQZWZI.js";
import "./chunk-OD3FDQCI.js";
import "./chunk-J2PJNRU7.js";
import "./chunk-56SPM3WK.js";
import "./chunk-XMZAPOBR.js";
import "./chunk-BLJKKR5D.js";
import "./chunk-ZGNCYHMZ.js";
import "./chunk-X2S4RQJ4.js";
import "./chunk-FUPLN7UM.js";
import "./chunk-376OPXM4.js";
import "./chunk-DER356EU.js";
import "./chunk-MZIWIEIR.js";
import "./chunk-TQEOEDAZ.js";
import "./chunk-SHFHZMHO.js";
import "./chunk-NRP45AHD.js";
import "./chunk-IWQ7452U.js";
import "./chunk-NAN5J6QS.js";
import "./chunk-B4DKBAM3.js";
import {
  u
} from "./chunk-6M2AHKYV.js";
import "./chunk-SZIJNKCV.js";
import "./chunk-6O43OEU5.js";
import "./chunk-J2K7ZDSV.js";
import "./chunk-2UML3WQZ.js";
import "./chunk-KXVMEIWT.js";
import "./chunk-UDND2Z3V.js";
import "./chunk-23Y3DIC6.js";
import "./chunk-JUVQV3R3.js";
import "./chunk-RAX2HD42.js";
import "./chunk-ZYRIJWLX.js";
import "./chunk-C5H57NTD.js";
import "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import "./chunk-YWAQYJRC.js";
import "./chunk-B356PXLT.js";
import "./chunk-EHPBHJYZ.js";
import "./chunk-3MNMDUQZ.js";
import "./chunk-UWG37XSU.js";
import {
  E as E2
} from "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import "./chunk-HLM6QCL2.js";
import "./chunk-RXYULINL.js";
import {
  h,
  l
} from "./chunk-5NXILPDI.js";
import {
  n as n2
} from "./chunk-THVR7IAM.js";
import "./chunk-ZWJJTUFL.js";
import "./chunk-XQN7F674.js";
import {
  U
} from "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import {
  Bt
} from "./chunk-KAN4HXCG.js";
import "./chunk-4FEGON7M.js";
import "./chunk-VWYWOOPX.js";
import "./chunk-M5VHU5LK.js";
import "./chunk-CXFRNDG4.js";
import "./chunk-7QMMKGW4.js";
import {
  e as e2,
  n2 as n,
  y as y2
} from "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import {
  D,
  E,
  b,
  j
} from "./chunk-MJXQTGI2.js";
import "./chunk-LIZHLHNA.js";
import "./chunk-BTUHYGXO.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";
import {
  y
} from "./chunk-HVKDYDPP.js";
import "./chunk-6QC7MLLS.js";
import {
  e,
  r,
  t
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/RectangleBinPack.js
var e8 = class {
  constructor(e9, t9) {
    this._width = 0, this._height = 0, this._free = [], this._width = e9, this._height = t9, this._free.push(new t3(0, 0, e9, t9));
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  allocate(e9, t9) {
    if (e9 > this._width || t9 > this._height)
      return new t3();
    let i7 = null, s5 = -1;
    for (let h6 = 0; h6 < this._free.length; ++h6) {
      const w = this._free[h6];
      e9 <= w.width && t9 <= w.height && (null === i7 || w.y <= i7.y && w.x <= i7.x) && (i7 = w, s5 = h6);
    }
    return null === i7 ? new t3() : (this._free.splice(s5, 1), i7.width < i7.height ? (i7.width > e9 && this._free.push(new t3(i7.x + e9, i7.y, i7.width - e9, t9)), i7.height > t9 && this._free.push(new t3(i7.x, i7.y + t9, i7.width, i7.height - t9))) : (i7.width > e9 && this._free.push(new t3(i7.x + e9, i7.y, i7.width - e9, i7.height)), i7.height > t9 && this._free.push(new t3(i7.x, i7.y + t9, e9, i7.height - t9))), new t3(i7.x, i7.y, e9, t9));
  }
  release(h6) {
    for (let e9 = 0; e9 < this._free.length; ++e9) {
      const t9 = this._free[e9];
      if (t9.y === h6.y && t9.height === h6.height && t9.x + t9.width === h6.x)
        t9.width += h6.width;
      else if (t9.x === h6.x && t9.width === h6.width && t9.y + t9.height === h6.y)
        t9.height += h6.height;
      else if (h6.y === t9.y && h6.height === t9.height && h6.x + h6.width === t9.x)
        t9.x = h6.x, t9.width += h6.width;
      else {
        if (h6.x !== t9.x || h6.width !== t9.width || h6.y + h6.height !== t9.y)
          continue;
        t9.y = h6.y, t9.height += h6.height;
      }
      this._free.splice(e9, 1), this.release(h6);
    }
    this._free.push(h6);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/GlyphMosaic.js
var r7 = class {
  constructor(e9, i7, s5) {
    this.width = 0, this.height = 0, this._dirties = [], this._glyphData = [], this._currentPage = 0, this._glyphIndex = {}, this._textures = [], this._rangePromises = /* @__PURE__ */ new Map(), this.width = e9, this.height = i7, this._glyphSource = s5, this._binPack = new e8(e9 - 4, i7 - 4), this._glyphData.push(new Uint8Array(e9 * i7)), this._dirties.push(true), this._textures.push(void 0);
  }
  getGlyphItems(i7, s5) {
    const h6 = [], r11 = this._glyphSource, n11 = /* @__PURE__ */ new Set(), a8 = 1 / 256;
    for (const t9 of s5) {
      const e9 = Math.floor(t9 * a8);
      n11.add(e9);
    }
    const o3 = [];
    return n11.forEach((t9) => {
      if (t9 <= 256) {
        const e9 = i7 + t9;
        if (this._rangePromises.has(e9))
          o3.push(this._rangePromises.get(e9));
        else {
          const s6 = r11.getRange(i7, t9).then(() => {
            this._rangePromises.delete(e9);
          }, () => {
            this._rangePromises.delete(e9);
          });
          this._rangePromises.set(e9, s6), o3.push(s6);
        }
      }
    }), Promise.all(o3).then(() => {
      let n12 = this._glyphIndex[i7];
      n12 || (n12 = {}, this._glyphIndex[i7] = n12);
      for (const a9 of s5) {
        const s6 = n12[a9];
        if (s6) {
          h6[a9] = { sdf: true, rect: s6.rect, metrics: s6.metrics, page: s6.page, code: a9 };
          continue;
        }
        const o4 = r11.getGlyph(i7, a9);
        if (!o4 || !o4.metrics)
          continue;
        const l10 = o4.metrics;
        let c5;
        if (0 === l10.width)
          c5 = new t3(0, 0, 0, 0);
        else {
          const e9 = 3, i8 = l10.width + 2 * e9, s7 = l10.height + 2 * e9;
          let h7 = i8 % 4 ? 4 - i8 % 4 : 4, r12 = s7 % 4 ? 4 - s7 % 4 : 4;
          1 === h7 && (h7 = 5), 1 === r12 && (r12 = 5), c5 = this._binPack.allocate(i8 + h7, s7 + r12), c5.isEmpty && (this._dirties[this._currentPage] || (this._glyphData[this._currentPage] = null), this._currentPage = this._glyphData.length, this._glyphData.push(new Uint8Array(this.width * this.height)), this._dirties.push(true), this._textures.push(void 0), this._binPack = new e8(this.width - 4, this.height - 4), c5 = this._binPack.allocate(i8 + h7, s7 + r12));
          const n13 = this._glyphData[this._currentPage], a10 = o4.bitmap;
          let g2, _4;
          if (a10)
            for (let t9 = 0; t9 < s7; t9++) {
              g2 = i8 * t9, _4 = this.width * (c5.y + t9 + 1) + c5.x;
              for (let t10 = 0; t10 < i8; t10++)
                n13[_4 + t10 + 1] = a10[g2 + t10];
            }
        }
        n12[a9] = { rect: c5, metrics: l10, tileIDs: null, page: this._currentPage }, h6[a9] = { sdf: true, rect: c5, metrics: l10, page: this._currentPage, code: a9 }, this._dirties[this._currentPage] = true;
      }
      return h6;
    });
  }
  removeGlyphs(t9) {
    for (const e9 in this._glyphIndex) {
      const i7 = this._glyphIndex[e9];
      if (!i7)
        continue;
      let s5;
      for (const e10 in i7)
        if (s5 = i7[e10], s5.tileIDs.delete(t9), 0 === s5.tileIDs.size) {
          const t10 = this._glyphData[s5.page], h6 = s5.rect;
          let r11, n11;
          for (let e11 = 0; e11 < h6.height; e11++)
            for (r11 = this.width * (h6.y + e11) + h6.x, n11 = 0; n11 < h6.width; n11++)
              t10[r11 + n11] = 0;
          delete i7[e10], this._dirties[s5.page] = true;
        }
    }
  }
  bind(t9, e9, r11, n11 = 0) {
    this._textures[r11] || (this._textures[r11] = new E4(t9, { pixelFormat: P.ALPHA, dataType: G.UNSIGNED_BYTE, width: this.width, height: this.height }, new Uint8Array(this.width * this.height)));
    const a8 = this._textures[r11];
    a8.setSamplingMode(e9), this._dirties[r11] && a8.setData(this._glyphData[r11]), t9.bindTexture(a8, n11), this._dirties[r11] = false;
  }
  dispose() {
    this._binPack = null;
    for (const t9 of this._textures)
      t9 && t9.dispose();
    this._textures.length = 0;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/GlyphSource.js
var s2 = class {
  constructor(e9) {
    if (this._metrics = [], this._bitmaps = [], e9)
      for (; e9.next(); )
        switch (e9.tag()) {
          case 1: {
            const t9 = e9.getMessage();
            for (; t9.next(); )
              switch (t9.tag()) {
                case 3: {
                  const e10 = t9.getMessage();
                  let s5, a8, r11, n11, i7, c5, g2;
                  for (; e10.next(); )
                    switch (e10.tag()) {
                      case 1:
                        s5 = e10.getUInt32();
                        break;
                      case 2:
                        a8 = e10.getBytes();
                        break;
                      case 3:
                        r11 = e10.getUInt32();
                        break;
                      case 4:
                        n11 = e10.getUInt32();
                        break;
                      case 5:
                        i7 = e10.getSInt32();
                        break;
                      case 6:
                        c5 = e10.getSInt32();
                        break;
                      case 7:
                        g2 = e10.getUInt32();
                        break;
                      default:
                        e10.skip();
                    }
                  e10.release(), s5 && (this._metrics[s5] = { width: r11, height: n11, left: i7, top: c5, advance: g2 }, this._bitmaps[s5] = a8);
                  break;
                }
                default:
                  t9.skip();
              }
            t9.release();
            break;
          }
          default:
            e9.skip();
        }
  }
  getMetrics(e9) {
    return this._metrics[e9];
  }
  getBitmap(e9) {
    return this._bitmaps[e9];
  }
};
var a4 = class {
  constructor() {
    this._ranges = [];
  }
  getRange(e9) {
    return this._ranges[e9];
  }
  addRange(e9, t9) {
    this._ranges[e9] = t9;
  }
};
var r8 = class {
  constructor(e9) {
    this._glyphInfo = {}, this._baseURL = e9;
  }
  getRange(a8, r11) {
    const n11 = this._getFontStack(a8);
    if (n11.getRange(r11))
      return Promise.resolve();
    const i7 = 256 * r11, c5 = i7 + 255;
    if (this._baseURL) {
      const g2 = this._baseURL.replace("{fontstack}", a8).replace("{range}", i7 + "-" + c5);
      return U(g2, { responseType: "array-buffer" }).then((e9) => {
        n11.addRange(r11, new s2(new n3(new Uint8Array(e9.data), new DataView(e9.data))));
      }).catch(() => {
        n11.addRange(r11, new s2());
      });
    }
    return n11.addRange(r11, new s2()), Promise.resolve();
  }
  getGlyph(e9, t9) {
    const s5 = this._getFontStack(e9);
    if (!s5)
      return;
    const a8 = Math.floor(t9 / 256);
    if (a8 > 256)
      return;
    const r11 = s5.getRange(a8);
    return r11 ? { metrics: r11.getMetrics(t9), bitmap: r11.getBitmap(t9) } : void 0;
  }
  _getFontStack(e9) {
    let t9 = this._glyphInfo[e9];
    return t9 || (t9 = this._glyphInfo[e9] = new a4()), t9;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/SpriteMosaic.js
var o = "dasharray-";
var n5 = class {
  constructor(t9, e9, s5 = 0) {
    this._size = [], this._mosaicsData = [], this._textures = [], this._dirties = [], this._maxItemSize = 0, this._currentPage = 0, this._pageWidth = 0, this._pageHeight = 0, this._mosaicRects = {}, this.pixelRatio = 1, (t9 <= 0 || e9 <= 0) && console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"), this._pageWidth = t9, this._pageHeight = e9, s5 > 0 && (this._maxItemSize = s5), this._binPack = new e8(t9 - 4, e9 - 4);
  }
  dispose() {
    this._binPack = null, this._mosaicRects = {};
    for (const t9 of this._textures)
      t9 && t9.dispose();
    this._textures.length = 0;
  }
  getWidth(t9) {
    return t9 >= this._size.length ? -1 : this._size[t9][0];
  }
  getHeight(t9) {
    return t9 >= this._size.length ? -1 : this._size[t9][1];
  }
  getPageSize(t9) {
    return t9 >= this._size.length ? null : this._size[t9];
  }
  setSpriteSource(t9) {
    if (this.dispose(), this.pixelRatio = t9.devicePixelRatio, 0 === this._mosaicsData.length) {
      this._binPack = new e8(this._pageWidth - 4, this._pageHeight - 4);
      const t10 = Math.floor(this._pageWidth), e9 = Math.floor(this._pageHeight), s5 = new Uint32Array(t10 * e9);
      this._mosaicsData[0] = s5, this._dirties.push(true), this._size.push([this._pageWidth, this._pageHeight]), this._textures.push(void 0);
    }
    this._sprites = t9;
  }
  getSpriteItem(t9, i7 = false) {
    let e9, s5, h6 = this._mosaicRects[t9];
    if (h6)
      return h6;
    if (!this._sprites || "loaded" !== this._sprites.loadStatus)
      return null;
    if (t9 && t9.startsWith(o) ? ([e9, s5] = this._rasterizeDash(t9), i7 = true) : e9 = this._sprites.getSpriteInfo(t9), !e9 || !e9.width || !e9.height || e9.width < 0 || e9.height < 0)
      return null;
    const a8 = e9.width, r11 = e9.height, [n11, _4, g2] = this._allocateImage(a8, r11);
    return n11.width <= 0 ? null : (this._copy(n11, e9, _4, g2, i7, s5), h6 = { rect: n11, width: a8, height: r11, sdf: e9.sdf, simplePattern: false, pixelRatio: e9.pixelRatio, page: _4 }, this._mosaicRects[t9] = h6, h6);
  }
  getSpriteItems(t9) {
    const i7 = {};
    for (const e9 of t9)
      i7[e9.name] = this.getSpriteItem(e9.name, e9.repeat);
    return i7;
  }
  getMosaicItemPosition(t9, i7) {
    const e9 = this.getSpriteItem(t9, i7), s5 = e9 && e9.rect;
    if (!s5)
      return null;
    s5.width = e9.width, s5.height = e9.height;
    const h6 = e9.width, a8 = e9.height, r11 = 2;
    return { tl: [s5.x + r11, s5.y + r11], br: [s5.x + r11 + h6, s5.y + r11 + a8], page: e9.page };
  }
  bind(t9, i7, e9 = 0, o3 = 0) {
    if (e9 >= this._size.length || e9 >= this._mosaicsData.length)
      return;
    this._textures[e9] || (this._textures[e9] = new E4(t9, { pixelFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, wrapMode: D2.CLAMP_TO_EDGE, width: this._size[e9][0], height: this._size[e9][1] }, new Uint8Array(this._mosaicsData[e9].buffer)));
    const n11 = this._textures[e9];
    n11.setSamplingMode(i7), this._dirties[e9] && n11.setData(new Uint8Array(this._mosaicsData[e9].buffer)), t9.bindTexture(n11, o3), this._dirties[e9] = false;
  }
  static _copyBits(t9, i7, e9, s5, h6, a8, r11, o3, n11, _4, g2) {
    let c5 = s5 * i7 + e9, l10 = o3 * a8 + r11;
    if (g2) {
      l10 -= a8;
      for (let r12 = -1; r12 <= _4; r12++, c5 = ((r12 + _4) % _4 + s5) * i7 + e9, l10 += a8)
        for (let i8 = -1; i8 <= n11; i8++)
          h6[l10 + i8] = t9[c5 + (i8 + n11) % n11];
    } else
      for (let p = 0; p < _4; p++) {
        for (let i8 = 0; i8 < n11; i8++)
          h6[l10 + i8] = t9[c5 + i8];
        c5 += i7, l10 += a8;
      }
  }
  _copy(t9, i7, e9, s5, h6, a8) {
    if (!this._sprites || "loaded" !== this._sprites.loadStatus || e9 >= this._mosaicsData.length)
      return;
    const r11 = new Uint32Array(a8 ? a8.buffer : this._sprites.image.buffer), o3 = this._mosaicsData[e9];
    o3 && r11 || console.error("Source or target images are uninitialized!");
    const _4 = 2, g2 = a8 ? i7.width : this._sprites.width;
    n5._copyBits(r11, g2, i7.x, i7.y, o3, s5[0], t9.x + _4, t9.y + _4, i7.width, i7.height, h6), this._dirties[e9] = true;
  }
  _allocateImage(t9, s5) {
    t9 += 2, s5 += 2;
    const h6 = Math.max(t9, s5);
    if (this._maxItemSize && this._maxItemSize < h6) {
      const i7 = new t3(0, 0, t9, s5);
      return this._mosaicsData.push(new Uint32Array(t9 * s5)), this._dirties.push(true), this._size.push([t9, s5]), this._textures.push(void 0), [i7, this._mosaicsData.length - 1, [t9, s5]];
    }
    let a8 = t9 % 4 ? 4 - t9 % 4 : 4, r11 = s5 % 4 ? 4 - s5 % 4 : 4;
    1 === a8 && (a8 = 5), 1 === r11 && (r11 = 5);
    const o3 = this._binPack.allocate(t9 + a8, s5 + r11);
    return o3.width <= 0 ? (this._dirties[this._currentPage] || (this._mosaicsData[this._currentPage] = null), this._currentPage = this._mosaicsData.length, this._mosaicsData.push(new Uint32Array(this._pageWidth * this._pageHeight)), this._dirties.push(true), this._size.push([this._pageWidth, this._pageHeight]), this._textures.push(void 0), this._binPack = new e8(this._pageWidth - 4, this._pageHeight - 4), this._allocateImage(t9, s5)) : [o3, this._currentPage, [this._pageWidth, this._pageHeight]];
  }
  _rasterizeDash(i7) {
    const e9 = /\[(.*?)\]/, s5 = i7.match(e9);
    if (!s5)
      return null;
    const h6 = s5[1].split(",").map(Number), a8 = i7.slice(i7.lastIndexOf("-") + 1), [r11, o3, n11] = e7(h6, a8);
    return [{ x: 0, y: 0, width: o3, height: n11, sdf: true, pixelRatio: 1 }, new Uint8Array(r11.buffer)];
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileHandler.js
var n6 = class {
  constructor(e9, t9, s5) {
    this._layer = e9, this._styleRepository = t9, this.devicePixelRatio = s5, this._spriteMosaic = null, this._glyphMosaic = null, this._connection = null;
  }
  destroy() {
    this._connection && (this._connection.close(), this._connection = null), this._styleRepository = null, this._layer = null, this._spriteMosaic && (this._spriteMosaic = null), this._glyphMosaic && (this._glyphMosaic = null);
  }
  get spriteMosaic() {
    return this._spriteSourcePromise.then(() => this._spriteMosaic);
  }
  get glyphMosaic() {
    return this._glyphMosaic;
  }
  async start(t9) {
    this._spriteSourcePromise = this._layer.loadSpriteSource(this.devicePixelRatio, t9), this._spriteSourcePromise.then((e9) => {
      this._spriteMosaic = new n5(1024, 1024, 250), this._spriteMosaic.setSpriteSource(e9);
    });
    const s5 = new r8(this._layer.currentStyleInfo.glyphsUrl ? Bt(this._layer.currentStyleInfo.glyphsUrl, { ...this._layer.customParameters, token: this._layer.apiKey }) : null);
    this._glyphMosaic = new r7(1024, 1024, s5), this._broadcastPromise = u2("WorkerTileHandler", { client: this, schedule: t9.schedule, signal: t9.signal }).then((s6) => {
      if (this._connection = s6, this._layer && !this._connection.closed) {
        const r11 = s6.broadcast("setStyle", this._layer.currentStyleInfo.style, t9);
        Promise.all(r11).catch((t10) => b(t10));
      }
    });
  }
  async updateStyle(e9) {
    return await this._broadcastPromise, this._broadcastPromise = Promise.all(this._connection.broadcast("updateStyle", e9)), this._broadcastPromise;
  }
  setSpriteSource(e9) {
    const t9 = new n5(1024, 1024, 250);
    return t9.setSpriteSource(e9), this._spriteMosaic = t9, this._spriteSourcePromise = Promise.resolve(e9), t9;
  }
  async setStyle(e9, t9) {
    await this._broadcastPromise, this._styleRepository = e9, this._spriteSourcePromise = this._layer.loadSpriteSource(this.devicePixelRatio, null), this._spriteSourcePromise.then((e10) => {
      this._spriteMosaic = new n5(1024, 1024, 250), this._spriteMosaic.setSpriteSource(e10);
    });
    const s5 = new r8(this._layer.currentStyleInfo.glyphsUrl ? Bt(this._layer.currentStyleInfo.glyphsUrl, { ...this._layer.customParameters, token: this._layer.apiKey }) : null);
    return this._glyphMosaic = new r7(1024, 1024, s5), this._broadcastPromise = Promise.all(this._connection.broadcast("setStyle", t9)), this._broadcastPromise;
  }
  fetchTileData(e9, t9) {
    return this._getRefKeys(e9, t9).then((e10) => {
      const s5 = this._layer.sourceNameToSource, r11 = [];
      for (const t10 in s5)
        r11.push(t10);
      return this._getSourcesData(r11, e10, t9);
    });
  }
  parseTileData(e9, t9) {
    const s5 = e9 && e9.data;
    if (!s5)
      return Promise.resolve(null);
    const { sourceName2DataAndRefKey: r11, transferList: i7 } = s5;
    return 0 === Object.keys(r11).length ? Promise.resolve(null) : this._broadcastPromise.then(() => this._connection.invoke("createTileAndParse", { key: e9.key.id, sourceName2DataAndRefKey: r11, styleLayerUIDs: e9.styleLayerUIDs }, { ...t9, transferList: i7 }));
  }
  async getSprites(e9) {
    return await this._spriteSourcePromise, this._spriteMosaic.getSpriteItems(e9);
  }
  getGlyphs(e9) {
    return this._glyphMosaic.getGlyphItems(e9.font, e9.codePoints);
  }
  async _getTilePayload(e9, s5, r11) {
    const i7 = e5.pool.acquire(e9.id), o3 = this._layer.sourceNameToSource[s5], { level: a8, row: l10, col: n11 } = i7;
    e5.pool.release(i7);
    try {
      return { protobuff: await o3.requestTile(a8, l10, n11, r11), sourceName: s5 };
    } catch (h6) {
      if (j(h6))
        throw h6;
      return { protobuff: null, sourceName: s5 };
    }
  }
  _getRefKeys(e9, t9) {
    const r11 = this._layer.sourceNameToSource, i7 = new Array();
    for (const s5 in r11) {
      const o3 = r11[s5].getRefKey(e9, t9);
      i7.push(o3);
    }
    return E(i7);
  }
  _getSourcesData(e9, t9, r11) {
    const i7 = [];
    for (let s5 = 0; s5 < t9.length; s5++)
      if (null == t9[s5].value || null == e9[s5])
        i7.push(null);
      else {
        const o3 = this._getTilePayload(t9[s5].value, e9[s5], r11);
        i7.push(o3);
      }
    return E(i7).then((e10) => {
      const s5 = {}, r12 = [];
      for (let i8 = 0; i8 < e10.length; i8++)
        if (e10[i8].value && e10[i8].value && e10[i8].value.protobuff && e10[i8].value.protobuff.byteLength > 0) {
          const o3 = t9[i8].value.id;
          s5[e10[i8].value.sourceName] = { refKey: o3, protobuff: e10[i8].value.protobuff }, r12.push(e10[i8].value.protobuff);
        }
      return { sourceName2DataAndRefKey: s5, transferList: r12 };
    });
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileManager.js
var r9 = 512;
var o2 = 1e-6;
var n7 = (e9, i7) => e9 + 1 / (1 << 2 * i7);
var a5 = class {
  constructor(i7, t9) {
    this._tiles = /* @__PURE__ */ new Map(), this._tileCache = new e3(40, (e9) => e9.dispose()), this._viewSize = [0, 0], this._visibleTiles = /* @__PURE__ */ new Map(), this.acquireTile = i7.acquireTile, this.releaseTile = i7.releaseTile, this.tileInfoView = i7.tileInfoView, this._container = t9;
  }
  destroy() {
    for (const [e9, i7] of this._tiles)
      i7.dispose();
    this._tiles = null, this._tileCache.clear(), this._tileCache = null;
  }
  update(e9) {
    this._updateCacheSize(e9);
    const i7 = this.tileInfoView, t9 = i7.getTileCoverage(e9.state, 0, "smallest"), { spans: r11, lodInfo: o3 } = t9, { level: n11 } = o3, a8 = this._tiles, c5 = /* @__PURE__ */ new Set(), h6 = /* @__PURE__ */ new Set();
    for (const { row: s5, colFrom: _4, colTo: f3 } of r11)
      for (let e10 = _4; e10 <= f3; e10++) {
        const i8 = e5.getId(n11, s5, o3.normalizeCol(e10), o3.getWorldForColumn(e10)), t10 = this._getOrAcquireTile(i8);
        c5.add(i8), t10.processed() ? this._addToContainer(t10) : h6.add(new e5(i8));
      }
    for (const [s5, l10] of a8)
      l10.isCoverage = c5.has(s5);
    for (const s5 of h6)
      this._findPlaceholdersForMissingTiles(s5, c5);
    let d2 = false;
    for (const [s5, l10] of a8)
      l10.neededForCoverage = c5.has(s5), l10.neededForCoverage || l10.isHoldingForFade && i7.intersects(t9, l10.key) && c5.add(s5), l10.isFading && (d2 = true);
    for (const [s5, l10] of this._tiles)
      c5.has(s5) || this._releaseTile(s5);
    return l4.pool.release(t9), !d2;
  }
  clear() {
    this._tiles.clear(), this._tileCache.clear(), this._visibleTiles.clear();
  }
  clearCache() {
    this._tileCache.clear();
  }
  _findPlaceholdersForMissingTiles(e9, i7) {
    const t9 = [];
    for (const [l10, r11] of this._tiles)
      this._addPlaceholderChild(t9, r11, e9, i7);
    const s5 = t9.reduce(n7, 0);
    Math.abs(1 - s5) < o2 || this._addPlaceholderParent(e9.id, i7);
  }
  _addPlaceholderChild(e9, i7, t9, s5) {
    i7.key.level <= t9.level || !i7.hasData() || h4(t9, i7.key) && (this._addToContainer(i7), s5.add(i7.id), e9.push(i7.key.level - t9.level));
  }
  _addPlaceholderParent(e9, i7) {
    const t9 = this._tiles;
    let s5 = e9;
    for (; ; ) {
      if (s5 = c2(s5), !s5 || i7.has(s5))
        return;
      const e10 = t9.get(s5);
      if (e10 && e10.hasData())
        return this._addToContainer(e10), void i7.add(e10.id);
    }
  }
  _getOrAcquireTile(e9) {
    let i7 = this._tiles.get(e9);
    return i7 || (i7 = this._tileCache.pop(e9), i7 || (i7 = this.acquireTile(new e5(e9))), this._tiles.set(e9, i7), i7);
  }
  _releaseTile(e9) {
    const i7 = this._tiles.get(e9);
    this.releaseTile(i7), this._removeFromContainer(i7), this._tiles.delete(e9), i7.hasData() ? this._tileCache.put(e9, i7, 1) : i7.dispose();
  }
  _addToContainer(e9) {
    let s5;
    const l10 = [], r11 = this._container;
    if (r11.contains(e9))
      return;
    const o3 = this._visibleTiles;
    for (const [t9, n11] of o3)
      this._canConnectDirectly(e9, n11) && l10.push(n11), t(s5) && this._canConnectDirectly(n11, e9) && (s5 = n11);
    if (r(s5)) {
      for (const i7 of l10)
        s5.childrenTiles.delete(i7), e9.childrenTiles.add(i7), i7.parentTile = e9;
      s5.childrenTiles.add(e9), e9.parentTile = s5;
    } else
      for (const i7 of l10)
        e9.childrenTiles.add(i7), i7.parentTile = e9;
    o3.set(e9.id, e9), r11.addChild(e9);
  }
  _removeFromContainer(e9) {
    if (this._visibleTiles.delete(e9.id), this._container.removeChild(e9), r(e9.parentTile)) {
      e9.parentTile.childrenTiles.delete(e9);
      for (const i7 of e9.childrenTiles)
        r(e9.parentTile) && e9.parentTile.childrenTiles.add(i7);
    }
    for (const i7 of e9.childrenTiles)
      i7.parentTile = e9.parentTile;
    e9.parentTile = null, e9.childrenTiles.clear();
  }
  _canConnectDirectly(e9, i7) {
    const t9 = e9.key;
    let { level: s5, row: l10, col: r11, world: o3 } = i7.key;
    const n11 = this._visibleTiles;
    for (; s5 > 0; ) {
      if (s5--, l10 >>= 1, r11 >>= 1, t9.level === s5 && t9.row === l10 && t9.col === r11 && t9.world === o3)
        return true;
      if (n11.has(`${s5}/${l10}/${r11}/${o3}`))
        return false;
    }
    return false;
  }
  _updateCacheSize(e9) {
    const i7 = e9.state.size;
    if (i7[0] === this._viewSize[0] && i7[1] === this._viewSize[1])
      return;
    const t9 = Math.ceil(i7[0] / r9) + 1, s5 = Math.ceil(i7[1] / r9) + 1;
    this._viewSize[0] = i7[0], this._viewSize[1] = i7[1], this._tileCache.maxSize = 5 * t9 * s5;
  }
};
function c2(e9) {
  const [i7, t9, s5, l10] = e9.split("/"), r11 = parseInt(i7, 10);
  return 0 === r11 ? null : `${r11 - 1}/${parseInt(t9, 10) >> 1}/${parseInt(s5, 10) >> 1}/${parseInt(l10, 10)}`;
}
function h4(e9, i7) {
  const t9 = i7.level - e9.level;
  return e9.row === i7.row >> t9 && e9.col === i7.col >> t9 && e9.world === i7.world;
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/core.js
var t5 = class {
  constructor(t9) {
    this.xTile = 0, this.yTile = 0, this.hash = 0, this.priority = 1, this.colliders = [], this.textVertexRanges = [], this.iconVertexRanges = [], this.tile = t9;
  }
};
var s3 = class {
  constructor() {
    this.tileSymbols = [], this.parts = [{ startTime: 0, startOpacity: 0, targetOpacity: 0, show: false }, { startTime: 0, startOpacity: 0, targetOpacity: 0, show: false }], this.show = false;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/util.js
function l5(t9, e9, s5, o3, r11, l10) {
  const i7 = s5 - r11;
  if (i7 >= 0)
    return (e9 >> i7) + (o3 - (l10 << i7)) * (t9 >> i7);
  const n11 = -i7;
  return e9 - (l10 - (o3 << n11)) * (t9 >> n11) << n11;
}
var i3 = class {
  constructor(t9, e9, s5) {
    this._rows = Math.ceil(e9 / s5), this._columns = Math.ceil(t9 / s5), this._cellSize = s5, this.cells = new Array(this._rows);
    for (let o3 = 0; o3 < this._rows; o3++) {
      this.cells[o3] = new Array(this._columns);
      for (let t10 = 0; t10 < this._columns; t10++)
        this.cells[o3][t10] = [];
    }
  }
  getCell(t9, e9) {
    const s5 = Math.min(Math.max(Math.floor(e9 / this._cellSize), 0), this._rows - 1), o3 = Math.min(Math.max(Math.floor(t9 / this._cellSize), 0), this._columns - 1);
    return this.cells[s5] && this.cells[s5][o3] || null;
  }
  getCellSpan(t9, e9, s5, o3) {
    return [Math.min(Math.max(Math.floor(t9 / this._cellSize), 0), this.columns - 1), Math.min(Math.max(Math.floor(e9 / this._cellSize), 0), this.rows - 1), Math.min(Math.max(Math.floor(s5 / this._cellSize), 0), this.columns - 1), Math.min(Math.max(Math.floor(o3 / this._cellSize), 0), this.rows - 1)];
  }
  get cellSize() {
    return this._cellSize;
  }
  get columns() {
    return this._columns;
  }
  get rows() {
    return this._rows;
  }
};
function n8(t9, e9, o3, r11, l10, i7) {
  const n11 = e9[r11++];
  for (let c5 = 0; c5 < n11; c5++) {
    const n12 = new t5(i7);
    n12.xTile = e9[r11++], n12.yTile = e9[r11++], n12.hash = e9[r11++], n12.priority = e9[r11++];
    const c6 = e9[r11++];
    for (let t10 = 0; t10 < c6; t10++) {
      const t11 = e9[r11++], s5 = e9[r11++], l11 = e9[r11++], i8 = e9[r11++], c7 = !!e9[r11++], a9 = e9[r11++], h7 = o3[r11++], d2 = o3[r11++], f3 = e9[r11++], u7 = e9[r11++];
      n12.colliders.push({ xTile: t11, yTile: s5, dxPixels: l11, dyPixels: i8, hard: c7, partIndex: a9, width: f3, height: u7, minLod: h7, maxLod: d2 });
    }
    const a8 = t9[r11++];
    for (let e10 = 0; e10 < a8; e10++)
      n12.textVertexRanges.push([t9[r11++], t9[r11++]]);
    const h6 = t9[r11++];
    for (let e10 = 0; e10 < h6; e10++)
      n12.iconVertexRanges.push([t9[r11++], t9[r11++]]);
    l10.push(n12);
  }
  return r11;
}
function c3(t9, e9, s5) {
  for (const [o3, r11] of t9.symbols)
    a6(t9, e9, s5, r11, o3);
}
function a6(t9, s5, o3, r11, l10) {
  const i7 = t9.layerData.get(l10);
  if (i7.type === I2.SYMBOL) {
    for (const e9 of r11) {
      const s6 = e9.unique;
      let r12;
      if (e9.selectedForRendering) {
        const e10 = s6.parts[0], l11 = e10.startOpacity, i8 = e10.targetOpacity;
        t9.allSymbolsFadingOut = t9.allSymbolsFadingOut && 0 === i8;
        const n11 = o3 ? Math.floor(127 * l11) | i8 << 7 : i8 ? 255 : 0;
        r12 = n11 << 24 | n11 << 16 | n11 << 8 | n11;
      } else
        r12 = 0;
      for (const [t10, o4] of e9.iconVertexRanges)
        for (let e10 = t10; e10 < t10 + o4; e10 += 4)
          i7.iconOpacity[e10 / 4] = r12;
      if (e9.selectedForRendering) {
        const e10 = s6.parts[1], l11 = e10.startOpacity, i8 = e10.targetOpacity;
        t9.allSymbolsFadingOut = t9.allSymbolsFadingOut && 0 === i8;
        const n11 = o3 ? Math.floor(127 * l11) | i8 << 7 : i8 ? 255 : 0;
        r12 = n11 << 24 | n11 << 16 | n11 << 8 | n11;
      } else
        r12 = 0;
      for (const [t10, o4] of e9.textVertexRanges)
        for (let e10 = t10; e10 < t10 + o4; e10 += 4)
          i7.textOpacity[e10 / 4] = r12;
    }
    i7.lastOpacityUpdate = s5, i7.opacityChanged = true;
  }
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/RenderBucket.js
var a7 = class {
  constructor(e9, t9) {
    this.layerUIDs = [], this.isDestroyed = false, this._data = e9, this.memoryUsed = e9.byteLength;
    let r11 = 1;
    const i7 = new Uint32Array(e9);
    this.layerUIDs = [];
    const s5 = i7[r11++];
    for (let n11 = 0; n11 < s5; n11++)
      this.layerUIDs[n11] = i7[r11++];
    this.bufferDataOffset = r11, t9 && (this.layer = t9.getStyleLayerByUID(this.layerUIDs[0]));
  }
  get isPreparedForRendering() {
    return t(this._data);
  }
  get offset() {
    return this.bufferDataOffset;
  }
  destroy() {
    this.isDestroyed || (this.doDestroy(), this.isDestroyed = true);
  }
  prepareForRendering(t9) {
    t(this._data) || (this.doPrepareForRendering(t9, this._data, this.bufferDataOffset), this._data = null);
  }
};
var l6 = class extends a7 {
  constructor(e9, t9) {
    super(e9, t9), this.type = I2.LINE, this.lineIndexStart = 0, this.lineIndexCount = 0;
    const r11 = new Uint32Array(e9);
    let s5 = this.bufferDataOffset;
    this.lineIndexStart = r11[s5++], this.lineIndexCount = r11[s5++];
    const n11 = r11[s5++];
    if (n11 > 0) {
      const e10 = /* @__PURE__ */ new Map();
      for (let t10 = 0; t10 < n11; t10++) {
        const t11 = r11[s5++], i7 = r11[s5++], n12 = r11[s5++];
        e10.set(t11, [i7, n12]);
      }
      this.patternMap = e10;
    }
    this.bufferDataOffset = s5;
  }
  hasData() {
    return this.lineIndexCount > 0;
  }
  triangleCount() {
    return this.lineIndexCount / 3;
  }
  doDestroy() {
    r(this.lineVertexArrayObject) && this.lineVertexArrayObject.dispose(), r(this.lineVertexBuffer) && this.lineVertexBuffer.dispose(), r(this.lineIndexBuffer) && this.lineIndexBuffer.dispose(), this.lineVertexArrayObject = null, this.lineVertexBuffer = null, this.lineIndexBuffer = null, this.memoryUsed = 0;
  }
  doPrepareForRendering(e9, t9, r11) {
    const i7 = new Uint32Array(t9), s5 = new Int32Array(i7.buffer), a8 = i7[r11++];
    this.lineVertexBuffer = E5.createVertex(e9, F.STATIC_DRAW, new Int32Array(s5.buffer, 4 * r11, a8)), r11 += a8;
    const l10 = i7[r11++];
    this.lineIndexBuffer = E5.createIndex(e9, F.STATIC_DRAW, new Uint32Array(i7.buffer, 4 * r11, l10)), r11 += l10;
    const u7 = this.layer.lineMaterial;
    this.lineVertexArrayObject = new a2(e9, u7.getAttributeLocations(), u7.getLayoutInfo(), { geometry: this.lineVertexBuffer }, this.lineIndexBuffer);
  }
};
var u4 = class extends a7 {
  constructor(e9, t9) {
    super(e9, t9), this.type = I2.FILL, this.fillIndexStart = 0, this.fillIndexCount = 0, this.outlineIndexStart = 0, this.outlineIndexCount = 0;
    const r11 = new Uint32Array(e9);
    let s5 = this.bufferDataOffset;
    this.fillIndexStart = r11[s5++], this.fillIndexCount = r11[s5++], this.outlineIndexStart = r11[s5++], this.outlineIndexCount = r11[s5++];
    const n11 = r11[s5++];
    if (n11 > 0) {
      const e10 = /* @__PURE__ */ new Map();
      for (let t10 = 0; t10 < n11; t10++) {
        const t11 = r11[s5++], i7 = r11[s5++], n12 = r11[s5++];
        e10.set(t11, [i7, n12]);
      }
      this.patternMap = e10;
    }
    this.bufferDataOffset = s5;
  }
  hasData() {
    return this.fillIndexCount > 0 || this.outlineIndexCount > 0;
  }
  triangleCount() {
    return (this.fillIndexCount + this.outlineIndexCount) / 3;
  }
  doDestroy() {
    r(this.fillVertexArrayObject) && this.fillVertexArrayObject.dispose(), r(this.fillVertexBuffer) && this.fillVertexBuffer.dispose(), r(this.fillIndexBuffer) && this.fillIndexBuffer.dispose(), this.fillVertexArrayObject = null, this.fillVertexBuffer = null, this.fillIndexBuffer = null, r(this.outlineVertexArrayObject) && this.outlineVertexArrayObject.dispose(), r(this.outlineVertexBuffer) && this.outlineVertexBuffer.dispose(), r(this.outlineIndexBuffer) && this.outlineIndexBuffer.dispose(), this.outlineVertexArrayObject = null, this.outlineVertexBuffer = null, this.outlineIndexBuffer = null, this.memoryUsed = 0;
  }
  doPrepareForRendering(e9, t9, r11) {
    const i7 = new Uint32Array(t9), s5 = new Int32Array(i7.buffer), a8 = i7[r11++];
    this.fillVertexBuffer = E5.createVertex(e9, F.STATIC_DRAW, new Int32Array(s5.buffer, 4 * r11, a8)), r11 += a8;
    const l10 = i7[r11++];
    this.fillIndexBuffer = E5.createIndex(e9, F.STATIC_DRAW, new Uint32Array(i7.buffer, 4 * r11, l10)), r11 += l10;
    const u7 = i7[r11++];
    this.outlineVertexBuffer = E5.createVertex(e9, F.STATIC_DRAW, new Int32Array(s5.buffer, 4 * r11, u7)), r11 += u7;
    const h6 = i7[r11++];
    this.outlineIndexBuffer = E5.createIndex(e9, F.STATIC_DRAW, new Uint32Array(i7.buffer, 4 * r11, h6)), r11 += h6;
    const c5 = this.layer, x = c5.fillMaterial, y5 = c5.outlineMaterial;
    this.fillVertexArrayObject = new a2(e9, x.getAttributeLocations(), x.getLayoutInfo(), { geometry: this.fillVertexBuffer }, this.fillIndexBuffer), this.outlineVertexArrayObject = new a2(e9, y5.getAttributeLocations(), y5.getLayoutInfo(), { geometry: this.outlineVertexBuffer }, this.outlineIndexBuffer);
  }
};
var h5 = class extends a7 {
  constructor(e9, t9, r11) {
    super(e9, t9), this.type = I2.SYMBOL, this.iconPerPageElementsMap = /* @__PURE__ */ new Map(), this.glyphPerPageElementsMap = /* @__PURE__ */ new Map(), this.symbolInstances = [], this.isIconSDF = false, this.opacityChanged = false, this.lastOpacityUpdate = 0, this.symbols = [];
    const n11 = new Uint32Array(e9), f3 = new Int32Array(e9), o3 = new Float32Array(e9);
    let a8 = this.bufferDataOffset;
    this.isIconSDF = !!n11[a8++];
    const l10 = n11[a8++];
    for (let i7 = 0; i7 < l10; i7++) {
      const e10 = n11[a8++], t10 = n11[a8++], r12 = n11[a8++];
      this.iconPerPageElementsMap.set(e10, [t10, r12]);
    }
    const u7 = n11[a8++];
    for (let i7 = 0; i7 < u7; i7++) {
      const e10 = n11[a8++], t10 = n11[a8++], r12 = n11[a8++];
      this.glyphPerPageElementsMap.set(e10, [t10, r12]);
    }
    const h6 = n11[a8++], c5 = n11[a8++];
    this.iconOpacity = new Int32Array(h6), this.textOpacity = new Int32Array(c5), a8 = n8(n11, f3, o3, a8, this.symbols, r11), this.bufferDataOffset = a8;
  }
  hasData() {
    return this.iconPerPageElementsMap.size > 0 || this.glyphPerPageElementsMap.size > 0;
  }
  triangleCount() {
    let e9 = 0;
    for (const [t9, r11] of this.iconPerPageElementsMap)
      e9 += r11[1];
    for (const [t9, r11] of this.glyphPerPageElementsMap)
      e9 += r11[1];
    return e9 / 3;
  }
  doDestroy() {
    r(this.iconVertexArrayObject) && this.iconVertexArrayObject.dispose(), r(this.iconVertexBuffer) && this.iconVertexBuffer.dispose(), r(this.iconOpacityBuffer) && this.iconOpacityBuffer.dispose(), r(this.iconIndexBuffer) && this.iconIndexBuffer.dispose(), this.iconVertexArrayObject = null, this.iconVertexBuffer = null, this.iconOpacityBuffer = null, this.iconIndexBuffer = null, r(this.textVertexArrayObject) && this.textVertexArrayObject.dispose(), r(this.textVertexBuffer) && this.textVertexBuffer.dispose(), r(this.textOpacityBuffer) && this.textOpacityBuffer.dispose(), r(this.textIndexBuffer) && this.textIndexBuffer.dispose(), this.textVertexArrayObject = null, this.textVertexBuffer = null, this.textOpacityBuffer = null, this.textIndexBuffer = null, this.memoryUsed = 0;
  }
  updateOpacityInfo() {
    if (!this.opacityChanged)
      return;
    this.opacityChanged = false;
    const e9 = e(this.iconOpacity), t9 = e(this.iconOpacityBuffer);
    e9.length > 0 && e9.byteLength === t9.size && t9.setSubData(e9, 0, 0, e9.length);
    const i7 = e(this.textOpacity), s5 = e(this.textOpacityBuffer);
    i7.length > 0 && i7.byteLength === s5.size && s5.setSubData(i7, 0, 0, i7.length);
  }
  doPrepareForRendering(e9, t9, i7) {
    const s5 = new Uint32Array(t9), a8 = new Int32Array(s5.buffer), l10 = s5[i7++];
    this.iconVertexBuffer = E5.createVertex(e9, F.STATIC_DRAW, new Int32Array(a8.buffer, 4 * i7, l10)), i7 += l10;
    const u7 = s5[i7++];
    this.iconIndexBuffer = E5.createIndex(e9, F.STATIC_DRAW, new Uint32Array(s5.buffer, 4 * i7, u7)), i7 += u7;
    const h6 = s5[i7++];
    this.textVertexBuffer = E5.createVertex(e9, F.STATIC_DRAW, new Int32Array(a8.buffer, 4 * i7, h6)), i7 += h6;
    const c5 = s5[i7++];
    this.textIndexBuffer = E5.createIndex(e9, F.STATIC_DRAW, new Uint32Array(s5.buffer, 4 * i7, c5)), i7 += c5, this.iconOpacityBuffer = E5.createVertex(e9, F.STATIC_DRAW, e(this.iconOpacity).buffer), this.textOpacityBuffer = E5.createVertex(e9, F.STATIC_DRAW, e(this.textOpacity).buffer);
    const x = this.layer, y5 = x.iconMaterial, d2 = x.textMaterial;
    this.iconVertexArrayObject = new a2(e9, y5.getAttributeLocations(), y5.getLayoutInfo(), { geometry: this.iconVertexBuffer, opacity: this.iconOpacityBuffer }, this.iconIndexBuffer), this.textVertexArrayObject = new a2(e9, d2.getAttributeLocations(), d2.getLayoutInfo(), { geometry: this.textVertexBuffer, opacity: this.textOpacityBuffer }, this.textIndexBuffer);
  }
};
var c4 = class extends a7 {
  constructor(e9, t9) {
    super(e9, t9), this.type = I2.CIRCLE, this.circleIndexStart = 0, this.circleIndexCount = 0;
    const r11 = new Uint32Array(e9);
    let s5 = this.bufferDataOffset;
    this.circleIndexStart = r11[s5++], this.circleIndexCount = r11[s5++], this.bufferDataOffset = s5;
  }
  hasData() {
    return this.circleIndexCount > 0;
  }
  triangleCount() {
    return this.circleIndexCount / 3;
  }
  doDestroy() {
    r(this.circleVertexArrayObject) && this.circleVertexArrayObject.dispose(), r(this.circleVertexBuffer) && this.circleVertexBuffer.dispose(), r(this.circleIndexBuffer) && this.circleIndexBuffer.dispose(), this.circleVertexArrayObject = null, this.circleVertexBuffer = null, this.circleIndexBuffer = null, this.memoryUsed = 0;
  }
  doPrepareForRendering(e9, t9, r11) {
    const i7 = new Uint32Array(t9), s5 = new Int32Array(i7.buffer), a8 = i7[r11++];
    this.circleVertexBuffer = E5.createVertex(e9, F.STATIC_DRAW, new Int32Array(s5.buffer, 4 * r11, a8)), r11 += a8;
    const l10 = i7[r11++];
    this.circleIndexBuffer = E5.createIndex(e9, F.STATIC_DRAW, new Uint32Array(i7.buffer, 4 * r11, l10)), r11 += l10;
    const u7 = this.layer.circleMaterial;
    this.circleVertexArrayObject = new a2(e9, u7.getAttributeLocations(), u7.getLayoutInfo(), { geometry: this.circleVertexBuffer }, this.circleIndexBuffer);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/VectorTile.js
var m2 = class extends r6 {
  constructor(e9, t9, s5, a8, r11, i7, o3, h6 = null) {
    super(e9, t9, s5, a8, r11, i7, 4096, 4096), this._memCache = h6, this.type = "vector-tile", this._referenced = 0, this._hasSymbolBuckets = false, this._memoryUsedByLayerData = 0, this.layerData = /* @__PURE__ */ new Map(), this.layerCount = 0, this.status = "loading", this.allSymbolsFadingOut = false, this.lastOpacityUpdate = 0, this.symbols = /* @__PURE__ */ new Map(), this.isCoverage = false, this.neededForCoverage = false, this.decluttered = false, this.invalidating = false, this.parentTile = null, this.childrenTiles = /* @__PURE__ */ new Set(), this._processed = false, this._referenced = 1, this.styleRepository = o3, this.id = e9.id;
  }
  get hasSymbolBuckets() {
    return this._hasSymbolBuckets;
  }
  get isFading() {
    return this._hasSymbolBuckets && performance.now() - this.lastOpacityUpdate < e6;
  }
  get isHoldingForFade() {
    return this._hasSymbolBuckets && (!this.allSymbolsFadingOut || performance.now() - this.lastOpacityUpdate < e6);
  }
  get wasRequested() {
    return "errored" === this.status || "loaded" === this.status || "reloading" === this.status;
  }
  setData(e9) {
    this.changeDataImpl(e9), this.requestRender(), this.ready(), this.invalidating = false, this._processed = true;
  }
  deleteLayerData(t9) {
    let s5 = false;
    for (const e9 of t9)
      if (this.layerData.has(e9)) {
        const t10 = this.layerData.get(e9);
        this._memoryUsedByLayerData -= t10.memoryUsed, t10.type === I2.SYMBOL && this.symbols.has(e9) && (this.symbols.delete(e9), s5 = true), t10.destroy(), this.layerData.delete(e9), this.layerCount--;
      }
    r(this._memCache) && this._memCache.updateSize(this.key.id, this, this._memoryUsedByLayerData), s5 && this.emit("symbols-changed"), this.requestRender();
  }
  processed() {
    return this._processed;
  }
  hasData() {
    return this.layerCount > 0;
  }
  dispose() {
    "unloaded" !== this.status && (u5.delete(this), m2._destroyRenderBuckets(this.layerData), this.layerData = null, this.layerCount = 0, this._memoryUsedByLayerData = 0, this.destroy(), this.status = "unloaded");
  }
  release() {
    return 0 == --this._referenced && (this.dispose(), this.stage = null, true);
  }
  retain() {
    ++this._referenced;
  }
  get referenced() {
    return this._referenced;
  }
  get memoryUsage() {
    return (this._memoryUsedByLayerData + 256) / (this._referenced || 1);
  }
  changeDataImpl(t9) {
    let s5 = false;
    if (t9) {
      const { bucketsWithData: a8, emptyBuckets: r11 } = t9, i7 = this._createRenderBuckets(a8);
      if (r11 && r11.byteLength > 0) {
        const e9 = new Uint32Array(r11);
        for (const t10 of e9)
          this._deleteLayerData(t10);
      }
      for (const [e9, t10] of i7)
        this._deleteLayerData(e9), t10.type === I2.SYMBOL && (this.symbols.set(e9, t10.symbols), s5 = true), this._memoryUsedByLayerData += t10.memoryUsed, this.layerData.set(e9, t10), this.layerCount++;
      r(this._memCache) && this._memCache.updateSize(this.key.id, this, this._memoryUsedByLayerData);
    }
    this._hasSymbolBuckets = false;
    for (const [e9, a8] of this.layerData)
      a8.type === I2.SYMBOL && (this._hasSymbolBuckets = true);
    s5 && this.emit("symbols-changed");
  }
  attachWithContext(e9) {
    this.stage = { context: e9, trashDisplayObject(e10) {
      e10.processDetach();
    }, untrashDisplayObject: () => false };
  }
  setTransform(e9) {
    super.setTransform(e9);
    const i7 = this.resolution / (e9.resolution * e9.pixelRatio), o3 = this.width / this.rangeX * i7, h6 = this.height / this.rangeY * i7, n11 = [0, 0];
    e9.toScreen(n11, [this.x, this.y]);
    const l10 = this.transforms.tileUnitsToPixels;
    r2(l10), M(l10, l10, n11), h2(l10, l10, Math.PI * e9.rotation / 180), f(l10, l10, [o3, h6, 1]);
  }
  _createTransforms() {
    return { dvs: e4(), tileMat3: e4(), tileUnitsToPixels: e4() };
  }
  static _destroyRenderBuckets(e9) {
    if (!e9)
      return;
    const t9 = /* @__PURE__ */ new Set();
    e9.forEach((e10) => {
      t9.has(e10) || (e10.destroy(), t9.add(e10));
    }), e9.clear();
  }
  _createRenderBuckets(e9) {
    const t9 = /* @__PURE__ */ new Map(), s5 = /* @__PURE__ */ new Map();
    for (const a8 of e9) {
      const e10 = this._deserializeBucket(a8, s5);
      for (const s6 of e10.layerUIDs)
        t9.set(s6, e10);
    }
    return t9;
  }
  _deserializeBucket(e9, t9) {
    let s5 = t9.get(e9);
    if (s5)
      return s5;
    switch (new Uint32Array(e9)[0]) {
      case I2.FILL:
        s5 = new u4(e9, this.styleRepository);
        break;
      case I2.LINE:
        s5 = new l6(e9, this.styleRepository);
        break;
      case I2.SYMBOL:
        s5 = new h5(e9, this.styleRepository, this);
        break;
      case I2.CIRCLE:
        s5 = new c4(e9, this.styleRepository);
    }
    return t9.set(e9, s5), s5;
  }
  _deleteLayerData(e9) {
    if (!this.layerData.has(e9))
      return;
    const t9 = this.layerData.get(e9);
    this._memoryUsedByLayerData -= t9.memoryUsed, t9.destroy(), this.layerData.delete(e9), this.layerCount--;
  }
};
var u5 = /* @__PURE__ */ new Map();

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/jobs.js
function i4(e9, t9, n11, o3, i7, l10) {
  const { iconRotationAlignment: a8, textRotationAlignment: c5, iconTranslate: h6, iconTranslateAnchor: u7, textTranslate: d2, textTranslateAnchor: y5 } = o3;
  let x = 0;
  for (const g2 of e9.colliders) {
    const [e10, o4] = 0 === g2.partIndex ? h6 : d2, m4 = 0 === g2.partIndex ? u7 : y5, f3 = g2.minLod <= l10 && l10 <= g2.maxLod;
    x += f3 ? 0 : 1, g2.enabled = f3, g2.xScreen = g2.xTile * i7[0] + g2.yTile * i7[3] + i7[6], g2.yScreen = g2.xTile * i7[1] + g2.yTile * i7[4] + i7[7], m4 === r4.MAP ? (g2.xScreen += n11 * e10 - t9 * o4, g2.yScreen += t9 * e10 + n11 * o4) : (g2.xScreen += e10, g2.yScreen += o4), l2.VIEWPORT === (0 === g2.partIndex ? a8 : c5) ? (g2.dxScreen = g2.dxPixels, g2.dyScreen = g2.dyPixels) : (g2.dxScreen = n11 * (g2.dxPixels + g2.width / 2) - t9 * (g2.dyPixels + g2.height / 2) - g2.width / 2, g2.dyScreen = t9 * (g2.dxPixels + g2.width / 2) + n11 * (g2.dyPixels + g2.height / 2) - g2.height / 2);
  }
  e9.colliders.length > 0 && x === e9.colliders.length && (e9.unique.show = false);
}
var l7 = class {
  constructor(o3, r11, s5, i7, l10, a8) {
    this._symbols = o3, this._styleRepository = i7, this._zoom = l10, this._currentLayerCursor = 0, this._currentSymbolCursor = 0, this._styleProps = /* @__PURE__ */ new Map(), this._allNeededMatrices = /* @__PURE__ */ new Map(), this._gridIndex = new i3(r11, s5, t4), this._si = Math.sin(Math.PI * a8 / 180), this._co = Math.cos(Math.PI * a8 / 180);
    for (const t9 of o3)
      for (const n11 of t9.symbols)
        this._allNeededMatrices.has(n11.tile) || this._allNeededMatrices.set(n11.tile, r3(n11.tile.transforms.tileUnitsToPixels));
  }
  work(e9) {
    const t9 = this._gridIndex;
    function n11(e10) {
      const n12 = e10.xScreen + e10.dxScreen, o4 = e10.yScreen + e10.dyScreen, r11 = n12 + e10.width, s5 = o4 + e10.height, [i7, l10, a8, c5] = t9.getCellSpan(n12, o4, r11, s5);
      for (let h6 = l10; h6 <= c5; h6++)
        for (let e11 = i7; e11 <= a8; e11++) {
          const i8 = t9.cells[h6][e11];
          for (const e12 of i8) {
            const t10 = e12.xScreen + e12.dxScreen, i9 = e12.yScreen + e12.dyScreen, l11 = t10 + e12.width, a9 = i9 + e12.height;
            if (!(r11 < t10 || n12 > l11 || s5 < i9 || o4 > a9))
              return true;
          }
        }
      return false;
    }
    const o3 = performance.now();
    for (; this._currentLayerCursor < this._symbols.length; this._currentLayerCursor++, this._currentSymbolCursor = 0) {
      const t10 = this._symbols[this._currentLayerCursor], r11 = this._getProperties(t10.styleLayerUID);
      for (; this._currentSymbolCursor < t10.symbols.length; this._currentSymbolCursor++) {
        if (this._currentSymbolCursor % 100 == 99 && performance.now() - o3 > e9)
          return false;
        const s5 = t10.symbols[this._currentSymbolCursor];
        if (!s5.unique.show)
          continue;
        i4(s5, this._si, this._co, r11, this._allNeededMatrices.get(s5.tile), this._zoom);
        const l10 = s5.unique;
        if (!l10.show)
          continue;
        const { iconAllowOverlap: a8, iconIgnorePlacement: c5, textAllowOverlap: h6, textIgnorePlacement: u7 } = r11;
        for (const e10 of s5.colliders) {
          if (!e10.enabled)
            continue;
          const t11 = l10.parts[e10.partIndex];
          if (!t11.show)
            continue;
          !(e10.partIndex ? h6 : a8) && n11(e10) && (e10.hard ? l10.show = false : t11.show = false);
        }
        if (l10.show)
          for (const e10 of s5.colliders) {
            if (!e10.enabled)
              continue;
            if (e10.partIndex ? u7 : c5)
              continue;
            if (!l10.parts[e10.partIndex].show)
              continue;
            const t11 = e10.xScreen + e10.dxScreen, n12 = e10.yScreen + e10.dyScreen, o4 = t11 + e10.width, r12 = n12 + e10.height, [s6, i7, a9, h7] = this._gridIndex.getCellSpan(t11, n12, o4, r12);
            for (let l11 = i7; l11 <= h7; l11++)
              for (let t12 = s6; t12 <= a9; t12++) {
                this._gridIndex.cells[l11][t12].push(e10);
              }
          }
      }
    }
    return true;
  }
  _getProperties(e9) {
    const t9 = this._styleProps.get(e9);
    if (t9)
      return t9;
    const n11 = this._zoom, s5 = this._styleRepository.getStyleLayerByUID(e9), i7 = s5.getLayoutValue("symbol-placement", n11) !== n4.POINT;
    let l10 = s5.getLayoutValue("icon-rotation-alignment", n11);
    l10 === l2.AUTO && (l10 = i7 ? l2.MAP : l2.VIEWPORT);
    let a8 = s5.getLayoutValue("text-rotation-alignment", n11);
    a8 === l2.AUTO && (a8 = i7 ? l2.MAP : l2.VIEWPORT);
    const c5 = s5.getPaintValue("icon-translate", n11), h6 = s5.getPaintValue("icon-translate-anchor", n11), u7 = s5.getPaintValue("text-translate", n11), d2 = s5.getPaintValue("text-translate-anchor", n11), y5 = { iconAllowOverlap: s5.getLayoutValue("icon-allow-overlap", n11), iconIgnorePlacement: s5.getLayoutValue("icon-ignore-placement", n11), textAllowOverlap: s5.getLayoutValue("text-allow-overlap", n11), textIgnorePlacement: s5.getLayoutValue("text-ignore-placement", n11), iconRotationAlignment: l10, textRotationAlignment: a8, iconTranslateAnchor: h6, iconTranslate: c5, textTranslateAnchor: d2, textTranslate: u7 };
    return this._styleProps.set(e9, y5), y5;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolDeclutterer.js
function t6(o3, e9) {
  if (o3.priority - e9.priority)
    return o3.priority - e9.priority;
  const t9 = o3.tile.key, i7 = e9.tile.key;
  return t9.world - i7.world ? t9.world - i7.world : t9.level - i7.level ? t9.level - i7.level : t9.row - i7.row ? t9.row - i7.row : t9.col - i7.col ? t9.col - i7.col : o3.xTile - e9.xTile ? o3.xTile - e9.xTile : o3.yTile - e9.yTile;
}
var i5 = class {
  constructor(o3, e9, t9, i7, s5, r11) {
    this._visibleTiles = o3, this._symbolRepository = e9, this._createCollisionJob = t9, this._assignTileSymbolsOpacity = i7, this._symbolLayerSorter = s5, this._isLayerVisible = r11, this._selectionJob = null, this._selectionJobCompleted = false, this._collisionJob = null, this._collisionJobCompleted = false, this._opacityJob = null, this._opacityJobCompleted = false, this._running = true;
  }
  get running() {
    return this._running;
  }
  setScreenSize(o3, e9) {
    this._screenWidth === o3 && this._screenHeight === e9 || this.restart(), this._screenWidth = o3, this._screenHeight = e9;
  }
  restart() {
    this._selectionJob = null, this._selectionJobCompleted = false, this._collisionJob = null, this._collisionJobCompleted = false, this._opacityJob = null, this._opacityJobCompleted = false, this._running = true;
  }
  continue(o3) {
    if (this._selectionJob || (this._selectionJob = this._createSelectionJob()), !this._selectionJobCompleted) {
      const e9 = performance.now();
      if (!this._selectionJob.work(o3))
        return false;
      if (this._selectionJobCompleted = true, 0 === (o3 = Math.max(0, o3 - (performance.now() - e9))))
        return false;
    }
    if (this._collisionJob || (this._collisionJob = this._createCollisionJob(this._selectionJob.sortedSymbols, this._screenWidth, this._screenHeight)), !this._collisionJobCompleted) {
      const e9 = performance.now();
      if (!this._collisionJob.work(o3))
        return false;
      if (this._collisionJobCompleted = true, 0 === (o3 = Math.max(0, o3 - (performance.now() - e9))))
        return false;
    }
    if (this._opacityJob || (this._opacityJob = this._createOpacityJob()), !this._opacityJobCompleted) {
      const e9 = performance.now();
      if (!this._opacityJob.work(o3))
        return false;
      if (this._opacityJobCompleted = true, 0 === (o3 = Math.max(0, o3 - (performance.now() - e9))))
        return false;
    }
    return this._running = false, true;
  }
  _createSelectionJob() {
    const o3 = this._symbolRepository.uniqueSymbols;
    for (let t9 = 0; t9 < o3.length; t9++) {
      const e10 = o3[t9];
      for (let o4 = 0; o4 < e10.uniqueSymbols.length; o4++) {
        const t10 = e10.uniqueSymbols[o4];
        for (const o5 of t10.tileSymbols)
          o5.selectedForRendering = false;
      }
    }
    const e9 = [];
    let i7 = 0, s5 = 0;
    const r11 = this._isLayerVisible;
    function n11(n12) {
      let l11;
      const c5 = performance.now();
      for (; s5 < o3.length; s5++, i7 = 0) {
        const t9 = o3[s5], h6 = t9.styleLayerUID;
        if (!r11(h6)) {
          e9[s5] || (e9[s5] = { styleLayerUID: h6, symbols: [] });
          continue;
        }
        e9[s5] = e9[s5] || { styleLayerUID: h6, symbols: [] };
        const a8 = e9[s5];
        for (; i7 < t9.uniqueSymbols.length; i7++) {
          if (l11 = t9.uniqueSymbols[i7], i7 % 100 == 99 && performance.now() - c5 > n12)
            return false;
          let o4 = null, e10 = false, s6 = false;
          for (const t10 of l11.tileSymbols)
            if (!s6 || !e10) {
              const i8 = t10.tile;
              (!o4 || i8.isCoverage || i8.neededForCoverage && !e10) && (o4 = t10, (i8.neededForCoverage || i8.isCoverage) && (s6 = true), i8.isCoverage && (e10 = true));
            }
          if (o4.selectedForRendering = true, s6) {
            a8.symbols.push(o4), l11.show = true;
            for (const o5 of l11.parts)
              o5.show = true;
          } else
            l11.show = false;
        }
      }
      for (const o4 of e9)
        o4.symbols.sort(t6);
      return true;
    }
    const l10 = this._symbolLayerSorter;
    return { work: n11, get sortedSymbols() {
      return e9.sort(l10);
    } };
  }
  _createOpacityJob() {
    const e9 = this._assignTileSymbolsOpacity, t9 = this._visibleTiles;
    let i7 = 0;
    function r11(o3, t10) {
      const i8 = o3.symbols;
      for (const [e10, r12] of i8)
        s4(r12, t10);
      e9(o3, t10);
      for (const e10 of o3.childrenTiles)
        r11(e10, t10);
    }
    return { work(e10) {
      const s5 = performance.now();
      for (; i7 < t9.length; i7++) {
        if (performance.now() - s5 > e10)
          return false;
        const n11 = t9[i7];
        if (r(n11.parentTile))
          continue;
        r11(n11, performance.now());
      }
      return true;
    } };
  }
};
function s4(o3, t9) {
  for (const i7 of o3) {
    const o4 = i7.unique;
    for (const i8 of o4.parts) {
      const s5 = i8.targetOpacity > 0.5 ? 1 : -1;
      i8.startOpacity += s5 * ((t9 - i8.startTime) / e6), i8.startOpacity = Math.min(Math.max(i8.startOpacity, 0), 1), i8.startTime = t9, i8.targetOpacity = o4.show && i8.show ? 1 : 0;
    }
  }
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolRepository.js
var l8 = 32;
var i6 = 8;
var n9 = 64;
var r10 = class {
  constructor(e9, s5, o3) {
    this.tileCoordRange = e9, this._visibleTiles = s5, this._createUnique = o3, this._tiles = /* @__PURE__ */ new Map(), this._uniqueSymbolsReferences = /* @__PURE__ */ new Map();
  }
  get uniqueSymbols() {
    return t(this._uniqueSymbolLayerArray) && (this._uniqueSymbolLayerArray = this._createUniqueSymbolLayerArray()), this._uniqueSymbolLayerArray;
  }
  add(e9, s5) {
    this._uniqueSymbolLayerArray = null;
    let t9 = this._tiles.get(e9.id);
    t9 || (t9 = { symbols: /* @__PURE__ */ new Map() }, this._tiles.set(e9.id, t9));
    const r11 = /* @__PURE__ */ new Map();
    if (s5)
      for (const o3 of s5)
        t9.symbols.has(o3) && (r11.set(o3, t9.symbols.get(o3)), t9.symbols.delete(o3));
    else
      for (const [o3, l10] of e9.layerData)
        t9.symbols.has(o3) && (r11.set(o3, t9.symbols.get(o3)), t9.symbols.delete(o3));
    this._removeSymbols(r11);
    const y5 = e9.symbols, a8 = /* @__PURE__ */ new Map();
    for (const [f3, c5] of y5) {
      let e10 = c5.length;
      if (e10 >= l8) {
        let s6 = this.tileCoordRange;
        do {
          s6 /= 2, e10 /= 4;
        } while (e10 > i6 && s6 > n9);
        const l10 = new i3(this.tileCoordRange, this.tileCoordRange, s6);
        a8.set(f3, { flat: c5, index: l10 }), t9.symbols.set(f3, { flat: c5, index: l10 });
        for (const e11 of c5)
          l10.getCell(e11.xTile, e11.yTile).push(e11);
      } else
        a8.set(f3, { flat: c5 }), t9.symbols.set(f3, { flat: c5 });
    }
    this._addSymbols(e9.key, y5);
  }
  deleteStyleLayers(e9) {
    this._uniqueSymbolLayerArray = null;
    for (const [s5, o3] of this._tiles) {
      const t9 = /* @__PURE__ */ new Map();
      for (const s6 of e9)
        o3.symbols.has(s6) && (t9.set(s6, o3.symbols.get(s6)), o3.symbols.delete(s6));
      this._removeSymbols(t9), 0 === o3.symbols.size && this._tiles.delete(s5);
    }
  }
  removeTile(e9) {
    this._uniqueSymbolLayerArray = null;
    const s5 = this._tiles.get(e9.id);
    if (!s5)
      return;
    const o3 = /* @__PURE__ */ new Map();
    for (const [t9, l10] of e9.symbols)
      s5.symbols.has(t9) && (o3.set(t9, s5.symbols.get(t9)), s5.symbols.delete(t9));
    this._removeSymbols(o3), 0 === s5.symbols.size && this._tiles.delete(e9.id);
  }
  _removeSymbols(e9) {
    for (const [s5, { flat: o3 }] of e9)
      for (const e10 of o3) {
        const o4 = e10.unique, t9 = o4.tileSymbols, l10 = t9.length - 1;
        for (let s6 = 0; s6 < l10; s6++)
          if (t9[s6] === e10) {
            t9[s6] = t9[l10];
            break;
          }
        if (t9.length = l10, 0 === l10) {
          const e11 = this._uniqueSymbolsReferences.get(s5);
          e11.delete(o4), 0 === e11.size && this._uniqueSymbolsReferences.delete(s5);
        }
        e10.unique = null;
      }
  }
  _addSymbols(s5, o3) {
    if (0 === o3.size)
      return;
    const t9 = this._visibleTiles;
    for (const e9 of t9)
      e9.parentTile || e9.key.world !== s5.world || e9.key.level === s5.level && !e9.key.equals(s5) || this._matchSymbols(e9, s5, o3);
    for (const [l10, i7] of o3)
      for (const s6 of i7)
        if (t(s6.unique)) {
          const e9 = this._createUnique();
          s6.unique = e9, e9.tileSymbols.push(s6);
          let o4 = this._uniqueSymbolsReferences.get(l10);
          o4 || (o4 = /* @__PURE__ */ new Set(), this._uniqueSymbolsReferences.set(l10, o4)), o4.add(e9);
        }
  }
  _matchSymbols(e9, o3, l10) {
    if (e9.key.level > o3.level) {
      const s5 = e9.key.level - o3.level;
      if (e9.key.row >> s5 !== o3.row || e9.key.col >> s5 !== o3.col)
        return;
    }
    if (o3.level > e9.key.level) {
      const s5 = o3.level - e9.key.level;
      if (o3.row >> s5 !== e9.key.row || o3.col >> s5 !== e9.key.col)
        return;
    }
    if (o3.equals(e9.key)) {
      for (const s5 of e9.childrenTiles)
        this._matchSymbols(s5, o3, l10);
      return;
    }
    const i7 = /* @__PURE__ */ new Map();
    for (const [n11, r11] of l10) {
      const l11 = [];
      for (const s5 of r11) {
        const i8 = l5(this.tileCoordRange, s5.xTile, o3.level, o3.col, e9.key.level, e9.key.col), n12 = l5(this.tileCoordRange, s5.yTile, o3.level, o3.row, e9.key.level, e9.key.row);
        i8 >= 0 && i8 < this.tileCoordRange && n12 >= 0 && n12 < this.tileCoordRange && l11.push({ symbol: s5, xTransformed: i8, yTransformed: n12 });
      }
      const y5 = [], a8 = e9.key.level < o3.level ? 1 : 1 << e9.key.level - o3.level, f3 = this._tiles.get(e9.id).symbols.get(n11);
      if (f3) {
        const e10 = f3.flat;
        for (const o4 of l11) {
          let t9, l12 = false;
          const i8 = o4.xTransformed, n12 = o4.yTransformed;
          t9 = r(f3.index) ? f3.index.getCell(i8, n12) : e10;
          const r12 = o4.symbol, c5 = r12.hash;
          for (const e11 of t9)
            if (c5 === e11.hash && Math.abs(i8 - e11.xTile) <= a8 && Math.abs(n12 - e11.yTile) <= a8) {
              const s5 = e11.unique;
              r12.unique = s5, s5.tileSymbols.push(r12), l12 = true;
              break;
            }
          l12 || y5.push(r12);
        }
      }
      y5.length > 0 && i7.set(n11, y5);
    }
    for (const s5 of e9.childrenTiles)
      this._matchSymbols(s5, o3, i7);
  }
  _createUniqueSymbolLayerArray() {
    const e9 = this._uniqueSymbolsReferences, s5 = new Array(e9.size);
    let o3, t9 = 0;
    for (const [l10, i7] of e9) {
      const e10 = new Array(i7.size);
      o3 = 0;
      for (const s6 of i7)
        e10[o3++] = s6;
      s5[t9] = { styleLayerUID: l10, uniqueSymbols: e10 }, t9++;
    }
    return s5;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolFader.js
var n10 = 0.5;
var _ = 1e-6;
var m3 = class extends n2 {
  constructor(t9, e9) {
    super(), this.styleRepository = t9, this._tileToHandle = /* @__PURE__ */ new Map(), this._viewState = { scale: 0, rotation: 0, center: [0, 0], size: [0, 0] }, this._declutterViewState = { scale: 0, rotation: 0, center: [0, 0], size: [0, 0] }, this._completed = false, this._symbolRepository = new r10(4096, e9, () => new s3()), this._symbolDeclutterer = new i5(e9, this._symbolRepository, (t10, e10, i7) => new l7(t10, e10, i7, this.styleRepository, this._zoom, this._viewState.rotation), (t10, e10) => {
      t10.allSymbolsFadingOut = true, t10.lastOpacityUpdate = e10, c3(t10, e10, true), t10.decluttered = true, t10.requestRender();
    }, (t10, e10) => this.styleRepository.getStyleLayerByUID(t10.styleLayerUID).z - this.styleRepository.getStyleLayerByUID(e10.styleLayerUID).z, (t10) => {
      const e10 = this.styleRepository.getStyleLayerByUID(t10);
      if (this._zoom + _ < e10.minzoom || this._zoom - _ >= e10.maxzoom)
        return false;
      const i7 = e10.getLayoutProperty("visibility");
      return !i7 || i7.getValue() !== i.NONE;
    });
  }
  addTile(t9) {
    t9.decluttered = false, this._tileToHandle.set(t9, t9.on("symbols-changed", () => {
      this._symbolRepository.add(t9), this.restartDeclutter();
    })), this._symbolRepository.add(t9), this.restartDeclutter();
  }
  removeTile(t9) {
    const e9 = this._tileToHandle.get(t9);
    e9 && (this._symbolRepository.removeTile(t9), this.restartDeclutter(), e9.remove(), this._tileToHandle.delete(t9));
  }
  update(t9, e9) {
    return this._zoom = t9, this._viewState = { scale: e9.scale, rotation: e9.rotation, center: [e9.center[0], e9.center[1]], size: [e9.size[0], e9.size[1]] }, this._continueDeclutter(), this._completed;
  }
  restartDeclutter() {
    this._completed = false, this._symbolDeclutterer.restart(), this._notifyUnstable();
  }
  clear() {
    this._completed = false, this._symbolRepository = null, this._symbolDeclutterer.restart(), this._tileToHandle.forEach((t9) => t9.remove()), this._tileToHandle.clear();
  }
  get stale() {
    return this._zoom !== this._declutterZoom || this._viewState.size[0] !== this._declutterViewState.size[0] || this._viewState.size[1] !== this._declutterViewState.size[1] || this._viewState.scale !== this._declutterViewState.scale || this._viewState.rotation !== this._declutterViewState.rotation;
  }
  deleteStyleLayers(t9) {
    this._symbolRepository.deleteStyleLayers(t9);
  }
  _continueDeclutter() {
    this._completed && !this.stale || (this._symbolDeclutterer.running || (this._declutterZoom = this._zoom, this._declutterViewState.center[0] = this._viewState.center[0], this._declutterViewState.center[1] = this._viewState.center[1], this._declutterViewState.rotation = this._viewState.rotation, this._declutterViewState.scale = this._viewState.scale, this._declutterViewState.size[0] = this._viewState.size[0], this._declutterViewState.size[1] = this._viewState.size[1], this._symbolDeclutterer.restart()), this._symbolDeclutterer.setScreenSize(this._viewState.size[0], this._viewState.size[1]), this._completed = this._symbolDeclutterer.continue(c), this._completed && this._scheduleNotifyStable());
  }
  _scheduleNotifyStable() {
    r(this._stableNotificationHandle) && clearTimeout(this._stableNotificationHandle), this._stableNotificationHandle = setTimeout(() => {
      this._stableNotificationHandle = null, this.emit("fade-complete");
    }, (1 + n10) * e6);
  }
  _notifyUnstable() {
    r(this._stableNotificationHandle) && (clearTimeout(this._stableNotificationHandle), this._stableNotificationHandle = null), this.emit("fade-start");
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/RenderableTile.js
var t7 = class extends r6 {
  _createTransforms() {
    return { dvs: e4(), tileMat3: e4() };
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/VectorTileContainer.js
var _2 = 1e-6;
function f2(e9, t9) {
  if (e9) {
    const s5 = e9.getLayoutProperty("visibility");
    if (!s5 || s5.getValue() !== i.NONE && (void 0 === e9.minzoom || e9.minzoom < t9 + _2) && (void 0 === e9.maxzoom || e9.maxzoom >= t9 - _2))
      return true;
  }
  return false;
}
var b2 = class extends i2 {
  constructor(e9) {
    super(e9), this._backgroundTiles = [], this._pointToCallbacks = /* @__PURE__ */ new Map();
  }
  destroy() {
    this.removeAllChildren(), this._spriteMosaic && (this._spriteMosaic.dispose(), this._spriteMosaic = null), this._glyphMosaic && (this._glyphMosaic.dispose(), this._glyphMosaic = null), r(this._symbolFader) && (this._symbolFader.clear(), this._symbolFader = null), this._styleRepository = null, this._backgroundTiles = [], this._pointToCallbacks.clear();
  }
  setStyleResources(e9, r11, i7) {
    if (this._spriteMosaic = e9, this._glyphMosaic = r11, this._styleRepository = i7, t(this._symbolFader)) {
      const e10 = new m3(this._styleRepository, this.children);
      e10.on("fade-start", () => {
        this.emit("fade-start"), this.requestRender();
      }), e10.on("fade-complete", () => {
        this.emit("fade-complete"), this.requestRender();
      }), this._symbolFader = e10;
    }
    e(this._symbolFader).styleRepository = i7;
  }
  setSpriteMosaic(e9) {
    this._spriteMosaic.dispose(), this._spriteMosaic = e9;
  }
  deleteStyleLayers(t9) {
    r(this._symbolFader) && this._symbolFader.deleteStyleLayers(t9);
  }
  async hitTest(e9) {
    const t9 = D();
    return this._pointToCallbacks.set(e9, t9), this.requestRender(), t9.promise;
  }
  enterTileInvalidation() {
    for (const e9 of this.children)
      e9.invalidating = true;
  }
  createRenderParams(e9) {
    return { ...super.createRenderParams(e9), renderPass: null, styleLayer: null, styleLayerUID: -1, glyphMosaic: this._glyphMosaic, spriteMosaic: this._spriteMosaic, hasClipping: !!this._clippingInfos };
  }
  doRender(e9) {
    !this.visible || e9.drawPhase !== I3.MAP && e9.drawPhase !== I3.DEBUG || void 0 === this._spriteMosaic || super.doRender(e9);
  }
  addChild(t9) {
    return super.addChild(t9), r(this._symbolFader) ? this._symbolFader.addTile(t9) : t9.decluttered = true, this.requestRender(), t9;
  }
  removeChild(t9) {
    return r(this._symbolFader) && this._symbolFader.removeTile(t9), this.requestRender(), super.removeChild(t9);
  }
  renderChildren(e9) {
    const { drawPhase: t9 } = e9;
    if (t9 !== I3.DEBUG) {
      if (this._doRender(e9), this._pointToCallbacks.size > 0) {
        e9.drawPhase = I3.HITTEST;
        const s5 = e9.painter.effects.hittestVTL;
        s5.bind(e9), this._doRender(e9), s5.draw(e9, this._pointToCallbacks), s5.unbind(e9), e9.drawPhase = t9;
      }
    } else
      super.renderChildren(e9);
  }
  removeAllChildren() {
    for (let t9 = 0; t9 < this.children.length; t9++) {
      const s5 = this.children[t9];
      r(this._symbolFader) && this._symbolFader.removeTile(s5), s5.dispose();
    }
    super.removeAllChildren();
  }
  getStencilTarget() {
    return this.children.filter((e9) => e9.neededForCoverage && e9.hasData());
  }
  restartDeclutter() {
    r(this._symbolFader) && this._symbolFader.restartDeclutter();
  }
  _doRender(e9) {
    const { context: t9 } = e9, s5 = this._styleRepository;
    if (!s5)
      return;
    const r11 = s5.layers;
    let i7 = true;
    e9.drawPhase === I3.HITTEST && (i7 = false), s5.backgroundBucketIds.length > 0 && (e9.renderPass = "background", this._renderBackgroundLayers(e9, s5.backgroundBucketIds)), super.renderChildren(e9), e9.drawPhase === I3.MAP && this._fade(e9.displayLevel, e9.state);
    const o3 = this.children.filter((e10) => e10.visible && e10.hasData());
    if (!o3 || 0 === o3.length)
      return t9.bindVAO(), t9.setStencilTestEnabled(true), void t9.setBlendingEnabled(true);
    for (const l10 of o3)
      l10.triangleCount = 0;
    t9.setStencilWriteMask(0), t9.setColorMask(true, true, true, true), t9.setStencilOp(O.KEEP, O.KEEP, O.REPLACE), t9.setStencilTestEnabled(true), t9.setBlendingEnabled(false), t9.setDepthTestEnabled(true), t9.setDepthWriteEnabled(true), t9.setDepthFunction(I.LEQUAL), t9.setClearDepth(1), t9.clear(t9.gl.DEPTH_BUFFER_BIT), e9.renderPass = "opaque";
    for (let l10 = r11.length - 1; l10 >= 0; l10--)
      this._renderStyleLayer(r11[l10], e9, o3);
    t9.setDepthWriteEnabled(false), t9.setBlendingEnabled(i7), t9.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA), e9.renderPass = "translucent";
    for (let l10 = 0; l10 < r11.length; l10++)
      this._renderStyleLayer(r11[l10], e9, o3);
    t9.bindVAO(), t9.setStencilTestEnabled(true), t9.setBlendingEnabled(true);
  }
  _fade(t9, s5) {
    r(this._symbolFader) && (this._symbolFader.update(t9, s5) || this.requestRender());
  }
  _renderStyleLayer(e9, t9, s5) {
    const { painter: r11, renderPass: i7 } = t9;
    if (void 0 === e9)
      return;
    const o3 = e9.getLayoutProperty("visibility");
    if (o3 && o3.getValue() === i.NONE)
      return;
    let a8;
    switch (e9.type) {
      case a3.BACKGROUND:
        return;
      case a3.FILL:
        if ("opaque" !== i7 && "translucent" !== t9.renderPass)
          return;
        a8 = "vtlFill";
        break;
      case a3.LINE:
        if ("translucent" !== i7)
          return;
        a8 = "vtlLine";
        break;
      case a3.CIRCLE:
        if ("translucent" !== i7)
          return;
        a8 = "vtlCircle";
        break;
      case a3.SYMBOL:
        if ("translucent" !== i7)
          return;
        a8 = "vtlSymbol";
    }
    if (s5 = e9.type === a3.SYMBOL ? s5.filter((e10) => e10.decluttered) : s5.filter((e10) => e10.neededForCoverage), "vtlSymbol" !== a8) {
      const r12 = t9.displayLevel;
      if (0 === s5.length || void 0 !== e9.minzoom && e9.minzoom >= r12 + _2 || void 0 !== e9.maxzoom && e9.maxzoom < r12 - _2)
        return;
    }
    const d2 = e9.uid;
    t9.styleLayerUID = d2, t9.styleLayer = e9;
    for (const l10 of s5)
      if (l10.layerData.has(d2)) {
        r11.renderObjects(t9, s5, a8);
        break;
      }
  }
  _renderBackgroundLayers(t9, s5) {
    const { context: r11, displayLevel: o3, painter: l10, state: h6 } = t9, m4 = this._styleRepository;
    let _4 = false;
    for (const e9 of s5) {
      if (m4.getLayerById(e9).type === a3.BACKGROUND && f2(m4.getLayerById(e9), o3)) {
        _4 = true;
        break;
      }
    }
    if (!_4)
      return;
    const b3 = this._tileInfoView.getTileCoverage(t9.state, 0, "smallest"), { spans: g2, lodInfo: T } = b3, { level: E6 } = T, C2 = u(), L3 = [];
    if (this._renderPasses) {
      const s6 = this._renderPasses[0];
      r(this._clippingInfos) && (s6.brushes[0].prepareState(t9), s6.brushes[0].drawMany(t9, this._clippingInfos));
    }
    const v = this._backgroundTiles;
    let R2, S = 0;
    for (const { row: e9, colFrom: n11, colTo: a8 } of g2)
      for (let t10 = n11; t10 <= a8; t10++) {
        if (S < v.length)
          R2 = v[S], R2.key.set(E6, e9, T.normalizeCol(t10), T.getWorldForColumn(t10)), this._tileInfoView.getTileBounds(C2, R2.key, false), R2.x = C2[0], R2.y = C2[3], R2.resolution = this._tileInfoView.getTileResolution(E6);
        else {
          const s6 = new e5(E6, e9, T.normalizeCol(t10), T.getWorldForColumn(t10)), r12 = this._tileInfoView.getTileBounds(u(), s6), o4 = this._tileInfoView.getTileResolution(E6);
          R2 = new t7(s6, o4, r12[0], r12[3], 512, 512, 4096, 4096), v.push(R2);
        }
        R2.setTransform(h6), L3.push(R2), S++;
      }
    r11.setStencilWriteMask(0), r11.setColorMask(true, true, true, true), r11.setStencilOp(O.KEEP, O.KEEP, O.REPLACE), r11.setStencilFunction(I.EQUAL, 0, 255);
    let F2 = true;
    t9.drawPhase === I3.HITTEST && (F2 = false), r11.setStencilTestEnabled(F2);
    for (const e9 of s5) {
      const s6 = m4.getLayerById(e9);
      s6.type === a3.BACKGROUND && f2(s6, o3) && (t9.styleLayerUID = s6.uid, t9.styleLayer = s6, l10.renderObjects(t9, L3, "vtlBackground"));
    }
    l4.pool.release(b3);
  }
};

// node_modules/@arcgis/core/views/2d/layers/support/DebugOverlay.js
var _3 = { geometry: [new t2("a_PositionAndFlags", 3, C.SHORT, 0, 6)] };
var u6 = /* @__PURE__ */ new Map();
u6.set("a_PositionAndFlags", 0);
var l9 = { vsPath: "debug/overlay", fsPath: "debug/overlay", attributes: u6 };
var d = class extends r5 {
  constructor(e9) {
    super(), this._conf = e9;
  }
  static makeFlags(e9, t9) {
    return e9 | t9 << 2;
  }
  _createTransforms() {
    return { dvs: e4() };
  }
  doRender(e9) {
    this._updateTransforms(e9), this._ensureResources(e9);
    const { context: t9 } = e9;
    t9.useProgram(this._program), this._program.setUniformMatrix3fv("u_dvsMat3", this.transforms.dvs), this._program.setUniform4fv("u_colors", this._conf.getColors(e9)), this._program.setUniform1fv("u_opacities", this._conf.getOpacities(e9));
    const { vertexData: s5, indexData: r11 } = this._conf.getMesh(e9);
    this._vertexBuffer.setData(s5), this._indexBuffer.setData(r11), t9.bindVAO(this._vertexArray), t9.setBlendingEnabled(true), t9.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), t9.setDepthTestEnabled(false), t9.setStencilTestEnabled(false), t9.setColorMask(true, true, true, true), t9.drawElements(E3.TRIANGLES, r11.length, C.UNSIGNED_INT, 0);
  }
  onDetach() {
    this._vertexArray && (this._vertexArray.dispose(), this._vertexArray = null);
  }
  _updateTransforms(r11) {
    r2(this.transforms.dvs), M(this.transforms.dvs, this.transforms.dvs, [-1, 1]), f(this.transforms.dvs, this.transforms.dvs, [2 / r11.state.size[0], -2 / r11.state.size[1], 1]);
  }
  _ensureResources(e9) {
    const { context: t9 } = e9;
    this._program || (this._program = e9.painter.materialManager.getProgram(l9)), this._vertexBuffer || (this._vertexBuffer = E5.createVertex(t9, F.STREAM_DRAW)), this._indexBuffer || (this._indexBuffer = E5.createIndex(t9, F.STREAM_DRAW)), this._vertexArray || (this._vertexArray = new a2(t9, u6, _3, { geometry: this._vertexBuffer }, this._indexBuffer));
  }
};

// node_modules/@arcgis/core/views/2d/tiling/TileInfoViewPOT.js
var t8 = class extends h3 {
  constructor() {
    super(...arguments), this._fullCacheLodInfos = null, this._levelByScale = {};
  }
  getTileParentId(e9) {
    const l10 = e5.pool.acquire(e9), t9 = 0 === l10.level ? null : e5.getId(l10.level - 1, l10.row >> 1, l10.col >> 1, l10.world);
    return e5.pool.release(l10), t9;
  }
  getTileCoverage(e9, l10, s5) {
    const t9 = super.getTileCoverage(e9, l10, s5);
    if (!t9)
      return t9;
    const o3 = 1 << t9.lodInfo.level;
    return t9.spans = t9.spans.filter((e10) => e10.row >= 0 && e10.row < o3), t9;
  }
  scaleToLevel(e9) {
    if (this._fullCacheLodInfos || this._initializeFullCacheLODs(this._lodInfos), this._levelByScale[e9])
      return this._levelByScale[e9];
    {
      const l10 = this._fullCacheLodInfos;
      if (e9 > l10[0].scale)
        return l10[0].level;
      let s5, t9;
      for (let o3 = 0; o3 < l10.length - 1; o3++)
        if (t9 = l10[o3 + 1], e9 > t9.scale)
          return s5 = l10[o3], s5.level + (s5.scale - e9) / (s5.scale - t9.scale);
      return l10[l10.length - 1].level;
    }
  }
  _initializeFullCacheLODs(l10) {
    let s5;
    if (0 === l10[0].level)
      s5 = l10.map((e9) => ({ level: e9.level, resolution: e9.resolution, scale: e9.scale }));
    else {
      const l11 = this.tileInfo.size[0], t9 = this.tileInfo.spatialReference;
      s5 = j2.create({ size: l11, spatialReference: t9 }).lods.map((e9) => ({ level: e9.level, resolution: e9.resolution, scale: e9.scale }));
    }
    for (let e9 = 0; e9 < s5.length; e9++)
      this._levelByScale[s5[e9].scale] = s5[e9].level;
    this._fullCacheLodInfos = s5;
  }
};

// node_modules/@arcgis/core/views/2d/layers/VectorTileLayerView2D.js
var D3 = class extends y4(u3) {
  constructor() {
    super(...arguments), this._styleChanges = [], this._fetchQueue = null, this._parseQueue = null, this._isTileHandlerReady = false, this.fading = false, this._getCollidersMesh = (e9) => {
      const { pixelRatio: t9 } = e9.state;
      let i7 = 0;
      const s5 = [], r11 = [];
      for (const a8 of this._vectorTileContainer.children)
        if (a8.symbols)
          for (const [e10, l10] of a8.symbols)
            for (const a9 of l10)
              for (const e11 of a9.colliders) {
                const l11 = (e11.xScreen + e11.dxScreen) * t9, n11 = (e11.yScreen + e11.dyScreen) * t9, o3 = e11.width * t9, h6 = e11.height * t9, u7 = a9.unique.parts[e11.partIndex].targetOpacity > 0.5;
                if (!u7 && "all" !== this.layer.showCollisionBoxes)
                  continue;
                const c5 = 2, y5 = 0, p = 3, d2 = 0, _4 = 3, f3 = 1, g2 = 3, m4 = 0, C2 = u7 ? c5 : y5, T = u7 ? p : d2, v = d.makeFlags(C2, T);
                s5.push(l11, n11, v, l11 + o3, n11, v, l11, n11 + h6, v, l11 + o3, n11 + h6, v), r11.push(i7 + 0, i7 + 1, i7 + 2, i7 + 1, i7 + 3, i7 + 2), i7 += 4;
                const H = u7 ? _4 : f3, w = u7 ? g2 : m4, S = d.makeFlags(H, w);
                s5.push(l11, n11, S, l11 + o3, n11, S, l11, n11 + 1, S, l11 + o3, n11 + 1, S), r11.push(i7 + 0, i7 + 1, i7 + 2, i7 + 1, i7 + 3, i7 + 2), i7 += 4, s5.push(l11, n11 + h6 - 1, S, l11 + o3, n11 + h6 - 1, S, l11, n11 + h6, S, l11 + o3, n11 + h6, S), r11.push(i7 + 0, i7 + 1, i7 + 2, i7 + 1, i7 + 3, i7 + 2), i7 += 4, s5.push(l11, n11, S, l11 + 1, n11, S, l11, n11 + h6, S, l11 + 1, n11 + h6, S), r11.push(i7 + 0, i7 + 1, i7 + 2, i7 + 1, i7 + 3, i7 + 2), i7 += 4, s5.push(l11 + o3 - 1, n11, S, l11 + o3, n11, S, l11 + o3 - 1, n11 + h6, S, l11 + o3, n11 + h6, S), r11.push(i7 + 0, i7 + 1, i7 + 2, i7 + 1, i7 + 3, i7 + 2), i7 += 4;
              }
      return { vertexData: new Int16Array(s5), indexData: new Uint32Array(r11) };
    }, this._getCollidersColors = () => [1, 0.5, 0, 1, 1, 0, 0, 1, 0, 1, 0.5, 1, 0, 0.5, 0, 1], this._getCollidersOpacities = () => [0.05, 0.01, 0.15, 0.2];
  }
  async hitTest(e9, i7) {
    if (!this._tileHandlerPromise)
      return null;
    await this._tileHandlerPromise;
    const s5 = await this._vectorTileContainer.hitTest(i7);
    if (!s5 || 0 === s5.length)
      return null;
    const r11 = s5[0] - 1, a8 = this._styleRepository, l10 = a8.getStyleLayerByUID(r11);
    if (!l10)
      return null;
    const n11 = a8.getStyleLayerIndex(l10.id);
    return [{ type: "graphic", mapPoint: e9, layer: this.layer, graphic: new g({ attributes: { layerId: n11, layerName: l10.id, layerUID: r11 }, layer: this.layer, sourceLayer: this.layer }) }];
  }
  update(e9) {
    if (this._tileHandlerPromise && this._isTileHandlerReady)
      return e9.pixelRatio !== this._tileHandler.devicePixelRatio ? (this._start(), void (this._tileHandler.devicePixelRatio = e9.pixelRatio)) : void (this._styleChanges.length > 0 ? this._tileHandlerPromise = this._applyStyleChanges() : (this._fetchQueue.pause(), this._parseQueue.pause(), this._fetchQueue.state = e9.state, this._parseQueue.state = e9.state, this._tileManager.update(e9) || this.requestUpdate(), this._parseQueue.resume(), this._fetchQueue.resume()));
  }
  attach() {
    const { style: e9 } = this.layer.currentStyleInfo;
    this._styleRepository = new l3(e9), this._tileInfoView = new t8(this.layer.tileInfo, this.layer.fullExtent), this._vectorTileContainer = new b2(this._tileInfoView), this._tileHandler = new n6(this.layer, this._styleRepository, window.devicePixelRatio || 1), this.container.addChild(this._vectorTileContainer), this._start(), this.handles.add([this._vectorTileContainer.on("fade-start", () => {
      this.fading = true, this.notifyChange("updating"), this.requestUpdate();
    }), this._vectorTileContainer.on("fade-complete", () => {
      var _a;
      (_a = this._collisionOverlay) == null ? void 0 : _a.requestRender(), this.fading = false, this.notifyChange("updating"), this.requestUpdate();
    }), l(() => this.layer.showCollisionBoxes, (e10) => {
      "none" !== e10 ? this._collisionOverlay || (this._collisionOverlay = new d({ getMesh: this._getCollidersMesh, getColors: this._getCollidersColors, getOpacities: this._getCollidersOpacities }), this.container.addChild(this._collisionOverlay)) : (this.container.removeChild(this._collisionOverlay), this._collisionOverlay = null), this.container.requestRender();
    }, h), this.layer.on("paint-change", (e10) => {
      if (e10.isDataDriven)
        this._styleChanges.push({ type: L.PAINTER_CHANGED, data: e10 }), this.notifyChange("updating"), this.requestUpdate();
      else {
        const t9 = this._styleRepository, i7 = t9.getLayerById(e10.layer);
        if (!i7)
          return;
        const s5 = i7.type === a3.SYMBOL;
        t9.setPaintProperties(e10.layer, e10.paint), s5 && this._vectorTileContainer.restartDeclutter(), this._vectorTileContainer.requestRender();
      }
    }), this.layer.on("layout-change", (e10) => {
      const t9 = this._styleRepository, i7 = t9.getLayerById(e10.layer);
      if (!i7)
        return;
      const s5 = m(i7.layout, e10.layout);
      if (!t(s5)) {
        if (a(s5, "visibility") && 1 === Q(s5))
          return t9.setLayoutProperties(e10.layer, e10.layout), i7.type === a3.SYMBOL && this._vectorTileContainer.restartDeclutter(), void this._vectorTileContainer.requestRender();
        this._styleChanges.push({ type: L.LAYOUT_CHANGED, data: e10 }), this.notifyChange("updating"), this.requestUpdate();
      }
    }), this.layer.on("style-layer-visibility-change", (e10) => {
      const t9 = this._styleRepository, i7 = t9.getLayerById(e10.layer);
      i7 && (t9.setStyleLayerVisibility(e10.layer, e10.visibility), i7.type === a3.SYMBOL && this._vectorTileContainer.restartDeclutter(), this._vectorTileContainer.requestRender());
    }), this.layer.on("style-layer-change", (e10) => {
      this._styleChanges.push({ type: L.LAYER_CHANGED, data: e10 }), this.notifyChange("updating"), this.requestUpdate();
    }), this.layer.on("delete-style-layer", (e10) => {
      this._styleChanges.push({ type: L.LAYER_REMOVED, data: e10 }), this.notifyChange("updating"), this.requestUpdate();
    }), this.layer.on("load-style", () => this._loadStyle()), this.layer.on("spriteSource-change", (e10) => {
      this._newSpriteSource = e10.spriteSource, this._styleChanges.push({ type: L.SPRITES_CHANGED, data: null });
      const t9 = this._styleRepository.layers;
      for (const i7 of t9)
        switch (i7.type) {
          case a3.SYMBOL:
            i7.getLayoutProperty("icon-image") && this._styleChanges.push({ type: L.LAYOUT_CHANGED, data: { layer: i7.id, layout: i7.layout } });
            break;
          case a3.LINE:
            i7.getPaintProperty("line-pattern") && this._styleChanges.push({ type: L.PAINTER_CHANGED, data: { layer: i7.id, paint: i7.paint, isDataDriven: i7.isPainterDataDriven() } });
            break;
          case a3.FILL:
            i7.getLayoutProperty("fill-pattern") && this._styleChanges.push({ type: L.PAINTER_CHANGED, data: { layer: i7.id, paint: i7.paint, isDataDriven: i7.isPainterDataDriven() } });
        }
      this.notifyChange("updating"), this.requestUpdate();
    })], this.declaredClass);
  }
  detach() {
    var _a, _b;
    this._stop(), this.container.removeAllChildren(), (_a = this._vectorTileContainer) == null ? void 0 : _a.destroy(), this._vectorTileContainer = null, (_b = this._tileHandler) == null ? void 0 : _b.destroy(), this._tileHandler = null, this.handles.remove(this.declaredClass);
  }
  moveStart() {
    this.requestUpdate();
  }
  viewChange() {
    this.requestUpdate();
  }
  moveEnd() {
    this._collisionOverlay && this._vectorTileContainer.restartDeclutter(), this.requestUpdate();
  }
  supportsSpatialReference(e9) {
    var _a;
    return E2((_a = this.layer.tileInfo) == null ? void 0 : _a.spatialReference, e9);
  }
  canResume() {
    let e9 = super.canResume();
    const { currentStyleInfo: t9 } = this.layer;
    if (e9 && (t9 == null ? void 0 : t9.layerDefinition)) {
      const i7 = this.view.scale, { minScale: s5, maxScale: r11 } = t9.layerDefinition;
      t9 && t9.layerDefinition && (s5 && s5 < i7 && (e9 = false), r11 && r11 > i7 && (e9 = false));
    }
    return e9;
  }
  isUpdating() {
    const e9 = this._vectorTileContainer.children;
    return !this._isTileHandlerReady || !this._fetchQueue || !this._parseQueue || this._fetchQueue.updating || this._parseQueue.updating || e9.length > 0 && e9.some((e10) => e10.invalidating) || this.fading;
  }
  acquireTile(e9) {
    const t9 = this._createVectorTile(e9);
    return this._tileHandlerPromise.then(() => {
      this._fetchQueue.push(t9.key).then((e10) => this._parseQueue.push({ key: t9.key, data: e10 })).then((e10) => {
        t9.once("attach", () => this.requestUpdate()), t9.setData(e10), this.requestUpdate(), this.notifyChange("updating");
      }).catch((e10) => {
        this.notifyChange("updating"), j(e10) || s.getLogger(this.declaredClass).error(e10);
      });
    }), t9;
  }
  releaseTile(e9) {
    const t9 = e9.key.id;
    this._fetchQueue.abort(t9), this._parseQueue.abort(t9), this.requestUpdate();
  }
  _start() {
    if (this._stop(), this._tileManager = new a5({ acquireTile: (e10) => this.acquireTile(e10), releaseTile: (e10) => this.releaseTile(e10), tileInfoView: this._tileInfoView }, this._vectorTileContainer), !this.layer.currentStyleInfo)
      return;
    const e9 = new AbortController(), t9 = this._tileHandler.start({ signal: e9.signal }).then(() => {
      this._fetchQueue = new y3({ tileInfoView: this._tileInfoView, process: (e10, t10) => this._getTileData(e10, t10), concurrency: 15 }), this._parseQueue = new y3({ tileInfoView: this._tileInfoView, process: (e10, t10) => this._parseTileData(e10, t10), concurrency: 8 }), this.requestUpdate(), this._isTileHandlerReady = true;
    });
    this._tileHandler.spriteMosaic.then((e10) => {
      this._vectorTileContainer.setStyleResources(e10, this._tileHandler.glyphMosaic, this._styleRepository), this.requestUpdate();
    }), this._tileHandlerAbortController = e9, this._tileHandlerPromise = t9;
  }
  _stop() {
    if (!this._tileHandlerAbortController || !this._vectorTileContainer)
      return;
    const e9 = this._tileHandlerAbortController;
    e9 && e9.abort(), this._tileHandlerPromise = null, this._isTileHandlerReady = false, this._fetchQueue && (this._fetchQueue.destroy(), this._fetchQueue = null), this._parseQueue && (this._parseQueue.destroy(), this._parseQueue = null), this._tileManager && (this._tileManager.destroy(), this._tileManager = null), this._vectorTileContainer.removeAllChildren();
  }
  async _getTileData(e9, t9) {
    const i7 = await this._tileHandler.fetchTileData(e9, t9);
    return this.notifyChange("updating"), i7;
  }
  async _parseTileData(e9, t9) {
    return this._tileHandler.parseTileData(e9, t9);
  }
  async _applyStyleChanges() {
    this._isTileHandlerReady = false, this._fetchQueue.pause(), this._parseQueue.pause(), this._fetchQueue.clear(), this._parseQueue.clear(), this._tileManager.clearCache();
    const e9 = this._styleChanges;
    try {
      await this._tileHandler.updateStyle(e9);
    } catch (n11) {
      s.getLogger(this.declaredClass).error("error applying vector-tiles style update", n11.message), this._fetchQueue.resume(), this._parseQueue.resume(), this._isTileHandlerReady = true;
    }
    const t9 = this._styleRepository, i7 = [];
    e9.forEach((e10) => {
      if (e10.type !== L.LAYER_REMOVED)
        return;
      const s5 = e10.data, r12 = t9.getLayerById(s5.layer);
      r12 && i7.push(r12.uid);
    });
    const r11 = [];
    let a8;
    e9.forEach((e10) => {
      const i8 = e10.type, s5 = e10.data;
      switch (i8) {
        case L.PAINTER_CHANGED:
          t9.setPaintProperties(s5.layer, s5.paint), a8 = s5.layer;
          break;
        case L.LAYOUT_CHANGED:
          t9.setLayoutProperties(s5.layer, s5.layout), a8 = s5.layer;
          break;
        case L.LAYER_REMOVED:
          return void t9.deleteStyleLayer(s5.layer);
        case L.LAYER_CHANGED:
          t9.setStyleLayer(s5.layer, s5.index), a8 = s5.layer.id;
          break;
        case L.SPRITES_CHANGED:
          this._vectorTileContainer.setSpriteMosaic(this._tileHandler.setSpriteSource(this._newSpriteSource)), this._newSpriteSource = null, a8 = null;
      }
      const l11 = t9.getLayerById(a8);
      l11 && r11.push(l11.uid);
    });
    const l10 = this._vectorTileContainer.children;
    if (i7.length > 0) {
      this._vectorTileContainer.deleteStyleLayers(i7);
      for (const e10 of l10)
        e10.deleteLayerData(i7);
    }
    if (this._fetchQueue.resume(), this._parseQueue.resume(), r11.length > 0) {
      const e10 = [];
      for (const t10 of l10) {
        const i8 = this._fetchQueue.push(t10.key).then((e11) => this._parseQueue.push({ key: t10.key, data: e11, styleLayerUIDs: r11 })).then((e11) => t10.setData(e11));
        e10.push(i8);
      }
      await Promise.all(e10);
    }
    this._styleChanges = [], this._isTileHandlerReady = true, this.notifyChange("updating"), this.requestUpdate();
  }
  async _loadStyle() {
    const { style: e9 } = this.layer.currentStyleInfo, t9 = y(e9);
    this._isTileHandlerReady = false, this._fetchQueue.pause(), this._parseQueue.pause(), this._fetchQueue.clear(), this._parseQueue.clear(), this.notifyChange("updating"), this._styleRepository = new l3(t9), this._vectorTileContainer.destroy(), this._tileManager.clear(), this._tileHandlerAbortController.abort(), this._tileHandlerAbortController = new AbortController();
    const { signal: s5 } = this._tileHandlerAbortController;
    try {
      this._tileHandlerPromise = this._tileHandler.setStyle(this._styleRepository, t9), await this._tileHandlerPromise;
    } catch (l10) {
      if (!j(l10))
        throw l10;
    }
    if (s5.aborted)
      return this._fetchQueue.resume(), this._parseQueue.resume(), this._isTileHandlerReady = true, this.notifyChange("updating"), void this.requestUpdate();
    const r11 = await this._tileHandler.spriteMosaic;
    this._vectorTileContainer.setStyleResources(r11, this._tileHandler.glyphMosaic, this._styleRepository), this._fetchQueue.resume(), this._parseQueue.resume(), this._isTileHandlerReady = true, this.notifyChange("updating"), this.requestUpdate();
  }
  _createVectorTile(e9) {
    const t9 = this._tileInfoView.getTileBounds(u(), e9), i7 = this._tileInfoView.getTileResolution(e9.level);
    return new m2(e9, i7, t9[0], t9[3], 512, 512, this._styleRepository);
  }
};
function Q(e9) {
  if (t(e9))
    return 0;
  switch (e9.type) {
    case "partial":
      return Object.keys(e9.diff).length;
    case "complete":
      return Math.max(Object.keys(e9.oldValue).length, Object.keys(e9.newValue).length);
    case "collection":
      return Object.keys(e9.added).length + Object.keys(e9.changed).length + Object.keys(e9.removed).length;
  }
}
e2([y2()], D3.prototype, "_fetchQueue", void 0), e2([y2()], D3.prototype, "_parseQueue", void 0), e2([y2()], D3.prototype, "_isTileHandlerReady", void 0), e2([y2()], D3.prototype, "fading", void 0), D3 = e2([n("esri.views.2d.layers.VectorTileLayerView2D")], D3);
var L2 = D3;
export {
  L2 as default
};
//# sourceMappingURL=VectorTileLayerView2D-PEQ445QG.js.map
