import {
  t as t2,
  u as u3
} from "./chunk-5ZAWCTS6.js";
import {
  c as c3,
  e as e5,
  r as r4,
  s as s3
} from "./chunk-X6GHUY4U.js";
import {
  C,
  D,
  E as E2,
  L as L3
} from "./chunk-3OFVLRSL.js";
import {
  e as e4
} from "./chunk-C6HDWDWX.js";
import {
  A,
  B,
  E,
  F,
  L as L2,
  O,
  V,
  c as c2,
  d,
  g,
  i as i3,
  q,
  u as u2,
  w as w2,
  x as x2
} from "./chunk-67RD6CZ4.js";
import {
  x
} from "./chunk-NGFMX3UT.js";
import {
  e as e2
} from "./chunk-XFDO4CMR.js";
import {
  e as e3,
  r as r3
} from "./chunk-IVLBGTXL.js";
import {
  r as r5
} from "./chunk-4BIBXEQB.js";
import {
  n
} from "./chunk-O6VYMEIX.js";
import {
  b
} from "./chunk-HUQX7WZO.js";
import {
  c,
  f as f2,
  i as i2,
  p,
  u
} from "./chunk-RT3T2K4S.js";
import {
  U
} from "./chunk-DMI7A7TC.js";
import {
  Q,
  X,
  Y,
  nt
} from "./chunk-KAN4HXCG.js";
import {
  L,
  f,
  w
} from "./chunk-MJXQTGI2.js";
import {
  s as s2
} from "./chunk-LIZHLHNA.js";
import {
  r as r2
} from "./chunk-BTUHYGXO.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";
import {
  e,
  i2 as i
} from "./chunk-6QC7MLLS.js";
import {
  r,
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/chunks/vec42.js
function t3(t10, r11, f9) {
  if (t10.count !== r11.count)
    return void e4.error("source and destination buffers need to have the same number of elements");
  const o6 = t10.count, n6 = f9[0], u6 = f9[1], d4 = f9[2], s5 = f9[3], c7 = f9[4], i6 = f9[5], a2 = f9[6], p3 = f9[7], y = f9[8], B2 = f9[9], m2 = f9[10], l3 = f9[11], S = f9[12], h = f9[13], b2 = f9[14], M2 = f9[15], v = t10.typedBuffer, g2 = t10.typedBufferStride, _ = r11.typedBuffer, j = r11.typedBufferStride;
  for (let e10 = 0; e10 < o6; e10++) {
    const t11 = e10 * g2, r12 = e10 * j, f10 = _[r12], o7 = _[r12 + 1], z = _[r12 + 2], O2 = _[r12 + 3];
    v[t11] = n6 * f10 + c7 * o7 + y * z + S * O2, v[t11 + 1] = u6 * f10 + i6 * o7 + B2 * z + h * O2, v[t11 + 2] = d4 * f10 + a2 * o7 + m2 * z + b2 * O2, v[t11 + 3] = s5 * f10 + p3 * o7 + l3 * z + M2 * O2;
  }
}
function r6(t10, r11, f9) {
  if (t10.count !== r11.count)
    return void e4.error("source and destination buffers need to have the same number of elements");
  const o6 = t10.count, n6 = f9[0], u6 = f9[1], d4 = f9[2], s5 = f9[3], c7 = f9[4], i6 = f9[5], a2 = f9[6], p3 = f9[7], y = f9[8], B2 = t10.typedBuffer, m2 = t10.typedBufferStride, l3 = r11.typedBuffer, S = r11.typedBufferStride;
  for (let e10 = 0; e10 < o6; e10++) {
    const t11 = e10 * m2, r12 = e10 * S, f10 = l3[r12], o7 = l3[r12 + 1], h = l3[r12 + 2], b2 = l3[r12 + 3];
    B2[t11] = n6 * f10 + s5 * o7 + a2 * h, B2[t11 + 1] = u6 * f10 + c7 * o7 + p3 * h, B2[t11 + 2] = d4 * f10 + i6 * o7 + y * h, B2[t11 + 3] = b2;
  }
}
function f3(e10, t10) {
  const r11 = Math.min(e10.count, t10.count), f9 = e10.typedBuffer, o6 = e10.typedBufferStride, n6 = t10.typedBuffer, u6 = t10.typedBufferStride;
  for (let d4 = 0; d4 < r11; d4++) {
    const e11 = d4 * o6, t11 = d4 * u6, r12 = n6[t11], s5 = n6[t11 + 1], c7 = n6[t11 + 2], i6 = r12 * r12 + s5 * s5 + c7 * c7;
    if (i6 > 0) {
      const t12 = 1 / Math.sqrt(i6);
      f9[e11] = t12 * r12, f9[e11 + 1] = t12 * s5, f9[e11 + 2] = t12 * c7;
    }
  }
}
function o(e10, t10, r11) {
  const f9 = Math.min(e10.count, t10.count), o6 = e10.typedBuffer, n6 = e10.typedBufferStride, u6 = t10.typedBuffer, d4 = t10.typedBufferStride;
  for (let s5 = 0; s5 < f9; s5++) {
    const e11 = s5 * n6, t11 = s5 * d4;
    o6[e11] = r11 * u6[t11], o6[e11 + 1] = r11 * u6[t11 + 1], o6[e11 + 2] = r11 * u6[t11 + 2], o6[e11 + 3] = r11 * u6[t11 + 3];
  }
}
function n2(e10, t10, r11) {
  const f9 = Math.min(e10.count, t10.count), o6 = e10.typedBuffer, n6 = e10.typedBufferStride, u6 = t10.typedBuffer, d4 = t10.typedBufferStride;
  for (let s5 = 0; s5 < f9; s5++) {
    const e11 = s5 * n6, t11 = s5 * d4;
    o6[e11] = u6[t11] >> r11, o6[e11 + 1] = u6[t11 + 1] >> r11, o6[e11 + 2] = u6[t11 + 2] >> r11, o6[e11 + 3] = u6[t11 + 3] >> r11;
  }
}
var u4 = Object.freeze(Object.defineProperty({ __proto__: null, transformMat4: t3, transformMat3: r6, normalize: f3, scale: o, shiftRight: n2 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/vec22.js
function f4(e10, t10, r11) {
  const f9 = e10.typedBuffer, n6 = e10.typedBufferStride, d4 = t10.typedBuffer, o6 = t10.typedBufferStride, u6 = r11 ? r11.count : t10.count;
  let s5 = (r11 && r11.dstIndex ? r11.dstIndex : 0) * n6, c7 = (r11 && r11.srcIndex ? r11.srcIndex : 0) * o6;
  for (let p3 = 0; p3 < u6; ++p3)
    f9[s5] = d4[c7], f9[s5 + 1] = d4[c7 + 1], s5 += n6, c7 += o6;
}
function n3(n6, d4, o6) {
  const u6 = n6.typedBuffer, s5 = n6.typedBufferStride, c7 = d4.typedBuffer, p3 = d4.typedBufferStride, l3 = o6 ? o6.count : d4.count;
  let y = (o6 && o6.dstIndex ? o6.dstIndex : 0) * s5, i6 = (o6 && o6.srcIndex ? o6.srcIndex : 0) * p3;
  if (s3(d4.elementType)) {
    const e10 = r4(d4.elementType);
    if (c3(d4.elementType))
      for (let t10 = 0; t10 < l3; ++t10)
        u6[y] = Math.max(c7[i6] / e10, -1), u6[y + 1] = Math.max(c7[i6 + 1] / e10, -1), y += s5, i6 += p3;
    else
      for (let t10 = 0; t10 < l3; ++t10)
        u6[y] = c7[i6] / e10, u6[y + 1] = c7[i6 + 1] / e10, y += s5, i6 += p3;
  } else
    f4(n6, d4, o6);
  return n6;
}
function d2(e10, t10, r11, f9) {
  var _a, _b;
  const n6 = e10.typedBuffer, d4 = e10.typedBufferStride, o6 = (_a = f9 == null ? void 0 : f9.count) != null ? _a : e10.count;
  let u6 = ((_b = f9 == null ? void 0 : f9.dstIndex) != null ? _b : 0) * d4;
  for (let s5 = 0; s5 < o6; ++s5)
    n6[u6] = t10, n6[u6 + 1] = r11, u6 += d4;
}
var o2 = Object.freeze(Object.defineProperty({ __proto__: null, copy: f4, normalizeIntegerBuffer: n3, fill: d2 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/vec43.js
function e6(e10, t10, f9) {
  const d4 = e10.typedBuffer, n6 = e10.typedBufferStride, o6 = t10.typedBuffer, r11 = t10.typedBufferStride, c7 = f9 ? f9.count : t10.count;
  let u6 = (f9 && f9.dstIndex ? f9.dstIndex : 0) * n6, l3 = (f9 && f9.srcIndex ? f9.srcIndex : 0) * r11;
  for (let s5 = 0; s5 < c7; ++s5)
    d4[u6] = o6[l3], d4[u6 + 1] = o6[l3 + 1], d4[u6 + 2] = o6[l3 + 2], d4[u6 + 3] = o6[l3 + 3], u6 += n6, l3 += r11;
}
function t4(e10, t10, f9, d4, n6, o6) {
  var _a, _b;
  const r11 = e10.typedBuffer, c7 = e10.typedBufferStride, u6 = (_a = o6 == null ? void 0 : o6.count) != null ? _a : e10.count;
  let l3 = ((_b = o6 == null ? void 0 : o6.dstIndex) != null ? _b : 0) * c7;
  for (let s5 = 0; s5 < u6; ++s5)
    r11[l3] = t10, r11[l3 + 1] = f9, r11[l3 + 2] = d4, r11[l3 + 3] = n6, l3 += c7;
}
var f5 = Object.freeze(Object.defineProperty({ __proto__: null, copy: e6, fill: t4 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/mat32.js
function e7(e10, t10, r11) {
  const o6 = e10.typedBuffer, d4 = e10.typedBufferStride, f9 = t10.typedBuffer, n6 = t10.typedBufferStride, c7 = r11 ? r11.count : t10.count;
  let u6 = (r11 && r11.dstIndex ? r11.dstIndex : 0) * d4, l3 = (r11 && r11.srcIndex ? r11.srcIndex : 0) * n6;
  for (let p3 = 0; p3 < c7; ++p3) {
    for (let e11 = 0; e11 < 9; ++e11)
      o6[u6 + e11] = f9[l3 + e11];
    u6 += d4, l3 += n6;
  }
}
var t5 = Object.freeze(Object.defineProperty({ __proto__: null, copy: e7 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/mat42.js
function e8(e10, t10, r11) {
  const o6 = e10.typedBuffer, d4 = e10.typedBufferStride, f9 = t10.typedBuffer, n6 = t10.typedBufferStride, c7 = r11 ? r11.count : t10.count;
  let u6 = (r11 && r11.dstIndex ? r11.dstIndex : 0) * d4, l3 = (r11 && r11.srcIndex ? r11.srcIndex : 0) * n6;
  for (let p3 = 0; p3 < c7; ++p3) {
    for (let e11 = 0; e11 < 16; ++e11)
      o6[u6 + e11] = f9[l3 + e11];
    u6 += d4, l3 += n6;
  }
}
var t6 = Object.freeze(Object.defineProperty({ __proto__: null, copy: e8 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/scalar.js
function e9(e10, t10, r11) {
  const n6 = e10.typedBuffer, o6 = e10.typedBufferStride, c7 = t10.typedBuffer, d4 = t10.typedBufferStride, f9 = r11 ? r11.count : t10.count;
  let u6 = (r11 && r11.dstIndex ? r11.dstIndex : 0) * o6, s5 = (r11 && r11.srcIndex ? r11.srcIndex : 0) * d4;
  for (let p3 = 0; p3 < f9; ++p3)
    n6[u6] = c7[s5], u6 += o6, s5 += d4;
}
function t7(e10, t10) {
  const r11 = e10.count;
  t10 || (t10 = new e10.TypedArrayConstructor(r11));
  for (let n6 = 0; n6 < r11; n6++)
    t10[n6] = e10.get(n6);
  return t10;
}
var r7 = Object.freeze(Object.defineProperty({ __proto__: null, copy: e9, makeDense: t7 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/geometry/support/buffer/utils.js
function r8(s5, r11) {
  return new s5(new ArrayBuffer(r11 * s5.ElementCount * e5(s5.ElementType)));
}

// node_modules/@arcgis/core/views/3d/glTF/DefaultLoadingContext.js
var n4 = class {
  constructor(r11) {
    this._streamDataRequester = r11;
  }
  async loadJSON(r11, e10) {
    return this._load("json", r11, e10);
  }
  async loadBinary(r11, e10) {
    return X(r11) ? (f(e10), Y(r11)) : this._load("binary", r11, e10);
  }
  async loadImage(r11, e10) {
    return this._load("image", r11, e10);
  }
  async _load(t10, i6, m2) {
    if (t(this._streamDataRequester))
      return (await U(i6, { responseType: c4[t10] })).data;
    const n6 = await b(this._streamDataRequester.request(i6, t10, m2));
    if (true === n6.ok)
      return n6.value;
    throw w(n6.error), new s2("", `Request for resource failed: ${n6.error}`);
  }
};
var c4 = { image: "image", binary: "array-buffer", json: "json" };

// node_modules/@arcgis/core/views/3d/glTF/DefaultErrorContext.js
var o3 = class {
  error(e10) {
    throw new s2("gltf-loader-error", e10);
  }
  errorUnsupported(e10) {
    throw new s2("gltf-loader-unsupported-feature", e10);
  }
  errorUnsupportedIf(r11, e10) {
    r11 && this.errorUnsupported(e10);
  }
  assert(r11, e10) {
    r11 || this.error(e10);
  }
  warn(r11) {
    s.getLogger("esri.views.3d.glTF").warn(r11);
  }
  warnUnsupported(r11) {
    this.warn("[Unsupported Feature] " + r11);
  }
  warnUnsupportedIf(r11, e10) {
    r11 && this.warnUnsupported(e10);
  }
};

// node_modules/@arcgis/core/views/3d/glTF/LoaderResult.js
function r9(e10 = {}) {
  return { color: [1, 1, 1], opacity: 1, alphaMode: "OPAQUE", alphaCutoff: 0.5, doubleSided: false, castShadows: true, receiveShadows: true, receiveAmbientOcclustion: true, textureColor: null, textureNormal: null, textureOcclusion: null, textureEmissive: null, textureMetallicRoughness: null, colorTextureTransform: null, normalTextureTransform: null, occlusionTextureTransform: null, emissiveTextureTransform: null, metallicRoughnessTextureTransform: null, emissiveFactor: [0, 0, 0], metallicFactor: 1, roughnessFactor: 1, colorMixMode: "multiply", ...e10 };
}
function l(r11, l3 = {}) {
  return { data: r11, parameters: { wrap: { s: D.REPEAT, t: D.REPEAT, ...l3.wrap }, noUnpackFlip: true, mipmap: false, ...l3 } };
}

// node_modules/@arcgis/core/views/3d/glTF/internal/BinaryStreamReader.js
var t8 = class {
  constructor(t10) {
    this._data = t10, this._offset4 = 0, this._dataUint32 = new Uint32Array(this._data, 0, Math.floor(this._data.byteLength / 4));
  }
  readUint32() {
    const t10 = this._offset4;
    return this._offset4 += 1, this._dataUint32[t10];
  }
  readUint8Array(t10) {
    const s5 = 4 * this._offset4;
    return this._offset4 += t10 / 4, new Uint8Array(this._data, s5, t10);
  }
  remainingBytes() {
    return this._data.byteLength - 4 * this._offset4;
  }
};

// node_modules/@arcgis/core/views/3d/glTF/internal/enums.js
var A2;
var E3;
!function(A3) {
  A3.SCALAR = "SCALAR", A3.VEC2 = "VEC2", A3.VEC3 = "VEC3", A3.VEC4 = "VEC4", A3.MAT2 = "MAT2", A3.MAT3 = "MAT3", A3.MAT4 = "MAT4";
}(A2 || (A2 = {})), function(A3) {
  A3[A3.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", A3[A3.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER";
}(E3 || (E3 = {}));

// node_modules/@arcgis/core/views/3d/glTF/internal/fillDefaults.js
var t9 = { baseColorFactor: [1, 1, 1, 1], metallicFactor: 1, roughnessFactor: 1 };
var a = { pbrMetallicRoughness: t9, emissiveFactor: [0, 0, 0], alphaMode: "OPAQUE", alphaCutoff: 0.5, doubleSided: false };
var l2 = { ESRI_externalColorMixMode: "tint" };
var i4 = (e10 = {}) => {
  const o6 = { ...t9, ...e10.pbrMetallicRoughness }, r11 = s4({ ...l2, ...e10.extras });
  return { ...a, ...e10, pbrMetallicRoughness: o6, extras: r11 };
};
function s4(o6) {
  switch (o6.ESRI_externalColorMixMode) {
    case "multiply":
    case "tint":
    case "ignore":
    case "replace":
      break;
    default:
      n(o6.ESRI_externalColorMixMode), o6.ESRI_externalColorMixMode = "tint";
  }
  return o6;
}
var n5 = { magFilter: L3.LINEAR, minFilter: L3.LINEAR_MIPMAP_LINEAR, wrapS: D.REPEAT, wrapT: D.REPEAT };
var c5 = (e10) => ({ ...n5, ...e10 });

// node_modules/@arcgis/core/views/3d/glTF/internal/pathUtils.js
function r10(r11) {
  let e10, t10;
  return r11.replace(/^(.*\/)?([^/]*)$/, (r12, a2, i6) => (e10 = a2 || "", t10 = i6 || "", "")), { dirPart: e10, filePart: t10 };
}

// node_modules/@arcgis/core/views/3d/glTF/internal/Resource.js
var M = { MAGIC: 1179937895, CHUNK_TYPE_JSON: 1313821514, CHUNK_TYPE_BIN: 5130562, MIN_HEADER_LENGTH: 20 };
var F2 = class {
  constructor(e10, t10, r11, s5, n6) {
    this._context = e10, this._errorContext = t10, this.uri = r11, this.json = s5, this._glbBuffer = n6, this._bufferLoaders = /* @__PURE__ */ new Map(), this._textureLoaders = /* @__PURE__ */ new Map(), this._textureCache = /* @__PURE__ */ new Map(), this._materialCache = /* @__PURE__ */ new Map(), this._nodeParentMap = /* @__PURE__ */ new Map(), this._nodeTransformCache = /* @__PURE__ */ new Map(), this._baseUri = r10(this.uri).dirPart, this._checkVersionSupported(), this._checkRequiredExtensionsSupported(), t10.errorUnsupportedIf(null == s5.scenes, "Scenes must be defined."), t10.errorUnsupportedIf(null == s5.meshes, "Meshes must be defined"), t10.errorUnsupportedIf(null == s5.nodes, "Nodes must be defined."), this._computeNodeParents();
  }
  static async load(e10, t10, o6, a2) {
    if (X(o6)) {
      const r11 = nt(o6);
      if (r11 && "model/gltf-binary" !== r11.mediaType)
        try {
          const s5 = JSON.parse(r11.isBase64 ? atob(r11.data) : r11.data);
          return new F2(e10, t10, o6, s5);
        } catch {
        }
      const a3 = Y(o6);
      if (F2._isGLBData(a3))
        return this._fromGLBData(e10, t10, o6, a3);
    }
    if (o6.endsWith(".gltf")) {
      const r11 = await e10.loadJSON(o6, a2);
      return new F2(e10, t10, o6, r11);
    }
    const i6 = await e10.loadBinary(o6, a2);
    if (F2._isGLBData(i6))
      return this._fromGLBData(e10, t10, o6, i6);
    const u6 = await e10.loadJSON(o6, a2);
    return new F2(e10, t10, o6, u6);
  }
  static _isGLBData(e10) {
    if (null == e10)
      return false;
    const t10 = new t8(e10);
    return t10.remainingBytes() >= 4 && t10.readUint32() === M.MAGIC;
  }
  static async _fromGLBData(e10, t10, r11, s5) {
    const n6 = await F2._parseGLBData(t10, s5);
    return new F2(e10, t10, r11, n6.json, n6.binaryData);
  }
  static async _parseGLBData(e10, t10) {
    const r11 = new t8(t10);
    e10.assert(r11.remainingBytes() >= 12, "GLB binary data is insufficiently large.");
    const s5 = r11.readUint32(), n6 = r11.readUint32(), o6 = r11.readUint32();
    e10.assert(s5 === M.MAGIC, "Magic first 4 bytes do not fit to expected GLB value."), e10.assert(t10.byteLength >= o6, "GLB binary data is smaller than header specifies."), e10.errorUnsupportedIf(2 !== n6, "An unsupported GLB container version was detected. Only version 2 is supported.");
    let a2, i6, u6 = 0;
    for (; r11.remainingBytes() >= 8; ) {
      const t11 = r11.readUint32(), s6 = r11.readUint32();
      0 === u6 ? (e10.assert(s6 === M.CHUNK_TYPE_JSON, "First GLB chunk must be JSON."), e10.assert(t11 >= 0, "No JSON data found."), a2 = await K(r11.readUint8Array(t11))) : 1 === u6 ? (e10.errorUnsupportedIf(s6 !== M.CHUNK_TYPE_BIN, "Second GLB chunk expected to be BIN."), i6 = r11.readUint8Array(t11)) : e10.warnUnsupported("More than 2 GLB chunks detected. Skipping."), u6 += 1;
    }
    return a2 || e10.error("No GLB JSON chunk detected."), { json: a2, binaryData: i6 };
  }
  async getBuffer(e10, t10) {
    const r11 = this.json.buffers[e10], s5 = this._errorContext;
    if (null == r11.uri)
      return s5.assert(null != this._glbBuffer, "GLB buffer not present"), this._glbBuffer;
    const n6 = await this._getBufferLoader(e10, t10);
    return s5.assert(n6.byteLength === r11.byteLength, "Buffer byte lengths should match."), n6;
  }
  async _getBufferLoader(e10, t10) {
    const r11 = this._bufferLoaders.get(e10);
    if (r11)
      return r11;
    const s5 = this.json.buffers[e10].uri, n6 = this._context.loadBinary(this._resolveUri(s5), t10).then((e11) => new Uint8Array(e11));
    return this._bufferLoaders.set(e10, n6), n6;
  }
  async getAccessor(e10, t10) {
    const r11 = this._errorContext;
    r11.errorUnsupportedIf(!this.json.accessors, "Accessors missing.");
    const s5 = this.json.accessors[e10];
    r11.errorUnsupportedIf(null == (s5 == null ? void 0 : s5.bufferView), "Some accessor does not specify a bufferView."), r11.errorUnsupportedIf(s5.type in [A2.MAT2, A2.MAT3, A2.MAT4], `AttributeType ${s5.type} is not supported`);
    const n6 = this.json.bufferViews[s5.bufferView], o6 = await this.getBuffer(n6.buffer, t10), a2 = V2[s5.type], i6 = Y2[s5.componentType], u6 = a2 * i6, c7 = n6.byteStride || u6;
    return { raw: o6.buffer, byteStride: c7, byteOffset: o6.byteOffset + (n6.byteOffset || 0) + (s5.byteOffset || 0), entryCount: s5.count, isDenselyPacked: c7 === u6, componentCount: a2, componentByteSize: i6, componentType: s5.componentType, min: s5.min, max: s5.max, normalized: !!s5.normalized };
  }
  async getIndexData(e10, t10) {
    if (null == e10.indices)
      return;
    const r11 = await this.getAccessor(e10.indices, t10);
    if (r11.isDenselyPacked)
      switch (r11.componentType) {
        case C.UNSIGNED_BYTE:
          return new Uint8Array(r11.raw, r11.byteOffset, r11.entryCount);
        case C.UNSIGNED_SHORT:
          return new Uint16Array(r11.raw, r11.byteOffset, r11.entryCount);
        case C.UNSIGNED_INT:
          return new Uint32Array(r11.raw, r11.byteOffset, r11.entryCount);
      }
    else
      switch (r11.componentType) {
        case C.UNSIGNED_BYTE:
          return t7(this._wrapAccessor(d, r11));
        case C.UNSIGNED_SHORT:
          return t7(this._wrapAccessor(g, r11));
        case C.UNSIGNED_INT:
          return t7(this._wrapAccessor(B, r11));
      }
  }
  async getPositionData(e10, t10) {
    const r11 = this._errorContext;
    r11.errorUnsupportedIf(null == e10.attributes.POSITION, "No POSITION vertex data found.");
    const s5 = await this.getAccessor(e10.attributes.POSITION, t10);
    return r11.errorUnsupportedIf(s5.componentType !== C.FLOAT, "Expected type FLOAT for POSITION vertex attribute, but found " + C[s5.componentType]), r11.errorUnsupportedIf(3 !== s5.componentCount, "POSITION vertex attribute must have 3 components, but found " + s5.componentCount.toFixed()), this._wrapAccessor(i3, s5);
  }
  async getNormalData(e10, t10) {
    const r11 = this._errorContext;
    r11.assert(null != e10.attributes.NORMAL, "No NORMAL vertex data found.");
    const s5 = await this.getAccessor(e10.attributes.NORMAL, t10);
    return r11.errorUnsupportedIf(s5.componentType !== C.FLOAT, "Expected type FLOAT for NORMAL vertex attribute, but found " + C[s5.componentType]), r11.errorUnsupportedIf(3 !== s5.componentCount, "NORMAL vertex attribute must have 3 components, but found " + s5.componentCount.toFixed()), this._wrapAccessor(i3, s5);
  }
  async getTangentData(e10, t10) {
    const r11 = this._errorContext;
    r11.assert(null != e10.attributes.TANGENT, "No TANGENT vertex data found.");
    const s5 = await this.getAccessor(e10.attributes.TANGENT, t10);
    return r11.errorUnsupportedIf(s5.componentType !== C.FLOAT, "Expected type FLOAT for TANGENT vertex attribute, but found " + C[s5.componentType]), r11.errorUnsupportedIf(4 !== s5.componentCount, "TANGENT vertex attribute must have 4 components, but found " + s5.componentCount.toFixed()), new c2(s5.raw, s5.byteOffset, s5.byteStride, s5.byteOffset + s5.byteStride * s5.entryCount);
  }
  async getTextureCoordinates(e10, t10) {
    const r11 = this._errorContext;
    r11.assert(null != e10.attributes.TEXCOORD_0, "No TEXCOORD_0 vertex data found.");
    const s5 = await this.getAccessor(e10.attributes.TEXCOORD_0, t10);
    return r11.errorUnsupportedIf(2 !== s5.componentCount, "TEXCOORD_0 vertex attribute must have 2 components, but found " + s5.componentCount.toFixed()), s5.componentType === C.FLOAT ? this._wrapAccessor(u2, s5) : (r11.errorUnsupportedIf(!s5.normalized, "Integer component types are only supported for a normalized accessor for TEXCOORD_0."), J(s5));
  }
  async getVertexColors(e10, t10) {
    const r11 = this._errorContext;
    r11.assert(null != e10.attributes.COLOR_0, "No COLOR_0 vertex data found.");
    const s5 = await this.getAccessor(e10.attributes.COLOR_0, t10);
    if (r11.errorUnsupportedIf(4 !== s5.componentCount && 3 !== s5.componentCount, "COLOR_0 attribute must have 3 or 4 components, but found " + s5.componentCount.toFixed()), 4 === s5.componentCount) {
      if (s5.componentType === C.FLOAT)
        return this._wrapAccessor(c2, s5);
      if (s5.componentType === C.UNSIGNED_BYTE)
        return this._wrapAccessor(x2, s5);
      if (s5.componentType === C.UNSIGNED_SHORT)
        return this._wrapAccessor(L2, s5);
    } else if (3 === s5.componentCount) {
      if (s5.componentType === C.FLOAT)
        return this._wrapAccessor(i3, s5);
      if (s5.componentType === C.UNSIGNED_BYTE)
        return this._wrapAccessor(O, s5);
      if (s5.componentType === C.UNSIGNED_SHORT)
        return this._wrapAccessor(E, s5);
    }
    r11.errorUnsupported("Unsupported component type for COLOR_0 attribute: " + C[s5.componentType]);
  }
  hasPositions(e10) {
    return void 0 !== e10.attributes.POSITION;
  }
  hasNormals(e10) {
    return void 0 !== e10.attributes.NORMAL;
  }
  hasVertexColors(e10) {
    return void 0 !== e10.attributes.COLOR_0;
  }
  hasTextureCoordinates(e10) {
    return void 0 !== e10.attributes.TEXCOORD_0;
  }
  hasTangents(e10) {
    return void 0 !== e10.attributes.TANGENT;
  }
  async getMaterial(e10, t10, r11) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    let s5 = e10.material ? this._materialCache.get(e10.material) : void 0;
    if (!s5) {
      const n6 = null != e10.material ? i4(this.json.materials[e10.material]) : i4(), o6 = n6.pbrMetallicRoughness, a2 = this.hasVertexColors(e10), i6 = this.getTexture(o6.baseColorTexture, t10), u6 = this.getTexture(n6.normalTexture, t10), c7 = r11 ? this.getTexture(n6.occlusionTexture, t10) : void 0, f9 = r11 ? this.getTexture(n6.emissiveTexture, t10) : void 0, d4 = r11 ? this.getTexture(o6.metallicRoughnessTexture, t10) : void 0, p3 = null != e10.material ? e10.material : -1;
      s5 = { alphaMode: n6.alphaMode, alphaCutoff: n6.alphaCutoff, color: o6.baseColorFactor, doubleSided: !!n6.doubleSided, colorTexture: await i6, normalTexture: await u6, name: n6.name, id: p3, occlusionTexture: await c7, emissiveTexture: await f9, emissiveFactor: n6.emissiveFactor, metallicFactor: o6.metallicFactor, roughnessFactor: o6.roughnessFactor, metallicRoughnessTexture: await d4, hasVertexColors: a2, ESRI_externalColorMixMode: n6.extras.ESRI_externalColorMixMode, colorTextureTransform: (_b = (_a = o6 == null ? void 0 : o6.baseColorTexture) == null ? void 0 : _a.extensions) == null ? void 0 : _b.KHR_texture_transform, normalTextureTransform: (_d = (_c = n6.normalTexture) == null ? void 0 : _c.extensions) == null ? void 0 : _d.KHR_texture_transform, occlusionTextureTransform: (_f = (_e = n6.occlusionTexture) == null ? void 0 : _e.extensions) == null ? void 0 : _f.KHR_texture_transform, emissiveTextureTransform: (_h = (_g = n6.emissiveTexture) == null ? void 0 : _g.extensions) == null ? void 0 : _h.KHR_texture_transform, metallicRoughnessTextureTransform: (_j = (_i = o6 == null ? void 0 : o6.metallicRoughnessTexture) == null ? void 0 : _i.extensions) == null ? void 0 : _j.KHR_texture_transform };
    }
    return s5;
  }
  async getTexture(t10, r11) {
    if (!t10)
      return;
    this._errorContext.errorUnsupportedIf(0 !== (t10.texCoord || 0), "Only TEXCOORD with index 0 is supported.");
    const s5 = t10.index, n6 = this._errorContext, o6 = this.json.textures[s5], a2 = c5(null != o6.sampler ? this.json.samplers[o6.sampler] : {});
    n6.errorUnsupportedIf(null == o6.source, "Source is expected to be defined for a texture.");
    const i6 = this.json.images[o6.source], u6 = await this._loadTextureImageData(s5, o6, r11);
    return r2(this._textureCache, s5, () => {
      const e10 = (e11) => 33071 === e11 || 33648 === e11 || 10497 === e11, t11 = (e11) => (n6.error(`Unexpected TextureSampler WrapMode: ${e11}. Using default REPEAT(10497).`), 10497);
      return { data: u6, wrapS: e10(a2.wrapS) ? a2.wrapS : t11(a2.wrapS), wrapT: e10(a2.wrapT) ? a2.wrapT : t11(a2.wrapT), minFilter: a2.minFilter, name: i6.name, id: s5 };
    });
  }
  getNodeTransform(e10) {
    if (void 0 === e10)
      return k;
    let t10 = this._nodeTransformCache.get(e10);
    if (!t10) {
      const r11 = this.getNodeTransform(this._getNodeParent(e10)), s5 = this.json.nodes[e10];
      s5.matrix ? t10 = u(e3(), r11, s5.matrix) : s5.translation || s5.rotation || s5.scale ? (t10 = r3(r11), s5.translation && c(t10, t10, s5.translation), s5.rotation && (H[3] = x(H, s5.rotation), f2(t10, t10, H[3], H)), s5.scale && i2(t10, t10, s5.scale)) : t10 = r11, this._nodeTransformCache.set(e10, t10);
    }
    return t10;
  }
  _wrapAccessor(e10, t10) {
    return new e10(t10.raw, t10.byteOffset, t10.byteStride, t10.byteOffset + t10.byteStride * (t10.entryCount - 1) + t10.componentByteSize * t10.componentCount);
  }
  _resolveUri(e10) {
    return Q(e10, this._baseUri);
  }
  _getNodeParent(e10) {
    return this._nodeParentMap.get(e10);
  }
  _checkVersionSupported() {
    const e10 = r5.parse(this.json.asset.version, "glTF");
    P.validate(e10);
  }
  _checkRequiredExtensionsSupported() {
    const e10 = this.json, t10 = this._errorContext;
    e10.extensionsRequired && 0 !== e10.extensionsRequired.length && t10.errorUnsupported("gltf loader was not able to load unsupported feature. Required extensions: " + e10.extensionsRequired.join(", "));
  }
  _computeNodeParents() {
    this.json.nodes.forEach((e10, t10) => {
      e10.children && e10.children.forEach((e11) => {
        this._nodeParentMap.set(e11, t10);
      });
    });
  }
  async _loadTextureImageData(e10, t10, r11) {
    const s5 = this._textureLoaders.get(e10);
    if (s5)
      return s5;
    const n6 = this._createTextureLoader(t10, r11);
    return this._textureLoaders.set(e10, n6), n6;
  }
  async _createTextureLoader(e10, t10) {
    const r11 = this.json.images[e10.source];
    if (r11.uri)
      return this._context.loadImage(this._resolveUri(r11.uri), t10);
    const s5 = this._errorContext;
    s5.errorUnsupportedIf(null == r11.bufferView, "Image bufferView must be defined."), s5.errorUnsupportedIf(null == r11.mimeType, "Image mimeType must be defined.");
    const n6 = this.json.bufferViews[r11.bufferView], o6 = await this.getBuffer(n6.buffer, t10);
    return s5.errorUnsupportedIf(null != n6.byteStride, "byteStride not supported for image buffer"), q2(new Uint8Array(o6.buffer, o6.byteOffset + (n6.byteOffset || 0), n6.byteLength), r11.mimeType);
  }
  async getLoadedBuffersSize() {
    if (this._glbBuffer)
      return this._glbBuffer.byteLength;
    const e10 = await L(Array.from(this._bufferLoaders.values())), r11 = await L(Array.from(this._textureLoaders.values()));
    return e10.reduce((e11, t10) => {
      var _a;
      return e11 + ((_a = t10 == null ? void 0 : t10.byteLength) != null ? _a : 0);
    }, 0) + r11.reduce((e11, t10) => e11 + (t10 ? t10.width * t10.height * 4 : 0), 0);
  }
};
var P = new r5(2, 0, "glTF");
var k = p(e3(), Math.PI / 2);
var H = e2();
var V2 = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4 };
var Y2 = { [C.BYTE]: 1, [C.UNSIGNED_BYTE]: 1, [C.SHORT]: 2, [C.UNSIGNED_SHORT]: 2, [C.FLOAT]: 4, [C.UNSIGNED_INT]: 4 };
function J(e10) {
  switch (e10.componentType) {
    case C.BYTE:
      return new V(e10.raw, e10.byteOffset, e10.byteStride, e10.byteOffset + e10.byteStride * e10.entryCount);
    case C.UNSIGNED_BYTE:
      return new A(e10.raw, e10.byteOffset, e10.byteStride, e10.byteOffset + e10.byteStride * e10.entryCount);
    case C.SHORT:
      return new q(e10.raw, e10.byteOffset, e10.byteStride, e10.byteOffset + e10.byteStride * e10.entryCount);
    case C.UNSIGNED_SHORT:
      return new w2(e10.raw, e10.byteOffset, e10.byteStride, e10.byteOffset + e10.byteStride * e10.entryCount);
    case C.UNSIGNED_INT:
      return new F(e10.raw, e10.byteOffset, e10.byteStride, e10.byteOffset + e10.byteStride * e10.entryCount);
    case C.FLOAT:
      return new u2(e10.raw, e10.byteOffset, e10.byteStride, e10.byteOffset + e10.byteStride * e10.entryCount);
  }
}
async function K(e10) {
  return new Promise((t10, r11) => {
    const s5 = new Blob([e10]), n6 = new FileReader();
    n6.onload = () => {
      const e11 = n6.result;
      t10(JSON.parse(e11));
    }, n6.onerror = (e11) => {
      r11(e11);
    }, n6.readAsText(s5);
  });
}
async function q2(e10, t10) {
  return new Promise((r11, s5) => {
    const n6 = new Blob([e10], { type: t10 }), o6 = URL.createObjectURL(n6), a2 = new Image(), i6 = () => {
      URL.revokeObjectURL(o6), "decode" in a2 ? a2.decode().then(() => r11(a2), () => r11(a2)).then(c7) : (r11(a2), c7());
    }, u6 = (e11) => {
      URL.revokeObjectURL(o6), s5(e11), c7();
    }, c7 = () => {
      a2.removeEventListener("load", i6), a2.removeEventListener("error", u6);
    };
    a2.addEventListener("load", i6), a2.addEventListener("error", u6), a2.src = o6;
  });
}

// node_modules/@arcgis/core/views/3d/glTF/loader.js
var u5 = 0;
async function m(r11, s5, a2 = {}, i6 = true) {
  const m2 = await F2.load(r11, x3, s5, a2), p3 = "gltf_" + u5++, T2 = { lods: [], materials: /* @__PURE__ */ new Map(), textures: /* @__PURE__ */ new Map(), meta: c6(m2) }, h = !(!m2.json.asset.extras || "symbolResource" !== m2.json.asset.extras.ESRI_type), g2 = /* @__PURE__ */ new Map();
  await d3(m2, async (r12, s6, n6, u6) => {
    var _a;
    const c7 = (_a = g2.get(n6)) != null ? _a : 0;
    g2.set(n6, c7 + 1);
    const d4 = void 0 !== r12.mode ? r12.mode : E2.TRIANGLES, h2 = d4 === E2.TRIANGLES || d4 === E2.TRIANGLE_STRIP || d4 === E2.TRIANGLE_FAN ? d4 : null;
    if (t(h2))
      return void x3.warnUnsupported("Unsupported primitive mode (" + E2[d4] + "). Skipping primitive.");
    if (!m2.hasPositions(r12))
      return void x3.warn("Skipping primitive without POSITION vertex attribute.");
    const R2 = m2.getPositionData(r12, a2), w3 = m2.getMaterial(r12, a2, i6), v = m2.hasNormals(r12) ? m2.getNormalData(r12, a2) : null, S = m2.hasTangents(r12) ? m2.getTangentData(r12, a2) : null, _ = m2.hasTextureCoordinates(r12) ? m2.getTextureCoordinates(r12, a2) : null, E4 = m2.hasVertexColors(r12) ? m2.getVertexColors(r12, a2) : null, I = m2.getIndexData(r12, a2), M2 = { transform: r3(s6), attributes: { position: await R2, normal: v ? await v : null, texCoord0: _ ? await _ : null, color: E4 ? await E4 : null, tangent: S ? await S : null }, indices: await I, primitiveType: h2, material: f7(T2, await w3, p3) };
    let F3 = null;
    r(T2.meta) && r(T2.meta.ESRI_lod) && "screenSpaceRadius" === T2.meta.ESRI_lod.metric && (F3 = T2.meta.ESRI_lod.thresholds[n6]), T2.lods[n6] = T2.lods[n6] || { parts: [], name: u6, lodThreshold: F3 }, T2.lods[n6].parts[c7] = M2;
  });
  for (const e10 of T2.lods)
    e10.parts = e10.parts.filter((e11) => !!e11);
  const R = await m2.getLoadedBuffersSize();
  return { model: T2, meta: { isEsriSymbolResource: h, uri: m2.uri }, customMeta: {}, size: R };
}
function c6(o6) {
  const t10 = o6.json;
  let r11 = null;
  return t10.nodes.forEach((o7) => {
    const t11 = o7.extras;
    r(t11) && (t11.ESRI_proxyEllipsoid || t11.ESRI_lod) && (r11 = t11);
  }), r11;
}
async function d3(e10, o6) {
  const t10 = e10.json, r11 = t10.scenes[t10.scene || 0].nodes, s5 = r11.length > 1, a2 = [];
  for (const i6 of r11) {
    const e11 = t10.nodes[i6];
    if (a2.push(n6(i6, 0)), p2(e11) && !s5) {
      e11.extensions.MSFT_lod.ids.forEach((e12, o7) => n6(e12, o7 + 1));
    }
  }
  async function n6(r12, s6) {
    const i6 = t10.nodes[r12], l3 = e10.getNodeTransform(r12);
    if (x3.warnUnsupportedIf(null != i6.weights, "Morph targets are not supported."), null != i6.mesh) {
      const e11 = t10.meshes[i6.mesh];
      for (const t11 of e11.primitives)
        a2.push(o6(t11, l3, s6, e11.name));
    }
    for (const e11 of i6.children || [])
      a2.push(n6(e11, s6));
  }
  await Promise.all(a2);
}
function p2(e10) {
  return e10.extensions && e10.extensions.MSFT_lod && Array.isArray(e10.extensions.MSFT_lod.ids);
}
function f7(e10, o6, t10) {
  const r11 = (o7) => {
    const r12 = `${t10}_tex_${o7 && o7.id}${o7 && o7.name ? "_" + o7.name : ""}`;
    if (o7 && !e10.textures.has(r12)) {
      const t11 = l(o7.data, { wrap: { s: o7.wrapS, t: o7.wrapT }, mipmap: T.includes(o7.minFilter), noUnpackFlip: true });
      e10.textures.set(r12, t11);
    }
    return r12;
  }, n6 = `${t10}_mat_${o6.id}_${o6.name}`;
  if (!e10.materials.has(n6)) {
    const t11 = r9({ color: [o6.color[0], o6.color[1], o6.color[2]], opacity: o6.color[3], alphaMode: o6.alphaMode, alphaCutoff: o6.alphaCutoff, doubleSided: o6.doubleSided, colorMixMode: o6.ESRI_externalColorMixMode, textureColor: o6.colorTexture ? r11(o6.colorTexture) : void 0, textureNormal: o6.normalTexture ? r11(o6.normalTexture) : void 0, textureOcclusion: o6.occlusionTexture ? r11(o6.occlusionTexture) : void 0, textureEmissive: o6.emissiveTexture ? r11(o6.emissiveTexture) : void 0, textureMetallicRoughness: o6.metallicRoughnessTexture ? r11(o6.metallicRoughnessTexture) : void 0, emissiveFactor: [o6.emissiveFactor[0], o6.emissiveFactor[1], o6.emissiveFactor[2]], colorTextureTransform: o6.colorTextureTransform, normalTextureTransform: o6.normalTextureTransform, occlusionTextureTransform: o6.occlusionTextureTransform, emissiveTextureTransform: o6.emissiveTextureTransform, metallicRoughnessTextureTransform: o6.metallicRoughnessTextureTransform, metallicFactor: o6.metallicFactor, roughnessFactor: o6.roughnessFactor });
    e10.materials.set(n6, t11);
  }
  return n6;
}
var x3 = new o3();
var T = [L3.LINEAR_MIPMAP_LINEAR, L3.LINEAR_MIPMAP_NEAREST];

// node_modules/@arcgis/core/views/3d/glTF/internal/indexUtils.js
function o4(r11, o6 = u3) {
  return "number" == typeof r11 ? o6(r11) : i(r11) || e(r11) ? new Uint32Array(r11) : r11;
}
function f8(e10) {
  const t10 = "number" == typeof e10 ? e10 : e10.length;
  if (t10 < 3)
    return [];
  const n6 = t10 - 2, o6 = t2(n6);
  if ("number" == typeof e10) {
    let e11 = 0;
    for (let t11 = 0; t11 < n6; t11 += 1)
      t11 % 2 == 0 ? (o6[e11++] = t11, o6[e11++] = t11 + 1, o6[e11++] = t11 + 2) : (o6[e11++] = t11 + 1, o6[e11++] = t11, o6[e11++] = t11 + 2);
  } else {
    let t11 = 0;
    for (let r11 = 0; r11 < n6; r11 += 1)
      if (r11 % 2 == 0) {
        const n7 = e10[r11], f9 = e10[r11 + 1], i6 = e10[r11 + 2];
        o6[t11++] = n7, o6[t11++] = f9, o6[t11++] = i6;
      } else {
        const n7 = e10[r11 + 1], f9 = e10[r11], i6 = e10[r11 + 2];
        o6[t11++] = n7, o6[t11++] = f9, o6[t11++] = i6;
      }
  }
  return o6;
}
function i5(e10) {
  const t10 = "number" == typeof e10 ? e10 : e10.length;
  if (t10 < 3)
    return new Uint16Array(0);
  const n6 = t10 - 2, r11 = n6 <= 65536 ? new Uint16Array(3 * n6) : new Uint32Array(3 * n6);
  if ("number" == typeof e10) {
    let e11 = 0;
    for (let t11 = 0; t11 < n6; ++t11)
      r11[e11++] = 0, r11[e11++] = t11 + 1, r11[e11++] = t11 + 2;
    return r11;
  }
  {
    const t11 = e10[0];
    let o6 = e10[1], f9 = 0;
    for (let i6 = 0; i6 < n6; ++i6) {
      const n7 = e10[i6 + 2];
      r11[f9++] = t11, r11[f9++] = o6, r11[f9++] = n7, o6 = n7;
    }
    return r11;
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/DefaultMaterial_COLOR_GAMMA.js
var o5 = 2.1;

export {
  r6 as r,
  f3 as f,
  o,
  n2 as n,
  n3 as n2,
  d2 as d,
  e6 as e,
  t4 as t,
  r8 as r2,
  n4 as n3,
  m,
  o4 as o2,
  f8 as f2,
  i5 as i,
  o5 as o3
};
//# sourceMappingURL=chunk-2DWNY35K.js.map
