import {
  V,
  e2 as e7,
  g as g5,
  i as i5,
  p as p4,
  w as w4
} from "./chunk-6W5CPYUF.js";
import {
  Z,
  k
} from "./chunk-FS3REKZ4.js";
import {
  U,
  a as a3,
  a2 as a4,
  e as e6,
  j as j2,
  m as m5,
  m2 as m6
} from "./chunk-6NRJP66X.js";
import {
  r as r5
} from "./chunk-KDTWVGPE.js";
import {
  i as i4,
  v as v2
} from "./chunk-IJUE2JUP.js";
import {
  f,
  w as w3
} from "./chunk-URFNTHOE.js";
import {
  n as n5
} from "./chunk-FCIHN4UG.js";
import {
  O,
  Q
} from "./chunk-NGFMX3UT.js";
import {
  e as e4
} from "./chunk-XFDO4CMR.js";
import {
  c as c2,
  m as m4
} from "./chunk-OFXOSNPT.js";
import {
  p as p3
} from "./chunk-2NKIENHY.js";
import {
  d as d2,
  g as g4,
  s as s3
} from "./chunk-C6BDJNUQ.js";
import {
  o as o2
} from "./chunk-KXA4TECI.js";
import {
  e as e5,
  r as r4
} from "./chunk-VHXWATHW.js";
import {
  r as r3
} from "./chunk-RG3AHHRL.js";
import {
  I as I2,
  y as y5
} from "./chunk-LT5KLTS5.js";
import {
  l as l2
} from "./chunk-MFXTPFHI.js";
import {
  rn
} from "./chunk-FFVIDMFN.js";
import {
  h as h3
} from "./chunk-36I5ESAQ.js";
import {
  $,
  L
} from "./chunk-WJCI2CGX.js";
import {
  a as a2,
  d
} from "./chunk-REIQNAQW.js";
import {
  g as g3
} from "./chunk-J6LQZWZI.js";
import {
  c,
  i as i3
} from "./chunk-NRP45AHD.js";
import {
  j
} from "./chunk-UDND2Z3V.js";
import {
  a
} from "./chunk-C5H57NTD.js";
import {
  A,
  E,
  P,
  _,
  e as e2,
  g,
  z
} from "./chunk-3LR5O4WA.js";
import {
  n,
  r as r2
} from "./chunk-D4V6J5BT.js";
import {
  h as h2,
  m2 as m3,
  p as p2,
  u,
  v2 as v,
  y as y4
} from "./chunk-3MNMDUQZ.js";
import {
  w
} from "./chunk-UWG37XSU.js";
import {
  I
} from "./chunk-LNZAOBFW.js";
import {
  l,
  w as w2
} from "./chunk-5NXILPDI.js";
import {
  n as n4
} from "./chunk-THVR7IAM.js";
import {
  e as e3,
  m as m2,
  n as n2,
  n2 as n3,
  y as y3
} from "./chunk-OOLCFNXJ.js";
import {
  D,
  g as g2,
  x
} from "./chunk-MJXQTGI2.js";
import {
  s2
} from "./chunk-UA3YPL2R.js";
import {
  y as y2
} from "./chunk-HVKDYDPP.js";
import {
  i as i2
} from "./chunk-6QC7MLLS.js";
import {
  e,
  h,
  i,
  m,
  o,
  p,
  r,
  s,
  t,
  y
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/views/interactive/ManipulatorCollection.js
var i6;
!function(t2) {
  t2[t2.WhenToolEditable = 0] = "WhenToolEditable", t2[t2.WhenToolNotEditable = 1] = "WhenToolNotEditable", t2[t2.Always = 2] = "Always";
}(i6 || (i6 = {}));
var e8 = class {
  constructor() {
    this._isToolEditable = true, this._manipulators = new j(), this._resourceContexts = { manipulator3D: {} }, this._attached = false;
  }
  set isToolEditable(t2) {
    this._isToolEditable = t2;
  }
  get length() {
    return this._manipulators.length;
  }
  add(t2, a7 = i6.WhenToolEditable) {
    this.addMany([t2], a7);
  }
  addMany(t2, a7 = i6.WhenToolEditable) {
    for (const i7 of t2) {
      const t3 = { manipulator: i7, visibilityPredicate: a7, attached: false };
      this._manipulators.add(t3), this._attached && this._updateManipulatorAttachment(t3);
    }
  }
  remove(t2) {
    for (let a7 = 0; a7 < this._manipulators.length; a7++)
      if (this._manipulators.getItemAt(a7).manipulator === t2) {
        const t3 = this._manipulators.splice(a7, 1)[0];
        this._detachManipulator(t3);
        break;
      }
  }
  removeAll() {
    this._manipulators.forEach((t2) => {
      this._detachManipulator(t2);
    }), this._manipulators.removeAll();
  }
  attach() {
    this._manipulators.forEach((t2) => {
      this._updateManipulatorAttachment(t2);
    }), this._attached = true;
  }
  detach() {
    this._manipulators.forEach((t2) => {
      this._detachManipulator(t2);
    }), this._attached = false;
  }
  destroy() {
    this.detach(), this._manipulators.forEach(({ manipulator: t2 }) => {
      t2.destroy && t2.destroy();
    }), this._manipulators.destroy(), this._resourceContexts = null;
  }
  on(t2, a7) {
    return this._manipulators.on(t2, (t3) => {
      a7(t3);
    });
  }
  forEach(t2) {
    for (const a7 of this._manipulators.items)
      t2(a7);
  }
  some(t2) {
    return this._manipulators.items.some(t2);
  }
  toArray() {
    const t2 = [];
    return this.forEach((a7) => t2.push(a7.manipulator)), t2;
  }
  intersect(t2, i7) {
    let e11 = null, o4 = Number.MAX_VALUE;
    return this._manipulators.forEach(({ manipulator: s5, attached: r7 }) => {
      if (!r7 || !s5.interactive)
        return;
      const n7 = s5.intersectionDistance(t2, i7);
      r(n7) && n7 < o4 && (o4 = n7, e11 = s5);
    }), e11;
  }
  _updateManipulatorAttachment(t2) {
    this._isManipulatorItemVisible(t2) ? this._attachManipulator(t2) : this._detachManipulator(t2);
  }
  _attachManipulator(t2) {
    t2.attached || (t2.manipulator.attach && t2.manipulator.attach(this._resourceContexts), t2.attached = true);
  }
  _detachManipulator(t2) {
    if (!t2.attached)
      return;
    const a7 = t2.manipulator;
    a7.grabbing = false, a7.dragging = false, a7.hovering = false, a7.selected = false, a7.detach && a7.detach(this._resourceContexts), t2.attached = false;
  }
  _isManipulatorItemVisible(t2) {
    return t2.visibilityPredicate === i6.Always || (this._isToolEditable ? t2.visibilityPredicate === i6.WhenToolEditable : t2.visibilityPredicate === i6.WhenToolNotEditable);
  }
};

// node_modules/@arcgis/core/views/interactive/InteractiveToolBase.js
var p5 = class extends m2 {
  constructor(t2) {
    super(t2), this.manipulators = new e8(), this.automaticManipulatorSelection = true, this.hasGrabbedManipulators = false, this.hasHoveredManipulators = false, this.firstGrabbedManipulator = null, this.created = false, this.removeIncompleteOnCancel = true, this._editableFlags = /* @__PURE__ */ new Map([[o2.MANAGER, true], [o2.USER, true]]), this._creationFinishedResolver = D();
  }
  get active() {
    return null != this.view && this.view.activeTool === this;
  }
  set visible(t2) {
    this._get("visible") !== t2 && (this._set("visible", t2), this._syncVisible());
  }
  get editable() {
    return this.getEditableFlag(o2.USER);
  }
  set editable(t2) {
    this.setEditableFlag(o2.USER, t2);
  }
  get updating() {
    return false;
  }
  get cursor() {
    return null;
  }
  get hasFocusedManipulators() {
    return this.hasGrabbedManipulators || this.hasHoveredManipulators;
  }
  destroy() {
    this.manipulators.destroy(), this._set("view", null);
  }
  onAdd() {
    this._syncVisible();
  }
  activate() {
    t(this.view) ? s2.getLogger(this.declaredClass).error("Can't activate tool if view is not defined.") : (this.view.focus(), this.onActivate());
  }
  deactivate() {
    this.onDeactivate();
  }
  handleInputEvent(t2) {
    this.onInputEvent(t2);
  }
  handleInputEventAfter(t2) {
    this.onInputEventAfter(t2);
  }
  setEditableFlag(t2, e11) {
    this._editableFlags.set(t2, e11), this.manipulators.isToolEditable = this.internallyEditable, this._updateManipulatorAttachment(), t2 === o2.USER && this.notifyChange("editable"), this.onEditableChange(), this.onManipulatorSelectionChanged();
  }
  getEditableFlag(t2) {
    return this._editableFlags.get(t2);
  }
  whenCreated() {
    return this._creationFinishedResolver.promise;
  }
  onManipulatorSelectionChanged() {
  }
  onActivate() {
  }
  onDeactivate() {
  }
  onShow() {
  }
  onHide() {
  }
  onEditableChange() {
  }
  onInputEvent(t2) {
  }
  onInputEventAfter(t2) {
  }
  get internallyEditable() {
    return this.getEditableFlag(o2.USER) && this.getEditableFlag(o2.MANAGER);
  }
  finishToolCreation() {
    this.created || this._creationFinishedResolver.resolve(this), this._set("created", true);
  }
  _syncVisible() {
    if (this.initialized) {
      if (this.visible)
        this._show();
      else if (this._hide(), this.active)
        return void (this.view.activeTool = null);
    }
  }
  _show() {
    this._updateManipulatorAttachment(), this.onShow();
  }
  _hide() {
    this._updateManipulatorAttachment(), this.onHide();
  }
  _updateManipulatorAttachment() {
    this.visible ? this.manipulators.attach() : this.manipulators.detach();
  }
};
e3([y3({ constructOnly: true })], p5.prototype, "view", void 0), e3([y3({ readOnly: true })], p5.prototype, "active", null), e3([y3({ value: true })], p5.prototype, "visible", null), e3([y3({ value: true })], p5.prototype, "editable", null), e3([y3({ readOnly: true })], p5.prototype, "manipulators", void 0), e3([y3({ readOnly: true })], p5.prototype, "updating", null), e3([y3()], p5.prototype, "cursor", null), e3([y3({ readOnly: true })], p5.prototype, "automaticManipulatorSelection", void 0), e3([y3()], p5.prototype, "hasFocusedManipulators", null), e3([y3()], p5.prototype, "hasGrabbedManipulators", void 0), e3([y3()], p5.prototype, "hasHoveredManipulators", void 0), e3([y3()], p5.prototype, "firstGrabbedManipulator", void 0), e3([y3({ readOnly: true })], p5.prototype, "created", void 0), e3([y3({ readOnly: true })], p5.prototype, "removeIncompleteOnCancel", void 0), p5 = e3([n3("esri.views.interactive.InteractiveToolBase")], p5);

// node_modules/@arcgis/core/views/draw/support/surfaceCoordinateSystems.js
function g6(r7, e11, s5 = null) {
  return r(s5) ? [r7, e11, s5] : [r7, e11];
}
function R(r7, e11, s5 = null) {
  return r(s5) ? { x: r7, y: e11, z: s5 } : { x: r7, y: e11 };
}
var W = class {
  constructor(t2) {
    this.spatialReference = t2;
  }
  mapToLocalMultiple(t2) {
    return m(t2.map((t3) => this.mapToLocal(t3)));
  }
  get doUnnormalization() {
    return false;
  }
};
var v3 = class extends W {
  constructor(t2, r7, o4 = null) {
    super(r7), this._defaultZ = o4, this.transform = e5(), this.transformInv = e5(), this.transform = r4(t2), r3(this.transformInv, this.transform);
  }
  makeMapPoint(t2, r7) {
    return g6(t2, r7, this._defaultZ);
  }
  mapToLocal(t2) {
    return R(this.transform[0] * t2[0] + this.transform[2] * t2[1] + this.transform[4], this.transform[1] * t2[0] + this.transform[3] * t2[1] + this.transform[5]);
  }
  localToMap(t2) {
    return g6(this.transformInv[0] * t2.x + this.transformInv[2] * t2.y + this.transformInv[4], this.transformInv[1] * t2.x + this.transformInv[3] * t2.y + this.transformInv[5], this._defaultZ);
  }
};
var F = class extends W {
  constructor(t2, r7) {
    super(t2.spatialReference), this.view = t2, this.defaultZ = null, this.pWS = n(), this.tangentFrameUpWS = n(), this.tangentFrameRightWS = n(), this.tangentFrameForwardWS = n(), this.localFrameRightWS = n(), this.localFrameUpWS = n(), this.worldToLocalTransform = e4(), this.localToWorldTransform = e4(), this.scale = 1, this.scale = t2.resolution, this.referenceMapPoint = r7, this.defaultZ = r7.hasZ ? r7.z : null;
    const e11 = t2.state.camera.viewRight;
    this.view.renderCoordsHelper.toRenderCoords(this.referenceMapPoint, this.pWS), this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS, n5.X, this.tangentFrameRightWS), this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS, n5.Y, this.tangentFrameUpWS), this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS, n5.Z, this.tangentFrameForwardWS);
    const s5 = n();
    g(s5, this.tangentFrameForwardWS, P(e11, this.tangentFrameForwardWS)), e2(this.localFrameRightWS, e11, s5), z(this.localFrameRightWS, this.localFrameRightWS), _(this.localFrameUpWS, this.tangentFrameForwardWS, this.localFrameRightWS), Q(this.worldToLocalTransform, this.localFrameRightWS, this.tangentFrameRightWS), O(this.localToWorldTransform, this.worldToLocalTransform);
  }
  get doUnnormalization() {
    return "global" === this.view.viewingMode;
  }
  makeMapPoint(t2, r7) {
    return g6(t2, r7, this.defaultZ);
  }
  mapToLocal(r7) {
    const e11 = n();
    this.view.renderCoordsHelper.toRenderCoords(new w({ x: r7[0], y: r7[1], spatialReference: this.spatialReference }), e11), E(e11, e11, this.worldToLocalTransform);
    const s5 = this.view.renderCoordsHelper.fromRenderCoords(e11, this.view.spatialReference);
    return r(s5) ? R(s5.x / this.scale, s5.y / this.scale) : null;
  }
  localToMap(r7) {
    const e11 = n();
    this.view.renderCoordsHelper.toRenderCoords(new w({ x: r7.x * this.scale, y: r7.y * this.scale, spatialReference: this.spatialReference }), e11), E(e11, e11, this.localToWorldTransform);
    const s5 = this.view.renderCoordsHelper.fromRenderCoords(e11, this.view.spatialReference);
    return r(s5) ? g6(s5.x, s5.y, this.defaultZ) : null;
  }
};
function S(t2, r7) {
  if ("2d" === t2.type)
    return new v3(t2.state.transform, t2.spatialReference, r7.length > 2 ? r7[2] : null);
  if ("3d" === t2.type) {
    const e11 = r7.length > 2 ? new w({ x: r7[0], y: r7[1], z: r7[2], spatialReference: t2.spatialReference }) : new w({ x: r7[0], y: r7[1], spatialReference: t2.spatialReference });
    return new F(t2, e11);
  }
  return null;
}

// node_modules/@arcgis/core/views/draw/support/createUtils.js
function R2(t2, e11) {
  const o4 = new w({ x: t2[0], y: t2[1], spatialReference: e11 });
  return t2.length > 2 && (o4.z = t2[2]), o4;
}
function j3(t2, e11) {
  return new u({ points: t2, spatialReference: e11 });
}
function T(t2, e11, o4) {
  const n7 = new m3({ paths: t2, spatialReference: e11 });
  return o4 && p2(n7), n7;
}
function b(o4, n7, r7, a7 = true) {
  const s5 = y2(o4);
  s5.forEach((e11) => {
    const o5 = e11[0], n8 = e11[e11.length - 1];
    i2(o5, n8) && 1 !== e11.length || e11.push(e11[0]);
  });
  let l4 = new v({ rings: s5, spatialReference: n7 });
  return l4.rings.forEach((t2) => {
    h2(t2, false, false) || t2.reverse();
  }), r7 && p2(l4), a7 && l4.isSelfIntersecting && I(n7) && (l4 = w3(l4)), l4;
}
function U2(t2, e11, n7) {
  const r7 = e11.mapToLocalMultiple(t2), a7 = [], s5 = { x: r7[0].x, y: r7[0].y }, l4 = { x: r7[1].x, y: r7[1].y }, i7 = Math.round(l4.x - s5.x), c4 = Math.round(l4.y - s5.y), y8 = Math.max(Math.abs(i7), Math.abs(c4));
  if (n7) {
    const t3 = { x: s5.x + y8, y: s5.y + y8 }, e12 = { x: s5.x - y8, y: s5.y - y8 };
    a7.push(R(t3.x, e12.y), R(e12.x, e12.y), R(e12.x, t3.y), R(t3.x, t3.y));
  } else {
    const t3 = { x: i7 > 0 ? s5.x + y8 : s5.x - y8, y: c4 > 0 ? s5.y + y8 : s5.y - y8 };
    a7.push(R(s5.x, s5.y), R(t3.x, s5.y), R(t3.x, t3.y), R(s5.x, t3.y));
  }
  return z2(b([m(a7.map((t3) => e11.localToMap(t3)))], e11.spatialReference, e11.doUnnormalization, true), a7, e11);
}
function P2(t2, e11, n7) {
  let r7 = e11.mapToLocalMultiple(t2);
  if (1 === r7.length) {
    const t3 = 48, e12 = r7[0];
    r7 = [R(e12.x - t3, e12.y + t3), R(e12.x + t3, e12.y - t3), R(e12.x + t3, e12.y - t3), R(e12.x - t3, e12.y + t3)];
  }
  const a7 = [], s5 = { x: r7[0].x, y: r7[0].y }, l4 = { x: r7[1].x, y: r7[1].y };
  if (n7) {
    const t3 = Math.round(l4.x - s5.x), e12 = Math.round(l4.y - s5.y);
    a7.push(R(s5.x - t3, s5.y - e12), R(l4.x, s5.y - e12), R(l4.x, l4.y), R(s5.x - t3, l4.y));
  } else
    a7.push(R(s5.x, s5.y), R(l4.x, s5.y), R(l4.x, l4.y), R(s5.x, l4.y));
  return z2(b([m(a7.map((t3) => e11.localToMap(t3)))], e11.spatialReference, e11.doUnnormalization, true), a7, e11);
}
function z2(t2, e11, o4) {
  const r7 = w5(e11[3], e11[2], o4), a7 = w5(e11[1], e11[2], o4), s5 = w5(e11[0], e11[1], o4), l4 = w5(e11[0], e11[3], o4);
  return { geometry: t2, midpoints: r(r7) && r(a7) && r(s5) && r(l4) ? { top: r7, right: a7, bottom: s5, left: l4 } : null };
}
function w5(t2, e11, o4) {
  L2[0] = t2.x, L2[1] = t2.y, L2[2] = 0, v4[0] = e11.x, v4[1] = e11.y, v4[2] = 0, A(L2, L2, v4, 0.5), I3.x = L2[0], I3.y = v4[1], I3.z = v4[2];
  const r7 = o4.localToMap(I3);
  return r(r7) ? R2(r7, o4.spatialReference) : null;
}
var I3 = R(0, 0, 0);
var L2 = n();
var v4 = n();
function E2(t2, e11, o4, n7) {
  const s5 = e11.mapToLocalMultiple(t2);
  let l4 = null, c4 = null;
  if (o4)
    l4 = s5[0], c4 = s5[1];
  else {
    const t3 = s5[0], e12 = s5[1], o5 = Math.round(e12.x - t3.x), n8 = Math.round(e12.y - t3.y), r7 = Math.max(Math.abs(o5), Math.abs(n8));
    l4 = R(o5 > 0 ? t3.x + r7 / 2 : t3.x - r7 / 2, n8 > 0 ? t3.y + r7 / 2 : t3.y - r7 / 2), c4 = R(Math.abs(o5) > Math.abs(n8) ? l4.x - r7 / 2 : l4.x, Math.abs(o5) > Math.abs(n8) ? l4.y : l4.y - r7 / 2);
  }
  const p6 = e11.localToMap(l4), m7 = e11.localToMap(c4);
  if (t(p6) || t(m7))
    return null;
  e11.doUnnormalization && y4([[p6, m7]], e11.spatialReference);
  const h6 = R2(p6, e11.spatialReference), M2 = R2(m7, e11.spatialReference), g8 = $(e11.spatialReference);
  let d4 = 0;
  if (I(e11.spatialReference))
    d4 = g8 * f(h6, M2, null);
  else {
    const t3 = l4.x - c4.x, e12 = l4.y - c4.y;
    d4 = g8 * Math.sqrt(t3 * t3 + e12 * e12) * (n7 || 1);
  }
  const j5 = new m4({ center: h6, radius: d4, radiusUnit: "meters", spatialReference: e11.spatialReference });
  return { geometry: b(j5.rings, j5.spatialReference, false), center: h6, edge: M2 };
}
function k2(t2, e11, r7) {
  const a7 = e11.mapToLocalMultiple(t2), s5 = a7[0], l4 = a7[1], i7 = Math.round(l4.x - s5.x), c4 = Math.round(l4.y - s5.y), y8 = R(r7 ? s5.x : s5.x + i7 / 2, r7 ? s5.y : s5.y + c4 / 2), p6 = r7 ? i7 : i7 / 2, m7 = r7 ? c4 : c4 / 2, x2 = 60, u3 = [], h6 = 2 * Math.PI / x2;
  function M2(t3) {
    const e12 = Math.cos(t3), o4 = Math.sin(t3);
    return R(p6 * e12 + y8.x, m7 * o4 + y8.y);
  }
  for (let o4 = 0; o4 < x2; o4++)
    u3.push(M2(o4 * h6));
  u3.push(u3[0]);
  const { spatialReference: g8, doUnnormalization: d4 } = e11, j5 = b([m(u3.map((t3) => e11.localToMap(t3)))], g8, d4, false), T2 = e11.localToMap(M2(Math.PI / 2)), U4 = e11.localToMap(M2(0)), P4 = e11.localToMap(M2(-Math.PI / 2)), z4 = e11.localToMap(M2(Math.PI));
  return { geometry: j5, midpoints: r(T2) && r(U4) && r(P4) && r(z4) ? { top: R2(T2, g8), right: R2(U4, g8), bottom: R2(P4, g8), left: R2(z4, g8) } : null };
}

// node_modules/@arcgis/core/views/interactive/tooltip/DrawTooltipInfos.js
var s4 = class extends e6 {
  constructor(t2) {
    super(t2), this.type = "draw-point";
  }
};
e3([y3()], s4.prototype, "type", void 0), e3([y3()], s4.prototype, "elevation", void 0), s4 = e3([n3("esri.views.interactive.tooltip.DrawPointTooltipInfo")], s4);
var a5 = class extends e6 {
  constructor(t2) {
    super(t2), this.type = "draw-polyline";
  }
};
e3([y3()], a5.prototype, "type", void 0), e3([y3()], a5.prototype, "elevation", void 0), e3([y3()], a5.prototype, "totalLength", void 0), e3([y3()], a5.prototype, "viewType", void 0), a5 = e3([n3("esri.views.interactive.tooltip.DrawPolylineTooltipInfo")], a5);
var l3 = class extends e6 {
  constructor(t2) {
    super(t2), this.type = "draw-polygon";
  }
};
e3([y3()], l3.prototype, "type", void 0), e3([y3()], l3.prototype, "elevation", void 0), e3([y3()], l3.prototype, "area", void 0), e3([y3()], l3.prototype, "viewType", void 0), l3 = e3([n3("esri.views.interactive.tooltip.DrawPolygonTooltipInfo")], l3);
var y6 = class extends e6 {
  constructor(t2) {
    super(t2), this.type = "draw-rectangle", this.xSize = j2, this.ySize = j2, this.area = U;
  }
};
e3([y3()], y6.prototype, "type", void 0), e3([y3()], y6.prototype, "xSize", void 0), e3([y3()], y6.prototype, "ySize", void 0), e3([y3()], y6.prototype, "area", void 0), y6 = e3([n3("esri.views.interactive.tooltip.DrawRectangleTooltipInfo")], y6);
var n6 = class extends e6 {
  constructor(t2) {
    super(t2), this.type = "draw-circle", this.radius = null, this.xSize = null, this.ySize = null, this.area = U;
  }
};
e3([y3()], n6.prototype, "type", void 0), e3([y3()], n6.prototype, "radius", void 0), e3([y3()], n6.prototype, "xSize", void 0), e3([y3()], n6.prototype, "ySize", void 0), e3([y3()], n6.prototype, "area", void 0), n6 = e3([n3("esri.views.interactive.tooltip.DrawCircleTooltipInfo")], n6);

// node_modules/@arcgis/core/views/draw/DrawGraphicTool.js
var Z2 = class extends a2(n4.EventedMixin(p5)) {
  constructor(e11) {
    super(e11), this._graphic = null, this._createOperationGeometry = null, this.defaultZ = 0, this.geometryType = null, this.hasZ = true, this.labelOptions = new c2(), this.mode = null, this.snappingManager = null, this.snapToScene = false, this.tooltip = null, this.tooltipOptions = new p3();
  }
  initialize() {
    this.internalGraphicsLayer = new h3({ listMode: "hide", internal: true }), this.view.map.layers.add(this.internalGraphicsLayer), this.drawOperation = this.makeDrawOperation(), this.handles.add([this.drawOperation.on("vertex-add", (e11) => this.onVertexAdd(e11)), this.drawOperation.on("vertex-remove", (e11) => this.onVertexRemove(e11)), this.drawOperation.on("vertex-update", (e11) => this.onVertexUpdate(e11)), this.drawOperation.on("cursor-update", (e11) => this.onCursorUpdate(e11)), this.drawOperation.on("complete", (e11) => this.onComplete(e11)), l(() => this.tooltipOptions.enabled, (e11) => {
      this.tooltip = e11 ? new m5({ view: this.view, info: this._tooltipInfo }) : s(this.tooltip);
    }, w2), l(() => this._tooltipInfo, (e11) => {
      r(this.tooltip) && (this.tooltip.info = e11);
    }, w2)]), this.finishToolCreation();
  }
  destroy() {
    this.drawOperation = s(this.drawOperation), this.tooltip = s(this.tooltip), this._destroyAllVisualisations(), this.view.map.remove(this.internalGraphicsLayer), this.internalGraphicsLayer = s(this.internalGraphicsLayer), this._set("view", null);
  }
  get _defaultElevation() {
    return a3(this.defaultZ, "meters");
  }
  get canRedo() {
    return this.drawOperation.canRedo;
  }
  get canUndo() {
    return this.drawOperation.canUndo;
  }
  set centered(e11) {
    this._set("centered", e11), this._updateGraphic();
  }
  set enabled(e11) {
    this.drawOperation.interactive = e11, this._set("enabled", e11);
  }
  set forceUniformSize(e11) {
    this._set("forceUniformSize", e11), this._updateGraphic();
  }
  get graphic() {
    return this._graphic;
  }
  set graphicSymbol(e11) {
    this._set("graphicSymbol", e11), r(this._graphic) && (this._graphic.symbol = e11);
  }
  get updating() {
    var _a, _b;
    return (_b = (_a = this.drawOperation) == null ? void 0 : _a.updating) != null ? _b : false;
  }
  completeCreateOperation() {
    this.drawOperation.complete();
  }
  onInputEvent(e11) {
    this.drawOperation.onInputEvent(e11);
  }
  redo() {
    this.drawOperation.redo();
  }
  reset() {
  }
  undo() {
    this.drawOperation.undo();
  }
  _createGraphic(e11) {
    this._graphic = new g3({ ...this.graphicProperties, geometry: e11, symbol: this.graphicSymbol }), this.internalGraphicsLayer.add(this._graphic), this.handles.add(this.initializeGraphic(this._graphic)), this.notifyChange("graphic"), this.handles.add(n2(() => {
      r(this._graphic) && (this.internalGraphicsLayer.remove(this._graphic), this._graphic = s(this._graphic));
    }), H);
  }
  _destroyAllVisualisations() {
    this.handles.remove(N.outline), this.handles.remove(N.regularVertices), this.handles.remove(N.activeVertex), this.handles.remove(H);
  }
  _getCreateOperationGeometry(e11 = { operationComplete: false }) {
    if (null == this.drawOperation || 0 === this.drawOperation.numVertices)
      return null;
    const t2 = this.drawOperation.stagedVertex, i7 = this.drawOperation.committedVertices, o4 = i7.slice();
    r(t2) && o4.push(this.drawOperation.coordinateHelper.pointToArray(t2));
    const r7 = r(t2) ? this.drawOperation.coordinateHelper.pointToArray(t2) : i7.splice(-1)[0], n7 = { regularVertices: null, activeVertex: null, full: null, outline: null, circle: null, rectangle: null }, a7 = o4.length, s5 = this.view.spatialReference, p6 = "3d" === this.view.type && "global" === this.view.viewingMode;
    switch (this.geometryType) {
      case "point":
        n7.regularVertices = i7, n7.activeVertex = r7, n7.full = this.drawOperation.coordinateHelper.arrayToPoint(o4[0]);
        break;
      case "multipoint":
        n7.regularVertices = i7, n7.activeVertex = r7, a7 > 0 && (n7.full = j3(o4, s5));
        break;
      case "polyline":
        n7.regularVertices = i7, n7.activeVertex = r7, a7 > 0 && (n7.full = T([o4], s5, p6));
        break;
      case "polygon":
        n7.regularVertices = i7, n7.activeVertex = r7, a7 > 0 && (n7.full = b([o4], s5, p6, true));
        break;
      case "circle":
        if (a7 > 0) {
          const t3 = S(this.view, o4[0]);
          if (1 === a7 && e11.operationComplete) {
            const e12 = o4[0], i8 = t3.makeMapPoint(e12[0] + B * this.view.resolution, e12[1]);
            n7.circle = E2([e12, i8], t3, true), n7.full = r(n7.circle) ? n7.circle.geometry : null;
          } else
            2 === a7 && (this.forceUniformSize ? (n7.circle = E2(o4, t3, this.centered), n7.full = r(n7.circle) ? n7.circle.geometry : null) : (n7.rectangle = k2(o4, t3, this.centered), n7.full = n7.rectangle.geometry));
        }
        break;
      case "rectangle":
        if (a7 > 0) {
          const t3 = S(this.view, o4[0]);
          if (1 === a7 && e11.operationComplete) {
            const e12 = o4[0], i8 = t3.makeMapPoint(e12[0] + B * this.view.resolution, e12[1]);
            n7.rectangle = U2([e12, i8], t3, true), n7.full = n7.rectangle.geometry;
          } else
            2 === a7 && (n7.rectangle = this.forceUniformSize ? U2(o4, t3, this.centered) : P2(o4, t3, this.centered), n7.full = n7.rectangle.geometry);
        }
        break;
      default:
        return null;
    }
    switch (this.geometryType) {
      case "point":
      case "multipoint":
        break;
      case "polyline":
      case "polygon":
        a7 > 1 && (n7.outline = T([o4], s5, p6));
        break;
      case "circle":
      case "rectangle":
        r(n7.full) && "polygon" === n7.full.type && (n7.outline = b(n7.full.rings, s5, p6));
    }
    return n7;
  }
  initializeGraphic(e11) {
    return null;
  }
  onComplete(e11) {
    this._updateGraphic();
    let t2 = null;
    if (this.drawOperation.isCompleted) {
      const e12 = this._getCreateOperationGeometry({ operationComplete: true });
      r(e12) && (t(this._graphic) ? this._createGraphic(e12.full) : this._graphic.geometry = e12.full, t2 = e(this._graphic).clone());
    }
    this._createOperationGeometry = null, this.emit("complete", { graphic: t2, ...e11 });
  }
  onCursorUpdate(e11) {
    this._updateGraphic(), this.emit("cursor-update", e11);
  }
  onDeactivate() {
    this.drawOperation.isCompleted || this.drawOperation.cancel();
  }
  onVertexAdd(e11) {
    this._updateGraphic(), this.emit("vertex-add", e11);
  }
  onVertexRemove(e11) {
    this._updateGraphic(), this.emit("vertex-remove", e11);
  }
  onVertexUpdate(e11) {
    this._updateGraphic(), this.emit("vertex-update", e11);
  }
  _updateGraphic() {
    const e11 = this._getCreateOperationGeometry();
    this._createOperationGeometry = e11, t(e11) ? this._destroyAllVisualisations() : (r(e11.outline) ? this.handles.add(this.onOutlineChanged(e11.outline), N.outline) : this.handles.remove(N.outline), r(e11.regularVertices) ? this.handles.add(this.onRegularVerticesChanged(e11.regularVertices), N.regularVertices) : this.handles.remove(N.regularVertices), r(e11.activeVertex) ? this.handles.add(this.onActiveVertexChanged(e11.activeVertex), N.activeVertex) : this.handles.remove(N.activeVertex), r(e11.full) ? t(this._graphic) ? this._createGraphic(e11.full) : this._graphic.geometry = e11.full : this.handles.remove(H));
  }
  get _tooltipInfo() {
    const { drawOperation: e11 } = this;
    if (!e11)
      return null;
    switch (this.geometryType) {
      case "point":
        return this._drawPointTooltipInfo;
      case "polyline":
        return this._drawPolylineTooltipInfo;
      case "polygon":
        return this._drawPolygonTooltipInfo;
      case "rectangle":
        return this._drawRectangleTooltipInfo;
      case "circle":
        return this._drawCircleTooltipInfo;
      default:
        return null;
    }
  }
  get _drawPointTooltipInfo() {
    const e11 = o(this.graphic, (e12) => e12.geometry);
    return t(e11) || "point" !== e11.type || "2d" === this.view.type && 0 === this.defaultZ ? null : new s4({ tooltipOptions: this.tooltipOptions, elevation: this._elevationTooltipDetail });
  }
  get _drawPolylineTooltipInfo() {
    const e11 = this._createOperationGeometry, t2 = r(e11) ? e11.full : null;
    if (t(t2) || "polyline" !== t2.type)
      return null;
    const i7 = m6(t2, this._elevationMode);
    return new a5({ tooltipOptions: this.tooltipOptions, elevation: this._elevationTooltipDetail, totalLength: i(i7, j2), viewType: this.view.type });
  }
  get _drawPolygonTooltipInfo() {
    const e11 = this._createOperationGeometry, t2 = r(e11) ? e11.full : null;
    if (t(t2) || "polygon" !== t2.type)
      return null;
    const i7 = i5(t2, this._elevationMode);
    return new l3({ tooltipOptions: this.tooltipOptions, elevation: this._elevationTooltipDetail, area: i(i7, U), viewType: this.view.type });
  }
  get _drawRectangleTooltipInfo() {
    return t(this.drawOperation) ? null : new y6({ tooltipOptions: this.tooltipOptions, xSize: i(this._xSize, j2), ySize: i(this._ySize, j2), area: i(this._fullGeometryArea, U) });
  }
  get _drawCircleTooltipInfo() {
    if (t(this.drawOperation))
      return null;
    const e11 = this.forceUniformSize;
    return new n6({ tooltipOptions: this.tooltipOptions, radius: e11 ? i(this._circleRadius, j2) : null, xSize: e11 ? null : i(this._xSize, j2), ySize: e11 ? null : i(this._ySize, j2), area: i(this._fullGeometryArea, U) });
  }
  get _circleRadius() {
    const e11 = this._createOperationGeometry;
    return r(e11) && r(e11.circle) && r(e11.circle.center) && r(e11.circle.edge) ? a4(e11.circle.center, e11.circle.edge, this._elevationMode) : null;
  }
  get _xSize() {
    const e11 = this._createOperationGeometry;
    if (t(e11) || t(e11.rectangle))
      return null;
    const { midpoints: t2 } = e11.rectangle;
    return r(t2) ? a4(t2.left, t2.right, this._elevationMode) : null;
  }
  get _ySize() {
    const e11 = this._createOperationGeometry;
    if (t(e11) || t(e11.rectangle))
      return null;
    const { midpoints: t2 } = e11.rectangle;
    return r(t2) ? a4(t2.top, t2.bottom, this._elevationMode) : null;
  }
  get _fullGeometryArea() {
    const e11 = this._createOperationGeometry, t2 = r(e11) ? e11.full : null;
    return t(t2) || "polygon" !== t2.type ? null : i5(t2, this._elevationMode);
  }
  get _elevationTooltipDetail() {
    return { mode: this.drawOperation.elevationInfo.mode, ...this._vertexTooltipElevation };
  }
  get _vertexTooltipElevation() {
    var _a;
    const { tooltipOptions: e11, view: t2, drawOperation: i7 } = this;
    if (t(i7))
      return this._defaultElevation;
    const o4 = (_a = i7.stagedVertex) != null ? _a : i7.lastVertex;
    if (t(o4) || "2d" === t2.type)
      return this._defaultElevation;
    const r7 = { mode: e11.elevation.mode, offset: 0 }, n7 = g4(t2, o4, i7.elevationInfo, r7) * L(o4.spatialReference);
    return a3(n7, "meters");
  }
  get _elevationMode() {
    return this.drawOperation.isDraped ? "on-the-ground" : "absolute-height";
  }
};
e3([y3()], Z2.prototype, "_createOperationGeometry", void 0), e3([y3()], Z2.prototype, "_defaultElevation", null), e3([y3({ value: true })], Z2.prototype, "centered", null), e3([y3({ nonNullable: true })], Z2.prototype, "defaultZ", void 0), e3([y3()], Z2.prototype, "drawOperation", void 0), e3([y3({ value: true })], Z2.prototype, "enabled", null), e3([y3({ value: true })], Z2.prototype, "forceUniformSize", null), e3([y3({ constructOnly: true })], Z2.prototype, "geometryType", void 0), e3([y3()], Z2.prototype, "graphic", null), e3([y3({ constructOnly: true })], Z2.prototype, "graphicProperties", void 0), e3([y3()], Z2.prototype, "graphicSymbol", null), e3([y3({ constructOnly: true })], Z2.prototype, "hasZ", void 0), e3([y3({ constructOnly: true, type: c2 })], Z2.prototype, "labelOptions", void 0), e3([y3({ constructOnly: true })], Z2.prototype, "mode", void 0), e3([y3()], Z2.prototype, "snappingManager", void 0), e3([y3()], Z2.prototype, "snapToScene", void 0), e3([y3()], Z2.prototype, "tooltip", void 0), e3([y3({ constructOnly: true, type: p3 })], Z2.prototype, "tooltipOptions", void 0), e3([y3({ readOnly: true })], Z2.prototype, "type", void 0), e3([y3({ readOnly: true })], Z2.prototype, "updating", null), e3([y3({ constructOnly: true, nonNullable: true })], Z2.prototype, "view", void 0), e3([y3()], Z2.prototype, "_tooltipInfo", null), e3([y3()], Z2.prototype, "_drawPointTooltipInfo", null), e3([y3()], Z2.prototype, "_drawPolylineTooltipInfo", null), e3([y3()], Z2.prototype, "_drawPolygonTooltipInfo", null), e3([y3()], Z2.prototype, "_drawRectangleTooltipInfo", null), e3([y3()], Z2.prototype, "_drawCircleTooltipInfo", null), e3([y3()], Z2.prototype, "_circleRadius", null), e3([y3()], Z2.prototype, "_xSize", null), e3([y3()], Z2.prototype, "_ySize", null), e3([y3()], Z2.prototype, "_fullGeometryArea", null), e3([y3()], Z2.prototype, "_elevationTooltipDetail", null), e3([y3()], Z2.prototype, "_vertexTooltipElevation", null), e3([y3()], Z2.prototype, "_elevationMode", null), Z2 = e3([n3("esri.views.draw.DrawGraphicTool")], Z2);
var H = "create-operation-graphic";
var N = { outline: "outline-visual", regularVertices: "regular-vertices-visual", activeVertex: "active-vertex-visual" };
function q(e11) {
  switch (e11) {
    case "point":
    case "polyline":
    case "polygon":
    case "multipoint":
      return e11;
    case "circle":
    case "rectangle":
      return "segment";
    default:
      return null;
  }
}
var B = 48;

// node_modules/@arcgis/core/views/interactive/dragEventPipeline.js
function y7(t2, n7) {
  let e11 = null, a7 = null;
  return (s5) => {
    if ("cancel" === s5.action)
      return void (r(a7) && (a7.execute({ action: "cancel" }), e11 = null, a7 = null));
    const c4 = { action: s5.action, screenStart: s5.start, screenEnd: s5.screenPoint };
    "start" === s5.action && t(e11) && (e11 = new G(), a7 = new G(), n7(t2, e11, a7, s5.pointerType, c4)), r(e11) && e11.execute(c4), "end" === s5.action && r(e11) && (e11 = null, a7 = null);
  };
}
function d3(t2, n7) {
  return t2.events.on("drag", y7(t2, n7));
}
function g7(t2, n7) {
  const e11 = [t2.x, t2.y, t2.z], r7 = n7, o4 = [Math.cos(r7), Math.sin(r7)], a7 = Math.sqrt(o4[0] * o4[0] + o4[1] * o4[1]);
  if (0 === a7)
    return null;
  o4[0] /= a7, o4[1] /= a7;
  const s5 = (t3) => {
    const n8 = (t3.x - e11[0]) * o4[0] + (t3.y - e11[1]) * o4[1];
    t3.x = e11[0] + n8 * o4[0], t3.y = e11[1] + n8 * o4[1];
  };
  return (t3) => (s5(t3.mapStart), s5(t3.mapEnd), { ...t3, axis: o4 });
}
function h4(t2, n7) {
  let e11 = null;
  return (r7) => {
    if ("start" === r7.action && (e11 = S2(t2, r7.mapStart.spatialReference, n7)), t(e11))
      return null;
    const a7 = r7.mapEnd.x - r7.mapStart.x, s5 = r7.mapEnd.y - r7.mapStart.y, c4 = r7.mapEnd.z - r7.mapStart.z;
    return e11.move(a7, s5, c4), { ...r7, translationX: a7, translationY: s5, translationZ: c4 };
  };
}
function E3(t2, n7) {
  return t(t2) ? null : t2.spatialReference.equals(n7) ? t2.clone() : rn(t2, n7);
}
function S2(t2, n7, e11) {
  const r7 = t2.geometry, a7 = Z(n7);
  if (t(r7))
    return null;
  if ("mesh" === r7.type)
    return j4(t2, r7, a7, e11);
  const s5 = E3(r7, a7), c4 = r7.spatialReference;
  return t(s5) ? null : { move: (n8, e12, r8) => {
    const o4 = r5(s5.clone(), n8, e12, r8);
    o4.spatialReference.equals(c4) ? t2.geometry = o4 : t2.geometry = rn(o4, c4);
  } };
}
function j4(t2, n7, e11, o4) {
  if (r(n7.transform))
    return z3(t2, n7, n7.transform, e11);
  if (!n7.spatialReference.equals(e11))
    return null;
  let a7 = 0, s5 = 0, c4 = 0;
  return { move: (e12, r7, i7) => {
    const l4 = e12 - a7, u3 = r7 - s5, f2 = i7 - c4;
    if (l4 || u3 || f2) {
      const y8 = new w(n7.origin.x + l4, n7.origin.y + u3, n7.origin.z + f2, n7.origin.spatialReference);
      n7.centerAt(y8, { geographic: o4 === l2.Global }), t2.notifyGeometryChanged(), a7 = e12, s5 = r7, c4 = i7;
    }
  } };
}
function z3(t2, n7, e11, a7) {
  const s5 = E3(e11.getOriginPoint(n7.spatialReference), a7), l4 = n7.spatialReference;
  return t(s5) ? null : { move: (n8, o4, a8) => {
    const u3 = r5(s5.clone(), n8, o4, a8);
    if (u3.spatialReference.equals(l4))
      e11.origin = r2(u3.x, u3.y, u3.z);
    else {
      const t3 = rn(u3, l4);
      r(t3) && (e11.origin = r2(t3.x, t3.y, t3.z));
    }
    t2.notifyMeshTransformChanged(), t2.notifyGeometryChanged();
  } };
}
function v5(t2, n7) {
  const e11 = t2.map((t3) => e(h4(t3, n7))).filter((t3) => r(t3));
  return (t3) => {
    const n8 = t3.mapEnd.x - t3.mapStart.x, r7 = t3.mapEnd.y - t3.mapStart.y, o4 = t3.mapEnd.z - t3.mapStart.z;
    return e11.forEach((n9) => n9(t3)), { ...t3, translationX: n8, translationY: r7, translationZ: o4 };
  };
}
function w6(t2, e11) {
  const r7 = /* @__PURE__ */ new Map();
  for (const o4 of e11)
    r7.set(o4, y2(t2[o4]));
  return (n7) => (r7.forEach((n8, e12) => {
    t2[e12] = n8;
  }), n7);
}
function M(t2) {
  return r(t2.geometry) && "mesh" === t2.geometry.type ? q2(t2, t2.geometry) : w6(t2, ["geometry"]);
}
function q2(t2, n7) {
  const e11 = r(n7.transform) ? n7.transform.clone() : null, o4 = n7.vertexAttributes.clonePositional();
  return (r7) => (n7.transform = e11, n7.vertexAttributes = o4, t2.notifyGeometryChanged(), r7);
}
function D2(t2) {
  const n7 = t2.map((t3) => e(M(t3))).filter((t3) => r(t3));
  return (t3) => (n7.forEach((n8) => n8(t3)), t3);
}
function P3() {
  let t2 = 0, n7 = 0, e11 = 0;
  return (r7) => {
    "start" === r7.action && (t2 = r7.mapStart.x, n7 = r7.mapStart.y, e11 = r7.mapStart.z);
    const o4 = r7.mapEnd.x - t2, a7 = r7.mapEnd.y - n7, s5 = r7.mapEnd.z - e11;
    return t2 = r7.mapEnd.x, n7 = r7.mapEnd.y, e11 = r7.mapEnd.z, { ...r7, mapDeltaX: o4, mapDeltaY: a7, mapDeltaZ: s5, mapDeltaSpatialReference: r7.mapStart.spatialReference };
  };
}
function U3() {
  let t2 = 0, n7 = 0;
  return (e11) => {
    "start" === e11.action && (t2 = e11.screenStart.x, n7 = e11.screenStart.y);
    const r7 = e11.screenEnd.x - t2, o4 = e11.screenEnd.y - n7;
    return t2 = e11.screenEnd.x, n7 = e11.screenEnd.y, { ...e11, screenDeltaX: r7, screenDeltaY: o4 };
  };
}
function C(t2, n7) {
  let r7 = null, o4 = 0, a7 = 0;
  return (c4) => {
    if ("start" === c4.action && (r7 = t2.toScreen(n7), r7.x < 0 || r7.x > t2.width || r7.y < 0 || r7.y > t2.height ? r7 = null : (o4 = c4.screenStart.x - r7.x, a7 = c4.screenStart.y - r7.y)), null == r7)
      return null;
    const i7 = a(c4.screenEnd.x - o4, 0, t2.width), l4 = a(c4.screenEnd.y - a7, 0, t2.height), u3 = c(i7, l4);
    return c4.screenStart = r7, c4.screenEnd = u3, c4;
  };
}
var G = class {
  constructor() {
    this.execute = () => {
    };
  }
  next(t2, n7 = new G()) {
    return r(t2) && (this.execute = (e11) => {
      const o4 = t2(e11);
      r(o4) && n7.execute(o4);
    }), n7;
  }
};
function X(t2, n7, e11 = []) {
  if ("2d" === t2.type)
    return (t3) => t3;
  let o4 = null;
  return (a7) => {
    "start" === a7.action && (o4 = t2.toMap(a7.screenStart, { exclude: e11 }), r(o4) && (o4.z = d2(o4, t2, n7)));
    const s5 = t2.toMap(a7.screenEnd, { exclude: e11 });
    r(s5) && (s5.z = d2(s5, t2, n7));
    const c4 = r(o4) && r(s5) ? { sceneStart: o4, sceneEnd: s5 } : null;
    return { ...a7, scenePoints: c4 };
  };
}

// node_modules/@arcgis/core/views/interactive/snapping/SnappingDragPipelineStep.js
var u2 = class {
  constructor() {
    this.next = new G();
  }
  createSnapDragEventPipelineStep({ predicate: o4 = () => true, cancel: i7, snappingManager: r7, snappingContext: p6, updatingHandles: l4, useZ: c4 = true }) {
    if (t(r7))
      return (e11) => e11;
    let u3 = null, d4 = null;
    const f2 = () => {
      u3 = p(u3), r7.doneSnapping(), r(d4) && d4.frameTask.remove(), d4 = null;
    };
    i7.next((e11) => (f2(), e11)), this.next = new G();
    const m7 = this._createSnapFunction(r7, c4);
    let h6 = null, S3 = null, x2 = null;
    return (n7) => {
      if (!o4(n7))
        return n7;
      if ("start" === n7.action) {
        const e11 = this._createFrameTask(r7.view);
        if (d4 = this._createSnappingInfo(p6, n7, e11), d4.context.selfSnappingZ = null, !c4 && r(n7.info)) {
          const e12 = this._extractSelfSnappingZ(p6.coordinateHelper, n7.info.handle.component);
          r(e12) && (d4.context.selfSnappingZ = { value: e12, elevationInfo: p6.elevationInfo });
        }
      }
      if (r(d4)) {
        const { context: t2, originalScenePos: o5, originalPos: i8 } = d4, { mapEnd: s5, mapStart: p7, action: f3, scenePoints: P4 } = n7, g8 = this._updatePosition(i8, this._computeMapDelta(s5, p7)), _2 = this._computeMapDelta(p7, i8), y8 = { ...n7, action: "update" }, v6 = d4.context, Z3 = this._updateScenePosition(o5, P4), T2 = r7.update({ point: g8, scenePoint: Z3, context: t2 });
        if (x2 = T2, this._applySnappedUpdate(s5, T2, _2, c4), h6 = g8, S3 = Z3, "end" !== f3) {
          const { frameTask: t3 } = d4;
          t(u3) && (u3 = new AbortController()), l4.addPromise(g2(m7({ frameTask: t3, event: y8, context: v6, point: g8, scenePoint: Z3, delta: _2, lastPos: h6, lastScenePos: S3, lastUpdate: x2 }, u3.signal)));
        }
      }
      return "end" === n7.action && f2(), n7;
    };
  }
  _createSnapFunction(e11, n7) {
    return x(async ({ frameTask: a7, point: o4, scenePoint: r7, context: s5, event: p6, delta: l4, lastPos: c4, lastScenePos: u3, lastUpdate: d4 }, f2) => {
      const m7 = await a7.schedule(() => e11.snap({ point: o4, scenePoint: r7, context: s5, signal: f2 }), f2);
      if (m7.valid) {
        let r8 = await a7.schedule(() => m7.apply(), f2);
        o4 !== c4 && r(c4) && (r8 = e11.update({ point: c4, scenePoint: u3, context: s5 })), i4(r8, d4) || (this._applySnappedUpdate(p6.mapEnd, r8, l4, n7), this.next.execute(p6));
      }
    });
  }
  _createFrameTask(e11) {
    return "3d" === e11.type ? e11.resourceController.scheduler.registerTask(I2.SNAPPING) : y5;
  }
  _createSnappingInfo(e11, n7, a7) {
    return { context: new e7({ editGeometryOperations: e11.editGeometryOperations, elevationInfo: e11.elevationInfo, pointer: e11.pointer, vertexHandle: r(n7.info) ? n7.info.handle : null, excludeFeature: e11.excludeFeature, visualizer: e11.visualizer }), originalPos: r(n7.snapOrigin) ? e11.coordinateHelper.vectorToDehydratedPoint(n7.snapOrigin) : n7.mapStart, originalScenePos: r(n7.scenePoints) ? n7.scenePoints.sceneStart : null, frameTask: a7 };
  }
  _updatePosition(e11, [t2, n7, a7]) {
    const o4 = k(e11);
    return o4.x += t2, o4.y += n7, o4.hasZ && (o4.z += a7), o4;
  }
  _updateScenePosition(t2, n7) {
    return t(t2) || t(n7) ? null : this._updatePosition(t2, this._computeMapDelta(n7.sceneEnd, n7.sceneStart));
  }
  _computeMapDelta(e11, t2) {
    const n7 = e11.hasZ && t2.hasZ ? e11.z - t2.z : 0;
    return [e11.x - t2.x, e11.y - t2.y, n7];
  }
  _applySnappedUpdate(e11, t2, [n7, a7, o4], i7) {
    e11.x = t2.x + n7, e11.y = t2.y + a7, i7 && e11.hasZ && t2.hasZ && (e11.z = t2.z + o4);
  }
  _extractSelfSnappingZ(n7, a7) {
    if (!n7.hasZ())
      return null;
    const o4 = a7.vertices;
    let i7 = null;
    for (const r7 of o4) {
      const a8 = n7.getZ(r7.pos);
      if (r(i7) && Math.abs(a8 - i7) > 1e-6)
        return null;
      t(i7) && (i7 = a8);
    }
    return i7;
  }
};

// node_modules/@arcgis/core/views/draw/DrawingMode.js
var e9 = "click";

// node_modules/@arcgis/core/views/draw/DrawManipulator.js
var e10 = class {
  constructor({ grabbableForEvent: e11 }) {
    this.events = new n4(), this.interactive = true, this.selectable = false, this.cursor = null, this.grabbable = true, this.grabbableForEvent = e11;
  }
  intersectionDistance(t2, e11) {
    return 0;
  }
  attach() {
  }
  detach() {
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/SnappingOperation.js
var h5 = class extends m2 {
  constructor(t2) {
    super(t2), this.constrainResult = (t3) => t3, this._snapPoints = null, this._abortController = null, this._stagedPoint = null, this._snap = x(async (t3, s5, r7, e11) => {
      const i7 = await this._frameTask.schedule(() => s5.snap({ ...t3, context: r7, signal: e11 }), e11);
      i7.valid && await this._frameTask.schedule(() => {
        this.stagedPoint = i7.apply(), t3 !== this._snapPoints && r(this._snapPoints) && (this.stagedPoint = s5.update({ ...this._snapPoints, context: r7 }));
      }, e11);
    });
  }
  get stagedPoint() {
    return this._stagedPoint;
  }
  set stagedPoint(t2) {
    this._stagedPoint = this.constrainResult(t2);
  }
  initialize() {
    var _a, _b;
    const t2 = "3d" === this.view.type ? (_b = (_a = this.view) == null ? void 0 : _a.resourceController) == null ? void 0 : _b.scheduler : null;
    this._frameTask = r(t2) ? t2.registerTask(I2.SNAPPING) : y5;
  }
  destroy() {
    this._abortController = p(this._abortController), this._frameTask = h(this._frameTask);
  }
  async snap(t2, s5, o4) {
    const { point: r7, scenePoint: e11 } = t2;
    return this.stagedPoint = s5.update({ point: r7, scenePoint: e11, context: o4 }), this._snapPoints = t2, t(this._abortController) && (this._abortController = new AbortController()), this._snap(t2, s5, o4, this._abortController.signal);
  }
  abort() {
    this._abortController = p(this._abortController);
  }
};
e3([y3({ constructOnly: true })], h5.prototype, "view", void 0), e3([y3()], h5.prototype, "stagedPoint", null), e3([y3()], h5.prototype, "constrainResult", void 0), e3([y3()], h5.prototype, "_stagedPoint", void 0), h5 = e3([n3("esri.views.interactive.snapping.SnappingOperation")], h5);

// node_modules/@arcgis/core/views/draw/DrawOperation.js
var C2 = class extends n4.EventedMixin(d) {
  constructor(e11) {
    super(e11), this._createOperationCompleted = false, this._pointerDownStates = /* @__PURE__ */ new Set(), this._snappingPipeline = new u2(), this.isDraped = true, this.labelOptions = new c2(), this.tooltipOptions = new p3(), this.snapToSceneEnabled = null, this.lastVertex = null, t(e11.elevationInfo) && (this.elevationInfo = s3(e11.hasZ));
  }
  initialize() {
    const { geometryType: e11, view: t2 } = this, { spatialReference: i7 } = t2, n7 = "viewingMode" in t2.state ? t2.state.viewingMode : l2.Local, s5 = "segment" === e11 || "multipoint" === e11 ? "polyline" : e11;
    this.coordinateHelper = w4(this.hasZ, this.hasM, i7), this._editGeometryOperations = new V(new g5(s5, this.coordinateHelper)), this._snappingOperation = new h5({ view: t2, constrainResult: (e12) => t(e12) ? e12 : this._getEffectiveDrawSurface().constrainZ(e12) }), this.handles.add(l(() => this.stagedVertex, (e12) => {
      t(e12) || this.emit("cursor-update", { updated: null, vertices: [{ componentIndex: 0, vertexIndex: this._activeComponent.vertices.length, coordinates: this.coordinateHelper.pointToArray(e12) }], operation: "apply", type: "vertex-update" });
    }, { sync: true, equals: (e12, t3) => y(e12, t3, i4) })), this._activeComponent = new p4(i7, n7), this._editGeometryOperations.data.components.push(this._activeComponent);
    const a7 = this.segmentLabels;
    r(a7) && (a7.context = { view: t2, editGeometryOperations: this._editGeometryOperations, elevationInfo: this.elevationInfo, labelOptions: this.labelOptions }, this.handles.add([l(() => this.labelOptions.enabled, (e12) => {
      a7.visible = e12;
    }, w2), this.on("cursor-update", () => {
      const e12 = this.stagedVertex;
      a7.stagedVertex = r(e12) ? this.coordinateHelper.pointToVector(e12) : null;
    })])), this.handles.add(this._editGeometryOperations.on(["vertex-add", "vertex-update", "vertex-remove"], (e12) => {
      const t3 = e12.vertices.map((e13) => ({ componentIndex: 0, vertexIndex: e13.index, coordinates: this.coordinateHelper.vectorToArray(e13.pos) })), i8 = t3.map((e13) => e13.coordinates);
      switch (e12.type) {
        case "vertex-add":
          this.emit(e12.type, { ...e12, added: i8, vertices: t3 });
          break;
        case "vertex-update":
          this.emit(e12.type, { ...e12, updated: i8, vertices: t3 });
          break;
        case "vertex-remove":
          this.emit(e12.type, { ...e12, removed: i8, vertices: t3 });
      }
      const n8 = this._activeComponent.getLastVertex(), s6 = r(n8) ? this.coordinateHelper.vectorToDehydratedPoint(n8.pos) : null;
      (t(s6) || t(this.lastVertex) || !i4(this.lastVertex, s6)) && (this.lastVertex = s6);
    })), this._manipulator = new e10({ grabbableForEvent: (e12) => "click" !== this.drawingMode || "touch" === e12.pointerType && this._snappingEnabled && 1 === this._pointerDownStates.size }), this.manipulators.add(this._manipulator), this._manipulator.grabbable = "point" !== e11, this.handles.add([this._createManipulatorDragPipeline(this._manipulator), this._manipulator.events.on("immediate-click", (e12) => this._onImmediateClick(e12)), this._manipulator.events.on("immediate-double-click", (e12) => this._onImmediateDoubleClick(e12))]);
  }
  destroy() {
    s(this.segmentLabels), s(this._snappingOperation), this._editGeometryOperations = s(this._editGeometryOperations);
  }
  get _snappingEnabled() {
    return r(this.snappingManager) && this.snappingManager.options.effectiveEnabled;
  }
  get _requiresScenePoint() {
    const e11 = this._getEffectiveDrawSurface();
    return "3d" === this.view.type && this.drawSurface !== e11;
  }
  get canRedo() {
    return this._editGeometryOperations.canRedo;
  }
  get canUndo() {
    return this._editGeometryOperations.canUndo;
  }
  get committedVertices() {
    return this._activeComponent.vertices.map((e11) => this.coordinateHelper.vectorToArray(e11.pos));
  }
  set drawingMode(e11) {
    this._set("drawingMode", e11 != null ? e11 : e9);
  }
  get interactive() {
    return this._manipulator.interactive;
  }
  set interactive(e11) {
    this._manipulator.interactive = e11;
  }
  get isCompleted() {
    return this._createOperationCompleted;
  }
  get numCommittedVertices() {
    return this._activeComponent.vertices.length;
  }
  get numVertices() {
    return r(this.stagedVertex) ? this._activeComponent.vertices.length + 1 : this._activeComponent.vertices.length;
  }
  get stagedVertex() {
    return this._snappingOperation.stagedPoint;
  }
  set stagedVertex(e11) {
    this._snappingOperation.stagedPoint = y2(e11);
  }
  get updating() {
    return this.updatingHandles.updating;
  }
  get vertices() {
    const e11 = this.committedVertices;
    return r(this.stagedVertex) && e11.push(this.coordinateHelper.pointToArray(this.stagedVertex)), e11;
  }
  cancel() {
    this.complete({ aborted: true });
  }
  commitStagedVertex() {
    if (this._snappingOperation.abort(), r(this.stagedVertex)) {
      const { stagedVertex: e11 } = this;
      this.stagedVertex = null, this._editGeometryOperations.appendVertex(this.coordinateHelper.pointToVector(e11));
    }
  }
  complete(e11) {
    const t2 = e11 && e11.aborted || false;
    this._snappingOperation.abort(), r(this.snappingManager) && this.snappingManager.doneSnapping(), "segment" === this.geometryType || "point" === this.geometryType ? this.commitStagedVertex() : this.stagedVertex = null;
    const i7 = "multipoint" === this.geometryType && 0 === this.numVertices || "polyline" === this.geometryType && this.numVertices < 2 || "polygon" === this.geometryType && this.numVertices < 3;
    this._createOperationCompleted = !i7, (this.isCompleted || t2) && this.emit("complete", { vertices: this.vertices.map((e12, t3) => ({ componentIndex: 0, vertexIndex: t3, coordinates: e12 })), aborted: t2, type: "complete" });
  }
  onInputEvent(e11) {
    switch (e11.type) {
      case "pointer-down":
        this._pointerDownStates.add(e11.pointerId);
        break;
      case "pointer-up":
        this._pointerDownStates.delete(e11.pointerId);
    }
    switch (e11.type) {
      case "pointer-move":
        return this._onPointerMove(e11);
      case "hold":
        return this._onHold(e11);
    }
  }
  redo() {
    this._editGeometryOperations.redo();
  }
  undo() {
    r(this.snappingManager) && this.snappingManager.doneSnapping(), this._editGeometryOperations.undo();
  }
  _closeOnClickVertexIndex(e11) {
    const t2 = this._activeComponent;
    if ("polygon" === this.geometryType && t2.vertices.length > 2) {
      if (this._vertexWithinPointerDistance(t2.vertices[0].pos, e11))
        return 0;
      if (this._vertexWithinPointerDistance(t2.vertices[t2.vertices.length - 1].pos, e11))
        return t2.vertices.length - 1;
    }
    return null;
  }
  _createManipulatorDragPipeline(e11) {
    switch (e(this.drawingMode)) {
      case "click":
        return this._createManipulatorDragPipelineClick(e11);
      case "freehand":
        return this._createManipulatorDragPipelineFreehand(e11);
      case "hybrid":
        return this._createManipulatorDragPipelineHybrid(e11);
    }
  }
  _createManipulatorDragPipelineClick(e11) {
    return d3(e11, (e12, t2, i7, n7) => {
      const r7 = "touch" === n7 && this._snappingEnabled;
      !this.isCompleted && r7 && (i7 = i7.next((e13) => (r7 && r(this.snappingManager) && this.snappingManager.doneSnapping(), e13)), t2.next(this._screenToMapDragEventStep()).next((e13) => ("start" === e13.action && (this.stagedVertex = e13.mapStart, ("segment" === this.geometryType || r7 && 0 === this.numVertices) && this.commitStagedVertex()), e13)).next(X(this.view, this.elevationInfo)).next(this._snappingPipeline.createSnapDragEventPipelineStep({ predicate: () => r7, cancel: i7, snappingManager: this.snappingManager, snappingContext: new e7({ editGeometryOperations: this._editGeometryOperations, elevationInfo: this.elevationInfo, pointer: n7, visualizer: this.snappingVisualizer }), updatingHandles: this.updatingHandles, useZ: !this._requiresScenePoint }), this._snappingPipeline.next).next((e13) => (r7 && (this.stagedVertex = e13.mapEnd, "end" === e13.action && this.commitStagedVertex()), e13)).next((e13) => ("end" === e13.action && ("segment" !== this.geometryType && "point" !== this.geometryType || this.complete()), e13)));
    });
  }
  _createManipulatorDragPipelineFreehand(e11) {
    return d3(e11, (e12, t2) => {
      this.isCompleted || t2.next(this._screenToMapDragEventStep()).next((e13) => ("start" === e13.action && (t(this.stagedVertex) && (this.stagedVertex = e13.mapStart), "segment" === this.geometryType && this.commitStagedVertex()), e13)).next((e13) => {
        switch (e13.action) {
          case "start":
          case "update":
            this.stagedVertex = e13.mapEnd, "polygon" !== this.geometryType && "polyline" !== this.geometryType || this.commitStagedVertex();
            break;
          case "end":
            this.complete();
        }
        return e13;
      });
    });
  }
  _createManipulatorDragPipelineHybrid(e11) {
    return d3(e11, (e12, t2) => {
      this.isCompleted || t2.next(this._screenToMapDragEventStep()).next((e13) => ("start" === e13.action && (t(this.stagedVertex) && (this.stagedVertex = e13.mapStart), this.commitStagedVertex()), e13)).next((e13) => {
        switch (e13.action) {
          case "start":
          case "update":
            this.stagedVertex = e13.mapEnd, "polygon" !== this.geometryType && "polyline" !== this.geometryType || this.commitStagedVertex();
            break;
          case "end":
            "segment" !== this.geometryType && "point" !== this.geometryType || this.complete();
        }
        return e13;
      });
    });
  }
  get _drawAtFixedElevation() {
    return ("segment" === this.geometryType || "polygon" === this.geometryType) && this.numCommittedVertices > 0;
  }
  _getEffectiveDrawSurface() {
    if (t(this.elevationDrawSurface))
      return this.drawSurface;
    if (!this.coordinateHelper.hasZ())
      return this.elevationDrawSurface.defaultZ = null, this.elevationDrawSurface;
    let e11 = this.defaultZ, t2 = false;
    return r(this.elevationInfo) && "absolute-height" === this.elevationInfo.mode && (t2 = true), r(this.snapToSceneEnabled) && (t2 = this.snapToSceneEnabled), r(this.elevationInfo) && "on-the-ground" === this.elevationInfo.mode && (t2 = false), this._drawAtFixedElevation && (e11 = this.coordinateHelper.getZ(this._activeComponent.vertices[0].pos), t2 = false), t2 ? this.drawSurface : (this.elevationDrawSurface.defaultZ = e11, this.elevationDrawSurface);
  }
  _mapToScreen(e11) {
    return this._getEffectiveDrawSurface().mapToScreen(e11);
  }
  _onHold(e11) {
    this._snappingOperation.abort(), "click" === this.drawingMode && "touch" === e11.pointerType && this._snappingEnabled && (this.stagedVertex = e11.mapPoint), e11.stopPropagation();
  }
  _onImmediateClick(e11) {
    if ("mouse" === e11.pointerType && 2 === e11.button || this._manipulator.dragging)
      return;
    const t2 = this._activeComponent, i7 = this._closeOnClickVertexIndex(e11.screenPoint);
    if (r(i7))
      return e11.stopPropagation(), void this.complete();
    const n7 = this._screenToMap(e11.screenPoint);
    if (r(n7))
      switch (this.drawingMode) {
        case "freehand":
          "point" === this.geometryType && (r(this.stagedVertex) ? this.commitStagedVertex() : this._editGeometryOperations.appendVertex(this.coordinateHelper.pointToVector(n7)), this.complete());
          break;
        case "click":
        case "hybrid":
          this._snappingOperation.abort(), r(this.stagedVertex) ? this.commitStagedVertex() : this._editGeometryOperations.appendVertex(this.coordinateHelper.pointToVector(n7)), ("point" === this.geometryType || "segment" === this.geometryType && 2 === t2.vertices.length || "segment" === this.geometryType && "hybrid" === this.drawingMode && 1 === t2.vertices.length) && this.complete();
      }
    e11.stopPropagation();
  }
  _onImmediateDoubleClick(e11) {
    this._manipulator.dragging || "point" === this.geometryType || (this.complete(), e11.stopPropagation());
  }
  _onPointerMove(e11) {
    const t2 = c(e11.x, e11.y), i7 = this._snappingOperation;
    if (this._manipulator.dragging || this._pointerDownStates.has(e11.pointerId) || this._manipulator.grabbing || !this._manipulator.interactive)
      return void i7.abort();
    e11.stopPropagation();
    const n7 = this._closeOnClickVertexIndex(t2);
    if (r(n7))
      return this._closeOnVertex(n7), void i7.abort();
    const s5 = this._screenToMap(t2), a7 = this._requiresScenePoint ? this.drawSurface.screenToMap(t2) : null;
    if (this._manipulator.cursor = r(s5) ? "crosshair" : null, t(s5))
      return void i7.abort();
    const c4 = this.snappingManager;
    if (t(c4))
      return this.stagedVertex = s5, void i7.abort();
    const d4 = this._drawAtFixedElevation ? o(this.elevationDrawSurface, ({ defaultZ: e12 }) => e12) : null, l4 = new e7({ editGeometryOperations: this._editGeometryOperations, elevationInfo: this.elevationInfo, pointer: e11.pointerType, visualizer: this.snappingVisualizer, selfSnappingZ: r(d4) ? { value: d4, elevationInfo: this.elevationInfo } : null });
    this.updatingHandles.addPromise(g2(i7.snap({ point: s5, scenePoint: a7 }, c4, l4)));
  }
  _closeOnVertex(e11) {
    this.stagedVertex = null;
    const t2 = { componentIndex: 0, vertexIndex: e11, coordinates: this.coordinateHelper.vectorToArray(this._activeComponent.vertices[e11].pos) };
    this.emit("cursor-update", { updated: null, vertices: [t2], operation: "apply", type: "vertex-update" });
  }
  _screenToMap(e11) {
    return this._getEffectiveDrawSurface().screenToMap(e11);
  }
  _screenToMapDragEventStep() {
    let e11 = null;
    return (t2) => {
      if ("start" === t2.action && (e11 = this._screenToMap(t2.screenStart)), t(e11))
        return null;
      const i7 = this._screenToMap(t2.screenEnd);
      return r(i7) ? { ...t2, mapStart: e11, mapEnd: i7 } : null;
    };
  }
  _vertexWithinPointerDistance(e11, t2) {
    const i7 = 25, n7 = this._mapToScreen(this.coordinateHelper.vectorToDehydratedPoint(e11));
    return !!r(n7) && k3(n7, t2, i7);
  }
};
function k3(e11, t2, i7) {
  const n7 = e11.x - t2.x, r7 = e11.y - t2.y;
  return n7 * n7 + r7 * r7 <= i7;
}
e3([y3()], C2.prototype, "_snappingEnabled", null), e3([y3()], C2.prototype, "defaultZ", void 0), e3([y3()], C2.prototype, "isDraped", void 0), e3([y3({ value: e9 })], C2.prototype, "drawingMode", null), e3([y3({ constructOnly: true })], C2.prototype, "elevationDrawSurface", void 0), e3([y3({ constructOnly: true })], C2.prototype, "elevationInfo", void 0), e3([y3({ constructOnly: true, type: c2 })], C2.prototype, "labelOptions", void 0), e3([y3({ constructOnly: true, type: p3 })], C2.prototype, "tooltipOptions", void 0), e3([y3({ constructOnly: true })], C2.prototype, "geometryType", void 0), e3([y3({ constructOnly: true })], C2.prototype, "hasM", void 0), e3([y3({ constructOnly: true })], C2.prototype, "hasZ", void 0), e3([y3({ constructOnly: true })], C2.prototype, "manipulators", void 0), e3([y3({ constructOnly: true })], C2.prototype, "drawSurface", void 0), e3([y3({ constructOnly: true })], C2.prototype, "segmentLabels", void 0), e3([y3({ constructOnly: true })], C2.prototype, "snappingManager", void 0), e3([y3({ constructOnly: true })], C2.prototype, "snappingVisualizer", void 0), e3([y3()], C2.prototype, "snapToSceneEnabled", void 0), e3([y3()], C2.prototype, "_snappingOperation", void 0), e3([y3()], C2.prototype, "stagedVertex", null), e3([y3()], C2.prototype, "lastVertex", void 0), e3([y3()], C2.prototype, "updating", null), e3([y3({ constructOnly: true })], C2.prototype, "view", void 0), C2 = e3([n3("esri.views.draw.DrawOperation")], C2);

// node_modules/@arcgis/core/views/draw/drawSurfaces.js
var o3 = class {
  constructor(e11, t2, s5, i7 = null) {
    this._elevationInfo = e11, this.defaultZ = t2, this._view = s5, this._excludeGraphics = i7;
  }
  screenToMap(s5) {
    if (r(this.defaultZ))
      return this._view.sceneIntersectionHelper.intersectElevationFromScreen(i3(s5.x, s5.y), this._elevationInfo, this.defaultZ, this._excludeGraphics);
    const i7 = this._view.sceneIntersectionHelper.intersectElevationFromScreen(i3(s5.x, s5.y), this._elevationInfo, 0, this._excludeGraphics);
    return r(i7) && (i7.z = void 0), i7;
  }
  mapToScreen(e11) {
    const t2 = v2(e11.x, e11.y, g4(this._view, e11, this._elevationInfo), e11.spatialReference);
    return this._view.toScreen(t2);
  }
  constrainZ(t2) {
    const { defaultZ: s5 } = this;
    return r(s5) && t2.z !== s5 && ((t2 = k(t2)).z = s5), t2;
  }
};
var c3 = class {
  constructor(e11, t2, s5 = []) {
    this.view = e11, this.elevationInfo = t2, this.exclude = s5;
  }
  screenToMap(t2) {
    const s5 = this.view.toMap(t2, { exclude: this.exclude });
    return r(s5) && (s5.z = d2(s5, this.view, this.elevationInfo)), s5;
  }
  mapToScreen(t2) {
    let i7 = t2;
    return r(this.elevationInfo) && (i7 = v2(t2.x, t2.y, g4(this.view, t2, this.elevationInfo), t2.spatialReference)), this.view.toScreen(i7);
  }
  constrainZ(e11) {
    return e11;
  }
};
var a6 = class {
  constructor(e11, t2 = false, s5 = 0) {
    this.view = e11, this.hasZ = t2, this.defaultZ = s5, this.mapToScreen = (t3) => e11.toScreen(t3), this.screenToMap = t2 ? (t3) => {
      const i7 = e11.toMap(t3);
      return i7.z = s5, i7;
    } : (t3) => e11.toMap(t3);
  }
  constrainZ(e11) {
    const { defaultZ: t2 } = this;
    return this.hasZ && e11.z !== t2 && ((e11 = k(e11)).z = t2), e11;
  }
};

export {
  p5 as p,
  Z2 as Z,
  q,
  d3 as d,
  g7 as g,
  h4 as h,
  v5 as v,
  M,
  D2 as D,
  P3 as P,
  U3 as U,
  C,
  G,
  X,
  u2 as u,
  C2,
  o3 as o,
  c3 as c,
  a6 as a
};
//# sourceMappingURL=chunk-44WW37FH.js.map
