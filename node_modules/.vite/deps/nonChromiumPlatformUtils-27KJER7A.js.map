{
  "version": 3,
  "sources": ["../../@esri/calcite-components/dist/components/nonChromiumPlatformUtils.js"],
  "sourcesContent": ["/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.\n * v1.0.6\n */\nimport { e as rectToClientRect } from './floating-ui.js';\n\n/**\n * This module provides utils to fix positioning across shadow DOM in non-Chromium browsers\n *\n * It is based on floating-ui's distributable\n */\n/**\n * \uD83D\uDC47 the following are needed to fix shadow DOM positioning \uD83D\uDC47\uFE0F\n *\n * @param element\n */\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === \"fixed\") {\n    return null;\n  }\n  return composedOffsetParent(element);\n}\n/**\n * Polyfills the old offsetParent behavior from before the spec was changed:\n * https://github.com/w3c/csswg-drafts/issues/159\n *\n * @param element\n */\nfunction composedOffsetParent(element) {\n  let { offsetParent } = element;\n  let ancestor = element;\n  let foundInsideSlot = false;\n  while (ancestor && ancestor !== offsetParent) {\n    const { assignedSlot } = ancestor;\n    if (assignedSlot) {\n      let newOffsetParent = assignedSlot.offsetParent;\n      if (getComputedStyle(assignedSlot).display === \"contents\") {\n        const hadStyleAttribute = assignedSlot.hasAttribute(\"style\");\n        const oldDisplay = assignedSlot.style.display;\n        assignedSlot.style.display = getComputedStyle(ancestor).display;\n        newOffsetParent = assignedSlot.offsetParent;\n        assignedSlot.style.display = oldDisplay;\n        if (!hadStyleAttribute) {\n          assignedSlot.removeAttribute(\"style\");\n        }\n      }\n      ancestor = assignedSlot;\n      if (offsetParent !== newOffsetParent) {\n        offsetParent = newOffsetParent;\n        foundInsideSlot = true;\n      }\n    }\n    else if (isShadowRoot(ancestor) && ancestor.host && foundInsideSlot) {\n      break;\n    }\n    ancestor = (isShadowRoot(ancestor) && ancestor.host) || ancestor.parentNode;\n  }\n  return offsetParent;\n}\nfunction getElementRects(_ref) {\n  const { reference, floating, strategy } = _ref;\n  return {\n    reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),\n    floating: { ...getDimensions(floating), x: 0, y: 0 }\n  };\n}\n/**\n * \u261D\uFE0F the following are needed to fix shadow DOM positioning \u261D\uFE0F\n */\n/**\n * \uD83D\uDC47 the following are taken directly from floating-ui's ESM distributable to support the exports above \uD83D\uDC47\uFE0F\n *\n * **Notes**:\n * unused functions are removed\n * ESLint is disabled\n * TS-warnings are suppressed\n */\n/* eslint-disable */\nfunction isWindow(value) {\n  return value && value.document && value.location && value.alert && value.setInterval;\n}\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n  if (!isWindow(node)) {\n    const ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n  return node;\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeName(node) {\n  return isWindow(node) ? \"\" : node ? (node.nodeName || \"\").toLowerCase() : \"\";\n}\nfunction getUAString() {\n  // @ts-ignore\n  const uaData = navigator.userAgentData;\n  if (uaData != null && uaData.brands) {\n    return uaData.brands.map((item) => item.brand + \"/\" + item.version).join(\" \");\n  }\n  return navigator.userAgent;\n}\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support\n  if (typeof ShadowRoot === \"undefined\") {\n    return false;\n  }\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  const { overflow, overflowX, overflowY, display } = getComputedStyle(element);\n  return (/auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX) && ![\"inline\", \"contents\"].includes(display));\n}\nfunction isTableElement(element) {\n  return [\"table\", \"td\", \"th\"].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  // TODO: Try and use feature detection here instead\n  const isFirefox = /firefox/i.test(getUAString());\n  const css = getComputedStyle(element); // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return (css.transform !== \"none\" ||\n    css.perspective !== \"none\" ||\n    (isFirefox && css.willChange === \"filter\") ||\n    (isFirefox && (css.filter ? css.filter !== \"none\" : false)) ||\n    [\"transform\", \"perspective\"].some((value) => css.willChange.includes(value)) ||\n    [\"paint\", \"layout\", \"strict\", \"content\"].some(\n    // TS 4.1 compat\n    (value) => {\n      const contain = css.contain;\n      return contain != null ? contain.includes(value) : false;\n    }));\n}\nfunction isLayoutViewport() {\n  // Not Safari\n  return !/^((?!chrome|android).)*safari/i.test(getUAString()); // Feature detection for this fails in various ways\n  // \u2022 Always-visible scrollbar or not\n  // \u2022 Width of <html>, etc.\n  // const vV = win.visualViewport;\n  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;\n}\nfunction isLastTraversableNode(node) {\n  return [\"html\", \"body\", \"#document\"].includes(getNodeName(node));\n}\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n  const win = isElement(element) ? getWindow(element) : window;\n  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  const x = (clientRect.left +\n    (addVisualOffsets\n      ? (_win$visualViewport$o =\n        (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null\n        ? _win$visualViewport$o\n        : 0\n      : 0)) /\n    scaleX;\n  const y = (clientRect.top +\n    (addVisualOffsets\n      ? (_win$visualViewport$o2 =\n        (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null\n        ? _win$visualViewport$o2\n        : 0\n      : 0)) /\n    scaleY;\n  const width = clientRect.width / scaleX;\n  const height = clientRect.height / scaleY;\n  return {\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x,\n    y\n  };\n}\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  // @ts-ignore\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\nfunction isScaled(element) {\n  // @ts-ignore\n  const rect = getBoundingClientRect(element);\n  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;\n}\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, // @ts-ignore - checked above (TS 4.1 compat)\n  isOffsetParentAnElement && isScaled(offsetParent), strategy === \"fixed\");\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n  if (isOffsetParentAnElement || (!isOffsetParentAnElement && strategy !== \"fixed\")) {\n    if (getNodeName(offsetParent) !== \"body\" || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      // @ts-ignore\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n    else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === \"html\") {\n    return node;\n  }\n  return (\n  // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n  // @ts-ignore\n  node.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    node.parentNode || // DOM Element detected\n    (isShadowRoot(node) ? node.host : null) || // ShadowRoot detected\n    getDocumentElement(node) // fallback\n  );\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    }\n    else {\n      const parent = currentNode.parentNode;\n      currentNode = isShadowRoot(parent) ? parent.host : parent;\n    }\n  }\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element) {\n  const window = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === \"static\") {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n  if (offsetParent &&\n    (getNodeName(offsetParent) === \"html\" ||\n      (getNodeName(offsetParent) === \"body\" &&\n        getComputedStyle(offsetParent).position === \"static\" &&\n        !isContainingBlock(offsetParent)))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\nfunction getDimensions(element) {\n  if (isHTMLElement(element)) {\n    return {\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    };\n  }\n  // @ts-ignore\n  const rect = getBoundingClientRect(element);\n  return {\n    width: rect.width,\n    height: rect.height\n  };\n}\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const layoutViewport = isLayoutViewport();\n    if (layoutViewport || (!layoutViewport && strategy === \"fixed\")) {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body || html).direction === \"rtl\") {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    // @ts-ignore assume body is always available\n    return node.ownerDocument.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n  if (list === void 0) {\n    list = [];\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  const target = isBody\n    ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [])\n    : scrollableAncestor;\n  const updatedList = list.concat(target);\n  return isBody\n    ? updatedList // @ts-ignore: isBody tells us target will be an HTMLElement here\n    : updatedList.concat(getOverflowAncestors(target));\n}\nfunction contains(parent, child) {\n  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n    do {\n      // use `===` replace node.isSameNode()\n      if (next && parent === next) {\n        return true;\n      } // @ts-ignore: need a better way to handle this...\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n  return false;\n}\nfunction getNearestParentCapableOfEscapingClipping(element, clippingAncestors) {\n  let currentNode = element;\n  while (currentNode && !isLastTraversableNode(currentNode) && !clippingAncestors.includes(currentNode)) {\n    if (isElement(currentNode) && [\"absolute\", \"fixed\"].includes(getComputedStyle(currentNode).position)) {\n      break;\n    }\n    const parentNode = getParentNode(currentNode);\n    currentNode = isShadowRoot(parentNode) ? parentNode.host : parentNode;\n  }\n  return currentNode;\n}\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, false, strategy === \"fixed\");\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  return {\n    top,\n    left,\n    x: left,\n    y: top,\n    right: left + element.clientWidth,\n    bottom: top + element.clientHeight,\n    width: element.clientWidth,\n    height: element.clientHeight\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingParent, strategy) {\n  if (clippingParent === \"viewport\") {\n    return rectToClientRect(getViewportRect(element, strategy));\n  }\n  if (isElement(clippingParent)) {\n    return getInnerBoundingClientRect(clippingParent, strategy);\n  }\n  return rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping ancestor\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\nfunction getClippingAncestors(element) {\n  // @ts-ignore\n  const clippingAncestors = getOverflowAncestors(element);\n  const nearestEscapableParent = getNearestParentCapableOfEscapingClipping(element, clippingAncestors);\n  let clipperElement = null;\n  if (nearestEscapableParent && isHTMLElement(nearestEscapableParent)) {\n    const offsetParent = getOffsetParent(nearestEscapableParent);\n    if (isOverflowElement(nearestEscapableParent)) {\n      clipperElement = nearestEscapableParent;\n    }\n    else if (isHTMLElement(offsetParent)) {\n      clipperElement = offsetParent;\n    }\n  }\n  if (!isElement(clipperElement)) {\n    return [];\n  } // @ts-ignore isElement check ensures we return Array<Element>\n  return clippingAncestors.filter((clippingAncestors) => clipperElement &&\n    isElement(clippingAncestors) &&\n    contains(clippingAncestors, clipperElement) &&\n    getNodeName(clippingAncestors) !== \"body\");\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors\nfunction getClippingRect(_ref) {\n  let { element, boundary, rootBoundary, strategy } = _ref;\n  const mainClippingAncestors = boundary === \"clippingAncestors\" ? getClippingAncestors(element) : [].concat(boundary);\n  const clippingAncestors = [...mainClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nexport { getClippingRect, getElementRects, getOffsetParent };\n"],
  "mappings": "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",
  "names": ["window", "clippingAncestors"]
}
