import {
  i as i2,
  p as p2
} from "./chunk-6ZSFG5OL.js";
import {
  r as r3
} from "./chunk-O5SNR6GN.js";
import {
  D,
  h as h4
} from "./chunk-W2R5RR3G.js";
import "./chunk-NVFGGIRQ.js";
import {
  h as h2
} from "./chunk-CCMJCJP5.js";
import {
  h as h3,
  j,
  m as m3
} from "./chunk-6NRJP66X.js";
import {
  a,
  i,
  m as m4,
  s as s2
} from "./chunk-KDTWVGPE.js";
import "./chunk-KLOEF26H.js";
import "./chunk-URFNTHOE.js";
import "./chunk-XLJB6BCW.js";
import "./chunk-CNM6M4B2.js";
import {
  e as e2
} from "./chunk-GLZIV37N.js";
import {
  p
} from "./chunk-2NKIENHY.js";
import "./chunk-C6BDJNUQ.js";
import "./chunk-Y3Q6KWWE.js";
import "./chunk-OJ2HHY2O.js";
import "./chunk-4RQKL5NC.js";
import "./chunk-HSH7J5EL.js";
import "./chunk-757322TP.js";
import "./chunk-P3W4YLFD.js";
import "./chunk-75RMBUYZ.js";
import "./chunk-RW4M3CI3.js";
import "./chunk-FFVIDMFN.js";
import "./chunk-ZN2ROKCE.js";
import "./chunk-NWBHRPMR.js";
import "./chunk-IIUWTGWW.js";
import "./chunk-K6AYGXUT.js";
import "./chunk-BHXTNOEK.js";
import "./chunk-IS4TIT4N.js";
import "./chunk-I4RYNNL6.js";
import "./chunk-NCONZRBI.js";
import "./chunk-A4HIS5ZJ.js";
import "./chunk-ZWUEORSX.js";
import "./chunk-QWNKYSI4.js";
import "./chunk-FMJZBZWF.js";
import "./chunk-GOYVJTGW.js";
import "./chunk-ZPYDYUP5.js";
import "./chunk-36I5ESAQ.js";
import "./chunk-CYI2FLSH.js";
import "./chunk-TDV3ZXCQ.js";
import "./chunk-XJCUKRCO.js";
import "./chunk-SOEQPPQP.js";
import "./chunk-22F6X66Z.js";
import "./chunk-AIDV7EKX.js";
import "./chunk-FZQZIM7U.js";
import "./chunk-YM6PUX7G.js";
import "./chunk-QEYOWTXD.js";
import "./chunk-CZBRZ6SU.js";
import "./chunk-KDO6J2FO.js";
import "./chunk-RT3T2K4S.js";
import "./chunk-WJCI2CGX.js";
import "./chunk-REIQNAQW.js";
import {
  g
} from "./chunk-J6LQZWZI.js";
import {
  y as y2
} from "./chunk-OD3FDQCI.js";
import "./chunk-J2PJNRU7.js";
import "./chunk-56SPM3WK.js";
import "./chunk-XMZAPOBR.js";
import "./chunk-BLJKKR5D.js";
import "./chunk-ZGNCYHMZ.js";
import "./chunk-X2S4RQJ4.js";
import "./chunk-FUPLN7UM.js";
import "./chunk-376OPXM4.js";
import "./chunk-DER356EU.js";
import "./chunk-MZIWIEIR.js";
import {
  S
} from "./chunk-TQEOEDAZ.js";
import {
  m as m2
} from "./chunk-SHFHZMHO.js";
import "./chunk-NRP45AHD.js";
import "./chunk-IWQ7452U.js";
import "./chunk-NAN5J6QS.js";
import "./chunk-B4DKBAM3.js";
import {
  u as u2
} from "./chunk-6M2AHKYV.js";
import "./chunk-SZIJNKCV.js";
import "./chunk-6O43OEU5.js";
import "./chunk-J2K7ZDSV.js";
import "./chunk-2UML3WQZ.js";
import "./chunk-KXVMEIWT.js";
import "./chunk-UDND2Z3V.js";
import "./chunk-23Y3DIC6.js";
import "./chunk-JUVQV3R3.js";
import "./chunk-RAX2HD42.js";
import "./chunk-ZYRIJWLX.js";
import "./chunk-C5H57NTD.js";
import "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import "./chunk-YWAQYJRC.js";
import "./chunk-B356PXLT.js";
import "./chunk-EHPBHJYZ.js";
import {
  h2 as h,
  m2 as m,
  r as r2,
  u,
  v2 as v
} from "./chunk-3MNMDUQZ.js";
import {
  w
} from "./chunk-UWG37XSU.js";
import "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import "./chunk-HLM6QCL2.js";
import "./chunk-RXYULINL.js";
import {
  f,
  l,
  w as w2
} from "./chunk-5NXILPDI.js";
import {
  n as n2
} from "./chunk-THVR7IAM.js";
import "./chunk-ZWJJTUFL.js";
import "./chunk-XQN7F674.js";
import "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import "./chunk-KAN4HXCG.js";
import "./chunk-4FEGON7M.js";
import "./chunk-VWYWOOPX.js";
import "./chunk-M5VHU5LK.js";
import "./chunk-CXFRNDG4.js";
import "./chunk-7QMMKGW4.js";
import {
  e,
  n2 as n,
  y
} from "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import "./chunk-MJXQTGI2.js";
import "./chunk-LIZHLHNA.js";
import "./chunk-BTUHYGXO.js";
import "./chunk-UA3YPL2R.js";
import "./chunk-HVKDYDPP.js";
import "./chunk-6QC7MLLS.js";
import {
  r,
  s,
  t
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/geometry/support/rotate.js
function i3(n3) {
  let e3 = 0, t2 = 0;
  const r4 = n3.length;
  let i4, o2 = n3[t2];
  for (t2 = 0; t2 < r4 - 1; t2++)
    i4 = n3[t2 + 1], e3 += (i4[0] - o2[0]) * (i4[1] + o2[1]), o2 = i4;
  return e3 >= 0;
}
function o(n3, e3, t2, r4) {
  const i4 = [];
  for (const o2 of n3) {
    const n4 = o2.slice(0);
    i4.push(n4);
    const s4 = e3 * (o2[0] - r4.x) - t2 * (o2[1] - r4.y) + r4.x, c = t2 * (o2[0] - r4.x) + e3 * (o2[1] - r4.y) + r4.y;
    n4[0] = s4, n4[1] = c;
  }
  return i4;
}
function s3(s4, c, a2) {
  const f2 = s4.spatialReference, m5 = c * Math.PI / 180, x = Math.cos(m5), p3 = Math.sin(m5);
  if ("xmin" in s4 && (a2 = a2 != null ? a2 : s4.center, s4 = new v({ spatialReference: f2, rings: [[[s4.xmin, s4.ymin], [s4.xmin, s4.ymax], [s4.xmax, s4.ymax], [s4.xmax, s4.ymin], [s4.xmin, s4.ymin]]] })), "paths" in s4) {
    a2 = a2 != null ? a2 : s4.extent.center;
    const n3 = [];
    for (const e3 of s4.paths)
      n3.push(o(e3, x, p3, a2));
    return new m({ spatialReference: f2, paths: n3 });
  }
  if ("rings" in s4) {
    a2 = a2 != null ? a2 : s4.extent.center;
    const e3 = [];
    for (const n3 of s4.rings) {
      const t2 = i3(n3), r4 = o(n3, x, p3, a2);
      i3(r4) !== t2 && r4.reverse(), e3.push(r4);
    }
    return new v({ spatialReference: f2, rings: e3 });
  }
  if ("x" in s4) {
    a2 = a2 != null ? a2 : s4;
    const n3 = new w({ x: x * (s4.x - a2.x) - p3 * (s4.y - a2.y) + a2.x, y: p3 * (s4.x - a2.x) + x * (s4.y - a2.y) + a2.y, spatialReference: f2 });
    return null != s4.z && (n3.z = s4.z), null != s4.m && (n3.m = s4.m), n3;
  }
  return "points" in s4 ? (a2 = a2 != null ? a2 : s4.extent.center, new u({ points: o(s4.points, x, p3, a2), spatialReference: f2 })) : null;
}

// node_modules/@arcgis/core/views/draw/support/Box.js
var L = class {
  constructor(t2, e3, i4, s4) {
    this.graphics = t2, this.mover = e3, this.dx = i4, this.dy = s4, this.type = "move-start";
  }
};
var z = class {
  constructor(t2, e3, i4, s4) {
    this.graphics = t2, this.mover = e3, this.dx = i4, this.dy = s4, this.type = "move";
  }
};
var Y = class {
  constructor(t2, e3, i4, s4) {
    this.graphics = t2, this.mover = e3, this.dx = i4, this.dy = s4, this.type = "move-stop";
  }
};
var N = class {
  constructor(t2, e3, i4) {
    this.graphics = t2, this.mover = e3, this.angle = i4, this.type = "rotate-start";
  }
};
var U = class {
  constructor(t2, e3, i4) {
    this.graphics = t2, this.mover = e3, this.angle = i4, this.type = "rotate";
  }
};
var A = class {
  constructor(t2, e3, i4) {
    this.graphics = t2, this.mover = e3, this.angle = i4, this.type = "rotate-stop";
  }
};
var P = class {
  constructor(t2, e3, i4, s4) {
    this.graphics = t2, this.mover = e3, this.xScale = i4, this.yScale = s4, this.type = "scale-start";
  }
};
var X = class {
  constructor(t2, e3, i4, s4) {
    this.graphics = t2, this.mover = e3, this.xScale = i4, this.yScale = s4, this.type = "scale";
  }
};
var D2 = class {
  constructor(t2, e3, i4, s4) {
    this.graphics = t2, this.mover = e3, this.xScale = i4, this.yScale = s4, this.type = "scale-stop";
  }
};
var V = h2.transformGraphics;
var F = { centerIndicator: new y2({ style: "cross", size: V.center.size, color: V.center.color }), fill: { default: new S({ color: V.fill.color, outline: { color: V.fill.outlineColor, join: "round", width: 1 } }), active: new S({ color: V.fill.stagedColor, outline: { color: V.fill.outlineColor, join: "round", style: "dash", width: 1 } }) }, handles: { default: new y2({ style: "square", size: V.vertex.size, color: V.vertex.color, outline: { color: V.vertex.outlineColor, width: 1 } }), hover: new y2({ style: "square", size: V.vertex.hoverSize, color: V.vertex.hoverColor, outline: { color: V.vertex.hoverOutlineColor, width: 1 } }) }, rotator: { default: new y2({ style: "circle", size: V.vertex.size, color: V.vertex.color, outline: { color: V.vertex.outlineColor, width: 1 } }), hover: new y2({ style: "circle", size: V.vertex.hoverSize, color: V.vertex.hoverColor, outline: { color: V.vertex.hoverOutlineColor, width: 1 } }) }, rotatorLine: new m2({ color: V.line.color, width: 1 }) };
var q = class extends n2.EventedAccessor {
  constructor(t2) {
    super(t2), this._activeHandleGraphic = null, this._graphicAttributes = { esriSketchTool: "box" }, this._mover = null, this._centerGraphic = null, this._backgroundGraphic = null, this._vertexGraphics = [], this._rotateHandleGraphic = null, this._rotateGraphicOffset = 20, this._angleOfRotation = 0, this._rotateLineGraphic = null, this._startInfo = null, this._tooltip = null, this._totalDx = 0, this._totalDy = 0, this._xScale = 1, this._yScale = 1, this.type = "box", this.callbacks = { onMoveStart() {
    }, onMove() {
    }, onMoveStop() {
    }, onScaleStart() {
    }, onScale() {
    }, onScaleStop() {
    }, onRotateStart() {
    }, onRotate() {
    }, onRotateStop() {
    }, onGraphicClick() {
    } }, this.enableMovement = true, this.enableRotation = true, this.enableScaling = true, this.graphics = [], this.highlightsEnabled = true, this.layer = null, this.preserveAspectRatio = false, this.showCenterGraphic = true, this.symbols = F, this.tooltipOptions = new p(), this.view = null, this._getBounds = (() => {
      const t3 = u2();
      return (e3, i4) => {
        e3[0] = Number.POSITIVE_INFINITY, e3[1] = Number.POSITIVE_INFINITY, e3[2] = Number.NEGATIVE_INFINITY, e3[3] = Number.NEGATIVE_INFINITY;
        for (const s4 of i4) {
          if (!s4)
            continue;
          let i5, r4, o2, a2;
          if ("point" === s4.type)
            i5 = o2 = s4.x, r4 = a2 = s4.y;
          else if ("multipoint" === s4.type) {
            const e4 = r2(s4);
            [i5, r4, o2, a2] = h(t3, [e4]);
          } else if ("extent" === s4.type)
            [i5, r4, o2, a2] = [s4.xmin, s4.ymin, s4.xmax, s4.ymax];
          else {
            const e4 = r2(s4);
            [i5, r4, o2, a2] = h(t3, e4);
          }
          e3[0] = Math.min(i5, e3[0]), e3[1] = Math.min(r4, e3[1]), e3[2] = Math.max(o2, e3[2]), e3[3] = Math.max(a2, e3[3]);
        }
        return e3;
      };
    })();
  }
  initialize() {
    const t2 = this.view;
    this._highlightHelper = new h4({ view: t2 }), this._tooltip = new m3({ view: t2 }), this._setup(), this.addHandles([f(() => t2 == null ? void 0 : t2.ready, () => {
      const { layer: t3, view: e3 } = this;
      e2(e3, t3);
    }, { once: true, initial: true }), l(() => this.preserveAspectRatio, () => {
      this._activeHandleGraphic && (this._scaleGraphic(this._activeHandleGraphic), this._updateGraphics(), this._updateTooltip(this._activeHandleGraphic));
    }), l(() => t2 == null ? void 0 : t2.scale, () => {
      this._updateRotateGraphic(), this._updateRotateLineGraphic();
    }), l(() => this.graphics, () => this.refresh()), l(() => this.layer, (t3, e3) => {
      e3 && this._resetGraphics(e3), this.refresh();
    }), l(() => this.highlightsEnabled, () => {
      var _a;
      (_a = this._highlightHelper) == null ? void 0 : _a.removeAll(), this._setUpHighlights();
    }), l(() => this.tooltipOptions.enabled, (t3) => {
      this._tooltip = t3 ? new m3({ view: this.view }) : s(this._tooltip);
    }, w2), this.on("move-start", (t3) => {
      var _a, _b;
      return (_b = (_a = this.callbacks) == null ? void 0 : _a.onMoveStart) == null ? void 0 : _b.call(_a, t3);
    }), this.on("move", (t3) => {
      var _a, _b;
      return (_b = (_a = this.callbacks) == null ? void 0 : _a.onMove) == null ? void 0 : _b.call(_a, t3);
    }), this.on("move-stop", (t3) => {
      var _a, _b;
      return (_b = (_a = this.callbacks) == null ? void 0 : _a.onMoveStop) == null ? void 0 : _b.call(_a, t3);
    }), this.on("rotate-start", (t3) => {
      var _a, _b;
      return (_b = (_a = this.callbacks) == null ? void 0 : _a.onRotateStart) == null ? void 0 : _b.call(_a, t3);
    }), this.on("rotate", (t3) => {
      var _a, _b;
      return (_b = (_a = this.callbacks) == null ? void 0 : _a.onRotate) == null ? void 0 : _b.call(_a, t3);
    }), this.on("rotate-stop", (t3) => {
      var _a, _b;
      return (_b = (_a = this.callbacks) == null ? void 0 : _a.onRotateStop) == null ? void 0 : _b.call(_a, t3);
    }), this.on("scale-start", (t3) => {
      var _a, _b;
      return (_b = (_a = this.callbacks) == null ? void 0 : _a.onScaleStart) == null ? void 0 : _b.call(_a, t3);
    }), this.on("scale", (t3) => {
      var _a, _b;
      return (_b = (_a = this.callbacks) == null ? void 0 : _a.onScale) == null ? void 0 : _b.call(_a, t3);
    }), this.on("scale-stop", (t3) => {
      var _a, _b;
      return (_b = (_a = this.callbacks) == null ? void 0 : _a.onScaleStop) == null ? void 0 : _b.call(_a, t3);
    })]);
  }
  destroy() {
    this._reset(), this._tooltip = s(this._tooltip);
  }
  get state() {
    var _a, _b;
    const t2 = (_b = (_a = this.view) == null ? void 0 : _a.ready) != null ? _b : false, e3 = this.graphics.length && this.layer;
    return t2 && e3 ? "active" : t2 ? "ready" : "disabled";
  }
  isUIGraphic(t2) {
    return this._vertexGraphics.includes(t2) || t2 === this._backgroundGraphic || t2 === this._centerGraphic || t2 === this._rotateHandleGraphic || t2 === this._rotateLineGraphic;
  }
  move(t2, e3) {
    if (this._mover && this.graphics.length) {
      for (const i4 of this.graphics) {
        const s4 = i4.geometry, r4 = s2(s4, t2, e3, this.view);
        i4.geometry = r4;
      }
      this.refresh(), this.emit("move-stop", new Y(this.graphics, null, t2, e3));
    }
  }
  scale(t2, e3) {
    if (this._mover && this.graphics.length) {
      for (const i4 of this.graphics) {
        const s4 = i4.geometry, r4 = i(s4, t2, e3);
        i4.geometry = r4;
      }
      this.refresh(), this.emit("scale-stop", new D2(this.graphics, null, t2, e3));
    }
  }
  rotate(t2, e3) {
    if (this._mover && this.graphics.length) {
      if (!e3) {
        const t3 = this._vertexGraphics[1].geometry.x, i4 = this._vertexGraphics[3].geometry.y;
        e3 = new w(t3, i4, this.view.spatialReference);
      }
      for (const i4 of this.graphics) {
        const s4 = i4.geometry, r4 = s3(s4, t2, e3);
        i4.geometry = r4;
      }
      this.refresh(), this.emit("rotate-stop", new A(this.graphics, null, t2));
    }
  }
  refresh() {
    this._reset(), this._setup();
  }
  reset() {
    this.graphics = [];
  }
  _setup() {
    "active" === this.state && (this._setUpHighlights(), this._setupGraphics(), this._setupMover(), this._updateGraphics());
  }
  _reset() {
    this._highlightHelper.removeAll(), this._resetGraphicStateVars(), this._resetGraphics(), this._updateTooltip(), this._mover && this._mover.destroy(), this._mover = null, this.view.cursor = "default";
  }
  _resetGraphicStateVars() {
    this._startInfo = null, this._activeHandleGraphic = null, this._totalDx = 0, this._totalDy = 0, this._xScale = 1, this._yScale = 1, this._angleOfRotation = 0;
  }
  _resetGraphics(t2) {
    (t2 = t2 || this.layer) && (t2.removeMany(this._vertexGraphics), t2.remove(this._backgroundGraphic), t2.remove(this._centerGraphic), t2.remove(this._rotateHandleGraphic), t2.remove(this._rotateLineGraphic)), this._vertexGraphics = [], this._backgroundGraphic = null, this._centerGraphic = null, this._rotateHandleGraphic = null, this._rotateLineGraphic = null;
  }
  _setupMover() {
    let t2 = [];
    this.enableScaling && (t2 = t2.concat(this._vertexGraphics)), this.enableMovement && (t2 = t2.concat(this.graphics, this._backgroundGraphic)), this.enableRotation && t2.push(this._rotateHandleGraphic), this.showCenterGraphic && t2.push(this._centerGraphic), this._mover = new D({ enableMoveAllGraphics: false, highlightsEnabled: false, indicatorsEnabled: false, view: this.view, graphics: t2, callbacks: { onGraphicClick: (t3) => this._onGraphicClickCallback(t3), onGraphicMoveStart: (t3) => this._onGraphicMoveStartCallback(t3), onGraphicMove: (t3) => this._onGraphicMoveCallback(t3), onGraphicMoveStop: (t3) => this._onGraphicMoveStopCallback(t3), onGraphicPointerOver: (t3) => this._onGraphicPointerOverCallback(t3), onGraphicPointerOut: (t3) => this._onGraphicPointerOutCallback(t3) } });
  }
  _getStartInfo(t2) {
    const [e3, i4, s4, r4] = this._getBoxBounds(u2()), o2 = Math.abs(s4 - e3), a2 = Math.abs(r4 - i4), h5 = (s4 + e3) / 2, c = (r4 + i4) / 2, { x: n3, y: l2 } = t2.geometry;
    return { width: o2, height: a2, centerX: h5, centerY: c, startX: n3, startY: l2, graphicInfos: this._getGraphicInfos(), box: this._backgroundGraphic.geometry, rotate: this._rotateHandleGraphic.geometry };
  }
  _getGraphicInfos() {
    return this.graphics.map((t2) => this._getGraphicInfo(t2));
  }
  _getGraphicInfo(t2) {
    const e3 = t2.geometry, [i4, s4, r4, o2] = this._getBounds(u2(), [e3]);
    return { width: Math.abs(r4 - i4), height: Math.abs(o2 - s4), centerX: (r4 + i4) / 2, centerY: (o2 + s4) / 2, geometry: e3 };
  }
  _onGraphicClickCallback(t2) {
    t2.viewEvent.stopPropagation(), this.emit("graphic-click", t2), this.callbacks.onGraphicClick && this.callbacks.onGraphicClick(t2);
  }
  _onGraphicMoveStartCallback(t2) {
    const { _angleOfRotation: e3, _xScale: i4, _yScale: s4, _backgroundGraphic: r4, _vertexGraphics: o2, _rotateHandleGraphic: a2, symbols: h5 } = this, c = t2.graphic;
    this._resetGraphicStateVars(), this._hideGraphicsBeforeUpdate(), r4.symbol = h5.fill.active, this._startInfo = this._getStartInfo(c), this._updateTooltip(c, t2.viewEvent), c === a2 ? (this.view.cursor = "grabbing", this.emit("rotate-start", new N(this.graphics, c, e3))) : o2.includes(c) ? (this._activeHandleGraphic = c, this.emit("scale-start", new P(this.graphics, c, i4, s4))) : this.emit("move-start", new L(this.graphics, c, t2.dx, t2.dy));
  }
  _onGraphicMoveCallback(t2) {
    const e3 = t2.graphic;
    if (this._startInfo)
      if (this._vertexGraphics.includes(e3))
        this._scaleGraphic(e3), this._updateTooltip(e3, t2.viewEvent), this.emit("scale", new X(this.graphics, e3, this._xScale, this._yScale));
      else if (e3 === this._rotateHandleGraphic)
        this._rotateGraphic(e3), this._updateTooltip(e3, t2.viewEvent), this.emit("rotate", new U(this.graphics, e3, this._angleOfRotation));
      else {
        const { dx: i4, dy: s4 } = t2;
        this._totalDx += i4, this._totalDy += s4, this._moveGraphic(e3, i4, s4), this._updateTooltip(e3, t2.viewEvent), this.emit("move", new z(this.graphics, e3, i4, s4));
      }
  }
  _onGraphicMoveStopCallback(t2) {
    const e3 = t2.graphic;
    if (!this._startInfo)
      return void this.refresh();
    const { _angleOfRotation: i4, _totalDx: s4, _totalDy: r4, _xScale: o2, _yScale: a2, _vertexGraphics: h5, _rotateHandleGraphic: c } = this;
    this.refresh(), e3 === c ? (this.view.cursor = "pointer", this.emit("rotate-stop", new A(this.graphics, e3, i4))) : h5.includes(e3) ? this.emit("scale-stop", new D2(this.graphics, e3, o2, a2)) : this.emit("move-stop", new Y(this.graphics, e3, s4, r4));
  }
  _onGraphicPointerOverCallback(t2) {
    const { _backgroundGraphic: e3, _vertexGraphics: i4, graphics: s4, _rotateHandleGraphic: r4, symbols: o2, view: a2 } = this, h5 = t2.graphic;
    if (h5 === r4)
      return r4.symbol = o2.rotator.hover, a2.cursor = "pointer", void this._updateTooltip(h5);
    if (s4.includes(h5) || h5 === e3)
      return void (a2.cursor = "move");
    if (!i4.includes(h5))
      return void (a2.cursor = "pointer");
    this._updateTooltip(h5), t2.graphic.symbol = o2.handles.hover;
    const c = a2.rotation;
    let n3, l2 = t2.index;
    switch (l2 < 8 && (c >= 0 && c < 45 ? l2 %= 8 : l2 = c >= 45 && c < 90 ? (l2 + 1) % 8 : c >= 90 && c < 135 ? (l2 + 2) % 8 : c >= 135 && c < 180 ? (l2 + 3) % 8 : c >= 180 && c < 225 ? (l2 + 4) % 8 : c >= 225 && c < 270 ? (l2 + 5) % 8 : c >= 270 && c < 315 ? (l2 + 6) % 8 : (l2 + 7) % 8), l2) {
      case 0:
      case 4:
        n3 = "nwse-resize";
        break;
      case 1:
      case 5:
        n3 = "ns-resize";
        break;
      case 2:
      case 6:
        n3 = "nesw-resize";
        break;
      case 3:
      case 7:
        n3 = "ew-resize";
        break;
      default:
        n3 = "pointer";
    }
    a2.cursor = n3;
  }
  _onGraphicPointerOutCallback(t2) {
    const { _vertexGraphics: e3, _rotateHandleGraphic: i4, symbols: s4, view: r4 } = this;
    t2.graphic === i4 ? i4.symbol = s4.rotator.default : e3.includes(t2.graphic) && (t2.graphic.symbol = s4.handles.default), r4.cursor = "default", this._updateTooltip();
  }
  _scaleGraphic(t2) {
    const { _startInfo: e3, _vertexGraphics: i4, preserveAspectRatio: s4, view: r4 } = this, { centerX: o2, centerY: a2, startX: h5, startY: c } = e3, { resolution: n3, transform: l2 } = r4.state, p3 = i4.indexOf(t2);
    1 !== p3 && 5 !== p3 || this._updateX(t2, o2), 3 !== p3 && 7 !== p3 || this._updateY(t2, a2);
    const { x: _, y: d } = t2.geometry, g2 = l2[0] * _ + l2[2] * d + l2[4], u3 = l2[1] * _ + l2[3] * d + l2[5], m5 = e3.graphicInfos.map((t3) => t3.geometry);
    if (s4) {
      const t3 = l2[0] * o2 + l2[2] * a2 + l2[4], e4 = l2[1] * o2 + l2[3] * a2 + l2[5], i5 = l2[0] * h5 + l2[2] * c + l2[4], s5 = l2[1] * h5 + l2[3] * c + l2[5];
      this._xScale = this._yScale = a(t3, e4, i5, s5, g2, u3);
      for (const r5 of m5) {
        const t4 = m5.indexOf(r5);
        this.graphics[t4].geometry = i(r5, this._xScale, this._yScale, [o2, a2]);
      }
      this._updateBackgroundGraphic();
    } else {
      const { width: t3, height: i5 } = e3;
      let s5 = _ - h5, l3 = c - d;
      if (1 === p3 || 5 === p3 ? s5 = 0 : 3 !== p3 && 7 !== p3 || (l3 = 0), 0 === s5 && 0 === l3)
        return;
      const g3 = t3 + (h5 > o2 ? s5 : -1 * s5), u4 = i5 + (c < a2 ? l3 : -1 * l3), v2 = o2 + s5 / 2, y3 = a2 + l3 / 2;
      this._xScale = g3 / t3 || 1, this._yScale = u4 / i5 || 1, 1 === p3 || 5 === p3 ? this._xScale = 1 : 3 !== p3 && 7 !== p3 || (this._yScale = 1);
      const b = (v2 - o2) / n3, w3 = (y3 - a2) / n3, x = i(e3.box, this._xScale, this._yScale);
      this._backgroundGraphic.geometry = s2(x, b, w3, r4, true);
      const { centerX: S2, centerY: k } = this._getGraphicInfo(this._backgroundGraphic), R = (S2 - o2) / n3, I = -1 * (k - a2) / n3;
      for (const e4 of m5) {
        const t4 = m5.indexOf(e4), i6 = i(e4, this._xScale, this._yScale, [o2, a2]);
        this.graphics[t4].geometry = s2(i6, R, I, r4, true);
      }
      this._centerGraphic.geometry = new w(S2, k, r4.spatialReference);
    }
  }
  _rotateGraphic(t2) {
    const { centerX: e3, centerY: i4, startX: s4, startY: r4, box: o2, rotate: a2 } = this._startInfo, h5 = new w(s4, r4, this.view.spatialReference), c = new w(e3, i4, this.view.spatialReference), n3 = t2.geometry;
    this._angleOfRotation = m4(h5, n3, c);
    const l2 = this._startInfo.graphicInfos.map((t3) => t3.geometry);
    for (const p3 of l2) {
      const t3 = l2.indexOf(p3), e4 = s3(p3, this._angleOfRotation, c);
      this.graphics[t3].geometry = e4;
    }
    this._backgroundGraphic.geometry = s3(o2, this._angleOfRotation, c), this._rotateHandleGraphic.geometry = s3(a2, this._angleOfRotation, c);
  }
  _moveGraphic(t2, e3, i4) {
    if (this.graphics.includes(t2)) {
      const s4 = this._backgroundGraphic.geometry;
      this._backgroundGraphic.geometry = s2(s4, e3, i4, this.view);
      for (const r4 of this.graphics)
        r4 !== t2 && (r4.geometry = s2(r4.geometry, e3, i4, this.view));
    } else if (t2 === this._centerGraphic) {
      const t3 = this._backgroundGraphic.geometry;
      this._backgroundGraphic.geometry = s2(t3, e3, i4, this.view);
    }
    if (t2 === this._backgroundGraphic || t2 === this._centerGraphic)
      for (const s4 of this.graphics)
        s4.geometry = s2(s4.geometry, e3, i4, this.view);
  }
  _setUpHighlights() {
    var _a;
    this.highlightsEnabled && this.graphics.length && ((_a = this._highlightHelper) == null ? void 0 : _a.add(this.graphics));
  }
  _setupGraphics() {
    const { _graphicAttributes: t2, symbols: i4 } = this;
    this._centerGraphic = new g(null, i4.centerIndicator, t2), this.showCenterGraphic && this.layer.add(this._centerGraphic), this._backgroundGraphic = new g(null, i4.fill.default, t2), this.layer.add(this._backgroundGraphic), this._rotateLineGraphic = new g(null, i4.rotatorLine, t2), this._rotateHandleGraphic = new g(null, i4.rotator.default, t2), this.enableRotation && !this._hasExtentGraphic() && this.layer.addMany([this._rotateLineGraphic, this._rotateHandleGraphic]);
    for (let s4 = 0; s4 < 8; s4++)
      this._vertexGraphics.push(new g(null, i4.handles.default, t2));
    this.enableScaling && this.layer.addMany(this._vertexGraphics);
  }
  _updateGraphics() {
    this._updateBackgroundGraphic(), this._updateHandleGraphics(), this._updateCenterGraphic(), this._updateRotateGraphic(), this._updateRotateLineGraphic();
  }
  _hideGraphicsBeforeUpdate() {
    this._centerGraphic.visible = false, this._rotateHandleGraphic.visible = false, this._rotateLineGraphic.visible = false, this._vertexGraphics.forEach((t2) => t2.visible = false);
  }
  _updateHandleGraphics() {
    const t2 = this._getCoordinates(true);
    this._vertexGraphics.forEach((e3, i4) => {
      const [s4, r4] = t2[i4];
      this._updateXY(e3, s4, r4);
    });
  }
  _updateBackgroundGraphic() {
    const t2 = this._getCoordinates();
    this._backgroundGraphic.geometry = new v({ rings: t2, spatialReference: this.view.spatialReference });
  }
  _updateCenterGraphic() {
    const [t2, e3, i4, s4] = this._getBoxBounds(u2()), r4 = (i4 + t2) / 2, o2 = (s4 + e3) / 2;
    this._centerGraphic.geometry = new w(r4, o2, this.view.spatialReference);
  }
  _updateRotateGraphic() {
    if (!this._vertexGraphics.length)
      return;
    const { x: t2, y: e3 } = this._vertexGraphics[1].geometry, i4 = e3 + this.view.state.resolution * this._rotateGraphicOffset;
    this._rotateHandleGraphic.geometry = new w(t2, i4, this.view.spatialReference);
  }
  _updateRotateLineGraphic() {
    if (!this._vertexGraphics.length || !this._rotateHandleGraphic || !this._rotateHandleGraphic.geometry)
      return;
    const t2 = this._vertexGraphics[1].geometry, e3 = this._rotateHandleGraphic.geometry;
    this._rotateLineGraphic.geometry = new m({ paths: [[t2.x, t2.y], [e3.x, e3.y]], spatialReference: this.view.spatialReference });
  }
  _updateXY(t2, e3, i4) {
    t2.geometry = new w(e3, i4, this.view.spatialReference);
  }
  _updateX(t2, e3) {
    const i4 = t2.geometry.y;
    t2.geometry = new w(e3, i4, this.view.spatialReference);
  }
  _updateY(t2, e3) {
    const i4 = t2.geometry.x;
    t2.geometry = new w(i4, e3, this.view.spatialReference);
  }
  _hasExtentGraphic() {
    return this.graphics.some((t2) => t2 && r(t2.geometry) && "extent" === t2.geometry.type);
  }
  _getBoxBounds(t2) {
    const e3 = this.graphics.map((t3) => t3.geometry);
    return this._getBounds(t2, e3);
  }
  _getCoordinates(t2) {
    const [e3, i4, s4, r4] = this._getBoxBounds(u2());
    if (t2) {
      const t3 = (e3 + s4) / 2, o2 = (r4 + i4) / 2;
      return [[e3, r4], [t3, r4], [s4, r4], [s4, o2], [s4, i4], [t3, i4], [e3, i4], [e3, o2]];
    }
    return [[e3, r4], [s4, r4], [s4, i4], [e3, i4]];
  }
  _updateTooltip(t2, e3) {
    if (t(this._tooltip))
      return;
    if (!t2)
      return void this._tooltip.clear();
    const { _backgroundGraphic: i4, graphics: s4, _vertexGraphics: r4, _rotateHandleGraphic: a2 } = this;
    t2 === a2 ? this._updateRotateTooltip() : r4.includes(t2) ? this._updateScaleTooltip() : (s4.includes(t2) || t2 === i4) && this._updateMoveTooltip(e3);
  }
  _updateRotateTooltip() {
    t(this._tooltip) || (this._tooltip.info = new i2({ tooltipOptions: this.tooltipOptions, angle: -this._angleOfRotation }));
  }
  _updateScaleTooltip() {
    const { _tooltip: t2, _xScale: e3, _yScale: i4, tooltipOptions: s4, view: r4 } = this;
    if (t(t2))
      return;
    const a2 = r4.spatialReference, h5 = this._getCoordinates(), c = new w(h5[0][0], h5[0][1], a2), n3 = new w(h5[1][0], h5[1][1], a2), l2 = new w(h5[2][0], h5[2][1], a2), p3 = h3(c, n3), _ = h3(n3, l2);
    if (t(p3) || t(_))
      return;
    const d = Math.abs(e3), g2 = Math.abs(i4);
    t2.info = new p2({ tooltipOptions: s4, xScale: d, yScale: g2, xSize: p3, ySize: _ });
  }
  _updateMoveTooltip(t2) {
    const { _tooltip: e3, tooltipOptions: i4, view: s4 } = this;
    if (t(e3))
      return;
    const h5 = new r3({ tooltipOptions: i4 });
    if (t2) {
      const { x: e4, y: i5 } = t2.origin, o2 = s4.toMap(t2), c = s4.toMap({ x: e4, y: i5 }), n3 = h3(c, o2);
      h5.distance = r(n3) ? n3 : j;
    }
    e3.info = h5;
  }
};
e([y()], q.prototype, "_tooltip", void 0), e([y({ readOnly: true })], q.prototype, "type", void 0), e([y()], q.prototype, "callbacks", void 0), e([y()], q.prototype, "enableMovement", void 0), e([y()], q.prototype, "enableRotation", void 0), e([y()], q.prototype, "enableScaling", void 0), e([y()], q.prototype, "graphics", void 0), e([y()], q.prototype, "highlightsEnabled", void 0), e([y()], q.prototype, "layer", void 0), e([y()], q.prototype, "preserveAspectRatio", void 0), e([y()], q.prototype, "showCenterGraphic", void 0), e([y({ readOnly: true })], q.prototype, "state", null), e([y({ value: F, cast(t2) {
  const { centerIndicator: e3 = F.centerIndicator, fill: i4 = F.fill, handles: s4 = F.handles, rotator: r4 = F.rotator, rotatorLine: o2 = F.rotatorLine } = t2 || {};
  return { centerIndicator: e3, fill: i4, handles: s4, rotator: r4, rotatorLine: o2 };
} })], q.prototype, "symbols", void 0), e([y({ type: p })], q.prototype, "tooltipOptions", void 0), e([y({ constructOnly: true })], q.prototype, "view", void 0), q = e([n("esri.views.draw.support.Box")], q);
var J = q;
export {
  J as default
};
//# sourceMappingURL=Box-N32QQGD3.js.map
