import {
  D as D2,
  E,
  F,
  G as G2,
  I,
  L,
  M as M2,
  M2 as M3,
  O as O2,
  P,
  T,
  U as U2,
  h as h2,
  i as i4,
  j as j5,
  v as v3,
  x as x3,
  y as y5,
  z
} from "./chunk-6CR2FXC5.js";
import {
  e as e2
} from "./chunk-65SMURZR.js";
import {
  i as i3
} from "./chunk-VGNX3TFX.js";
import {
  c as c3
} from "./chunk-TZTENXCS.js";
import {
  n as n6,
  p as p6
} from "./chunk-RQPDRERN.js";
import {
  n as n7
} from "./chunk-6BYMCM5A.js";
import {
  p as p7
} from "./chunk-BR5PSTJI.js";
import {
  i as i5,
  j as j6
} from "./chunk-2T7LFOXQ.js";
import {
  s as s6
} from "./chunk-LZKCWJVH.js";
import {
  a as a3
} from "./chunk-LPRQBCQL.js";
import {
  v as v4
} from "./chunk-QR4K7IDQ.js";
import {
  o as o4
} from "./chunk-7N45W3EA.js";
import {
  p as p8
} from "./chunk-MQVQXXLV.js";
import {
  p as p5
} from "./chunk-HAVCYBU2.js";
import {
  a as a2
} from "./chunk-4HXPP4EA.js";
import {
  i as i2
} from "./chunk-M3NPSHCI.js";
import {
  v as v5
} from "./chunk-SBKKCBDN.js";
import {
  K,
  x as x2
} from "./chunk-AMLHWG76.js";
import {
  r as r3
} from "./chunk-ZJZBAYFU.js";
import {
  v as v2
} from "./chunk-G3HEFWHV.js";
import {
  p as p2
} from "./chunk-3GENFQBG.js";
import {
  c as c2
} from "./chunk-FX6IXM55.js";
import {
  O
} from "./chunk-QFFP6A5Q.js";
import {
  t as t4
} from "./chunk-O5PXWHV2.js";
import {
  h,
  m as m4,
  y as y4
} from "./chunk-J5VTDQTQ.js";
import {
  t as t6
} from "./chunk-YF2CRSQX.js";
import {
  n as n5,
  o as o3,
  p as p3,
  p2 as p4
} from "./chunk-JP3KAUQB.js";
import {
  C
} from "./chunk-PDEVQZ7U.js";
import {
  D,
  c,
  j as j3,
  l,
  m as m5,
  p,
  u
} from "./chunk-YGVY4EIZ.js";
import {
  x
} from "./chunk-UK3I5WXR.js";
import {
  u as u2
} from "./chunk-ZL4T4NIV.js";
import {
  n as n3
} from "./chunk-TDV3ZXCQ.js";
import {
  t as t5
} from "./chunk-XJCUKRCO.js";
import {
  b as b2
} from "./chunk-SOEQPPQP.js";
import {
  a
} from "./chunk-REIQNAQW.js";
import {
  g
} from "./chunk-J6LQZWZI.js";
import {
  M,
  j3 as j4
} from "./chunk-OD3FDQCI.js";
import {
  n as n4
} from "./chunk-BLJKKR5D.js";
import {
  k as k2
} from "./chunk-FUPLN7UM.js";
import {
  F as F2,
  x as x4
} from "./chunk-376OPXM4.js";
import {
  m as m3
} from "./chunk-6O43OEU5.js";
import {
  i
} from "./chunk-KXVMEIWT.js";
import {
  j as j2,
  n as n2
} from "./chunk-UDND2Z3V.js";
import {
  t as t3
} from "./chunk-B356PXLT.js";
import {
  v2 as v
} from "./chunk-3MNMDUQZ.js";
import {
  w2
} from "./chunk-UWG37XSU.js";
import {
  k2 as k
} from "./chunk-LNZAOBFW.js";
import {
  r as r2
} from "./chunk-HLM6QCL2.js";
import {
  o as o2
} from "./chunk-RXYULINL.js";
import {
  m as m2
} from "./chunk-ZWJJTUFL.js";
import {
  U
} from "./chunk-DMI7A7TC.js";
import {
  G,
  j
} from "./chunk-KAN4HXCG.js";
import {
  s as s5
} from "./chunk-VWYWOOPX.js";
import {
  e,
  m,
  n2 as n,
  s4,
  t5 as t2,
  y as y2
} from "./chunk-OOLCFNXJ.js";
import {
  w,
  y as y3
} from "./chunk-MJXQTGI2.js";
import {
  s as s3
} from "./chunk-LIZHLHNA.js";
import {
  b
} from "./chunk-BTUHYGXO.js";
import {
  s2
} from "./chunk-UA3YPL2R.js";
import {
  has,
  o,
  y
} from "./chunk-HVKDYDPP.js";
import {
  r,
  s,
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/layers/graphics/sources/MemorySource.js
var b3 = 0;
var T2 = "esri.layers.graphics.sources.MemorySource";
var F3 = s2.getLogger(T2);
var G3 = class extends m3.LoadableMixin(m2(a(j2))) {
  constructor(e4) {
    super(e4), this._idToClientGraphic = null, this.type = "memory";
  }
  load(e4) {
    const t7 = r(e4) ? e4.signal : null;
    return this.addResolvingPromise(this._startWorker(t7)), Promise.resolve(this);
  }
  destroy() {
    var _a;
    (_a = this._connection) == null ? void 0 : _a.close(), this._connection = null;
  }
  get _workerGeometryType() {
    var _a;
    const e4 = (_a = this.layer) == null ? void 0 : _a.geometryType;
    return e4 ? this._geometryTypeRequiresClientGraphicMapping(e4) ? "polygon" : e4 : null;
  }
  applyEdits(e4) {
    return this.load().then(() => this._applyEdits(e4));
  }
  openPorts() {
    return this.load().then(() => this._connection.openPorts());
  }
  async queryFeatures(e4, t7 = {}) {
    await this.load(t7);
    const r4 = await this._connection.invoke("queryFeatures", e4 ? e4.toJSON() : null, t7);
    r3(e4, this.layer.spatialReference, r4);
    const s7 = x.fromJSON(r4);
    if (!this._requiresClientGraphicMapping())
      return s7;
    const o6 = this.layer.objectIdField;
    for (const i7 of s7.features) {
      const e5 = i7.attributes[o6], t8 = this._idToClientGraphic.get(e5);
      t8 && (i7.geometry = t8.geometry);
    }
    return s7.geometryType = this.layer.geometryType, s7;
  }
  async queryFeaturesJSON(e4, t7 = {}) {
    if (this._requiresClientGraphicMapping())
      throw new s3("query-features-json:unsupported", "Cannot query in JSON format for client only geometry types (mesh and extent)");
    await this.load(t7);
    const r4 = await this._connection.invoke("queryFeatures", e4 ? e4.toJSON() : null, t7);
    return r3(e4, this.layer.spatialReference, r4), r4;
  }
  queryFeatureCount(e4, t7 = {}) {
    return this.load(t7).then(() => this._connection.invoke("queryFeatureCount", e4 ? e4.toJSON() : null, t7));
  }
  queryObjectIds(e4, t7 = {}) {
    return this.load(t7).then(() => this._connection.invoke("queryObjectIds", e4 ? e4.toJSON() : null, t7));
  }
  queryExtent(e4, t7 = {}) {
    return this.load(t7).then(() => this._connection.invoke("queryExtent", e4 ? e4.toJSON() : null, t7)).then((e5) => ({ count: e5.count, extent: w2.fromJSON(e5.extent) }));
  }
  querySnapping(e4, t7 = {}) {
    return this.load(t7).then(() => this._connection.invoke("querySnapping", e4, t7));
  }
  async _applyEdits(e4) {
    if (!this._connection)
      throw new s3("feature-layer-source:edit-failure", "Memory source not loaded");
    const t7 = this.layer.objectIdField;
    let r4 = null;
    const o6 = [], i7 = [];
    await Promise.all([this._prepareClientMapping(e4.addFeatures, null), this._prepareClientMapping(e4.updateFeatures, null)]);
    const n8 = (e5) => "objectId" in e5 && null != e5.objectId ? e5.objectId : "attributes" in e5 && null != e5.attributes[t7] ? e5.attributes[t7] : null;
    if (e4.addFeatures && (r4 = this._prepareAddFeatures(e4.addFeatures)), e4.deleteFeatures)
      for (const s7 of e4.deleteFeatures) {
        const e5 = n8(s7);
        null != e5 && o6.push(e5);
      }
    const a4 = e4.updateFeatures && this._idToClientGraphic ? /* @__PURE__ */ new Map() : null;
    if (e4.updateFeatures) {
      for (const s7 of e4.updateFeatures)
        if (i7.push(this._serializeFeature(s7)), a4) {
          const e5 = n8(s7);
          null != e5 && a4.set(e5, s7);
        }
    }
    i2(r4 ? r4.features : null, i7, this.layer.spatialReference);
    const { fullExtent: l2, featureEditResults: u4 } = await this._connection.invoke("applyEdits", { adds: r4 ? r4.features : [], updates: i7, deletes: o6 });
    return this.fullExtent = l2, r4 && r4.finish(u4.uidToObjectId), this._updateClientGraphicIds(a4, u4), this._createEditsResult(u4);
  }
  async _prepareClientMapping(e4, t7) {
    if ("mesh" !== this._layerOrSourceGeometryType || t(e4))
      return;
    const r4 = [];
    for (const { geometry: s7 } of e4)
      !r(s7) || "mesh" !== s7.type || s7.hasExtent || s7.loaded || r4.push(s7.load({ signal: t7 }));
    r4.length && await Promise.all(r4);
  }
  _updateClientGraphicIds(e4, t7) {
    if (this._idToClientGraphic) {
      if (e4)
        for (const r4 of t7.updateResults) {
          if (!r4.success)
            continue;
          const t8 = e4.get(r4.objectId);
          null != t8 && this._addIdToClientGraphic(t8);
        }
      for (const e5 of t7.deleteResults)
        e5.success && this._idToClientGraphic.delete(e5.objectId);
    }
  }
  _createEditsResult(e4) {
    return { addFeatureResults: e4.addResults ? e4.addResults.map(this._createFeatureEditResult, this) : [], updateFeatureResults: e4.updateResults ? e4.updateResults.map(this._createFeatureEditResult, this) : [], deleteFeatureResults: e4.deleteResults ? e4.deleteResults.map(this._createFeatureEditResult, this) : [], addAttachmentResults: [], updateAttachmentResults: [], deleteAttachmentResults: [] };
  }
  _createFeatureEditResult(e4) {
    const t7 = true === e4.success ? null : e4.error || { code: void 0, description: void 0 };
    return { objectId: e4.objectId, globalId: e4.globalId, error: t7 ? new s3("feature-layer-source:edit-failure", t7.description, { code: t7.code }) : null };
  }
  _prepareAddFeatures(e4) {
    const t7 = /* @__PURE__ */ new Map(), r4 = new Array(e4.length);
    let s7 = null;
    for (let i7 = 0; i7 < e4.length; i7++) {
      const o7 = e4[i7], n8 = this._serializeFeature(o7);
      !s7 && r(o7.geometry) && (s7 = o7.geometry.type), r4[i7] = n8, t7.set(`${n8.uid}`, o7);
    }
    const o6 = this;
    return { features: r4, inferredGeometryType: s7, finish(e5) {
      const r5 = o6.sourceJSON.objectIdField;
      for (const s8 in e5) {
        const i7 = e5[s8], n8 = t7.get(s8);
        n8 && (n8.attributes || (n8.attributes = {}), -1 === i7 ? delete n8.attributes[r5] : n8.attributes[r5] = i7, o6._addIdToClientGraphic(n8));
      }
    } };
  }
  _addIdToClientGraphic(e4) {
    if (!this._idToClientGraphic)
      return;
    const t7 = this.sourceJSON.objectIdField, r4 = e4.attributes && e4.attributes[t7];
    null != r4 && this._idToClientGraphic.set(r4, e4);
  }
  get _layerOrSourceGeometryType() {
    var _a, _b, _c;
    return (_c = (_a = this.layer) == null ? void 0 : _a.geometryType) != null ? _c : (_b = this.sourceJSON) == null ? void 0 : _b.geometryType;
  }
  _requiresClientGraphicMapping() {
    return this._geometryTypeRequiresClientGraphicMapping(this._layerOrSourceGeometryType);
  }
  _geometryRequiresClientGraphicMapping(e4) {
    return this._geometryTypeRequiresClientGraphicMapping(e4.type);
  }
  _geometryTypeRequiresClientGraphicMapping(e4) {
    return "mesh" === e4 || "multipatch" === e4 || "extent" === e4;
  }
  _serializeFeature(e4) {
    const { attributes: t7 } = e4, r4 = this._geometryForSerialization(e4), s7 = (b3++).toString();
    return r4 ? { uid: s7, geometry: r4.toJSON(), attributes: t7 } : { uid: s7, attributes: t7 };
  }
  _geometryForSerialization(e4) {
    const { geometry: t7 } = e4;
    if (t(t7))
      return null;
    if (this._geometryRequiresClientGraphicMapping(t7)) {
      return t7.extent ? v.fromExtent(t7.extent) : null;
    }
    return t7;
  }
  async _startWorker(e4) {
    this._connection = await u2("MemorySourceWorker", { strategy: has("feature-layers-workers") ? "dedicated" : "local", signal: e4 });
    const { fields: t7, spatialReference: r4, objectIdField: s7, hasM: o6, hasZ: i7, timeInfo: n8 } = this.layer, a4 = "defaults" === this.layer.originOf("spatialReference");
    await this._prepareClientMapping(this.items, e4);
    const l2 = this._prepareAddFeatures(this.items);
    this.handles.add(this.on("before-changes", (e5) => {
      F3.error("Source modifications will not propagate after layer has been loaded. Please use .applyEdits() instead"), e5.preventDefault();
    }));
    const u4 = { features: l2.features, fields: t7 && t7.map((e5) => e5.toJSON()), geometryType: t3.toJSON(this._workerGeometryType), hasM: "mesh" !== this._layerOrSourceGeometryType && o6, hasZ: "mesh" === this._layerOrSourceGeometryType || i7, objectIdField: s7, spatialReference: a4 ? null : r4 && r4.toJSON(), timeInfo: n8 ? n8.toJSON() : null }, c4 = await this._connection.invoke("load", u4, { signal: e4 });
    for (const p10 of c4.warnings)
      F3.warn(p10.message, { layer: this.layer, warning: p10 });
    c4.featureErrors.length && F3.warn(`Encountered ${c4.featureErrors.length} validation errors while loading features`, c4.featureErrors);
    const d = c4.layerDefinition;
    this._geometryTypeRequiresClientGraphicMapping(l2.inferredGeometryType) && (d.geometryType = t3.toJSON(l2.inferredGeometryType)), this.sourceJSON = d, this._requiresClientGraphicMapping() && (this._idToClientGraphic = /* @__PURE__ */ new Map()), l2.finish(c4.assignedObjectIds);
  }
};
e([n2({ Type: g, ensureType: b(g) })], G3.prototype, "itemType", void 0), e([y2()], G3.prototype, "type", void 0), e([y2({ constructOnly: true })], G3.prototype, "layer", void 0), e([y2({ readOnly: true })], G3.prototype, "_workerGeometryType", null), e([y2()], G3.prototype, "sourceJSON", void 0), G3 = e([n(T2)], G3);

// node_modules/@arcgis/core/layers/support/PublishingInfo.js
var e3 = class extends m {
  constructor() {
    super(...arguments), this.updating = false, this.status = "unknown";
  }
};
e([y2()], e3.prototype, "updating", void 0), e([y2()], e3.prototype, "status", void 0), e3 = e([n("esri.layers.support.PublishingInfo")], e3);
var p9 = e3;

// node_modules/@arcgis/core/layers/mixins/PublishableLayer.js
var o5 = "esri.layers.mixins.PublishableLayer";
var i6 = Symbol(o5);
var u3 = (i7) => {
  let n8 = class extends i7 {
    get publishingInfo() {
      if (this.destroyed)
        return null;
      const t7 = this._get("publishingInfo");
      if (t7)
        return t7;
      const s7 = new p9();
      return this._checkPublishingStatus(s7), s7;
    }
    _checkPublishingStatus(t7) {
      const s7 = 250, e4 = 125;
      let r4 = 0;
      const o6 = async (s8) => {
        let n9;
        t7.updating = true;
        try {
          n9 = await this.fetchPublishingStatus();
        } catch (u4) {
          n9 = "unavailable";
        }
        "published" !== n9 && "unavailable" !== n9 || ("publishing" === t7.status && this.refresh(), i8.remove()), t7.status = n9, t7.updating = false, i8.removed || (r4 = setTimeout(o6, s8, s8 + e4));
      }, i8 = { removed: false, remove() {
        this.removed = true, clearTimeout(r4);
      } };
      this.when().catch(() => i8.remove()), o6(s7), this.own(i8);
    }
  };
  return e([y2({ readOnly: true, clonable: false })], n8.prototype, "publishingInfo", null), n8 = e([n(o5)], n8), n8;
};

// node_modules/@arcgis/core/layers/FeatureLayer.js
var Ve = "FeatureLayer";
var Qe = "esri.layers.FeatureLayer";
var Ne = s2.getLogger(Qe);
function Ge(e4, r4) {
  return new s3("layer:unsupported", `Layer (${e4.title}, ${e4.id}) of type '${e4.declaredClass}' ${r4}`, { layer: e4 });
}
function Je(e4) {
  return e4 && e4 instanceof j2;
}
var $e = s6();
function We(e4, r4, t7) {
  const i7 = !!(t7 == null ? void 0 : t7.writeLayerSchema);
  return { enabled: i7, ignoreOrigin: i7 };
}
var Be = class extends M3(n6(p6(u3(a2(n3(c3(a3(t5(p2(p5(c2(v2(O(o4(i3(i(b2))))))))))))))))) {
  constructor(...e4) {
    super(...e4), this._handles = new t2(), this.charts = null, this.copyright = null, this.displayField = null, this.dynamicDataSource = null, this.fields = null, this.fieldsIndex = null, this.formTemplate = null, this.fullExtent = null, this.geometryType = null, this.hasM = void 0, this.hasZ = void 0, this.infoFor3D = null, this.isTable = false, this.labelsVisible = true, this.labelingInfo = null, this.legendEnabled = true, this.objectIdField = null, this.outFields = null, this.path = null, this.popupEnabled = true, this.popupTemplate = null, this.screenSizePerspectiveEnabled = true, this.spatialReference = k.WGS84, this.subtypeCode = null, this.templates = null, this.timeInfo = null, this.title = null, this.sublayerTitleMode = "item-title", this.type = "feature", this.typeIdField = null, this.types = null, this.visible = true;
  }
  destroy() {
    var _a;
    (_a = this.source) == null ? void 0 : _a.destroy(), this._handles = s(this._handles);
  }
  normalizeCtorArgs(e4, r4) {
    return "string" == typeof e4 ? { url: e4, ...r4 } : e4;
  }
  load(e4) {
    var _a;
    const r4 = r(e4) ? e4.signal : null;
    if (((_a = this.portalItem) == null ? void 0 : _a.loaded) && this.source)
      return this.addResolvingPromise(this.createGraphicsSource(r4).then((e5) => this.initLayerProperties(e5))), Promise.resolve(this);
    const t7 = this.loadFromPortal({ supportedTypes: ["Feature Service", "Feature Collection"] }, e4).catch(w).then(async () => {
      if (this.url && null == this.layerId && /FeatureServer|MapServer\/*$/i.test(this.url)) {
        const e5 = await this._fetchFirstLayerId(r4);
        null != e5 && (this.layerId = e5);
      }
      if (!this.url && !this._hasMemorySource())
        throw new s3("feature-layer:missing-url-or-source", "Feature layer must be created with either a url or a source");
      return this.initLayerProperties(await this.createGraphicsSource(r4));
    }).then(() => this.finishLoadEditablePortalLayer(e4));
    return this.addResolvingPromise(t7), Promise.resolve(this);
  }
  readCapabilities(e4, r4) {
    return r4 = r4.layerDefinition || r4, h2(e4, r4, this.url);
  }
  get createQueryVersion() {
    var _a;
    return this.commitProperty("definitionExpression"), this.commitProperty("dynamicDataSource"), this.commitProperty("timeExtent"), this.commitProperty("timeOffset"), this.commitProperty("geometryType"), this.commitProperty("gdbVersion"), this.commitProperty("historicMoment"), this.commitProperty("returnZ"), this.commitProperty("capabilities"), this.commitProperty("returnM"), ((_a = this._get("createQueryVersion")) != null ? _a : 0) + 1;
  }
  get editingEnabled() {
    var _a;
    return !(this.loaded && !((_a = this.capabilities) == null ? void 0 : _a.operations.supportsEditing)) && (this._isOverridden("editingEnabled") ? this._get("editingEnabled") : this._hasMemorySource() || this.userHasEditingPrivileges);
  }
  set editingEnabled(e4) {
    this._overrideIfSome("editingEnabled", e4);
  }
  readEditingEnabled(e4, r4) {
    return this._readEditingEnabled(r4, false);
  }
  readEditingEnabledFromWebMap(e4, r4, t7) {
    return this._readEditingEnabled(r4, true, t7);
  }
  writeEditingEnabled(e4, r4) {
    this._writeEditingEnabled(e4, r4, false);
  }
  writeEditingEnabledToWebMap(e4, r4, t7, i7) {
    this._writeEditingEnabled(e4, r4, true, i7);
  }
  readIsTable(e4, r4) {
    var _a;
    return "Table" === (r4 = (_a = r4 == null ? void 0 : r4.layerDefinition) != null ? _a : r4).type || !r4.geometryType;
  }
  writeIsTable(e4, r4, t7, i7) {
    (i7 == null ? void 0 : i7.writeLayerSchema) && o(t7, e4 ? "Table" : "Feature Layer", r4);
  }
  readGlobalIdField(e4, r4) {
    return z(r4.layerDefinition || r4);
  }
  readObjectIdField(e4, r4) {
    return U2(r4.layerDefinition || r4);
  }
  get parsedUrl() {
    const e4 = j(this.url);
    return null != e4 && (null != this.dynamicDataSource ? e4.path = G(e4.path, "dynamicLayer") : null != this.layerId && (e4.path = G(e4.path, this.layerId.toString()))), e4;
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  set renderer(e4) {
    F2(e4, this.fieldsIndex), this._set("renderer", e4);
  }
  readRenderer(e4, r4, s7) {
    var _a, _b;
    const a4 = (_a = (r4 = r4.layerDefinition || r4).drawingInfo) == null ? void 0 : _a.renderer;
    if (a4) {
      const e5 = (_b = o3(a4, r4, s7)) != null ? _b : void 0;
      return e5 || Ne.error("Failed to create renderer", { rendererDefinition: r4.drawingInfo.renderer, layer: this, context: s7 }), e5;
    }
    if (r4.defaultSymbol)
      return r4.types && r4.types.length ? new C({ defaultSymbol: ze(r4.defaultSymbol, r4, s7), field: r4.typeIdField, uniqueValueInfos: r4.types.map((e5) => ({ id: e5.id, symbol: ze(e5.symbol, e5, s7) })) }) : new p3({ symbol: ze(r4.defaultSymbol, r4, s7) });
  }
  set source(e4) {
    const r4 = this._get("source");
    r4 !== e4 && (Je(r4) && this._resetMemorySource(r4), Je(e4) && this._initMemorySource(e4), this._set("source", e4));
  }
  castSource(e4) {
    return e4 ? Array.isArray(e4) || e4 instanceof j2 ? new G3({ layer: this, items: e4 }) : e4 : null;
  }
  readSource(e4, r4) {
    var _a;
    const t7 = x.fromJSON(r4.featureSet);
    return new G3({ layer: this, items: (_a = t7 == null ? void 0 : t7.features) != null ? _a : [] });
  }
  readTemplates(e4, r4) {
    const t7 = r4.editFieldsInfo, i7 = t7 && t7.creatorField, o6 = t7 && t7.editorField;
    return e4 = e4 && e4.map((e5) => p7.fromJSON(e5)), this._fixTemplates(e4, i7), this._fixTemplates(e4, o6), e4;
  }
  readTitle(e4, r4) {
    var _a, _b;
    const t7 = (_b = (_a = r4.layerDefinition) == null ? void 0 : _a.name) != null ? _b : r4.name, i7 = r4.title || r4.layerDefinition && r4.layerDefinition.title;
    if (t7) {
      const e5 = this.portalItem && this.portalItem.title;
      if ("item-title" === this.sublayerTitleMode)
        return this.url ? y4(this.url, t7) : t7;
      let r5 = t7;
      if (!r5 && this.url) {
        const e6 = m4(this.url);
        r(e6) && (r5 = e6.title);
      }
      if (!r5)
        return;
      return "item-title-and-service-name" === this.sublayerTitleMode && e5 && e5 !== r5 && (r5 = e5 + " - " + r5), h(r5);
    }
    if ("item-title" === this.sublayerTitleMode && i7)
      return i7;
  }
  readTitleFromWebMap(e4, r4) {
    return r4.title || r4.layerDefinition && r4.layerDefinition.name;
  }
  readTypeIdField(e4, r4) {
    let t7 = (r4 = r4.layerDefinition || r4).typeIdField;
    if (t7 && r4.fields) {
      t7 = t7.toLowerCase();
      const e5 = r4.fields.find((e6) => e6.name.toLowerCase() === t7);
      e5 && (t7 = e5.name);
    }
    return t7;
  }
  readTypes(e4, r4) {
    e4 = (r4 = r4.layerDefinition || r4).types;
    const t7 = r4.editFieldsInfo, i7 = t7 && t7.creatorField, o6 = t7 && t7.editorField;
    return e4 && e4.map((e5) => (e5 = n7.fromJSON(e5), this._fixTemplates(e5.templates, i7), this._fixTemplates(e5.templates, o6), e5));
  }
  readVisible(e4, r4) {
    return r4.layerDefinition && null != r4.layerDefinition.defaultVisibility ? !!r4.layerDefinition.defaultVisibility : null != r4.visibility ? !!r4.visibility : void 0;
  }
  async addAttachment(e4, r4) {
    return F(this, e4, r4, Ve);
  }
  async updateAttachment(e4, r4, t7) {
    return x3(this, e4, r4, t7, Ve);
  }
  async applyEdits(e4, r4) {
    return P(this, e4, r4);
  }
  on(e4, r4) {
    return super.on(e4, r4);
  }
  createPopupTemplate(e4) {
    return p8(this, e4);
  }
  async createGraphicsSource(e4) {
    if (this._hasMemorySource() && this.source)
      return this.source.load({ signal: e4 });
    const { default: r4 } = await y3(import("./FeatureLayerSource-KUKCXBFR.js"), e4);
    return new r4({ layer: this }).load({ signal: e4 });
  }
  createQuery() {
    const e4 = L(this);
    e4.dynamicDataSource = this.dynamicDataSource;
    const r4 = r(this.subtypeCode) ? `${this.subtypeField} = ${this.subtypeCode}` : null, t7 = t6(this.definitionExpression, r4);
    return e4.where = t7 || "1=1", e4;
  }
  async deleteAttachments(e4, r4) {
    return O2(this, e4, r4, Ve);
  }
  async fetchRecomputedExtents(e4) {
    return v3(this, e4, Ve);
  }
  getFeatureType(e4) {
    const { typeIdField: r4, types: t7 } = this;
    if (!r4 || !e4)
      return null;
    const i7 = e4.attributes ? e4.attributes[r4] : void 0;
    if (null == i7)
      return null;
    let o6 = null;
    return t7 == null ? void 0 : t7.some((e5) => {
      const { id: r5 } = e5;
      return null != r5 && (r5.toString() === i7.toString() && (o6 = e5), !!o6);
    }), o6;
  }
  getFieldDomain(e4, r4) {
    const t7 = r4 && r4.feature, i7 = this.getFeatureType(t7);
    if (i7) {
      const r5 = i7.domains && i7.domains[e4];
      if (r5 && "inherited" !== r5.type)
        return r5;
    }
    return this._getLayerDomain(e4);
  }
  getField(e4) {
    return this.fieldsIndex.get(e4);
  }
  async queryAttachments(e4, r4) {
    return E(this, e4, r4, Ve);
  }
  async queryFeatures(e4, r4) {
    var _a;
    const t7 = await this.load(), i7 = await t7.source.queryFeatures((_a = x2.from(e4)) != null ? _a : t7.createQuery(), r4);
    if (i7 == null ? void 0 : i7.features)
      for (const o6 of i7.features)
        o6.layer = o6.sourceLayer = t7;
    return i7;
  }
  async queryObjectIds(e4, r4) {
    return I(this, e4, r4, Ve);
  }
  async queryFeatureCount(e4, r4) {
    return T(this, e4, r4, Ve);
  }
  async queryExtent(e4, r4) {
    return j5(this, e4, r4, Ve);
  }
  async queryRelatedFeatures(e4, r4) {
    return M2(this, e4, r4, Ve);
  }
  async queryRelatedFeaturesCount(e4, r4) {
    return D2(this, e4, r4, Ve);
  }
  async queryTopFeatures(e4, r4) {
    var _a;
    const { source: t7, capabilities: i7 } = await this.load();
    if (!t7.queryTopFeatures || !((_a = i7 == null ? void 0 : i7.query) == null ? void 0 : _a.supportsTopFeaturesQuery))
      throw new s3(Ve, "Layer source does not support queryTopFeatures capability");
    const o6 = await t7.queryTopFeatures(v5.from(e4), r4);
    if (o6 == null ? void 0 : o6.features)
      for (const s7 of o6.features)
        s7.layer = s7.sourceLayer = this;
    return o6;
  }
  async queryTopObjectIds(e4, r4) {
    const { source: t7, capabilities: i7 } = await this.load();
    if (!t7.queryTopObjectIds || !(i7 == null ? void 0 : i7.query.supportsTopFeaturesQuery))
      throw new s3(Ve, "Layer source does not support queryTopObjectIds capability");
    return t7.queryTopObjectIds(v5.from(e4), r4);
  }
  async queryTopFeaturesExtent(e4, r4) {
    var _a;
    const { source: t7, capabilities: i7 } = await this.load();
    if (!t7.queryTopExtents || !((_a = i7 == null ? void 0 : i7.query) == null ? void 0 : _a.supportsTopFeaturesQuery))
      throw new s3(Ve, "Layer source does not support queryTopExtents capability");
    return t7.queryTopExtents(v5.from(e4), r4);
  }
  async queryTopFeatureCount(e4, r4) {
    var _a;
    const { source: t7, capabilities: i7 } = await this.load();
    if (!t7.queryTopCount || !((_a = i7 == null ? void 0 : i7.query) == null ? void 0 : _a.supportsTopFeaturesQuery))
      throw new s3(Ve, "Layer source does not support queryFeatureCount capability");
    return t7.queryTopCount(v5.from(e4), r4);
  }
  read(e4, r4) {
    const t7 = e4.featureCollection;
    if (t7) {
      const e5 = t7.layers;
      e5 && 1 === e5.length && (super.read(e5[0], r4), null != t7.showLegend && super.read({ showLegend: t7.showLegend }, r4));
    }
    super.read(e4, r4), r4 && "service" === r4.origin && this.revert(["objectIdField", "fields", "timeInfo", "spatialReference"], "service");
  }
  write(e4, r4) {
    var _a, _b;
    r4 = { ...r4, origin: (_a = r4 == null ? void 0 : r4.origin) != null ? _a : void 0, writeLayerSchema: (_b = r4 == null ? void 0 : r4.writeLayerSchema) != null ? _b : this._hasMemorySource() };
    const { origin: t7, layerContainerType: i7, messages: o6 } = r4;
    if (this.dynamicDataSource)
      return o6 == null ? void 0 : o6.push(Ge(this, "using a dynamic data source cannot be written to web scenes, web maps and feature service items")), null;
    if (this.isTable) {
      if ("web-scene" === t7 || "web-map" === t7 && "tables" !== i7)
        return o6 == null ? void 0 : o6.push(Ge(this, "using a table source cannot be written to web scenes and web maps")), null;
      if (this._hasMemorySource())
        return o6 == null ? void 0 : o6.push(Ge(this, "using an in-memory table source cannot be written to web scenes and web maps")), null;
    } else if (this.loaded && "web-map" === t7 && "tables" === i7)
      return o6 == null ? void 0 : o6.push(Ge(this, "using a non-table source cannot be written to tables in web maps")), null;
    return super.write(e4, r4);
  }
  clone() {
    if (this._hasMemorySource())
      throw new s3(Ve, `FeatureLayer (title: ${this.title}, id: ${this.id}) created using in-memory source cannot be cloned`);
    return super.clone();
  }
  serviceSupportsSpatialReference(e4) {
    var _a;
    return !!this.loaded && ("memory" === ((_a = this.source) == null ? void 0 : _a.type) || e2(this, e4));
  }
  async save(e4) {
    return (await import("./featureLayerUtils-4K6V2KUA.js")).save(this, e4);
  }
  async saveAs(e4, r4) {
    return (await import("./featureLayerUtils-4K6V2KUA.js")).saveAs(this, e4, r4);
  }
  _readEditingEnabled(e4, r4, t7) {
    var _a;
    let i7 = (_a = e4.layerDefinition) == null ? void 0 : _a.capabilities;
    return i7 ? this._hasEditingCapability(i7) : (i7 = e4.capabilities, r4 && "web-map" === (t7 == null ? void 0 : t7.origin) && !this._hasMemorySource() && i7 ? this._hasEditingCapability(i7) : void 0);
  }
  _hasEditingCapability(e4) {
    return e4.toLowerCase().split(",").map((e5) => e5.trim()).includes("editing");
  }
  _writeEditingEnabled(e4, r4, t7, i7) {
    var _a, _b;
    if (!e4) {
      const e5 = ((_b = (_a = this.capabilities) == null ? void 0 : _a.operations) == null ? void 0 : _b.supportsSync) ? "Query,Sync" : "Query";
      o("layerDefinition.capabilities", e5, r4), t7 && !(i7 == null ? void 0 : i7.writeLayerSchema) && (r4.capabilities = e5);
    }
  }
  _getLayerDomain(e4) {
    const r4 = this.fieldsIndex.get(e4);
    return r4 ? r4.domain : null;
  }
  _fetchFirstLayerId(e4) {
    return U(this.url, { query: { f: "json", ...this.customParameters, token: this.apiKey }, responseType: "json", signal: e4 }).then((e5) => {
      const r4 = e5.data;
      if (r4)
        return Array.isArray(r4.layers) && r4.layers.length > 0 ? r4.layers[0].id : Array.isArray(r4.tables) && r4.tables.length > 0 ? r4.tables[0].id : void 0;
    });
  }
  async initLayerProperties(e4) {
    return this._set("source", e4), e4.sourceJSON && (this.sourceJSON = e4.sourceJSON, this.read(e4.sourceJSON, { origin: "service", url: this.parsedUrl })), this._verifySource(), this._verifyFields(), F2(this.renderer, this.fieldsIndex), x4(this.timeInfo, this.fieldsIndex), t4(this, { origin: "service" });
  }
  async hasDataChanged() {
    return G2(this);
  }
  async fetchPublishingStatus() {
    const e4 = this.source;
    return (e4 == null ? void 0 : e4.fetchPublishingStatus) ? e4.fetchPublishingStatus() : "unavailable";
  }
  _verifyFields() {
    var _a, _b, _c;
    const e4 = (_b = (_a = this.parsedUrl) == null ? void 0 : _a.path) != null ? _b : "undefined";
    this.objectIdField || console.log("FeatureLayer: 'objectIdField' property is not defined (url: " + e4 + ")"), this.isTable || this._hasMemorySource() || -1 !== e4.search(/\/FeatureServer\//i) || ((_c = this.fields) == null ? void 0 : _c.some((e5) => "geometry" === e5.type)) || console.log("FeatureLayer: unable to find field of type 'geometry' in the layer 'fields' list. If you are using a map service layer, features will not have geometry (url: " + e4 + ")");
  }
  _fixTemplates(e4, r4) {
    e4 && e4.forEach((e5) => {
      const t7 = e5.prototype && e5.prototype.attributes;
      t7 && r4 && delete t7[r4];
    });
  }
  _verifySource() {
    if (this._hasMemorySource()) {
      if (this.url)
        throw new s3("feature-layer:mixed-source-and-url", "FeatureLayer cannot be created with both an in-memory source and a url");
    } else if (!this.url)
      throw new s3("feature-layer:source-or-url-required", "FeatureLayer requires either a url, a valid portal item or a source");
  }
  _initMemorySource(e4) {
    e4.forEach((e5) => {
      e5.layer = this, e5.sourceLayer = this;
    }), this._handles.add([e4.on("after-add", (e5) => {
      e5.item.layer = this, e5.item.sourceLayer = this;
    }), e4.on("after-remove", (e5) => {
      e5.item.layer = null, e5.item.sourceLayer = null;
    })], "fl-source");
  }
  _resetMemorySource(e4) {
    e4.forEach((e5) => {
      e5.layer = null, e5.sourceLayer = null;
    }), this._handles.remove("fl-source");
  }
  _hasMemorySource() {
    return !(this.url || !this.source);
  }
};
e([o2("service", "capabilities")], Be.prototype, "readCapabilities", null), e([y2({ json: { origins: { "portal-item": { write: true }, "web-map": { write: true } } } })], Be.prototype, "charts", void 0), e([y2({ readOnly: true })], Be.prototype, "createQueryVersion", null), e([y2({ json: { read: { source: "layerDefinition.copyrightText" } } })], Be.prototype, "copyright", void 0), e([y2({ json: { read: { source: "layerDefinition.displayField" } } })], Be.prototype, "displayField", void 0), e([y2({ types: j4, readOnly: true })], Be.prototype, "defaultSymbol", void 0), e([y2({ type: K })], Be.prototype, "dynamicDataSource", void 0), e([y2({ type: Boolean })], Be.prototype, "editingEnabled", null), e([o2(["portal-item", "web-scene"], "editingEnabled", ["layerDefinition.capabilities"])], Be.prototype, "readEditingEnabled", null), e([o2("web-map", "editingEnabled", ["capabilities", "layerDefinition.capabilities"])], Be.prototype, "readEditingEnabledFromWebMap", null), e([r2(["portal-item", "web-scene"], "editingEnabled", { "layerDefinition.capabilities": { type: String } })], Be.prototype, "writeEditingEnabled", null), e([r2("web-map", "editingEnabled", { capabilities: { type: String }, "layerDefinition.capabilities": { type: String } })], Be.prototype, "writeEditingEnabledToWebMap", null), e([y2({ ...$e.fields, json: { read: { source: "layerDefinition.fields" }, origins: { service: { name: "fields" }, "web-map": { write: { target: "layerDefinition.fields", overridePolicy: We } } } } })], Be.prototype, "fields", void 0), e([y2($e.fieldsIndex)], Be.prototype, "fieldsIndex", void 0), e([y2({ type: y5, json: { name: "formInfo", write: true, origins: { "web-scene": { read: false, write: false } } } })], Be.prototype, "formTemplate", void 0), e([y2({ json: { read: { source: "layerDefinition.extent" } } })], Be.prototype, "fullExtent", void 0), e([y2({ json: { origins: { "web-map": { write: { target: "layerDefinition.geometryType", overridePolicy: We, writer(e4, r4, t7) {
  const i7 = e4 ? i4.toJSON(e4) : null;
  i7 && o(t7, i7, r4);
} } } }, read: { source: "layerDefinition.geometryType", reader: i4.read } } })], Be.prototype, "geometryType", void 0), e([y2({ json: { read: { source: "layerDefinition.hasM" } } })], Be.prototype, "hasM", void 0), e([y2({ json: { read: { source: "layerDefinition.hasZ" } } })], Be.prototype, "hasZ", void 0), e([y2(j3)], Be.prototype, "id", void 0), e([y2({ readOnly: true, json: { origins: { service: { read: true } }, read: false } })], Be.prototype, "infoFor3D", void 0), e([y2({ json: { origins: { "web-map": { write: { target: "layerDefinition.type" } } } } })], Be.prototype, "isTable", void 0), e([o2("service", "isTable", ["type", "geometryType"]), o2("isTable", ["layerDefinition.type", "layerDefinition.geometryType"])], Be.prototype, "readIsTable", null), e([r2("web-map", "isTable")], Be.prototype, "writeIsTable", null), e([y2(m5)], Be.prototype, "labelsVisible", void 0), e([y2({ type: [j6], json: { origins: { service: { read: { source: "drawingInfo.labelingInfo", reader: i5 }, write: { target: "drawingInfo.labelingInfo", enabled: false } } }, read: { source: "layerDefinition.drawingInfo.labelingInfo", reader: i5 }, write: { target: "layerDefinition.drawingInfo.labelingInfo" } } })], Be.prototype, "labelingInfo", void 0), e([y2((() => {
  const e4 = y(u);
  return e4.json.origins["portal-item"] = { write: { target: "layerDefinition.drawingInfo.transparency", writer(e5, r4, t7) {
    o(t7, n4(e5), r4);
  } } }, e4;
})())], Be.prototype, "opacity", void 0), e([y2(c)], Be.prototype, "legendEnabled", void 0), e([y2({ type: ["show", "hide"], json: (() => {
  const e4 = y(D.json);
  return e4.origins["portal-item"] = { read: false, write: false }, e4;
})() })], Be.prototype, "listMode", void 0), e([o2("globalIdField", ["layerDefinition.globalIdField", "layerDefinition.fields"])], Be.prototype, "readGlobalIdField", null), e([y2({ json: { origins: { "web-map": { write: { target: "layerDefinition.objectIdField", overridePolicy: We } } } } })], Be.prototype, "objectIdField", void 0), e([o2("objectIdField", ["layerDefinition.objectIdField", "layerDefinition.fields"])], Be.prototype, "readObjectIdField", null), e([y2({ value: "ArcGISFeatureLayer", type: ["ArcGISFeatureLayer"] })], Be.prototype, "operationalLayerType", void 0), e([y2($e.outFields)], Be.prototype, "outFields", void 0), e([y2({ readOnly: true })], Be.prototype, "parsedUrl", null), e([y2({ type: String, json: { origins: { "web-scene": { read: true, write: true } }, read: false } })], Be.prototype, "path", void 0), e([y2(p)], Be.prototype, "popupEnabled", void 0), e([y2({ type: k2, json: { name: "popupInfo", write: true } })], Be.prototype, "popupTemplate", void 0), e([y2({ readOnly: true })], Be.prototype, "defaultPopupTemplate", null), e([y2({ types: p4, json: { origins: { service: { write: { target: "drawingInfo.renderer", enabled: false } }, "web-scene": { types: n5, name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy: (e4, r4, t7) => ({ ignoreOrigin: t7 == null ? void 0 : t7.writeLayerSchema }) } } }, write: { target: "layerDefinition.drawingInfo.renderer", overridePolicy: (e4, r4, t7) => ({ ignoreOrigin: t7 == null ? void 0 : t7.writeLayerSchema }) } } })], Be.prototype, "renderer", null), e([o2("service", "renderer", ["drawingInfo.renderer", "defaultSymbol"]), o2("renderer", ["layerDefinition.drawingInfo.renderer", "layerDefinition.defaultSymbol"])], Be.prototype, "readRenderer", null), e([y2((() => {
  const e4 = y(l);
  return e4.json.origins["portal-item"] = { read: false, write: false }, e4;
})())], Be.prototype, "screenSizePerspectiveEnabled", void 0), e([y2({ clonable: false })], Be.prototype, "source", null), e([s5("source")], Be.prototype, "castSource", null), e([o2("portal-item", "source", ["featureSet"]), o2("web-map", "source", ["featureSet"])], Be.prototype, "readSource", null), e([y2({ json: { read: { source: "layerDefinition.extent.spatialReference" } } })], Be.prototype, "spatialReference", void 0), e([y2({ type: Number })], Be.prototype, "subtypeCode", void 0), e([y2({ type: [p7] })], Be.prototype, "templates", void 0), e([o2("templates", ["editFieldsInfo", "creatorField", "editorField", "templates"])], Be.prototype, "readTemplates", null), e([y2({ type: v4 })], Be.prototype, "timeInfo", void 0), e([y2()], Be.prototype, "title", void 0), e([o2("service", "title", ["name"]), o2("portal-item", "title", ["layerDefinition.title", "layerDefinition.name", "title"])], Be.prototype, "readTitle", null), e([o2("web-map", "title", ["layerDefinition.name", "title"])], Be.prototype, "readTitleFromWebMap", null), e([y2({ type: String })], Be.prototype, "sublayerTitleMode", void 0), e([y2({ json: { read: false } })], Be.prototype, "type", void 0), e([y2({ type: String })], Be.prototype, "typeIdField", void 0), e([o2("service", "typeIdField"), o2("typeIdField", ["layerDefinition.typeIdField"])], Be.prototype, "readTypeIdField", null), e([y2({ type: [n7] })], Be.prototype, "types", void 0), e([o2("service", "types", ["types"]), o2("types", ["layerDefinition.types"])], Be.prototype, "readTypes", null), e([y2({ type: Boolean, json: { origins: { "portal-item": { write: { target: "layerDefinition.defaultVisibility" } } } } })], Be.prototype, "visible", void 0), e([o2("portal-item", "visible", ["visibility", "layerDefinition.defaultVisibility"])], Be.prototype, "readVisible", null), Be = e([n(Qe)], Be);
var ze = s4({ types: M });
var Ze = Be;

export {
  Ze
};
//# sourceMappingURL=chunk-53VWTVL2.js.map
