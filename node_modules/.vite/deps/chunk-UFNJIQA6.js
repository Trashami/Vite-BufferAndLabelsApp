import {
  i
} from "./chunk-Z5PNFOTJ.js";
import {
  h
} from "./chunk-P5Y67HOZ.js";
import {
  gt
} from "./chunk-TJ2I6XQT.js";
import {
  G
} from "./chunk-XMZAPOBR.js";
import {
  D,
  u
} from "./chunk-6M2AHKYV.js";
import {
  n
} from "./chunk-THVR7IAM.js";
import {
  s as s2
} from "./chunk-LIZHLHNA.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";
import {
  has
} from "./chunk-HVKDYDPP.js";
import {
  r,
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/layers/graphics/data/BoundsStore.js
var d = 5e4;
var n2 = { minX: 0, minY: 0, maxX: 0, maxY: 0 };
function t2(i2) {
  n2.minX = i2[0], n2.minY = i2[1], n2.maxX = i2[2], n2.maxY = i2[3];
}
function e(i2, s3, d2) {
  t2(s3), i2.search(n2, d2);
}
var o = class {
  constructor() {
    this._indexInvalid = false, this._boundsToLoad = [], this._boundsById = /* @__PURE__ */ new Map(), this._idByBounds = /* @__PURE__ */ new Map(), this._index = new h(9, has("esri-csp-restrictions") ? (i2) => ({ minX: i2[0], minY: i2[1], maxX: i2[2], maxY: i2[3] }) : ["[0]", "[1]", "[2]", "[3]"]), this._loadIndex = () => {
      if (this._indexInvalid) {
        const i2 = new Array(this._idByBounds.size);
        let s3 = 0;
        this._idByBounds.forEach((d2, n3) => {
          i2[s3++] = n3;
        }), this._indexInvalid = false, this._index.clear(), this._index.load(i2);
      } else
        this._boundsToLoad.length && (this._index.load(this._boundsToLoad.filter((i2) => this._idByBounds.has(i2))), this._boundsToLoad.length = 0);
    };
  }
  get fullBounds() {
    if (!this._boundsById.size)
      return null;
    const i2 = D();
    for (const s3 of this._boundsById.values())
      s3 && (i2[0] = Math.min(s3[0], i2[0]), i2[1] = Math.min(s3[1], i2[1]), i2[2] = Math.max(s3[2], i2[2]), i2[3] = Math.max(s3[3], i2[3]));
    return i2;
  }
  get valid() {
    return !this._indexInvalid;
  }
  clear() {
    this._indexInvalid = false, this._boundsToLoad.length = 0, this._boundsById.clear(), this._idByBounds.clear(), this._index.clear();
  }
  delete(i2) {
    const s3 = this._boundsById.get(i2);
    this._boundsById.delete(i2), s3 && (this._idByBounds.delete(s3), this._indexInvalid || this._index.remove(s3));
  }
  forEachInBounds(i2, s3) {
    this._loadIndex(), e(this._index, i2, (i3) => s3(this._idByBounds.get(i3)));
  }
  get(i2) {
    return this._boundsById.get(i2);
  }
  has(i2) {
    return this._boundsById.has(i2);
  }
  invalidateIndex() {
    this._indexInvalid || (this._indexInvalid = true, this._boundsToLoad.length = 0);
  }
  set(i2, s3) {
    if (!this._indexInvalid) {
      const s4 = this._boundsById.get(i2);
      s4 && (this._index.remove(s4), this._idByBounds.delete(s4));
    }
    this._boundsById.set(i2, s3), s3 && (this._idByBounds.set(s3, i2), this._indexInvalid || (this._boundsToLoad.push(s3), this._boundsToLoad.length > d && this._loadIndex()));
  }
};

// node_modules/@arcgis/core/layers/graphics/data/FeatureStore.js
var u2 = class {
  constructor(e2) {
    this.geometryInfo = e2, this._boundsStore = new o(), this._featuresById = /* @__PURE__ */ new Map(), this._markedIds = /* @__PURE__ */ new Set(), this.events = new n(), this.featureAdapter = i;
  }
  get geometryType() {
    return this.geometryInfo.geometryType;
  }
  get hasM() {
    return this.geometryInfo.hasM;
  }
  get hasZ() {
    return this.geometryInfo.hasZ;
  }
  get numFeatures() {
    return this._featuresById.size;
  }
  get fullBounds() {
    return this._boundsStore.fullBounds;
  }
  get storeStatistics() {
    let e2 = 0;
    return this._featuresById.forEach((t3) => {
      r(t3.geometry) && t3.geometry.coords && (e2 += t3.geometry.coords.length);
    }), { featureCount: this._featuresById.size, vertexCount: e2 / (this.hasZ ? this.hasM ? 4 : 3 : this.hasM ? 3 : 2) };
  }
  add(e2) {
    this._add(e2), this._emitChanged();
  }
  addMany(e2) {
    for (const t3 of e2)
      this._add(t3);
    this._emitChanged();
  }
  clear() {
    this._featuresById.clear(), this._boundsStore.clear(), this._emitChanged();
  }
  removeById(e2) {
    const t3 = this._featuresById.get(e2);
    return t3 ? (this._remove(t3), this._emitChanged(), t3) : null;
  }
  removeManyById(e2) {
    this._boundsStore.invalidateIndex();
    for (const t3 of e2) {
      const e3 = this._featuresById.get(t3);
      e3 && this._remove(e3);
    }
    this._emitChanged();
  }
  forEachBounds(e2, t3, r2) {
    for (const s3 of e2) {
      const e3 = this._boundsStore.get(s3.objectId);
      e3 && t3(G(r2, e3));
    }
  }
  getFeature(e2) {
    return this._featuresById.get(e2);
  }
  has(e2) {
    return this._featuresById.has(e2);
  }
  toArray() {
    return Array.from(this._featuresById.values());
  }
  forEach(e2) {
    this._featuresById.forEach((t3) => e2(t3));
  }
  forEachInBounds(e2, t3) {
    this._boundsStore.forEachInBounds(e2, (e3) => {
      t3(this._featuresById.get(e3));
    });
  }
  startMarkingUsedFeatures() {
    this._boundsStore.invalidateIndex(), this._markedIds.clear();
  }
  sweep() {
    let e2 = false;
    this._featuresById.forEach((t3, r2) => {
      this._markedIds.has(r2) || (e2 = true, this._remove(t3));
    }), this._markedIds.clear(), e2 && this._emitChanged();
  }
  _emitChanged() {
    this.events.emit("changed", void 0);
  }
  _add(t3) {
    if (!t3)
      return;
    const i2 = t3.objectId;
    if (null == i2)
      return void s.getLogger("esri.layers.graphics.data.FeatureStore").error(new s2("featurestore:invalid-feature", "feature id is missing", { feature: t3 }));
    const n3 = this._featuresById.get(i2);
    let h2;
    if (this._markedIds.add(i2), n3 ? (t3.displayId = n3.displayId, h2 = this._boundsStore.get(i2), this._boundsStore.delete(i2)) : r(this.onFeatureAdd) && this.onFeatureAdd(t3), t(t3.geometry) || !t3.geometry.coords || !t3.geometry.coords.length)
      return this._boundsStore.set(i2, null), void this._featuresById.set(i2, t3);
    h2 = gt(r(h2) ? h2 : u(), t3.geometry, this.geometryInfo.hasZ, this.geometryInfo.hasM), r(h2) && this._boundsStore.set(i2, h2), this._featuresById.set(i2, t3);
  }
  _remove(e2) {
    return r(this.onFeatureRemove) && this.onFeatureRemove(e2), this._markedIds.delete(e2.objectId), this._boundsStore.delete(e2.objectId), this._featuresById.delete(e2.objectId), e2;
  }
};

export {
  o,
  u2 as u
};
//# sourceMappingURL=chunk-UFNJIQA6.js.map
