import {
  B,
  C,
  M,
  N as N2,
  W,
  f,
  m,
  o,
  s as s3
} from "./chunk-NOCUJJC3.js";
import {
  g
} from "./chunk-AKA4FJNZ.js";
import "./chunk-P6POPBMF.js";
import "./chunk-U7A2AWFU.js";
import {
  J as J2
} from "./chunk-ZB4SIC65.js";
import {
  dn
} from "./chunk-E7ZZRFGO.js";
import "./chunk-YHCS4AQC.js";
import "./chunk-QOM6O2E2.js";
import {
  A,
  D2 as D,
  E,
  F2 as F,
  J,
  K,
  N,
  Ne,
  P2 as P,
  Q,
  V,
  X,
  Y,
  Z,
  _,
  e,
  e2,
  j,
  k as k2,
  n,
  r,
  re,
  s2 as s,
  s3 as s2,
  se,
  t,
  u,
  w
} from "./chunk-GDBM63TX.js";
import "./chunk-6UMNMSQC.js";
import "./chunk-TJ2I6XQT.js";
import "./chunk-EDHROVWI.js";
import "./chunk-34YPGGJT.js";
import "./chunk-2ZKX6TXA.js";
import "./chunk-GLGOVVCK.js";
import "./chunk-BUVDI6S7.js";
import "./chunk-ZL4T4NIV.js";
import "./chunk-NAKEKTIK.js";
import "./chunk-QWNKYSI4.js";
import "./chunk-FMJZBZWF.js";
import "./chunk-GOYVJTGW.js";
import "./chunk-ZPYDYUP5.js";
import "./chunk-WJCI2CGX.js";
import "./chunk-NAN5J6QS.js";
import "./chunk-YWAQYJRC.js";
import "./chunk-B356PXLT.js";
import "./chunk-EHPBHJYZ.js";
import "./chunk-3MNMDUQZ.js";
import {
  p
} from "./chunk-UWG37XSU.js";
import {
  k2 as k
} from "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import "./chunk-HLM6QCL2.js";
import "./chunk-RXYULINL.js";
import "./chunk-XQN7F674.js";
import "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import "./chunk-KAN4HXCG.js";
import "./chunk-4FEGON7M.js";
import "./chunk-VWYWOOPX.js";
import "./chunk-M5VHU5LK.js";
import "./chunk-7QMMKGW4.js";
import "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import "./chunk-MJXQTGI2.js";
import "./chunk-LIZHLHNA.js";
import "./chunk-BTUHYGXO.js";
import "./chunk-UA3YPL2R.js";
import "./chunk-HVKDYDPP.js";
import "./chunk-6QC7MLLS.js";
import "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/arcade/arcadeAsyncRuntime.js
function q(e3) {
  return e3 && "function" == typeof e3.then;
}
var W2 = 100;
async function V2(e3, t2) {
  const n2 = [];
  for (let r2 = 0; r2 < t2.arguments.length; r2++)
    n2.push(await J3(e3, t2.arguments[r2]));
  return n2;
}
async function _2(e3, t2, n2) {
  if (true === t2.preparsed)
    return n2(e3, null, t2.arguments);
  return n2(e3, t2, await V2(e3, t2));
}
var Y2 = class extends r {
  constructor(e3, t2) {
    super(), this.definition = null, this.context = null, this.definition = e3, this.context = t2;
  }
  createFunction(e3) {
    return (...t2) => {
      const n2 = { spatialReference: this.context.spatialReference, console: this.context.console, lrucache: this.context.lrucache, exports: this.context.exports, libraryResolver: this.context.libraryResolver, interceptor: this.context.interceptor, localScope: {}, depthCounter: { depth: e3.depthCounter + 1 }, globalScope: this.context.globalScope };
      if (n2.depthCounter.depth > 64)
        throw new t(e3, e.MaximumCallDepth, null);
      return Pe(this.definition, n2, t2, null);
    };
  }
  call(e3, t2) {
    return H(e3, t2, (n2, a, i) => {
      const l = { spatialReference: e3.spatialReference, services: e3.services, console: e3.console, libraryResolver: e3.libraryResolver, exports: e3.exports, lrucache: e3.lrucache, interceptor: e3.interceptor, localScope: {}, abortSignal: e3.abortSignal, globalScope: e3.globalScope, depthCounter: { depth: e3.depthCounter.depth + 1 } };
      if (l.depthCounter.depth > 64)
        throw new t(e3, e.MaximumCallDepth, t2);
      return Pe(this.definition, l, i, t2);
    });
  }
  marshalledCall(e3, t2, n2, r2) {
    return r2(e3, t2, async (o2, a, i) => {
      const l = { spatialReference: e3.spatialReference, globalScope: n2.globalScope, depthCounter: { depth: e3.depthCounter.depth + 1 }, libraryResolver: e3.libraryResolver, exports: e3.exports, console: e3.console, abortSignal: e3.abortSignal, lrucache: e3.lrucache, interceptor: e3.interceptor, localScope: {} };
      return i = i.map((t3) => !F(t3) || t3 instanceof s ? t3 : n(t3, e3, r2)), n(await Pe(this.definition, l, i, t2), n2, r2);
    });
  }
};
var z = class extends s2 {
  constructor(e3) {
    super(e3);
  }
  async global(e3) {
    const t2 = this.executingContext.globalScope[e3.toLowerCase()];
    if (t2.valueset || (t2.value = await J3(this.executingContext, t2.node), t2.valueset = true), F(t2.value) && !(t2.value instanceof s)) {
      const e4 = new s();
      e4.fn = t2.value, e4.parameterEvaluator = H, e4.context = this.executingContext, t2.value = e4;
    }
    return t2.value;
  }
  setGlobal(e3, t2) {
    if (F(t2))
      throw new t(null, e.AssignModuleFunction, null);
    this.executingContext.globalScope[e3.toLowerCase()] = { value: t2, valueset: true, node: null };
  }
  hasGlobal(e3) {
    return void 0 === this.executingContext.exports[e3] && (e3 = e3.toLowerCase()), void 0 !== this.executingContext.exports[e3];
  }
  async loadModule(e3) {
    let n2 = e3.spatialReference;
    null == n2 && (n2 = new k({ wkid: 102100 })), this.moduleScope = Ge({}, e3.customfunctions), this.executingContext = { spatialReference: n2, services: e3.services, libraryResolver: new s3(e3.libraryResolver._moduleSingletons, this.source.syntax.loadedModules), exports: {}, abortSignal: void 0 === e3.abortSignal || null === e3.abortSignal ? { aborted: false } : e3.abortSignal, globalScope: this.moduleScope, console: e3.console ? e3.console : Te, lrucache: e3.lrucache, interceptor: e3.interceptor, localScope: null, depthCounter: { depth: 1 } }, await J3(this.executingContext, this.source.syntax);
  }
};
async function H(e3, t2, n2) {
  if (true === t2.preparsed) {
    const r3 = n2(e3, null, t2.arguments);
    return q(r3), r3;
  }
  const r2 = n2(e3, t2, await V2(e3, t2));
  return q(r2), r2;
}
async function J3(e3, t2, n2) {
  if (t2.breakpoint && true !== n2) {
    const n3 = t2.breakpoint();
    return await n3, J3(e3, t2, true);
  }
  try {
    switch (t2 == null ? void 0 : t2.type) {
      case "VariableDeclarator":
        return await xe(e3, t2);
      case "ImportDeclaration":
        return await ve(e3, t2);
      case "ExportNamedDeclaration":
        return await be(e3, t2);
      case "VariableDeclaration":
        return await Se(e3, t2, 0);
      case "BlockStatement":
      case "Program":
        return await he(e3, t2);
      case "FunctionDeclaration":
        return await ye(e3, t2);
      case "ReturnStatement":
        return await ge(e3, t2);
      case "IfStatement":
        return await de(e3, t2);
      case "ExpressionStatement":
        return await we(e3, t2);
      case "UpdateExpression":
        return await ue(e3, t2);
      case "AssignmentExpression":
        return await pe(e3, t2);
      case "ForStatement":
        return await ne(e3, t2);
      case "WhileStatement":
        return await Z2(e3, t2);
      case "ForInStatement":
        return await ce(e3, t2);
      case "BreakStatement":
        return j;
      case "EmptyStatement":
        return k2;
      case "ContinueStatement":
        return A;
      case "TemplateElement":
        return await Le(e3, t2);
      case "TemplateLiteral":
        return await Ne2(e3, t2);
      case "Identifier":
        return await Me(e3, t2);
      case "MemberExpression":
        return await Ie(e3, t2);
      case "Literal":
        return t2.value;
      case "CallExpression":
        return await je(e3, t2);
      case "UnaryExpression":
        return await Fe(e3, t2);
      case "BinaryExpression":
        return await Re(e3, t2);
      case "LogicalExpression":
        return await Ae(e3, t2);
      case "ArrayExpression":
        return await Ce(e3, t2);
      case "ObjectExpression":
        return await Q2(e3, t2);
      case "Property":
        return await X2(e3, t2);
      default:
        throw new t(e3, e.Unrecognised, t2);
    }
  } catch (i) {
    throw u(e3, t2, i);
  }
}
async function Q2(e3, t2) {
  const a = [];
  for (let n2 = 0; n2 < t2.properties.length; n2++)
    a[n2] = await J3(e3, t2.properties[n2]);
  const i = {}, l = /* @__PURE__ */ new Map();
  for (let n2 = 0; n2 < a.length; n2++) {
    const s5 = a[n2];
    if (F(s5.value))
      throw new t(e3, e.NoFunctionInDictionary, t2);
    if (false === w(s5.key))
      throw new t(e3, e.KeyMustBeString, t2);
    let c = s5.key.toString();
    const u2 = c.toLowerCase();
    l.has(u2) ? c = l.get(u2) : l.set(u2, c), s5.value === k2 ? i[c] = null : i[c] = s5.value;
  }
  const s4 = new J2(i);
  return s4.immutable = false, s4;
}
async function X2(e3, t2) {
  const n2 = await J3(e3, t2.value);
  if ("Identifier" === t2.key.type)
    return { key: t2.key.name, value: n2 };
  return { key: await J3(e3, t2.key), value: n2 };
}
async function Z2(e3, t2) {
  const n2 = { testResult: true, lastAction: k2 };
  if (n2.testResult = await J3(e3, t2.test), false === n2.testResult)
    return k2;
  if (true !== n2.testResult)
    throw new t(e3, e.BooleanConditionRequired, t2);
  for (; true === n2.testResult && (n2.lastAction = await J3(e3, t2.body), n2.lastAction !== j) && !(n2.lastAction instanceof D); )
    if (n2.testResult = await J3(e3, t2.test), true !== n2.testResult && false !== n2.testResult)
      throw new t(e3, e.BooleanConditionRequired, t2);
  return n2.lastAction instanceof D ? n2.lastAction : k2;
}
async function $(e3, t2, n2) {
  const r2 = await J3(e3, t2.body);
  return n2.lastAction = r2, n2.lastAction === j || n2.lastAction instanceof D ? (n2.testResult = false, n2) : null !== t2.update ? (await J3(e3, t2.update), n2) : n2;
}
async function ee(e3, t2, n2) {
  var _a;
  if (null !== t2.test) {
    const a = await J3(e3, t2.test);
    if (true === ((_a = e3.abortSignal) == null ? void 0 : _a.aborted))
      throw new t(e3, e.Cancelled, t2);
    if (n2.testResult = a, false === n2.testResult)
      return n2;
    if (true !== n2.testResult)
      throw new t(e3, e.BooleanConditionRequired, t2);
    return $(e3, t2, n2);
  }
  return $(e3, t2, n2);
}
function te(e3, t2, n2, r2, o2, a) {
  try {
    ee(e3, t2, n2).then(() => {
      try {
        true === n2.testResult ? ++a > W2 ? (a = 0, setTimeout(() => {
          te(e3, t2, n2, r2, o2, a);
        }, 0)) : te(e3, t2, n2, r2, o2, a) : n2.lastAction instanceof D ? r2(n2.lastAction) : r2(k2);
      } catch (i) {
        o2(i);
      }
    }, (e4) => {
      o2(e4);
    });
  } catch (i) {
    o2(i);
  }
}
function ne(e3, t2) {
  try {
    return null !== t2.init ? J3(e3, t2.init).then(() => new Promise((n2, r2) => {
      te(e3, t2, { testResult: true, lastAction: k2 }, (e4) => {
        n2(e4);
      }, (e4) => {
        r2(e4);
      }, 0);
    })) : new Promise((n2, r2) => {
      te(e3, t2, { testResult: true, lastAction: k2 }, (e4) => {
        n2(e4);
      }, (e4) => {
        r2(e4);
      }, 0);
    });
  } catch (n2) {
    return Promise.reject(n2);
  }
}
function re2(e3, t2, n2, r2, o2, a, i, l, s4, c) {
  try {
    if (r2 <= a)
      return void l(k2);
    o2.value = "k" === i ? n2[a] : a, J3(e3, t2.body).then((u2) => {
      try {
        u2 instanceof D ? l(u2) : u2 === j ? l(k2) : ++c > W2 ? (c = 0, setTimeout(() => {
          re2(e3, t2, n2, r2, o2, a + 1, i, l, s4, c);
        }, 0)) : re2(e3, t2, n2, r2, o2, a + 1, i, l, s4, c);
      } catch (f2) {
        s4(f2);
      }
    }, (e4) => {
      s4(e4);
    });
  } catch (u2) {
    s4(u2);
  }
}
function oe(e3, t2, n2, r2, o2, a, i, l, s4) {
  try {
    if (n2.length() <= o2)
      return void i(k2);
    r2.value = "k" === a ? n2.get(o2) : o2, J3(e3, t2.body).then((c) => {
      c instanceof D ? i(c) : c === j ? i(k2) : ++s4 > W2 ? (s4 = 0, setTimeout(() => {
        oe(e3, t2, n2, r2, o2 + 1, a, i, l, s4);
      }, 0)) : oe(e3, t2, n2, r2, o2 + 1, a, i, l, s4);
    }, (e4) => {
      l(e4);
    });
  } catch (c) {
    l(c);
  }
}
function ae(e3, t2, n2, r2, o2, a) {
  try {
    if (void 0 === a && (a = "i"), 0 === n2.length)
      return void r2.resolve(k2);
    re2(e3, t2, n2, n2.length, o2, 0, a, (e4) => {
      r2.resolve(e4);
    }, (e4) => {
      r2.reject(e4);
    }, 0);
  } catch (i) {
    r2.reject(i);
  }
}
function ie(e3, t2, n2, r2, o2, a) {
  try {
    if (void 0 === a && (a = "i"), 0 === n2.length)
      return void r2.resolve(k2);
    oe(e3, t2, n2, o2, 0, a, (e4) => {
      r2.resolve(e4);
    }, (e4) => {
      r2.reject(e4);
    }, 0);
  } catch (i) {
    r2.reject(i);
  }
}
function le(e3, t2, n2, r2, o2) {
  try {
    ae(e3, t2, n2.keys(), r2, o2, "k");
  } catch (a) {
    r2.reject(a);
  }
}
function se2(e3, t2, n2, r2, o2, a, l, s4) {
  try {
    e3.next().then((c) => {
      try {
        if (null === c)
          a(k2);
        else {
          const u2 = g.createFromGraphicLikeObject(c.geometry, c.attributes, r2);
          u2._underlyingGraphic = c, o2.value = u2;
          J3(t2, n2.body).then((i) => {
            try {
              i === j ? a(k2) : i instanceof D ? a(i) : ++s4 > W2 ? (s4 = 0, setTimeout(() => {
                se2(e3, t2, n2, r2, o2, a, l, s4);
              }, 0)) : se2(e3, t2, n2, r2, o2, a, l, s4);
            } catch (c2) {
              l(c2);
            }
          }, (e4) => {
            l(e4);
          });
        }
      } catch (u2) {
        l(u2);
      }
    }, (e4) => {
      l(e4);
    });
  } catch (c) {
    l(c);
  }
}
async function ce(e3, t2) {
  return new Promise((a, i) => {
    J3(e3, t2.right).then((l) => {
      try {
        let s4 = null;
        s4 = "VariableDeclaration" === t2.left.type ? J3(e3, t2.left) : Promise.resolve(), s4.then(() => {
          try {
            let s5 = "";
            if ("VariableDeclaration" === t2.left.type) {
              const e4 = t2.left.declarations[0].id;
              "Identifier" === e4.type && (s5 = e4.name);
            } else
              "Identifier" === t2.left.type && (s5 = t2.left.name);
            if (!s5)
              throw new t(e3, e.InvalidIdentifier, t2);
            s5 = s5.toLowerCase();
            let c = null;
            if (null != e3.localScope && void 0 !== e3.localScope[s5] && (c = e3.localScope[s5]), null === c && void 0 !== e3.globalScope[s5] && (c = e3.globalScope[s5]), null === c)
              return void i(new t(e3, e.InvalidIdentifier, t2));
            Y(l) || w(l) ? ae(e3, t2, l, { reject: i, resolve: a }, c) : E(l) ? ie(e3, t2, l, { reject: i, resolve: a }, c) : l instanceof J2 || J(l) ? le(e3, t2, l, { reject: i, resolve: a }, c) : P(l) ? se2(l.iterator(e3.abortSignal), e3, t2, l, c, (e4) => {
              a(e4);
            }, (e4) => {
              i(e4);
            }, 0) : ae(e3, t2, [], { reject: i, resolve: a }, c);
          } catch (s5) {
            i(s5);
          }
        }, i);
      } catch (s4) {
        i(s4);
      }
    }, i);
  });
}
async function ue(e3, t2) {
  const a = t2.argument;
  if ("MemberExpression" === a.type) {
    const i2 = { t: null }, l2 = await J3(e3, a.object);
    let s4 = null;
    i2.t = l2, true === a.computed ? s4 = await J3(e3, a.property) : "Identifier" === a.property.type && (s4 = a.property.name);
    const c = i2.t;
    let u2;
    if (Y(c)) {
      if (!Z(s4))
        throw new t(e3, e.ArrayAccessorMustBeNumber, t2);
      if (s4 < 0 && (s4 = c.length + s4), s4 < 0 || s4 >= c.length)
        throw new t(e3, e.OutOfBounds, t2);
      u2 = re(c[s4]), c[s4] = "++" === t2.operator ? u2 + 1 : u2 - 1;
    } else if (c instanceof J2) {
      if (false === w(s4))
        throw new t(e3, e.KeyAccessorMustBeString, t2);
      if (true !== c.hasField(s4))
        throw new t(e3, e.FieldNotFound, t2, { key: s4 });
      u2 = re(c.field(s4)), c.setField(s4, "++" === t2.operator ? u2 + 1 : u2 - 1);
    } else if (c instanceof z) {
      if (false === w(s4))
        throw new t(e3, e.ModuleAccessorMustBeString, t2);
      if (true !== c.hasGlobal(s4))
        throw new t(e3, e.ModuleExportNotFound, t2);
      u2 = re(await c.global(s4)), c.setGlobal(s4, "++" === t2.operator ? u2 + 1 : u2 - 1);
    } else {
      if (!J(c))
        throw E(c) ? new t(e3, e.Immutable, t2) : new t(e3, e.InvalidParameter, t2);
      if (false === w(s4))
        throw new t(e3, e.KeyAccessorMustBeString, t2);
      if (true !== c.hasField(s4))
        throw new t(e3, e.FieldNotFound, t2, { key: s4 });
      u2 = re(c.field(s4)), c.setField(s4, "++" === t2.operator ? u2 + 1 : u2 - 1);
    }
    return false === t2.prefix ? u2 : "++" === t2.operator ? u2 + 1 : u2 - 1;
  }
  const i = "Identifier" === t2.argument.type ? t2.argument.name.toLowerCase() : "";
  if (!i)
    throw new t(e3, e.InvalidIdentifier, t2);
  let l;
  if (null != e3.localScope && void 0 !== e3.localScope[i])
    return l = re(e3.localScope[i].value), e3.localScope[i] = { value: "++" === t2.operator ? l + 1 : l - 1, valueset: true, node: t2 }, false === t2.prefix ? l : "++" === t2.operator ? l + 1 : l - 1;
  if (void 0 !== e3.globalScope[i])
    return l = re(e3.globalScope[i].value), e3.globalScope[i] = { value: "++" === t2.operator ? l + 1 : l - 1, valueset: true, node: t2 }, false === t2.prefix ? l : "++" === t2.operator ? l + 1 : l - 1;
  throw new t(e3, e.InvalidIdentifier, t2);
}
function fe(e3, t2, n2, a, i) {
  switch (t2) {
    case "=":
      return e3 === k2 ? null : e3;
    case "/=":
      return re(n2) / re(e3);
    case "*=":
      return re(n2) * re(e3);
    case "-=":
      return re(n2) - re(e3);
    case "+=":
      return w(n2) || w(e3) ? K(n2) + K(e3) : re(n2) + re(e3);
    case "%=":
      return re(n2) % re(e3);
    default:
      throw new t(i, e.UnsupportedOperator, a);
  }
}
async function pe(e3, t2) {
  const a = t2.left;
  if ("MemberExpression" === a.type) {
    const i2 = await J3(e3, t2.right), l = await J3(e3, a.object);
    let s4 = null;
    if (true === a.computed)
      s4 = await J3(e3, a.property);
    else {
      if ("Identifier" !== a.property.type)
        throw new t(e3, e.InvalidIdentifier, t2);
      s4 = a.property.name;
    }
    if (Y(l)) {
      if (!Z(s4))
        throw new t(e3, e.ArrayAccessorMustBeNumber, t2);
      if (s4 < 0 && (s4 = l.length + s4), s4 < 0 || s4 > l.length)
        throw new t(e3, e.OutOfBounds, t2);
      if (s4 === l.length) {
        if ("=" !== t2.operator)
          throw new t(e3, e.OutOfBounds, t2);
        l[s4] = fe(i2, t2.operator, l[s4], t2, e3);
      } else
        l[s4] = fe(i2, t2.operator, l[s4], t2, e3);
    } else if (l instanceof J2) {
      if (false === w(s4))
        throw new t(e3, e.KeyAccessorMustBeString, t2);
      if (true === l.hasField(s4))
        l.setField(s4, fe(i2, t2.operator, l.field(s4), t2, e3));
      else {
        if ("=" !== t2.operator)
          throw new t(e3, e.FieldNotFound, t2, { key: s4 });
        l.setField(s4, fe(i2, t2.operator, null, t2, e3));
      }
    } else if (l instanceof z) {
      if (false === w(s4))
        throw new t(e3, e.KeyAccessorMustBeString, t2);
      if (true !== l.hasGlobal(s4))
        throw new t(e3, e.ModuleExportNotFound, t2);
      l.setGlobal(s4, fe(i2, t2.operator, await l.global(s4), t2, e3));
    } else {
      if (!J(l))
        throw E(l) ? new t(e3, e.Immutable, t2) : new t(e3, e.InvalidParameter, t2);
      if (false === w(s4))
        throw new t(e3, e.KeyAccessorMustBeString, t2);
      if (true === l.hasField(s4))
        l.setField(s4, fe(i2, t2.operator, l.field(s4), t2, e3));
      else {
        if ("=" !== t2.operator)
          throw new t(e3, e.FieldNotFound, t2, { key: s4 });
        l.setField(s4, fe(i2, t2.operator, null, t2, e3));
      }
    }
    return k2;
  }
  const i = a.name.toLowerCase();
  if (null != e3.localScope && void 0 !== e3.localScope[i]) {
    const n2 = await J3(e3, t2.right);
    return e3.localScope[i] = { value: fe(n2, t2.operator, e3.localScope[i].value, t2, e3), valueset: true, node: t2.right }, k2;
  }
  if (void 0 !== e3.globalScope[i]) {
    const n2 = await J3(e3, t2.right);
    return e3.globalScope[i] = { value: fe(n2, t2.operator, e3.globalScope[i].value, t2, e3), valueset: true, node: t2.right }, k2;
  }
  throw new t(e3, e.InvalidIdentifier, t2);
}
async function we(e3, t2) {
  if ("AssignmentExpression" === t2.expression.type)
    return J3(e3, t2.expression);
  if ("CallExpression" === t2.expression.type) {
    const n3 = await J3(e3, t2.expression);
    return n3 === k2 ? k2 : new N(n3);
  }
  const n2 = await J3(e3, t2.expression);
  return n2 === k2 ? k2 : new N(n2);
}
async function de(e3, t2) {
  const n2 = await J3(e3, t2.test);
  if (true === n2)
    return J3(e3, t2.consequent);
  if (false === n2)
    return null !== t2.alternate ? J3(e3, t2.alternate) : k2;
  throw new t(e3, e.BooleanConditionRequired, t2);
}
async function he(e3, t2) {
  return me(e3, t2, 0);
}
async function me(e3, t2, n2) {
  if (n2 >= t2.body.length)
    return k2;
  const r2 = await J3(e3, t2.body[n2]);
  return r2 instanceof D || r2 === j || r2 === A || n2 === t2.body.length - 1 ? r2 : me(e3, t2, n2 + 1);
}
async function ge(e3, t2) {
  if (null === t2.argument)
    return new D(k2);
  const n2 = await J3(e3, t2.argument);
  return new D(n2);
}
async function ye(e3, t2) {
  const n2 = t2.id.name.toLowerCase();
  return e3.globalScope[n2] = { valueset: true, node: null, value: new Y2(t2, e3) }, k2;
}
async function ve(e3, t2) {
  var _a, _b;
  const n2 = t2.specifiers[0].local.name.toLowerCase(), r2 = e3.libraryResolver.loadLibrary(n2);
  let o2 = null;
  return ((_a = e3.libraryResolver._moduleSingletons) == null ? void 0 : _a.has(r2.uri)) ? o2 = e3.libraryResolver._moduleSingletons.get(r2.uri) : (o2 = new z(r2), await o2.loadModule(e3), (_b = e3.libraryResolver._moduleSingletons) == null ? void 0 : _b.set(r2.uri, o2)), e3.globalScope[n2] = { value: o2, valueset: true, node: t2 }, k2;
}
async function be(e3, t2) {
  if (await J3(e3, t2.declaration), "FunctionDeclaration" === t2.declaration.type)
    e3.exports[t2.declaration.id.name.toLowerCase()] = "function";
  else if ("VariableDeclaration" === t2.declaration.type)
    for (const n2 of t2.declaration.declarations)
      e3.exports[n2.id.name.toLowerCase()] = "variable";
  return k2;
}
async function Se(e3, t2, n2) {
  return n2 >= t2.declarations.length ? k2 : (await J3(e3, t2.declarations[n2]), n2 === t2.declarations.length - 1 || await Se(e3, t2, n2 + 1), k2);
}
async function xe(e3, t2) {
  let n2 = null;
  if (n2 = null === t2.init ? null : await J3(e3, t2.init), null !== e3.localScope) {
    if (n2 === k2 && (n2 = null), "Identifier" !== t2.id.type)
      throw new t(e3, e.InvalidIdentifier, t2);
    const a2 = t2.id.name.toLowerCase();
    return null != e3.localScope && (e3.localScope[a2] = { value: n2, valueset: true, node: t2.init }), k2;
  }
  if ("Identifier" !== t2.id.type)
    throw new t(e3, e.InvalidIdentifier, t2);
  const a = t2.id.name.toLowerCase();
  return n2 === k2 && (n2 = null), e3.globalScope[a] = { value: n2, valueset: true, node: t2.init }, k2;
}
async function Ie(e3, t2) {
  const a = await J3(e3, t2.object);
  if (null === a)
    throw new t(e3, e.MemberOfNull, t2);
  if (false === t2.computed) {
    if ("Identifier" === t2.property.type) {
      if (a instanceof J2 || J(a))
        return a.field(t2.property.name);
      if (a instanceof p)
        return W(a, t2.property.name, e3, t2);
      if (a instanceof z) {
        if (!a.hasGlobal(t2.property.name))
          throw new t(e3, e.InvalidIdentifier, t2);
        return a.global(t2.property.name);
      }
      throw new t(e3, e.InvalidMemberAccessKey, t2);
    }
    throw new t(e3, e.InvalidMemberAccessKey, t2);
  }
  let i = await J3(e3, t2.property);
  if (a instanceof J2 || J(a)) {
    if (w(i))
      return a.field(i);
    throw new t(e3, e.InvalidMemberAccessKey, t2);
  }
  if (a instanceof z) {
    if (w(i))
      return a.global(i);
    throw new t(e3, e.InvalidMemberAccessKey, t2);
  }
  if (a instanceof p) {
    if (w(i))
      return W(a, i, e3, t2);
    throw new t(e3, e.InvalidMemberAccessKey, t2);
  }
  if (Y(a)) {
    if (Z(i) && isFinite(i) && Math.floor(i) === i) {
      if (i < 0 && (i = a.length + i), i >= a.length || i < 0)
        throw new t(e3, e.OutOfBounds, t2);
      return a[i];
    }
    throw new t(e3, e.InvalidMemberAccessKey, t2);
  }
  if (E(a)) {
    if (Z(i) && isFinite(i) && Math.floor(i) === i) {
      if (i < 0 && (i = a.length() + i), i >= a.length() || i < 0)
        throw new t(e3, e.OutOfBounds, t2);
      return a.get(i);
    }
    throw new t(e3, e.InvalidMemberAccessKey, t2);
  }
  if (w(a)) {
    if (Z(i) && isFinite(i) && Math.floor(i) === i) {
      if (i < 0 && (i = a.length + i), i >= a.length || i < 0)
        throw new t(e3, e.OutOfBounds, t2);
      return a[i];
    }
    throw new t(e3, e.InvalidMemberAccessKey, t2);
  }
  throw new t(e3, e.InvalidMemberAccessKey, t2);
}
async function Fe(e3, t2) {
  const n2 = await J3(e3, t2.argument);
  if (_(n2)) {
    if ("!" === t2.operator)
      return !n2;
    if ("-" === t2.operator)
      return -1 * re(n2);
    if ("+" === t2.operator)
      return 1 * re(n2);
    if ("~" === t2.operator)
      return ~re(n2);
    throw new t(e3, e.UnsupportedUnaryOperator, t2);
  }
  if ("-" === t2.operator)
    return -1 * re(n2);
  if ("+" === t2.operator)
    return 1 * re(n2);
  if ("~" === t2.operator)
    return ~re(n2);
  throw new t(e3, e.UnsupportedUnaryOperator, t2);
}
async function Ce(e3, t2) {
  const n2 = [];
  for (let r2 = 0; r2 < t2.elements.length; r2++)
    n2.push(await J3(e3, t2.elements[r2]));
  for (let a = 0; a < n2.length; a++) {
    if (F(n2[a]))
      throw new t(e3, e.NoFunctionInArray, t2);
    n2[a] === k2 && (n2[a] = null);
  }
  return n2;
}
async function Re(e3, t2) {
  const n2 = [];
  n2[0] = await J3(e3, t2.left), n2[1] = await J3(e3, t2.right);
  const a = n2[0], i = n2[1];
  switch (t2.operator) {
    case "|":
    case "<<":
    case ">>":
    case ">>>":
    case "^":
    case "&":
      return Ne(re(a), re(i), t2.operator);
    case "==":
      return X(a, i);
    case "!=":
      return !X(a, i);
    case "<":
    case ">":
    case "<=":
    case ">=":
      return Q(a, i, t2.operator);
    case "+":
      return w(a) || w(i) ? K(a) + K(i) : re(a) + re(i);
    case "-":
      return re(a) - re(i);
    case "*":
      return re(a) * re(i);
    case "/":
      return re(a) / re(i);
    case "%":
      return re(a) % re(i);
    default:
      throw new t(e3, e.UnsupportedOperator, t2);
  }
}
async function Ae(e3, t2) {
  const n2 = await J3(e3, t2.left);
  let a = null;
  if (!_(n2))
    throw new t(e3, e.LogicalExpressionOnlyBoolean, t2);
  switch (t2.operator) {
    case "||":
      if (true === n2)
        return n2;
      if (a = await J3(e3, t2.right), _(a))
        return a;
      throw new t(e3, e.LogicExpressionOrAnd, t2);
    case "&&":
      if (false === n2)
        return n2;
      if (a = await J3(e3, t2.right), _(a))
        return a;
      throw new t(e3, e.LogicExpressionOrAnd, t2);
    default:
      throw new t(e3, e.LogicExpressionOrAnd, t2);
  }
}
async function Me(e3, t2) {
  const n2 = t2.name.toLowerCase();
  if (null != e3.localScope && void 0 !== e3.localScope[n2]) {
    const t3 = e3.localScope[n2];
    if (true === t3.valueset)
      return t3.value;
    if (null !== t3.d)
      return t3.d;
    t3.d = J3(e3, t3.node);
    const r2 = await t3.d;
    return t3.value = r2, t3.valueset = true, r2;
  }
  if (void 0 !== e3.globalScope[n2]) {
    const t3 = e3.globalScope[n2];
    if (true === t3.valueset)
      return t3.value;
    if (null !== t3.d)
      return t3.d;
    t3.d = J3(e3, t3.node);
    const r2 = await t3.d;
    return t3.value = r2, t3.valueset = true, r2;
  }
  throw new t(e3, e.InvalidIdentifier, t2);
}
async function je(e3, t2) {
  if ("MemberExpression" === t2.callee.type) {
    const n2 = await J3(e3, t2.callee.object);
    if (!(n2 instanceof z))
      throw new t(e3, e.FuncionNotFound, t2);
    const a = false === t2.callee.computed ? t2.callee.property.name : await J3(e3, t2.callee.property);
    if (!n2.hasGlobal(a))
      throw new t(e3, e.FuncionNotFound, t2);
    const i = await n2.global(a);
    if (!F(i))
      throw new t(e3, e.CallNonFunction, t2);
    return i.call(e3, t2);
  }
  if ("Identifier" !== t2.callee.type)
    throw new t(e3, e.FuncionNotFound, t2);
  if (null != e3.localScope && void 0 !== e3.localScope[t2.callee.name.toLowerCase()]) {
    const n2 = e3.localScope[t2.callee.name.toLowerCase()];
    if (F(n2.value))
      return n2.value.call(e3, t2);
    throw new t(e3, e.CallNonFunction, t2);
  }
  if (void 0 !== e3.globalScope[t2.callee.name.toLowerCase()]) {
    const n2 = e3.globalScope[t2.callee.name.toLowerCase()];
    if (F(n2.value))
      return n2.value.call(e3, t2);
    throw new t(e3, e.CallNonFunction, t2);
  }
  throw new t(e3, e.FuncionNotFound, t2);
}
async function Le(e3, t2) {
  return t2.value ? t2.value.cooked : "";
}
function ke(e3, t2, n2) {
  if (F(e3))
    throw new t(t2, e.NoFunctionInTemplateLiteral, n2);
  return e3;
}
async function Ne2(e3, t2) {
  const n2 = [];
  for (let a = 0; a < t2.expressions.length; a++) {
    const r3 = await J3(e3, t2.expressions[a]);
    n2[a] = K(r3);
  }
  let r2 = "", o2 = 0;
  for (const a of t2.quasis)
    if (r2 += a.value ? a.value.cooked : "", false === a.tail) {
      r2 += n2[o2] ? ke(n2[o2], e3, t2) : "", o2++;
    }
  return r2;
}
var Oe = {};
async function Ee(e3, t2, n2, r2) {
  const o2 = await J3(e3, t2.arguments[n2]);
  if (X(o2, r2))
    return J3(e3, t2.arguments[n2 + 1]);
  const a = t2.arguments.length - n2;
  return 1 === a ? J3(e3, t2.arguments[n2]) : 2 === a ? null : 3 === a ? J3(e3, t2.arguments[n2 + 2]) : Ee(e3, t2, n2 + 2, r2);
}
async function Be(e3, t2, n2, a) {
  if (true === a)
    return J3(e3, t2.arguments[n2 + 1]);
  if (3 === t2.arguments.length - n2)
    return J3(e3, t2.arguments[n2 + 2]);
  const i = await J3(e3, t2.arguments[n2 + 2]);
  if (false === _(i))
    throw new t(e3, e.ModuleExportNotFound, t2.arguments[n2 + 2]);
  return Be(e3, t2, n2 + 2, i);
}
async function Pe(e3, t2, n2, a) {
  const i = e3.body;
  if (n2.length !== e3.params.length)
    throw new t(t2, e.WrongNumberOfParameters, null);
  for (let r2 = 0; r2 < n2.length; r2++) {
    const o2 = e3.params[r2];
    "Identifier" === o2.type && null != t2.localScope && (t2.localScope[o2.name.toLowerCase()] = { d: null, value: n2[r2], valueset: true, node: null });
  }
  const l = await J3(t2, i);
  if (l instanceof D)
    return l.value;
  if (l === j)
    throw new t(t2, e.UnexpectedToken, a);
  if (l === A)
    throw new t(t2, e.UnexpectedToken, a);
  return l instanceof N ? l.value : l;
}
M(Oe, _2), B(Oe, _2), N2(Oe, _2), C(Oe, _2), f(Oe, _2), dn({ functions: Oe, compiled: false, signatures: null, evaluateIdentifier: null, mode: "async", standardFunction: _2, standardFunctionAsync: H }), Oe.iif = async function(e3, t2) {
  V(null === t2.arguments ? [] : t2.arguments, 3, 3, e3, t2);
  const n2 = await J3(e3, t2.arguments[0]);
  if (false === _(n2))
    throw new t(e3, e.BooleanConditionRequired, t2);
  return J3(e3, n2 ? t2.arguments[1] : t2.arguments[2]);
}, Oe.decode = async function(e3, t2) {
  if (t2.arguments.length < 2)
    throw new t(e3, e.WrongNumberOfParameters, t2);
  if (2 === t2.arguments.length)
    return J3(e3, t2.arguments[1]);
  if ((t2.arguments.length - 1) % 2 == 0)
    throw new t(e3, e.WrongNumberOfParameters, t2);
  return Ee(e3, t2, 1, await J3(e3, t2.arguments[0]));
}, Oe.when = async function(e3, t2) {
  if (t2.arguments.length < 3)
    throw new t(e3, e.WrongNumberOfParameters, t2);
  if (t2.arguments.length % 2 == 0)
    throw new t(e3, e.WrongNumberOfParameters, t2);
  const n2 = await J3(e3, t2.arguments[0]);
  if (false === _(n2))
    throw new t(e3, e.BooleanConditionRequired, t2.arguments[0]);
  return Be(e3, t2, 0, n2);
};
var Ke = { fixSpatialReference: se, parseArguments: V2, standardFunction: _2, standardFunctionAsync: H, evaluateIdentifier: Me };
for (const Ve in Oe)
  Oe[Ve] = { value: new e2(Oe[Ve]), valueset: true, node: null };
var De = function() {
};
function Ge(e3, t2) {
  const r2 = new De();
  null == e3 && (e3 = {}), null == t2 && (t2 = {});
  const o2 = new J2({ newline: "\n", tab: "	", singlequote: "'", doublequote: '"', forwardslash: "/", backwardslash: "\\" });
  o2.immutable = false, r2.textformatting = { value: o2, valueset: true, node: null };
  for (const n2 in t2)
    r2[n2] = { value: new e2(t2[n2]), native: true, valueset: true, node: null };
  for (const n2 in e3)
    e3[n2] && "esri.Graphic" === e3[n2].declaredClass ? r2[n2] = { value: g.createFromGraphic(e3[n2]), valueset: true, node: null } : r2[n2] = { value: e3[n2], valueset: true, node: null };
  return r2;
}
function Te(e3) {
  console.log(e3);
}
De.prototype = Oe, De.prototype.infinity = { value: Number.POSITIVE_INFINITY, valueset: true, node: null }, De.prototype.pi = { value: Math.PI, valueset: true, node: null };
var Ue = Ke;
function qe(e3) {
  const t2 = { mode: "async", compiled: false, functions: {}, signatures: [], standardFunction: _2, standardFunctionAsync: H, evaluateIdentifier: Me };
  for (let n2 = 0; n2 < e3.length; n2++)
    e3[n2].registerFunctions(t2);
  for (const n2 in t2.functions)
    Oe[n2] = { value: new e2(t2.functions[n2]), valueset: true, node: null }, De.prototype[n2] = Oe[n2];
  for (let n2 = 0; n2 < t2.signatures.length; n2++)
    o(t2.signatures[n2], "async");
}
async function We(e3, n2) {
  let a = n2.spatialReference;
  null == a && (a = new k({ wkid: 102100 }));
  let i = null;
  e3.usesModules && (i = new s3(/* @__PURE__ */ new Map(), e3.loadedModules));
  const l = Ge(n2.vars, n2.customfunctions), s4 = { spatialReference: a, services: n2.services, exports: {}, libraryResolver: i, abortSignal: void 0 === n2.abortSignal || null === n2.abortSignal ? { aborted: false } : n2.abortSignal, globalScope: l, console: n2.console ? n2.console : Te, lrucache: n2.lrucache, interceptor: n2.interceptor, localScope: null, depthCounter: { depth: 1 } };
  let c = await J3(s4, e3);
  if (c instanceof D && (c = c.value), c instanceof N && (c = c.value), c === k2 && (c = null), c === j)
    throw new t(s4, e.IllegalResult, null);
  if (c === A)
    throw new t(s4, e.IllegalResult, null);
  if (F(c))
    throw new t(s4, e.IllegalResult, null);
  return c;
}
qe([m]);
export {
  We as executeScript,
  qe as extend,
  Ue as functionHelper
};
//# sourceMappingURL=arcadeAsyncRuntime-OBVVL7W4.js.map
