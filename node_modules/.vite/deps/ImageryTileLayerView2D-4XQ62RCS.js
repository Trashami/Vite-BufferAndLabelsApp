import {
  d as d3,
  y as y4
} from "./chunk-A2S4JS7P.js";
import {
  i as i2,
  r as r3
} from "./chunk-QXJIQKLY.js";
import {
  d as d2,
  n3 as n2,
  p
} from "./chunk-GRWIJKD6.js";
import "./chunk-WGK2FJEK.js";
import "./chunk-CNTOSDAN.js";
import {
  r as r4
} from "./chunk-Q5IFLFM5.js";
import {
  i as i3
} from "./chunk-VPBDKONJ.js";
import {
  y as y3
} from "./chunk-L4LV52OG.js";
import {
  u as u3
} from "./chunk-PCWW275T.js";
import "./chunk-7N2Z7KNR.js";
import "./chunk-DBT4KOKX.js";
import "./chunk-EPMXCACW.js";
import "./chunk-KG5RWWIW.js";
import "./chunk-27YO3FKC.js";
import "./chunk-6TBB7UXB.js";
import "./chunk-UO3LS2M5.js";
import {
  I
} from "./chunk-EQNT4A7P.js";
import "./chunk-2GP5D74I.js";
import "./chunk-QISOH77W.js";
import "./chunk-XO5VJRK4.js";
import {
  a,
  f,
  g as g4,
  u as u2
} from "./chunk-PHSKOWOP.js";
import {
  J,
  U as U2,
  ie,
  v
} from "./chunk-DQCR5QA4.js";
import {
  m
} from "./chunk-367STH4F.js";
import {
  j as j3
} from "./chunk-OYDVEVDU.js";
import {
  g as g3,
  s as s5
} from "./chunk-OAXPH6DL.js";
import "./chunk-O4DPVR3F.js";
import "./chunk-MATM5L52.js";
import "./chunk-4OM3EX6P.js";
import {
  s as s4
} from "./chunk-E24JZEAW.js";
import "./chunk-3OFVLRSL.js";
import "./chunk-UWKVAZQ6.js";
import "./chunk-FV3CMB37.js";
import {
  mt
} from "./chunk-FVJU3I6I.js";
import "./chunk-VHXWATHW.js";
import "./chunk-7DLBSBVE.js";
import {
  r as r2
} from "./chunk-4XFEPZ26.js";
import {
  y as y2
} from "./chunk-FERTI5PU.js";
import {
  h as h2
} from "./chunk-VWCRJ6R6.js";
import "./chunk-MKNNZ33G.js";
import "./chunk-JQUWFKNU.js";
import {
  l as l2
} from "./chunk-GX2FDWTU.js";
import "./chunk-TFHLTN6F.js";
import "./chunk-UDYHZLTE.js";
import {
  e as e3
} from "./chunk-IQBIGNPU.js";
import "./chunk-4JNOVZUK.js";
import {
  i,
  s as s3
} from "./chunk-ZNRXLY4R.js";
import "./chunk-RG3AHHRL.js";
import "./chunk-75RMBUYZ.js";
import "./chunk-TJ2I6XQT.js";
import "./chunk-EDHROVWI.js";
import "./chunk-34YPGGJT.js";
import {
  j as j2
} from "./chunk-OOOPZLJE.js";
import "./chunk-U2WD23Z5.js";
import "./chunk-ZEEU5HOK.js";
import "./chunk-FFVIDMFN.js";
import "./chunk-VQXS4XNR.js";
import "./chunk-ZN2ROKCE.js";
import "./chunk-INL7BDTP.js";
import {
  g
} from "./chunk-YGVY4EIZ.js";
import "./chunk-NDQ5FHGV.js";
import "./chunk-ZWUEORSX.js";
import "./chunk-US2IWMHE.js";
import "./chunk-QWNKYSI4.js";
import "./chunk-ZPYDYUP5.js";
import "./chunk-AIDV7EKX.js";
import "./chunk-FZQZIM7U.js";
import "./chunk-YM6PUX7G.js";
import "./chunk-QEYOWTXD.js";
import "./chunk-CZBRZ6SU.js";
import "./chunk-KDO6J2FO.js";
import "./chunk-RT3T2K4S.js";
import "./chunk-WJCI2CGX.js";
import {
  d
} from "./chunk-REIQNAQW.js";
import {
  g as g2
} from "./chunk-J6LQZWZI.js";
import "./chunk-OD3FDQCI.js";
import "./chunk-J2PJNRU7.js";
import "./chunk-56SPM3WK.js";
import "./chunk-XMZAPOBR.js";
import "./chunk-BLJKKR5D.js";
import "./chunk-ZGNCYHMZ.js";
import "./chunk-X2S4RQJ4.js";
import "./chunk-FUPLN7UM.js";
import "./chunk-376OPXM4.js";
import "./chunk-DER356EU.js";
import "./chunk-MZIWIEIR.js";
import "./chunk-TQEOEDAZ.js";
import "./chunk-SHFHZMHO.js";
import "./chunk-NRP45AHD.js";
import "./chunk-IWQ7452U.js";
import "./chunk-NAN5J6QS.js";
import "./chunk-B4DKBAM3.js";
import {
  u
} from "./chunk-6M2AHKYV.js";
import "./chunk-SZIJNKCV.js";
import "./chunk-6O43OEU5.js";
import "./chunk-J2K7ZDSV.js";
import "./chunk-2UML3WQZ.js";
import "./chunk-KXVMEIWT.js";
import "./chunk-UDND2Z3V.js";
import "./chunk-23Y3DIC6.js";
import "./chunk-JUVQV3R3.js";
import "./chunk-RAX2HD42.js";
import "./chunk-ZYRIJWLX.js";
import "./chunk-C5H57NTD.js";
import "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import "./chunk-YWAQYJRC.js";
import "./chunk-B356PXLT.js";
import "./chunk-EHPBHJYZ.js";
import "./chunk-3MNMDUQZ.js";
import {
  w,
  w2
} from "./chunk-UWG37XSU.js";
import "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import "./chunk-HLM6QCL2.js";
import "./chunk-RXYULINL.js";
import {
  U,
  h,
  l,
  w as w3
} from "./chunk-5NXILPDI.js";
import "./chunk-THVR7IAM.js";
import "./chunk-ZWJJTUFL.js";
import "./chunk-XQN7F674.js";
import "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import "./chunk-KAN4HXCG.js";
import "./chunk-4FEGON7M.js";
import "./chunk-VWYWOOPX.js";
import "./chunk-M5VHU5LK.js";
import "./chunk-CXFRNDG4.js";
import "./chunk-7QMMKGW4.js";
import {
  e as e2,
  n2 as n,
  y
} from "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import {
  E,
  j,
  x
} from "./chunk-MJXQTGI2.js";
import {
  s as s2
} from "./chunk-LIZHLHNA.js";
import "./chunk-BTUHYGXO.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";
import "./chunk-HVKDYDPP.js";
import "./chunk-6QC7MLLS.js";
import {
  e,
  r,
  t
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/views/2d/engine/imagery/RasterTile.js
var i4 = class extends r3 {
  constructor(t2, e4, i5, r6, a2, n6, m2 = null) {
    super(t2, e4, i5, r6, a2, n6), this.bitmap = new p(m2, null, null), this.bitmap.coordScale = [a2, n6], this.bitmap.once("isReady", () => this.ready());
  }
  destroy() {
    super.destroy(), this.bitmap.destroy(), this.bitmap = null, this.stage = null;
  }
  set stencilRef(t2) {
    this.bitmap.stencilRef = t2;
  }
  get stencilRef() {
    return this.bitmap.stencilRef;
  }
  setTransform(t2) {
    super.setTransform(t2), this.bitmap.transforms.dvs = this.transforms.dvs;
  }
  _createTransforms() {
    return { dvs: e3(), tileMat3: e3() };
  }
  onAttach() {
    this.bitmap.stage = this.stage;
  }
  onDetach() {
    this.bitmap.stage = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/imagery/RasterTileContainer.js
var n3 = class extends i2 {
  constructor() {
    super(...arguments), this.isCustomTilingScheme = false;
  }
  createTile(e4) {
    const s6 = this._getTileBounds(e4), [i5, r6] = this._tileInfoView.tileInfo.size, o2 = this._tileInfoView.getTileResolution(e4.level);
    return new i4(e4, o2, s6[0], s6[3], i5, r6);
  }
  prepareRenderPasses(e4) {
    const s6 = e4.registerRenderPass({ name: "imagery (tile)", brushes: [n2.raster], target: () => this.children.map((e5) => e5.bitmap), drawPhase: I.MAP });
    return [...super.prepareRenderPasses(e4), s6];
  }
  doRender(e4) {
    this.visible && e4.drawPhase === I.MAP && super.doRender(e4);
  }
  _getTileBounds(i5) {
    const t2 = this._tileInfoView.getTileBounds(u(), i5);
    if (this.isCustomTilingScheme && i5.world) {
      const { tileInfo: e4 } = this._tileInfoView, r6 = mt(e4.spatialReference);
      if (r6) {
        const { resolution: s6 } = e4.lodAt(i5.level), o2 = r6 / s6 % e4.size[0], n6 = o2 ? (e4.size[0] - o2) * s6 : 0;
        t2[0] -= n6 * i5.world, t2[2] -= n6 * i5.world;
      }
    }
    return t2;
  }
};

// node_modules/@arcgis/core/views/2d/layers/imagery/BaseImageryTileSubView2D.js
var v2 = [0, 0];
var T = class extends d {
  constructor() {
    super(...arguments), this._emptyTilePixelBlock = null, this._tileStrategy = null, this._tileInfoView = null, this._fetchQueue = null, this._blockCacheRegistryUrl = null, this._blockCacheRegistryId = null, this._srcResolutions = null, this.previousLOD = null, this._needBlockCacheUpdate = false, this._globalSymbolizerParams = null, this._symbolizerParams = null, this._abortController = null, this._isCustomTilingScheme = false, this._globalUpdateRequested = false, this.attached = false, this.container = null, this.layer = null, this.timeExtent = null, this.redrawOrRefetch = x((e4, t2) => !this.previousLOD || this.layerView.suspended ? Promise.resolve() : e4 ? this.updatingHandles.addPromise(this.doRefresh()) : this.updatingHandles.addPromise(this._redrawImage(t2)));
  }
  get useWebGLForProcessing() {
    var _a;
    return (_a = this._get("useWebGLForProcessing")) != null ? _a : true;
  }
  set useWebGLForProcessing(e4) {
    this._set("useWebGLForProcessing", e4);
  }
  get useProgressiveUpdate() {
    return null == this._get("useProgressiveUpdate") || this._get("useProgressiveUpdate");
  }
  set useProgressiveUpdate(e4) {
    if (this._tileStrategy && this.useProgressiveUpdate !== e4) {
      this._tileStrategy.destroy(), this.container.removeAllChildren();
      const t2 = this._getCacheSize(e4);
      this._tileStrategy = new r2({ cachePolicy: "purge", acquireTile: (e5) => this.acquireTile(e5), releaseTile: (e5) => this.releaseTile(e5), cacheSize: t2, tileInfoView: this._tileInfoView }), this._set("useProgressiveUpdate", e4), this.layerView.requestUpdate();
    }
  }
  update(e4) {
    var _a;
    this._fetchQueue.pause(), this._fetchQueue.state = e4.state, this._tileStrategy.update(e4), this._fetchQueue.resume();
    const { extent: t2, resolution: i5, scale: s6 } = e4.state, r6 = this._tileInfoView.getClosestInfoForScale(s6);
    if (this.layer.raster) {
      if (!this.useProgressiveUpdate || this._needBlockCacheUpdate) {
        const e5 = this._srcResolutions[r6.level], s7 = t2.toJSON ? t2 : w2.fromJSON(t2);
        g4(this._blockCacheRegistryUrl, this._blockCacheRegistryId, s7, i5, e5, this.layer.raster.ioConfig.sampling);
      }
      this._needBlockCacheUpdate = false, ((_a = this.previousLOD) == null ? void 0 : _a.level) !== r6.level && (this.previousLOD = r6, null == this._symbolizerParams || this.layerView.hasTilingEffects || this._updateSymbolizerParams(), this._tileStrategy.updateCacheSize(0));
    }
  }
  moveEnd() {
    !this.layerView.hasTilingEffects && this.useProgressiveUpdate || (this._abortController && this._abortController.abort(), this._abortController = new AbortController(), 0 === this._fetchQueue.length && this._redrawImage(this._abortController.signal).then(() => {
      this._globalUpdateRequested = false, this.layerView.requestUpdate();
    }));
    const e4 = this._getCacheSize(this.useProgressiveUpdate);
    this._tileStrategy.updateCacheSize(e4), this.layerView.requestUpdate();
  }
  get updating() {
    var _a;
    return ((_a = this._fetchQueue) == null ? void 0 : _a.updating) || this._globalUpdateRequested || !(!this.updatingHandles || !this.updatingHandles.updating);
  }
  attach() {
    l2("2d").supportsTextureFloat || (this.useWebGLForProcessing = false), this._initializeTileInfo(), this._tileInfoView = new h2(this.layerView.tileInfo, this.layerView.fullExtent);
    const e4 = this._computeFetchConcurrency();
    this._fetchQueue = new y2({ tileInfoView: this._tileInfoView, concurrency: e4, process: (e5, t3) => this._fetchTile1(e5, t3) });
    const t2 = this._getCacheSize(this.useProgressiveUpdate);
    this._tileStrategy = new r2({ cachePolicy: "purge", acquireTile: (e5) => this.acquireTile(e5), releaseTile: (e5) => this.releaseTile(e5), cacheSize: t2, tileInfoView: this._tileInfoView }), this._updateBlockCacheRegistry();
  }
  detach() {
    this._tileStrategy.destroy(), this._fetchQueue.clear(), this.container.removeAllChildren(), this._fetchQueue = this._tileStrategy = this._tileInfoView = null, f(this._blockCacheRegistryUrl, this._blockCacheRegistryId), this._blockCacheRegistryUrl = this._blockCacheRegistryId = null;
  }
  acquireTile(e4) {
    const t2 = this.container.createTile(e4);
    return this._enqueueTileFetch(t2), this.layerView.requestUpdate(), this._needBlockCacheUpdate = true, this._globalUpdateRequested = this.layerView.hasTilingEffects || !this.useProgressiveUpdate, t2;
  }
  releaseTile(e4) {
    this._fetchQueue.abort(e4.key.id), this.container.removeChild(e4), e4.once("detach", () => {
      e4.destroy(), this.layerView.requestUpdate();
    }), this.layerView.requestUpdate();
  }
  createEmptyTilePixelBlock(e4 = null) {
    const t2 = null == e4 || e4.join(",") === this._tileInfoView.tileInfo.size.join(",");
    if (t2 && r(this._emptyTilePixelBlock))
      return this._emptyTilePixelBlock;
    e4 = e4 || this._tileInfoView.tileInfo.size;
    const [i5, r6] = e4, l4 = new g3({ width: i5, height: r6, pixels: [new Uint8Array(i5 * r6)], mask: new Uint8Array(i5 * r6), pixelType: "u8" });
    return t2 && (this._emptyTilePixelBlock = l4), l4;
  }
  _fetchTile1(e4, t2) {
    const i5 = r(t2) && t2.signal, l4 = this.canUseWebGLForProcessing(), { layerView: a2 } = this, o2 = !a2.tileInfo.isWrappable && r(U2(a2.view.spatialReference)), h3 = { allowPartialFill: true, datumTransformation: a2.datumTransformation, interpolation: l4 ? "nearest" : this.layer.interpolation, registryId: this._blockCacheRegistryId, requestRawData: l4, signal: e(i5), srcResolution: this._srcResolutions[e4.level], timeExtent: a2.timeExtent, tileInfo: a2.tileInfo, disableWrapAround: o2 };
    return this.fetchTile(e4, h3);
  }
  _getCacheSize(e4) {
    return e4 ? 40 : 0;
  }
  _initializeTileInfo() {
    const e4 = this.layerView.view.spatialReference, t2 = new w({ x: this.layerView.fullExtent.xmin, y: this.layerView.fullExtent.ymax, spatialReference: e4 }), { scales: i5, srcResolutions: s6, isCustomTilingScheme: r6 } = ie(this.layer.rasterInfo, e4), l4 = j2.create({ spatialReference: e4, size: 512, scales: i5 });
    (0 === l4.origin.x || l4.origin.x > t2.x) && (l4.origin = t2), this._isCustomTilingScheme = r6, this.layerView.set("tileInfo", l4), this._srcResolutions = s6 != null ? s6 : [];
  }
  _computeFetchConcurrency() {
    const { blockBoundary: e4 } = this.layer.rasterInfo.storageInfo, t2 = e4[e4.length - 1];
    return (t2.maxCol - t2.minCol + 1) * (t2.maxRow - t2.minRow + 1) > 64 ? 2 : 10;
  }
  async _enqueueTileFetch(e4, t2) {
    this.updatingHandles.addPromise(this._enqueueTileFetch1(e4, t2));
  }
  async _enqueueTileFetch1(e4, t2) {
    if (!this._fetchQueue.has(e4.key.id)) {
      try {
        const t3 = await this._fetchQueue.push(e4.key), { bandIds: r6 } = this.layer;
        let l4 = !this.useProgressiveUpdate || this.layerView.hasTilingEffects && !this._globalSymbolizerParams;
        if (this._globalUpdateRequested && !this.layerView.moving && 0 === this._fetchQueue.length) {
          l4 = false;
          try {
            await this._redrawImage(this._abortController && this._abortController.signal);
          } catch (s6) {
            j(s6) && s.getLogger(this.declaredClass).error(s6);
          }
          this._globalUpdateRequested = false;
        }
        !this.canUseWebGLForProcessing() && "rasterVF" !== this.type || this.layerView.hasTilingEffects || null != this._symbolizerParams || this._updateSymbolizerParams();
        const o2 = this._tileInfoView.getTileCoords(v2, e4.key), h3 = this._tileInfoView.getTileResolution(e4.key);
        await this.updateTileSource(e4, { source: t3, symbolizerParams: this._symbolizerParams, globalSymbolizerParams: this._globalSymbolizerParams, suspended: l4, bandIds: r6, coords: o2, resolution: h3 }), e4.once("attach", () => this.layerView.requestUpdate()), this.container.addChild(e4);
      } catch (s6) {
        j(s6) || s.getLogger(this.declaredClass).error(s6);
      }
      this.layerView.requestUpdate();
    }
  }
  async _redrawImage(e4) {
    if (0 === this.container.children.length)
      return;
    await this.layer.updateRenderer(), this.layerView.hasTilingEffects ? await this._updateGlobalSymbolizerParams(e4) : (this._updateSymbolizerParams(), this._globalSymbolizerParams = null);
    const t2 = this.container.children.map(async (e5) => this.updateTileSymbolizerParameters(e5, { local: this._symbolizerParams, global: this._globalSymbolizerParams }));
    await E(t2), this.container.requestRender();
  }
  async _updateGlobalSymbolizerParams(e4) {
    const t2 = { srcResolution: this._srcResolutions[this.previousLOD.level], registryId: this._blockCacheRegistryId, signal: e4 }, i5 = await this.layer.fetchPixels(this.layerView.view.extent, this.layerView.view.width, this.layerView.view.height, t2);
    if (!i5 || !i5.pixelBlock)
      return;
    const s6 = this.layer.symbolizer.generateWebGLParameters({ pixelBlock: s5(i5.pixelBlock, this.layer.bandIds), isGCS: this.layerView.view.spatialReference.isGeographic, resolution: { x: this.previousLOD.resolution, y: this.previousLOD.resolution }, bandIds: this.layer.bandIds });
    !this.canUseWebGLForProcessing() && s6 && "stretch" === s6.type && this.layer.renderer && "raster-stretch" === this.layer.renderer.type && (s6.factor = s6.factor.map((e5) => 255 * e5), s6.outMin = Math.round(255 * s6.outMin), s6.outMax = Math.round(255 * s6.outMax)), this._globalSymbolizerParams = s6;
  }
  _updateSymbolizerParams() {
    this._symbolizerParams = this.layer.symbolizer.generateWebGLParameters({ pixelBlock: null, isGCS: this.layerView.view.spatialReference.isGeographic, resolution: { x: this.previousLOD.resolution, y: this.previousLOD.resolution }, bandIds: this.layer.bandIds });
  }
  _updateBlockCacheRegistry(e4 = false) {
    const { url: t2, rasterInfo: i5, raster: s6 } = this.layer, { multidimensionalDefinition: r6 } = this.layer.normalizeRasterFetchOptions({ multidimensionalDefinition: this.layer.multidimensionalDefinition, timeExtent: this.layerView.timeExtent }), l4 = (i5 == null ? void 0 : i5.multidimensionalInfo) ? s6.getSliceIndex(r6) : null, a2 = a(t2, l4);
    if (a2 !== this._blockCacheRegistryUrl) {
      if (null != this._blockCacheRegistryUrl && f(this._blockCacheRegistryUrl, this._blockCacheRegistryId), this._blockCacheRegistryId = u2(a2, this.layer.raster.rasterInfo), e4) {
        const e5 = this._tileInfoView.getClosestInfoForScale(this.layerView.view.scale), t3 = this._srcResolutions[e5.level];
        g4(a2, this._blockCacheRegistryId, this.layerView.view.extent, this.layerView.view.resolution, t3, this.layer.raster.ioConfig.sampling);
      }
      this._blockCacheRegistryUrl = a2;
    }
  }
  async doRefresh() {
    if (!this.attached)
      return;
    await this.layer.updateRenderer(), this.layerView.hasTilingEffects || this._updateSymbolizerParams(), this._updateBlockCacheRegistry(true), this._fetchQueue.reset();
    const e4 = [];
    this._globalUpdateRequested = this.layerView.hasTilingEffects || !this.useProgressiveUpdate, this._tileStrategy.tiles.forEach((t2) => e4.push(this._enqueueTileFetch(t2))), await E(e4);
  }
};
e2([y()], T.prototype, "_fetchQueue", void 0), e2([y()], T.prototype, "_globalUpdateRequested", void 0), e2([y()], T.prototype, "attached", void 0), e2([y()], T.prototype, "container", void 0), e2([y()], T.prototype, "layer", void 0), e2([y()], T.prototype, "layerView", void 0), e2([y()], T.prototype, "type", void 0), e2([y()], T.prototype, "useWebGLForProcessing", null), e2([y()], T.prototype, "useProgressiveUpdate", null), e2([y()], T.prototype, "timeExtent", void 0), e2([y()], T.prototype, "updating", null), T = e2([n("esri.views.2d.layers.imagery.BaseImageryTileSubView2D")], T);

// node_modules/@arcgis/core/views/2d/layers/imagery/ImageryTileView2D.js
var l3 = class extends T {
  constructor() {
    super(...arguments), this.container = null, this.layer = null, this.type = "raster";
  }
  attach() {
    super.attach(), this.container = new n3(this._tileInfoView), this.container.isCustomTilingScheme = this._isCustomTilingScheme;
  }
  detach() {
    super.detach(), this.container.removeAllChildren(), this.container = null;
  }
  canUseWebGLForProcessing() {
    return this.useWebGLForProcessing && this.layer.symbolizer.canRenderInWebGL && !("majority" === this.layer.interpolation && r4(this.layer));
  }
  fetchTile(e4, r6) {
    return this.layer.fetchTile(e4.level, e4.row, e4.col, r6);
  }
  async updateTileSource(e4, t2) {
    const { bandIds: s6 } = this.layer, i5 = this._getLayerInterpolation(), o2 = this.canUseWebGLForProcessing(), { source: a2, globalSymbolizerParams: l4, suspended: n6, coords: c2, resolution: p2 } = t2, u4 = this.layerView.hasTilingEffects ? l4 : t2.symbolizerParams, { bitmap: d4 } = e4;
    if ([d4.x, d4.y] = c2, d4.resolution = p2, a2 && r(a2) && r(a2.pixelBlock)) {
      const e5 = { extent: a2.extent, pixelBlock: a2.pixelBlock };
      if (d4.rawPixelData = e5, o2)
        d4.source = a2.pixelBlock, d4.isRendereredSource = false;
      else {
        const r6 = await this.layer.applyRenderer(e5, "stretch" === (l4 == null ? void 0 : l4.type) ? l4 : null);
        d4.source = r6, d4.isRendereredSource = true;
      }
      d4.symbolizerParameters = o2 ? u4 : null, o2 ? d4.transformGrid || (d4.transformGrid = a2.transformGrid) : d4.transformGrid = null;
    } else {
      const e5 = this.createEmptyTilePixelBlock();
      d4.source = e5, d4.symbolizerParameters = o2 ? u4 : null, d4.transformGrid = null;
    }
    d4.bandIds = o2 ? s6 : null, d4.width = this._tileInfoView.tileInfo.size[0], d4.height = this._tileInfoView.tileInfo.size[1], d4.interpolation = i5, d4.suspended = n6, d4.invalidateTexture();
  }
  async updateTileSymbolizerParameters(e4, t2) {
    const { local: s6, global: i5 } = t2, { bandIds: o2 } = this.layer, a2 = this._getLayerInterpolation(), l4 = this.canUseWebGLForProcessing(), { bitmap: n6 } = e4, { rawPixelData: c2 } = n6;
    !l4 && r(c2) ? (n6.source = await this.layer.applyRenderer(c2, "stretch" === (i5 == null ? void 0 : i5.type) ? i5 : null), n6.isRendereredSource = true) : (n6.isRendereredSource && r(c2) && (n6.source = c2.pixelBlock), n6.isRendereredSource = false), n6.symbolizerParameters = l4 ? this.layerView.hasTilingEffects ? i5 : s6 : null, n6.bandIds = l4 ? o2 : null, n6.interpolation = a2, n6.suspended = false;
  }
  _getLayerInterpolation() {
    const e4 = this.layer.renderer.type;
    if ("raster-colormap" === e4 || "unique-value" === e4 || "class-breaks" === e4)
      return "nearest";
    const { interpolation: r6 } = this.layer, { renderer: t2 } = this.layer;
    return "raster-stretch" === t2.type && null != t2.colorRamp ? "bilinear" === r6 || "cubic" === r6 ? "bilinear" : "nearest" : r6;
  }
};
e2([y()], l3.prototype, "container", void 0), e2([y()], l3.prototype, "layer", void 0), e2([y()], l3.prototype, "type", void 0), l3 = e2([n("esri.views.2d.layers.imagery.ImageryTileView2D")], l3);
var n4 = l3;

// node_modules/@arcgis/core/views/2d/engine/imagery/RasterVFTile.js
var r5 = class extends r3 {
  constructor(t2, s6, e4, a2, r6, o2, l4 = null) {
    super(t2, s6, e4, a2, r6, o2), this.tileData = new y4(l4), this.tileData.coordScale = [r6, o2], this.tileData.once("isReady", () => this.ready());
  }
  destroy() {
    super.destroy(), this.tileData.destroy(), this.tileData = null, this.stage = null;
  }
  set stencilRef(t2) {
    this.tileData.stencilRef = t2;
  }
  get stencilRef() {
    return this.tileData.stencilRef;
  }
  _createTransforms() {
    return { dvs: e3(), tileMat3: e3() };
  }
  setTransform(e4) {
    super.setTransform(e4);
    const i5 = this.resolution / (e4.resolution * e4.pixelRatio), a2 = this.transforms.tileMat3, [r6, o2] = this.tileData.offset, l4 = [this.x + r6 * this.resolution, this.y - o2 * this.resolution], [h3, n6] = e4.toScreenNoRotation([0, 0], l4), { symbolTileSize: f4 } = this.tileData.symbolizerParameters, m2 = Math.round((this.width - this.tileData.offset[0]) / f4) * f4, c2 = Math.round((this.height - this.tileData.offset[1]) / f4) * f4, u4 = m2 / this.rangeX * i5, D = c2 / this.rangeY * i5;
    s3(a2, u4, 0, 0, 0, D, 0, h3, n6, 1), i(this.transforms.dvs, e4.displayViewMat3, a2), this.tileData.transforms.dvs = this.transforms.dvs;
  }
  onAttach() {
    this.tileData.stage = this.stage;
  }
  onDetach() {
    this.tileData.stage = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/imagery/RasterVFTileContainer.js
var o = class extends i2 {
  constructor() {
    super(...arguments), this.isCustomTilingScheme = false, this.symbolTypes = ["triangle"];
  }
  createTile(s6) {
    const t2 = this._tileInfoView.getTileBounds(u(), s6), [i5, o2] = this._tileInfoView.tileInfo.size, n6 = this._tileInfoView.getTileResolution(s6.level);
    return new r5(s6, n6, t2[0], t2[3], i5, o2);
  }
  prepareRenderPasses(e4) {
    const r6 = e4.registerRenderPass({ name: "imagery (vf tile)", brushes: [d2], target: () => this.children.map((e5) => e5.tileData), drawPhase: I.MAP });
    return [...super.prepareRenderPasses(e4), r6];
  }
  doRender(e4) {
    this.visible && e4.drawPhase === I.MAP && this.symbolTypes.forEach((s6) => {
      e4.renderPass = s6, super.doRender(e4);
    });
  }
};

// node_modules/@arcgis/core/views/2d/layers/imagery/VectorFieldTileView2D.js
var n5 = class extends T {
  constructor() {
    super(...arguments), this._handle = null, this.container = null, this.layer = null, this.type = "rasterVF";
  }
  canUseWebGLForProcessing() {
    return false;
  }
  async fetchTile(e4, t2) {
    t2 = { ...t2, interpolation: "nearest", requestProjectedLocalDirections: true };
    const i5 = await this.layer.fetchTile(e4.level, e4.row, e4.col, t2);
    return "vector-magdir" === this.layer.rasterInfo.dataType && (i5 == null ? void 0 : i5.pixelBlock) && (i5.pixelBlock = await this.layer.convertVectorFieldData(i5.pixelBlock, t2)), i5;
  }
  updateTileSource(e4, i5) {
    const r6 = i5.symbolizerParams, { tileData: o2 } = e4;
    o2.key = e4.key, o2.width = this._tileInfoView.tileInfo.size[0], o2.height = this._tileInfoView.tileInfo.size[1];
    const { symbolTileSize: s6 } = r6, { source: l4 } = i5;
    if (o2.offset = this._getTileSymbolOffset(o2.key, s6), r(l4) && r(l4.pixelBlock)) {
      const e5 = { extent: l4.extent, pixelBlock: l4.pixelBlock };
      o2.rawPixelData = e5, o2.symbolizerParameters = r6, o2.source = this._sampleVectorFieldData(l4.pixelBlock, r6, o2.offset);
    } else {
      const e5 = [Math.round((this._tileInfoView.tileInfo[0] - o2.offset[0]) / s6), Math.round((this._tileInfoView.tileInfo[1] - o2.offset[1]) / s6)], t2 = this.createEmptyTilePixelBlock(e5);
      o2.source = t2, o2.symbolizerParameters = r6;
    }
    return o2.invalidateVAO(), Promise.resolve(null);
  }
  updateTileSymbolizerParameters(e4, i5) {
    var _a;
    const r6 = i5.local, { symbolTileSize: o2 } = r6, { tileData: s6 } = e4;
    s6.offset = this._getTileSymbolOffset(s6.key, o2);
    const l4 = s6.symbolizerParameters.symbolTileSize;
    return s6.symbolizerParameters = r6, r((_a = s6.rawPixelData) == null ? void 0 : _a.pixelBlock) && l4 !== o2 && (s6.source = this._sampleVectorFieldData(s6.rawPixelData.pixelBlock, s6.symbolizerParameters, s6.offset)), Promise.resolve(null);
  }
  attach() {
    super.attach(), this.container = new o(this._tileInfoView), this.container.isCustomTilingScheme = this._isCustomTilingScheme, this._updateSymbolType(this.layer.renderer), this._handle = l(() => this.layer.renderer, (e4) => this._updateSymbolType(e4));
  }
  detach() {
    super.detach(), this.container.removeAllChildren(), this._handle.remove(), this._handle = null;
  }
  _getTileSymbolOffset(e4, t2) {
    const i5 = e4.col * this._tileInfoView.tileInfo.size[0] % t2, r6 = e4.row * this._tileInfoView.tileInfo.size[1] % t2;
    return [i5 > t2 / 2 ? t2 - i5 : -i5, r6 > t2 / 2 ? t2 - r6 : -r6];
  }
  _sampleVectorFieldData(e4, t2, i5) {
    const { symbolTileSize: r6 } = t2;
    return j3(e4, "vector-uv", r6, i5);
  }
  _updateSymbolType(e4) {
    "vector-field" === e4.type && (this.container.symbolTypes = "wind-barb" === e4.style ? ["scalar", "triangle"] : "simple-scalar" === e4.style ? ["scalar"] : ["triangle"]);
  }
};
e2([y()], n5.prototype, "container", void 0), e2([y()], n5.prototype, "layer", void 0), e2([y()], n5.prototype, "type", void 0), n5 = e2([n("esri.views.2d.layers.imagery.VectorFieldTileView2D")], n5);
var c = n5;

// node_modules/@arcgis/core/views/layers/ImageryTileLayerView.js
var f2 = (f4) => {
  let m2 = class extends f4 {
    constructor() {
      super(...arguments), this._rasterFieldPrefix = "Raster.", this.layer = null, this.view = null, this.tileInfo = null;
    }
    get fullExtent() {
      return this._getfullExtent();
    }
    _getfullExtent() {
      return this.projectFullExtent(this.view.spatialReference);
    }
    get hasTilingEffects() {
      return this.layer.renderer && "dynamicRangeAdjustment" in this.layer.renderer && this.layer.renderer.dynamicRangeAdjustment;
    }
    get datumTransformation() {
      return v(e(this.layer.fullExtent), this.view.spatialReference, true);
    }
    supportsSpatialReference(e4) {
      return !!this.projectFullExtent(e4);
    }
    projectFullExtent(e4) {
      const t2 = e(this.layer.fullExtent), r6 = v(t2, e4, false);
      return J(t2, e4, r6);
    }
    async fetchPopupFeatures(e4, o2) {
      const { layer: a2 } = this;
      if (!e4)
        throw new s2("imageryTileLayerView:fetchPopupFeatures", "Nothing to fetch without area", { layer: a2 });
      const { popupEnabled: n6 } = a2, l4 = s4(a2, o2);
      if (!n6 || t(l4))
        throw new s2("imageryTileLayerView:fetchPopupFeatures", "Missing required popupTemplate or popupEnabled", { popupEnabled: n6, popupTemplate: l4 });
      const p2 = [], { value: u4, magdirValue: f5 } = await a2.identify(e4, { timeExtent: this.timeExtent });
      let m3 = "";
      if (u4 && u4.length) {
        m3 = "imagery-tile" === a2.type && a2.hasStandardTime() && null != u4[0] ? u4.map((e6) => a2.getStandardTimeValue(e6)).join(", ") : u4.join(", ");
        const e5 = { ObjectId: 0 };
        e5["Raster.ServicePixelValue"] = m3;
        const r6 = a2.rasterInfo.attributeTable;
        if (r(r6)) {
          const { fields: t2, features: o4 } = r6, s7 = t2.find(({ name: e6 }) => "value" === e6.toLowerCase()), i5 = s7 ? o4.find((e6) => String(e6.attributes[s7.name]) === m3) : null;
          if (i5) {
            for (const r7 in i5.attributes)
              if (i5.attributes.hasOwnProperty(r7)) {
                e5[this._rasterFieldPrefix + r7] = i5.attributes[r7];
              }
          }
        }
        const o3 = a2.rasterInfo.dataType;
        "vector-magdir" !== o3 && "vector-uv" !== o3 || (e5["Raster.Magnitude"] = f5 == null ? void 0 : f5[0], e5["Raster.Direction"] = f5 == null ? void 0 : f5[1]);
        const s6 = new g2(this.fullExtent.clone(), null, e5);
        s6.layer = a2, s6.sourceLayer = s6.layer, p2.push(s6);
      }
      return p2;
    }
  };
  return e2([y()], m2.prototype, "layer", void 0), e2([y(g)], m2.prototype, "timeExtent", void 0), e2([y()], m2.prototype, "view", void 0), e2([y()], m2.prototype, "fullExtent", null), e2([y()], m2.prototype, "tileInfo", void 0), e2([y({ readOnly: true })], m2.prototype, "hasTilingEffects", null), m2 = e2([n("esri.views.layers.ImageryTileLayerView")], m2), m2;
};

// node_modules/@arcgis/core/views/2d/layers/ImageryTileLayerView2D.js
var f3 = class extends f2(i3(y3(u3))) {
  constructor() {
    super(...arguments), this._useWebGLForProcessing = true, this._useProgressiveUpdate = true, this.subview = null;
  }
  get useWebGLForProcessing() {
    return this._useWebGLForProcessing;
  }
  set useWebGLForProcessing(e4) {
    this._useWebGLForProcessing = e4, this.subview && "useWebGLForProcessing" in this.subview && (this.subview.useWebGLForProcessing = e4);
  }
  get useProgressiveUpdate() {
    return this._useWebGLForProcessing;
  }
  set useProgressiveUpdate(e4) {
    this._useProgressiveUpdate = e4, this.subview && "useProgressiveUpdate" in this.subview && (this.subview.useProgressiveUpdate = e4);
  }
  update(e4) {
    this.subview.update(e4), this.notifyChange("updating");
  }
  isUpdating() {
    return !this.subview || this.subview.updating;
  }
  attach() {
    this.layer.increaseRasterJobHandlerUsage(), this._updateSubview(), this.handles.add([l(() => {
      const { layer: e4 } = this;
      return { bandIds: e4.bandIds, renderer: e4.renderer, interpolation: e4.interpolation, multidimensionalDefinition: e4.multidimensionalDefinition, rasterFunction: "imagery-tile" === e4.type ? e4.rasterFunction : null };
    }, (e4, t2) => {
      var _a, _b;
      const s6 = e4.interpolation !== t2.interpolation && ("majority" === e4.interpolation || "majority" === t2.interpolation) && r4(this.layer), o2 = e4.renderer !== t2.renderer && ((_a = t2.renderer) == null ? void 0 : _a.type) !== ((_b = e4.renderer) == null ? void 0 : _b.type);
      o2 && this._updateSubview();
      const a2 = e4.multidimensionalDefinition !== t2.multidimensionalDefinition, n6 = e4.rasterFunction !== t2.rasterFunction, u4 = a2 || s6 || o2 || n6;
      this.subview.redrawOrRefetch(u4).catch((e5) => {
        j(e5) || s.getLogger(this.declaredClass).error(e5);
      }), this.notifyChange("updating");
    }), l(() => {
      var _a;
      return (_a = this.layer.blendMode) != null ? _a : "normal";
    }, (e4) => {
      this.subview.container.blendMode = e4;
    }, w3), l(() => {
      var _a;
      return (_a = this.layer.effect) != null ? _a : null;
    }, (e4) => {
      this.subview.container.effect = e4;
    }, w3), l(() => {
      var _a;
      return (_a = this.layer.multidimensionalSubset) != null ? _a : null;
    }, (e4, t2) => {
      const { multidimensionalDefinition: o2 } = this.layer;
      r(o2) && m(o2, e4) !== m(o2, t2) && (this.subview.redrawOrRefetch(true).catch((e5) => {
        j(e5) || s.getLogger(this.declaredClass).error(e5);
      }), this.notifyChange("updating"));
    }, U), l(() => this.timeExtent, () => {
      this.subview.timeExtent = this.timeExtent, this.subview.redrawOrRefetch(true).catch((e4) => {
        j(e4) || s.getLogger(this.declaredClass).error(e4);
      });
    }, h)], "attach");
  }
  detach() {
    var _a;
    this.handles.remove("attach"), this.layer.decreaseRasterJobHandlerUsage(), this._detachSubview(this.subview), (_a = this.subview) == null ? void 0 : _a.destroy(), this.subview = null;
  }
  moveStart() {
    this.requestUpdate();
  }
  viewChange() {
    this.requestUpdate();
  }
  moveEnd() {
    this.subview.moveEnd();
  }
  async hitTest(e4, i5) {
    return [{ type: "graphic", layer: this.layer, mapPoint: e4, graphic: new g2({ attributes: {}, geometry: e4.clone() }) }];
  }
  doRefresh() {
    var _a;
    return (_a = this.subview) == null ? void 0 : _a.doRefresh();
  }
  _updateSubview() {
    var _a;
    const e4 = "vector-field" === this.layer.renderer.type ? "rasterVF" : "flow" === this.layer.renderer.type ? "flow" : "raster";
    if (this.subview) {
      if (this.subview.type === e4)
        return void this._attachSubview(this.subview);
      this._detachSubview(this.subview), (_a = this.subview) == null ? void 0 : _a.destroy(), this.subview = null;
    }
    const { layer: t2 } = this;
    let i5;
    i5 = "rasterVF" === e4 ? new c({ layer: t2, layerView: this }) : "flow" === e4 ? new d3({ layer: t2, layerView: this }) : new n4({ layer: t2, layerView: this }), "useWebGLForProcessing" in i5 && (i5.useWebGLForProcessing = this._useWebGLForProcessing), "useProgressiveUpdate" in i5 && (i5.useProgressiveUpdate = this._useProgressiveUpdate), "previousLOD" in i5 && (i5.previousLOD = this.subview && "previousLOD" in this.subview && this.subview.previousLOD), this._attachSubview(i5), this.subview = i5, this.requestUpdate();
  }
  _attachSubview(e4) {
    e4 && !e4.attached && (e4.attach(), e4.attached = true, this.container.addChildAt(e4.container, 0), e4.container.blendMode = this.layer.blendMode, e4.container.effect = this.layer.effect);
  }
  _detachSubview(e4) {
    (e4 == null ? void 0 : e4.attached) && (this.container.removeChild(e4.container), e4.detach(), e4.attached = false);
  }
};
e2([y()], f3.prototype, "subview", void 0), e2([y()], f3.prototype, "useWebGLForProcessing", null), e2([y()], f3.prototype, "useProgressiveUpdate", null), f3 = e2([n("esri.views.2d.layers.ImageryTileLayerView2D")], f3);
var L = f3;
export {
  L as default
};
//# sourceMappingURL=ImageryTileLayerView2D-4XQ62RCS.js.map
