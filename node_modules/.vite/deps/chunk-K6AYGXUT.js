// node_modules/@arcgis/core/node_modules/@esri/calcite-components/dist/components/dom.js
var autoTheme = "calcite-theme-auto";
var darkTheme = "calcite-theme-dark";
var lightTheme = "calcite-theme-light";
var CSS_UTILITY = {
  autoTheme,
  darkTheme,
  lightTheme,
  rtl: "calcite--rtl"
};
var TEXT = {
  loading: "Loading"
};
function getElementDir(el) {
  const prop = "dir";
  const selector = `[${prop}]`;
  const closest = closestElementCrossShadowBoundary(el, selector);
  return closest ? closest.getAttribute(prop) : "ltr";
}
function getElementProp(el, prop, fallbackValue) {
  const selector = `[${prop}]`;
  const closest = el.closest(selector);
  return closest ? closest.getAttribute(prop) : fallbackValue;
}
function getRootNode(el) {
  return el.getRootNode();
}
function getHost(root) {
  return root.host || null;
}
function queryElementRoots(element, { selector, id }) {
  function queryFrom(el) {
    if (!el) {
      return null;
    }
    if (el.assignedSlot) {
      el = el.assignedSlot;
    }
    const rootNode = getRootNode(el);
    const found = id ? "getElementById" in rootNode ? rootNode.getElementById(id) : null : selector ? rootNode.querySelector(selector) : null;
    const host = getHost(rootNode);
    return found ? found : host ? queryFrom(host) : null;
  }
  return queryFrom(element);
}
function closestElementCrossShadowBoundary(element, selector) {
  function closestFrom(el) {
    return el ? el.closest(selector) || closestFrom(getHost(getRootNode(el))) : null;
  }
  return closestFrom(element);
}
function walkUpAncestry(element, onVisit) {
  return visit(element, onVisit);
}
function visit(node, onVisit) {
  if (!node) {
    return;
  }
  const result = onVisit(node);
  if (result !== void 0) {
    return result;
  }
  const { parentNode } = node;
  return visit(parentNode instanceof ShadowRoot ? parentNode.host : parentNode, onVisit);
}
function containsCrossShadowBoundary(element, maybeDescendant) {
  return !!walkUpAncestry(maybeDescendant, (node) => node === element ? true : void 0);
}
function isCalciteFocusable(el) {
  return typeof (el === null || el === void 0 ? void 0 : el.setFocus) === "function";
}
async function focusElement(el) {
  if (!el) {
    return;
  }
  return isCalciteFocusable(el) ? el.setFocus() : el.focus();
}
var defaultSlotSelector = ":not([slot])";
function getSlotted(element, slotName, options) {
  if (slotName && !Array.isArray(slotName) && typeof slotName !== "string") {
    options = slotName;
    slotName = null;
  }
  const slotSelector = slotName ? Array.isArray(slotName) ? slotName.map((name) => `[slot="${name}"]`).join(",") : `[slot="${slotName}"]` : defaultSlotSelector;
  if (options === null || options === void 0 ? void 0 : options.all) {
    return queryMultiple(element, slotSelector, options);
  }
  return querySingle(element, slotSelector, options);
}
function getDirectChildren(el, selector) {
  return el ? Array.from(el.children || []).filter((child) => child === null || child === void 0 ? void 0 : child.matches(selector)) : [];
}
function queryMultiple(element, slotSelector, options) {
  let matches = slotSelector === defaultSlotSelector ? getDirectChildren(element, defaultSlotSelector) : Array.from(element.querySelectorAll(slotSelector));
  matches = options && options.direct === false ? matches : matches.filter((el) => el.parentElement === element);
  matches = (options === null || options === void 0 ? void 0 : options.matches) ? matches.filter((el) => el === null || el === void 0 ? void 0 : el.matches(options.matches)) : matches;
  const selector = options === null || options === void 0 ? void 0 : options.selector;
  return selector ? matches.map((item) => Array.from(item.querySelectorAll(selector))).reduce((previousValue, currentValue) => [...previousValue, ...currentValue], []).filter((match) => !!match) : matches;
}
function querySingle(element, slotSelector, options) {
  let match = slotSelector === defaultSlotSelector ? getDirectChildren(element, defaultSlotSelector)[0] || null : element.querySelector(slotSelector);
  match = options && options.direct === false ? match : (match === null || match === void 0 ? void 0 : match.parentElement) === element ? match : null;
  match = (options === null || options === void 0 ? void 0 : options.matches) ? (match === null || match === void 0 ? void 0 : match.matches(options.matches)) ? match : null : match;
  const selector = options === null || options === void 0 ? void 0 : options.selector;
  return selector ? match === null || match === void 0 ? void 0 : match.querySelector(selector) : match;
}
function setRequestedIcon(iconObject, iconValue, matchedValue) {
  if (typeof iconValue === "string" && iconValue !== "") {
    return iconValue;
  } else if (iconValue === "") {
    return iconObject[matchedValue];
  }
}
function toAriaBoolean(value) {
  return Boolean(value).toString();
}
function isPrimaryPointerButton(event) {
  return !!(event.isPrimary && event.button === 0);
}

export {
  autoTheme,
  darkTheme,
  CSS_UTILITY,
  TEXT,
  getElementDir,
  getElementProp,
  queryElementRoots,
  closestElementCrossShadowBoundary,
  containsCrossShadowBoundary,
  focusElement,
  getSlotted,
  setRequestedIcon,
  toAriaBoolean,
  isPrimaryPointerButton
};
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.0-beta.97
 */
//# sourceMappingURL=chunk-K6AYGXUT.js.map
