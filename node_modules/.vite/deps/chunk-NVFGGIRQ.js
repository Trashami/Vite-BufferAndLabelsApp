import {
  o
} from "./chunk-KLOEF26H.js";
import {
  l as l2
} from "./chunk-C6BDJNUQ.js";
import {
  b
} from "./chunk-75RMBUYZ.js";
import {
  An,
  gn,
  rn
} from "./chunk-FFVIDMFN.js";
import {
  J
} from "./chunk-NCONZRBI.js";
import {
  x as x2
} from "./chunk-YM6PUX7G.js";
import {
  d,
  i,
  u
} from "./chunk-NRP45AHD.js";
import {
  x
} from "./chunk-3LR5O4WA.js";
import {
  n
} from "./chunk-D4V6J5BT.js";
import {
  U,
  l
} from "./chunk-5NXILPDI.js";
import {
  n as n3
} from "./chunk-THVR7IAM.js";
import {
  e,
  m,
  n2,
  y
} from "./chunk-OOLCFNXJ.js";
import {
  r,
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/views/interactive/GraphicManipulator.js
var C = class extends m {
  constructor(e2) {
    super(e2), this.layer = null, this.interactive = true, this.selectable = false, this.grabbable = true, this.dragging = false, this.cursor = null, this.events = new n3.EventEmitter(), this._circleCollisionCache = null, this._graphicSymbolChangedHandle = null, this._originalSymbol = null;
  }
  set graphic(e2) {
    this._circleCollisionCache = null, this._originalSymbol = e2.symbol, this._set("graphic", e2), this.attachSymbolChanged();
  }
  get elevationInfo() {
    const e2 = "elevationInfo" in this.graphic.layer && this.graphic.layer.elevationInfo, t2 = l2(this.graphic), i2 = e2 ? e2.offset : 0;
    return new x2({ mode: t2, offset: i2 });
  }
  set focusedSymbol(e2) {
    e2 !== this._get("focusedSymbol") && (this._set("focusedSymbol", e2), this._updateGraphicSymbol(), this._circleCollisionCache = null);
  }
  grabbableForEvent() {
    return true;
  }
  set grabbing(e2) {
    e2 !== this._get("grabbing") && (this._set("grabbing", e2), this._updateGraphicSymbol());
  }
  set hovering(e2) {
    e2 !== this._get("hovering") && (this._set("hovering", e2), this._updateGraphicSymbol());
  }
  set selected(e2) {
    e2 !== this._get("selected") && (this._set("selected", e2), this._updateGraphicSymbol(), this.events.emit("select-changed", { action: e2 ? "select" : "deselect" }));
  }
  get _focused() {
    return this._get("hovering") || this._get("grabbing");
  }
  destroy() {
    this.detachSymbolChanged(), this._resetGraphicSymbol(), this._set("view", null);
  }
  intersectionDistance(e2) {
    const t2 = this.graphic;
    if (false === t2.visible)
      return null;
    const i2 = t2.geometry;
    if (t(i2))
      return null;
    const r2 = this._get("focusedSymbol"), l3 = r(r2) ? r2 : t2.symbol;
    return "2d" === this.view.type ? this._intersectDistance2D(this.view, e2, i2, l3) : this._intersectDistance3D(this.view, e2, t2);
  }
  attach() {
    this.attachSymbolChanged(), r(this.layer) && this.layer.add(this.graphic);
  }
  detach() {
    this.detachSymbolChanged(), this._resetGraphicSymbol(), r(this.layer) && this.layer.remove(this.graphic);
  }
  attachSymbolChanged() {
    this.detachSymbolChanged(), this._graphicSymbolChangedHandle = l(() => {
      var _a;
      return (_a = this.graphic) == null ? void 0 : _a.symbol;
    }, (e2) => {
      r(e2) && e2 !== this.focusedSymbol && e2 !== this._originalSymbol && (this._originalSymbol = e2, this._focused && r(this.focusedSymbol) && (this.graphic.symbol = this.focusedSymbol));
    }, U);
  }
  detachSymbolChanged() {
    r(this._graphicSymbolChangedHandle) && (this._graphicSymbolChangedHandle.remove(), this._graphicSymbolChangedHandle = null);
  }
  _updateGraphicSymbol() {
    this.graphic.symbol = this._focused && r(this.focusedSymbol) ? this.focusedSymbol : this._originalSymbol;
  }
  _resetGraphicSymbol() {
    this.graphic.symbol = this._originalSymbol;
  }
  _intersectDistance2D(e2, t2, i2, r2) {
    if (r2 = r2 || J(i2), t(r2))
      return null;
    const l3 = 1;
    let c = this._circleCollisionCache;
    if ("point" !== i2.type || "simple-marker" !== r2.type)
      return o(t2, i2, e2) ? l3 : null;
    if (t(c) || !c.originalPoint.equals(i2)) {
      const t3 = i2, o2 = e2.spatialReference;
      if (An(t3.spatialReference, o2)) {
        const e3 = rn(t3, o2);
        c = { originalPoint: t3.clone(), mapPoint: e3, radiusPx: u(r2.size) }, this._circleCollisionCache = c;
      }
    }
    if (r(c)) {
      const i3 = d(t2, D), o2 = e2.toScreen(c.mapPoint), s = c.radiusPx, h = o2.x + u(r2.xoffset), p = o2.y - u(r2.yoffset);
      return b(i3, [h, p]) < s * s ? l3 : null;
    }
    return null;
  }
  _intersectDistance3D(e2, t2, i2) {
    const o2 = e2.toMap(t2, { include: [i2] });
    return o2 && gn(o2, j, e2.renderSpatialReference) ? x(j, e2.state.camera.eye) : null;
  }
};
e([y({ constructOnly: true, nonNullable: true })], C.prototype, "graphic", null), e([y()], C.prototype, "elevationInfo", null), e([y({ constructOnly: true, nonNullable: true })], C.prototype, "view", void 0), e([y({ value: null })], C.prototype, "focusedSymbol", null), e([y({ constructOnly: true })], C.prototype, "layer", void 0), e([y()], C.prototype, "interactive", void 0), e([y()], C.prototype, "selectable", void 0), e([y()], C.prototype, "grabbable", void 0), e([y({ value: false })], C.prototype, "grabbing", null), e([y()], C.prototype, "dragging", void 0), e([y()], C.prototype, "hovering", null), e([y({ value: false })], C.prototype, "selected", null), e([y()], C.prototype, "cursor", void 0), C = e([n2("esri.views.interactive.GraphicManipulator")], C);
var j = n();
var D = i();

export {
  C
};
//# sourceMappingURL=chunk-NVFGGIRQ.js.map
