import {
  A as A6,
  B2 as B4,
  C as C6,
  D as D4,
  E as E10,
  E2 as E11,
  F as F5,
  G as G4,
  H as H2,
  I as I3,
  I2 as I4,
  J as J2,
  J2 as J3,
  L as L3,
  Q,
  R as R8,
  S as S5,
  T2 as T4,
  U as U4,
  U2 as U5,
  V as V3,
  X2 as X,
  a as a18,
  b as b11,
  d as d11,
  d2 as d12,
  d3 as d13,
  e as e17,
  e2 as e18,
  f as f13,
  f2 as f14,
  f4 as f15,
  g as g9,
  h as h15,
  h2 as h16,
  i2 as i13,
  i3 as i14,
  i4 as i15,
  j as j8,
  j2 as j9,
  l as l19,
  m as m9,
  m2 as m10,
  m3 as m11,
  p as p10,
  r as r15,
  s as s12,
  s2 as s13,
  t as t15,
  t2 as t16,
  u as u17,
  ue,
  v as v9,
  v2 as v10,
  v3 as v11,
  x as x7,
  x2 as x8,
  x3 as x9,
  x4 as x10,
  z as z2
} from "./chunk-LOQE65I2.js";
import {
  u as u18
} from "./chunk-YWYFZG6T.js";
import {
  M as M5
} from "./chunk-MWLNLEBX.js";
import {
  _ as _7,
  p as p12
} from "./chunk-WG4RPCMG.js";
import {
  T as T5,
  a as a19
} from "./chunk-63O7K5LP.js";
import "./chunk-7UVYS6N7.js";
import {
  p as p11
} from "./chunk-TMILTRNC.js";
import "./chunk-ZGU5MP3X.js";
import "./chunk-KPTMJVEB.js";
import "./chunk-EHTPZ3ZP.js";
import "./chunk-T6LV2MRC.js";
import "./chunk-WWDLDTQB.js";
import {
  f as f11
} from "./chunk-FS3REKZ4.js";
import {
  r as r16
} from "./chunk-LX3EHQCS.js";
import {
  a as a16,
  f as f12,
  p as p9,
  s as s11
} from "./chunk-ELKWN2M6.js";
import {
  a as a17,
  e as e16,
  o as o16
} from "./chunk-FGBXDVCJ.js";
import "./chunk-5OCDKMG5.js";
import "./chunk-BU5AMSMP.js";
import {
  u as u15
} from "./chunk-PCWW275T.js";
import {
  a as a15
} from "./chunk-33C4NXXN.js";
import {
  G as G3,
  U as U3
} from "./chunk-FXVIA5BW.js";
import {
  i as i12
} from "./chunk-J42Y5N2P.js";
import "./chunk-DWAZ7HI7.js";
import {
  o as o13
} from "./chunk-WWLBKNPY.js";
import {
  i as i11
} from "./chunk-Z5PNFOTJ.js";
import "./chunk-IOZMLQTF.js";
import {
  h as h14
} from "./chunk-P5Y67HOZ.js";
import {
  J,
  M as M4,
  O as O5,
  T as T3,
  v as v8,
  w as w8
} from "./chunk-IJUE2JUP.js";
import {
  B as B3,
  C as C5,
  E as E9,
  Y as Y2,
  c as c13
} from "./chunk-SSCI2ECM.js";
import {
  B as B2,
  E as E8,
  P as P4,
  d as d8,
  e as e13,
  f as f9,
  f2 as f10,
  h as h13,
  i as i9,
  l as l18,
  m as m7,
  m2 as m8,
  o as o11,
  s as s8,
  u2 as u14,
  y2 as y4
} from "./chunk-7ZSUZDMT.js";
import "./chunk-QB3YZMAB.js";
import {
  s as s9
} from "./chunk-OF6PIPJD.js";
import {
  L as L2
} from "./chunk-IMFUUJSK.js";
import "./chunk-5OCLJKTT.js";
import {
  A as A5,
  E as E7,
  S as S4,
  _ as _6,
  a as a13,
  c as c15,
  l as l17
} from "./chunk-5SEVEYDG.js";
import {
  b as b10,
  v as v5
} from "./chunk-77RDPZ67.js";
import {
  T as T2
} from "./chunk-ZNZ4EIIF.js";
import "./chunk-ZZLJFOS7.js";
import {
  i as i7
} from "./chunk-K3TAVS2D.js";
import "./chunk-J3QY3JS6.js";
import "./chunk-FUF4C2M3.js";
import "./chunk-KBM2LGNP.js";
import "./chunk-AGHOAN2O.js";
import {
  e as e12,
  o as o10,
  t as t12
} from "./chunk-HP6QT5KY.js";
import "./chunk-OPS2DUBP.js";
import "./chunk-PNLWREZJ.js";
import {
  d2 as d9,
  h as h10,
  t as t11
} from "./chunk-WEBU4A2Q.js";
import "./chunk-QFWDN2OM.js";
import "./chunk-372DRRBO.js";
import "./chunk-X7GQR2IY.js";
import {
  e as e14
} from "./chunk-6WTG5RYO.js";
import {
  E as E5,
  O as O4,
  U as U2,
  d2 as d10,
  h as h11,
  o2 as o7,
  p as p8,
  r2 as r14,
  v as v6,
  v2 as v7,
  x as x6
} from "./chunk-HNRPDSCT.js";
import "./chunk-ZSBQER52.js";
import "./chunk-GDICPMRK.js";
import "./chunk-BW4YO4QD.js";
import "./chunk-S6WNSMC7.js";
import "./chunk-JPRTIOCM.js";
import {
  i as i8
} from "./chunk-AMNM3DGI.js";
import "./chunk-RNRS2JL4.js";
import {
  h as h9
} from "./chunk-SBPLVEUA.js";
import "./chunk-3IISYLTT.js";
import "./chunk-7QNA4ADD.js";
import "./chunk-FGA4AGTH.js";
import "./chunk-6ZCPLPAF.js";
import "./chunk-XTFH7327.js";
import {
  W,
  _ as _5,
  a as a12,
  h as h12,
  l as l16,
  o as o9
} from "./chunk-MOPTUDCV.js";
import "./chunk-6VLXCUNV.js";
import {
  C as C4,
  a as a11,
  c as c14,
  i as i6,
  n as n13,
  u as u13
} from "./chunk-D2XA6Z6P.js";
import {
  o as o8
} from "./chunk-MYQCUAHK.js";
import {
  E as E4,
  E2 as E6,
  R as R7
} from "./chunk-O4DPVR3F.js";
import "./chunk-MATM5L52.js";
import "./chunk-4OM3EX6P.js";
import "./chunk-YJIITZRY.js";
import "./chunk-ZSZHMQBF.js";
import "./chunk-MIXBH4EM.js";
import "./chunk-L7GGOP5S.js";
import "./chunk-C6PUUIY2.js";
import "./chunk-33T2SX6R.js";
import "./chunk-TGHV3HKU.js";
import "./chunk-HT2GXPWH.js";
import "./chunk-BQL7VXQR.js";
import "./chunk-735C75BI.js";
import "./chunk-ZLTZ3KAT.js";
import {
  A as A3,
  a as a10,
  f as f7
} from "./chunk-IPDZATIB.js";
import {
  A as A4,
  O as O3,
  P as P3,
  R as R6,
  Y,
  _ as _4,
  b as b9,
  l as l15,
  p as p6,
  p2 as p7,
  q as q5
} from "./chunk-ZX55SO5Y.js";
import {
  R as R5,
  k2 as k3,
  p as p5,
  w as w7
} from "./chunk-FCIHN4UG.js";
import {
  n as n10,
  o as o6
} from "./chunk-XP4QUBSF.js";
import {
  n as n11
} from "./chunk-A22ACVMF.js";
import {
  O as O2
} from "./chunk-RUM3DXFX.js";
import "./chunk-2DWNY35K.js";
import {
  u as u12
} from "./chunk-5ZAWCTS6.js";
import "./chunk-X6GHUY4U.js";
import {
  D as D3,
  F as F3,
  I,
  R as R4
} from "./chunk-3OFVLRSL.js";
import {
  c as c12,
  l as l13
} from "./chunk-4NNECS4K.js";
import {
  x as x5
} from "./chunk-UWKVAZQ6.js";
import "./chunk-XP6I2GEX.js";
import {
  g as g5
} from "./chunk-2FEM2LL2.js";
import {
  c as c10
} from "./chunk-L3EXV6PG.js";
import {
  R as R3,
  V as V2,
  j as j7,
  k as k2,
  v as v4
} from "./chunk-AQS2GDHU.js";
import {
  r as r11,
  t as t7
} from "./chunk-C6HDWDWX.js";
import {
  T,
  a as a8,
  b as b8,
  c as c11,
  d as d7,
  h as h8,
  i as i5,
  l as l12,
  u as u10,
  x as x4
} from "./chunk-67RD6CZ4.js";
import "./chunk-NGFMX3UT.js";
import "./chunk-XFDO4CMR.js";
import {
  e as e9,
  o as o3,
  r as r9
} from "./chunk-IVLBGTXL.js";
import {
  e as e8
} from "./chunk-GHN7C53L.js";
import {
  s as s10,
  u as u16
} from "./chunk-OTFFDA2T.js";
import "./chunk-4HL6BBWO.js";
import {
  e as e15,
  t as t13
} from "./chunk-IPJF6OUC.js";
import "./chunk-I4YZGF7W.js";
import {
  a as a14
} from "./chunk-C6BDJNUQ.js";
import {
  g as g8,
  o as o15
} from "./chunk-RSD4VYC6.js";
import "./chunk-IIAN3QNN.js";
import {
  t as t10
} from "./chunk-UDYHZLTE.js";
import "./chunk-IQBIGNPU.js";
import {
  r as r13
} from "./chunk-4JNOVZUK.js";
import {
  t as t8
} from "./chunk-OJ2HHY2O.js";
import "./chunk-6FXLJAMI.js";
import {
  a as a9,
  g as g6,
  o as o5,
  u as u11
} from "./chunk-ZNRXLY4R.js";
import {
  g2 as g7
} from "./chunk-O7LTV6XN.js";
import "./chunk-4TWWY75O.js";
import "./chunk-SQSR6K2M.js";
import {
  c as c16
} from "./chunk-4RQKL5NC.js";
import {
  o as o14
} from "./chunk-P3W4YLFD.js";
import {
  _ as _3,
  j as j6,
  l as l11,
  o as o4,
  q as q4,
  r as r10,
  s as s7,
  v as v3
} from "./chunk-75RMBUYZ.js";
import {
  nt as nt2
} from "./chunk-TJ2I6XQT.js";
import "./chunk-EDHROVWI.js";
import {
  s as s5,
  t as t4
} from "./chunk-34YPGGJT.js";
import "./chunk-TWJNUVV2.js";
import "./chunk-4BIBXEQB.js";
import "./chunk-G34PZCB3.js";
import {
  t as t14
} from "./chunk-TM6KXMYT.js";
import "./chunk-DUCSW4OU.js";
import "./chunk-WVDA5Z37.js";
import "./chunk-QGJM2PN7.js";
import {
  e as e11
} from "./chunk-EGV5SNBD.js";
import {
  F as F4,
  I as I2,
  y as y5
} from "./chunk-LT5KLTS5.js";
import "./chunk-SERWCSJG.js";
import {
  l as l14
} from "./chunk-MFXTPFHI.js";
import "./chunk-RW4M3CI3.js";
import {
  e as e10,
  f as f8,
  n as n12,
  r as r12,
  t as t9
} from "./chunk-ZEEU5HOK.js";
import {
  An,
  Bn,
  Hn,
  Zn,
  ee,
  gn,
  jn,
  pn,
  vn,
  xn
} from "./chunk-FFVIDMFN.js";
import {
  a as a7,
  c as c9,
  u as u9
} from "./chunk-NCONZRBI.js";
import "./chunk-YTOF4Z6B.js";
import {
  e as e7,
  i as i4
} from "./chunk-A4HIS5ZJ.js";
import {
  x as x3
} from "./chunk-AMLHWG76.js";
import "./chunk-OFQYIOO7.js";
import "./chunk-J5VTDQTQ.js";
import "./chunk-JP3KAUQB.js";
import "./chunk-INL7BDTP.js";
import {
  C as C3
} from "./chunk-PDEVQZ7U.js";
import "./chunk-7XXQ7762.js";
import {
  d as d5,
  m as m6
} from "./chunk-DVGM5RQS.js";
import "./chunk-R6OA44DQ.js";
import "./chunk-QTYVDCOW.js";
import {
  S as S3
} from "./chunk-HSDU7DIL.js";
import "./chunk-FWRLW4G5.js";
import "./chunk-JNNRJ7GQ.js";
import "./chunk-E52E6T7N.js";
import "./chunk-GLGOVVCK.js";
import "./chunk-BUVDI6S7.js";
import {
  N
} from "./chunk-6Z6ZAVRA.js";
import "./chunk-PK4W65H4.js";
import "./chunk-GY2AJLN6.js";
import "./chunk-W62B63EU.js";
import "./chunk-N43PI2UO.js";
import {
  n as n8
} from "./chunk-O6VYMEIX.js";
import {
  _ as _2,
  l as l10,
  n as n9,
  r as r8,
  t as t6
} from "./chunk-NDQ5FHGV.js";
import {
  b as b2,
  c as c3
} from "./chunk-HUQX7WZO.js";
import "./chunk-ZWUEORSX.js";
import "./chunk-US2IWMHE.js";
import "./chunk-ZPYDYUP5.js";
import {
  b as b5
} from "./chunk-SOEQPPQP.js";
import "./chunk-22F6X66Z.js";
import "./chunk-AIDV7EKX.js";
import "./chunk-FZQZIM7U.js";
import {
  r as r7
} from "./chunk-QEYOWTXD.js";
import "./chunk-CZBRZ6SU.js";
import {
  m as m4
} from "./chunk-KDO6J2FO.js";
import {
  b as b4,
  c as c4,
  g as g2,
  h as h5,
  i as i2,
  l as l7,
  m as m3,
  n as n7,
  r as r6,
  s as s6,
  u as u7,
  x as x2
} from "./chunk-RT3T2K4S.js";
import {
  $,
  L,
  u as u5
} from "./chunk-WJCI2CGX.js";
import {
  d as d6
} from "./chunk-REIQNAQW.js";
import {
  g as g4
} from "./chunk-J6LQZWZI.js";
import {
  S as S2,
  b as b6,
  b2 as b7,
  c as c5,
  c2 as c8,
  d as d4,
  f as f5,
  f2 as f6,
  h as h7,
  i as i3,
  j as j5,
  l2 as l9,
  m as m5
} from "./chunk-OD3FDQCI.js";
import "./chunk-J2PJNRU7.js";
import {
  c as c7,
  t as t5
} from "./chunk-56SPM3WK.js";
import {
  A as A2,
  B,
  D as D2,
  E as E3,
  F as F2,
  G as G2,
  M as M3,
  P as P2,
  R as R2,
  S,
  V,
  a as a6,
  c as c6,
  d as d3,
  f as f4,
  g as g3,
  h as h6,
  l as l8,
  p as p4,
  q as q3,
  u as u8,
  w as w6
} from "./chunk-XMZAPOBR.js";
import "./chunk-BLJKKR5D.js";
import {
  d as d2
} from "./chunk-ZGNCYHMZ.js";
import "./chunk-X2S4RQJ4.js";
import "./chunk-FUPLN7UM.js";
import "./chunk-376OPXM4.js";
import {
  i as i10,
  o as o12
} from "./chunk-DER356EU.js";
import "./chunk-MZIWIEIR.js";
import "./chunk-TQEOEDAZ.js";
import "./chunk-SHFHZMHO.js";
import {
  e as e6,
  u as u4
} from "./chunk-NRP45AHD.js";
import "./chunk-IWQ7452U.js";
import "./chunk-NAN5J6QS.js";
import "./chunk-B4DKBAM3.js";
import {
  D,
  M as M2,
  R,
  a as a5,
  b as b3,
  h as h4,
  m as m2,
  p as p3,
  u as u6,
  y as y3
} from "./chunk-6M2AHKYV.js";
import "./chunk-SZIJNKCV.js";
import "./chunk-6O43OEU5.js";
import "./chunk-J2K7ZDSV.js";
import "./chunk-2UML3WQZ.js";
import "./chunk-KXVMEIWT.js";
import {
  j as j4
} from "./chunk-UDND2Z3V.js";
import "./chunk-23Y3DIC6.js";
import "./chunk-JUVQV3R3.js";
import {
  l as l4
} from "./chunk-RAX2HD42.js";
import "./chunk-ZYRIJWLX.js";
import {
  F,
  a as a3,
  h as h2,
  l as l3
} from "./chunk-C5H57NTD.js";
import {
  G,
  H,
  O,
  P,
  _,
  c,
  e as e3,
  g,
  j,
  o as o2,
  q as q2,
  r as r4,
  s as s2,
  u,
  x,
  z
} from "./chunk-3LR5O4WA.js";
import {
  a as a2,
  l as l2,
  r as r5
} from "./chunk-GDVNKPJ7.js";
import {
  e as e2,
  f,
  l,
  n as n2,
  r as r2
} from "./chunk-D4V6J5BT.js";
import {
  a,
  r as r3
} from "./chunk-OSHI574D.js";
import "./chunk-YWAQYJRC.js";
import "./chunk-B356PXLT.js";
import "./chunk-EHPBHJYZ.js";
import {
  c as c2,
  u2 as u3,
  v2
} from "./chunk-3MNMDUQZ.js";
import {
  M,
  w as w3,
  w2 as w4
} from "./chunk-UWG37XSU.js";
import {
  E as E2,
  k2 as k
} from "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import "./chunk-HLM6QCL2.js";
import "./chunk-RXYULINL.js";
import {
  U,
  a as a4,
  f as f3,
  h as h3,
  j as j3,
  l as l6,
  w as w5
} from "./chunk-5NXILPDI.js";
import {
  n as n6
} from "./chunk-THVR7IAM.js";
import "./chunk-ZWJJTUFL.js";
import "./chunk-XQN7F674.js";
import "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import {
  It,
  nt
} from "./chunk-KAN4HXCG.js";
import "./chunk-4FEGON7M.js";
import "./chunk-VWYWOOPX.js";
import "./chunk-M5VHU5LK.js";
import "./chunk-CXFRNDG4.js";
import "./chunk-7QMMKGW4.js";
import {
  e as e4,
  l as l5,
  m,
  n as n4,
  n2 as n5,
  t5 as t3,
  v,
  y as y2
} from "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import {
  e as e5
} from "./chunk-U2XHEJM7.js";
import {
  A,
  C as C2,
  E,
  d,
  f as f2,
  j as j2,
  p as p2,
  w as w2
} from "./chunk-MJXQTGI2.js";
import {
  s as s4
} from "./chunk-LIZHLHNA.js";
import {
  n as n3,
  t as t2
} from "./chunk-BTUHYGXO.js";
import {
  s2 as s3
} from "./chunk-UA3YPL2R.js";
import {
  has,
  y
} from "./chunk-HVKDYDPP.js";
import {
  C,
  u as u2
} from "./chunk-6QC7MLLS.js";
import {
  b,
  e,
  h,
  i,
  n,
  o,
  p,
  q,
  r,
  s,
  t,
  w
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/views/3d/layers/LayerView3D.js
var n14 = (n26) => {
  let c31 = class extends n26 {
    constructor() {
      super(...arguments), this.slicePlaneEnabled = false, this.supportsHeightUnitConversion = false;
    }
    postscript(e31) {
      super.postscript(e31), g8(this.layer) && this.addResolvingPromise(this._validateHeightModelInfo());
    }
    async _validateHeightModelInfo() {
      const e31 = new AbortController(), o24 = e31.signal;
      this.handles.add(n4(() => e31.abort())), await j3(() => {
        var _a;
        return (_a = this.view.defaultsFromMap) == null ? void 0 : _a.heightModelInfoReady;
      }, o24), f2(o24);
      const i23 = o15(this.layer, this.view.heightModelInfo, this.supportsHeightUnitConversion);
      if (i23)
        throw i23;
    }
    canResume() {
      const e31 = this.layer && "effectiveScaleRange" in this.layer ? this.layer.effectiveScaleRange : null;
      return super.canResume() && (!e31 || !e31.minScale || !e31.maxScale || e31.minScale >= e31.maxScale);
    }
    getSuspendInfo() {
      const e31 = super.getSuspendInfo(), s23 = this.layer && "effectiveScaleRange" in this.layer ? this.layer.effectiveScaleRange : null;
      return s23 && s23.minScale && s23.maxScale && s23.minScale < s23.maxScale && (e31.outsideScaleRange = true), e31;
    }
  };
  return e4([y2()], c31.prototype, "view", void 0), e4([y2()], c31.prototype, "slicePlaneEnabled", void 0), c31 = e4([n5("esri.views.3d.layers.LayerView3D")], c31), c31;
};

// node_modules/@arcgis/core/views/3d/layers/graphics/elevationAlignPointsInFeatures.js
async function m12(t24, n26, i23, f25, m19) {
  const { elevationProvider: j14, renderCoordsHelper: u33, spatialReference: y17 } = t24, { elevationInfo: v23 } = n26, I12 = d12(v23, true), g21 = await u17(I12, y17, m19);
  f2(m19);
  const x20 = [], h25 = /* @__PURE__ */ new Set(), w16 = /* @__PURE__ */ new Set();
  for (const { objectId: o24, points: a29 } of f25) {
    const p21 = i23(o24);
    if (t(p21)) {
      for (const e31 of a29)
        x20.push(e31[2]);
      h25.add(o24);
      continue;
    }
    p21.isDraped && w16.add(o24);
    const f26 = p21.graphic.geometry;
    c17.setFromElevationInfo(a14(f26, v23)), c17.updateFeatureExpressionInfoContext(g21, p21.graphic, n26), l20.spatialReference = t24.spatialReference;
    for (const { x: e31, y: o25, z: t25 } of a29)
      l20.x = e31, l20.y = o25, l20.z = t25 != null ? t25 : 0, d11(l20, j14, c17, u33, d14), x20.push(d14.z);
  }
  return { elevations: x20, drapedObjectIds: w16, failedObjectIds: h25 };
}
var c17 = new h16();
var l20 = v8(0, 0, 0, k.WGS84);
var d14 = new j8();

// node_modules/@arcgis/core/renderers/support/renderingInfoUtils.js
function i16(e31, o24) {
  if (!e31 || e31.symbol)
    return null;
  const r30 = o24 && o24.renderer;
  return e31 && r(r30) && r30.getObservationRenderer ? r30.getObservationRenderer(e31) : r30;
}
function n15(e31, o24) {
  if (r(e31.symbol))
    return e31.symbol;
  const r30 = i16(e31, o24);
  return r(r30) && "dot-density" !== r30.type ? r30.getSymbol(e31, o24) : null;
}
function a20(e31, t24) {
  var _a;
  const a29 = i16(e31, t24), l32 = n15(e31, t24);
  if (t(l32))
    return null;
  const s23 = { renderer: a29, symbol: l32 };
  if (t(a29) || !("visualVariables" in a29) || !a29.visualVariables)
    return s23;
  const u33 = (_a = N(a29, e31, t24)) != null ? _a : [], c31 = ["proportional", "proportional", "proportional"];
  for (const { variable: o24, value: r30 } of u33)
    switch (o24.type) {
      case "color":
        s23.color = r30.toRgba();
        break;
      case "size":
        if ("outline" === o24.target)
          s23.outlineSize = r30;
        else {
          const e32 = o24.axis, t25 = o24.useSymbolValue ? "symbol-value" : r30;
          switch (e32) {
            case "width":
              c31[0] = t25;
              break;
            case "depth":
              c31[1] = t25;
              break;
            case "height":
              c31[2] = t25;
              break;
            case "width-and-depth":
              c31[0] = c31[1] = t25;
              break;
            default:
              c31[0] = c31[1] = c31[2] = t25;
          }
        }
        break;
      case "opacity":
        s23.opacity = r30;
        break;
      case "rotation":
        switch (o24.axis) {
          case "tilt":
            s23.tilt = r30;
            break;
          case "roll":
            s23.roll = r30;
            break;
          default:
            s23.heading = r30;
        }
    }
  return "proportional" === c31[0] && "proportional" === c31[1] && "proportional" === c31[2] || (s23.size = c31), s23;
}
async function l21(e31, o24) {
  if (r(e31.symbol))
    return e31.symbol;
  const r30 = i16(e31, o24);
  return r(r30) ? r30.getSymbolAsync(e31, o24) : null;
}
async function s14(t24, o24) {
  var _a;
  const n26 = i16(t24, o24), a29 = await l21(t24, o24);
  if (!a29)
    return null;
  const s23 = { renderer: n26, symbol: a29 };
  if (!n26 || !("visualVariables" in n26) || !n26.visualVariables)
    return s23;
  const u33 = (_a = N(n26, t24, o24)) != null ? _a : [], c31 = ["proportional", "proportional", "proportional"];
  for (const { variable: r30, value: i23 } of u33)
    if ("color" === r30.type)
      s23.color = l4.toUnitRGBA(i23);
    else if ("size" === r30.type)
      if ("outline" === r30.target)
        s23.outlineSize = i23;
      else {
        const e31 = r30.axis, t25 = r30.useSymbolValue ? "symbol-value" : i23;
        "width" === e31 ? c31[0] = t25 : "depth" === e31 ? c31[1] = t25 : "height" === e31 ? c31[2] = t25 : c31[0] = c31[1] = "width-and-depth" === e31 ? t25 : c31[2] = t25;
      }
    else
      "opacity" === r30.type ? s23.opacity = i23 : "rotation" === r30.type && "tilt" === r30.axis ? s23.tilt = i23 : "rotation" === r30.type && "roll" === r30.axis ? s23.roll = i23 : "rotation" === r30.type && (s23.heading = i23);
  return (isFinite(c31[0]) || isFinite(c31[1]) || isFinite(c31[2])) && (s23.size = c31), s23;
}
function u19(e31, t24 = 0) {
  const o24 = e31[t24];
  return "number" == typeof o24 && isFinite(o24) ? o24 : null;
}
function c18(e31) {
  for (let t24 = 0; t24 < 3; t24++) {
    const o24 = e31[t24];
    if ("number" == typeof o24)
      return isFinite(o24) ? o24 : 0;
  }
  return 0;
}

// node_modules/@arcgis/core/views/3d/layers/graphics/constants.js
var s15 = 1.2;
var c19 = l10;

// node_modules/@arcgis/core/symbols/support/defaults3D.js
var a21 = h7.fromSimpleMarkerSymbol(c9);
var c20 = b7.fromSimpleLineSymbol(u9);
var S6 = S2.fromSimpleFillSymbol(a7);
var u20 = new c8({ symbolLayers: [new f5({ material: { color: e7 }, edges: new c5({ size: "1px", color: i4 }) })] });
function b12(r30) {
  if (t(r30))
    return null;
  switch (r30.type) {
    case "mesh":
      return u20;
    case "point":
    case "multipoint":
      return a21;
    case "polyline":
      return c20;
    case "polygon":
    case "extent":
      return S6;
  }
  return null;
}

// node_modules/@arcgis/core/views/3d/layers/graphics/ElevationQuery.js
var n16 = class {
  constructor(e31, t24) {
    this.spatialReference = e31, this._view = t24;
  }
  getElevation(e31, t24, r30) {
    return this._view.elevationProvider.getElevation(e31, t24, 0, this.spatialReference, r30);
  }
  async queryElevation(e31, t24, r30, s23, i23) {
    return this._view.elevationProvider.queryElevation(e31, t24, 0, this.spatialReference, i23, r30, s23);
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/enums.js
var E12;
var C7;
!function(E23) {
  E23[E23.GRAPHIC = 0] = "GRAPHIC", E23[E23.LABEL = 1] = "LABEL", E23[E23._COUNT = 2] = "_COUNT";
}(E12 || (E12 = {})), function(E23) {
  E23[E23.USER_SETTING = 0] = "USER_SETTING", E23[E23.SCALE_RANGE = 1] = "SCALE_RANGE", E23[E23.FILTER = 2] = "FILTER", E23[E23.DECONFLICTION = 3] = "DECONFLICTION", E23[E23._COUNT = 4] = "_COUNT";
}(C7 || (C7 = {}));

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DFeatureStore.js
var l22 = class extends m {
  constructor(t24) {
    super(t24), this.events = new n6(), this.hasZ = null, this.hasM = null, this.objectIdField = null, this.viewSpatialReference = null, this.featureAdapter = { getAttribute: (t25, e31) => "graphic" in t25 ? t25.graphic.attributes[e31] : i11.getAttribute(t25, e31), getAttributes: (t25) => "graphic" in t25 ? t25.graphic.attributes : i11.getAttributes(t25), getObjectId: (t25) => "graphic" in t25 ? O5(t25.graphic, this.objectIdField) : i11.getObjectId(t25), getGeometry: (t25) => "graphic" in t25 ? t25.getAsOptimizedGeometry(this.hasZ, this.hasM) : i11.getGeometry(t25), getCentroid: (t25, e31) => {
      if ("graphic" in t25) {
        let r30 = null;
        r(t25.centroid) ? r30 = t25.centroid : "point" === t25.graphic.geometry.type && pn(t25.graphic.geometry, u22, this.viewSpatialReference) && (r30 = u22);
        const i23 = new Array(2 + (e31.hasZ ? 1 : 0) + (e31.hasM ? 1 : 0));
        return t(r30) ? (i23[0] = 0, i23[1] = 0, i23[2] = 0, i23[3] = 0) : (i23[0] = r30.x, i23[1] = r30.y, e31.hasZ && (i23[2] = r30.hasZ ? r30.z : 0), e31.hasM && (i23[e31.hasZ ? 3 : 2] = r30.hasM ? r30.m : 0)), new t4([], i23);
      }
      return i11.getCentroid(t25, e31);
    }, cloneWithGeometry: (t25, e31) => "graphic" in t25 ? new s5(e31, this.featureAdapter.getAttributes(t25), null, this.featureAdapter.getObjectId(t25)) : i11.cloneWithGeometry(t25, e31) };
  }
  forEachInBounds(t24, e31) {
    this.getSpatialIndex().forEachInBounds(t24, e31);
  }
  forEachBounds(t24, e31, r30) {
    const s23 = this.getSpatialIndex();
    for (const i23 of t24) {
      const t25 = this.featureAdapter.getObjectId(i23);
      r(s23.getBounds(t25, r30)) && e31(r30);
    }
  }
};
e4([y2({ constructOnly: true })], l22.prototype, "getSpatialIndex", void 0), e4([y2({ constructOnly: true })], l22.prototype, "toArray", void 0), e4([y2({ constructOnly: true })], l22.prototype, "forEach", void 0), e4([y2({ constructOnly: true })], l22.prototype, "hasZ", void 0), e4([y2({ constructOnly: true })], l22.prototype, "hasM", void 0), e4([y2({ constructOnly: true })], l22.prototype, "objectIdField", void 0), e4([y2({ constructOnly: true })], l22.prototype, "viewSpatialReference", void 0), e4([y2({ constructOnly: true })], l22.prototype, "featureSpatialReference", void 0), l22 = e4([n5("esri.views.3d.layers.graphics.Graphics3DFeatureStore")], l22);
var u22 = { type: "point", x: 0, y: 0, hasZ: false, hasM: false, spatialReference: null };

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DGraphicCreationContext.js
var r17 = class {
  constructor(r30, s23, t24) {
    this.graphic = r30, this.renderingInfo = s23, this.layer = t24;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DSymbolCreationContext.js
var e19 = class {
  constructor(e31) {
    this.schedule = e31, this.sharedResources = null, this.streamDataRequester = null, this.elevationProvider = null, this.renderer = null, this.stage = null, this.clippingExtent = null, this.renderCoordsHelper = null, this.overlaySR = null, this.layer = null, this.drapeSourceRenderer = null, this.graphicsCoreOwner = null, this.localOriginFactory = null, this.featureExpressionInfoContext = null, this.screenSizePerspectiveEnabled = true, this.slicePlaneEnabled = false, this.physicalBasedRenderingEnabled = false, this.skipHighSymbolLods = false, this.isAsync = false;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/ElevationAligners.js
function p13(t24, e31, o24, a29) {
  const r30 = t24.stageObject, n26 = r30.geometryRecords;
  let s23 = 0;
  for (const i23 of n26) {
    const { update: t25, averageGeometrySampledElevation: n27 } = O6(i23, e31, o24, a29);
    s23 += n27, t25 && r30.geometryVertexAttrsUpdated(i23);
  }
  return s23 / n26.length;
}
function d15(t24, o24, r30, s23) {
  const l32 = t24.stageObject, f25 = o24.centerPointInElevationSR;
  let u33 = 0;
  if (l32.metadata.usesVerticalDistanceToGround)
    d11(f25, r30, o24, s23, M6), U4(l32, M6.verticalDistanceToGround), u33 = M6.sampledElevation;
  else {
    d11(f25, r30, o24, s23, M6);
    "absolute-height" !== o24.mode && (u33 = M6.sampledElevation);
  }
  const p21 = n7(g10, l32.transformation), d27 = o2(E13, p21[12], p21[13], p21[14]);
  t14.TESTS_DISABLE_OPTIMIZATIONS ? (T6[0] = f25.x, T6[1] = f25.y, T6[2] = M6.z, Zn(f25.spatialReference, T6, p21, s23.spatialReference) && (l32.transformation = p21)) : s23.setAltitudeOfTransformation(M6.z, p21);
  const I12 = S7 / s23.unitInMeters;
  return (Math.abs(p21[12] - d27[0]) >= I12 || Math.abs(p21[13] - d27[1]) >= I12 || Math.abs(p21[14] - d27[2]) >= I12) && (l32.transformation = p21), u33;
}
var g10 = e9();
function I5(e31, o24, r30, s23) {
  const l32 = e31.graphics3DSymbolLayer.lodRenderer;
  if (t(l32))
    return 0;
  const c31 = o24.centerPointInElevationSR;
  d11(c31, r30, o24, s23, M6);
  const f25 = "absolute-height" !== o24.mode ? M6.sampledElevation : 0, u33 = l32.instanceData, p21 = e31.instanceIndex, d27 = A7;
  u33.getGlobalTransform(p21, d27);
  const g21 = o2(E13, d27[12], d27[13], d27[14]);
  t14.TESTS_DISABLE_OPTIMIZATIONS ? (T6[0] = c31.x, T6[1] = c31.y, T6[2] = M6.z, Zn(c31.spatialReference, T6, d27, s23.spatialReference) && u33.setGlobalTransform(p21, d27)) : s23.setAltitudeOfTransformation(M6.z, d27);
  const I12 = S7 / s23.unitInMeters;
  return (t14.TESTS_DISABLE_OPTIMIZATIONS || Math.abs(d27[12] - g21[0]) >= I12 || Math.abs(d27[13] - g21[1]) >= I12 || Math.abs(d27[14] - g21[2]) >= I12) && u33.setGlobalTransform(p21, d27), f25;
}
function b13(t24, e31, o24, a29) {
  const r30 = t24.stageObject, n26 = r30.geometryRecords;
  if (0 === n26.length)
    return 0;
  let s23 = 0, i23 = null, l32 = 0, c31 = false;
  for (const m19 of n26) {
    const t25 = m19.geometry.vertexAttributes.get(O2.POSITION);
    if (t25 !== i23) {
      const { update: r31, averageGeometrySampledElevation: n27 } = O6(m19, e31, o24, a29);
      l32 = n27, i23 = t25, c31 = r31;
    }
    c31 && r30.geometryVertexAttrsUpdated(m19), s23 += l32;
  }
  return s23 / n26.length;
}
var S7 = 0.01;
var T6 = n2();
var h17 = n2();
var v13 = n2();
var A7 = e9();
var E13 = n2();
var M6 = new j8();
function O6(t24, e31, o24, a29) {
  let r30 = false;
  const n26 = o24.spatialReference, l32 = t24.geometry, c31 = t24.getShaderTransformation(), p21 = e31.requiresSampledElevationInfo;
  h17[0] = c31[12], h17[1] = c31[13], h17[2] = c31[14], l32.invalidateBoundingInfo();
  const d27 = l32.getMutableAttribute(O2.POSITION), g21 = d27.data, I12 = l32.vertexAttributes.get(O2.MAPPOS).data, b26 = d27.size, A12 = g21.length / b26, E23 = new t15(I12, n26);
  let O13 = 0, y17 = 0;
  for (let f25 = 0; f25 < A12; f25++) {
    if (v13[0] = g21[O13], v13[1] = g21[O13 + 1], v13[2] = g21[O13 + 2], d11(E23, o24, e31, a29, M6), p21 && (y17 += M6.sampledElevation), t14.TESTS_DISABLE_OPTIMIZATIONS)
      g21[O13] = E23.array[E23.offset], g21[O13 + 1] = E23.array[E23.offset + 1], g21[O13 + 2] = M6.z, xn(g21, n26, O13, g21, a29.spatialReference, O13, 1), g21[O13] -= h17[0], g21[O13 + 1] -= h17[1], g21[O13 + 2] -= h17[2], r30 = true;
    else {
      T6[0] = g21[O13] + h17[0], T6[1] = g21[O13 + 1] + h17[1], T6[2] = g21[O13 + 2] + h17[2], a29.setAltitude(T6, M6.z), g21[O13] = T6[0] - h17[0], g21[O13 + 1] = T6[1] - h17[1], g21[O13 + 2] = T6[2] - h17[2];
      const t25 = S7 / a29.unitInMeters;
      (Math.abs(v13[0] - g21[O13]) >= t25 || Math.abs(v13[1] - g21[O13 + 1]) >= t25 || Math.abs(v13[2] - g21[O13 + 2]) >= t25) && (r30 = true);
    }
    O13 += b26, E23.offset += 3;
  }
  return y17 /= A12, { update: r30, averageGeometrySampledElevation: y17 };
}

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DObject3DGraphicLayer.js
var _8 = class {
  constructor(e31, t24, s23, i23, a29, r30, n26, o24 = null) {
    this.graphics3DSymbolLayer = e31, this.stageObject = t24, this._uniqueGeometries = s23, this._uniqueMaterials = i23, this._sharedResource = a29, this.elevationAligner = r30, this.elevationContext = n26, this._edgeState = o24, this.type = "object3d", this._stageLayer = null, this._stage = null, this._visible = false, this._addedToStage = false, this.alignedSampledElevation = 0, this.needsElevationUpdates = false, this.useObjectOriginAsAttachmentOrigin = false, this.graphics3DSymbolLayer = e31, this.stageObject = t24;
  }
  get isElevationSource() {
    return !(!this.stageObject.metadata || !this.stageObject.metadata.isElevationSource);
  }
  initialize(e31, t24) {
    this._stageLayer = t24, this._stage = e31, e31.addMany(this._uniqueMaterials), e31.addMany(this._uniqueGeometries), e31.add(this.stageObject);
  }
  destroy() {
    const t24 = this._stage;
    this._stageLayer && (t24.removeMany(this._uniqueMaterials), t24.removeMany(this._uniqueGeometries)), t24.remove(this.stageObject), this._addedToStage && (this._stageLayer.remove(this.stageObject), this._addedToStage = false);
    const s23 = this._stage.renderView.ensureEdgeView();
    s23.hasObject(this.stageObject) && s23.removeObject(this.stageObject), this.stageObject.dispose(), r(this._sharedResource) && this._sharedResource.release(), this._visible = false, this._stageLayer = null, this._stage = null;
  }
  layerOpacityChanged(e31, s23) {
    if (t(this._edgeState))
      return;
    const i23 = v14(this._edgeState.baseMaterial);
    let a29 = false;
    for (const t24 of this._edgeState.edgeMaterials)
      t24.objectTransparency !== i23 && (t24.objectTransparency = i23, a29 = true);
    a29 && this._resetEdgeObject(s23);
    this._stage.renderView.ensureEdgeView().updateAllComponentOpacities(this.stageObject, [e31]);
  }
  slicePlaneEnabledChanged(e31, s23) {
    if (t(this._edgeState))
      return;
    this._stage.renderView.ensureEdgeView().updateAllComponentMaterials(this.stageObject, this._edgeState.edgeMaterials, { hasSlicePlane: e31 }, !s23), this._edgeState.properties.hasSlicePlane = e31;
  }
  setVisibility(t24) {
    if (null != this._stage && this._visible !== t24 && (this._visible = t24, this._visible ? this._addedToStage ? this.stageObject.setVisible(true) : (this._stageLayer.add(this.stageObject), this._addedToStage = true) : this.stageObject.setVisible(false), r(this._edgeState))) {
      const e31 = this._stage.renderView.ensureEdgeView();
      e31.hasObject(this.stageObject) ? e31.updateObjectVisibility(this.stageObject, t24) : t24 && this._addOrUpdateEdgeObject(e31, false);
    }
  }
  get visible() {
    return this._visible;
  }
  alignWithElevation(t24, s23, i23, a29) {
    null != this.elevationAligner && (r(i23) && i13(this.elevationContext.featureExpressionInfoContext, i23), this.alignedSampledElevation = this.elevationAligner(this, this.elevationContext, t24, s23), this._resetEdgeObject(a29));
  }
  getCenterObjectSpace(e31 = n2()) {
    return r4(e31, k3(this.stageObject.boundingVolumeObjectSpace.bounds));
  }
  getBoundingBoxObjectSpace(e31 = a6()) {
    const t24 = this.stageObject.boundingVolumeObjectSpace;
    return d3(e31, t24.min), q3(e31, t24.max), e31;
  }
  computeAttachmentOrigin(e31) {
    if (this.useObjectOriginAsAttachmentOrigin) {
      const t24 = this.stageObject.transformation;
      e31.render.origin[0] += t24[12], e31.render.origin[1] += t24[13], e31.render.origin[2] += t24[14], e31.render.num++;
    } else
      for (const t24 of this.stageObject.geometryRecords)
        t24.computeAttachmentOrigin(y6) && (O(y6, y6, this.stageObject.transformation), u(e31.render.origin, e31.render.origin, y6), e31.render.num++);
  }
  async getProjectedBoundingBox(e31, t24, i23, r30, n26) {
    const o24 = this.getBoundingBoxObjectSpace(n26), c31 = E14, h25 = P2(o24) ? 1 : c31.length;
    for (let s23 = 0; s23 < h25; s23++) {
      const e32 = c31[s23];
      S8[0] = o24[e32[0]], S8[1] = o24[e32[1]], S8[2] = o24[e32[2]], O(S8, S8, this.stageObject.transformation), f16[3 * s23 + 0] = S8[0], f16[3 * s23 + 1] = S8[1], f16[3 * s23 + 2] = S8[2];
    }
    if (!e31(f16, 0, h25))
      return null;
    A2(o24);
    let u33 = null;
    this.calculateRelativeScreenBounds && (u33 = this.calculateRelativeScreenBounds());
    for (let s23 = 0; s23 < 3 * h25; s23 += 3) {
      for (let e32 = 0; e32 < 3; e32++)
        o24[e32] = Math.min(o24[e32], f16[s23 + e32]), o24[e32 + 3] = Math.max(o24[e32 + 3], f16[s23 + e32]);
      u33 && i23.push({ location: f16.slice(s23, s23 + 3), screenSpaceBoundingRect: u33 });
    }
    if (t24 && t24.service && "absolute-height" !== this.elevationContext.mode) {
      p4(o24, y6);
      const e32 = "relative-to-scene" === this.elevationContext.mode ? "scene" : "ground";
      let i24 = 0;
      if (t24.useViewElevation)
        i24 = i(t24.service.getElevation(y6[0], y6[1], e32), 0);
      else
        try {
          const a29 = X(o24, t24.service.spatialReference, t24);
          i24 = i(await t24.service.queryElevation(y6[0], y6[1], r30, a29, e32), 0);
        } catch (O13) {
        }
      V(o24, 0, 0, -this.alignedSampledElevation + i24);
    }
    return o24;
  }
  addObjectState(e31, t24) {
    e31 === u13.Highlight && t24.addObject(this.stageObject, this.stageObject.highlight()), e31 === u13.MaskOccludee && t24.addObject(this.stageObject, this.stageObject.maskOccludee());
  }
  removeObjectState(e31) {
    e31.removeObject(this.stageObject);
  }
  _resetEdgeObject(e31) {
    if (t(this._edgeState))
      return;
    const s23 = this._stage.renderView.ensureEdgeView();
    this._visible ? this._addOrUpdateEdgeObject(s23, e31) : s23.removeObject(this.stageObject);
  }
  _addOrUpdateEdgeObject(e31, s23) {
    const i23 = this._edgeState;
    if (t(i23))
      return;
    const a29 = v14(i23.baseMaterial);
    for (const t24 of i23.edgeMaterials)
      t24.objectTransparency = a29;
    e31.addOrUpdateObject3D(this.stageObject, i23.edgeMaterials, i23.properties, !s23).then(() => {
      var _a;
      return (_a = this._stageLayer) == null ? void 0 : _a.sync();
    });
  }
};
function v14(e31) {
  return e31.isVisible ? e31.parameters.transparent ? A3.TRANSPARENT : A3.OPAQUE : A3.INVISIBLE;
}
var f16 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
var S8 = n2();
var y6 = n2();
var E14 = [[0, 1, 2], [3, 1, 2], [0, 4, 2], [3, 4, 2], [0, 1, 5], [3, 1, 5], [0, 4, 5], [3, 4, 5]];

// node_modules/@arcgis/core/views/3d/layers/graphics/interfaces.js
var e20;
!function(e31) {
  e31[e31.Recreate_Symbol = 0] = "Recreate_Symbol", e31[e31.Recreate_Graphics = 1] = "Recreate_Graphics", e31[e31.Fast_Update = 2] = "Fast_Update";
}(e20 || (e20 = {}));

// node_modules/@arcgis/core/views/3d/layers/graphics/Loadable.js
var a23 = class {
  constructor(t24) {
    this.schedule = t24, this._abortController = null, this._loadStatus = e21.LOADING, this._loadError = null, this._loader = null, this.logger = null;
  }
  destroy() {
    this.abortLoad();
  }
  get loadStatus() {
    return this._loadStatus;
  }
  load(r30, l32) {
    return this._loadStatus === e21.LOADED ? (r30 && r30(), i(this._loader, Promise.resolve())) : this._loadStatus === e21.FAILED ? (l32 && l32(this._loadError), i(this._loader, Promise.resolve())) : (t(this._loader) && (this._abortController = new AbortController(), this._loader = this.doLoad(this._abortController.signal).then(() => {
      this._abortController = null, this._loadStatus = e21.LOADED;
    }, (t24) => {
      throw this._loadError = t24, this._abortController = null, this._loadStatus = e21.FAILED, !j2(t24) && this.logger && t24.message && this.logger.warn(t24.message), t24;
    })), this._loader.then(r30, l32).catch(() => {
    }), this._loader);
  }
  abortLoad() {
    r(this._abortController) ? this._abortController = p(this._abortController) : this._loadStatus === e21.LOADING && (this._loadStatus = e21.FAILED), this._loader = null;
  }
};
var e21;
!function(t24) {
  t24[t24.LOADING = 0] = "LOADING", t24[t24.LOADED = 1] = "LOADED", t24[t24.FAILED = 2] = "FAILED";
}(e21 || (e21 = {}));

// node_modules/@arcgis/core/views/3d/layers/graphics/primitiveObjectSymbolUtils.js
function r18(e31) {
  switch (e31) {
    case "sphere":
    case "cube":
    case "diamond":
    case "cylinder":
    case "cone":
    case "inverted-cone":
    case "tetrahedron":
      return true;
  }
  return false;
}
function o17(r30, o24) {
  const S18 = (n26, s23, a29 = false) => ({ levels: n26.map((n27) => {
    const t24 = s23(n27.tesselation);
    return a29 && D4(t24), { components: [{ geometry: t24, material: o24 }], faceCount: t24.indexCount / 3, minScreenSpaceRadius: n27.minScreenSpaceRadius };
  }) });
  switch (r30) {
    case "sphere":
      return S18([{ tesselation: 0, minScreenSpaceRadius: 0 }, { tesselation: 1, minScreenSpaceRadius: 8 }, { tesselation: 2, minScreenSpaceRadius: 16 }, { tesselation: 3, minScreenSpaceRadius: 50 }, { tesselation: 4, minScreenSpaceRadius: 250 }], (e31) => R8(0.5, e31, true));
    case "cube":
      return S18([{ tesselation: 0, minScreenSpaceRadius: 0 }], () => v9(1));
    case "cone":
      return S18(u23, (e31) => C6(1, 0.5, e31, false), true);
    case "inverted-cone":
      return S18(u23, (e31) => C6(1, 0.5, e31, true), true);
    case "cylinder":
      return S18(u23, (e31) => E10(1, 0.5, e31, [0, 0, 1], [0, 0, 0.5]));
    case "tetrahedron":
      return S18([{ tesselation: 0, minScreenSpaceRadius: 0 }], () => L3(1), true);
    case "diamond":
      return S18([{ tesselation: 0, minScreenSpaceRadius: 0 }], () => x8(1), true);
    default:
      return;
  }
}
var u23 = [{ tesselation: 6, minScreenSpaceRadius: 0 }, { tesselation: 18, minScreenSpaceRadius: 7 }, { tesselation: 64, minScreenSpaceRadius: 65 }];

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/lodRendering/LodResources.js
function r19(r30) {
  const e31 = [];
  return r30.levels.forEach((o24) => {
    o24.components.forEach((o25) => {
      e31.push(o25.material);
    });
  }), u2(e31);
}
function e22(r30) {
  const e31 = new Array();
  return r30.levels.forEach((o24) => {
    o24.components.forEach((o25) => {
      o25.textures && e31.push(...o25.textures);
    });
  }), u2(e31);
}
function n17(r30) {
  const e31 = [];
  return r30.components.forEach((o24) => {
    e31.push(o24.geometry);
  }), u2(e31);
}
function t17(r30) {
  const e31 = [];
  return r30.levels.forEach((o24) => {
    o24.components.forEach((o25) => {
      e31.push(o25.geometry);
    });
  }), u2(e31);
}
function c21(o24) {
  return n17(o24).reduce((o25, r30) => o25 + r30.indexCount / 3, 0);
}

// node_modules/@arcgis/core/views/3d/layers/graphics/symbolComplexity.js
var b14 = { primitivesPerFeature: 0, primitivesPerCoordinate: 0, drawCallsPerFeature: 0, estimated: true, memory: { bytesPerFeature: 0, bytesPerCoordinate: 0, bytesPerFeatureLabel: 0, resourceBytes: 0, draped: { bytesPerFeature: 0, bytesPerFeatureLabel: 0, bytesPerCoordinate: 0 } } };
function y7(e31) {
  if ("web-style" === e31.type)
    return b14;
  return P5(e31.symbolLayers.toArray().map((r30) => m13(e31, r30)));
}
function P5(e31) {
  let t24 = 0, a29 = 0, s23 = 0, i23 = false, o24 = 0;
  const u33 = { bytesPerFeature: 0, bytesPerFeatureLabel: 0, bytesPerCoordinate: 0, resourceBytes: 0, draped: { bytesPerFeature: 0, bytesPerFeatureLabel: 0, bytesPerCoordinate: 0 } };
  for (const b26 of e31)
    t(b26) || (t24 += b26.primitivesPerFeature, a29 += b26.primitivesPerCoordinate, s23 += b26.drawCallsPerFeature, u33.bytesPerFeature += b26.memory.bytesPerFeature, u33.bytesPerFeatureLabel += b26.memory.bytesPerFeatureLabel, u33.bytesPerCoordinate += b26.memory.bytesPerCoordinate, u33.resourceBytes += b26.memory.resourceBytes, u33.draped.bytesPerFeature += b26.memory.bytesPerFeature, u33.draped.bytesPerFeatureLabel += b26.memory.bytesPerFeatureLabel, u33.draped.bytesPerCoordinate += b26.memory.bytesPerCoordinate, i23 = i23 || b26.estimated, ++o24);
  return { primitivesPerFeature: t24, primitivesPerCoordinate: a29, drawCallsPerFeature: s23, estimated: i23, memory: u33, numComplexities: o24 };
}
function d16(e31) {
  const r30 = P5(e31);
  return r30.numComplexities > 0 && (r30.primitivesPerFeature /= r30.numComplexities, r30.primitivesPerCoordinate /= r30.numComplexities, r30.drawCallsPerFeature /= r30.numComplexities, r30.memory.bytesPerFeature /= r30.numComplexities, r30.memory.bytesPerFeatureLabel /= r30.numComplexities, r30.memory.bytesPerCoordinate /= r30.numComplexities, r30.memory.resourceBytes /= r30.numComplexities, r30.memory.draped.bytesPerFeature /= r30.numComplexities, r30.memory.draped.bytesPerFeatureLabel /= r30.numComplexities, r30.memory.draped.bytesPerCoordinate /= r30.numComplexities), r30;
}
var n18 = {};
function m13(r30, s23) {
  const o24 = l23(r30, s23), u33 = a10(s23) ? 2 : 0;
  switch (s23.type) {
    case "extrude":
      return { primitivesPerFeature: -4, primitivesPerCoordinate: 4, drawCallsPerFeature: u33, estimated: false, memory: o24 };
    case "fill":
      return "mesh-3d" === r30.type ? { primitivesPerFeature: 0, primitivesPerCoordinate: 0, drawCallsPerFeature: u33, estimated: false, memory: o24 } : r(s23.outline) && s23.outline.size > 0 ? { primitivesPerFeature: -4, primitivesPerCoordinate: 3, drawCallsPerFeature: 0, estimated: false, memory: o24 } : { primitivesPerFeature: -2, primitivesPerCoordinate: 1, drawCallsPerFeature: 0, estimated: false, memory: o24 };
    case "water":
      return { primitivesPerFeature: -2, primitivesPerCoordinate: 1, drawCallsPerFeature: 0, estimated: false, memory: o24 };
    case "line":
      return { primitivesPerFeature: -2, primitivesPerCoordinate: 2, drawCallsPerFeature: 0, estimated: false, memory: o24 };
    case "object":
      if (s23.resource && s23.resource.href)
        return { primitivesPerFeature: 16, primitivesPerCoordinate: 0, drawCallsPerFeature: 0, estimated: true, memory: o24 };
      return { ...F6(s23.resource && s23.resource.primitive || d4), memory: o24 };
    case "path": {
      const r31 = 3, t24 = 3, a29 = 10;
      let i23 = 0, u34 = 0;
      switch (s23.profile) {
        case "circle":
          i23 = a29;
          break;
        case "quad":
          i23 = 4;
          break;
        default:
          return void n8(s23.profile);
      }
      switch (s23.join) {
        case "round":
          u34 = r31;
          break;
        case "miter":
        case "bevel":
          u34 = 1;
          break;
        default:
          return void n8(s23.join);
      }
      const b26 = 2 * i23, y17 = i23 * u34 * 2;
      let P11 = -2 * y17 - b26;
      switch (s23.cap) {
        case "none":
          break;
        case "butt":
        case "square":
          P11 += 2 * (i23 - 1);
          break;
        case "round":
          P11 += 2 * (i23 * (t24 - 1) * 2 + i23);
          break;
        default:
          return;
      }
      return { primitivesPerFeature: P11, primitivesPerCoordinate: y17 + b26, drawCallsPerFeature: 0, estimated: false, memory: o24 };
    }
    case "text":
    case "icon":
      return { primitivesPerFeature: 2, primitivesPerCoordinate: 0, drawCallsPerFeature: 0, estimated: false, memory: o24 };
    default:
      return;
  }
}
function l23(r30, a29) {
  const s23 = "point-3d" === r30.type;
  switch (a29.type) {
    case "extrude":
      return a29.edges && a29.edges.size > 0 ? c22.EXTRUDE_EDGES : c22.EXTRUDE;
    case "fill":
      return r(a29.outline) && a29.outline.size > 0 ? c22.FILL_OUTLINE : c22.FILL;
    case "water":
      return c22.FILL;
    case "line":
      return "round" === a29.join ? c22.LINE_ROUND : c22.LINE_MITER;
    case "path":
      switch (a29.join) {
        case "round":
          switch (a29.profile) {
            case "circle":
              return c22.PATH_ROUND_CIRCLE;
            case "quad":
              return c22.PATH_ROUND_QUAD;
            default:
              return void n8(a29.profile);
          }
        case "miter":
        case "bevel":
          switch (a29.profile) {
            case "circle":
              return c22.PATH_MITER_CIRCLE;
            case "quad":
              return c22.PATH_MITER_QUAD;
            default:
              return void n8(a29.profile);
          }
        default:
          return void n8(a29.join);
      }
    case "object":
      return s23 ? c22.OBJECT_POINT : c22.OBJECT_POLYGON;
    case "icon":
    case "text":
      return s23 ? c22.ICON_POINT : c22.ICON_POLYGON;
    default:
      return;
  }
}
function F6(e31) {
  let r30 = n18[e31];
  if (r30)
    return r30;
  const t24 = o17(e31, null);
  return r30 = { primitivesPerFeature: n17(t24.levels[0]).reduce((e32, r31) => e32 + r31.indices.get(O2.POSITION).length / 3, 0), primitivesPerCoordinate: 0, drawCallsPerFeature: 0, estimated: false }, n18[e31] = r30, r30;
}
var c22 = { ICON_POINT: { bytesPerFeature: 7127.413186968842, bytesPerFeatureLabel: 4826.302896296296, bytesPerCoordinate: 0, resourceBytes: 0, draped: { bytesPerFeature: 3929.4396628895197, bytesPerFeatureLabel: 3550.1332222222227, bytesPerCoordinate: 0 } }, ICON_POLYGON: { bytesPerFeature: 9329.452613976147, bytesPerFeatureLabel: 3675.3372604938268, bytesPerCoordinate: 60.177252982212096, resourceBytes: 0, draped: { bytesPerFeature: 6190.247450139383, bytesPerFeatureLabel: 3744.074358024691, bytesPerCoordinate: 59.488211068026104 } }, OBJECT_POINT: { bytesPerFeature: 2350.5884192634558, bytesPerFeatureLabel: 4446.651003703703, bytesPerCoordinate: 0, resourceBytes: 0, draped: { bytesPerFeature: 2350.5884192634558, bytesPerFeatureLabel: 4446.651003703703, bytesPerCoordinate: 0 } }, OBJECT_POLYGON: { bytesPerFeature: 4583.807620302299, bytesPerFeatureLabel: 3665.342685185186, bytesPerCoordinate: 60.11621818101506, resourceBytes: 0, draped: { bytesPerFeature: 4583.807620302299, bytesPerFeatureLabel: 3665.342685185186, bytesPerCoordinate: 60.11621818101506 } }, LINE_MITER: { bytesPerFeature: 7321.028181375921, bytesPerFeatureLabel: 4048.0226716049388, bytesPerCoordinate: 186.55621386363578, resourceBytes: 0, draped: { bytesPerFeature: 4246.856619435009, bytesPerFeatureLabel: 3852.3737679012347, bytesPerCoordinate: 163.47884002621583 } }, LINE_ROUND: { bytesPerFeature: 7482.205842738954, bytesPerFeatureLabel: 4045.886987654321, bytesPerCoordinate: 191.5452524171851, resourceBytes: 0, draped: { bytesPerFeature: 4473.481387957992, bytesPerFeatureLabel: 3842.1112395061728, bytesPerCoordinate: 167.27703460226945 } }, PATH_MITER_CIRCLE: { bytesPerFeature: 9010.489006415351, bytesPerFeatureLabel: 4230.9109, bytesPerCoordinate: 4618.2594178027275, resourceBytes: 0, draped: { bytesPerFeature: 9010.489006415351, bytesPerFeatureLabel: 4230.9109, bytesPerCoordinate: 4618.2594178027275 } }, PATH_ROUND_CIRCLE: { bytesPerFeature: 4104.727250200398, bytesPerFeatureLabel: 4251.8525, bytesPerCoordinate: 8019.043777064957, resourceBytes: 0, draped: { bytesPerFeature: 4104.727250200398, bytesPerFeatureLabel: 4251.8525, bytesPerCoordinate: 8019.043777064957 } }, PATH_MITER_QUAD: { bytesPerFeature: 9416.372942261387, bytesPerFeatureLabel: 4241.2757, bytesPerCoordinate: 3176.7222742582203, resourceBytes: 0, draped: { bytesPerFeature: 9416.372942261387, bytesPerFeatureLabel: 4241.2757, bytesPerCoordinate: 3176.7222742582203 } }, PATH_ROUND_QUAD: { bytesPerFeature: 6614.431545308682, bytesPerFeatureLabel: 4206.7461, bytesPerCoordinate: 5141.817789093826, resourceBytes: 0, draped: { bytesPerFeature: 6614.431545308682, bytesPerFeatureLabel: 4206.7461, bytesPerCoordinate: 5141.817789093826 } }, FILL: { bytesPerFeature: 9478.244183633637, bytesPerFeatureLabel: 3713.816824691358, bytesPerCoordinate: 95.9343604185578, resourceBytes: 0, draped: { bytesPerFeature: 6287.911108168086, bytesPerFeatureLabel: 3790.785032098766, bytesPerCoordinate: 83.08783220478168 } }, FILL_OUTLINE: { bytesPerFeature: 13085.871870349445, bytesPerFeatureLabel: 3392.613241975309, bytesPerCoordinate: 118.63968023169875, resourceBytes: 0, draped: { bytesPerFeature: 8437.199992480122, bytesPerFeatureLabel: 3973.5431172839503, bytesPerCoordinate: 106.33556817014312 } }, EXTRUDE: { bytesPerFeature: 19459.53727140414, bytesPerFeatureLabel: 3743.7045209876546, bytesPerCoordinate: 372.6819978900477, resourceBytes: 0, draped: { bytesPerFeature: 19459.53727140414, bytesPerFeatureLabel: 3743.7045209876546, bytesPerCoordinate: 372.6819978900477 } }, EXTRUDE_EDGES: { bytesPerFeature: 22266.888534913724, bytesPerFeatureLabel: 3064.3193358024696, bytesPerCoordinate: 374.3725221561312, resourceBytes: 0, draped: { bytesPerFeature: 22266.888534913724, bytesPerFeatureLabel: 3064.3193358024696, bytesPerCoordinate: 374.3725221561312 } } };

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DSymbolLayer.js
var f17 = s3.getLogger("esri.views.3d.layers.graphics.Graphics3DSymbolLayer");
var y8 = class extends a23 {
  constructor(e31, t24, i23, o24) {
    super(i23.schedule), this._context = i23, this._elevationInfoOverride = null, this._ignoreDrivers = false, this._drivenProperties = { color: false, opacity: false, opacityAlwaysOpaque: true, size: false }, this.complexity = null, this.logger = f17, this._elevationOptions = { supportsOffsetAdjustment: false, supportsOnTheGround: true }, this.symbol = e31, this.symbolLayer = t24, this._renderPriority = o24.renderPriority, this._renderPriorityStep = o24.renderPriorityStep, this._elevationContext = new h16(), this.complexity = this.computeComplexity(), this._ignoreDrivers = o24.ignoreDrivers, this._ignoreDrivers || (this._drivenProperties = g11(this._context.renderer)), this._updateElevationContext();
  }
  getCachedSize() {
    return null;
  }
  get extentPadding() {
    return 0;
  }
  _drivenPropertiesChanged(e31) {
    if (this._ignoreDrivers)
      return false;
    const t24 = this._drivenProperties, i23 = g11(e31);
    return i23.color !== t24.color || i23.opacity !== t24.opacity || i23.opacityAlwaysOpaque !== t24.opacityAlwaysOpaque || i23.size !== t24.size;
  }
  get needsDrivenTransparentPass() {
    return this._drivenProperties.opacity && !this._drivenProperties.opacityAlwaysOpaque;
  }
  _logGeometryCreationWarnings(e31, t24, i23, o24) {
    const r30 = e31.projectionSuccess, n26 = "polygons" in e31 ? e31.polygons : null, s23 = `${o24} geometry failed to be created`;
    let a29 = null;
    r30 ? !this._logGeometryValidationWarnings(t24, i23, o24) && n26 && 0 === n26.length && "rings" === i23 && t24.length > 0 && t24[0].length > 2 && (a29 = `${s23} (filled rings should use clockwise winding - try reversing the order of vertices)`) : a29 = `${s23} (failed to project geometry to view spatial reference)`, a29 && f17.warnOncePerTick(a29);
  }
  _logGeometryValidationWarnings(e31, t24, i23) {
    const o24 = `${i23} geometry failed to be created`;
    return !e31.length || 1 === e31.length && !e31[0].length ? (f17.warnOncePerTick(`${o24} (no ${t24} were defined)`), true) : (!Array.isArray(e31) || !Array.isArray(e31[0])) && (f17.warnOncePerTick(`${o24} (${t24} should be defined as a 2D array)`), true);
  }
  _validateGeometry(e31, t24 = null, o24 = null) {
    if (r(t24) && !t24.includes(e31.type))
      return this.logger.warn("unsupported geometry type for " + o24 + ` symbol: ${e31.type}`), false;
    if ("point" === e31.type) {
      const t25 = e31;
      if (!isFinite(t25.x) || !isFinite(t25.y))
        return f17.warn("point coordinate is not a valid number, graphic skipped"), false;
    }
    return true;
  }
  _defaultElevationInfoNoZ() {
    return m14;
  }
  _defaultElevationInfoZ() {
    return _9;
  }
  _updateElevationContext() {
    r(this._elevationInfoOverride) ? (this._elevationContext.setFromElevationInfo(this._elevationInfoOverride), this._elevationContext.updateFeatureExpressionInfoContext(null)) : this._context.layer.elevationInfo ? (this._elevationContext.setFromElevationInfo(this._context.layer.elevationInfo), this._elevationContext.updateFeatureExpressionInfoContext(this._context.featureExpressionInfoContext)) : this._elevationContext.reset();
  }
  getDefaultElevationInfo(e31) {
    return e31.hasZ ? this._defaultElevationInfoZ() : this._defaultElevationInfoNoZ();
  }
  getGeometryElevationMode(e31, t24 = this.getDefaultElevationInfo(e31)) {
    return this._elevationContext.mode || t24.mode;
  }
  setElevationInfoOverride(e31) {
    this._elevationInfoOverride = e31, this._updateElevationContext();
  }
  setGraphicElevationContext(e31, t24) {
    const i23 = e(e31.geometry), n26 = this.getDefaultElevationInfo(i23);
    t24.unit = null != this._elevationContext.unit ? this._elevationContext.unit : n26.unit, t24.mode = this.getGeometryElevationMode(i23, n26), t24.offsetMeters = i(this._elevationContext.meterUnitOffset, i(n26.offset, 0));
    const s23 = !this._elevationOptions.supportsOnTheGround && "on-the-ground" === t24.mode;
    s23 && (t24.mode = "relative-to-ground", t24.offsetMeters = 0);
    const a29 = s23 ? f14 : this._elevationContext.featureExpressionInfoContext;
    return t24.updateFeatureExpressionInfoContext(a29, e31, this._context.layer), t24;
  }
  prepareSymbolLayerPatch(e31) {
  }
  updateGeometry(e31, t24) {
    return false;
  }
  onRemoveGraphic(e31) {
  }
  _getLayerOpacity() {
    if (this._context.graphicsCoreOwner && "fullOpacity" in this._context.graphicsCoreOwner)
      return this._context.graphicsCoreOwner.fullOpacity;
    const e31 = this._context.layer.opacity;
    return e31 != null ? e31 : 1;
  }
  _getCombinedOpacity(e31, t24 = x11) {
    let o24 = 1;
    return this.draped || (o24 *= this._getLayerOpacity()), this._drivenProperties.opacity || (r(e31) ? o24 *= e31.a : t24.hasIntrinsicColor || (o24 = 0)), o24;
  }
  _getCombinedOpacityAndColor(t24, o24 = x11) {
    const r30 = this._getCombinedOpacity(t24, o24);
    if (this._drivenProperties.color)
      return B4(null, r30);
    const s23 = r(t24) ? l4.toUnitRGB(t24) : l;
    return B4(s23, r30);
  }
  _getVertexOpacityAndColor(e31, t24 = null) {
    const o24 = this._drivenProperties.color ? e31.color : null, r30 = this._drivenProperties.opacity ? e31.opacity : null, n26 = B4(o24, r30);
    return r(t24) && (n26[0] *= t24, n26[1] *= t24, n26[2] *= t24, n26[3] *= t24), n26;
  }
  isFastUpdatesEnabled() {
    return this._fastUpdates && this._fastUpdates.enabled;
  }
  computeComplexity() {
    return m13(this.symbol, this.symbolLayer);
  }
  globalPropertyChanged(e31, t24, i23) {
    switch (e31) {
      case "opacity":
        return this.layerOpacityChanged(t24, i23), true;
      case "elevationInfo": {
        const e32 = this._elevationContext.mode;
        this._updateElevationContext();
        return this.layerElevationInfoChanged(t24, i23, e32) !== x9.RECREATE;
      }
      case "slicePlaneEnabled":
        return this.slicePlaneEnabledChanged(t24, i23);
      case "physicalBasedRenderingEnabled":
        return this.physicalBasedRenderingChanged();
      case "pixelRatio":
        return this.pixelRatioChanged();
      default:
        return false;
    }
  }
  updateGraphics3DGraphicElevationInfo(e31, t24, o24) {
    let r30 = x9.UPDATE;
    return e31.forEach((e32) => {
      const n26 = t24(e32);
      if (r(n26)) {
        const t25 = e32.graphic;
        this.setGraphicElevationContext(t25, n26.elevationContext), n26.needsElevationUpdates = o24(n26.elevationContext.mode);
      } else
        r30 = x9.RECREATE;
    }), r30;
  }
  applyRendererDiff(e31, t24) {
    return e20.Recreate_Symbol;
  }
  getFastUpdateAttrValues(e31) {
    if (!this._fastUpdates.enabled)
      return null;
    const t24 = this._fastUpdates.visualVariables, i23 = t24.size ? v15(t24.size.field, e31) : 0, o24 = t24.color ? v15(t24.color.field, e31) : 0, r30 = t24.opacity ? v15(t24.opacity.field, e31) : 0;
    return r8(i23, o24, r30, 0);
  }
  get draped() {
    return this._draped;
  }
  ensureDrapedStatus(e31) {
    return null == this._draped ? (this._draped = e31, true) : (e31 !== this.draped && f17.warnOnce("A symbol can only produce either draped or non-draped visualizations. Use two separate symbol instances for draped and non-draped graphics if necessary."), false);
  }
  test() {
    const e31 = () => {
      var _a, _b, _c, _d, _e6, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
      return { size: (_d = (_c = (_b = (_a = this._fastUpdates) == null ? void 0 : _a.visualVariables) == null ? void 0 : _b.size) == null ? void 0 : _c.field) != null ? _d : null, color: (_h = (_g = (_f = (_e6 = this._fastUpdates) == null ? void 0 : _e6.visualVariables) == null ? void 0 : _f.color) == null ? void 0 : _g.field) != null ? _h : null, opacity: (_l = (_k = (_j = (_i = this._fastUpdates) == null ? void 0 : _i.visualVariables) == null ? void 0 : _j.opacity) == null ? void 0 : _k.field) != null ? _l : null, rotation: (_p = (_o = (_n = (_m = this._fastUpdates) == null ? void 0 : _m.visualVariables) == null ? void 0 : _n.rotation) == null ? void 0 : _o.field) != null ? _p : null };
    };
    return { drivenProperties: this._drivenProperties, getVisVarFields: e31 };
  }
};
function v15(e31, t24) {
  const i23 = null != e31 ? t24.attributes[e31] : 0;
  return null != i23 && isFinite(i23) ? i23 : 0;
}
function g11(e31) {
  const t24 = { color: false, opacity: false, opacityAlwaysOpaque: true, size: false };
  return e31 && "visualVariables" in e31 && e31.visualVariables && e31.visualVariables.forEach((e32) => {
    switch (e32.type) {
      case "color":
        if (t24.color = true, e32.stops)
          for (let i23 = 0; i23 < e32.stops.length; i23++) {
            const o24 = e32.stops[i23].color;
            o24 && (t24.opacity = true, o24.a < 1 && (t24.opacityAlwaysOpaque = false));
          }
        break;
      case "opacity":
        t24.opacity = true, t24.opacityAlwaysOpaque = false;
        break;
      case "size":
        t24.size = true;
    }
  }), t24;
}
var m14 = { mode: "on-the-ground", offset: 0, unit: "meters" };
var _9 = { mode: "absolute-height", offset: 0, unit: "meters" };
var x11 = { hasIntrinsicColor: false };

// node_modules/@arcgis/core/views/3d/layers/graphics/pointUtils.js
var m15 = n2();
function u24(t24, i23, s23, a29, l32, u33, f25, d27) {
  const g21 = s23 ? s23.length : 0, h25 = t24.clippingExtent;
  if (gn(i23, m15, t24.elevationProvider.spatialReference), r(h25) && !E3(h25, m15))
    return null;
  gn(i23, m15, t24.renderCoordsHelper.spatialReference);
  const j14 = t24.localOriginFactory.getOrigin(m15), y17 = new x7({ castShadow: false, metadata: { layerUid: u33, graphicUid: f25, usesVerticalDistanceToGround: true } });
  for (let e31 = 0; e31 < g21; e31++) {
    const t25 = o3;
    y17.addGeometry(s23[e31], a29[e31], t25, j14, d27);
  }
  return { object: y17, sampledElevation: h15(y17, i23, t24.elevationProvider, t24.renderCoordsHelper, l32) };
}
function f18(r30, t24, n26) {
  const i23 = r30.elevationContext, s23 = n26.spatialReference;
  gn(t24, m15, s23), i23.centerPointInElevationSR = v8(m15[0], m15[1], t24.hasZ ? m15[2] : 0, r(s23) ? s23 : null);
}
function d17(e31) {
  switch (e31.type) {
    case "point":
      return e31;
    case "polygon":
    case "extent":
      return A6(e31);
    case "polyline": {
      const r30 = e31.paths[0];
      if (!r30 || 0 === r30.length)
        return null;
      const t24 = u3(r30, c2(r30) / 2);
      return v8(t24[0], t24[1], t24[2], e31.spatialReference);
    }
    case "mesh":
      return e31.origin;
  }
  return null;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/LineCalloutTechnique.js
var h18 = class extends e12 {
  initializeConfiguration(i23, t24) {
    t24.spherical = i23.viewingMode === l14.Global;
  }
  initializeProgram(e31) {
    return new o10(e31.rctx, h18.shader.get().build(this.configuration), E5);
  }
  setPipelineState(e31) {
    const i23 = e31 ? I.ALWAYS : I.LESS;
    return this.configuration.depthHudEnabled ? W({ depthTest: { func: i23 }, depthWrite: a12 }) : W({ blending: l16(R4.ONE, R4.SRC_ALPHA, R4.ONE_MINUS_SRC_ALPHA, R4.ONE_MINUS_SRC_ALPHA), depthTest: { func: i23 }, colorWrite: _5 });
  }
  initializePipeline() {
    return this.setPipelineState(this.configuration.hasMultipassGeometry);
  }
};
h18.shader = new t12(u18, () => import("./LineCallout.glsl-P5UP5A6H.js"));

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/LineCalloutTechniqueConfiguration.js
var i17 = class extends s9 {
  constructor() {
    super(...arguments), this.screenCenterOffsetUnitsEnabled = p11.World, this.spherical = false, this.occlusionTestEnabled = true, this.hasVerticalOffset = false, this.hasScreenSizePerspective = false, this.depthHudEnabled = false, this.depthHudAlignStartEnabled = false, this.hasSlicePlane = false, this.hasMultipassGeometry = false;
  }
};
e4([e14({ count: p11.COUNT })], i17.prototype, "screenCenterOffsetUnitsEnabled", void 0), e4([e14()], i17.prototype, "spherical", void 0), e4([e14()], i17.prototype, "occlusionTestEnabled", void 0), e4([e14()], i17.prototype, "hasVerticalOffset", void 0), e4([e14()], i17.prototype, "hasScreenSizePerspective", void 0), e4([e14()], i17.prototype, "depthHudEnabled", void 0), e4([e14()], i17.prototype, "depthHudAlignStartEnabled", void 0), e4([e14()], i17.prototype, "hasSlicePlane", void 0), e4([e14()], i17.prototype, "hasMultipassGeometry", void 0), e4([e14({ constValue: true })], i17.prototype, "hasSliceInVertexProgram", void 0), e4([e14({ constValue: false })], i17.prototype, "isDraped", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/LineCalloutMaterial.js
var g12 = class extends d10 {
  constructor(e31) {
    super(e31, new S9()), this._configuration = new i17(), this._uniqueMaterialIdentifier = g12.uniqueMaterialIdentifier(this.parameters);
  }
  get uniqueMaterialIdentifier() {
    return this._uniqueMaterialIdentifier;
  }
  getPassParameters() {
    return this.parameters;
  }
  getConfiguration(t24, r30) {
    const i23 = (r30 == null ? void 0 : r30.slot) !== E8.LINE_CALLOUTS;
    return this._configuration.occlusionTestEnabled = this.parameters.occlusionTest, this._configuration.hasVerticalOffset = r(this.parameters.verticalOffset), this._configuration.hasScreenSizePerspective = r(this.parameters.screenSizePerspective), this._configuration.depthHudEnabled = i23, this._configuration.depthHudAlignStartEnabled = !!this.parameters.depthHUDAlignStart, this._configuration.screenCenterOffsetUnitsEnabled = "screen" === this.parameters.centerOffsetUnits ? p11.Screen : p11.World, this._configuration.hasSlicePlane = this.parameters.hasSlicePlane, this._configuration.hasMultipassGeometry = r30.multipassGeometry.enabled, this._configuration;
  }
  intersect() {
  }
  requiresSlot(e31, t24) {
    if (t24 === h9.Color)
      switch (e31) {
        case E8.LINE_CALLOUTS:
        case E8.LINE_CALLOUTS_HUD_DEPTH:
          return true;
      }
    return false;
  }
  createGLMaterial(e31) {
    return new O7(e31);
  }
  createBufferWriter() {
    return new b15();
  }
  validateParameters(e31) {
    const t24 = g12.uniqueMaterialIdentifier(e31);
    t24 !== this._uniqueMaterialIdentifier && (this._uniqueMaterialIdentifier = t24);
  }
  static uniqueMaterialIdentifier(e31) {
    return JSON.stringify({ screenOffset: e31.screenOffset || [0, 0], centerOffsetUnits: e31.centerOffsetUnits || "world" });
  }
};
var O7 = class extends t11 {
  beginSlot(e31) {
    return this.ensureTechnique(h18, e31);
  }
};
var S9 = class extends h11 {
  constructor() {
    super(...arguments), this.screenOffset = f8, this.color = [0, 0, 0, 1], this.size = 1, this.occlusionTest = false, this.shaderPolygonOffset = 1e-5, this.depthHUDAlignStart = false, this.centerOffsetUnits = "world", this.hasSlicePlane = false;
  }
};
var L4 = T2().vec3f(O2.POSITION).vec3f(O2.NORMAL).vec2f(O2.UV0).vec4f(O2.AUXPOS1);
var I6 = [t10(0, 0), t10(1, 0), t10(0, 1), t10(1, 0), t10(1, 1), t10(0, 1)];
var b15 = class {
  constructor() {
    this.vertexBufferLayout = L4;
  }
  allocate(e31) {
    return this.vertexBufferLayout.createBuffer(e31);
  }
  elementCount(e31) {
    return 6 * e31.indices.get(O2.POSITION).length;
  }
  write(e31, t24, r30, i23, s23) {
    y4(r30.indices.get(O2.POSITION), r30.vertexAttributes.get(O2.POSITION).data, e31, i23.position, s23, 6), B2(r30.indices.get(O2.NORMAL), r30.vertexAttributes.get(O2.NORMAL).data, t24, i23.normal, s23, 6), u14(r30.indices.get(O2.AUXPOS1), r30.vertexAttributes.get(O2.AUXPOS1).data, i23.auxpos1, s23, 6);
    for (let n26 = 0; n26 < I6.length; ++n26)
      i23.uv0.setVec(s23 + n26, I6[n26]);
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DLineCalloutSymbolLayer.js
var b16 = class extends y8 {
  constructor(e31, t24) {
    super(e31, null, t24, U6), this._elevationOptions = { supportsOffsetAdjustment: true, supportsOnTheGround: false }, this.ensureDrapedStatus(false);
  }
  async doLoad() {
    this._material = new g12(this._materialParameters), this._context.stage.add(this._material);
  }
  destroy() {
    super.destroy(), this._context.stage.remove(this._material), this._material = null;
  }
  _perInstanceMaterialParameters(e31) {
    const t24 = this._materialParameters;
    return t24.screenOffset = e31.screenOffset || f8, t24.centerOffsetUnits = e31.centerOffsetUnits || "world", t24;
  }
  get _materialParameters() {
    const r30 = this.symbol, a29 = r30.callout, n26 = r(a29.color) ? l4.toUnitRGBA(a29.color) : [0, 0, 0, 0];
    n26[3] *= this._getLayerOpacity();
    const s23 = u4(a29.size || 0);
    let o24 = null;
    if (r30.verticalOffset) {
      const { screenLength: e31, minWorldLength: a30, maxWorldLength: n27 } = r30.verticalOffset;
      o24 = { screenLength: u4(e31), minWorldLength: a30 || 0, maxWorldLength: r(n27) ? n27 : 1 / 0 };
    }
    const l32 = r(a29.border) && r(a29.border.color) ? l4.toUnitRGBA(a29.border.color) : null, c31 = "object" === r30.symbolLayers.getItemAt(0).type, m19 = !c31, d27 = c31 ? 0 : void 0, h25 = "label-3d" === r30.type;
    return { color: n26, size: s23, verticalOffset: o24, screenSizePerspective: this._context.screenSizePerspectiveEnabled ? this._context.sharedResources.screenSizePerspectiveSettings : null, screenOffset: [0, 0], centerOffsetUnits: "world", borderColor: l32, occlusionTest: m19, shaderPolygonOffset: d27, depthHUDAlignStart: h25, hasSlicePlane: this._context.slicePlaneEnabled, renderOccluded: o7.Occlude, __tagStrict: "NoParameters" };
  }
  _defaultElevationInfoNoZ() {
    return E15;
  }
  createGraphics3DGraphic(e31) {
    const t24 = e31.renderingInfo, i23 = e31.graphic, a29 = this.setGraphicElevationContext(i23, new h16(), t24.elevationOffset || 0), s23 = t24.symbol, o24 = "on-the-ground" === this._elevationContext.mode && ("cim" === s23.type || !s23.symbolLayers.some((e32) => "object" === e32.type || "text" === e32.type));
    if ("label-3d" !== s23.type && o24)
      return null;
    if ("point-3d" === s23.type && s23.symbolLayers.every((e32) => "text" === e32.type && !l9(e32)))
      return null;
    const l32 = A6(i23.geometry);
    return t(l32) ? null : this._createAs3DShape(l32, a29, t24, i23.uid);
  }
  layerOpacityChanged() {
    r(this._material) && this._material.setParameters(this._materialParameters);
  }
  layerElevationInfoChanged(e31, r30, i23) {
    const a29 = this._elevationContext.mode, n26 = p10(b16.elevationModeChangeTypes, i23, a29);
    return n26 !== x9.UPDATE || e31.forEach((e32) => {
      const i24 = r30(e32);
      r(i24) && this.updateGraphicElevationContext(e32.graphic, i24);
    }), n26;
  }
  slicePlaneEnabledChanged() {
    return t(this._material) || this._material.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled }), true;
  }
  physicalBasedRenderingChanged() {
    return true;
  }
  pixelRatioChanged() {
    return true;
  }
  setGraphicElevationContext(e31, t24, r30 = 0) {
    const i23 = super.setGraphicElevationContext(e31, t24);
    return i23.addOffsetRenderUnits(r30), i23;
  }
  updateGraphicElevationContext(e31, t24) {
    this.setGraphicElevationContext(e31, t24.elevationContext, t24.metadata.elevationOffset), t24.needsElevationUpdates = g9(t24.elevationContext.mode);
  }
  computeComplexity() {
    return { primitivesPerFeature: 2, primitivesPerCoordinate: 0, drawCallsPerFeature: 0, estimated: false, memory: b14.memory };
  }
  _createVertexData(e31) {
    const { translation: t24, centerOffset: r30 } = e31, i23 = t24 ? { size: 3, data: [t24[0], t24[1], t24[2]], exclusive: true } : { size: 3, data: [0, 0, 0], exclusive: true }, a29 = r30 ? { size: 4, data: [r30[0], r30[1], r30[2], r30[3]], exclusive: true } : { size: 4, data: [0, 0, 0, 1], exclusive: true };
    return [[O2.POSITION, i23], [O2.NORMAL, { size: 3, data: [0, 0, 1], exclusive: true }], [O2.AUXPOS1, a29]];
  }
  _getOrCreateMaterial(e31) {
    const i23 = this._perInstanceMaterialParameters(e31), a29 = g12.uniqueMaterialIdentifier(i23);
    if (r(this._material) && a29 === this._material.uniqueMaterialIdentifier)
      return { material: this._material, isUnique: false };
    if (e31.materialCollection) {
      let t24 = e31.materialCollection.get(a29);
      return t(t24) && (t24 = new g12(i23), e31.materialCollection.add(a29, t24)), { material: t24, isUnique: false };
    }
    return { material: new g12(i23), isUnique: true };
  }
  _createAs3DShape(e31, t24, r30, i23) {
    const a29 = this._context.stage.renderView._getObjectAndLayerIdColor({ graphicUid: i23, layerUid: this._context.layer.uid }), n26 = [new d8(this._createVertexData(r30), P6, a11.Point, a29)], o24 = this._getOrCreateMaterial(r30), l32 = u24(this._context, e31, n26, [o24.material], t24, this._context.layer.uid, i23);
    if (null === l32)
      return null;
    const m19 = new _8(this, l32.object, n26, o24.isUnique ? [o24.material] : null, null, d15, t24);
    return m19.metadata = { elevationOffset: r30.elevationOffset || 0 }, m19.alignedSampledElevation = l32.sampledElevation, m19.needsElevationUpdates = g9(t24.mode), f18(m19, e31, this._context.elevationProvider), m19;
  }
};
b16.elevationModeChangeTypes = { definedChanged: x9.UPDATE, staysOnTheGround: x9.UPDATE, onTheGroundChanged: x9.RECREATE };
var C8 = [0];
var P6 = [[O2.POSITION, C8], [O2.NORMAL, C8], [O2.AUXPOS1, C8]];
var E15 = { mode: "relative-to-ground", offset: 0 };
var U6 = { ignoreDrivers: true, renderPriority: 0, renderPriorityStep: 1 };

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DCalloutSymbolLayerFactory.js
var t18 = s3.getLogger("esri.views.3d.layers.graphics.Graphics3DCalloutSymbolLayerFactory");
function e23(o24, l32) {
  if (!i3(o24))
    return t18.error("Graphics3DCalloutSymbolLayerFactory#make", `symbol of type '${o24.type}' does not support callouts`), null;
  if (!o24.callout)
    return null;
  const e31 = a24[o24.callout.type];
  return e31 ? new e31(o24, l32) : (t18.error("Graphics3DCalloutSymbolLayerFactory#make", `unknown or unsupported callout type ${o24.callout.type}`), null);
}
var a24 = { line: b16 };

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DGraphic.js
var S10 = new e5(Array, (e31) => w6(e31, D2), null, 10, 5);
var B5 = u6();
var V4 = class {
  constructor(e31, i23, r30, s23, a29) {
    this.graphic = e31, this.graphics3DSymbol = i23, this.graphics = r30, this._labelGraphics = new Array(), this._auxiliaryGraphics = new Array(), this._visibilityFlags = z3(E12._COUNT, C7._COUNT), this._featureExpressionFeature = null, this._optimizedGeometry = { geometry: null, hasZ: false, hasM: false }, this._extent = null, this.isElevationSource = false, ++i23.referenced, this._featureExpressionFeature = a29 ? s12(a29, e31, s23) : null;
    for (const o24 of r30)
      r(o24) && (this.isElevationSource = this.isElevationSource || o24.isElevationSource);
  }
  get labelGraphics() {
    return this._labelGraphics;
  }
  get extent() {
    return this._extent;
  }
  initialize(e31, i23) {
    this._layer = i23, this._stage = e31, this._forEachSymbolLayerGraphic((t24) => {
      t24.initialize(e31, i23), t24.setVisibility(this.isVisible());
    });
  }
  destroy() {
    this._forEachSymbolLayerGraphic((e31) => e31.destroy()), this.graphics = null, this._auxiliaryGraphics = null, --this.graphics3DSymbol.referenced, this.graphics3DSymbol = null;
  }
  get destroyed() {
    return null == this.graphics;
  }
  clearLabelGraphics() {
    this._forEachLabelGraphic((e31) => e31.destroy()), this._labelGraphics.length = 0;
  }
  addLabelGraphic(e31, i23, t24) {
    this._labelGraphics.push(e31), e31.initialize(i23, t24), e31.setVisibility(this.isVisible(E12.LABEL));
  }
  addAuxiliaryGraphic(e31) {
    this._auxiliaryGraphics.push(e31), this._layer && (e31.initialize(this._stage, this._layer), e31.setVisibility(this.isVisible()));
  }
  get isDraped() {
    let e31 = false;
    return this._forEachSymbolLayerGraphic((i23) => {
      "draped" === i23.type && (e31 = true);
    }), e31;
  }
  isVisible(e31 = E12.GRAPHIC, i23) {
    for (let t24 = 0; t24 <= e31; t24++) {
      const e32 = this._visibilityFlags[t24];
      for (let t25 = 0; t25 < e32.length; ++t25)
        if (false === e32[t25] && t25 !== i23)
          return false;
    }
    return true;
  }
  hasVisibilityFlag(e31, i23) {
    return null != this._visibilityFlags[i23][e31];
  }
  setVisibilityFlag(e31, i23, t24) {
    const r30 = this.isVisible(t24);
    this._visibilityFlags[t24][e31] = i23;
    const s23 = this.isVisible(t24);
    if (r30 === s23)
      return false;
    if (t24 === E12.LABEL)
      this._forEachLabelGraphic((e32) => e32.setVisibility(s23));
    else {
      this._forEachSymbolLayerGraphic((e33) => e33.setVisibility(s23));
      const e32 = this.isVisible(E12.LABEL);
      this._forEachLabelGraphic((i24) => i24.setVisibility(e32));
    }
    return true;
  }
  clearVisibilityFlag(e31, i23 = E12.GRAPHIC) {
    return this.setVisibilityFlag(e31, void 0, i23);
  }
  computeExtent(e31) {
    if (!this._extent) {
      const i23 = this.graphic.geometry;
      if (t(i23))
        return false;
      this._extent = u6(), J(i23, this._extent);
      const t24 = i23.spatialReference;
      if (!E2(t24, e31) && !vn(this._extent, t24, this._extent, e31))
        return this._extent = null, false;
    }
    return true;
  }
  getAsOptimizedGeometry(e31, i23) {
    return r(this._optimizedGeometry.geometry) && this._optimizedGeometry.hasZ === e31 && this._optimizedGeometry.hasM === i23 || (this._optimizedGeometry.geometry = this._convertGraphicToOptimizedGeometry(this.graphic, e31, i23), this._optimizedGeometry.hasZ = e31, this._optimizedGeometry.hasM = i23), this._optimizedGeometry.geometry;
  }
  _convertGraphicToOptimizedGeometry(e31, i23, t24) {
    let r30 = e31.geometry;
    return "mesh" !== r30.type && "extent" !== r30.type || (r30 = v2.fromExtent("mesh" === r30.type ? r30.extent : r30)), nt2(r30, i23, t24);
  }
  get usedMemory() {
    let e31 = t8(this.graphic.attributes);
    return this._forEachSymbolLayerGraphic((i23) => {
      const t24 = i23.graphics3DSymbolLayer.complexity;
      if (t(t24))
        return;
      const s23 = "draped" === i23.type ? t24.memory.draped : t24.memory;
      e31 += s23.bytesPerFeature, s23.bytesPerCoordinate && (e31 += w8(this.graphic.geometry) * s23.bytesPerCoordinate);
    }), e31;
  }
  computeAttachmentOrigin() {
    const e31 = { render: { origin: n2(), num: 0 }, draped: { origin: n12(), num: 0 } };
    for (const i23 of this.graphics)
      t(i23) || i23.computeAttachmentOrigin(e31);
    return e31.render.num && g(e31.render.origin, e31.render.origin, 1 / e31.render.num), e31.draped.num && l11(e31.draped.origin, e31.draped.origin, 1 / e31.draped.num), e31;
  }
  async getProjectedBoundingBox(i23, t24, s23, a29, o24) {
    return o24 || (o24 = { boundingBox: null, requiresDrapedElevation: false, screenSpaceObjects: [] }), o24.boundingBox ? A2(o24.boundingBox) : o24.boundingBox = A2(), o24.requiresDrapedElevation = false, await c3(this.graphics, async (e31) => {
      if (t(e31))
        return;
      const h25 = "draped" === e31.type ? t24 : i23, n26 = S10.acquire(), c31 = await e31.getProjectedBoundingBox(h25, s23, o24.screenSpaceObjects, a29, n26);
      isFinite(c31[2]) && isFinite(c31[5]) || (o24.requiresDrapedElevation = true), c31 && f4(o24.boundingBox, n26), S10.release(n26);
    }), l8(o24.boundingBox) || M2(B(o24.boundingBox, B5)) ? o24 : null;
  }
  needsElevationUpdates() {
    for (const e31 of this.graphics)
      if (r(e31) && ("object3d" === e31.type || "lod-instance" === e31.type) && e31.needsElevationUpdates)
        return true;
    for (const e31 of this._labelGraphics)
      if (e31 && e31.needsElevationUpdates)
        return true;
    return false;
  }
  alignWithElevation(e31, i23, t24) {
    this._forEachRenderedGraphic((r30) => {
      "object3d" !== r30.type && "lod-instance" !== r30.type || r30.alignWithElevation(e31, i23, this._featureExpressionFeature, t24);
    });
  }
  addObjectStateSet(e31, i23) {
    this._forEachSymbolLayerGraphic((t24) => t24.addObjectState(e31, i23));
  }
  removeObjectState(e31) {
    this._forEachSymbolLayerGraphic((i23) => i23.removeObjectState(e31));
  }
  _forEachGraphicList(e31, i23) {
    e31.forEach((e32) => e32 && i23(e32));
  }
  _forEachSymbolLayerGraphic(e31) {
    this._forEachGraphicList(this.graphics, e31), this._forEachGraphicList(this._auxiliaryGraphics, e31);
  }
  _forEachLabelGraphic(e31) {
    this._forEachGraphicList(this._labelGraphics, e31);
  }
  _forEachRenderedGraphic(e31) {
    this._forEachSymbolLayerGraphic(e31), this._forEachLabelGraphic(e31);
  }
};
function z3(e31, i23) {
  const t24 = new Array(e31);
  for (let r30 = 0; r30 < t24.length; r30++)
    t24[r30] = new Array(i23);
  return t24;
}

// node_modules/@arcgis/core/views/3d/layers/graphics/polygonUtils.js
function n19(r30) {
  const s23 = [[O2.POSITION, r30.indices]], n26 = [[O2.POSITION, { size: 3, data: r30.attributeData.position, exclusive: true }]];
  return r(r30.attributeData.color) && (n26.push([O2.COLOR, { size: 4, data: r30.attributeData.color, exclusive: true }]), s23.push([O2.COLOR, new Array(r30.indices.length).fill(0)])), r(r30.attributeData.uvMapSpace) && (n26.push([O2.UVMAPSPACE, { size: 4, data: r30.attributeData.uvMapSpace, exclusive: true }]), s23.push([O2.UVMAPSPACE, r30.indices])), r(r30.attributeData.boundingRect) && (n26.push([O2.BOUNDINGRECT, { size: 9, data: r30.attributeData.boundingRect, exclusive: true }]), s23.push([O2.BOUNDINGRECT, r30.indices])), r(r30.attributeData.mapPosition) && (n26.push([O2.MAPPOS, { size: 3, data: r30.attributeData.mapPosition, exclusive: true }]), s23.push([O2.MAPPOS, r30.indices])), new d8(n26, s23, a11.Triangle, r30.attributeData.objectAndLayerIdColor);
}
function o18(e31) {
  const r30 = [[O2.POSITION, e31.indices], [O2.UV0, e31.indices]], s23 = [[O2.POSITION, { size: 3, data: e31.attributeData.position, exclusive: true }], [O2.UV0, { size: 2, data: e31.attributeData.uv0, exclusive: true }]];
  return r(e31.attributeData.mapPosition) && (s23.push([O2.MAPPOS, { size: 3, data: e31.attributeData.mapPosition, exclusive: true }]), r30.push([O2.MAPPOS, e31.indices])), new d8(s23, r30);
}
function u25(t24) {
  switch (t24.type) {
    case "extent":
      if (t24 instanceof w4)
        return v2.fromExtent(t24);
      break;
    case "polygon":
      return t24;
  }
  return null;
}
var c23 = class {
  constructor(t24, e31, i23) {
    this.renderData = t24, this.layerUid = e31, this.graphicsUid = i23, this.outGeometries = new Array(), this.outMaterials = new Array(), this.outTransforms = new Array();
  }
};

// node_modules/@arcgis/core/views/3d/support/renderInfoUtils/polygon.js
function e24(o24, s23, e31, r30) {
  const c31 = l13(o24.rings, o24.hasZ, c12.CCW_IS_HOLE), u33 = new Float64Array(c31.position.length), h25 = f13(c31.position, o24.spatialReference, 0, u33, 0, c31.position, 0, c31.position.length / 3, s23, e31, r30), g21 = null != h25;
  return new l24(c31.position, u33, a25(c31.polygons, c31.position, u33), p14(c31.outlines, c31.position, u33), g21, h25);
}
function r20(i23, e31) {
  const r30 = l13(i23.rings, false, c12.CCW_IS_HOLE), c31 = xn(r30.position, i23.spatialReference, 0, r30.position, e31, 0, r30.position.length / 3);
  for (let o24 = 2; o24 < r30.position.length; o24 += 3)
    r30.position[o24] = ue;
  return { position: r30.position, polygons: a25(r30.polygons, r30.position), outlines: p14(r30.outlines, r30.position), projectionSuccess: c31 };
}
function p14(o24, t24, n26) {
  return o24.filter(({ count: o25 }) => o25 > 1).map(({ index: o25, count: i23 }) => {
    const s23 = 3 * o25, e31 = s23 + 3 * i23;
    return n26 ? new u26(o25, i23, t24.subarray(s23, e31), n26.subarray(s23, e31)) : new c24(o25, i23, t24.subarray(s23, e31));
  });
}
function a25(o24, t24, n26) {
  const i23 = new Array();
  for (const { index: s23, count: e31, holeIndices: r30, pathLengths: p21 } of o24) {
    if (e31 <= 1)
      continue;
    const o25 = 3 * s23, a29 = o25 + 3 * e31, c31 = r30.map((o26) => o26 - s23);
    i23.push({ index: s23, count: e31, holeIndices: c31, pathLengths: p21, position: t24.subarray(o25, a29), mapPosition: n26 ? n26.subarray(o25, a29) : void 0 });
  }
  return i23;
}
var c24 = class {
  constructor(o24, t24, n26) {
    this.index = o24, this.count = t24, this.position = n26;
  }
};
var u26 = class extends c24 {
  constructor(o24, t24, n26, i23) {
    super(o24, t24, n26), this.mapPosition = i23;
  }
};
var l24 = class {
  constructor(o24, t24, n26, i23, s23, e31) {
    this.position = o24, this.mapPosition = t24, this.polygons = n26, this.outlines = i23, this.projectionSuccess = s23, this.sampledElevation = e31;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DExtrudeSymbolLayer.js
var X2 = ["polygon", "extent"];
var $2 = class extends y8 {
  constructor(e31, t24, r30, s23) {
    super(e31, t24, r30, s23), this.ensureDrapedStatus(false);
  }
  async doLoad() {
    if (!this._drivenProperties.size) {
      const t25 = S5(this._getSymbolSize());
      if (t25)
        throw new s4("graphics3dextrudesymbollayer:invalid-size", t25);
    }
    const t24 = q(this.symbolLayer, "material", "color"), s23 = this._getCombinedOpacityAndColor(t24), n26 = e2(s23), i23 = s23[3], o24 = i23 < 1 || this.needsDrivenTransparentPass, a29 = { usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: true, diffuse: n26, ambient: n26, opacity: i23, transparent: o24, cullFace: o24 ? n13.None : n13.Back, hasVertexColors: true, hasSlicePlane: this._context.slicePlaneEnabled, castShadows: this.symbolLayer.castShadows, offsetTransparentBackfaces: true };
    this._material = new C5(a29), this._bottomMaterial = new C5({ ...a29, cullFace: n13.Back }), this._context.stage.add(this._material), this._context.stage.add(this._bottomMaterial);
  }
  destroy() {
    super.destroy(), this._material && (this._context.stage.remove(this._material), this._context.stage.remove(this._bottomMaterial));
  }
  createGraphics3DGraphic(e31) {
    const t24 = e31.graphic;
    if (!this._validateGeometry(t24.geometry, X2, this.symbolLayer.type))
      return null;
    const r30 = this._getVertexOpacityAndColor(e31.renderingInfo, 255), s23 = this.setGraphicElevationContext(t24, new h16());
    return this._createAs3DShape(t24, e31.renderingInfo, r30, s23, t24.uid);
  }
  layerOpacityChanged(e31, t24) {
    const n26 = q(this.symbolLayer, "material", "color"), i23 = this._getCombinedOpacity(n26), o24 = i23 < 1 || this.needsDrivenTransparentPass;
    this._material.setParameters({ opacity: i23, transparent: o24 }), this._bottomMaterial.setParameters({ opacity: i23, transparent: o24 });
    const a29 = this._getLayerOpacity();
    e31.forEach((e32) => {
      const r30 = t24(e32);
      r(r30) && r30.layerOpacityChanged(a29, this._context.isAsync);
    });
  }
  layerElevationInfoChanged(e31, t24) {
    return this.updateGraphics3DGraphicElevationInfo(e31, t24, v10);
  }
  slicePlaneEnabledChanged(e31, t24) {
    return this._material.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled }), this._bottomMaterial.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled }), e31.forEach((e32) => {
      const r30 = t24(e32);
      r(r30) && r30.slicePlaneEnabledChanged(this._context.slicePlaneEnabled, this._context.isAsync);
    }), true;
  }
  physicalBasedRenderingChanged() {
    return this._material.setParameters({ usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: true }), this._bottomMaterial.setParameters({ usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: true }), true;
  }
  pixelRatioChanged() {
    return true;
  }
  _getExtrusionSize(e31) {
    var _a;
    let t24;
    return t24 = e31.size && this._drivenProperties.size ? (_a = u19(e31.size, 2)) != null ? _a : 0 : this._getSymbolSize(), t24 /= this._context.renderCoordsHelper.unitInMeters, t24;
  }
  applyRendererDiff(e31, t24) {
    return this._drivenPropertiesChanged(t24) ? e20.Recreate_Symbol : e20.Recreate_Graphics;
  }
  async queryForSnapping(e31, r30, s23, n26) {
    var _a, _b, _c;
    const o24 = this._getExtrusionSize(s23) * this._context.renderCoordsHelper.unitInMeters / L(r30), { objectId: a29, target: l32 } = e31, c31 = y(l32);
    switch (c31.z = ((_a = c31.z) != null ? _a : 0) + o24, e31.type) {
      case "edge": {
        const { start: r31, end: s24 } = e31, n27 = y(r31), i23 = y(s24);
        return n27.z = ((_b = n27.z) != null ? _b : 0) + o24, i23.z = ((_c = i23.z) != null ? _c : 0) + o24, [e15(a29, c31, 1 / 0, n27, i23)];
      }
      case "vertex":
        return [t13(a29, c31, 1 / 0), e15(a29, l32, 1 / 0, l32, c31)];
      default:
        return [];
    }
  }
  _getSymbolSize() {
    var _a;
    return (_a = this.symbolLayer.size) != null ? _a : 1;
  }
  _createAs3DShape(e31, t24, r30, i23, m19) {
    const d27 = u25(e31.geometry);
    if (t(d27))
      return null;
    if (0 === d27.rings.length || !d27.rings.some((e32) => e32.length > 0))
      return this._logGeometryValidationWarnings(d27.rings, "rings", "ExtrudeSymbol3DLayer"), null;
    const g21 = e24(d27, this._context.elevationProvider, this._context.renderCoordsHelper, i23);
    this._logGeometryCreationWarnings(g21, d27.rings, "rings", "ExtrudeSymbol3DLayer");
    const u33 = A6(d27);
    if (t(u33))
      return null;
    const f25 = new Array(), y17 = new Array(), _20 = new Array(), L8 = a6(), M13 = e9(), I12 = n2(), B10 = this._context.renderCoordsHelper.viewingMode === l14.Global;
    B10 || this._context.renderCoordsHelper.worldUpAtPosition(null, I12), Zn(d27.spatialReference, [u33.x, u33.y, 0], M13, this._context.renderCoordsHelper.spatialReference);
    const z8 = e9();
    h5(z8, M13);
    const R16 = e8();
    g6(R16, z8);
    const { polygons: D8, mapPosition: G9, position: k11 } = g21, V8 = k11.length / 3, H8 = new Float64Array(3 * V8 * 6), Z2 = new Float64Array(3 * V8 * 6), W5 = new Float64Array(3 * V8 * 6), q12 = new Float64Array(1 * V8 * 6);
    let K3 = 0;
    for (let s23 = 0; s23 < D8.length; ++s23) {
      const e32 = D8[s23], n26 = e32.count;
      if (this._context.clippingExtent && (A2(L8), M3(L8, e32.mapPosition), !R2(L8, this._context.clippingExtent)))
        continue;
      const i24 = x5(e32.mapPosition, e32.holeIndices, 3);
      if (0 === i24.length)
        continue;
      const a29 = 3 * n26 * 2 + i24.length, l32 = new Array(a29), c31 = new Array(i24.length), p21 = 6 * n26, d28 = 3 * H8.BYTES_PER_ELEMENT, g22 = new T(H8.buffer, K3 * d28, d28, (K3 + p21) * d28), u34 = 3 * Z2.BYTES_PER_ELEMENT, b26 = new T(Z2.buffer, K3 * u34, u34, (K3 + p21) * u34), x20 = new Float64Array(W5.buffer, 3 * K3 * W5.BYTES_PER_ELEMENT, 3 * p21), E23 = new Float64Array(q12.buffer, 1 * K3 * q12.BYTES_PER_ELEMENT, 1 * p21), M14 = this._getExtrusionSize(t24);
      te(k11, G9, i24, e32, g22.typedBuffer, x20, b26.typedBuffer, E23, l32, c31, M14, I12, B10), t7(g22, g22, z8), r11(b26, b26, R16), K3 += 6 * n26;
      const O13 = this._context.stage.renderView._getObjectAndLayerIdColor({ graphicUid: m19, layerUid: this._context.layer.uid }), C16 = ee2(l32, l32.length - c31.length, { positions: g22.typedBuffer, elevation: x20, normals: b26.typedBuffer, heights: E23 }, r30, O13);
      f25.push(C16), y17.push(this._material), _20.push(o3);
      const T9 = ee2(c31, 0, { positions: g22.typedBuffer, elevation: x20, normals: b26.typedBuffer, heights: E23 }, r30, O13);
      f25.push(T9), y17.push(this._bottomMaterial), _20.push(o3);
    }
    if (0 === f25.length)
      return null;
    const Q3 = new x7({ geometries: f25, materials: y17, transformations: _20, metadata: { layerUid: this._context.layer.uid, graphicUid: m19, isElevationSource: true } });
    Q3.transformation = M13;
    const X4 = f7(this.symbolLayer, { opacity: this._getLayerOpacity() }), $5 = r(X4) ? { baseMaterial: this._material, edgeMaterials: [X4], properties: { mergeGeometries: true, hasSlicePlane: this._context.slicePlaneEnabled } } : null, re2 = new _8(this, Q3, f25, null, null, de, i23, $5);
    return re2.alignedSampledElevation = g21.sampledElevation, re2.needsElevationUpdates = v10(i23.mode), re2;
  }
};
function ee2(e31, t24, r30, s23, n26) {
  const i23 = new Array(e31.length).fill(0), o24 = [[O2.POSITION, { size: 3, data: r30.positions, exclusive: true }], [O2.NORMAL, { size: 3, data: r30.normals, exclusive: true }], [O2.COLOR, { size: 4, data: s23, exclusive: true }], [O2.SIZE, { size: 1, data: r30.heights, exclusive: true }]], a29 = [[O2.POSITION, e31], [O2.NORMAL, e31], [O2.COLOR, i23]];
  return r30.elevation && (o24.push([O2.MAPPOS, { size: 3, data: r30.elevation }]), a29.push([O2.MAPPOS, e31])), new d8(o24, a29, a11.Triangle, n26, t24);
}
function te(e31, t24, r30, s23, n26, i23, o24, a29, l32, c31, h25, p21, m19) {
  const d27 = r30.length / 3;
  let g21 = 0, u33 = 2 * s23.count;
  re(e31, t24, s23.index, s23.count, r30, 0, d27, n26, i23, o24, a29, l32, c31, u33, h25, p21, m19);
  let f25 = 2 * s23.count;
  u33 = 0, ie(n26, i23, a29, o24, g21, s23.pathLengths[0], s23.count, f25, l32, u33, h25), f25 += 4 * s23.pathLengths[0], u33 += 2 * s23.pathLengths[0], g21 += s23.pathLengths[0];
  for (let y17 = 1; y17 < s23.pathLengths.length; ++y17)
    ie(n26, i23, a29, o24, g21, s23.pathLengths[y17], s23.count, f25, l32, u33, h25), f25 += 4 * s23.pathLengths[y17], u33 += 2 * s23.pathLengths[y17], g21 += s23.pathLengths[y17];
}
function re(e31, t24, r30, s23, n26, i23, o24, a29, l32, c31, h25, p21, g21, u33, f25, y17, _20) {
  r4(ue2, y17);
  const b26 = f25 > 0 ? 1 : -1;
  let x20 = 3 * r30, E23 = 0, P11 = 3 * E23, S18 = s23, j14 = 3 * S18;
  for (let m19 = 0; m19 < s23; ++m19)
    _20 && (ue2[0] = e31[x20 + 0], ue2[1] = e31[x20 + 1], ue2[2] = e31[x20 + 2], z(ue2, ue2)), a29[P11 + 0] = e31[x20 + 0], a29[P11 + 1] = e31[x20 + 1], a29[P11 + 2] = e31[x20 + 2], l32[P11 + 0] = t24[x20 + 0], l32[P11 + 1] = t24[x20 + 1], l32[P11 + 2] = t24[x20 + 2], c31[P11 + 0] = -b26 * ue2[0], c31[P11 + 1] = -b26 * ue2[1], c31[P11 + 2] = -b26 * ue2[2], h25[E23] = 0, a29[j14 + 0] = e31[x20 + 0] + f25 * ue2[0], a29[j14 + 1] = e31[x20 + 1] + f25 * ue2[1], a29[j14 + 2] = e31[x20 + 2] + f25 * ue2[2], l32[j14 + 0] = t24[x20 + 0], l32[j14 + 1] = t24[x20 + 1], l32[j14 + 2] = t24[x20 + 2], c31[j14 + 0] = b26 * ue2[0], c31[j14 + 1] = b26 * ue2[1], c31[j14 + 2] = b26 * ue2[2], h25[S18] = f25, P11 += 3, j14 += 3, x20 += 3, E23 += 1, S18 += 1;
  x20 = 3 * i23, P11 = 0, j14 = 3 * u33;
  const v23 = f25 < 0 ? _e : ye, w16 = f25 < 0 ? ye : _e;
  for (let m19 = 0; m19 < o24; ++m19)
    g21[P11 + 0] = n26[x20 + v23[0]], g21[P11 + 1] = n26[x20 + v23[1]], g21[P11 + 2] = n26[x20 + v23[2]], p21[j14 + 0] = n26[x20 + w16[0]] + s23, p21[j14 + 1] = n26[x20 + w16[1]] + s23, p21[j14 + 2] = n26[x20 + w16[2]] + s23, P11 += 3, j14 += 3, x20 += 3;
}
function se(e31, t24, r30, s23, n26, i23, o24) {
  s23[i23] = s23[o24], o24 *= 3, e31[(i23 *= 3) + 0] = e31[o24 + 0], e31[i23 + 1] = e31[o24 + 1], e31[i23 + 2] = e31[o24 + 2], t24[i23 + 0] = t24[o24 + 0], t24[i23 + 1] = t24[o24 + 1], t24[i23 + 2] = t24[o24 + 2], r30[i23 + 0] = n26[0], r30[i23 + 1] = n26[1], r30[i23 + 2] = n26[2];
}
var ne = n2();
function ie(e31, t24, r30, s23, n26, i23, o24, a29, l32, c31, h25) {
  let p21 = n26, m19 = n26 + 1, d27 = n26 + o24, g21 = n26 + o24 + 1, u33 = a29, f25 = a29 + 1, y17 = a29 + 2 * i23, _20 = a29 + 2 * i23 + 1;
  h25 < 0 && (p21 = n26 + o24 + 1, g21 = n26), c31 *= 3;
  for (let b26 = 0; b26 < i23; ++b26)
    b26 === i23 - 1 && (h25 > 0 ? (m19 = n26, g21 = n26 + o24) : (m19 = n26, p21 = n26 + o24)), pe(e31, p21, m19, d27, ne), se(e31, t24, s23, r30, ne, u33, p21), se(e31, t24, s23, r30, ne, f25, m19), se(e31, t24, s23, r30, ne, y17, d27), se(e31, t24, s23, r30, ne, _20, g21), l32[c31++] = u33, l32[c31++] = y17, l32[c31++] = _20, l32[c31++] = u33, l32[c31++] = _20, l32[c31++] = f25, p21++, m19++, d27++, g21++, u33 += 2, f25 += 2, y17 += 2, _20 += 2;
}
var oe = n2();
var ae = n2();
var le = n2();
var ce = n2();
var he = n2();
function pe(e31, t24, r30, s23, n26) {
  t24 *= 3, r30 *= 3, s23 *= 3, o2(oe, e31[t24++], e31[t24++], e31[t24++]), o2(ae, e31[r30++], e31[r30++], e31[r30++]), o2(le, e31[s23++], e31[s23++], e31[s23++]), e3(ce, ae, oe), e3(he, le, oe), _(n26, he, ce), z(n26, n26);
}
var me = n2();
function de(e31, t24, r30, n26) {
  const i23 = e31.stageObject, o24 = i23.geometryRecords, a29 = o24.length, l32 = "absolute-height" !== t24.mode;
  let h25 = 0;
  const m19 = i23.transformation, d27 = h5(e9(), m19);
  for (let c31 = 0; c31 < a29; c31 += 2) {
    const e32 = o24[c31].geometry, a30 = e32.getMutableAttribute(O2.POSITION).data, p21 = e32.vertexAttributes.get(O2.SIZE).data, u33 = e32.vertexAttributes.get(O2.MAPPOS).data, f25 = new t15(u33), _20 = a30.length / 3;
    let b26 = 0, x20 = false, E23 = 0;
    const P11 = r30.spatialReference;
    for (let i24 = 0; i24 < _20; i24++) {
      me[0] = a30[b26], me[1] = a30[b26 + 1], me[2] = a30[b26 + 2], d11(f25, r30, t24, n26, fe), l32 && (E23 += fe.sampledElevation), t14.TESTS_DISABLE_OPTIMIZATIONS ? (o2(ge, f25.array[f25.offset + 0], f25.array[f25.offset + 1], fe.z + p21[b26 / 3]), r(P11) && n26.toRenderCoords(ge, P11, ge), O(ge, ge, d27)) : (o2(ge, a30[b26 + 0], a30[b26 + 1], a30[b26 + 2]), O(ge, ge, m19), n26.setAltitude(ge, fe.z + p21[b26 / 3]), O(ge, ge, d27)), a30[b26] = ge[0], a30[b26 + 1] = ge[1], a30[b26 + 2] = ge[2];
      const e33 = be / n26.unitInMeters;
      (Math.abs(me[0] - a30[b26]) >= e33 || Math.abs(me[1] - a30[b26 + 1]) >= e33 || Math.abs(me[2] - a30[b26 + 2]) >= e33) && (x20 = true), f25.offset += 3, b26 += 3;
    }
    x20 && (e32.invalidateBoundingInfo(), i23.geometryVertexAttrsUpdated(o24[c31]), o24[c31 + 1].geometry.invalidateBoundingInfo(), i23.geometryVertexAttrsUpdated(o24[c31 + 1])), h25 += E23 / _20;
  }
  return h25 / a29;
}
var ge = n2();
var ue2 = n2();
var fe = new j8();
var ye = [0, 2, 1];
var _e = [0, 1, 2];
var be = 0.01;

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DDrapedGraphicLayer.js
var l25 = class {
  constructor(e31, t24, r30, i23) {
    this.graphics3DSymbolLayer = e31, this.renderGeometries = t24, this.boundingBox = r30, this._drapeSourceRenderer = i23, this.type = "draped", this.stage = null, this._visible = false, this._addedToStage = false, this.isElevationSource = false;
  }
  initialize(e31) {
    this.stage = e31;
  }
  setVisibility(e31) {
    if (null != this.stage && this._visible !== e31) {
      if (this._visible = e31, e31 && !this._addedToStage)
        return this._addedToStage = true, void this._drapeSourceRenderer.addGeometries(this.renderGeometries, E11.ADD);
      if (e31 || this._addedToStage) {
        for (const e32 of this.renderGeometries)
          e32.instanceParameters.visible = this._visible;
        this._drapeSourceRenderer.modifyGeometries(this.renderGeometries, I4.VISIBILITIES);
      }
    }
  }
  destroy() {
    this.stage && this._addedToStage && this._drapeSourceRenderer.removeGeometries(this.renderGeometries, E11.REMOVE), this._addedToStage = false, this._visible = false, this.stage = null;
  }
  getCenterObjectSpace(e31 = n2()) {
    return o2(e31, 0, 0, 0);
  }
  getBoundingBoxObjectSpace(e31 = a6()) {
    return A2(e31);
  }
  addObjectState(e31, t24) {
    e31 === u13.Highlight && (this.renderGeometries.forEach((e32) => {
      const r30 = e32.addHighlight();
      t24.addRenderGeometry(e32, r30, this);
    }), this._addedToStage && this._drapeSourceRenderer.modifyGeometries(this.renderGeometries, I4.HIGHLIGHTS));
  }
  removeObjectState(e31) {
    this.renderGeometries.forEach((t24) => {
      e31.removeRenderGeometry(t24);
    });
  }
  removeRenderGeometryObjectState(e31, t24) {
    e31.removeHighlight(t24), this._addedToStage && this._drapeSourceRenderer.modifyGeometries(this.renderGeometries, I4.HIGHLIGHTS);
  }
  computeAttachmentOrigin(e31) {
    for (const t24 of this.renderGeometries)
      t24.computeAttachmentOrigin(f19) && (e31.draped.origin[0] += f19[0], e31.draped.origin[1] += f19[1], e31.draped.num++);
  }
  async getProjectedBoundingBox(t24, r30, i23, n26, a29) {
    A2(a29);
    for (let e31 = 0; e31 < this.renderGeometries.length; e31++) {
      const r31 = this.renderGeometries[e31];
      this._getRenderGeometryProjectedBoundingRect(r31, t24, p15, i23), h6(a29, p15);
    }
    if (r30) {
      let t25;
      p4(a29, f19);
      const i24 = X(a29, r30.service.spatialReference, r30);
      try {
        t25 = await r30.service.queryElevation(f19[0], f19[1], n26, i24, "ground");
      } catch (h25) {
      }
      r(t25) && (a29[2] = Math.min(a29[2], t25), a29[5] = Math.max(a29[5], t25));
    }
    return a29;
  }
  _getRenderGeometryProjectedBoundingRect(e31, t24, r30, i23) {
    if (this.boundingBox)
      w6(S11, this.boundingBox);
    else {
      const t25 = e31.boundingSphere, r31 = t25[3];
      S11[0] = t25[0] - r31, S11[1] = t25[1] - r31, S11[2] = t25[2] - r31, S11[3] = t25[0] + r31, S11[4] = t25[1] + r31, S11[5] = t25[2] + r31;
    }
    return t24(S11, 0, 2), this.calculateRelativeScreenBounds && i23.push({ location: p4(S11), screenSpaceBoundingRect: this.calculateRelativeScreenBounds() }), B(S11, r30);
  }
};
var p15 = u6();
var S11 = a6();
var f19 = n2();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/TextRenderer.js
var s16 = class {
  constructor(t24, e31, i23, n26 = 2048) {
    this.text = t24, this._alignment = e31, this._parameters = i23, this._maxSize = n26, this._textWidths = [], this._lineWidths = [], this._renderPixelRatio = null, this._displayWidth = null, this._heightMetricsCached = null, this.key = `TextRenderer-${this._parameters.key}-${this._alignment}--${t24}`, this._lines = t24.split(/\r?\n/);
  }
  get displayWidth() {
    return Math.ceil(this._ensureTextWidth() + 2 * this._backgroundHorizontalPadding);
  }
  get displayHeight() {
    const t24 = this._lineSpacing * (this._lines.length - 1), e31 = this._lineHeight;
    return Math.ceil(t24 + e31 + 2 * this._haloSize + this._backgroundTopPadding + this._backgroundBottomPadding);
  }
  get renderedWidth() {
    return Math.ceil(this._toRenderUnit(this.displayWidth));
  }
  get renderedHeight() {
    return Math.ceil(this._toRenderUnit(this.displayHeight));
  }
  get firstRenderedBaselinePosition() {
    return this._toRenderUnit(this._firstLineYOffset + this._baselinePosition);
  }
  get _firstLineYOffset() {
    return this._backgroundTopPadding + this._haloSize;
  }
  get _heightMetrics() {
    return this._ensureHeightMetrics();
  }
  get _lineSpacing() {
    return (this._lineHeight + this._linePadding) * this._parameters.definition.lineSpacingFactor;
  }
  get _lineHeight() {
    return this._heightMetrics.lineHeight;
  }
  get _linePadding() {
    return this._lineHeight * d18;
  }
  get _baselinePosition() {
    return this._heightMetrics.baselinePosition;
  }
  get _renderedFontSize() {
    return this._toRenderUnit(this._fontSize);
  }
  get _fontSize() {
    return this._parameters.definition.size;
  }
  get _renderedHaloSize() {
    return this._toRenderUnit(this._haloSize);
  }
  get _haloSize() {
    return this._parameters.haloSize;
  }
  get _backgroundHorizontalPadding() {
    return this._hasBackground ? this._parameters.definition.background.padding[0] : 0;
  }
  get _backgroundVerticalPadding() {
    return this._hasBackground ? this._parameters.definition.background.padding[1] : 0;
  }
  get _backgroundTopPadding() {
    return Math.max(0, this._backgroundVerticalPadding - this._heightMetrics.paddingTop);
  }
  get _backgroundBottomPadding() {
    return Math.max(0, this._backgroundVerticalPadding - this._heightMetrics.paddingBottom);
  }
  get _hasBackground() {
    return !!this._parameters.backgroundStyle;
  }
  get renderPixelRatio() {
    if (t(this._renderPixelRatio)) {
      const t24 = this._parameters.definition.pixelRatio;
      this._maxSize > 0 ? this._renderPixelRatio = Math.min(t24, Math.min(this._maxSize / this.displayWidth, this._maxSize / this.displayHeight)) : this._renderPixelRatio = t24;
    }
    return this._renderPixelRatio;
  }
  _getLineXOffset(t24) {
    switch (this._alignment) {
      case h19.Left:
        return this._backgroundHorizontalPadding;
      case h19.Center:
        return (this.displayWidth - this._lineWidths[t24]) / 2;
      case h19.Right:
        return this.displayWidth - this._backgroundHorizontalPadding - this._lineWidths[t24];
    }
  }
  render(t24, e31 = 0, i23 = 0) {
    t24.save();
    const s23 = e31 /= this.renderPixelRatio, r30 = i23 /= this.renderPixelRatio, h25 = this._haloSize, o24 = this._firstLineYOffset;
    e31 += h25, i23 += o24 + this._baselinePosition;
    const a29 = this._haloSize > 0;
    a29 && this._renderHalo(t24, s23, r30, h25, o24), this._setFontProperties(t24, this._renderedFontSize);
    for (let n26 = 0; n26 < this._lines.length; ++n26) {
      const s24 = this._lines[n26], r31 = this._getLineXOffset(n26);
      a29 && (t24.globalCompositeOperation = "destination-out", t24.fillStyle = "rgb(0, 0, 0)", this._fillText(t24, s24, e31 + r31, i23), this._renderLineDecoration(t24, e31 + r31, i23, this._textWidths[n26])), t24.globalCompositeOperation = "source-over", t24.fillStyle = this._parameters.textStyle, this._fillText(t24, s24, e31 + this._getLineXOffset(n26), i23), this._renderLineDecoration(t24, e31 + r31, i23, this._textWidths[n26]), i23 += this._lineSpacing;
    }
    if (t14.TEXT_SHOW_BASELINE) {
      t24.strokeStyle = _10, t24.setLineDash([2, 2]), t24.lineWidth = 1;
      let e32 = r30 + o24;
      for (let i24 = 0; i24 < this._lines.length; ++i24) {
        const i25 = e32 + this._baselinePosition;
        this._drawLine(t24, [s23, i25], [s23 + this.displayWidth, i25]), e32 += this._lineSpacing;
      }
    }
    if (t14.TEXT_SHOW_BORDER && (t24.strokeStyle = _10, t24.setLineDash([]), t24.lineWidth = 1, this._drawBox(t24, [s23, r30], [this.displayWidth, this.displayHeight])), this._hasBackground) {
      const e32 = this._parameters.definition.background.borderRadius * this.renderPixelRatio;
      this._roundedRect(t24, s23, r30, e32), t24.globalCompositeOperation = "destination-over", t24.fillStyle = this._parameters.backgroundStyle, t24.fill();
    }
    t24.restore();
  }
  _renderLineDecoration(t24, e31, i23, n26, s23 = false) {
    if ("none" === this._parameters.definition.font.decoration || 0 === n26)
      return;
    const r30 = 1, h25 = Math.max(this._parameters.definition.size / 16, r30);
    switch (this._parameters.definition.font.decoration) {
      case "underline":
        i23 += 2 * h25;
        break;
      case "line-through":
        i23 -= 0.33 * this._baselinePosition;
    }
    const o24 = s23 ? this._haloSize : 0;
    t24.strokeStyle = s23 ? this._parameters.haloStyle : this._parameters.textStyle, t24.lineWidth = this._toRenderUnit(h25 + 2 * o24), t24.beginPath(), t24.moveTo(this._toRenderUnit(e31 - o24), this._toRenderUnit(i23)), t24.lineTo(this._toRenderUnit(e31 + n26 + o24), this._toRenderUnit(i23)), t24.stroke();
  }
  _roundedRect(e31, i23, n26, s23) {
    i23 = this._toRenderUnit(i23), n26 = this._toRenderUnit(n26);
    const r30 = this.renderedWidth, h25 = this.renderedHeight;
    0 !== s23 ? (s23 = a3(s23, 0, Math.floor(h25 / 2)), e31.beginPath(), e31.moveTo(i23, n26 + s23), e31.arcTo(i23, n26, i23 + s23, n26, s23), e31.lineTo(i23 + r30 - s23, n26), e31.arcTo(i23 + r30, n26, i23 + r30, n26 + s23, s23), e31.lineTo(i23 + r30, n26 + h25 - s23), e31.arcTo(i23 + r30, n26 + h25, i23 + r30 - s23, n26 + h25, s23), e31.lineTo(i23 + s23, n26 + h25), e31.arcTo(i23, n26 + h25, i23, n26 + h25 - s23, s23), e31.closePath()) : e31.rect(i23, n26, r30, h25);
  }
  _renderHalo(t24, e31, i23, n26, s23) {
    const r30 = this.renderedWidth, h25 = this.renderedHeight, d27 = o19(a26, Math.max(r30, l26), Math.max(h25, l26)), _20 = d27.getContext("2d");
    _20.clearRect(0, 0, r30, h25), this._setFontProperties(_20, this._renderedFontSize), _20.fillStyle = this._parameters.haloStyle, _20.strokeStyle = this._parameters.haloStyle;
    const g21 = this._renderedHaloSize < 3;
    _20.lineJoin = g21 ? "miter" : "round", g21 ? this._renderHaloEmulated(_20, n26, s23) : this._renderHaloNative(_20, n26, s23);
    let c31 = s23 + this._baselinePosition;
    for (let o24 = 0; o24 < this._lines.length; ++o24) {
      const t25 = this._getLineXOffset(o24);
      this._renderLineDecoration(_20, n26 + t25, c31, this._textWidths[o24], true), c31 += this._lineSpacing;
    }
    t24.globalAlpha = this._parameters.definition.halo.color[3], t24.drawImage(d27, 0, 0, r30, h25, this._toRenderUnit(e31), this._toRenderUnit(i23), r30, h25), t24.globalAlpha = 1;
  }
  _renderHaloEmulated(t24, e31, i23) {
    i23 += this._baselinePosition;
    for (let n26 = 0; n26 < this._lines.length; ++n26) {
      const s23 = this._lines[n26], h25 = this._getLineXOffset(n26);
      for (const [n27, o24] of r21)
        this._fillText(t24, s23, e31 + h25 + this._haloSize * n27, i23 + this._haloSize * o24);
      i23 += this._lineSpacing;
    }
  }
  _renderHaloNative(t24, e31, i23) {
    const n26 = 2 * this._haloSize;
    i23 += this._baselinePosition;
    for (let s23 = 0; s23 < this._lines.length; ++s23) {
      const r30 = this._lines[s23], h25 = this._getLineXOffset(s23), o24 = 5, a29 = 0.1;
      for (let s24 = 0; s24 < o24; s24++) {
        const d27 = 1 - (o24 - 1) * a29 + s24 * a29;
        t24.lineWidth = this._toRenderUnit(d27 * n26), this._strokeText(t24, r30, e31 + h25, i23);
      }
      i23 += this._lineSpacing;
    }
  }
  _setFontProperties(t24, e31) {
    t24.font = this._parameters.fontString(e31), t24.textAlign = "left", t24.textBaseline = "alphabetic";
  }
  _ensureTextWidth() {
    if (r(this._displayWidth))
      return this._displayWidth;
    const t24 = o19(a26, l26, l26).getContext("2d");
    this._setFontProperties(t24, this._fontSize);
    let e31 = 2 * this._haloSize;
    const n26 = this._parameters.definition.font;
    "italic" !== n26.style && "oblique" !== n26.style && "bold" !== n26.weight && "bolder" !== n26.weight || (e31 += 0.3 * t24.measureText("A").width), this._textWidths.length = 0, this._lineWidths.length = 0;
    let s23 = 0;
    for (const i23 of this._lines) {
      const n27 = t24.measureText(i23).width, r30 = n27 + e31;
      this._textWidths.push(n27), this._lineWidths.push(r30), s23 = Math.max(s23, r30);
    }
    return this._displayWidth = s23, this._displayWidth;
  }
  _ensureHeightMetrics() {
    if (t(this._heightMetricsCached)) {
      const t24 = o19(a26, l26, l26).getContext("2d");
      this._setFontProperties(t24, this._fontSize);
      const e31 = t24.measureText(this.text + g13), i23 = this._hasBackground ? t24.measureText(this._lines[0]) : e31, n26 = 1 === this._lines.length ? i23 : this._hasBackground ? t24.measureText(this._lines[this._lines.length - 1]) : e31, s23 = e31.actualBoundingBoxAscent + e31.actualBoundingBoxDescent;
      this._heightMetricsCached = { paddingTop: e31.actualBoundingBoxAscent - i23.actualBoundingBoxAscent, paddingBottom: e31.actualBoundingBoxDescent - n26.actualBoundingBoxDescent, lineHeight: s23, baselinePosition: e31.actualBoundingBoxAscent };
    }
    return this._heightMetricsCached;
  }
  _toRenderUnit(t24) {
    return t24 * this.renderPixelRatio;
  }
  _toRoundedRenderUnit(t24) {
    return Math.round(t24 * this.renderPixelRatio);
  }
  _fillText(t24, e31, i23, n26) {
    t24.fillText(e31, this._toRenderUnit(i23), this._toRenderUnit(n26));
  }
  _strokeText(t24, e31, i23, n26) {
    t24.strokeText(e31, this._toRenderUnit(i23), this._toRenderUnit(n26));
  }
  _drawLine(t24, e31, i23) {
    t24.beginPath(), t24.moveTo(this._toRoundedRenderUnit(e31[0]) + 0.5, this._toRoundedRenderUnit(e31[1]) + 0.5), t24.lineTo(this._toRoundedRenderUnit(i23[0]) + 0.5, this._toRoundedRenderUnit(i23[1]) + 0.5), t24.stroke();
  }
  _drawBox(t24, e31, i23) {
    const n26 = this._toRenderUnit(e31[0]), s23 = this._toRenderUnit(e31[1]), r30 = this._toRenderUnit(i23[0]), h25 = this._toRenderUnit(i23[1]), o24 = Math.floor(n26) + 0.5, a29 = Math.ceil(n26 + r30) - 0.5, d27 = Math.floor(s23) + 0.5, l32 = Math.ceil(s23 + h25) - 0.5;
    t24.beginPath(), t24.moveTo(o24, d27), t24.lineTo(a29, d27), t24.lineTo(a29, l32), t24.lineTo(o24, l32), t24.lineTo(o24, d27), t24.stroke();
  }
};
var r21 = [];
{
  const t24 = 16;
  for (let e31 = 0; e31 < 360; e31 += 360 / t24)
    r21.push([Math.cos(Math.PI * e31 / 180), Math.sin(Math.PI * e31 / 180)]);
}
var h19;
function o19(t24, e31, i23) {
  return t24.canvas || (t24.canvas = document.createElement("canvas")), t24.canvas.width = e31, t24.canvas.height = i23, t24.canvas;
}
!function(t24) {
  t24[t24.Left = 0] = "Left", t24[t24.Center = 1] = "Center", t24[t24.Right = 2] = "Right";
}(h19 || (h19 = {}));
var a26 = { canvas: null };
var d18 = 0.2;
var l26 = 512;
var _10 = "rgb(255, 0, 255, 0.5)";
var g13 = (() => {
  let t24 = "";
  for (let e31 = 32; e31 < 127; e31++)
    t24 += String.fromCharCode(e31);
  return t24;
})();

// node_modules/@arcgis/core/views/3d/layers/graphics/placementUtils.js
var r22 = Object.freeze({ left: 0, center: 0.5, right: 1 });
var o20 = Object.freeze({ "bottom-left": r12(0, 0), bottom: r12(0.5, 0), "bottom-right": r12(1, 0), left: r12(0, 0.5), center: r12(0.5, 0.5), right: r12(1, 0.5), "top-left": r12(0, 1), top: r12(0.5, 1), "top-right": r12(1, 1) });
function c25(t24) {
  switch (t24) {
    case "left":
      return h19.Left;
    case "right":
      return h19.Right;
    default:
      return h19.Center;
  }
}
function i18(t24, e31) {
  switch (e31) {
    case "bottom":
      return "left" === t24 ? "bottom-left" : "right" === t24 ? "bottom-right" : "bottom";
    case "center":
      return t24;
    case "top":
      return "left" === t24 ? "top-left" : "right" === t24 ? "top-right" : "top";
  }
}
function f20(t24) {
  return "middle" === t24 ? "center" : t24;
}

// node_modules/@arcgis/core/views/3d/layers/support/FastSymbolUpdates.js
var S12;
var y9;
var h20;
function x12(e31) {
  return null != e31;
}
function b17(e31) {
  return "number" == typeof e31;
}
function C9(e31) {
  return "string" == typeof e31;
}
function g14(e31) {
  return null == e31 || C9(e31);
}
function M7(e31, o24) {
  e31 && e31.push(o24);
}
function V5(e31, o24, t24, i23 = e9()) {
  const n26 = e31 || 0, r30 = o24 || 0, s23 = t24 || 0;
  return 0 !== n26 && m3(i23, i23, -n26 / 180 * Math.PI), 0 !== r30 && b4(i23, i23, r30 / 180 * Math.PI), 0 !== s23 && l7(i23, i23, s23 / 180 * Math.PI), i23;
}
function D5(e31, o24, t24, i23, n26) {
  const r30 = e31.minSize, s23 = e31.maxSize;
  if (e31.expression)
    return M7(n26, "Could not convert size info: expression not supported"), false;
  if (e31.useSymbolValue) {
    const e32 = i23.symbolSize[t24];
    return o24.minSize[t24] = e32, o24.maxSize[t24] = e32, o24.offset[t24] = o24.minSize[t24], o24.factor[t24] = 0, o24.type[t24] = S12.DefinedSize, true;
  }
  if (x12(e31.field))
    return x12(e31.stops) ? 2 === e31.stops.length && b17(e31.stops[0].size) && b17(e31.stops[1].size) ? (T7(e31.stops[0].size, e31.stops[1].size, e31.stops[0].value, e31.stops[1].value, o24, t24), o24.type[t24] = S12.DefinedSize, true) : (M7(n26, "Could not convert size info: stops only supported with 2 elements"), false) : b17(r30) && b17(s23) && x12(e31.minDataValue) && x12(e31.maxDataValue) ? (T7(r30, s23, e31.minDataValue, e31.maxDataValue, o24, t24), o24.type[t24] = S12.DefinedSize, true) : null != m4[e31.valueUnit] ? (o24.minSize[t24] = -1 / 0, o24.maxSize[t24] = 1 / 0, o24.offset[t24] = 0, o24.factor[t24] = 1 / m4[e31.valueUnit], o24.type[t24] = S12.DefinedSize, true) : "unknown" === e31.valueUnit ? (M7(n26, "Could not convert size info: proportional size not supported"), false) : (M7(n26, "Could not convert size info: scale-dependent size not supported"), false);
  if (!x12(e31.field)) {
    if (e31.stops && e31.stops[0] && b17(e31.stops[0].size))
      return o24.minSize[t24] = e31.stops[0].size, o24.maxSize[t24] = e31.stops[0].size, o24.offset[t24] = o24.minSize[t24], o24.factor[t24] = 0, o24.type[t24] = S12.DefinedSize, true;
    if (b17(r30))
      return o24.minSize[t24] = r30, o24.maxSize[t24] = r30, o24.offset[t24] = r30, o24.factor[t24] = 0, o24.type[t24] = S12.DefinedSize, true;
  }
  return M7(n26, "Could not convert size info: unsupported variant of sizeInfo"), false;
}
function T7(e31, o24, t24, i23, n26, r30) {
  const s23 = Math.abs(i23 - t24) > 0 ? (o24 - e31) / (i23 - t24) : 0;
  n26.minSize[r30] = s23 > 0 ? e31 : o24, n26.maxSize[r30] = s23 > 0 ? o24 : e31, n26.offset[r30] = e31 - t24 * s23, n26.factor[r30] = s23;
}
function U7(e31, o24, t24, i23) {
  if (e31.normalizationField || e31.valueRepresentation)
    return M7(i23, "Could not convert size info: unsupported property"), null;
  if (!g14(e31.field))
    return M7(i23, "Could not convert size info: field is not a string"), null;
  if (o24.size) {
    if (e31.field)
      if (o24.size.field) {
        if (e31.field !== o24.size.field)
          return M7(i23, "Could not convert size info: multiple fields in use"), null;
      } else
        o24.size.field = e31.field;
  } else
    o24.size = { field: e31.field, minSize: [0, 0, 0], maxSize: [0, 0, 0], offset: [0, 0, 0], factor: [0, 0, 0], type: [S12.Undefined, S12.Undefined, S12.Undefined] };
  let n26;
  switch (e31.axis) {
    case "width":
      return n26 = D5(e31, o24.size, 0, t24, i23), n26 ? o24 : null;
    case "height":
      return n26 = D5(e31, o24.size, 2, t24, i23), n26 ? o24 : null;
    case "depth":
      return n26 = D5(e31, o24.size, 1, t24, i23), n26 ? o24 : null;
    case "width-and-depth":
      return n26 = D5(e31, o24.size, 0, t24, i23), n26 && D5(e31, o24.size, 1, t24, i23), n26 ? o24 : null;
    case null:
    case void 0:
    case "all":
      return n26 = D5(e31, o24.size, 0, t24, i23), n26 = n26 && D5(e31, o24.size, 1, t24, i23), n26 = n26 && D5(e31, o24.size, 2, t24, i23), n26 ? o24 : null;
    default:
      return M7(i23, `Could not convert size info: unknown axis "${e31.axis}""`), null;
  }
}
function E16(e31, o24, t24) {
  for (let n26 = 0; n26 < 3; ++n26) {
    let t25 = o24.unitInMeters;
    e31.type[n26] === S12.DefinedSize && (t25 *= o24.modelSize[n26], e31.type[n26] = S12.DefinedScale), e31.minSize[n26] = e31.minSize[n26] / t25, e31.maxSize[n26] = e31.maxSize[n26] / t25, e31.offset[n26] = e31.offset[n26] / t25, e31.factor[n26] = e31.factor[n26] / t25;
  }
  let i23;
  if (e31.type[0] !== S12.Undefined)
    i23 = 0;
  else if (e31.type[1] !== S12.Undefined)
    i23 = 1;
  else {
    if (e31.type[2] === S12.Undefined)
      return M7(t24, "No size axis contains a valid size or scale"), false;
    i23 = 2;
  }
  for (let n26 = 0; n26 < 3; ++n26)
    e31.type[n26] === S12.Undefined && (e31.minSize[n26] = e31.minSize[i23], e31.maxSize[n26] = e31.maxSize[i23], e31.offset[n26] = e31.offset[i23], e31.factor[n26] = e31.factor[i23], e31.type[n26] = e31.type[i23]);
  return true;
}
function O8(e31, o24, t24) {
  e31[4 * o24 + 0] = t24.r / 255, e31[4 * o24 + 1] = t24.g / 255, e31[4 * o24 + 2] = t24.b / 255, e31[4 * o24 + 3] = t24.a;
}
function j10(e31, o24, t24) {
  if (e31.normalizationField)
    return M7(t24, "Could not convert color info: unsupported property"), null;
  if (C9(e31.field)) {
    if (!e31.stops)
      return M7(t24, "Could not convert color info: missing stops or colors"), null;
    {
      if (e31.stops.length > 8)
        return M7(t24, "Could not convert color info: too many color stops"), null;
      o24.color = { field: e31.field, values: [0, 0, 0, 0, 0, 0, 0, 0], colors: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] };
      const i23 = e31.stops;
      for (let e32 = 0; e32 < 8; ++e32) {
        const t25 = i23[Math.min(e32, i23.length - 1)];
        o24.color.values[e32] = t25.value, O8(o24.color.colors, e32, t25.color);
      }
    }
  } else {
    if (!(e31.stops && e31.stops.length >= 0))
      return M7(t24, "Could not convert color info: no field and no colors/stops"), null;
    {
      const t25 = e31.stops && e31.stops.length >= 0 && e31.stops[0].color;
      o24.color = { field: null, values: [0, 0, 0, 0, 0, 0, 0, 0], colors: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] };
      for (let e32 = 0; e32 < 8; e32++)
        o24.color.values[e32] = 1 / 0, O8(o24.color.colors, e32, t25);
    }
  }
  return o24;
}
function k4(e31, o24, t24) {
  if (e31.normalizationField)
    return M7(t24, "Could not convert opacity info: unsupported property"), null;
  if (C9(e31.field)) {
    if (!e31.stops)
      return M7(t24, "Could not convert opacity info: missing stops or opacities"), null;
    {
      if (e31.stops.length > 8)
        return M7(t24, "Could not convert opacity info: too many opacity stops"), null;
      o24.opacity = { field: e31.field, values: [0, 0, 0, 0, 0, 0, 0, 0], opacityValues: [0, 0, 0, 0, 0, 0, 0, 0] };
      const i23 = e31.stops;
      for (let e32 = 0; e32 < 8; ++e32) {
        const t25 = i23[Math.min(e32, i23.length - 1)];
        o24.opacity.values[e32] = t25.value, o24.opacity.opacityValues[e32] = t25.opacity;
      }
    }
  } else {
    if (!(e31.stops && e31.stops.length >= 0))
      return M7(t24, "Could not convert opacity info: no field and no opacities/stops"), null;
    {
      const t25 = e31.stops && e31.stops.length >= 0 && e31.stops[0].opacity;
      o24.opacity = { field: null, values: [0, 0, 0, 0, 0, 0, 0, 0], opacityValues: [0, 0, 0, 0, 0, 0, 0, 0] };
      for (let e32 = 0; e32 < 8; e32++)
        o24.opacity.values[e32] = 1 / 0, o24.opacity.opacityValues[e32] = t25;
    }
  }
  return o24;
}
function w9(e31, o24, t24) {
  const i23 = 2 === t24 && "arithmetic" === e31.rotationType;
  o24.offset[t24] = i23 ? 90 : 0, o24.factor[t24] = i23 ? -1 : 1, o24.type[t24] = 1;
}
function F7(e31, o24, t24) {
  if (!C9(e31.field))
    return M7(t24, "Could not convert rotation info: field is not a string"), null;
  if (o24.rotation) {
    if (e31.field)
      if (o24.rotation.field) {
        if (e31.field !== o24.rotation.field)
          return M7(t24, "Could not convert rotation info: multiple fields in use"), null;
      } else
        o24.rotation.field = e31.field;
  } else
    o24.rotation = { field: e31.field, offset: [0, 0, 0], factor: [1, 1, 1], type: [0, 0, 0] };
  switch (e31.axis) {
    case "tilt":
      return w9(e31, o24.rotation, 0), o24;
    case "roll":
      return w9(e31, o24.rotation, 1), o24;
    case null:
    case void 0:
    case "heading":
      return w9(e31, o24.rotation, 2), o24;
    default:
      return M7(t24, `Could not convert rotation info: unknown axis "${e31.axis}""`), null;
  }
}
function A8(e31, o24, t24) {
  if (!e31)
    return null;
  const i23 = !o24.supportedTypes || !!o24.supportedTypes.size, n26 = !o24.supportedTypes || !!o24.supportedTypes.color, r30 = !o24.supportedTypes || !!o24.supportedTypes.rotation, s23 = !!o24.supportedTypes && !!o24.supportedTypes.opacity, l32 = e31.reduce((e32, l33) => {
    if (!e32)
      return e32;
    if (l33.valueExpression)
      return M7(t24, "Could not convert visual variables: arcade expressions not supported"), null;
    switch (l33.type) {
      case "size":
        return i23 ? U7(l33, e32, o24, t24) : e32;
      case "color":
        return n26 ? j10(l33, e32, t24) : e32;
      case "opacity":
        return s23 ? k4(l33, e32, t24) : null;
      case "rotation":
        return r30 ? F7(l33, e32, t24) : e32;
      default:
        return null;
    }
  }, { size: null, color: null, opacity: null, rotation: null });
  return !(e31.length > 0 && l32) || l32.size || l32.color || l32.opacity || l32.rotation ? l32 && l32.size && !E16(l32.size, o24, t24) ? null : l32 : null;
}
function I7(e31) {
  return e31 && null != e31.size;
}
function P7(e31, o24) {
  if (!e31)
    return { enabled: false };
  if (t14.TESTS_DISABLE_FAST_UPDATES)
    return { enabled: false };
  const t24 = A8(e31.visualVariables, o24);
  return t24 ? { enabled: true, visualVariables: t24, materialParameters: q6(t24, o24), requiresShaderTransformation: I7(t24) } : { enabled: false };
}
function R9(e31, o24, t24) {
  if (!o24 || !e31.enabled)
    return false;
  const i23 = e31.visualVariables, n26 = A8(o24.visualVariables, t24);
  return !!n26 && (!!(_11(i23.size, n26.size, "size") && _11(i23.color, n26.color, "color") && _11(i23.rotation, n26.rotation, "rotation") && _11(i23.opacity, n26.opacity, "opacity")) && (e31.visualVariables = n26, e31.materialParameters = q6(n26, t24), e31.requiresShaderTransformation = I7(n26), true));
}
function _11(e31, o24, t24) {
  if (!!e31 != !!o24)
    return false;
  if (e31 && e31.field !== o24.field)
    return false;
  if (e31 && "rotation" === t24) {
    const t25 = e31, i23 = o24;
    for (let e32 = 0; e32 < 3; e32++)
      if (t25.type[e32] !== i23.type[e32] || t25.offset[e32] !== i23.offset[e32] || t25.factor[e32] !== i23.factor[e32])
        return false;
  }
  return true;
}
function q6(e31, n26) {
  const r30 = { vvSizeEnabled: false, vvSizeMinSize: null, vvSizeMaxSize: null, vvSizeOffset: null, vvSizeFactor: null, vvSizeValue: null, vvColorEnabled: false, vvColorValues: null, vvColorColors: null, vvOpacityEnabled: false, vvOpacityValues: null, vvOpacityOpacities: null, vvSymbolAnchor: null, vvSymbolRotationMatrix: null }, s23 = I7(e31);
  return e31 && e31.size ? (r30.vvSizeEnabled = true, r30.vvSizeMinSize = e31.size.minSize, r30.vvSizeMaxSize = e31.size.maxSize, r30.vvSizeOffset = e31.size.offset, r30.vvSizeFactor = e31.size.factor) : e31 && s23 && (r30.vvSizeValue = n26.transformation.scale), e31 && s23 && (r30.vvSymbolAnchor = n26.transformation.anchor, r30.vvSymbolRotationMatrix = e8(), r6($3), V5(n26.transformation.rotation[2], n26.transformation.rotation[0], n26.transformation.rotation[1], $3), a9(r30.vvSymbolRotationMatrix, $3)), e31 && e31.color && (r30.vvColorEnabled = true, r30.vvColorValues = e31.color.values, r30.vvColorColors = e31.color.colors), e31 && e31.opacity && (r30.vvOpacityEnabled = true, r30.vvOpacityValues = e31.opacity.values, r30.vvOpacityOpacities = e31.opacity.opacityValues), r30;
}
!function(e31) {
  e31[e31.Undefined = 0] = "Undefined", e31[e31.DefinedSize = 1] = "DefinedSize", e31[e31.DefinedScale = 2] = "DefinedScale";
}(S12 || (S12 = {})), function(e31) {
  e31[e31.Undefined = 0] = "Undefined", e31[e31.DefinedAngle = 1] = "DefinedAngle";
}(y9 || (y9 = {})), function(o24) {
  const t24 = e9(), i23 = n2();
  function u33(o25, u34, f26) {
    if (!o25.vvSizeEnabled)
      return f26;
    n7(t24, f26);
    const c31 = o25.vvSymbolRotationMatrix;
    s6($3, c31[0], c31[1], c31[2], 0, c31[3], c31[4], c31[5], 0, c31[6], c31[7], c31[8], 0, 0, 0, 0, 1), u7(t24, t24, $3);
    for (let t25 = 0; t25 < 3; ++t25) {
      const n26 = o25.vvSizeOffset[t25] + u34[0] * o25.vvSizeFactor[t25];
      i23[t25] = a3(n26, o25.vvSizeMinSize[t25], o25.vvSizeMaxSize[t25]);
    }
    return i2(t24, t24, i23), c4(t24, t24, o25.vvSymbolAnchor), t24;
  }
  function f25(o25, t25, i24) {
    if (!t25.vvSizeEnabled)
      return o2(o25, 1, 1, 1);
    for (let n26 = 0; n26 < 3; ++n26) {
      const r30 = t25.vvSizeOffset[n26] + i24[0] * t25.vvSizeFactor[n26];
      o25[n26] = a3(r30, t25.vvSizeMinSize[n26], t25.vvSizeMaxSize[n26]);
    }
    return o25;
  }
  o24.evaluateModelTransform = u33, o24.evaluateModelTransformScale = f25;
}(h20 || (h20 = {}));
var $3 = e9();
var B6 = h20.evaluateModelTransform;
var L5 = h20.evaluateModelTransformScale;

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DIconSymbolLayer.js
var se2 = e9();
var ae2 = r2(0, 0, 1);
var oe2 = 16;
var ne2 = 1.5;
var le2 = a17;
var ce2 = [le2 / 2, le2 / 2, 1 - le2 / 2, 1 - le2 / 2];
var he2 = [e16 * le2, e16 * le2];
var me2 = class extends y8 {
  constructor(e31, t24, r30, i23) {
    super(e31, t24, r30, i23), this._cimLayers = null, this._cimSymbolMaterials = /* @__PURE__ */ new Map(), this._cimSymbolTextures = /* @__PURE__ */ new Map(), this._cimMaterialParametersInfo = null, this._cimRequiredFields = null, this._cimScaleFactorOrFunction = null, this._size = null, this._symbolTextureRatio = 1, this._outlineSize = 0, this._elevationOptions = { supportsOffsetAdjustment: true, supportsOnTheGround: true };
  }
  getCachedSize() {
    return { size: this._getIconSize() };
  }
  async doLoad(e31) {
    this._validateOrThrow();
    const t24 = this._prepareMaterialParameters(), r30 = this._getPrimitive();
    if (r(r30))
      this._prepareResourcesPrimitive(t24, r30);
    else {
      const r31 = g7(this.symbol, this.symbolLayer), i23 = nt(r31);
      i23 && "application/json" === i23.mediaType ? await this._prepareResourcesCIM(t24, JSON.parse(i23.data), e31) : await this._prepareResourcesHref(t24, r31, e31);
    }
  }
  _validateOrThrow() {
    if (this._drivenProperties.size)
      return;
    const e31 = S5(this._getIconSize());
    if (e31)
      throw new s4("graphics3diconsymbollayer:invalid-size", e31);
  }
  _getIconSize() {
    const e31 = this.symbolLayer, t24 = Math.round(null != e31.size ? u4(e31.size) : oe2);
    return this._drivenProperties.size ? Math.max(t24, 64) : t24;
  }
  _generateTextureCIM(e31) {
    const t24 = this._getGraphicHash(e31);
    let r30 = "" === t24 ? null : this._cimSymbolTextures.get(t24);
    if (!r30) {
      const i23 = { scaleFactor: this._cimScaleFactorOrFunction }, s23 = this._context.sharedResources.cimSymbolRasterizer.rasterizeCIMSymbol3D(this._cimLayers, e31, "esriGeometryPoint", i23, null, null);
      this._cimMaterialParametersInfo.anchorPosition = this._getAnchorPos("relative", s23.anchorPosition);
      const a29 = { width: s23.imageData.width, height: s23.imageData.height, powerOfTwoResizeMode: c14.PAD };
      r30 = new L2(s23.imageData, a29), this._cimSymbolTextures.set(t24, r30), this._context.stage.add(r30);
    }
    return r30;
  }
  _computeSize(e31, t24) {
    const r30 = e31.width / e31.height;
    return r30 > 1 ? [t24, Math.round(t24 / r30)] : [Math.round(t24 * r30), t24];
  }
  _prepareMaterialParameters() {
    const e31 = { anchorPosition: this._getAnchorPos(this.symbolLayer.anchor, this.symbolLayer.anchorPosition) }, t24 = this.symbol;
    if (ue3(t24)) {
      const { screenLength: r30, minWorldLength: s23, maxWorldLength: a29 } = t24.verticalOffset;
      e31.verticalOffset = { screenLength: u4(r30), minWorldLength: s23 || 0, maxWorldLength: r(a29) ? a29 : 1 / 0 };
    }
    return this._context.screenSizePerspectiveEnabled && (e31.screenSizePerspective = this._context.sharedResources.screenSizePerspectiveSettings), e31.occlusionTest = true, e31.hasSlicePlane = this._context.slicePlaneEnabled, e31;
  }
  _prepareResourcesPrimitive(e31, t24) {
    const r30 = this._getOutlineSize();
    if (de2(t24) && 0 === r30)
      throw new Error("Nothing to render");
    if (this._outlineSize = r30, e31.color = this._getFillColor(), e31.outlineColor = this._getOutlineColor(), e31.outlineSize = this._outlineSize, r(this._context.sharedResources.textures)) {
      const r31 = this._context.sharedResources.textures.fromData(`${t24}-icon`, () => o16(t24));
      this._texture = r31.texture, this._releaseTexture = r31, e31.textureId = this._texture.id;
    }
    e31.textureIsSignedDistanceField = true, e31.distanceFieldBoundingBox = ce2;
    const s23 = this._getIconSize();
    this._size = [s23, s23], this._symbolTextureRatio = 1 / le2, this._createMaterialAndAddToStage(e31, this._context.stage);
  }
  async _prepareResourcesHref(e31, s23, a29) {
    if (!has("esri-canvas-svg-support") && It(s23)) {
      throw new s4("graphics3diconsymbollayer:unsupported-image-format", "IconSymbol3DLayer failed to load (SVG symbols are not supported in IE11)");
    }
    this._outlineSize = this._getOutlineSize(), e31.color = this._getFillColor(), e31.outlineColor = this._getOutlineColor(), e31.outlineSize = this._outlineSize, e31.textureIsSignedDistanceField = false;
    const o24 = this._getIconSize(), n26 = o24 * this._context.graphicsCoreOwner.view.state.pixelRatio;
    if (r(this._context.sharedResources.textures)) {
      const i23 = await b2(this._context.sharedResources.textures.fromUrl(s23, n26, { signal: a29 }));
      if (false === i23.ok) {
        w2(i23.error);
        throw new s4("graphics3diconsymbollayer:request-failed", `Failed to load (Request for icon resource failed: ${s23})`);
      }
      this._releaseTexture = i23.value;
      const l32 = i23.value.texture, h25 = l32.params;
      this._size = this._computeSize(h25, o24), e31.textureId = l32.id;
    }
    this._createMaterialAndAddToStage(e31, this._context.stage);
  }
  async _prepareResourcesCIM(e31, t24, r30) {
    const i23 = new d2({ data: t24 });
    if (!this._context.sharedResources.cimSymbolRasterizer) {
      const e32 = (await import("./CIMSymbolRasterizer-BP7YNKLU.js")).CIMSymbolRasterizer;
      f2(r30), this._context.sharedResources.cimSymbolRasterizer || (this._context.sharedResources.cimSymbolRasterizer = new e32(this._context.renderCoordsHelper.spatialReference, true));
    }
    const s23 = this._context.layer.fields ? this._context.layer.fields.map((e32) => e32.toJSON()) : null;
    let a29, o24;
    if (this._cimLayers = await this._context.sharedResources.cimSymbolRasterizer.analyzeCIMSymbol(i23, s23, this._context.renderer && "dictionary" === this._context.renderer.type ? this._context.renderer.fieldMap : null, "esriGeometryPoint", { signal: r30 }), this._context.renderer && "dictionary" === this._context.renderer.type && this._context.renderer.scaleExpression) {
      const e32 = this._context.renderer;
      if (isNaN(e32.scaleExpression)) {
        const t25 = e32.scaleExpression, r31 = await o12(t25, this._context.layer.spatialReference, s23);
        o24 = (e33, t26, i24) => {
          const s24 = i12(r31, e33, { $view: i24 }, "esriGeometryPoint", t26);
          return null !== s24 ? s24 : 1;
        };
      } else
        a29 = Number(e32.scaleExpression);
    }
    this._cimScaleFactorOrFunction = a29 || o24 || 1;
    const n26 = this._context.renderer ? await this._context.renderer.getRequiredFields(this._context.layer.fieldsIndex) : [];
    f2(r30);
    const l32 = this._context.layer.fieldsIndex;
    this._cimRequiredFields = n26.map((e32) => l32.get(e32).name), this._cimMaterialParametersInfo = e31, this._cimMaterialParametersInfo.color = this._getFillColor(), this._cimMaterialParametersInfo.outlineColor = [0, 0, 0, 0], this._cimMaterialParametersInfo.outlineSize = 0, this._cimMaterialParametersInfo.textureIsSignedDistanceField = false;
  }
  _getPrimitive() {
    return this.symbolLayer.resource && this.symbolLayer.resource.href ? null : this.symbolLayer.resource && this.symbolLayer.resource.primitive || j5;
  }
  _getOutlineSize() {
    let e31 = 0;
    const t24 = this.symbolLayer;
    if (r(t24.outline) && null != t24.outline.size)
      return Math.max(u4(t24.outline.size), 0);
    return e31 = de2(this._getPrimitive()) ? ne2 : 0, Math.max(e31, 0);
  }
  _getOutlineColor() {
    const t24 = this._getLayerOpacity(), r30 = this.symbolLayer, a29 = q(r30, "outline", "color");
    if (r(a29)) {
      const r31 = l4.toUnitRGB(a29), i23 = a29.a * t24;
      return [r31[0], r31[1], r31[2], i23];
    }
    return [0, 0, 0, 0];
  }
  _getFillColor() {
    if (de2(this._getPrimitive()))
      return c19;
    const e31 = t(this._getPrimitive()), t24 = q(this.symbolLayer, "material", "color");
    return this._getCombinedOpacityAndColor(t24, { hasIntrinsicColor: e31 });
  }
  _getAnchorPos(e31, t24) {
    return "relative" === e31 ? r12((t24.x || 0) + 0.5, 0.5 - (t24.y || 0)) : e31 in o20 ? o20[e31] : o20.center;
  }
  _createMaterialAndAddToStage(e31, t24) {
    if (this._cimLayers ? this._fastUpdates = { enabled: false } : this._fastUpdates = P7(this._context.renderer, this._fastVisualVariableConvertOptions()), this._fastUpdates.enabled && Object.assign(e31, this._fastUpdates.materialParameters), this._cimLayers) {
      let r30 = r(e31.textureId) ? this._cimSymbolMaterials.get(e31.textureId) : null;
      return r30 || (r30 = new Q(e31), this._cimSymbolMaterials.set(i(e31.textureId, 0), r30), t24.add(r30)), r30;
    }
    return this._material = new Q(e31), t24.add(this._material), this._material;
  }
  _setDrapingDependentMaterialParameters() {
    this.draped && (this._forEachMaterial((e31) => {
      e31.setParameters({ verticalOffset: null, screenSizePerspective: null, occlusionTest: false, hasSlicePlane: false, shaderPolygonOffset: 0, isDraped: this.draped });
    }), this.layerOpacityChanged());
  }
  destroy() {
    super.destroy(), this._forEachMaterial((e31) => this._context.stage.remove(e31)), this._material = null, this._cimSymbolMaterials.clear(), this._cimSymbolTextures.forEach((e31) => this._context.stage.remove(e31)), this._cimSymbolTextures.clear(), this._releaseTexture = w(this._releaseTexture);
  }
  _getScaleFactor(e31, t24) {
    if (this._drivenProperties.size && e31.size) {
      for (let t25 = 0; t25 < 3; t25++) {
        const r30 = e31.size[t25];
        r30 && "symbol-value" !== r30 && "proportional" !== r30 && (e31.size[t25] = u4(r30));
      }
      if ("symbol-value" === e31.size[0])
        return 1;
      if (isFinite(+e31.size[0]))
        return +e31.size[0] / t24;
      if (isFinite(+e31.size[2]))
        return +e31.size[2] / t24;
    }
    return 1;
  }
  createGraphics3DGraphic(e31) {
    const t24 = e31.graphic;
    if (!this._validateGeometry(t24.geometry))
      return null;
    let r30, i23;
    if (this._cimLayers) {
      if (!this._cimLayers.length)
        return null;
      const e32 = this._generateTextureCIM(t24), s24 = { textureId: e32.id, ...this._cimMaterialParametersInfo };
      i23 = this._createMaterialAndAddToStage(s24, this._context.stage), r30 = [e32.params.width, e32.params.height];
    } else
      r30 = this._size, i23 = e(this._material);
    const s23 = d17(t24.geometry);
    if (t(s23))
      return this.logger.warn(`unsupported geometry type for icon symbol: ${t24.geometry.type}`), null;
    const o24 = e31.renderingInfo, n26 = this._getVertexOpacityAndColor(o24);
    let c31 = 1;
    if (!this._fastUpdates.enabled || !this._fastUpdates.visualVariables.size) {
      const e32 = r30[0] > r30[1] ? r30[0] : r30[1];
      c31 = this._getScaleFactor(o24, e32);
    }
    c31 *= this._symbolTextureRatio;
    const h25 = [r30[0] * c31, r30[1] * c31], m19 = this.setGraphicElevationContext(t24, new h16());
    return this.ensureDrapedStatus("on-the-ground" === m19.mode) && this._setDrapingDependentMaterialParameters(), this.draped ? this._createAsOverlay(t24, s23, i23, n26, h25, e31.layer.uid) : this._createAs3DShape(t24, s23, i23, n26, h25, m19, t24.uid);
  }
  layerOpacityChanged() {
    const e31 = this._getFillColor(), t24 = this._getOutlineColor();
    this._forEachMaterial((r30) => {
      r30.setParameters({ color: e31 }), r30.setParameters({ outlineColor: t24 });
    });
  }
  layerElevationInfoChanged(e31, t24, r30) {
    const i23 = this._elevationContext.mode, s23 = p10(me2.elevationModeChangeTypes, r30, i23);
    if (s23 !== x9.UPDATE)
      return s23;
    const a29 = g9(i23) || "absolute-height" === i23;
    return this.updateGraphics3DGraphicElevationInfo(e31, t24, () => a29);
  }
  slicePlaneEnabledChanged() {
    return this.draped || this._forEachMaterial((e31) => {
      e31.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled });
    }), true;
  }
  physicalBasedRenderingChanged() {
    return true;
  }
  pixelRatioChanged() {
    return !!this._getPrimitive();
  }
  applyRendererDiff(e31, t24) {
    for (const r30 in e31.diff) {
      if ("visualVariables" !== r30)
        return e20.Recreate_Symbol;
      if (!R9(this._fastUpdates, t24, this._fastVisualVariableConvertOptions()))
        return e20.Recreate_Symbol;
      r(this._material) && this._material.setParameters(this._fastUpdates.materialParameters);
    }
    return e20.Fast_Update;
  }
  _defaultElevationInfoNoZ() {
    return _e2;
  }
  _createAs3DShape(e31, t24, r30, i23, s23, a29, o24) {
    const n26 = this.getFastUpdateAttrValues(e31), l32 = n26 ? (e32) => B6(this._fastUpdates.materialParameters, n26, e32) : null, c31 = this._context.stage.renderView._getObjectAndLayerIdColor({ graphicUid: o24, layerUid: this._context.layer.uid }), h25 = [b11(ae2, null, i23, s23, pe2, null, n26, c31)], m19 = u24(this._context, t24, h25, [r30], a29, this._context.layer.uid, o24, l32);
    if (null === m19)
      return null;
    const u33 = new _8(this, m19.object, h25, null, null, d15, a29);
    return u33.alignedSampledElevation = m19.sampledElevation, u33.needsElevationUpdates = g9(a29.mode) || "absolute-height" === a29.mode, u33.getScreenSize = this._createScreenSizeGetter(s23, l32), u33.calculateRelativeScreenBounds = (e32) => r30.calculateRelativeScreenBounds(u33.getScreenSize(), 1, e32), f18(u33, t24, this._context.elevationProvider), u33;
  }
  _createAsOverlay(e31, t24, r30, s23, a29, o24) {
    r30.renderPriority = this._renderPriority;
    const n26 = n9();
    gn(t24, n26, this._context.overlaySR), n26[2] = ue;
    const l32 = this._context.clippingExtent;
    if (r(l32) && !E3(l32, n26))
      return null;
    const c31 = this.getFastUpdateAttrValues(e31), h25 = c31 ? (e32) => B6(this._fastUpdates.materialParameters, c31, e32) : null, m19 = this._context.stage.renderView._getObjectAndLayerIdColor({ graphicUid: e31.uid, layerUid: this._context.layer.uid }), u33 = b11(ae2, n26, s23, a29, null, null, c31, m19), d27 = new T4(u33, r30, { layerUid: o24, graphicUid: e31.uid, calculateShaderTransformation: h25 });
    n26[3] = 0, a2(d27.boundingSphere, n26);
    const _20 = new l25(this, [d27], null, this._context.drapeSourceRenderer);
    return _20.getScreenSize = this._createScreenSizeGetter(a29, h25), _20.calculateRelativeScreenBounds = (e32) => r30.calculateRelativeScreenBounds(_20.getScreenSize(), 1, e32), _20;
  }
  _createScreenSizeGetter(e31, t24) {
    const r30 = this._outlineSize + 2;
    if (this._fastUpdates.enabled) {
      const i23 = e31[0] / this._symbolTextureRatio, s23 = e31[1] / this._symbolTextureRatio;
      return (e32 = n12()) => {
        const a29 = t24(se2);
        return e32[0] = a29[0] * i23 + r30, e32[1] = a29[5] * s23 + r30, e32;
      };
    }
    {
      const t25 = e31[0] / this._symbolTextureRatio + r30, i23 = e31[1] / this._symbolTextureRatio + r30;
      return (e32 = n12()) => (e32[0] = t25, e32[1] = i23, e32);
    }
  }
  _fastVisualVariableConvertOptions() {
    const e31 = this._size[0] > this._size[1] ? this._size[0] : this._size[1], t24 = r2(e31, e31, e31), r30 = e6(1), i23 = e31 * r30;
    return { modelSize: t24, symbolSize: r2(i23, i23, i23), unitInMeters: r30, transformation: { anchor: f, scale: l, rotation: f } };
  }
  _getGraphicHash(e31) {
    let t24 = "";
    for (const r30 of this._cimRequiredFields)
      t24 += r30 + e31.attributes[r30];
    return t24;
  }
  _forEachMaterial(e31) {
    r(this._material) && e31(this._material), this._cimSymbolMaterials.forEach(e31);
  }
  test() {
    return { ...super.test(), material: this._material };
  }
};
function ue3(e31) {
  return e31 && "point-3d" === e31.type && e31.hasVisibleVerticalOffset();
}
function de2(e31) {
  return !t(e31) && ("cross" === e31 || "x" === e31);
}
me2.PRIMITIVE_SIZE = he2, me2.elevationModeChangeTypes = { definedChanged: x9.UPDATE, staysOnTheGround: x9.NONE, onTheGroundChanged: x9.RECREATE };
var _e2 = { mode: "relative-to-ground", offset: 0 };
var pe2 = r8(0, 0, 0, 1);

// node_modules/@arcgis/core/views/3d/layers/graphics/lineUtils.js
function n20(n26) {
  switch (n26) {
    case "butt":
      return r16.BUTT;
    case "square":
      return r16.SQUARE;
    case "round":
      return r16.ROUND;
    default:
      return null;
  }
}
function r23(e31) {
  return "diamond" === e31 ? "kite" : e31;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/LineMarkerTechnique.js
var R10 = /* @__PURE__ */ new Map([[O2.POSITION, 0], [O2.UV0, 2], [O2.AUXPOS1, 3], [O2.NORMAL, 4], [O2.COLOR, 5], [O2.COLORFEATUREATTRIBUTE, 5], [O2.SIZE, 6], [O2.SIZEFEATUREATTRIBUTE, 6], [O2.OPACITYFEATUREATTRIBUTE, 7]]);
var b18 = class extends e12 {
  initializeProgram(e31) {
    return new o10(e31.rctx, b18.shader.get().build(this.configuration), R10);
  }
  _makePipelineState(t24, i23) {
    const o24 = this.configuration, a29 = t24 === o8.NONE;
    return W({ blending: o24.output === h9.Color || o24.output === h9.Alpha ? a29 ? c15 : A5(t24) : null, depthTest: { func: l17(t24) }, depthWrite: a29 ? o24.writeDepth && a12 : E7(t24), colorWrite: _5, stencilWrite: o24.hasOccludees ? e13 : null, stencilTest: o24.hasOccludees ? i23 ? o11 : f10 : null, polygonOffset: { factor: 0, units: -10 } });
  }
  initializePipeline() {
    return this.configuration.occluder && (this._occluderPipelineTransparent = W({ blending: c15, depthTest: s8, depthWrite: null, colorWrite: _5, stencilWrite: null, stencilTest: m8 }), this._occluderPipelineOpaque = W({ blending: c15, depthTest: s8, depthWrite: null, colorWrite: _5, stencilWrite: l18, stencilTest: P4 }), this._occluderPipelineMaskWrite = W({ blending: null, depthTest: i9, depthWrite: null, colorWrite: null, stencilWrite: e13, stencilTest: o11 })), this._occludeePipelineState = this._makePipelineState(this.configuration.transparencyPassType, true), this._makePipelineState(this.configuration.transparencyPassType, false);
  }
  getPipelineState(e31, t24) {
    return t24 ? this._occludeePipelineState : this.configuration.occluder ? e31 === E8.TRANSPARENT_OCCLUDER_MATERIAL ? this._occluderPipelineTransparent : e31 === E8.OCCLUDER_MATERIAL ? this._occluderPipelineOpaque : this._occluderPipelineMaskWrite : super.getPipelineState(e31, t24);
  }
};
b18.shader = new t12(M5, () => import("./LineMarker.glsl-F3KAMGN7.js"));

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/LineMarkerMaterial.js
var v16 = class extends d10 {
  constructor(e31) {
    super(e31, new S13()), this._vertexAttributeLocations = R10, this._configuration = new a16(), this._layout = this.createLayout();
  }
  dispose() {
  }
  getConfiguration(e31, t24) {
    return this._configuration.output = e31, this._configuration.space = t24.slot === E8.DRAPED_MATERIAL ? p9.Draped : this.parameters.worldSpace ? p9.World : p9.Screen, this._configuration.hideOnShortSegments = this.parameters.hideOnShortSegments, this._configuration.hasCap = this.parameters.cap !== r16.BUTT, this._configuration.anchor = this.parameters.anchor, this._configuration.hasTip = this.parameters.hasTip, this._configuration.hasSlicePlane = this.parameters.hasSlicePlane, this._configuration.hasOccludees = this.parameters.hasOccludees, this._configuration.writeDepth = this.parameters.writeDepth, this._configuration.vvColor = this.parameters.vvColorEnabled, this._configuration.vvOpacity = this.parameters.vvOpacityEnabled, this._configuration.vvSize = this.parameters.vvSizeEnabled, this._configuration.occluder = this.parameters.renderOccluded === o7.OccludeAndTransparentStencil, this._configuration.transparencyPassType = t24.transparencyPassType, this._configuration.hasMultipassTerrain = t24.multipassTerrain.enabled, this._configuration.cullAboveGround = t24.multipassTerrain.cullAboveGround, this._configuration;
  }
  intersect() {
  }
  createLayout() {
    const e31 = T2().vec3f(O2.POSITION).vec2f(O2.UV0).vec3f(O2.AUXPOS1);
    return this.parameters.worldSpace && e31.vec3f(O2.NORMAL), this.parameters.vvSizeEnabled ? e31.f32(O2.SIZEFEATUREATTRIBUTE) : e31.f32(O2.SIZE), this.parameters.vvColorEnabled ? e31.f32(O2.COLORFEATUREATTRIBUTE) : e31.vec4f(O2.COLOR), this.parameters.vvOpacityEnabled && e31.f32(O2.OPACITYFEATUREATTRIBUTE), e31;
  }
  createBufferWriter() {
    return new O9(this._layout, this.parameters);
  }
  requiresSlot(e31, t24) {
    if (t24 === h9.Color || t24 === h9.Alpha || t24 === h9.Highlight || t24 === h9.Depth) {
      if (e31 === E8.DRAPED_MATERIAL)
        return true;
      if (this.parameters.renderOccluded === o7.OccludeAndTransparentStencil)
        return e31 === E8.OPAQUE_MATERIAL || e31 === E8.OCCLUDER_MATERIAL || e31 === E8.TRANSPARENT_OCCLUDER_MATERIAL;
      if (t24 === h9.Color || t24 === h9.Alpha) {
        return e31 === (this.parameters.writeDepth ? E8.TRANSPARENT_MATERIAL : E8.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL);
      }
      return e31 === E8.OPAQUE_MATERIAL;
    }
    return false;
  }
  createGLMaterial(e31) {
    return new _12(e31);
  }
};
var _12 = class extends h10 {
  _updateParameters(e31) {
    return this.updateTexture(this._material.parameters.textureId), this._material.setParameters(this.textureBindParameters), this.ensureTechnique(b18, e31);
  }
  _updateOccludeeState(e31) {
    e31.hasOccludees !== this._material.parameters.hasOccludees && this._material.setParameters({ hasOccludees: e31.hasOccludees });
  }
  beginSlot(e31) {
    return this._output !== h9.Color && this._output !== h9.Alpha || this._updateOccludeeState(e31), this._updateParameters(e31);
  }
};
var S13 = class extends v7 {
  constructor() {
    super(...arguments), this.width = 0, this.color = [1, 1, 1, 1], this.placement = "end", this.cap = r16.BUTT, this.anchor = s11.Center, this.hasTip = false, this.worldSpace = false, this.hideOnShortSegments = false, this.writeDepth = true, this.hasSlicePlane = false, this.vvFastUpdate = false, this.hasOccludees = false;
  }
};
var O9 = class {
  constructor(e31, t24) {
    this.vertexBufferLayout = e31, this._parameters = t24;
  }
  allocate(e31) {
    return this.vertexBufferLayout.createBuffer(e31);
  }
  elementCount() {
    return "begin-end" === this._parameters.placement ? 12 : 6;
  }
  write(s23, i23, n26, o24, h25) {
    const c31 = n26.vertexAttributes.get(O2.POSITION).data, u33 = c31.length / 3;
    let p21 = [1, 0, 0];
    const m19 = n26.vertexAttributes.get(O2.NORMAL);
    this._parameters.worldSpace && r(m19) && (p21 = m19.data);
    let d27 = 1, A12 = 0;
    this._parameters.vvSizeEnabled ? A12 = n26.vertexAttributes.get(O2.SIZEFEATUREATTRIBUTE).data[0] : n26.vertexAttributes.has(O2.SIZE) && (d27 = n26.vertexAttributes.get(O2.SIZE).data[0]);
    let f25 = [1, 1, 1, 1], E23 = 0;
    this._parameters.vvColorEnabled ? E23 = n26.vertexAttributes.get(O2.COLORFEATUREATTRIBUTE).data[0] : n26.vertexAttributes.has(O2.COLOR) && (f25 = n26.vertexAttributes.get(O2.COLOR).data);
    let T9 = 0;
    this._parameters.vvOpacityEnabled && (T9 = n26.vertexAttributes.get(O2.OPACITYFEATUREATTRIBUTE).data[0]);
    const v23 = new Float32Array(o24.buffer);
    let _20 = h25 * (this.vertexBufferLayout.stride / 4);
    const S18 = (e31, t24, r30, a29) => {
      if (v23[_20++] = e31[0], v23[_20++] = e31[1], v23[_20++] = e31[2], v23[_20++] = r30[0], v23[_20++] = r30[1], v23[_20++] = t24[0], v23[_20++] = t24[1], v23[_20++] = t24[2], this._parameters.worldSpace && (v23[_20++] = p21[0], v23[_20++] = p21[1], v23[_20++] = p21[2]), this._parameters.vvSizeEnabled ? v23[_20++] = A12 : v23[_20++] = d27, this._parameters.vvColorEnabled)
        v23[_20++] = E23;
      else {
        const e32 = Math.min(4 * a29, f25.length - 4);
        v23[_20++] = f25[e32 + 0], v23[_20++] = f25[e32 + 1], v23[_20++] = f25[e32 + 2], v23[_20++] = f25[e32 + 3];
      }
      this._parameters.vvOpacityEnabled && (v23[_20++] = T9);
    };
    let O13;
    !function(e31) {
      e31[e31.ASCENDING = 1] = "ASCENDING", e31[e31.DESCENDING = -1] = "DESCENDING";
    }(O13 || (O13 = {}));
    const R16 = (e31, i24) => {
      const n27 = o2(b19, c31[3 * e31], c31[3 * e31 + 1], c31[3 * e31 + 2]), o25 = g15;
      let h26 = e31 + i24;
      do {
        o2(o25, c31[3 * h26], c31[3 * h26 + 1], c31[3 * h26 + 2]), h26 += i24;
      } while (G(n27, o25) && h26 >= 0 && h26 < u33);
      s23 && (O(n27, n27, s23), O(o25, o25, s23)), S18(n27, o25, [-1, -1], e31), S18(n27, o25, [1, -1], e31), S18(n27, o25, [1, 1], e31), S18(n27, o25, [-1, -1], e31), S18(n27, o25, [1, 1], e31), S18(n27, o25, [-1, 1], e31);
    }, I12 = this._parameters.placement;
    "begin" !== I12 && "begin-end" !== I12 || R16(0, O13.ASCENDING), "end" !== I12 && "begin-end" !== I12 || R16(u33 - 1, O13.DESCENDING);
  }
};
var b19 = n2();
var g15 = n2();

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DLineSymbolLayer.js
var q7 = ["polyline", "polygon", "extent"];
var J4 = class extends y8 {
  constructor(e31, t24, r30, a29) {
    super(e31, t24, r30, a29);
  }
  async doLoad() {
    if (this._vvConvertOptions = { modelSize: [1, 1, 1], symbolSize: [1, 1, 1], unitInMeters: 1, transformation: { anchor: [0, 0, 0], scale: [1, 1, 1], rotation: [0, 0, 0] }, supportedTypes: { size: true, color: true, opacity: true, rotation: false } }, this._context.renderer && this._context.renderer.visualVariables && this._context.renderer.visualVariables.length > 0 ? this._fastUpdates = P7(this._context.renderer, this._vvConvertOptions) : this._fastUpdates = { enabled: false }, !this._drivenProperties.size) {
      if ((null != this.symbolLayer.size ? this.symbolLayer.size : e6(1)) < 0)
        throw new s4("graphics3dlinesymbollayer:invalid-size", "Symbol sizes may not be negative values");
    }
    this._markerTexture = r(this.symbolLayer.marker) && r(this._context.sharedResources.textures) ? f12(this._context.sharedResources.textures, r23(this.symbolLayer.marker.style)) : null;
  }
  _getMaterialParameters(e31, t24 = false) {
    var _a;
    const r30 = this._getCombinedOpacityAndColor(t24 && this._markerColor || this._materialColor);
    this._patternHidesLine && !t24 && (r30[3] = 0);
    const a29 = { width: this._computeMaterialWidth((_a = this.symbolLayer) == null ? void 0 : _a.size), color: r30, hasPolygonOffset: true, join: this.symbolLayer.join || "miter", cap: n20(this.symbolLayer.cap || "butt"), hasSlicePlane: this._context.slicePlaneEnabled, isClosed: e31, stipplePattern: a18(this.symbolLayer.pattern), stippleScaleWithLineWidth: true };
    return this._fastUpdates && this._fastUpdates.visualVariables ? { ...a29, ...this._fastUpdates.materialParameters } : a29;
  }
  get _materialColor() {
    return o(this.symbolLayer.material, (e31) => e31.color);
  }
  get _markerColor() {
    return o(this.symbolLayer.marker, (e31) => e31.color);
  }
  get _lineMaterial() {
    return t(this._lineMaterialCached) && (this._lineMaterialCached = new H2(this._getMaterialParameters(false)), this._context.stage.add(this._lineMaterialCached)), this._lineMaterialCached;
  }
  get _ringMaterial() {
    return t(this._ringMaterialCached) && (this._ringMaterialCached = new H2(this._getMaterialParameters(true)), this._context.stage.add(this._ringMaterialCached)), this._ringMaterialCached;
  }
  get _wireframeLineMaterial() {
    return t(this._wireframeLineMaterialCached) && (this._wireframeLineMaterialCached = new H2({ ...this._getMaterialParameters(false), wireframe: true }), this._context.stage.add(this._wireframeLineMaterialCached)), this._wireframeLineMaterialCached;
  }
  get _wireframeRingMaterial() {
    return t(this._wireframeRingMaterialCached) && (this._wireframeRingMaterialCached = new H2({ ...this._getMaterialParameters(true), wireframe: true }), this._context.stage.add(this._wireframeRingMaterialCached)), this._wireframeRingMaterialCached;
  }
  get _markerMaterial() {
    return t(this._markerMaterialCached) && r(this.symbolLayer.marker) && r(this._markerTexture) && (this._markerMaterialCached = new v16({ ...this._getMaterialParameters(false, true), placement: this.symbolLayer.marker.placement, textureId: this._markerTexture.texture.id }), this._context.stage.add(this._markerMaterialCached)), this._markerMaterialCached;
  }
  destroy() {
    super.destroy(), this._forEachMaterial((e31) => this._context.stage.remove(e31)), this._lineMaterialCached = null, this._ringMaterialCached = null, this._wireframeLineMaterialCached = null, this._wireframeRingMaterialCached = null, this._markerMaterialCached = null, this._markerTexture = w(this._markerTexture);
  }
  _getDrivenSize(e31) {
    return this._drivenProperties.size && e31.size ? u4(c18(e31.size)) : 1;
  }
  _getSizeFeatureAttributeData(e31) {
    return this._fastUpdates.enabled && this._fastUpdates.visualVariables.size ? v15(this._fastUpdates.visualVariables.size.field, e31) : null;
  }
  _getDrivenColor(e31) {
    const t24 = r8(1, 1, 1, 1);
    return this._drivenProperties.color && e31.color && (t24[0] = e31.color[0], t24[1] = e31.color[1], t24[2] = e31.color[2], e31.color.length > 0 && (t24[3] = e31.color[3])), this._drivenProperties.opacity && e31.opacity && (t24[3] = e31.opacity), t24;
  }
  _getColorFeatureAttributeData(e31) {
    return this._fastUpdates.enabled && this._fastUpdates.visualVariables.color ? v15(this._fastUpdates.visualVariables.color.field, e31) : null;
  }
  _getOpacityFeatureAttributeData(e31) {
    return this._fastUpdates.enabled && this._fastUpdates.visualVariables.opacity ? v15(this._fastUpdates.visualVariables.opacity.field, e31) : null;
  }
  createGraphics3DGraphic(e31) {
    const t24 = e31.graphic;
    if (!this._validateGeometry(t24.geometry, q7, this.symbolLayer.type))
      return null;
    const r30 = this.setGraphicElevationContext(t24, new h16());
    return this.ensureDrapedStatus("on-the-ground" === r30.mode), this.draped ? this._createAsOverlay(e31, this._context.layer.uid) : this._createAs3DShape(e31, r30, t24.uid);
  }
  applyRendererDiff(e31, t24) {
    for (const r30 in e31.diff) {
      if ("visualVariables" !== r30)
        return e20.Recreate_Symbol;
      if (!R9(this._fastUpdates, t24, this._vvConvertOptions))
        return e20.Recreate_Symbol;
      this._forEachMaterial((e32) => e32.setParameters(this._fastUpdates.materialParameters));
    }
    return e20.Fast_Update;
  }
  prepareSymbolLayerPatch(e31) {
    var _a, _b;
    if ("partial" !== e31.diff.type)
      return;
    const t24 = e31.diff.diff, r30 = {};
    "complete" === ((_a = t24.size) == null ? void 0 : _a.type) && (r30.width = this._computeMaterialWidth(t24.size.newValue), delete t24.size), "complete" === ((_b = t24.cap) == null ? void 0 : _b.type) && (r30.cap = n20(i(t24.cap.newValue, "butt")), delete t24.cap);
    const a29 = this._prepareMarkerPatch(e31, t24);
    this._prepareMaterialPatch(e31, t24, a29), e31.symbolLayerStatePatches.push(() => this._forEachMaterial((e32) => e32.setParameters(r30)));
  }
  layerOpacityChanged() {
    this._forEachMaterial((e31, t24) => this._updateMaterialLayerOpacity(e31, t24));
  }
  _forEachMaterial(e31) {
    r(this._lineMaterialCached) && e31(this._lineMaterialCached), r(this._ringMaterialCached) && e31(this._ringMaterialCached), r(this._wireframeLineMaterialCached) && e31(this._wireframeLineMaterialCached), r(this._wireframeRingMaterialCached) && e31(this._wireframeRingMaterialCached), r(this._markerMaterialCached) && e31(this._markerMaterialCached, true);
  }
  _updateMaterialLayerOpacity(e31, t24 = false) {
    const r30 = e31.parameters.color, a29 = q(this.symbolLayer, "material", "color"), i23 = this._patternHidesLine && !t24 ? 0 : this._getCombinedOpacity(a29), s23 = r8(r30[0], r30[1], r30[2], i23);
    e31.setParameters({ color: s23 });
  }
  layerElevationInfoChanged(e31, t24, r30) {
    const a29 = this._elevationContext.mode, i23 = p10(J4.elevationModeChangeTypes, r30, a29);
    if (i23 !== x9.UPDATE)
      return i23;
    const s23 = g9(a29);
    return this.updateGraphics3DGraphicElevationInfo(e31, t24, () => s23);
  }
  slicePlaneEnabledChanged() {
    const e31 = { hasSlicePlane: this._context.slicePlaneEnabled };
    return this._forEachMaterial((t24) => t24.setParameters(e31)), true;
  }
  physicalBasedRenderingChanged() {
    return true;
  }
  pixelRatioChanged() {
    return true;
  }
  _getGeometryAsPolygonOrPolyline(e31) {
    switch (e31.type) {
      case "extent":
        if (e31 instanceof w4)
          return v2.fromExtent(e31);
        break;
      case "polygon":
      case "polyline":
        return e31;
    }
    return null;
  }
  _createAs3DShape(e31, r30, a29) {
    const i23 = e31.graphic, s23 = this._getGeometryAsPolygonOrPolyline(i23.geometry), o24 = "polygon" === s23.type ? s23.rings : s23.paths, n26 = new Array(), l32 = new Array(), h25 = new Array(), c31 = a6(), d27 = i15(s23, this._context.elevationProvider, this._context.renderCoordsHelper, r30), m19 = "polygon" === s23.type ? "rings" : "paths";
    this._logGeometryCreationWarnings(d27, o24, m19, "LineSymbol3DLayer");
    for (let _20 = 0; _20 < d27.lines.length; _20++) {
      const { position: r31, mapPosition: i24 } = d27.lines[_20];
      if (r(this._context.clippingExtent) && (A2(c31), M3(c31, i24), !R2(c31, this._context.clippingExtent)))
        continue;
      const o25 = this._createGeometry(e31, r31, i24, s23.type, K.ELEVATED, a29);
      n26.push(o25), l32.push("polygon" === s23.type ? this._ringMaterial : this._lineMaterial), h25.push(o3), t14.LINE_WIREFRAMES && (n26.push(o25.cloneShallow()), l32.push("polygon" === s23.type ? this._wireframeRingMaterial : this._wireframeLineMaterial), h25.push(o3));
      const m20 = this._markerMaterial;
      r(m20) && (n26.push(o25.cloneShallow()), l32.push(m20), h25.push(o3));
    }
    if (0 === n26.length)
      return null;
    const f25 = new x7({ geometries: n26, materials: l32, transformations: h25, castShadow: false, metadata: { layerUid: this._context.layer.uid, graphicUid: a29 } }), C16 = new _8(this, f25, n26, null, null, b13, r30);
    return C16.alignedSampledElevation = d27.sampledElevation, C16.needsElevationUpdates = g9(r30.mode), C16;
  }
  _createGeometry(e31, t24, r30, a29, i23, s23) {
    const o24 = "polygon" === a29, n26 = this._fastUpdates.enabled && this._fastUpdates.visualVariables.color, l32 = this._fastUpdates.enabled && this._fastUpdates.visualVariables.size, h25 = this._context.stage.renderView._getObjectAndLayerIdColor({ graphicUid: s23, layerUid: this._context.layer.uid });
    return m11({ overlayInfo: i23 === K.DRAPED ? { spatialReference: this._context.overlaySR, renderCoordsHelper: this._context.renderCoordsHelper } : null, removeDuplicateStartEnd: o24, attributeData: { position: t24, mapPosition: r30, size: l32 ? null : this._getDrivenSize(e31.renderingInfo), color: n26 ? null : this._getDrivenColor(e31.renderingInfo), sizeFeature: this._getSizeFeatureAttributeData(e31.graphic), colorFeature: this._getColorFeatureAttributeData(e31.graphic), opacityFeature: this._getOpacityFeatureAttributeData(e31.graphic) } }, h25);
  }
  _createAsOverlay(e31, r30) {
    const a29 = e31.graphic, i23 = this._getGeometryAsPolygonOrPolyline(a29.geometry), s23 = "polygon" === i23.type ? i23.rings : i23.paths, o24 = "polygon" === i23.type ? this._ringMaterial : this._lineMaterial;
    o24.renderPriority = this._renderPriority;
    const l32 = t14.LINE_WIREFRAMES ? "polygon" === i23.type ? this._wireframeRingMaterial : this._wireframeLineMaterial : null, h25 = this._markerMaterial;
    r(l32) && (l32.renderPriority = this._renderPriority - 1e-3), r(h25) && (h25.renderPriority = this._renderPriority - 2e-3);
    const p21 = new Array(), c31 = a6(), d27 = A2(), m19 = s13(i23, this._context.overlaySR), C16 = "polygon" === i23.type ? "rings" : "paths";
    this._logGeometryCreationWarnings(m19, s23, C16, "LineSymbol3DLayer");
    for (const _20 of m19.lines) {
      if (A2(c31), M3(c31, _20.position), !R2(c31, this._context.clippingExtent))
        continue;
      f4(d27, c31);
      const s24 = this._createGeometry(e31, _20.position, null, i23.type, K.DRAPED, a29.uid), m20 = (e32) => {
        const t24 = new T4(s24, e32, { layerUid: r30, graphicUid: a29.uid });
        return p21.push(t24), t24;
      };
      if (r(h25)) {
        const e32 = m20(h25), t24 = e(this.symbolLayer.marker).placement;
        "begin" !== t24 && "begin-end" !== t24 || M3(c31, _20.position, 0, 1), "end" !== t24 && "begin-end" !== t24 || M3(c31, _20.position, _20.position.length - 3, 1), this._updateBoundingSphere(e32, c31);
      }
      const C17 = m20(o24);
      if (this._updateBoundingSphere(C17, c31), t14.LINE_WIREFRAMES) {
        const e32 = m20(l32);
        this._updateBoundingSphere(e32, c31);
      }
    }
    return new l25(this, p21, d27, this._context.drapeSourceRenderer);
  }
  _updateBoundingSphere(e31, t24) {
    r5(e31.boundingSphere, 0.5 * (t24[0] + t24[3]), 0.5 * (t24[1] + t24[4]), 0, 0.5 * Math.sqrt((t24[3] - t24[0]) * (t24[3] - t24[0]) + (t24[4] - t24[1]) * (t24[4] - t24[1])));
  }
  get _patternHidesLine() {
    const e31 = this.symbolLayer.pattern;
    return r(e31) && "style" === e31.type && "none" === e31.style;
  }
  _computeMaterialWidth(e31) {
    return e31 = i(e31, e6(1)), this._drivenProperties.size ? this._fastUpdates.enabled && this._fastUpdates.visualVariables.size ? u4(1) : 1 : u4(e31);
  }
  _prepareMaterialPatch(e31, t24, i23) {
    const s23 = t24.material;
    if (t(s23))
      return void (i23.changed && i23.useMaterialColor && this._patchMaterialColor(this._getCombinedOpacityAndColor(this._materialColor), this._markerMaterialCached, e31));
    if ("collection" === s23.type)
      return;
    const o24 = "complete" === s23.type ? o(s23.newValue, (e32) => e32.color) : "complete" === s23.diff.color.type ? s23.diff.color.newValue : null, n26 = this._getCombinedOpacityAndColor(o24);
    i23.useMaterialColor && this._patchMaterialColor(t6(n26), this._markerMaterialCached, e31), this._patternHidesLine && (n26[3] = 0), this._patchMaterialColor(n26, this._lineMaterialCached, e31), delete t24.material;
  }
  _prepareMarkerPatch(e31, r30) {
    const i23 = r30.marker;
    if (t(i23) || "partial" !== i23.type || r(i23.diff.style) || r(i23.diff.placement) || r(i23.diff.color) && "complete" !== i23.diff.color.type)
      return { changed: false, useMaterialColor: t(this._markerColor) };
    const s23 = i23.diff.color;
    if (t(s23))
      return delete r30.marker, { changed: false, useMaterialColor: t(this._markerColor) };
    const o24 = e(s23.newValue);
    return t(o24) ? (delete r30.marker, { changed: true, useMaterialColor: true }) : (this._patchMaterialColor(this._getCombinedOpacityAndColor(o24), this._markerMaterialCached, e31), delete r30.marker, { changed: true, useMaterialColor: false });
  }
  _patchMaterialColor(e31, t24, r30) {
    t(t24) || r30.symbolLayerStatePatches.push(() => t24.setParameters({ color: e31 }));
  }
};
var K;
J4.elevationModeChangeTypes = { definedChanged: x9.RECREATE, staysOnTheGround: x9.NONE, onTheGroundChanged: x9.RECREATE }, function(e31) {
  e31[e31.DRAPED = 0] = "DRAPED", e31[e31.ELEVATED = 1] = "ELEVATED";
}(K || (K = {}));

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DMeshFillSymbolLayer.js
var me3 = ["mesh"];
var he3 = class extends y8 {
  constructor(e31, t24, r30, a29) {
    super(e31, t24, r30, a29), this._materials = /* @__PURE__ */ new Map(), this._textures = /* @__PURE__ */ new Map(), this.ensureDrapedStatus(false);
  }
  async doLoad() {
    t14.DRAW_MESH_GEOMETRY_NORMALS && (this._debugVertexNormalMaterial = new F5({ color: [1, 0, 1, 1] }), this._debugFaceNormalMaterial = new F5({ color: [0, 1, 1, 1] }));
  }
  destroy() {
    super.destroy(), this._context.stage.removeMany(Array.from(this._materials.values(), (e31) => e31.material)), this._context.stage.removeMany(Array.from(this._textures.values())), this._materials.clear(), this._textures.clear();
  }
  createGraphics3DGraphic(e31) {
    const t24 = e31.graphic;
    if (!this._validateGeometry(t24.geometry, me3, "fill on mesh-3d"))
      return null;
    const r30 = this.setGraphicElevationContext(t24, new h16()), a29 = e31.renderingInfo;
    return this._createAs3DShape(t24, a29, r30, t24.uid);
  }
  layerOpacityChanged(e31, r30) {
    const a29 = this._getLayerOpacity();
    this._materials.forEach((e32) => {
      e32.material.setParameters({ layerOpacity: a29 });
      const t24 = e32.material.parameters;
      this._setMaterialTransparentParameter(t24, e32), e32.material.setParameters({ transparent: t24.transparent });
    }), e31.forEach((e32) => {
      const o24 = r30(e32);
      r(o24) && o24.layerOpacityChanged(a29, this._context.isAsync);
    });
  }
  layerElevationInfoChanged(e31, t24) {
    return this.updateGraphics3DGraphicElevationInfo(e31, t24, v10);
  }
  slicePlaneEnabledChanged(e31, r30) {
    return this._materials.forEach((e32) => {
      e32.material.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled });
    }), e31.forEach((e32) => {
      const a29 = r30(e32);
      r(a29) && a29.slicePlaneEnabledChanged(this._context.slicePlaneEnabled, this._context.isAsync);
    }), true;
  }
  physicalBasedRenderingChanged() {
    const e31 = this._usePBR();
    return this._materials.forEach((t24) => t24.material.setParameters({ usePBR: e31 })), true;
  }
  pixelRatioChanged() {
    return true;
  }
  _requiresSymbolVertexColors() {
    return this._drivenProperties.color || this._drivenProperties.opacity;
  }
  _colorOrTextureUid(t24) {
    return t(t24) ? "-" : t24 instanceof l4 ? t24.toHex() : t24.contentHash;
  }
  _materialPropertiesDefault(e31, t24) {
    const r30 = this._requiresSymbolVertexColors(), a29 = !!e31.vertexAttributes.color, o24 = !!e31.vertexAttributes.tangent;
    return { hasSymbolVertexColors: r30, hasVertexColors: a29, hasVertexTangents: o24, uid: `vc:${a29},vt:${o24},vct${t24},svc:${r30}` };
  }
  _materialProperties(e31, t24, r30) {
    const a29 = this._materialPropertiesDefault(e31, r30);
    if (!t24.material)
      return a29;
    const { color: o24, colorTexture: s23, normalTexture: n26, doubleSided: i23, alphaCutoff: l32, alphaMode: u33 } = t24.material, c31 = this._colorOrTextureUid(o24), m19 = this._colorOrTextureUid(s23), h25 = this._colorOrTextureUid(n26);
    if (a29.color = o24, a29.colorTexture = s23, a29.normalTexture = n26, a29.uid = `${a29.uid},cmuid:${c31},ctmuid:${m19},ntmuid:${h25},ds:${i23},ac:${l32},am:${u33}`, t24.material instanceof c10) {
      const { metallic: e32, roughness: r31, metallicRoughnessTexture: o25, emissiveColor: s24, emissiveTexture: n27, occlusionTexture: i24 } = t24.material, l33 = this._colorOrTextureUid(o25), u34 = this._colorOrTextureUid(s24), c32 = this._colorOrTextureUid(n27), m20 = this._colorOrTextureUid(i24);
      a29.metallic = e32, a29.roughness = r31, a29.metallicRoughnessTexture = o25, a29.emissiveColor = s24, a29.emissiveTexture = n27, a29.occlusionTexture = i24, a29.colorTextureTransform = t24.material.colorTextureTransform, a29.normalTextureTransform = t24.material.normalTextureTransform, a29.emissiveTextureTransform = t24.material.emissiveTextureTransform, a29.occlusionTextureTransform = t24.material.occlusionTextureTransform, a29.metallicRoughnessTextureTransform = t24.material.metallicRoughnessTextureTransform, a29.uid = `${a29.uid},mrm:${e32},mrr:${r31},mrt:${l33},emuid:${u34},etmuid:${c32},otmuid:${m20}`;
    }
    return a29;
  }
  _setInternalColorValueParameters(t24, r30) {
    r30.diffuse = l4.toUnitRGB(t24), r30.opacity = t24.a;
  }
  _getLoadableTextureResource(e31) {
    return e31.data ? e31.data : e31.url;
  }
  _getInternalTextureId(e31) {
    const r30 = this._getInternalTexture(e31, C4.Opaque);
    return r(r30) ? r30.id : null;
  }
  _getInternalTexture(e31, t24) {
    const r30 = this._getLoadableTextureResource(e31);
    if (!r30)
      return null;
    const a29 = `${e31.contentHash}/${t24}`;
    let o24 = this._textures.get(a29);
    return o24 || (o24 = new L2(r30, { mipmap: true, wrap: this._castTextureWrap(e31.wrap), noUnpackFlip: true, preMultiplyAlpha: t24 !== C4.Opaque }), this._textures.set(a29, o24), this._context.stage.add(o24), this._context.stage.loadImmediate(o24)), o24;
  }
  _castTextureWrap(e31 = "repeat") {
    if ("string" == typeof e31) {
      const t24 = this._castTextureWrapIndividual(e31);
      return { s: t24, t: t24 };
    }
    return { s: this._castTextureWrapIndividual(e31.horizontal), t: this._castTextureWrapIndividual(e31.vertical) };
  }
  _castTextureWrapIndividual(e31) {
    switch (e31) {
      case "clamp":
        return D3.CLAMP_TO_EDGE;
      case "mirror":
        return D3.MIRRORED_REPEAT;
      default:
        return D3.REPEAT;
    }
  }
  _setInternalMaterialParameters(r30, a29) {
    if (r(r30.color) && this._setInternalColorValueParameters(r30.color, a29), r(r30.colorTexture)) {
      const e31 = this._getInternalTexture(r30.colorTexture, a29.textureAlphaMode);
      r(e31) ? (a29.textureId = e31.id, a29.textureAlphaPremultiplied = !!e31.params.preMultiplyAlpha) : a29.textureId = void 0;
    }
    r(r30.normalTexture) && (a29.normalTextureId = this._getInternalTextureId(r30.normalTexture)), r(r30.emissiveColor) && (a29.emissiveFactor = l4.toUnitRGB(r30.emissiveColor)), r(r30.emissiveTexture) && (a29.emissiveTextureId = this._getInternalTextureId(r30.emissiveTexture)), r(r30.occlusionTexture) && (a29.occlusionTextureId = this._getInternalTextureId(r30.occlusionTexture)), r(r30.metallicRoughnessTexture) && (a29.metallicRoughnessTextureId = this._getInternalTextureId(r30.metallicRoughnessTexture)), a29.colorTextureTransformMatrix = c13(r30.colorTextureTransform), a29.normalTextureTransformMatrix = c13(r30.normalTextureTransform), a29.occlusionTextureTransformMatrix = c13(r30.occlusionTextureTransform), a29.emissiveTextureTransformMatrix = c13(r30.emissiveTextureTransform), a29.metallicRoughnessTextureTransformMatrix = c13(r30.metallicRoughnessTextureTransform);
  }
  _setExternalMaterialParameters(r30) {
    const a29 = this._drivenProperties.color;
    let o24 = r(this.symbolLayer.material) ? this.symbolLayer.material.colorMixMode : null;
    if (a29)
      r30.externalColor = _2;
    else {
      const a30 = r(this.symbolLayer.material) ? this.symbolLayer.material.color : null;
      r(a30) ? r30.externalColor = l4.toUnitRGBA(a30) : (o24 = null, r30.externalColor = _2);
    }
    o24 && (r30.colorMixMode = o24), r30.castShadows = !!this.symbolLayer.castShadows;
  }
  _hasTransparentVertexColors(e31) {
    const t24 = e31.vertexAttributes.color;
    if (t(t24))
      return false;
    for (let r30 = 3; r30 < t24.length; r30 += 4)
      if (255 !== t24[r30])
        return true;
    return false;
  }
  _getOrCreateMaterial(e31, r30) {
    var _a, _b, _c;
    const a29 = (_a = r30.material) == null ? void 0 : _a.color, o24 = (_b = r30.material) == null ? void 0 : _b.colorTexture, s23 = (_c = r30.material) == null ? void 0 : _c.alphaMode, n26 = "blend" === s23, i23 = !("opaque" === s23) && (this._hasTransparentVertexColors(e31) || r(a29) && a29.a < 1 || r(o24) && o24.transparent || n26), l32 = this._materialProperties(e31, r30, i23), u33 = this._materials.get(l32.uid);
    if (u33)
      return u33.material;
    const c31 = { material: null, isComponentTransparent: i23, alphaMode: r30.material ? r30.material.alphaMode : "opaque" }, m19 = null == l32.metallicRoughnessTexture && null == l32.metallic && null == l32.roughness, h25 = { usePBR: this._usePBR(), isSchematic: m19, hasVertexColors: l32.hasVertexColors, hasSymbolColors: l32.hasSymbolVertexColors, hasVertexTangents: l32.hasVertexTangents, ambient: f, diffuse: l, opacity: 1, doubleSided: true, doubleSidedType: "winding-order", cullFace: n13.None, layerOpacity: this._getLayerOpacity(), hasSlicePlane: this._context.slicePlaneEnabled, initTextureTransparent: true };
    m19 || (h25.mrrFactors = [null != l32.metallic ? l32.metallic : 1, null != l32.roughness ? l32.roughness : 1, 0.5]), r30.material && (h25.doubleSided = r30.material.doubleSided, h25.cullFace = r30.material.doubleSided ? n13.None : n13.Back, h25.textureAlphaCutoff = r30.material.alphaCutoff), this._setExternalMaterialParameters(h25), this._setMaterialTransparentParameter(h25, c31), this._setInternalMaterialParameters(l32, h25);
    const f25 = new C5(h25);
    return c31.material = f25, this._materials.set(l32.uid, c31), this._context.stage.add(f25), f25;
  }
  _usePBR() {
    return this._context.physicalBasedRenderingEnabled;
  }
  _setMaterialTransparentParameter(e31, t24) {
    e31.transparent = this.needsDrivenTransparentPass || t24.isComponentTransparent || e31.layerOpacity < 1 || e31.opacity < 1 || e31.externalColor && e31.externalColor[3] < 1, "auto" === t24.alphaMode ? e31.textureAlphaMode = e31.transparent ? C4.MaskBlend : C4.Opaque : e31.textureAlphaMode = "opaque" === t24.alphaMode ? C4.Opaque : "mask" === t24.alphaMode ? C4.Mask : C4.Blend;
  }
  _addDebugNormals(e31, t24, r30, a29) {
    const o24 = t24.length, s23 = e31.spatialReference.isGeographic ? 20015077 / 180 : 1, n26 = 0.1 * Math.max(e31.extent.width * s23, e31.extent.height * s23, e31.extent.zmax - e31.extent.zmin), i23 = [], l32 = [], u33 = [], c31 = [];
    for (let m19 = 0; m19 < o24; m19++) {
      const e32 = t24[m19], r31 = e32.vertexAttributes.get(O2.POSITION), a30 = e32.vertexAttributes.get(O2.NORMAL), o25 = e32.indices.get(O2.POSITION), s24 = e32.indices.get(O2.NORMAL), h26 = r31.data, d28 = a30.data;
      for (let t25 = 0; t25 < o25.length; t25++) {
        const e33 = 3 * o25[t25], r32 = 3 * s24[t25];
        for (let t26 = 0; t26 < 3; t26++)
          i23.push(h26[e33 + t26]);
        for (let t26 = 0; t26 < 3; t26++)
          i23.push(h26[e33 + t26] + d28[r32 + t26] * n26);
        if (l32.push(l32.length), l32.push(l32.length), t25 % 3 == 0) {
          this._calculateFaceNormal(h26, o25, t25, xe), this._getFaceVertices(h26, o25, t25, pe3, de3, ge2), u(pe3, pe3, de3), u(pe3, pe3, ge2), g(pe3, pe3, 1 / 3);
          for (let e34 = 0; e34 < 3; e34++)
            u33.push(pe3[e34]);
          for (let e34 = 0; e34 < 3; e34++)
            u33.push(pe3[e34] + xe[e34] * n26);
          c31.push(c31.length), c31.push(c31.length);
        }
      }
    }
    const h25 = new d8([[O2.POSITION, { data: i23, size: 3, exclusive: true }]], [[O2.POSITION, l32]], a11.Line);
    t24.push(h25), r30.push(this._debugVertexNormalMaterial), a29.push(r9(a29[0]));
    const d27 = new d8([[O2.POSITION, { data: u33, size: 3, exclusive: true }]], [[O2.POSITION, c31]], a11.Line);
    t24.push(d27), r30.push(this._debugFaceNormalMaterial), a29.push(r9(a29[0]));
  }
  _createAs3DShape(e31, r30, a29, o24) {
    const s23 = e31.geometry;
    if ("mesh" !== s23.type)
      return null;
    const n26 = this._createGeometryInfo(s23, r30, o24);
    if (!n26)
      return null;
    const { geometries: i23, materials: l32, transformations: u33, objectTransformation: c31 } = n26;
    t14.DRAW_MESH_GEOMETRY_NORMALS && this._addDebugNormals(s23, i23, l32, u33);
    const m19 = new x7({ geometries: i23, materials: l32, transformations: u33, metadata: { layerUid: this._context.layer.uid, graphicUid: o24 } });
    m19.transformation = c31;
    const h25 = this._createEdgeMaterial(), f25 = r(h25) ? { baseMaterial: l32[0], edgeMaterials: [h25], properties: { mergeGeometries: true, hasSlicePlane: this._context.slicePlaneEnabled } } : null, p21 = new _8(this, m19, i23, null, null, d15, a29, f25);
    return p21.needsElevationUpdates = v10(a29.mode), p21.useObjectOriginAsAttachmentOrigin = true, p21.elevationContext.centerPointInElevationSR = this._getCenterPointInElevationSR(m19), p21.alignedSampledElevation = d15(p21, p21.elevationContext, this._context.elevationProvider, this._context.renderCoordsHelper), p21;
  }
  _getCenterPointInElevationSR(e31) {
    const r30 = v8(0, 0, 0, r(this._context.elevationProvider.spatialReference) ? this._context.elevationProvider.spatialReference : null);
    return Hn([e31.transformation[12], e31.transformation[13], e31.transformation[14]], this._context.renderCoordsHelper.spatialReference, r30), r30;
  }
  _createComponentNormals(e31, t24, r30, a29) {
    switch (r30.shading || "flat") {
      case "source":
        return this._createComponentNormalsSource(e31, t24, r30, a29);
      case "flat":
        return this._createComponentNormalsFlat(e31, a29);
      case "smooth":
        return this._createComponentNormalsSmooth(e31, a29);
      default:
        return;
    }
  }
  _createComponentNormalsSource(e31, t24, a29, o24) {
    if (t(t24))
      return this._createComponentNormalsFlat(e31, o24);
    let s23 = false;
    if (!a29.trustSourceNormals)
      for (let r30 = 0; r30 < o24.length; r30 += 3) {
        this._calculateFaceNormal(e31, o24, r30, xe);
        for (let e32 = 0; e32 < 3; e32++) {
          const a30 = 3 * o24[r30 + e32];
          pe3[0] = t24[a30 + 0], pe3[1] = t24[a30 + 1], pe3[2] = t24[a30 + 2], P(xe, pe3) < 0 && (t24[a30 + 0] = -t24[a30 + 0], t24[a30 + 1] = -t24[a30 + 1], t24[a30 + 2] = -t24[a30 + 2], s23 = true);
        }
      }
    return { normals: t24, indices: o24, didFlipNormals: s23 };
  }
  _createComponentNormalsFlat(e31, t24) {
    const r30 = new Float32Array(t24.length), a29 = new Array(3 * t24.length);
    for (let o24 = 0; o24 < t24.length; o24 += 3) {
      const s23 = this._calculateFaceNormal(e31, t24, o24, xe);
      for (let e32 = 0; e32 < 3; e32++)
        r30[o24 + e32] = s23[e32], a29[o24 + e32] = o24 / 3;
    }
    return { normals: r30, indices: a29, didFlipNormals: false };
  }
  _createComponentNormalsSmooth(e31, t24) {
    const r30 = {};
    for (let s23 = 0; s23 < t24.length; s23 += 3) {
      const a30 = this._calculateFaceNormal(e31, t24, s23, xe);
      for (let e32 = 0; e32 < 3; e32++) {
        const o25 = t24[s23 + e32];
        let n26 = r30[o25];
        n26 || (n26 = { normal: n2(), count: 0 }, r30[o25] = n26), u(n26.normal, n26.normal, a30), n26.count++;
      }
    }
    const a29 = new Float32Array(3 * t24.length), o24 = new Array(3 * t24.length);
    for (let s23 = 0; s23 < t24.length; s23++) {
      const e32 = r30[t24[s23]];
      1 !== e32.count && (z(e32.normal, e32.normal), e32.count = 1);
      for (let t25 = 0; t25 < 3; t25++)
        a29[3 * s23 + t25] = e32.normal[t25];
      o24[s23] = s23;
    }
    return { normals: a29, indices: o24, didFlipNormals: false };
  }
  _getFaceVertices(e31, t24, r30, a29, o24, s23) {
    const n26 = 3 * t24[r30 + 0], i23 = 3 * t24[r30 + 1], l32 = 3 * t24[r30 + 2];
    a29[0] = e31[n26 + 0], a29[1] = e31[n26 + 1], a29[2] = e31[n26 + 2], o24[0] = e31[i23 + 0], o24[1] = e31[i23 + 1], o24[2] = e31[i23 + 2], s23[0] = e31[l32 + 0], s23[1] = e31[l32 + 1], s23[2] = e31[l32 + 2];
  }
  _calculateFaceNormal(e31, t24, r30, a29) {
    return this._getFaceVertices(e31, t24, r30, pe3, de3, ge2), e3(de3, de3, pe3), e3(ge2, ge2, pe3), _(pe3, de3, ge2), z(a29, pe3), a29;
  }
  _getOrCreateComponents(e31) {
    return i(e31.components, be2);
  }
  _createPositionBuffer(e31, r30) {
    let a29 = e31.vertexAttributes.position;
    const o24 = r30.reprojection === ve.ECEF ? r30.transformBeforeProject : null;
    if (r(o24) && (a29 = R3(a29, new Float64Array(a29.length), o24)), r30.reprojection === ve.NONE)
      return r30.needsBufferCopy ? new Float64Array(a29) : a29;
    const s23 = r(o24) ? a29 : new Float64Array(a29.length);
    return xn(a29, e31.spatialReference, 0, s23, this._context.renderCoordsHelper.spatialReference, 0, a29.length / 3), s23;
  }
  _createNormalBuffer(e31, a29, o24) {
    let s23 = e31.vertexAttributes.normal;
    if (t(s23))
      return null;
    const n26 = o24.reprojection === ve.ECEF ? o24.transformBeforeProject : null;
    r(n26) && (s23 = v4(s23, new Float32Array(s23.length), n26));
    if ("local" === this._context.graphicsCoreOwner.view.viewingMode || o24.reprojection === ve.NONE)
      return o24.needsBufferCopy && e31.vertexAttributes.normal === s23 ? new Float32Array(s23) : s23;
    const i23 = e31.vertexAttributes.position, l32 = r(n26) ? s23 : new Float32Array(s23.length);
    return j7(s23, i23, a29, e31.spatialReference, l32);
  }
  _createTangentBuffer(e31, a29, o24) {
    let s23 = e31.vertexAttributes.tangent;
    if (t(s23))
      return null;
    const n26 = o24.reprojection === ve.ECEF ? o24.transformBeforeProject : null;
    r(n26) && (s23 = V2(s23, new Float32Array(s23.length), n26));
    if ("local" === this._context.graphicsCoreOwner.view.viewingMode || o24.reprojection === ve.NONE)
      return o24.needsBufferCopy && e31.vertexAttributes.normal === s23 ? new Float32Array(s23) : s23;
    const i23 = e31.vertexAttributes.position, l32 = r(n26) ? s23 : new Float32Array(s23.length);
    return k2(s23, i23, a29, e31.spatialReference, l32);
  }
  _createColorBuffer(e31) {
    return e31.vertexAttributes.color;
  }
  _createSymbolColorBuffer(e31) {
    if (this._requiresSymbolVertexColors()) {
      const t24 = this._getVertexOpacityAndColor(e31), r30 = n10(q(this.symbolLayer, "material", "colorMixMode")), a29 = new Uint8Array(4);
      return o6(t24, r30, a29), a29;
    }
    return null;
  }
  _createBuffers(e31, r30) {
    const a29 = e31.vertexAttributes && e31.vertexAttributes.position;
    if (!a29)
      return this.logger.warn("Mesh geometry must contain position vertex attributes"), null;
    const o24 = e31.vertexAttributes.normal, s23 = e31.vertexAttributes.uv, n26 = e31.vertexAttributes.tangent;
    if (r(o24) && o24.length !== a29.length)
      return this.logger.warn("Mesh normal vertex buffer must contain the same number of elements as the position buffer"), null;
    if (r(n26) && n26.length / 4 != a29.length / 3)
      return this.logger.warn("Mesh tangent vertex buffer must contain the same number of elements as the position buffer"), null;
    if (r(s23) && s23.length / 2 != a29.length / 3)
      return this.logger.warn("Mesh uv vertex buffer must contain the same number of elements as the position buffer"), null;
    const i23 = this._computeReprojectionInfo(e31), l32 = this._createPositionBuffer(e31, i23), u33 = this._createColorBuffer(e31), c31 = this._createSymbolColorBuffer(r30), m19 = this._createNormalBuffer(e31, l32, i23), f25 = this._createTangentBuffer(e31, l32, i23);
    return { positionBuffer: l32, normalBuffer: m19, tangentBuffer: f25, uvBuffer: s23, colorBuffer: u33, symbolColorBuffer: c31, objectTransformation: i23.reprojection === ve.NONE && r(i23.objectTransformation) ? i23.objectTransformation : this._transformOriginLocal(e31, l32, m19, f25), geometryTransformation: i23.reprojection === ve.NONE && r(i23.geometryTransformation) ? i23.geometryTransformation : e9() };
  }
  _computeReprojectionInfo(e31) {
    const r30 = r(e31.transform), a29 = r30 && e31.transform.geographic || this._context.renderCoordsHelper.viewingMode === l14.Local ? ve.NONE : ve.ECEF;
    if (r30) {
      if (a29 === ve.NONE) {
        const t25 = e9();
        Zn(e31.spatialReference, e31.transform.origin, t25, this._context.renderCoordsHelper.spatialReference);
        return { reprojection: a29, objectTransformation: t25, geometryTransformation: r9(e31.transform.localMatrix), needsBufferCopy: false };
      }
      const t24 = x2(e9(), e31.transform.origin);
      return u7(t24, t24, e31.transform.localMatrix), { reprojection: a29, transformBeforeProject: t24, needsBufferCopy: true };
    }
    return { reprojection: a29, needsBufferCopy: true };
  }
  _transformOriginLocal(e31, r30, a29, o24) {
    const i23 = this._context.renderCoordsHelper.spatialReference, l32 = e31.anchor;
    fe2[0] = l32.x, fe2[1] = l32.y, fe2[2] = l32.z;
    const u33 = e9();
    Zn(e31.spatialReference, fe2, u33, i23);
    const m19 = T.fromTypedArray(r30);
    if (h5(_e3, u33), t7(m19, m19, _e3), r(a29) || r(o24)) {
      if (a9(Te, u33), o5(Te, Te), r(a29)) {
        const e32 = i5.fromTypedArray(a29);
        r11(e32, e32, Te);
      }
      if (r(o24)) {
        const e32 = i5.fromTypedArray(o24, 4 * o24.BYTES_PER_ELEMENT);
        r11(e32, e32, Te);
      }
    }
    return u33;
  }
  _validateFaces(e31, t24) {
    const r30 = e31.vertexAttributes.position.length / 3, a29 = t24.faces;
    if (a29) {
      let e32 = -1;
      for (let t25 = 0; t25 < a29.length; t25++) {
        const r31 = a29[t25];
        r31 > e32 && (e32 = r31);
      }
      if (r30 <= e32)
        return this.logger.warn(`Vertex index ${e32} is out of bounds of the mesh position buffer`), false;
    } else if (r30 % 3 != 0)
      return this.logger.warn("Mesh position buffer length must be a multiple of 9 if no component faces are defined (3 values per vertex * 3 vertices per triangle)"), false;
    return true;
  }
  _getOrCreateFaces(e31, t24) {
    return t24.faces ? t24.faces : u12(e31.vertexAttributes.position.length / 3);
  }
  _isOutsideClippingArea(e31) {
    if (!this._context.clippingExtent)
      return false;
    const r30 = e31.vertexAttributes && e31.vertexAttributes.position;
    if (!r30)
      return false;
    const a29 = this._context.elevationProvider.spatialReference;
    let o24;
    const s23 = r30.length / 3;
    return r(a29) && !e31.spatialReference.equals(a29) ? (o24 = new Float64Array(r30.length), xn(e31.vertexAttributes.position, e31.spatialReference, 0, o24, a29, 0, s23)) : o24 = r30, A2(ye2), M3(ye2, o24, 0, s23), !R2(ye2, this._context.clippingExtent);
  }
  _createGeometryInfo(e31, a29, o24) {
    if (!An(e31.spatialReference, this._context.graphicsCoreOwner.view.spatialReference))
      return this.logger.warn("Geometry spatial reference is not compatible with the view"), null;
    if (this._isOutsideClippingArea(e31))
      return null;
    const s23 = this._createBuffers(e31, a29);
    if (t(s23))
      return null;
    const { positionBuffer: n26, uvBuffer: i23, colorBuffer: l32, symbolColorBuffer: u33, normalBuffer: c31, tangentBuffer: m19, objectTransformation: h25, geometryTransformation: f25 } = s23, p21 = this._getOrCreateComponents(e31), d27 = [], g21 = [], x20 = [];
    let _20 = false;
    for (const r30 of p21) {
      if (!this._validateFaces(e31, r30))
        return null;
      const a30 = this._getOrCreateFaces(e31, r30);
      if (0 === a30.length)
        continue;
      const s24 = this._createComponentNormals(n26, c31, r30, a30);
      s24.didFlipNormals && (_20 = true);
      const h26 = [[O2.POSITION, { size: 3, data: n26, exclusive: true }], [O2.NORMAL, { size: 3, data: s24.normals, exclusive: true }]], p22 = [[O2.POSITION, a30], [O2.NORMAL, s24.indices]];
      r(l32) && (h26.push([O2.COLOR, { size: 4, data: l32, exclusive: true }]), p22.push([O2.COLOR, a30])), r(u33) && (h26.push([O2.SYMBOLCOLOR, { size: 4, data: u33, exclusive: true }]), p22.push([O2.SYMBOLCOLOR, new Array(a30.length).fill(0)])), r(i23) && (h26.push([O2.UV0, { size: 2, data: i23, exclusive: true }]), p22.push([O2.UV0, a30])), r(m19) && (h26.push([O2.TANGENT, { size: 4, data: m19, exclusive: true }]), p22.push([O2.TANGENT, a30]));
      const T9 = this._context.stage.renderView._getObjectAndLayerIdColor({ graphicUid: o24, layerUid: this._context.layer.uid }), y17 = new d8(h26, p22, a11.Triangle, T9);
      d27.push(y17), g21.push(f25), x20.push(this._getOrCreateMaterial(e31, r30));
    }
    return _20 && this.logger.warn("Normals have been automatically flipped to be consistent with the counter clock wise face winding order. It is better to generate mesh geometries that have consistent normals."), { geometries: d27, transformations: g21, materials: x20, objectTransformation: h25 };
  }
  _createEdgeMaterial() {
    const e31 = { opacity: this._getLayerOpacity() };
    return f7(this.symbolLayer, e31);
  }
};
var fe2 = n2();
var pe3 = n2();
var de3 = n2();
var ge2 = n2();
var xe = n2();
var _e3 = e9();
var Te = e8();
var ye2 = a6();
var be2 = [new g5()];
var ve;
!function(e31) {
  e31[e31.NONE = 0] = "NONE", e31[e31.ECEF = 1] = "ECEF";
}(ve || (ve = {}));

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DLodInstanceGraphicLayer.js
var f21 = class {
  constructor(e31, t24, i23, n26) {
    this.graphics3DSymbolLayer = e31, this.instanceIndex = t24, this.elevationAligner = i23, this.elevationContext = n26, this.type = "lod-instance", this._highlights = /* @__PURE__ */ new Set(), this.alignedSampledElevation = 0, this.isElevationSource = false, this.needsElevationUpdates = false;
  }
  initialize() {
  }
  setVisibility(e31) {
    const t24 = this._lodRenderer.instanceData;
    e31 !== t24.getVisible(this.instanceIndex) && t24.setVisible(this.instanceIndex, e31);
  }
  destroy() {
    null != this.instanceIndex && (this._lodRenderer.instanceData.removeInstance(this.instanceIndex), this.graphics3DSymbolLayer.notifyDestroyGraphicLayer(this));
  }
  alignWithElevation(t24, i23, n26) {
    if (this.elevationAligner) {
      i13(this.elevationContext.featureExpressionInfoContext, n26);
      const s23 = this.elevationAligner(this, this.elevationContext, t24, i23);
      r(s23) && (this.alignedSampledElevation = s23);
    }
  }
  getCenterObjectSpace(e31 = n2()) {
    return this._lodRenderer.instanceData.getCombinedLocalTransform(this.instanceIndex, I8), O(e31, this._lodRenderer.baseBoundingSphere.center, I8);
  }
  getBoundingBoxObjectSpace(e31 = a6()) {
    this._lodRenderer.instanceData.getCombinedLocalTransform(this.instanceIndex, I8);
    const t24 = this._lodRenderer.baseBoundingBox;
    A2(e31);
    for (let s23 = 0; s23 < 8; ++s23)
      o2(x13, 0 == (1 & s23) ? t24[0] : t24[3], 0 == (2 & s23) ? t24[1] : t24[4], 0 == (4 & s23) ? t24[2] : t24[5]), O(x13, x13, I8), c6(e31, x13);
    return e31;
  }
  computeAttachmentOrigin(e31) {
    this._lodRenderer.instanceData.getGlobalTransform(this.instanceIndex, I8), e31.render.origin[0] += I8[12], e31.render.origin[1] += I8[13], e31.render.origin[2] += I8[14], e31.render.num++;
  }
  async getProjectedBoundingBox(t24, n26, s23, r30, o24) {
    const d27 = this.getBoundingBoxObjectSpace(o24), m19 = v17, u33 = P2(d27) ? 1 : m19.length;
    this._lodRenderer.instanceData.getGlobalTransform(this.instanceIndex, I8);
    for (let e31 = 0; e31 < u33; e31++) {
      const t25 = m19[e31];
      x13[0] = d27[t25[0]], x13[1] = d27[t25[1]], x13[2] = d27[t25[2]], O(x13, x13, I8), p16[3 * e31 + 0] = x13[0], p16[3 * e31 + 1] = x13[1], p16[3 * e31 + 2] = x13[2];
    }
    if (!t24(p16, 0, u33))
      return null;
    A2(d27);
    let f25 = null;
    this.calculateRelativeScreenBounds && (f25 = this.calculateRelativeScreenBounds());
    for (let e31 = 0; e31 < 3 * u33; e31 += 3) {
      for (let t25 = 0; t25 < 3; t25++)
        d27[t25] = Math.min(d27[t25], p16[e31 + t25]), d27[t25 + 3] = Math.max(d27[t25 + 3], p16[e31 + t25]);
      f25 && s23.push({ location: p16.slice(e31, e31 + 3), screenSpaceBoundingRect: f25 });
    }
    if (n26 && (p4(d27, b20), "absolute-height" !== this.elevationContext.mode)) {
      let t25;
      const i23 = X(d27, n26.service.spatialReference, n26);
      try {
        t25 = await n26.service.queryElevation(b20[0], b20[1], r30, i23, "ground");
      } catch (_20) {
      }
      r(t25) && V(d27, 0, 0, -this.alignedSampledElevation + t25);
    }
    return d27;
  }
  addObjectState(e31, t24) {
    if (e31 === u13.Highlight) {
      const i23 = new r15(e31);
      this._addHighlightId(i23), t24.addExternal((e32) => {
        this._removeHighlightId(e32);
      }, i23);
    }
  }
  removeObjectState(e31) {
    this._highlights.forEach((t24) => e31.remove(t24));
  }
  _addHighlightId(e31) {
    this._highlights.add(e31), this._lodRenderer.instanceData.setHighlight(this.instanceIndex, true);
  }
  _removeHighlightId(e31) {
    this._highlights.delete(e31), this._lodRenderer.instanceData.setHighlight(this.instanceIndex, this._highlights.size > 0);
  }
  get _lodRenderer() {
    return this.graphics3DSymbolLayer.lodRenderer;
  }
};
var p16 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
var x13 = n2();
var b20 = n2();
var v17 = [[0, 1, 2], [3, 1, 2], [0, 4, 2], [3, 4, 2], [0, 1, 5], [3, 1, 5], [0, 4, 5], [3, 4, 5]];
var I8 = e9();

// node_modules/@arcgis/core/views/3d/layers/graphics/lodResourceUtils.js
function t19(s23) {
  const t24 = [];
  return s23.stageResources.geometries.forEach((e31, o24) => {
    const r30 = s23.stageResources.materials[o24], n26 = s23.stageResources.textures;
    t24.push({ material: r30, geometry: e31, textures: n26 });
  }), { components: t24, minScreenSpaceRadius: r(s23.lodThreshold) ? s23.lodThreshold : 0, pivotOffset: s23.pivotOffset };
}
function o21(e31) {
  return { levels: e31.map((e32) => t19(e32)) };
}
function r24(e31, t24 = c26) {
  const o24 = c21(e31);
  return Math.sqrt(o24 / (t24 * Math.PI));
}
function n21(e31) {
  e31.levels.forEach((e32) => {
    e32.minScreenSpaceRadius || (e32.minScreenSpaceRadius = r24(e32));
  });
}
var c26 = 0.05;

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/lodRendering/InstanceData.js
var O10;
function F8(t24) {
  let e31 = T2().mat4f64(O2.LOCALTRANSFORM).mat4f64(O2.GLOBALTRANSFORM).vec4f64(O2.BOUNDINGSPHERE).vec3f64(O2.MODELORIGIN).mat3f(O2.MODEL).mat3f(O2.MODELNORMAL).vec2f(O2.MODELSCALEFACTORS);
  return t24.includes("color") && (e31 = e31.vec4f(O2.COLOR)), t24.includes("featureAttribute") && (e31 = e31.vec4f(O2.FEATUREATTRIBUTE)), e31 = e31.u8(O2.STATE).u8(O2.LODLEVEL), t24.includes(O2.OBJECTANDLAYERIDCOLOR) && (e31 = e31.vec4u8(O2.OBJECTANDLAYERIDCOLOR)), e31.alignTo(8), e31;
}
!function(t24) {
  t24[t24.ALLOCATED = 1] = "ALLOCATED", t24[t24.DEFAULT_ACTIVE = 2] = "DEFAULT_ACTIVE", t24[t24.VISIBLE = 4] = "VISIBLE", t24[t24.HIGHLIGHT = 8] = "HIGHLIGHT", t24[t24.HIGHLIGHT_ACTIVE = 16] = "HIGHLIGHT_ACTIVE", t24[t24.REMOVE = 32] = "REMOVE", t24[t24.TRANSFORM_CHANGED = 64] = "TRANSFORM_CHANGED", t24[t24.ACTIVE = 18] = "ACTIVE";
}(O10 || (O10 = {}));
var v18 = class {
  constructor(t24) {
    this.localTransform = t24.getField(O2.LOCALTRANSFORM, b8), this.globalTransform = t24.getField(O2.GLOBALTRANSFORM, b8), this.modelOrigin = t24.getField(O2.MODELORIGIN, T), this.model = t24.getField(O2.MODEL, l12), this.modelNormal = t24.getField(O2.MODELNORMAL, l12), this.modelScaleFactors = t24.getField(O2.MODELSCALEFACTORS, u10), this.boundingSphere = t24.getField(O2.BOUNDINGSPHERE, h8), this.color = t24.getField(O2.COLOR, c11), this.featureAttribute = t24.getField(O2.FEATUREATTRIBUTE, c11), this.state = t24.getField(O2.STATE, d7), this.lodLevel = t24.getField(O2.LODLEVEL, d7), this.objectAndLayerIdColor = t24.getField(O2.OBJECTANDLAYERIDCOLOR, x4);
  }
};
var M8 = class extends n6 {
  constructor(t24, e31) {
    super(), this._capacity = 0, this._size = 0, this._next = 0, this._buffer = null, this._view = null, this._layout = F8(t24), this._shaderTransformation = e31;
  }
  get capacity() {
    return this._capacity;
  }
  get size() {
    return this._size;
  }
  get buffer() {
    return this._buffer.buffer;
  }
  get view() {
    return this._view;
  }
  addInstance() {
    this._size + 1 > this._capacity && this._grow();
    const t24 = this._findSlot();
    return this._view.state.set(t24, O10.ALLOCATED), this._size++, this.emit("instance-added", { index: t24 }), t24;
  }
  removeInstance(t24) {
    const e31 = this._view.state;
    e11(t24 >= 0 && t24 < this._capacity && e31.get(t24) & O10.ALLOCATED, "invalid instance handle"), this._getStateFlag(t24, O10.ACTIVE) ? this._setStateFlags(t24, O10.REMOVE) : this.freeInstance(t24), this.emit("instance-removed", { index: t24 });
  }
  freeInstance(t24) {
    const e31 = this._view.state;
    e11(t24 >= 0 && t24 < this._capacity && e31.get(t24) & O10.ALLOCATED, "invalid instance handle"), e31.set(t24, 0), this._size--;
  }
  setLocalTransform(t24, e31, s23 = true) {
    this._view.localTransform.setMat(t24, e31), s23 && this.updateModelTransform(t24);
  }
  getLocalTransform(t24, e31) {
    this._view.localTransform.getMat(t24, e31);
  }
  setGlobalTransform(t24, e31, s23 = true) {
    this._view.globalTransform.setMat(t24, e31), s23 && this.updateModelTransform(t24);
  }
  getGlobalTransform(t24, e31) {
    this._view.globalTransform.getMat(t24, e31);
  }
  updateModelTransform(t24) {
    const a29 = this._view, o24 = C10, h25 = b21;
    a29.localTransform.getMat(t24, R11), a29.globalTransform.getMat(t24, w10);
    const l32 = u7(w10, w10, R11);
    o2(o24, l32[12], l32[13], l32[14]), a29.modelOrigin.setVec(t24, o24), a9(h25, l32), a29.model.setMat(t24, h25);
    const c31 = p6(C10, l32);
    c31.sort(), a29.modelScaleFactors.set(t24, 0, c31[1]), a29.modelScaleFactors.set(t24, 1, c31[2]), u11(h25, h25), o5(h25, h25), a29.modelNormal.setMat(t24, h25), this._setStateFlags(t24, O10.TRANSFORM_CHANGED), this.emit("instance-transform-changed", { index: t24 });
  }
  getModelTransform(t24, e31) {
    const s23 = this._view;
    s23.model.getMat(t24, b21), s23.modelOrigin.getVec(t24, C10), e31[0] = b21[0], e31[1] = b21[1], e31[2] = b21[2], e31[3] = 0, e31[4] = b21[3], e31[5] = b21[4], e31[6] = b21[5], e31[7] = 0, e31[8] = b21[6], e31[9] = b21[7], e31[10] = b21[8], e31[11] = 0, e31[12] = C10[0], e31[13] = C10[1], e31[14] = C10[2], e31[15] = 1;
  }
  applyShaderTransformation(t24, e31) {
    this._shaderTransformation && this._shaderTransformation.applyTransform(this, t24, e31);
  }
  getCombinedModelTransform(t24, e31) {
    return this.getModelTransform(t24, e31), this._shaderTransformation && this._shaderTransformation.applyTransform(this, t24, e31), e31;
  }
  getCombinedLocalTransform(t24, e31) {
    return this._view.localTransform.getMat(t24, e31), this._shaderTransformation && this._shaderTransformation.applyTransform(this, t24, e31), e31;
  }
  getCombinedMaxScaleFactor(t24) {
    let e31 = this._view.modelScaleFactors.get(t24, 1);
    if (this._shaderTransformation) {
      const s23 = this._shaderTransformation.scaleFactor(C10, this, t24);
      e31 *= Math.max(s23[0], s23[1], s23[2]);
    }
    return e31;
  }
  getCombinedMedianScaleFactor(t24) {
    let e31 = this._view.modelScaleFactors.get(t24, 0);
    if (this._shaderTransformation) {
      const s23 = this._shaderTransformation.scaleFactor(C10, this, t24);
      e31 *= I9(s23[0], s23[1], s23[2]);
    }
    return e31;
  }
  getModel(t24, e31) {
    this._view.model.getMat(t24, e31);
  }
  setFeatureAttribute(t24, e31) {
    this._view.featureAttribute.setVec(t24, e31);
  }
  getFeatureAttribute(t24, e31) {
    this._view.featureAttribute.getVec(t24, e31);
  }
  setColor(t24, e31) {
    this._view.color.setVec(t24, e31);
  }
  setObjectAndLayerIdColor(t24, e31) {
    this._view.objectAndLayerIdColor.setVec(t24, e31);
  }
  getColor(t24, e31) {
    this._view.color.getVec(t24, e31);
  }
  setVisible(t24, e31) {
    e31 !== this.getVisible(t24) && (this._setStateFlag(t24, O10.VISIBLE, e31), this.emit("instance-visibility-changed", { index: t24 }));
  }
  getVisible(t24) {
    return this._getStateFlag(t24, O10.VISIBLE);
  }
  setHighlight(t24, e31) {
    e31 !== this.getHighlight(t24) && (this._setStateFlag(t24, O10.HIGHLIGHT, e31), this.emit("instance-highlight-changed", { index: t24 }));
  }
  getHighlight(t24) {
    return this._getStateFlag(t24, O10.HIGHLIGHT);
  }
  getState(t24) {
    return this._view.state.get(t24);
  }
  getLodLevel(t24) {
    return this._view.lodLevel.get(t24);
  }
  countFlags(t24) {
    let e31 = 0;
    for (let s23 = 0; s23 < this._capacity; ++s23) {
      this.getState(s23) & t24 && ++e31;
    }
    return e31;
  }
  _setStateFlags(t24, e31) {
    const s23 = this._view.state;
    e31 = s23.get(t24) | e31, s23.set(t24, e31);
  }
  _clearStateFlags(t24, e31) {
    const s23 = this._view.state;
    e31 = s23.get(t24) & ~e31, s23.set(t24, e31);
  }
  _setStateFlag(t24, e31, s23) {
    s23 ? this._setStateFlags(t24, e31) : this._clearStateFlags(t24, e31);
  }
  _getStateFlag(t24, e31) {
    return !!(this._view.state.get(t24) & e31);
  }
  _grow() {
    const t24 = Math.max(S14, Math.floor(this._capacity * p17)), e31 = this._layout.createBuffer(t24);
    if (this._buffer) {
      const t25 = new Uint8Array(this._buffer.buffer);
      new Uint8Array(e31.buffer).set(t25);
    }
    this._capacity = t24, this._buffer = e31, this._view = new v18(this._buffer);
  }
  _findSlot() {
    const t24 = this._view.state;
    let e31 = this._next;
    for (; t24.get(e31) & O10.ALLOCATED; )
      e31 = e31 + 1 === this._capacity ? 0 : e31 + 1;
    return this._next = e31 + 1 === this._capacity ? 0 : e31 + 1, e31;
  }
};
function I9(t24, e31, s23) {
  return Math.max(Math.min(t24, e31), Math.min(Math.max(t24, e31), s23));
}
var S14 = 1024;
var p17 = 2;
var C10 = n2();
var b21 = e8();
var R11 = e9();
var w10 = e9();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/lodRendering/InstanceOctree.js
var n22 = class extends G3 {
  constructor(e31, r30) {
    super((t24) => w7(this._instanceData.view.boundingSphere.getVec(t24, this._tmpSphere)), { maximumDepth: 25 }), this._tmpSphere = R5(), this._tmpMat4 = e9(), this._instanceData = e31, this._boundingSphere = r30;
  }
  addInstance(t24) {
    const s23 = this._instanceData.view.boundingSphere, i23 = this._instanceData.getCombinedModelTransform(t24, this._tmpMat4);
    O(this._tmpSphere, this._boundingSphere.center, i23), this._tmpSphere[3] = this._boundingSphere.radius * l15(i23), s23.setVec(t24, this._tmpSphere), this.add([t24]);
  }
  removeInstance(t24) {
    this.remove([t24]);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/lodRendering/LevelSelector.js
var t20 = class {
  constructor(t24, s23) {
    this.thresholdScale = 1, this._camera = new J3(), this._worldSpaceRadius = t24, this._thresholds = s23.map((e31) => e31);
  }
  updateCamera(e31) {
    this._camera.copyFrom(e31);
  }
  selectLevel(e31, t24) {
    const s23 = this._camera.computeScreenPixelSizeAt(e31), r30 = this._worldSpaceRadius * t24 / s23, a29 = this._thresholds;
    let h25 = -1;
    for (let o24 = 0; o24 < a29.length; ++o24)
      r30 >= a29[o24] * this.thresholdScale && (h25 = o24);
    return h25;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/lodRendering/LodComponentData.js
var m16 = class {
  constructor(s23, o24) {
    const i23 = s23.renderContext.rctx, { geometry: m19, material: u33 } = o24;
    this._materialRepository = s23.materialRep, u33.setParameters({ instancedDoublePrecision: true });
    const f25 = u33.createBufferWriter(), d27 = f25.vertexBufferLayout, p21 = f25.elementCount(m19), c31 = f25.allocate(p21);
    f25.write(null, null, m19, c31, 0), this.geometry = m19, this.material = u33, this.glMaterials = new e18(u33, this._materialRepository), this.vertexBufferLayout = d27, this.vbo = E6.createVertex(i23, F3.STATIC_DRAW, c31.buffer), this.vao = new r14(i23, E5, { geometry: o13(d27) }, { geometry: this.vbo }), this.vertexCount = p21;
  }
  destroy() {
    this.glMaterials.destroy(), this.vbo.dispose(), this.vao.dispose();
  }
  get boundingInfo() {
    return this.geometry.boundingInfo;
  }
  get triangleCount() {
    return this.vertexCount / 3;
  }
  intersect(r30, t24, e31, a29, n26, l32, m19, u33) {
    const f25 = this.geometry.id;
    this.material.intersect(this.geometry, null, r30.transform.transform, r30, e31, a29, (e32, a30, d27, p21, c31) => {
      if (e32 >= 0) {
        if (null != t24 && !t24(r30.rayBegin, r30.rayEnd, e32))
          return;
        const p22 = { layerUid: l32.layerUid, graphicUid: l32.graphicUid(n26), geometryId: f25, triangleNr: d27, baseBoundingSphere: m19, numLodLevels: u33 };
        if ((null == r30.results.min.drapedLayerOrder || c31 >= r30.results.min.drapedLayerOrder) && (null == r30.results.min.dist || e32 < r30.results.min.dist) && r30.results.min.set(i14.LOD, p22, e32, a30, r30.transform.transform, c31), r30.options.store !== t16.MIN && (null == r30.results.max.drapedLayerOrder || c31 >= r30.results.max.drapedLayerOrder) && (null == r30.results.max.dist || e32 > r30.results.max.dist) && r30.results.max.set(i14.LOD, p22, e32, a30, r30.transform.transform, c31), r30.options.store === t16.ALL) {
          const t25 = U5(r30.results.min.ray);
          t25.set(i14.LOD, p22, e32, a30, r30.transform.transform, c31), r30.results.all.push(t25);
        }
      }
    });
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/lodRendering/LodLevel.js
var h21 = class {
  constructor(n26, o24) {
    this.minScreenSpaceRadius = n26, this.components = o24;
  }
  static async create(n26, o24, i23) {
    const r30 = await Promise.allSettled(o24.components.map((o25) => n26.schedule(() => new m16(n26, o25), i23))), s23 = r30.map((n27) => "fulfilled" === n27.status ? n27.value : null).filter((n27) => n27);
    if (p2(i23) || s23.length !== r30.length) {
      s23.forEach((n27) => n27.destroy()), f2(i23);
      for (const n27 of r30)
        if ("rejected" === n27.status)
          throw n27.reason;
    }
    return new h21(o24.minScreenSpaceRadius, s23);
  }
  destroy() {
    this.components.forEach((n26) => n26.destroy());
  }
  intersect(n26, o24, t24, e31, i23, r30, s23) {
    this.components.forEach((c31) => c31.intersect(n26, o24, t24, e31, i23, r30, this.boundingSphere, s23));
  }
  get boundingBox() {
    if (t(this._boundingBox)) {
      const n26 = A2();
      this.components.forEach((t24) => {
        r(t24.boundingInfo) && (c6(n26, t24.boundingInfo.bbMin), c6(n26, t24.boundingInfo.bbMax));
      }), this._boundingBox = n26;
    }
    return this._boundingBox;
  }
  get boundingSphere() {
    if (t(this._boundingSphere)) {
      const n26 = this.boundingBox, o24 = n2();
      p4(n26, o24), this._boundingSphere = { center: o24, radius: 0.5 * g3(n26) };
    }
    return this._boundingSphere;
  }
  get triangleCount() {
    return this.components.reduce((n26, o24) => n26 + o24.triangleCount, 0);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/lodRendering/BackedBufferObject.js
var r25 = class {
  constructor(r30, i23, s23) {
    this._elementSize = i23, this._buffer = E6.createVertex(r30, F3.STATIC_DRAW), this.resize(s23);
  }
  destroy() {
    this._buffer.dispose();
  }
  get elementSize() {
    return this._elementSize;
  }
  get capacity() {
    return this._capacity;
  }
  get array() {
    return this._array;
  }
  get buffer() {
    return this._buffer;
  }
  get memoryUsage() {
    return { cpu: this._capacity * this._elementSize, gpu: this._capacity * this._elementSize };
  }
  copyRange(e31, t24, r30, i23 = 0) {
    const s23 = new Uint8Array(this.array, e31 * this.elementSize, (t24 - e31) * this.elementSize);
    new Uint8Array(r30.array, i23 * this.elementSize).set(s23);
  }
  transferAll() {
    this._buffer.setData(this._array);
  }
  transferRange(e31, t24) {
    const r30 = e31 * this._elementSize, i23 = t24 * this._elementSize;
    this._buffer.setSubData(new Uint8Array(this._array), r30, r30, i23);
  }
  resize(e31) {
    const t24 = e31 * this._elementSize, r30 = new ArrayBuffer(t24);
    this._array && (e31 >= this._capacity ? new Uint8Array(r30).set(new Uint8Array(this._array)) : new Uint8Array(r30).set(new Uint8Array(this._array).subarray(0, e31 * this._elementSize))), this._array = r30, this._buffer.setSize(t24), this._capacity = e31;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/lodRendering/RenderInstanceData.js
var n23 = class {
  constructor(a29) {
    this.modelOriginHi = a29.getField(O2.MODELORIGINHI, i5), this.modelOriginLo = a29.getField(O2.MODELORIGINLO, i5), this.model = a29.getField(O2.MODEL, l12), this.modelNormal = a29.getField(O2.MODELNORMAL, l12), this.color = a29.getField(O2.INSTANCECOLOR, c11), this.featureAttribute = a29.getField(O2.INSTANCEFEATUREATTRIBUTE, c11), this.objectAndLayerIdColor = a29.getField(O2.OBJECTANDLAYERIDCOLOR_INSTANCED, x4);
  }
};
var d19 = class {
  constructor(t24, i23) {
    this._headIndex = 0, this._tailIndex = 0, this._firstIndex = null, this._captureFirstIndex = true, this._updating = false, this._prevHeadIndex = 0, this._resized = false, this._rctx = t24, this._instanceBufferLayout = i23, this._elementSize = i23.stride, this._capacity = 1;
  }
  destroy() {
    this._buffer && this._buffer.destroy();
  }
  get buffer() {
    return this._buffer.buffer;
  }
  get view() {
    return this._view;
  }
  get capacity() {
    return this._capacity;
  }
  get size() {
    const t24 = this._headIndex, i23 = this._tailIndex;
    return t24 >= i23 ? t24 - i23 : t24 + this._capacity - i23;
  }
  get isEmpty() {
    return this._headIndex === this._tailIndex;
  }
  get isFull() {
    return this._tailIndex === (this._headIndex + 1) % this._capacity;
  }
  get headIndex() {
    return this._headIndex;
  }
  get tailIndex() {
    return this._tailIndex;
  }
  get firstIndex() {
    return this._firstIndex;
  }
  get memoryUsage() {
    return this._buffer ? this._buffer.memoryUsage : { cpu: 0, gpu: 0 };
  }
  reset() {
    this._headIndex = 0, this._tailIndex = 0, this._firstIndex = null;
  }
  startUpdateCylce() {
    this._captureFirstIndex = true;
  }
  beginUpdate() {
    e11(!this._updating, "already updating"), this._updating = true, this._prevHeadIndex = this._headIndex;
  }
  endUpdate() {
    e11(this._updating, "not updating"), this.size < f22 * this.capacity && this._shrink(), this._resized ? (this._buffer.transferAll(), this._resized = false) : this._transferRange(this._prevHeadIndex, this._headIndex), this._updating = false;
  }
  allocateHead() {
    e11(this._updating, "not updating"), this.isFull && this._grow();
    const t24 = this.headIndex;
    return this._captureFirstIndex && (this._firstIndex = t24, this._captureFirstIndex = false), this._incrementHead(), e11(this._headIndex !== this._tailIndex, "invalid pointers"), t24;
  }
  freeTail() {
    e11(this._updating, "not updating"), e11(this.size > 0, "invalid size");
    const t24 = this._tailIndex === this._firstIndex;
    this._incrementTail(), t24 && (this._firstIndex = this._tailIndex);
  }
  _grow() {
    const t24 = Math.max(_13, Math.floor(this._capacity * c27));
    this._resize(t24);
  }
  _shrink() {
    const t24 = Math.max(_13, Math.floor(this._capacity * u27));
    this._resize(t24);
  }
  _resize(t24) {
    if (e11(this._updating, "not updating"), t24 === this._capacity)
      return;
    const i23 = new r25(this._rctx, this._elementSize, t24);
    if (this._buffer) {
      this._firstIndex && (this._firstIndex = (this._firstIndex + this._capacity - this._tailIndex) % this._capacity);
      const t25 = this.size, e31 = this._compactInstances(i23);
      e11(e31 === t25, "invalid compaction"), this._buffer.destroy(), this._tailIndex = 0, this._headIndex = e31, this._prevHeadIndex = 0;
    }
    this._resized = true, this._capacity = t24, this._buffer = i23, this._view = new n23(this._instanceBufferLayout.createView(this._buffer.array));
  }
  _compactInstances(t24) {
    const i23 = this._headIndex, e31 = this._tailIndex;
    return e31 < i23 ? (this._buffer.copyRange(e31, i23, t24), i23 - e31) : e31 > i23 ? (this._buffer.copyRange(e31, this._capacity, t24), i23 > 0 && this._buffer.copyRange(0, i23, t24, this._capacity - e31), i23 + (this._capacity - e31)) : 0;
  }
  _incrementHead(t24 = 1) {
    this._headIndex = (this._headIndex + t24) % this._capacity;
  }
  _incrementTail(t24 = 1) {
    this._tailIndex = (this._tailIndex + t24) % this._capacity;
  }
  _transferRange(t24, i23) {
    t24 < i23 ? this._buffer.transferRange(t24, i23) : t24 > i23 && (i23 > 0 && this._buffer.transferRange(0, i23), this._buffer.transferRange(t24, this._capacity));
  }
};
var _13 = 1024;
var c27 = 2;
var f22 = 0.3;
var u27 = 0.5;

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/lodRendering/LodRenderer.js
var x14 = (e31) => {
  const t24 = e31.baseBoundingSphere.radius, a29 = e31.levels.map((e32) => e32.minScreenSpaceRadius);
  return new t20(t24, a29);
};
var M9 = class {
  constructor(e31, t24, a29, s23) {
    this.type = i14.LOD, this.isGround = false, this._levels = [], this._defaultRenderInstanceData = [], this._highlightRenderInstanceData = [], this._instanceIndex = 0, this._slicePlane = false, this._lastCamera = new J3(), this._updateCyclesWithStaticCamera = -1, this._needFullCycle = false, this.slots = [E8.OPAQUE_MATERIAL, E8.TRANSPARENT_MATERIAL], this.canRender = true, this._symbol = e31, this._optionalFields = t24, this._metadata = a29, this._instanceBufferLayout = B3({ instancedDoublePrecision: true, instanced: t24 }), this._glInstanceBufferLayout = o13(this._instanceBufferLayout, 1), this._instanceData = new M8(this._optionalFields, s23), this._instanceData.on("instance-added", () => this._requestUpdateCycle()), this._instanceData.on("instance-removed", () => this._requestUpdateCycle()), this._instanceData.on("instance-transform-changed", (e32) => {
      this._requestUpdateCycle(), this._metadata.notifyGraphicGeometryChanged(e32.index);
    }), this._instanceData.on("instance-visibility-changed", (e32) => {
      this._requestUpdateCycle(true), this._metadata.notifyGraphicVisibilityChanged(e32.index);
    }), this._instanceData.on("instance-highlight-changed", () => this._requestUpdateCycle(true)), this._enableLevelSelection = this._symbol.levels.length > 1;
  }
  get levels() {
    return this._levels;
  }
  get baseBoundingBox() {
    return this._levels[this._levels.length - 1].boundingBox;
  }
  get baseBoundingSphere() {
    return this._levels[this._levels.length - 1].boundingSphere;
  }
  get baseMaterial() {
    return this._levels[this._levels.length - 1].components[0].material;
  }
  get slicePlaneEnabled() {
    return this._slicePlane;
  }
  set slicePlaneEnabled(e31) {
    this._slicePlane = e31;
  }
  get layerUid() {
    return this._metadata.layerUid;
  }
  get instanceData() {
    return this._instanceData;
  }
  get memoryUsage() {
    const e31 = { cpu: 0, gpu: 0 };
    return this._defaultRenderInstanceData.forEach((t24) => {
      const a29 = t24.memoryUsage;
      e31.cpu += a29.cpu, e31.gpu += a29.gpu;
    }), this._highlightRenderInstanceData.forEach((t24) => {
      const a29 = t24.memoryUsage;
      e31.cpu += a29.cpu, e31.gpu += a29.gpu;
    }), e31;
  }
  get renderStats() {
    const e31 = this._instanceData.size, t24 = [];
    return this._levels.forEach((e32, a29) => {
      const s23 = this._defaultRenderInstanceData[a29], n26 = this._highlightRenderInstanceData[a29], i23 = s23.size + n26.size, r30 = e32.triangleCount;
      t24.push({ renderedInstances: i23, renderedTriangles: i23 * r30, trianglesPerInstance: r30 });
    }), { totalInstances: e31, renderedInstances: t24.reduce((e32, t25) => e32 + t25.renderedInstances, 0), renderedTriangles: t24.reduce((e32, t25) => e32 + t25.renderedTriangles, 0), levels: t24 };
  }
  async initializeRenderContext(e31, t24) {
    this._context = e31;
    const a29 = e31.renderContext.rctx, i23 = await Promise.allSettled(this._symbol.levels.map((s23) => (this._defaultRenderInstanceData.push(new d19(a29, this._instanceBufferLayout)), this._highlightRenderInstanceData.push(new d19(a29, this._instanceBufferLayout)), h21.create(e31, s23, t24)))), r30 = i23.map((e32) => "fulfilled" === e32.status ? e32.value : null).filter((e32) => e32);
    if (p2(t24) || r30.length !== i23.length) {
      r30.forEach((e32) => e32.destroy()), f2(t24);
      for (const e32 of i23)
        if ("rejected" === e32.status)
          throw e32.reason;
    }
    this._levels = r30, this._levelSelector = x14(this);
  }
  uninitializeRenderContext() {
    this._invalidateOctree(), this._levels.forEach((e31) => e31.destroy()), this._defaultRenderInstanceData.forEach((e31) => e31.destroy()), this._highlightRenderInstanceData.forEach((e31) => e31.destroy());
  }
  get needsTransparentPass() {
    return this._levels.some((e31) => e31.components.some((e32) => e32.material.requiresSlot(E8.TRANSPARENT_MATERIAL, h9.Color)));
  }
  get needsHighlight() {
    return this._highlightRenderInstanceData.some((e31) => e31.size > 0);
  }
  prepareRender(e31) {
    if (t14.LOD_INSTANCE_RENDERER_DISABLE_UPDATES)
      return;
    if (this._enableLevelSelection) {
      const t25 = e31.bindParameters.contentCamera.equals(this._lastCamera);
      this._lastCamera.copyFrom(e31.bindParameters.contentCamera), t25 || this._requestUpdateCycle();
    }
    const t24 = this._needFullCycle ? this._instanceData.size : 2e3;
    this._needFullCycle = false, this._updateInstances(e31.bindParameters.contentCamera, t24), this._needsUpdates && this._context.requestRender();
  }
  render(e31) {
    if (!this.baseMaterial.isVisible() || !this.baseMaterial.isVisibleForOutput(e31.output))
      return;
    e31.rctx.bindVAO();
    e31.output !== h9.Highlight && e31.output !== h9.ShadowHighlight && this._renderComponents(e31, this._defaultRenderInstanceData);
    e31.output !== h9.ShadowExludeHighlight && this._renderComponents(e31, this._highlightRenderInstanceData);
  }
  intersect(e31, t24, a29, s23) {
    if (!this.baseMaterial.isVisible())
      return;
    const n26 = n2();
    e3(n26, s23, a29);
    const i23 = (n27) => {
      this._instanceData.getCombinedModelTransform(n27, q8), e31.transform.set(q8), O(H3, a29, e31.transform.inverse), O(B7, s23, e31.transform.inverse);
      const i24 = this._instanceData.getState(n27), r30 = this._instanceData.getLodLevel(n27), o24 = this._levels.length;
      e11(i24 & O10.ACTIVE, "invalid instance state"), e11(r30 >= 0 && r30 < o24, "invaid lod level"), this._levels[r30].intersect(e31, t24, H3, B7, n27, this._metadata, o24);
    };
    this.baseMaterial.parameters.verticalOffset ? this._octree.forEach(i23) : this._octree.forEachAlongRay(a29, n26, i23);
  }
  queryDepthRange(e31) {
    return this._queryDepthRangeOctree(e31);
  }
  notifyShaderTransformationChanged() {
    this._invalidateOctree();
  }
  _requestUpdateCycle(e31 = false) {
    this._updateCyclesWithStaticCamera = -1, e31 && (this._needFullCycle = true), this._needsUpdates && this._context.requestRender();
  }
  get _needsUpdates() {
    return this._instanceData.size > 0 && this._updateCyclesWithStaticCamera < 1;
  }
  get _octree() {
    return t(this._octreeCached) && (this._octreeCached = this._buildOctree()), this._octreeCached;
  }
  _invalidateOctree() {
    this._octreeCached = s(this._octreeCached);
  }
  _buildOctree() {
    const e31 = new n22(this._instanceData, this.baseBoundingSphere), t24 = this._instanceData, a29 = t24.view ? t24.view.state : null;
    for (let s23 = 0; s23 < this._instanceData.capacity; ++s23) {
      a29.get(s23) & O10.ACTIVE && e31.addInstance(s23);
    }
    return e31;
  }
  _queryDepthRangeOctree(e31) {
    const t24 = e31.eye, a29 = e31.viewForward, s23 = this._octree.findClosest(a29, G3.DepthOrder.FRONT_TO_BACK, e31.frustum), n26 = this._octree.findClosest(a29, G3.DepthOrder.BACK_TO_FRONT, e31.frustum);
    if (null != s23 && null != n26) {
      this._instanceData.view.boundingSphere.getVec(s23, N2), e3(N2, N2, t24);
      const i23 = P(N2, a29) - N2[3];
      this._instanceData.view.boundingSphere.getVec(n26, N2), e3(N2, N2, t24);
      const l32 = P(N2, a29) + N2[3];
      return { near: Math.max(e31.near, i23), far: Math.min(e31.far, l32) };
    }
    return { near: 1 / 0, far: -1 / 0 };
  }
  _startUpdateCycle() {
    this._updateCyclesWithStaticCamera++, this._defaultRenderInstanceData.forEach((e31) => {
      e31.startUpdateCylce();
    }), this._highlightRenderInstanceData.forEach((e31) => {
      e31.startUpdateCylce();
    }), this._needsUpdates && this._context.requestRender();
  }
  _updateInstances(e31, t24) {
    const s23 = this._enableLevelSelection, n26 = this._levelSelector;
    n26.updateCamera(e31), this._defaultRenderInstanceData.forEach((e32) => e32.beginUpdate()), this._highlightRenderInstanceData.forEach((e32) => e32.beginUpdate());
    const i23 = this._instanceData, r30 = this._instanceData.view, o24 = i23.size, l32 = i23.capacity;
    let c31 = this._instanceIndex;
    t24 = Math.min(o24, t24);
    for (let h25 = 0; h25 < t24; ++h25) {
      0 === c31 && this._startUpdateCycle();
      const e32 = r30.state.get(c31);
      let o25 = 0;
      if (!(e32 & O10.ALLOCATED)) {
        c31 = c31 + 1 === l32 ? 0 : c31 + 1, t24++;
        continue;
      }
      const h26 = r30.lodLevel.get(c31);
      if (e32 & O10.DEFAULT_ACTIVE && this._defaultRenderInstanceData[h26].freeTail(), e32 & O10.HIGHLIGHT_ACTIVE && this._highlightRenderInstanceData[h26].freeTail(), e32 & O10.REMOVE)
        i23.freeInstance(c31);
      else if (e32 & O10.VISIBLE) {
        let t25 = 0;
        s23 && (r30.modelOrigin.getVec(c31, w11), t25 = n26.selectLevel(w11, i23.getCombinedMedianScaleFactor(c31))), o25 = e32 & ~(O10.ACTIVE | O10.TRANSFORM_CHANGED), t25 >= 0 && (e32 & O10.HIGHLIGHT ? (V6(this._highlightRenderInstanceData[t25], r30, c31), o25 |= O10.HIGHLIGHT_ACTIVE) : (V6(this._defaultRenderInstanceData[t25], r30, c31), o25 |= O10.DEFAULT_ACTIVE)), r30.state.set(c31, o25), r30.lodLevel.set(c31, t25);
      } else
        o25 = e32 & ~(O10.ACTIVE | O10.TRANSFORM_CHANGED), r30.state.set(c31, o25);
      if (r(this._octreeCached)) {
        const t25 = !!(e32 & O10.ACTIVE), a29 = !!(o25 & O10.ACTIVE);
        !t25 && a29 ? this._octreeCached.addInstance(c31) : t25 && !a29 ? this._octreeCached.removeInstance(c31) : t25 && a29 && e32 & O10.TRANSFORM_CHANGED && (this._octreeCached.removeInstance(c31), this._octreeCached.addInstance(c31));
      }
      c31 = c31 + 1 === l32 ? 0 : c31 + 1;
    }
    this._instanceIndex = c31, this._defaultRenderInstanceData.forEach((e32) => e32.endUpdate()), this._highlightRenderInstanceData.forEach((e32) => e32.endUpdate());
  }
  _renderComponents(e31, t24) {
    this.levels.forEach((a29, s23) => {
      a29.components.forEach((a30) => {
        this._renderComponent(e31, t24[s23], a30, s23);
      });
    });
  }
  _renderComponent(t24, a29, s23, n26) {
    const { bindParameters: i23, rctx: r30, output: o24 } = t24;
    if (0 === a29.size || !s23.material.requiresSlot(i23.slot, t24.output))
      return;
    const l32 = s23.glMaterials.load(r30, i23.slot, o24);
    if (t(l32))
      return;
    const c31 = l32.beginSlot(i23), h25 = r30.bindTechnique(c31, s23.material.parameters, i23);
    r30.bindVAO(s23.vao), c31.ensureAttributeLocations(s23.vao), h25.bindDraw(G5, i23, s23.material.parameters), t14.LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL && t24.output === h9.Color && (h25.setUniform4fv("externalColor", P8[Math.min(n26, P8.length - 1)]), h25.setUniform1i("colorMixMode", U2.replace));
    const d27 = r30.capabilities.instancing, _20 = a29.capacity, f25 = a29.headIndex, g21 = a29.tailIndex, C16 = a29.firstIndex, I12 = this._glInstanceBufferLayout, y17 = (e31, t25) => {
      R7(r30, E5, a29.buffer, I12, e31), d27.drawArraysInstanced(c31.primitiveType, 0, s23.vertexCount, t25 - e31), E4(r30, E5, a29.buffer, I12);
    };
    s23.material.parameters.transparent && null != C16 ? f25 > g21 ? (e11(C16 >= g21 && C16 <= f25, "invalid firstIndex"), y17(C16, f25), y17(g21, C16)) : f25 < g21 && (C16 <= f25 ? (e11(C16 >= 0 && C16 <= f25, "invalid firstIndex"), y17(C16, f25), y17(g21, _20), y17(0, C16)) : (e11(C16 >= g21 && C16 <= _20, "invalid firstIndex"), y17(C16, _20), y17(0, f25), y17(g21, C16))) : f25 > g21 ? y17(g21, f25) : f25 < g21 && (y17(0, f25), y17(g21, _20)), r30.bindVAO(null);
  }
};
function V6(e31, t24, a29) {
  const s23 = e31.allocateHead();
  F9(t24, a29, e31.view, s23);
}
function F9(e31, t24, a29, s23) {
  p8(e31.modelOrigin, t24, a29.modelOriginHi, a29.modelOriginLo, s23), a29.model.copyFrom(s23, e31.model, t24), a29.modelNormal.copyFrom(s23, e31.modelNormal, t24), e31.color && a29.color && a29.color.copyFrom(s23, e31.color, t24), e31.objectAndLayerIdColor && a29.objectAndLayerIdColor && a29.objectAndLayerIdColor.copyFrom(s23, e31.objectAndLayerIdColor, t24), e31.featureAttribute && a29.featureAttribute && a29.featureAttribute.copyFrom(s23, e31.featureAttribute, t24);
}
var w11 = n2();
var N2 = n9();
var q8 = e9();
var H3 = n2();
var B7 = n2();
var P8 = [r8(1, 0, 1, 1), r8(0, 0, 1, 1), r8(0, 1, 0, 1), r8(1, 1, 0, 1), r8(1, 0, 0, 1)];
var G5 = new E9();

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DObjectSymbolLayer.js
var me4 = class extends y8 {
  constructor(e31, t24, s23, r30) {
    super(e31, t24, s23, r30), this._resources = null, this._optionalFields = new Array(), this._instanceIndexToGraphicUid = /* @__PURE__ */ new Map(), this._hasLoadedPBRTextures = false, this._disposeResourceHandles = new Array(), this.ensureDrapedStatus(false), this._hasLoadedPBRTextures = s23.physicalBasedRenderingEnabled;
  }
  getCachedSize() {
    const [e31, s23, r30] = r(this._resources) ? this._resources.symbolSize : [1, 1, 1];
    return { width: e31, depth: s23, height: r30 };
  }
  async doLoad(e31) {
    if (!this._drivenProperties.size) {
      if (S5(this.symbolLayer))
        throw new Error();
    }
    const t24 = this.symbolLayer;
    if (this._isPrimitive) {
      const s23 = t24.resource ? t24.resource.primitive : d4;
      this._resources = await this._createResourcesForPrimitive(s23, e31);
    } else
      this._resources = await this._createResourcesForUrl(t24.resource.href, e31);
    this.layerOpacityChanged(), this.slicePlaneEnabledChanged(), this.physicalBasedRenderingChanged(), this.complexity = this.computeComplexity();
  }
  get extentPadding() {
    return r(this._resources) ? this._resources.extentPadding : 0;
  }
  get _isPrimitive() {
    return !(this.symbolLayer.resource && this.symbolLayer.resource.href);
  }
  get lodRenderer() {
    return q(this._resources, "lodRenderer");
  }
  _setMaterialTransparencyParams(e31, t24 = q(this.symbolLayer, "material", "color")) {
    const r30 = this._getCombinedOpacity(t24), a29 = r30 < 1 || this.needsDrivenTransparentPass;
    return e31.transparent = a29, e31.opacity = r30, e31.cullFace = a29 ? n13.None : n13.Back, e31;
  }
  async _createResourcesForPrimitive(s23, a29) {
    if (!r18(s23))
      throw new Error(`Unknown object symbol primitive: ${s23}`);
    const i23 = this.symbolLayer, n26 = a6(c7(s23)), c31 = e2(F2(n26)), l32 = e2(t5(c31, i23)), h25 = s2(l32), d27 = false, m19 = false, u33 = { usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: true, ambient: l, diffuse: l, hasSlicePlane: this._context.slicePlaneEnabled, hasSliceHighlight: false, castShadows: this.symbolLayer.castShadows, offsetTransparentBackfaces: !this.symbolLayer.isPrimitive }, y17 = u33.usePBR;
    this._setMaterialTransparencyParams(u33);
    const f25 = this.symbol;
    if ("point-3d" === f25.type && f25.verticalOffset) {
      const { screenLength: e31, minWorldLength: s24, maxWorldLength: r30 } = f25.verticalOffset;
      u33.verticalOffset = { screenLength: u4(e31), minWorldLength: s24 || 0, maxWorldLength: r(r30) ? r30 : 1 / 0 }, u33.castShadows = false;
    }
    if (this._context.screenSizePerspectiveEnabled && (u33.screenSizePerspective = this._context.sharedResources.screenSizePerspectiveSettings), this._drivenProperties.color)
      u33.externalColor = _2;
    else {
      const s24 = r(i23.material) && i23.material.color, r30 = r(s24) ? l4.toUnitRGBA(s24) : _2;
      u33.externalColor = r30;
    }
    this._fastUpdates = P7(this._context.renderer, this._fastVisualVariableConvertOptions(n26, l32, c31, n)), u33.instanced = ["transformation"], this._fastUpdates.enabled ? (Object.assign(u33, this._fastUpdates.materialParameters), u33.instanced.push("featureAttribute"), this._optionalFields.push("featureAttribute")) : this._hasPerInstanceColor() && (u33.instanced.push("color"), this._optionalFields.push("color")), has("enable-feature:objectAndLayerId-rendering") && (u33.instanced.push("objectAndLayerIdColor"), this._optionalFields.push("objectAndLayerIdColor"));
    const _20 = new C5(u33), P11 = o17(s23, _20);
    if (!P11)
      throw new Error(`Unknown object symbol primitive: ${s23}`);
    const R16 = r19(P11).map((e31) => ({ opacity: 1, transparent: e31.parameters.transparent })), v23 = await this._createStageResources(P11, y17);
    return { lodResources: P11, lodRenderer: await this._createLodRenderer(P11, a29), stageResources: v23, symbolSize: l32, extentPadding: h25, isEsriSymbolResource: d27, isWosr: m19, originalMaterialParameters: R16, physicalBasedRenderingEnabled: y17, resourceBoundingBox: n26, resourceSize: c31, pivotOffset: n };
  }
  async _createResourcesForUrl(e31, a29) {
    const i23 = ["transformation"], n26 = { materialParamsMixin: { instanced: i23, hasSlicePlane: this._context.slicePlaneEnabled, castShadows: this.symbolLayer.castShadows }, streamDataRequester: this._context.streamDataRequester, cache: this._context.sharedResources.objectResourceCache };
    this._fastUpdates = P7(this._context.renderer, this._fastVisualVariableConvertOptions(n, n, n, n)), this._fastUpdates.enabled ? (Object.assign(n26.materialParamsMixin, this._fastUpdates.materialParameters), i23.push("featureAttribute"), this._optionalFields.push("featureAttribute")) : this._hasPerInstanceColor() && (i23.push("color"), this._optionalFields.push("color")), has("enable-feature:objectAndLayerId-rendering") && (i23.push("objectAndLayerIdColor"), this._optionalFields.push("objectAndLayerIdColor"));
    const c31 = this.symbol;
    if ("point-3d" === c31.type && c31.verticalOffset) {
      const { screenLength: e32, minWorldLength: s23, maxWorldLength: r30 } = c31.verticalOffset;
      n26.materialParamsMixin.verticalOffset = { screenLength: u4(e32), minWorldLength: s23 || 0, maxWorldLength: r(r30) ? r30 : 1 / 0 }, n26.materialParamsMixin.castShadows = false;
    }
    n26.signal = a29, n26.usePBR = this._context.physicalBasedRenderingEnabled, n26.skipHighLods = this._context.skipHighSymbolLods;
    const l32 = n26.usePBR, h25 = await Y2(e31, n26), d27 = h25.isEsriSymbolResource, m19 = h25.isWosr, u33 = o21(h25.lods);
    n21(u33), u33.levels.sort((e32, t24) => e32.minScreenSpaceRadius - t24.minScreenSpaceRadius), u33.levels[0].minScreenSpaceRadius = Math.min(2, u33.levels[0].minScreenSpaceRadius);
    const y17 = this._context, f25 = this.symbolLayer.material, _20 = this._getExternalColorParameters(f25), g21 = q(this.symbolLayer, "material", "color"), P11 = this._getCombinedOpacity(g21, { hasIntrinsicColor: true }), R16 = this.needsDrivenTransparentPass, v23 = r19(u33), x20 = r19(u33).map((e32) => ({ opacity: e32.parameters.opacity || 1, transparent: e32.parameters.transparent }));
    v23.forEach((e32) => {
      const t24 = e32.parameters;
      e32.setParameters(_20);
      const s23 = t24.opacity * P11, r30 = s23 < 1 || R16 || t24.transparent;
      e32.setParameters({ opacity: s23, transparent: r30 }), y17.screenSizePerspectiveEnabled && e32.setParameters({ screenSizePerspective: y17.sharedResources.screenSizePerspectiveSettings });
    });
    const L8 = h25.referenceBoundingBox, S18 = e2(F2(L8)), C16 = e2(u33.levels[0].pivotOffset), j14 = e2(t5(S18, this.symbolLayer)), U10 = s2(j14);
    R9(this._fastUpdates, this._context.renderer, this._fastVisualVariableConvertOptions(L8, j14, S18, C16)) && v23.forEach((e32) => e32.setParameters(this._fastUpdates.materialParameters));
    const E23 = await this._createStageResources(u33, l32);
    return { lodResources: u33, lodRenderer: await this._createLodRenderer(u33, a29), stageResources: E23, symbolSize: j14, extentPadding: U10, isEsriSymbolResource: d27, isWosr: m19, originalMaterialParameters: x20, physicalBasedRenderingEnabled: l32, resourceBoundingBox: L8, resourceSize: S18, pivotOffset: C16 };
  }
  _addDisposeResource(e31) {
    this._disposeResourceHandles.push(e31);
  }
  async _createStageResources(e31, t24) {
    const s23 = this._context.stage, r30 = r19(e31);
    t24 !== this._context.physicalBasedRenderingEnabled && this.physicalBasedRenderingChanged(), s23.addMany(r30), this._addDisposeResource(() => s23.removeMany(r30));
    const a29 = e22(e31);
    s23.addMany(a29), this._addDisposeResource(() => s23.removeMany(a29)), await s23.load(a29);
    const i23 = t17(e31);
    return s23.addMany(i23), this._addDisposeResource(() => s23.removeMany(i23)), { materials: r30, textures: a29, geometries: i23 };
  }
  async _createLodRenderer(e31, t24) {
    const s23 = this._context.stage, r30 = { layerUid: this._context.layer.uid, graphicUid: (e32) => this._instanceIndexToGraphicUid.get(e32), notifyGraphicGeometryChanged: (e32) => this._context.notifyGraphicGeometryChanged(this._instanceIndexToGraphicUid.get(e32)), notifyGraphicVisibilityChanged: (e32) => this._context.notifyGraphicVisibilityChanged(this._instanceIndexToGraphicUid.get(e32)) }, a29 = this._fastUpdates.enabled ? { applyTransform: (e32, t25, s24) => {
      e32.getFeatureAttribute(t25, _e4), n7(s24, B6(this._fastUpdates.materialParameters, _e4, s24));
    }, scaleFactor: (e32, t25, s24) => (t25.getFeatureAttribute(s24, _e4), L5(e32, this._fastUpdates.materialParameters, _e4)) } : null, i23 = new M9(e31, this._optionalFields, r30, a29);
    return i23.slicePlaneEnabled = this._context.slicePlaneEnabled, this._addDisposeResource(() => {
      s23.removeRenderPlugin(i23);
    }), await s23.addRenderPlugin(i23.slots, i23, t24), i23;
  }
  _getExternalColorParameters(s23) {
    const r30 = {};
    return this._drivenProperties.color ? r30.externalColor = _2 : r(s23) && r(s23.color) ? r30.externalColor = l4.toUnitRGBA(s23.color) : (r30.externalColor = _2, r30.colorMixMode = "ignore"), r30;
  }
  destroy() {
    super.destroy(), this._cleanupResources();
  }
  _cleanupResources() {
    this._disposeResourceHandles.forEach((e31) => e31()), this._disposeResourceHandles.length = 0, this._resources = null;
  }
  createGraphics3DGraphic(e31) {
    const t24 = e31.graphic;
    if (!this._validateGeometry(t24.geometry))
      return null;
    const s23 = d17(t24.geometry);
    if (t(s23))
      return this.logger.warn(`unsupported geometry type for icon symbol: ${t24.geometry.type}`), null;
    const r30 = this.setGraphicElevationContext(t24, new h16()), i23 = e31.renderingInfo;
    return this._createAs3DShape(t24, s23, i23, r30, t24.uid, e31.layer.uid);
  }
  notifyDestroyGraphicLayer(e31) {
    this._instanceIndexToGraphicUid.delete(e31.instanceIndex);
  }
  graphicLayerToGraphicId() {
    return 0;
  }
  layerOpacityChanged() {
    if (t(this._resources))
      return;
    const e31 = this._drivenProperties.opacity, t24 = !this._isPrimitive, r30 = this._resources.stageResources.materials, i23 = this._resources.originalMaterialParameters;
    for (let a29 = 0; a29 < r30.length; a29++) {
      const o24 = r30[a29], n26 = q(this.symbolLayer, "material", "color"), c31 = i23[a29], l32 = this._getCombinedOpacity(n26, { hasIntrinsicColor: t24 }) * c31.opacity, h25 = l32 < 1 || e31 || c31.transparent;
      o24.setParameters({ opacity: l32, transparent: h25 }), this._isPrimitive && o24.setParameters({ cullFace: h25 ? n13.None : n13.Back });
    }
  }
  layerElevationInfoChanged(e31, t24) {
    return this.updateGraphics3DGraphicElevationInfo(e31, t24, v10);
  }
  slicePlaneEnabledChanged() {
    if (t(this._resources))
      return true;
    this._resources.lodRenderer.slicePlaneEnabled = this._context.slicePlaneEnabled;
    for (const e31 of this._resources.stageResources.materials)
      e31.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled });
    return true;
  }
  physicalBasedRenderingChanged() {
    if (t(this._resources))
      return true;
    const { stageResources: e31, isWosr: t24 } = this._resources;
    for (const s23 of e31.materials)
      this._isPrimitive ? s23.setParameters({ usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: true }) : t24 || s23.setParameters({ usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: false });
    return false !== this._hasLoadedPBRTextures || true !== this._context.physicalBasedRenderingEnabled || (this._hasLoadedPBRTextures = true, false);
  }
  pixelRatioChanged() {
    return true;
  }
  applyRendererDiff(e31, t24) {
    if (t(this._resources))
      return e20.Recreate_Symbol;
    const { stageResources: { materials: s23 }, lodRenderer: r30, resourceBoundingBox: i23, symbolSize: o24, resourceSize: n26, pivotOffset: c31 } = this._resources;
    for (const a29 in e31.diff) {
      if ("visualVariables" !== a29)
        return e20.Recreate_Symbol;
      if (!R9(this._fastUpdates, t24, this._fastVisualVariableConvertOptions(i23, o24, n26, c31)))
        return e20.Recreate_Symbol;
      for (const e32 of s23)
        e32.setParameters(this._fastUpdates.materialParameters);
      r30.notifyShaderTransformationChanged();
    }
    return e20.Fast_Update;
  }
  computeComplexity() {
    if (t(this._resources))
      return super.computeComplexity();
    const e31 = this._resources.lodResources, t24 = n17(e31.levels[0]).reduce((e32, t25) => e32 + t25.indices.get(O2.POSITION).length, 0) / 3, s23 = (e32) => Array.from(e32.vertexAttributes.values()).reduce((e33, t25) => {
      var _a, _b;
      return e33 + ((_b = (_a = t25.data.buffer) == null ? void 0 : _a.byteLength) != null ? _b : 0);
    }, 0) + Array.from(e32.indices.values()).reduce((e33, t25) => e33 + (Array.isArray(t25) ? 12 * t25.length : t25.buffer.byteLength), 0), r30 = e22(e31).reduce((e32, t25) => e32 + t25.estimatedTexMemRequired, 0) / 4 + t17(e31).reduce((e32, t25) => e32 + s23(t25), 0);
    return { primitivesPerFeature: t24, primitivesPerCoordinate: 0, drawCallsPerFeature: 0, estimated: false, memory: { ...l23(this.symbol, this.symbolLayer), resourceBytes: r30 } };
  }
  _hasLodRenderer() {
    return r(this._resources);
  }
  _createAs3DShape(e31, s23, r30, i23, o24, n26) {
    if (!this._hasLodRenderer() || t(this._resources))
      return null;
    const c31 = this.getFastUpdateAttrValues(e31), l32 = !this._fastUpdates.enabled && this._hasPerInstanceColor() ? B4(r30.color, r30.opacity) : null, h25 = this._context.clippingExtent;
    if (gn(s23, ue4, this._context.elevationProvider.spatialReference), r(h25) && !E3(h25, ue4))
      return null;
    const d27 = this._requiresTerrainElevation(i23), p21 = this._computeGlobalTransform(s23, i23, fe3, be3), m19 = this._computeLocalTransform(this._resources, this.symbolLayer, r30, ye3), u33 = this._resources.lodRenderer.instanceData, y17 = u33.addInstance();
    this._instanceIndexToGraphicUid.set(y17, o24), u33.setLocalTransform(y17, m19, false), u33.setGlobalTransform(y17, p21), c31 && u33.setFeatureAttribute(y17, c31), l32 && u33.setColor(y17, l32), has("enable-feature:objectAndLayerId-rendering") && u33.setObjectAndLayerIdColor(y17, this._context.stage.renderView._objectAndLayerIdRenderHelper.getObjectAndLayerIdColor({ graphicUid: o24, layerUid: n26 }));
    const f25 = new f21(this, y17, I5, i23);
    return d27 && (f25.alignedSampledElevation = be3.sampledElevation), f25.needsElevationUpdates = v10(i23.mode), f18(f25, s23, this._context.elevationProvider), f25;
  }
  _computeGlobalTransform(e31, t24, s23, r30) {
    return d11(e31, this._context.elevationProvider, t24, this._context.renderCoordsHelper, r30), ue4[0] = e31.x, ue4[1] = e31.y, ue4[2] = r30.z, Zn(e31.spatialReference, ue4, s23, this._context.renderCoordsHelper.spatialReference), s23;
  }
  _computeLocalTransform(e31, t24, s23, r30) {
    return r6(r30), this._applyObjectRotation(s23, false, r30), this._applyObjectRotation(t24, true, r30), this._applyObjectScale(e31, s23, r30), this._applyAnchor(e31, t24, r30), r30;
  }
  _applyObjectScale(e31, t24, s23) {
    if (this._fastUpdates.enabled && this._fastUpdates.requiresShaderTransformation)
      return;
    const r30 = this._drivenProperties.size && t24.size ? t24.size : e31.symbolSize, a29 = I3(r30, e31.symbolSize, e31.resourceSize, this._context.renderCoordsHelper.unitInMeters);
    1 === a29[0] && 1 === a29[1] && 1 === a29[2] || i2(s23, s23, a29);
  }
  prepareSymbolLayerPatch(e31) {
    if ("partial" !== e31.diff.type)
      return;
    const t24 = e31.diff.diff;
    this._preparePatchTransform(e31, t24), this._preparePatchColor(e31, t24);
  }
  updateGeometry(e31, t24) {
    if (t(this._resources))
      return true;
    const s23 = t24 && d17(t24);
    if (t(s23))
      return false;
    const r30 = this.getGeometryElevationMode(t24);
    return e31.elevationContext.mode === r30 && (this._computeGlobalTransform(s23, e31.elevationContext, fe3, be3), this._requiresTerrainElevation(e31.elevationContext) && (e31.alignedSampledElevation = be3.sampledElevation), this._resources.lodRenderer.instanceData.setGlobalTransform(e31.instanceIndex, fe3, true), f18(e31, s23, this._context.elevationProvider), true);
  }
  _preparePatchTransform(e31, t24) {
    if (!(t24.heading || t24.tilt || t24.roll || t24.width || t24.height || t24.depth || t24.anchor || t24.anchorPosition))
      return;
    if (t(this._resources))
      return;
    const s23 = (e32, t25, s24) => i(null != e32 && "complete" === e32.type ? e32.newValue : t25, s24), r30 = s23(t24.heading, this.symbolLayer.heading, 0), o24 = s23(t24.tilt, this.symbolLayer.tilt, 0), n26 = s23(t24.roll, this.symbolLayer.roll, 0), c31 = s23(t24.width, this.symbolLayer.width, void 0), l32 = s23(t24.height, this.symbolLayer.height, void 0), h25 = s23(t24.depth, this.symbolLayer.depth, void 0), d27 = s23(t24.anchor, this.symbolLayer.anchor, void 0), p21 = s23(t24.anchorPosition, this.symbolLayer.anchorPosition, void 0);
    delete t24.heading, delete t24.tilt, delete t24.roll, delete t24.width, delete t24.height, delete t24.depth, delete t24.anchor, delete t24.anchorPosition;
    const m19 = { heading: r30, tilt: o24, roll: n26, anchor: d27, anchorPosition: p21 }, u33 = this._resources;
    this.loadStatus === e21.LOADED && e31.symbolLayerStatePatches.push(() => {
      u33.symbolSize = e2(t5(u33.resourceSize, { width: c31, height: l32, depth: h25, isPrimitive: this.symbolLayer.isPrimitive }));
    }), e31.graphics3DGraphicPatches.push((e32, t25) => {
      const s24 = this._computeLocalTransform(u33, m19, t25, ye3), r31 = e32.instanceIndex;
      u33.lodRenderer.instanceData.setLocalTransform(r31, s24, true);
    });
  }
  _preparePatchColor(s23, r30) {
    if (!r30.material || "partial" !== r30.material.type)
      return;
    const i23 = r30.material.diff;
    if (!i23.color || "complete" !== i23.color.type || null == i23.color.newValue || null == i23.color.oldValue)
      return;
    const o24 = i23.color.newValue, n26 = r(o24) ? l4.toUnitRGBA(o24) : _2;
    delete i23.color;
    const c31 = this._resources;
    t(c31) || s23.graphics3DGraphicPatches.push((e31) => {
      let t24;
      this._hasPerInstanceColor() ? (c31.lodRenderer.instanceData.setColor(e31.instanceIndex, n26), t24 = this._setMaterialTransparencyParams({}, o24)) : t24 = this._setMaterialTransparencyParams({ externalColor: n26 }, o24);
      for (const s24 of c31.stageResources.materials)
        s24.setParameters(t24);
    });
  }
  _requiresTerrainElevation(e31) {
    return "absolute-height" !== e31.mode;
  }
  _applyObjectRotation(e31, t24, s23) {
    if (!(this._fastUpdates.enabled && this._fastUpdates.requiresShaderTransformation && t24))
      return G4(e31.heading, e31.tilt, e31.roll, s23);
  }
  _computeAnchor(e31, s23, r30) {
    const a29 = n2();
    switch (r30.anchor) {
      case "center":
        r4(a29, p4(e31)), j(a29, a29);
        break;
      case "top": {
        const t24 = p4(e31);
        o2(a29, -t24[0], -t24[1], -e31[5]);
        break;
      }
      case "bottom": {
        const t24 = p4(e31);
        o2(a29, -t24[0], -t24[1], -e31[2]);
        break;
      }
      case "relative": {
        const t24 = p4(e31), s24 = F2(e31), i23 = r30.anchorPosition, o24 = i23 ? r2(i23.x, i23.y, i23.z) : f;
        c(a29, s24, o24), u(a29, a29, t24), j(a29, a29);
        break;
      }
      default:
        r(s23) ? j(a29, s23) : r4(a29, f);
    }
    return a29;
  }
  _applyAnchor(e31, t24, s23) {
    if (this._fastUpdates.enabled && this._fastUpdates.requiresShaderTransformation)
      return;
    const r30 = this._computeAnchor(e31.resourceBoundingBox, e31.pivotOffset, t24);
    r30 && c4(s23, s23, r30);
  }
  _hasPerInstanceColor() {
    return this._drivenProperties.color || this._drivenProperties.opacity;
  }
  _fastVisualVariableConvertOptions(e31, s23, r30, a29) {
    const i23 = r(e31) ? e2(F2(e31)) : l, o24 = r(e31) ? this._computeAnchor(e31, a29, this.symbolLayer) : f, n26 = this._context.renderCoordsHelper.unitInMeters, c31 = I3(r(s23) ? s23 : void 0, s23, r30, n26), l32 = r2(this.symbolLayer.tilt || 0, this.symbolLayer.roll || 0, this.symbolLayer.heading || 0);
    return { modelSize: i23, symbolSize: r(s23) ? s23 : l, unitInMeters: n26, transformation: { anchor: o24, scale: c31, rotation: l32 } };
  }
};
var ue4 = n2();
var ye3 = e9();
var fe3 = e9();
var _e4 = n9();
var be3 = new j8();

// node_modules/@arcgis/core/chunks/mat2.js
function n24(t24, n26) {
  return t24[0] = n26[0], t24[1] = n26[1], t24[2] = n26[2], t24[3] = n26[3], t24;
}
function a27(t24) {
  return t24[0] = 1, t24[1] = 0, t24[2] = 0, t24[3] = 1, t24;
}
function r26(t24, n26, a29, r30, s23) {
  return t24[0] = n26, t24[1] = a29, t24[2] = r30, t24[3] = s23, t24;
}
function s17(t24, n26) {
  if (t24 === n26) {
    const a29 = n26[1];
    t24[1] = n26[2], t24[2] = a29;
  } else
    t24[0] = n26[0], t24[1] = n26[2], t24[2] = n26[1], t24[3] = n26[3];
  return t24;
}
function u28(t24, n26) {
  const a29 = n26[0], r30 = n26[1], s23 = n26[2], u33 = n26[3];
  let o24 = a29 * u33 - s23 * r30;
  return o24 ? (o24 = 1 / o24, t24[0] = u33 * o24, t24[1] = -r30 * o24, t24[2] = -s23 * o24, t24[3] = a29 * o24, t24) : null;
}
function o22(t24, n26) {
  const a29 = n26[0];
  return t24[0] = n26[3], t24[1] = -n26[1], t24[2] = -n26[2], t24[3] = a29, t24;
}
function e25(t24) {
  return t24[0] * t24[3] - t24[2] * t24[1];
}
function c28(t24, n26, a29) {
  const r30 = n26[0], s23 = n26[1], u33 = n26[2], o24 = n26[3], e31 = a29[0], c31 = a29[1], i23 = a29[2], f25 = a29[3];
  return t24[0] = r30 * e31 + u33 * c31, t24[1] = s23 * e31 + o24 * c31, t24[2] = r30 * i23 + u33 * f25, t24[3] = s23 * i23 + o24 * f25, t24;
}
function i19(t24, n26, a29) {
  const r30 = n26[0], s23 = n26[1], u33 = n26[2], o24 = n26[3], e31 = Math.sin(a29), c31 = Math.cos(a29);
  return t24[0] = r30 * c31 + u33 * e31, t24[1] = s23 * c31 + o24 * e31, t24[2] = r30 * -e31 + u33 * c31, t24[3] = s23 * -e31 + o24 * c31, t24;
}
function f23(t24, n26, a29) {
  const r30 = n26[0], s23 = n26[1], u33 = n26[2], o24 = n26[3], e31 = a29[0], c31 = a29[1];
  return t24[0] = r30 * e31, t24[1] = s23 * e31, t24[2] = u33 * c31, t24[3] = o24 * c31, t24;
}
function l27(t24, n26) {
  const a29 = Math.sin(n26), r30 = Math.cos(n26);
  return t24[0] = r30, t24[1] = a29, t24[2] = -a29, t24[3] = r30, t24;
}
function h22(t24, n26) {
  return t24[0] = n26[0], t24[1] = 0, t24[2] = 0, t24[3] = n26[1], t24;
}
function M10(t24) {
  return "mat2(" + t24[0] + ", " + t24[1] + ", " + t24[2] + ", " + t24[3] + ")";
}
function b22(t24) {
  return Math.sqrt(t24[0] ** 2 + t24[1] ** 2 + t24[2] ** 2 + t24[3] ** 2);
}
function m17(t24, n26, a29, r30) {
  return t24[2] = r30[2] / r30[0], a29[0] = r30[0], a29[1] = r30[1], a29[3] = r30[3] - t24[2] * a29[1], [t24, n26, a29];
}
function d20(t24, n26, a29) {
  return t24[0] = n26[0] + a29[0], t24[1] = n26[1] + a29[1], t24[2] = n26[2] + a29[2], t24[3] = n26[3] + a29[3], t24;
}
function p18(t24, n26, a29) {
  return t24[0] = n26[0] - a29[0], t24[1] = n26[1] - a29[1], t24[2] = n26[2] - a29[2], t24[3] = n26[3] - a29[3], t24;
}
function y10(t24, n26) {
  return t24[0] === n26[0] && t24[1] === n26[1] && t24[2] === n26[2] && t24[3] === n26[3];
}
function x15(n26, a29) {
  const r30 = n26[0], s23 = n26[1], u33 = n26[2], o24 = n26[3], e31 = a29[0], c31 = a29[1], i23 = a29[2], f25 = a29[3], l32 = a();
  return Math.abs(r30 - e31) <= l32 * Math.max(1, Math.abs(r30), Math.abs(e31)) && Math.abs(s23 - c31) <= l32 * Math.max(1, Math.abs(s23), Math.abs(c31)) && Math.abs(u33 - i23) <= l32 * Math.max(1, Math.abs(u33), Math.abs(i23)) && Math.abs(o24 - f25) <= l32 * Math.max(1, Math.abs(o24), Math.abs(f25));
}
function g16(t24, n26, a29) {
  return t24[0] = n26[0] * a29, t24[1] = n26[1] * a29, t24[2] = n26[2] * a29, t24[3] = n26[3] * a29, t24;
}
function j11(t24, n26, a29, r30) {
  return t24[0] = n26[0] + a29[0] * r30, t24[1] = n26[1] + a29[1] * r30, t24[2] = n26[2] + a29[2] * r30, t24[3] = n26[3] + a29[3] * r30, t24;
}
var S15 = c28;
var q9 = p18;
var _14 = Object.freeze(Object.defineProperty({ __proto__: null, copy: n24, identity: a27, set: r26, transpose: s17, invert: u28, adjoint: o22, determinant: e25, multiply: c28, rotate: i19, scale: f23, fromRotation: l27, fromScaling: h22, str: M10, frob: b22, LDU: m17, add: d20, subtract: p18, exactEquals: y10, equals: x15, multiplyScalar: g16, multiplyScalarAndAdd: j11, mul: S15, sub: q9 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/PathGeometry.js
var r27 = class extends d8 {
  constructor(e31, r30, i23, s23, n26, o24, c31) {
    super(e31, r30, a11.Triangle, c31), this.path = i23, this.geometrySR = s23, this.upVectorAlignment = n26, this.stencilWidth = o24;
  }
};
function i20(t24) {
  return "upVectorAlignment" in t24;
}

// node_modules/@arcgis/core/chunks/mat2f64.js
function e26() {
  return [1, 0, 0, 1];
}
function r28(e31) {
  return [e31[0], e31[1], e31[2], e31[3]];
}
function t21(e31, r30, t24, n26) {
  return [e31, r30, t24, n26];
}
function n25(e31, r30) {
  return new Float64Array(e31, r30, 4);
}
var o23 = Object.freeze(Object.defineProperty({ __proto__: null, create: e26, clone: r28, fromValues: t21, createView: n25 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/pathGeometryUtils.js
function E17() {
  return { up: n2(), right: n2() };
}
function k5(t24, e31, i23) {
  O(t24.up, e31.up, i23), O(t24.right, e31.right, i23);
}
function G6(t24, e31, i23) {
  r10(t24, P(i23, e31.right), P(i23, e31.up));
}
var B8 = class {
  constructor() {
    this.pos = n2(), this.posES = n2(), this.posGS = n2(), this.vRight = n2(), this.vLeft = n2(), this.frame = E17(), this.rotationFrame = E17(), this.rotationRight = n12(), this.rotationAngle = 0, this.miterStretch = e26();
  }
  setFrameFromUpVector(t24) {
    r4(this.frame.up, t24), u(at, this.vLeft, this.vRight), z(at, at), g(nt3, this.frame.up, P(at, this.frame.up)), e3(pt, at, nt3), z(pt, pt), _(this.frame.right, pt, this.frame.up);
  }
  computeRotationAxisAndAngleFromUpVector() {
    r4(this.rotationFrame.up, this.frame.up), r4(this.rotationFrame.right, this.frame.right), r10(this.rotationRight, 1, 0), g(nt3, this.frame.up, P(this.frame.up, this.vLeft)), e3(nt3, this.vLeft, nt3), j(nt3, nt3), z(nt3, nt3), g(at, this.frame.up, P(this.frame.up, this.vRight)), e3(at, this.vRight, at), z(at, at), _(lt, this.rotationFrame.up, this.vLeft);
    const s23 = Math.sign(P(lt, this.vRight));
    if (this.rotationAngle = s23 * (Math.PI - l3(P(nt3, at))), Math.abs(this.rotationAngle) > 0) {
      const t24 = F(Math.cos(0.5 * this.rotationAngle));
      r26(this.miterStretch, t24 - 1 + 1, 0, 0, 1);
    }
    const r30 = Math.PI - this.rotationAngle;
    this.maxStretchDistance = Math.abs(Math.min(this.vLeftLength, this.vRightLength) / Math.cos(0.5 * r30));
  }
};
var j12 = class {
  constructor() {
    this.vertices = [], this.vertexIndices = [], this.vertexNormals = [], this.poles = [], this.poleIndices = [], this.uvs = null, this.uvIndices = null;
  }
  addVertex(t24, e31) {
    return this.vertices.push(t9(t24)), this.vertexNormals.push(t9(e31)), this.vertices.length - 1;
  }
  addUV(t24) {
    return this.uvs || (this.uvs = [], this.uvIndices = []), this.uvs.push(t24), this.uvs.length - 1;
  }
  addPole(t24, e31 = null) {
    return this.poles.push({ position: t9(t24), normal: e31 ? t9(e31) : null }), this.poles.length - 1;
  }
  addSegment(t24, e31 = null, i23 = null) {
    this.vertexIndices.push(t24.v0), this.vertexIndices.push(t24.v1), e31 && (this.uvIndices.push(e31.v0), this.uvIndices.push(e31.v1)), i23 && (this.poleIndices.push(i23.v0), this.poleIndices.push(i23.v1));
  }
  get numSegments() {
    return this.vertexIndices.length / 2;
  }
  hasUV() {
    return null != this.uvs;
  }
  translate(t24, e31) {
    for (const i23 of this.vertices)
      i23[0] += t24, i23[1] += e31;
    for (const i23 of this.poles)
      i23.position[0] += t24, i23.position[1] += e31;
  }
  static circle(t24 = 20) {
    const e31 = 0.5, i23 = new j12(), s23 = { v0: 0, v1: 0 };
    i23.addPole(r12(0, 0));
    for (let h25 = 0; h25 < t24; ++h25) {
      const s24 = 2 * h25 * Math.PI / t24, r31 = Math.cos(s24), o25 = Math.sin(s24), n26 = r12(r31 * e31, o25 * e31), a29 = r12(r31, o25);
      i23.addVertex(n26, a29), i23.addUV(h25 / t24);
    }
    i23.addUV(1);
    for (let h25 = 0; h25 < t24 - 1; ++h25) {
      const t25 = { v0: h25, v1: h25 + 1 }, e32 = t25;
      i23.addSegment(t25, e32, s23);
    }
    const r30 = { v0: t24 - 1, v1: 0 }, o24 = { v0: t24 - 1, v1: t24 };
    return i23.addSegment(r30, o24, s23), i23;
  }
  static rect() {
    const t24 = 1, e31 = 1, i23 = new j12(), s23 = r12(0.5 * -t24, 0.5 * -e31), r30 = r12(0.5 * t24, 0.5 * -e31), o24 = r12(0.5 * t24, 0.5 * e31), h25 = r12(0.5 * -t24, 0.5 * e31), n26 = r12(0, -1), a29 = r12(1, 0), l32 = r12(0, 1), u33 = r12(-1, 0);
    i23.addUV(0), i23.addUV(1), i23.addPole(r12(0, 0.5 * e31), l32), i23.addPole(r12(0, 0.5 * e31)), i23.addPole(r12(0, 0.5 * -e31)), i23.addPole(r12(0, 0.5 * -e31), n26);
    const p21 = { v0: 0, v1: 1 };
    return i23.addVertex(s23, n26), i23.addVertex(r30, n26), i23.addSegment({ v0: 0, v1: 1 }, p21, { v0: 3, v1: 3 }), i23.addVertex(r30, a29), i23.addVertex(o24, a29), i23.addSegment({ v0: 2, v1: 3 }, p21, { v0: 2, v1: 1 }), i23.addVertex(o24, l32), i23.addVertex(h25, l32), i23.addSegment({ v0: 4, v1: 5 }, p21, { v0: 0, v1: 0 }), i23.addVertex(h25, u33), i23.addVertex(s23, u33), i23.addSegment({ v0: 6, v1: 7 }, p21, { v0: 1, v1: 2 }), i23;
  }
};
var z4 = class {
  constructor(t24) {
    this.vertices = [], this.offset = n2(), this.xform = e9(), this.vertices = t24;
    const e31 = Math.floor((t24.length - 1) / 2);
    r4(this.offset, this.vertices[e31].pos);
    for (const i23 of this.vertices)
      e3(i23.pos, i23.pos, this.offset);
    c4(this.xform, this.xform, this.offset), this.updatePathVertexInformation();
  }
  updatePathVertexInformation() {
    const t24 = this.vertices.length;
    let e31 = this.vertices[0];
    e31.index = 0, o2(e31.vLeft, 0, 0, 0), e31.vLeftLength = 0, e3(e31.vRight, this.vertices[1].pos, e31.pos), e31.vRightLength = s2(e31.vRight), z(e31.vRight, e31.vRight);
    let i23 = e31;
    for (let s23 = 1; s23 < t24; ++s23)
      e31 = this.vertices[s23], e31.index = s23, r4(e31.vLeft, i23.vRight), e31.vLeftLength = i23.vRightLength, s23 < t24 - 1 ? (e3(e31.vRight, this.vertices[s23 + 1].pos, e31.pos), e31.vRightLength = s2(e31.vRight), z(e31.vRight, e31.vRight)) : (r4(e31.vRight, e31.vLeft), e31.vRightLength = e31.vLeftLength), i23 = e31;
  }
};
function J5(t24, e31) {
  let i23 = null;
  const s23 = t24.vertices.length, r30 = 0.99619469809, o24 = n2(), h25 = n2(), n26 = n2(), a29 = n2(), l32 = n2(), u33 = n2(), p21 = p7();
  let f25 = t24.vertices[0];
  r4(h25, e31), o2(o24, 0, 1, 0), J2(f25.vRight, h25, o24, o24, n26, h25, r30), r4(f25.frame.up, h25), r4(f25.frame.right, n26), i23 = f25;
  for (let c31 = 1; c31 < s23; ++c31) {
    f25 = t24.vertices[c31], u(l32, f25.vLeft, f25.vRight);
    let e32 = s2(l32);
    e32 > 0 ? (e32 = 1 / Math.sqrt(e32), l32[0] = l32[0] * e32, l32[1] = l32[1] * e32, l32[2] = l32[2] * e32) : (l32[0] = f25.vRight[0], l32[1] = f25.vRight[1], l32[2] = f25.vRight[2]), u(u33, i23.pos, i23.frame.up), _4(f25.pos, l32, p21);
    q5(p21, p5(u33, f25.vLeft), a29) ? (e3(a29, a29, f25.pos), z(h25, a29), _(n26, l32, h25), z(n26, n26)) : J2(l32, i23.frame.up, i23.frame.right, o24, n26, h25, r30), r4(f25.frame.up, h25), r4(f25.frame.right, n26), i23 = f25;
  }
}
var H4 = class {
  numProfilesPerJoin() {
    return 1;
  }
  extrude(t24, e31, i23) {
    for (let s23 = 0; s23 < e31.vertices.length; ++s23)
      i23(t24.index, t24.frame, e31.vertices[s23], e31.vertexNormals[s23], false);
  }
};
var X3 = class {
  constructor(t24 = 0.8 * Math.PI, e31 = 1) {
    this.cutoffAngle = t24, this.numBendSubdivisions = e31;
  }
  numProfilesPerJoin() {
    return this.numBendSubdivisions + 1;
  }
  extrude(t24, e31, i23) {
    const s23 = ft;
    if (Math.abs(t24.rotationAngle) >= this.cutoffAngle)
      for (let r30 = 0; r30 < this.numBendSubdivisions + 1; ++r30) {
        g2(ct, 0.5 * -t24.rotationAngle + r30 * t24.rotationAngle / this.numBendSubdivisions, t24.rotationFrame.up), k5(s23, t24.frame, ct);
        for (let r31 = 0; r31 < e31.vertices.length; ++r31) {
          j6(e31.vertices[r31], t24.rotationRight) * t24.rotationAngle >= 0 ? i23(t24.index, s23, e31.vertices[r31], e31.vertexNormals[r31], false) : (_3(rt, e31.vertices[r31], t24.miterStretch), i23(t24.index, t24.frame, rt, e31.vertexNormals[r31], true));
        }
      }
    else
      for (let r30 = 0; r30 < this.numBendSubdivisions + 1; ++r30)
        for (let s24 = 0; s24 < e31.vertices.length; ++s24) {
          const r31 = j6(e31.vertices[s24], t24.rotationRight) * t24.rotationAngle >= 0;
          _3(rt, e31.vertices[s24], t24.miterStretch), i23(t24.index, t24.frame, rt, e31.vertexNormals[s24], !r31);
        }
  }
};
var K2 = { generateUV: false };
var Q2 = class {
  rebuildConnectingProfileGeometry(t24, e31, i23) {
    for (let s23 = 0; s23 < e31.vertices.length; ++s23)
      i23(t24.index, t24.frame, e31.vertices[s23], e31.vertexNormals[s23], 0, 0);
  }
};
var W2 = class extends Q2 {
  constructor() {
    super();
  }
  getNumVertices() {
    return 0;
  }
  getNumIndices() {
    return 0;
  }
  rebuildCapGeometry() {
  }
  buildTopology() {
  }
};
var Y3 = class extends Q2 {
  constructor(t24, e31 = 0, i23 = false) {
    super(), this.profile = t24, this.profilePlaneOffset = e31, this.flip = i23;
  }
  getNumVertices() {
    return this.profile.vertices.length;
  }
  getNumIndices() {
    return 3 * this.profile.numSegments;
  }
  rebuildConnectingProfileGeometry(t24, e31, i23) {
    for (let s23 = 0; s23 < e31.vertices.length; ++s23)
      i23(t24.index, t24.frame, e31.vertices[s23], e31.vertexNormals[s23], this.profilePlaneOffset, 0);
  }
  rebuildCapGeometry(t24, e31) {
    const i23 = ot;
    r10(i23, 0, 0);
    const s23 = this.flip ? 1 : -1;
    for (let r30 = 0; r30 < this.profile.vertices.length; ++r30)
      e31(t24.index, t24.frame, this.profile.vertices[r30], i23, this.profilePlaneOffset, s23);
  }
  buildTopology(t24, e31) {
    const i23 = this.vertexBufferStart + this.profile.vertexIndices[0];
    for (let s23 = 1; s23 < this.profile.numSegments; ++s23) {
      const t25 = this.profile.vertexIndices[2 * s23 + 0], r30 = this.profile.vertexIndices[2 * s23 + 1], o24 = this.vertexBufferStart + t25, h25 = this.vertexBufferStart + r30;
      this.flip ? e31(h25, o24, i23) : e31(i23, o24, h25);
    }
  }
};
var Z = class extends Q2 {
  constructor(t24) {
    super(), this.flip = false, this.sign = 0, this.breakNormals = false, this.numSegments = 3, this.profile = t24.profile, this.flip = t24.flip, this.sign = this.flip ? 1 : -1, this.breakNormals = t24.breakNormals, this.numSegments = t24.subdivisions;
  }
  getNumVertices() {
    let t24 = 0;
    return t24 = this.profile.vertices.length * (this.numSegments - 1), this.breakNormals && (t24 += this.profile.vertices.length), t24 += this.profile.poles.length, t24;
  }
  getNumIndices() {
    let t24 = 0;
    t24 += 2 * this.profile.numSegments * (this.numSegments - 1);
    for (let e31 = 0; e31 < this.profile.numSegments; ++e31) {
      const i23 = this.profile.vertexIndices[2 * e31 + 0], s23 = this.profile.vertexIndices[2 * e31 + 1];
      this.profile.poleIndices[i23] === this.profile.poleIndices[s23] ? t24 += 1 : t24 += 2;
    }
    return 3 * t24;
  }
  rebuildCapGeometry(t24, e31) {
    const i23 = t24.frame, s23 = 0.5 * this.sign, r30 = rt, o24 = ot;
    r10(o24, 0, 0);
    for (let h25 = 0; h25 < this.profile.poles.length; ++h25) {
      const r31 = this.profile.poles[h25];
      r31.normal ? e31(t24.index, i23, r31.position, r31.normal, s23, 0) : e31(t24.index, i23, r31.position, o24, s23, this.sign);
    }
    if (this.breakNormals)
      for (let h25 = 0; h25 < this.profile.vertices.length; ++h25)
        e31(t24.index, i23, this.profile.vertices[h25], this.profile.vertexNormals[h25], 0, 0);
    for (let h25 = 0; h25 < this.numSegments - 1; ++h25) {
      const n26 = (1 - (h25 + 1) / this.numSegments) * Math.PI * 0.5, a29 = Math.sin(n26), l32 = Math.cos(n26);
      for (let h26 = 0; h26 < this.profile.vertices.length; ++h26) {
        const n27 = this.profile.poles[this.profile.poleIndices[h26]];
        o4(r30, this.profile.vertices[h26], n27.position), l11(r30, r30, a29), n27.normal ? (s7(r30, r30, n27.position), e31(t24.index, i23, r30, n27.normal, s23 * l32, 0)) : (v3(o24, r30), l11(o24, o24, a29), s7(r30, r30, n27.position), e31(t24.index, i23, r30, o24, s23 * l32, this.sign * l32));
      }
    }
  }
  buildTopology(t24, e31) {
    const i23 = this.breakNormals ? this.vertexBufferStart + this.profile.poles.length : this.firstProfileVertexIndex, s23 = this.breakNormals ? this.vertexBufferStart + this.profile.poles.length + this.profile.vertices.length : this.vertexBufferStart + this.profile.poles.length;
    for (let r30 = 0; r30 < this.profile.numSegments; ++r30) {
      const t25 = this.profile.vertexIndices[2 * r30 + 0], o24 = this.profile.vertexIndices[2 * r30 + 1], h25 = this.vertexBufferStart + this.profile.poleIndices[t25], n26 = this.vertexBufferStart + this.profile.poleIndices[o24];
      let a29 = i23 + t25, l32 = i23 + o24;
      for (let i24 = 0; i24 < this.numSegments - 1; ++i24) {
        const r31 = s23 + i24 * this.profile.vertices.length + t25, h26 = s23 + i24 * this.profile.vertices.length + o24;
        this.flip ? (e31(r31, l32, a29), e31(l32, r31, h26)) : (e31(a29, l32, r31), e31(h26, r31, l32)), a29 = r31, l32 = h26;
      }
      this.flip ? (e31(h25, l32, a29), h25 !== n26 && e31(h25, n26, l32)) : (e31(a29, l32, h25), h25 !== n26 && e31(l32, n26, h25));
    }
  }
};
var $4 = class {
  constructor(t24, e31, i23, s23, r30, o24 = K2) {
    this.options = o24, this._extrusionVertexCount = 0, this.numExtrusionProfiles = 0, this.numVerticesTotal = 0, this.numNormalsTotal = 0, this.numUVTotal = 0, this.profile = e31, this.path = t24, this.extruder = i23, this.startCap = s23, this.endCap = r30;
    const h25 = this.path.vertices.length - 2;
    this.numExtrusionProfiles = i23.numProfilesPerJoin() * h25 + 2, this.numVerticesTotal = e31.vertices.length * this.numExtrusionProfiles, this.numNormalsTotal = this.numVerticesTotal, this.startCap.vertexBufferStart = this.numVerticesTotal;
    const n26 = this.startCap.getNumVertices();
    this.numVerticesTotal += n26, this.numNormalsTotal += n26, this.endCap.vertexBufferStart = this.numVerticesTotal;
    const a29 = this.endCap.getNumVertices();
    this.numVerticesTotal += a29, this.numNormalsTotal += a29, this.pathVertexData = new Float32Array(1 * this.numVerticesTotal), this.profileRightAxisData = new Float32Array(4 * this.numVerticesTotal), this.profileUpAxisData = new Float32Array(4 * this.numVerticesTotal), this.profileVertexAndNormalData = new Float32Array(4 * this.numVerticesTotal), this.profile.hasUV() && this.options.generateUV && (this.numUVTotal = this.profile.uvs.length, this.uvData = new Float32Array(2 * this.numUVTotal)), this.originData = new Float32Array(3 * this.path.vertices.length), this._rebuildGeometry(), this.buildTopology();
  }
  emitVertex(t24, e31, i23, s23, r30) {
    if (this.profileRightAxisData[4 * this._extrusionVertexCount + 0] = e31.right[0], this.profileRightAxisData[4 * this._extrusionVertexCount + 1] = e31.right[1], this.profileRightAxisData[4 * this._extrusionVertexCount + 2] = e31.right[2], this.profileUpAxisData[4 * this._extrusionVertexCount + 0] = e31.up[0], this.profileUpAxisData[4 * this._extrusionVertexCount + 1] = e31.up[1], this.profileUpAxisData[4 * this._extrusionVertexCount + 2] = e31.up[2], this.profileVertexAndNormalData[4 * this._extrusionVertexCount + 0] = i23[0], this.profileVertexAndNormalData[4 * this._extrusionVertexCount + 1] = i23[1], this.profileVertexAndNormalData[4 * this._extrusionVertexCount + 2] = s23[0], this.profileVertexAndNormalData[4 * this._extrusionVertexCount + 3] = s23[1], this.pathVertexData[this._extrusionVertexCount] = t24, r30) {
      const e32 = this.path.vertices[t24];
      this.profileRightAxisData[4 * this._extrusionVertexCount + 3] = e32.rotationRight[0] * e32.maxStretchDistance, this.profileUpAxisData[4 * this._extrusionVertexCount + 3] = e32.rotationRight[1] * e32.maxStretchDistance;
    } else
      this.profileRightAxisData[4 * this._extrusionVertexCount + 3] = 0, this.profileUpAxisData[4 * this._extrusionVertexCount + 3] = 0;
    ++this._extrusionVertexCount;
  }
  emitCapVertex(t24, e31, i23, s23, r30, o24) {
    this.profileRightAxisData[4 * this._extrusionVertexCount + 0] = e31.right[0], this.profileRightAxisData[4 * this._extrusionVertexCount + 1] = e31.right[1], this.profileRightAxisData[4 * this._extrusionVertexCount + 2] = e31.right[2], this.profileUpAxisData[4 * this._extrusionVertexCount + 0] = e31.up[0], this.profileUpAxisData[4 * this._extrusionVertexCount + 1] = e31.up[1], this.profileUpAxisData[4 * this._extrusionVertexCount + 2] = e31.up[2], this.profileVertexAndNormalData[4 * this._extrusionVertexCount + 0] = i23[0], this.profileVertexAndNormalData[4 * this._extrusionVertexCount + 1] = i23[1], this.profileVertexAndNormalData[4 * this._extrusionVertexCount + 2] = s23[0], this.profileVertexAndNormalData[4 * this._extrusionVertexCount + 3] = s23[1], this.pathVertexData[this._extrusionVertexCount] = t24, this.profileRightAxisData[4 * this._extrusionVertexCount + 3] = r30, this.profileUpAxisData[4 * this._extrusionVertexCount + 3] = o24, ++this._extrusionVertexCount;
  }
  emitTriangle(t24, e31, i23) {
    this.vertexIndices.push(t24), this.vertexIndices.push(e31), this.vertexIndices.push(i23), this.pathVertexIndices.push(this.pathVertexData[t24]), this.pathVertexIndices.push(this.pathVertexData[e31]), this.pathVertexIndices.push(this.pathVertexData[i23]), this.normalIndices.push(t24), this.normalIndices.push(e31), this.normalIndices.push(i23);
  }
  _rebuildGeometry() {
    const t24 = (t25, e32, i23, s23, r30) => this.emitVertex(t25, e32, i23, s23, r30), e31 = (t25, e32, i23, s23, r30, o24) => this.emitCapVertex(t25, e32, i23, s23, r30, o24);
    this._extrusionVertexCount = 0;
    for (const i23 of this.path.vertices)
      this.originData[3 * i23.index + 0] = i23.pos[0], this.originData[3 * i23.index + 1] = i23.pos[1], this.originData[3 * i23.index + 2] = i23.pos[2];
    this.startCap.rebuildConnectingProfileGeometry(this.path.vertices[0], this.profile, e31);
    for (let i23 = 1; i23 < this.path.vertices.length - 1; ++i23)
      this.extruder.extrude(this.path.vertices[i23], this.profile, t24);
    if (this.endCap.rebuildConnectingProfileGeometry(this.path.vertices[this.path.vertices.length - 1], this.profile, e31), this.startCap.rebuildCapGeometry(this.path.vertices[0], e31), this.endCap.rebuildCapGeometry(this.path.vertices[this.path.vertices.length - 1], e31), this.profile.hasUV() && this.options.generateUV)
      for (let i23 = 0; i23 < this.profile.uvs.length; ++i23)
        this.uvData[2 * i23 + 0] = this.profile.uvs[i23], this.uvData[2 * i23 + 1] = 0;
  }
  buildTopology() {
    const t24 = this.profile.vertices.length, e31 = this.profile.numSegments, i23 = this.numExtrusionProfiles - 1;
    let s23 = 3 * (2 * (e31 * i23));
    this.startCap.indexBufferStart = s23, this.startCap.firstProfileVertexIndex = 0, s23 += this.startCap.getNumIndices(), this.endCap.indexBufferStart = s23, this.endCap.firstProfileVertexIndex = t24 * (this.numExtrusionProfiles - 1), this.vertexIndices = new Array(), this.normalIndices = new Array(), this.pathVertexIndices = new Array(), this.profile.hasUV() && this.options.generateUV && (this.uvIndices = new Array());
    for (let o24 = 0; o24 < e31; ++o24) {
      const e32 = this.profile.vertexIndices[2 * o24], s24 = this.profile.vertexIndices[2 * o24 + 1];
      for (let r31 = 0; r31 < i23; ++r31) {
        const i24 = r31 * t24 + e32, o25 = (r31 + 1) * t24 + e32, h25 = (r31 + 1) * t24 + s24, n26 = r31 * t24 + s24;
        this.emitTriangle(i24, o25, h25), this.emitTriangle(i24, h25, n26);
      }
    }
    const r30 = (t25, e32, i24) => this.emitTriangle(t25, e32, i24);
    this.startCap.buildTopology(this.path.vertices[0], r30), this.endCap.buildTopology(this.path.vertices[this.path.vertices.length - 1], r30);
  }
  onPathChanged() {
    this._rebuildGeometry();
  }
};
var tt = class {
  constructor(t24) {
    this.builder = t24;
  }
  get xform() {
    return this.builder.path.xform;
  }
  onPathChanged() {
    this.builder.onPathChanged();
  }
};
var et = class extends tt {
  constructor(t24) {
    super(t24), this.vertexAttributePosition = null, this.vertexAttributeNormal = null, this.vertexAttributeColor = null, this.vertexAttributePosition = new Float32Array(3 * this.builder.numVerticesTotal), this.vertexAttributeNormal = new Float32Array(3 * this.builder.numNormalsTotal), this.vertexAttributeColor = new Uint8Array(4), this.vertexAttributeColor[0] = 255, this.vertexAttributeColor[1] = 255, this.vertexAttributeColor[2] = 255, this.vertexAttributeColor[3] = 255;
  }
  bakeVertexColors(t24) {
    this.vertexAttributeColor[0] = 255 * t24[0], this.vertexAttributeColor[1] = 255 * t24[1], this.vertexAttributeColor[2] = 255 * t24[2], this.vertexAttributeColor[3] = 255 * (t24.length > 3 ? t24[3] : 1);
  }
  bake(t24) {
    this.size = t24;
    for (let e31 = 0; e31 < this.builder.numVerticesTotal; ++e31) {
      let i23 = this.builder.pathVertexData[e31];
      const s23 = 0 === i23 || i23 === this.builder.path.vertices.length - 1;
      i23 *= 3;
      const r30 = st;
      o2(r30, this.builder.originData[i23++], this.builder.originData[i23++], this.builder.originData[i23]);
      const o24 = 4 * e31, h25 = nt3, l32 = rt, u33 = at, d27 = lt, v23 = ut;
      let m19 = 0, g21 = 0;
      if (o2(d27, this.builder.profileRightAxisData[o24], this.builder.profileRightAxisData[o24 + 1], this.builder.profileRightAxisData[o24 + 2]), o2(v23, this.builder.profileUpAxisData[o24], this.builder.profileUpAxisData[o24 + 1], this.builder.profileUpAxisData[o24 + 2]), r10(l32, this.builder.profileVertexAndNormalData[o24] * t24[0], this.builder.profileVertexAndNormalData[o24 + 1] * t24[1]), s23)
        _(u33, v23, d27), m19 = this.builder.profileRightAxisData[o24 + 3] * t24[0], g21 = this.builder.profileUpAxisData[o24 + 3];
      else {
        const t25 = ot, e32 = ht;
        r10(t25, this.builder.profileRightAxisData[o24 + 3], this.builder.profileUpAxisData[o24 + 3]);
        const i24 = q4(t25);
        v3(t25, t25);
        const s24 = j6(l32, t25);
        if (Math.abs(s24) > i24) {
          r10(e32, -t25[1], t25[0]);
          const r31 = j6(l32, e32);
          l11(t25, t25, i24 * Math.sign(s24)), l11(e32, e32, r31), s7(l32, t25, e32);
        }
        o2(u33, 0, 0, 0);
      }
      o2(h25, d27[0] * l32[0] + v23[0] * l32[1], d27[1] * l32[0] + v23[1] * l32[1], d27[2] * l32[0] + v23[2] * l32[1]), this.vertexAttributePosition[3 * e31 + 0] = r30[0] + h25[0] + u33[0] * m19, this.vertexAttributePosition[3 * e31 + 1] = r30[1] + h25[1] + u33[1] * m19, this.vertexAttributePosition[3 * e31 + 2] = r30[2] + h25[2] + u33[2] * m19;
      const V8 = rt;
      r10(V8, this.builder.profileVertexAndNormalData[o24 + 2], this.builder.profileVertexAndNormalData[o24 + 3]), this.vertexAttributeNormal[3 * e31 + 0] = d27[0] * V8[0] + v23[0] * V8[1] + u33[0] * g21, this.vertexAttributeNormal[3 * e31 + 1] = d27[1] * V8[0] + v23[1] * V8[1] + u33[1] * g21, this.vertexAttributeNormal[3 * e31 + 2] = d27[2] * V8[0] + v23[2] * V8[1] + u33[2] * g21;
    }
  }
  createGeometryData() {
    const t24 = [[O2.POSITION, this.builder.vertexIndices], [O2.NORMAL, this.builder.normalIndices]], e31 = [[O2.POSITION, { size: 3, data: this.vertexAttributePosition, exclusive: true }], [O2.NORMAL, { size: 3, data: this.vertexAttributeNormal, exclusive: true }]];
    if (this.vertexAttributeColor) {
      const i23 = this.builder.vertexIndices.length;
      t24.push([O2.COLOR, new Array(i23).fill(0)]), e31.push([O2.COLOR, { size: 4, data: this.vertexAttributeColor }]);
    }
    return { vertexAttributes: e31, indices: t24 };
  }
  onPathChanged() {
    super.onPathChanged(), this.bake(this.size);
  }
  intersect(t24, e31, i23) {
    const s23 = this.builder.vertexIndices, r30 = { size: 3, data: this.vertexAttributePosition }, o24 = s23.length / 3;
    v6(t24, e31, 0, o24, s23, r30, void 0, void 0, i23);
  }
};
var it = class extends tt {
  constructor(t24, e31, i23, s23) {
    super(t24), this.sizeAttributeValue = e31, this.colorAttributeValue = i23, this.opacityAttributeValue = s23, this.vvData = null, this.baked = new et(t24), this.vvData = new Float32Array(4 * this.builder.path.vertices.length);
    for (let r30 = 0; r30 < this.builder.path.vertices.length; ++r30) {
      this.vvData[4 * r30 + 0] = e31, this.vvData[4 * r30 + 1] = i23, this.vvData[4 * r30 + 2] = s23;
      const t25 = 0 === r30 || r30 === this.builder.path.vertices.length - 1;
      this.vvData[4 * r30 + 3] = t25 ? 1 : 0;
    }
  }
  createGeometryData() {
    return { vertexAttributes: [[O2.POSITION, { size: 3, data: this.builder.originData, exclusive: true }], [O2.PROFILERIGHT, { size: 4, data: this.builder.profileRightAxisData, exclusive: true }], [O2.PROFILEUP, { size: 4, data: this.builder.profileUpAxisData, exclusive: true }], [O2.PROFILEVERTEXANDNORMAL, { size: 4, data: this.builder.profileVertexAndNormalData, exclusive: true }], [O2.FEATUREVALUE, { size: 4, data: this.vvData, exclusive: true }]], indices: [[O2.POSITION, this.builder.pathVertexIndices], [O2.PROFILERIGHT, this.builder.vertexIndices], [O2.PROFILEUP, this.builder.vertexIndices], [O2.PROFILEVERTEXANDNORMAL, this.builder.vertexIndices], [O2.FEATUREVALUE, this.builder.pathVertexIndices]] };
  }
};
var st = n2();
var rt = n12();
var ot = n12();
var ht = n12();
var nt3 = n2();
var at = n2();
var lt = n2();
var ut = n2();
var pt = n2();
var ft = E17();
var ct = e9();

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/PathTechnique.js
var R12 = /* @__PURE__ */ new Map([[O2.POSITION, 0], [O2.PROFILERIGHT, 1], [O2.PROFILEUP, 2], [O2.PROFILEVERTEXANDNORMAL, 3], [O2.FEATUREVALUE, 4]]);
var x16 = class extends p12 {
  constructor() {
    super(...arguments), this.ambient = r2(0.2, 0.2, 0.2), this.diffuse = r2(0.8, 0.8, 0.8), this.specular = r2(0, 0, 0), this.opacity = 1;
  }
};
var C11 = class extends e12 {
  initializeConfiguration(e31, o24) {
    o24.hasWebGL2Context = e31.rctx.type === r13.WEBGL2, o24.spherical = e31.viewingMode === l14.Global, o24.doublePrecisionRequiresObfuscation = i8(e31.rctx);
  }
  initializeProgram(e31) {
    return new o10(e31.rctx, C11.shader.get().build(this.configuration), R12);
  }
  initializePipeline() {
    const e31 = this.configuration.transparencyPassType, o24 = this.configuration, t24 = e31 === o8.NONE, i23 = e31 === o8.FrontFace;
    return W({ blending: o24.output !== h9.Color && o24.output !== h9.Alpha || !o24.transparent ? null : t24 ? c15 : A5(e31), culling: o24.hasSlicePlane && !o24.transparent && !(o24.doubleSidedMode === i7.None) && o9, depthTest: { func: l17(e31) }, depthWrite: t24 || i23 ? a12 : null, colorWrite: _5, stencilWrite: o24.hasOccludees ? e13 : null, stencilTest: o24.hasOccludees ? f10 : null, polygonOffset: t24 || i23 ? null : _6 });
  }
};
C11.shader = new t12(_7, () => import("./Path.glsl-LOHZUGLY.js"));
var E18 = class extends s9 {
  constructor() {
    super(...arguments), this.output = h9.Color, this.doubleSidedMode = i7.None, this.transparencyPassType = o8.NONE, this.spherical = false, this.receiveShadows = false, this.receiveAmbientOcclusion = false, this.vvSize = false, this.vvColor = false, this.vvOpacity = false, this.hasSlicePlane = false, this.transparent = false, this.hasOccludees = false, this.hasMultipassTerrain = false, this.cullAboveGround = false, this.doublePrecisionRequiresObfuscation = false;
  }
};
e4([e14({ count: h9.COUNT })], E18.prototype, "output", void 0), e4([e14({ count: i7.COUNT })], E18.prototype, "doubleSidedMode", void 0), e4([e14({ count: o8.COUNT })], E18.prototype, "transparencyPassType", void 0), e4([e14()], E18.prototype, "spherical", void 0), e4([e14()], E18.prototype, "receiveShadows", void 0), e4([e14()], E18.prototype, "receiveAmbientOcclusion", void 0), e4([e14()], E18.prototype, "vvSize", void 0), e4([e14()], E18.prototype, "vvColor", void 0), e4([e14()], E18.prototype, "vvOpacity", void 0), e4([e14()], E18.prototype, "hasSlicePlane", void 0), e4([e14()], E18.prototype, "transparent", void 0), e4([e14()], E18.prototype, "hasOccludees", void 0), e4([e14()], E18.prototype, "hasMultipassTerrain", void 0), e4([e14()], E18.prototype, "cullAboveGround", void 0), e4([e14()], E18.prototype, "doublePrecisionRequiresObfuscation", void 0), e4([e14({ constValue: d9.Disabled })], E18.prototype, "pbrMode", void 0), e4([e14({ constValue: true })], E18.prototype, "hasVvInstancing", void 0), e4([e14({ constValue: false })], E18.prototype, "useCustomDTRExponentForWater", void 0), e4([e14({ constValue: false })], E18.prototype, "useFillLights", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/PathMaterial.js
var E19 = class extends d10 {
  constructor(e31) {
    super(e31, new _15()), this.supportsEdges = true, this._vertexAttributeLocations = R12, this._configuration = new E18(), this._vertexBufferLayout = E19.getVertexBufferLayout(this.parameters);
  }
  getConfiguration(e31, t24) {
    return this._configuration.output = e31, this._configuration.vvSize = this.parameters.vvSizeEnabled, this._configuration.vvColor = this.parameters.vvColorEnabled, this._configuration.vvOpacity = this.parameters.vvOpacityEnabled, this._configuration.hasSlicePlane = this.parameters.hasSlicePlane, this._configuration.transparent = this.parameters.transparent, this._configuration.hasOccludees = this.parameters.hasOccludees, e31 !== h9.Color && e31 !== h9.Alpha || (this._configuration.doubleSidedMode = this.parameters.doubleSided && "normal" === this.parameters.doubleSidedType ? i7.View : this.parameters.doubleSided && "winding-order" === this.parameters.doubleSidedType ? i7.WindingOrder : i7.None, this._configuration.receiveShadows = this.parameters.receiveShadows, this._configuration.receiveAmbientOcclusion = !!t24.ssaoHelper.ready && this.parameters.receiveSSAO), this._configuration.transparencyPassType = t24.transparencyPassType, this._configuration.hasMultipassTerrain = t24.multipassTerrain.enabled, this._configuration.cullAboveGround = t24.multipassTerrain.cullAboveGround, this._configuration;
  }
  isVisibleForOutput(e31) {
    return e31 !== h9.Shadow && e31 !== h9.ShadowExludeHighlight && e31 !== h9.ShadowHighlight || this.parameters.castShadows;
  }
  isVisible() {
    return super.isVisible() && this.parameters.opacity > 0;
  }
  intersect(i23, a29, s23, o24, n26, h25, u33) {
    const l32 = i23;
    if (!i20(l32))
      return;
    const d27 = l32.path, p21 = [this.parameters.size[0], this.parameters.size[1]];
    if (this.parameters.vvSizeEnabled) {
      const t24 = this.parameters.vvSizeOffset, r30 = this.parameters.vvSizeFactor, i24 = this.parameters.vvSizeMinSize, a30 = this.parameters.vvSizeMaxSize, s24 = d27.sizeAttributeValue;
      p21[0] *= a3(t24[0] + s24 * r30[0], i24[0], a30[0]), p21[1] *= a3(t24[2] + s24 * r30[2], i24[2], a30[2]);
    }
    const m19 = Math.max(p21[0], p21[1]), f25 = i23.boundingInfo;
    if (t(f25))
      return void this._intersectTriangles(d27, p21, n26, h25, u33);
    const b26 = u8(f25.bbMin[0] - m19, f25.bbMin[1] - m19, f25.bbMin[2] - m19, f25.bbMax[0] + m19, f25.bbMax[1] + m19, f25.bbMax[2] + m19), v23 = [h25[0] - n26[0], h25[1] - n26[1], h25[2] - n26[2]], S18 = Math.sqrt(v23[0] * v23[0] + v23[1] * v23[1] + v23[2] * v23[2]), g21 = [S18 / v23[0], S18 / v23[1], S18 / v23[2]];
    O4(b26, n26, g21, o24.tolerance) && this._intersectTriangles(d27, p21, n26, h25, u33);
  }
  _intersectTriangles(e31, t24, r30, i23, a29) {
    e31.baked.size && e31.baked.size[0] === t24[0] && e31.baked.size[1] === t24[1] || e31.baked.bake(t24), e31.baked.intersect(r30, i23, a29);
  }
  computeAttachmentOrigin(e31, t24) {
    const r30 = e31.vertexAttributes;
    if (!r30)
      return null;
    const i23 = r30.get(O2.POSITION);
    return f9(i23, null, false, t24);
  }
  createBufferWriter() {
    return new w12(this._vertexBufferLayout);
  }
  requiresSlot(e31, t24) {
    switch (t24) {
      case h9.Shadow:
      case h9.ShadowHighlight:
      case h9.ShadowExludeHighlight:
        if (!this.parameters.castShadows)
          return false;
      case h9.Color:
      case h9.Alpha:
      case h9.Depth:
      case h9.Normal:
      case h9.Highlight:
      case h9.ObjectAndLayerIdColor:
        return e31 === (this.parameters.transparent ? E8.TRANSPARENT_MATERIAL : E8.OPAQUE_MATERIAL) || e31 === E8.DRAPED_MATERIAL;
      default:
        return false;
    }
  }
  createGLMaterial(e31) {
    return new O11(e31);
  }
  static getVertexBufferLayout(e31) {
    const t24 = T2().vec3f(O2.POSITION).vec4f(O2.PROFILERIGHT).vec4f(O2.PROFILEUP).vec4f(O2.PROFILEVERTEXANDNORMAL);
    return (e31.vvColorEnabled || e31.vvSizeEnabled || e31.vvOpacityEnabled) && t24.vec4f(O2.FEATUREVALUE), t24;
  }
};
var O11 = class extends t11 {
  _updateOccludeeState(e31) {
    e31.hasOccludees !== this._material.parameters.hasOccludees && this._material.setParameters({ hasOccludees: e31.hasOccludees });
  }
  _updateShadowState(e31) {
    (t(this.technique) || e31.shadowMap.enabled !== this.technique.configuration.receiveShadows) && this._material.setParameters({ receiveShadows: e31.shadowMap.enabled });
  }
  beginSlot(e31) {
    return this._output !== h9.Color && this._output !== h9.Alpha || (this._updateShadowState(e31), this._updateOccludeeState(e31)), this.ensureTechnique(C11, e31);
  }
};
var _15 = class extends x16 {
  constructor() {
    super(...arguments), this.doubleSided = false, this.doubleSidedType = "normal", this.receiveSSAO = true, this.receiveShadows = false, this.castShadows = true, this.hasSlicePlane = false, this.transparent = false, this.hasOccludees = false;
  }
};
var w12 = class {
  constructor(e31) {
    this.vertexBufferLayout = e31;
  }
  allocate(e31) {
    return this.vertexBufferLayout.createBuffer(e31);
  }
  elementCount(e31) {
    return e31.indices.get(O2.POSITION).length;
  }
  write(e31, t24, r30, i23, a29) {
    y11(O2.PROFILERIGHT, r30, i23, a29), y11(O2.PROFILEUP, r30, i23, a29), y11(O2.PROFILEVERTEXANDNORMAL, r30, i23, a29), this.vertexBufferLayout.hasField(O2.FEATUREVALUE) && y11(O2.FEATUREVALUE, r30, i23, a29), m7(r30, this.vertexBufferLayout, e31, t24, i23, a29);
  }
};
function y11(e31, t24, r30, a29) {
  if (t24.vertexAttributes.has(e31)) {
    const s23 = t24.vertexAttributes.get(e31), o24 = t24.indices.get(e31);
    e11(4 === s23.size);
    const n26 = r30.getField(e31, c11);
    if (!n26)
      throw new Error("unable to acquire view for " + e31);
    u14(o24, s23.data, n26, a29);
  }
}

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DPathSymbolLayer.js
var se3 = ["polyline"];
var ae3 = class extends y8 {
  constructor(e31, t24, r30, i23) {
    super(e31, t24, r30, i23), this._intrinsicSize = r12(1, 1), this._upVectorAlignment = "path", this._stencilWidth = 0.1, this.ensureDrapedStatus(false);
  }
  async doLoad() {
    const t24 = r(this.symbolLayer.width) ? this.symbolLayer.width : this.symbolLayer.height, r30 = r(this.symbolLayer.height) ? this.symbolLayer.height : t24;
    this._vvConvertOptions = { modelSize: [1, 1, 1], symbolSize: [t24, 1, r30], unitInMeters: this._context.renderCoordsHelper.unitInMeters, transformation: { anchor: [0, 0, 0], scale: [1, 1, 1], rotation: [0, 0, 0] }, supportedTypes: { size: true, color: true, opacity: true, rotation: false } }, this._context.renderer && this._context.renderer.visualVariables && this._context.renderer.visualVariables.length > 0 ? this._fastUpdates = P7(this._context.renderer, this._vvConvertOptions) : this._fastUpdates = { enabled: false };
    const a29 = this.symbolLayer.anchor || "center";
    this._upVectorAlignment = "path", "heading" === this.symbolLayer.profileRotation && (this._upVectorAlignment = "world");
    const l32 = this.symbolLayer.profile || "circle";
    switch (l32) {
      case "circle":
      default:
        this._profile = j12.circle(_e5);
        break;
      case "quad":
        this._profile = j12.rect();
    }
    let c31 = [0, 0];
    "center" !== a29 && (c31 = { left: [0.5, 0], right: [-0.5, 0], top: [0, -0.5], bottom: [0, 0.5] }[a29], this._profile.translate(c31[0], c31[1]));
    switch (this.symbolLayer.join || "simple") {
      case "round":
        this._extruder = new X3(0, ge3);
        break;
      case "bevel":
        this._extruder = new X3(0, 1);
        break;
      case "miter":
        this._extruder = new X3(0.8 * Math.PI, 1);
        break;
      default:
        this._extruder = new H4();
    }
    const p21 = this.symbolLayer.cap || "butt";
    switch (p21) {
      case "none":
        this._startCap = new W2(), this._endCap = new W2();
        break;
      case "butt":
      default:
        this._startCap = new Y3(this._profile, 0), this._endCap = new Y3(this._profile, 0, true);
        break;
      case "square":
        this._startCap = new Y3(this._profile, -0.5), this._endCap = new Y3(this._profile, 0.5, true);
        break;
      case "round": {
        const e31 = "quad" === l32;
        this._startCap = new Z({ profile: this._profile, flip: false, breakNormals: e31, subdivisions: ye4 }), this._endCap = new Z({ profile: this._profile, flip: true, breakNormals: e31, subdivisions: ye4 });
        break;
      }
    }
    const m19 = q(this.symbolLayer, "material", "color"), d27 = this._getCombinedOpacityAndColor(m19), f25 = e2(d27), u33 = d27[3], g21 = u33 < 1 || this.needsDrivenTransparentPass, y17 = { diffuse: f25, ambient: f25, opacity: u33, transparent: g21, hasVertexColors: false, hasSlicePlane: this._context.slicePlaneEnabled, castShadows: this.symbolLayer.castShadows, cullFace: g21 || "none" === p21 ? n13.None : n13.Back, offsetTransparentBackfaces: true };
    if (!this._drivenProperties.size && (r10(this._intrinsicSize, t24, r30), !V3(this._intrinsicSize[0]) || !V3(this._intrinsicSize[1])))
      throw new s4("graphics3dpathsymbollayer:invalid-size", "Symbol sizes may not be negative values");
    if (this._fastUpdates.enabled && this._fastUpdates.visualVariables.size || l11(this._intrinsicSize, this._intrinsicSize, 1 / this._context.renderCoordsHelper.unitInMeters), this._fastUpdates.enabled) {
      const e31 = { ...y17, ...this._fastUpdates.materialParameters, size: e10(this._intrinsicSize) };
      this._material = new E19(e31);
    } else
      y17.hasVertexColors = this._drivenProperties.color || this._drivenProperties.opacity, this._material = new C5(y17);
    this._material.setParameters({ usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: true }), this._context.stage.add(this._material);
  }
  destroy() {
    super.destroy(), this._context.stage.remove(this._material), this._material = null;
  }
  createGraphics3DGraphic(e31) {
    const t24 = e31.graphic;
    if (!this._validateGeometry(t24.geometry, se3, this.symbolLayer.type))
      return null;
    const r30 = this.setGraphicElevationContext(t24, new h16()), i23 = e31.renderingInfo;
    return this._createAs3DShape(t24, i23, r30, t24.uid);
  }
  layerOpacityChanged() {
    const e31 = q(this.symbolLayer, "material", "color"), t24 = this._getCombinedOpacity(e31), r30 = t24 < 1 || this.needsDrivenTransparentPass;
    this._material.setParameters({ opacity: t24, transparent: r30 });
  }
  layerElevationInfoChanged(e31, t24) {
    return this.updateGraphics3DGraphicElevationInfo(e31, t24, v10);
  }
  slicePlaneEnabledChanged() {
    return this._material.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled }), true;
  }
  physicalBasedRenderingChanged() {
    return this._material.setParameters({ usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: true }), true;
  }
  pixelRatioChanged() {
    return true;
  }
  applyRendererDiff(e31, t24) {
    for (const r30 in e31.diff) {
      if ("visualVariables" !== r30)
        return e20.Recreate_Symbol;
      if (!R9(this._fastUpdates, t24, this._vvConvertOptions))
        return e20.Recreate_Symbol;
      this._material.setParameters(this._fastUpdates.materialParameters);
    }
    return e20.Fast_Update;
  }
  getVertexData(e31) {
    let t24 = 0;
    const r30 = e31.paths, s23 = [], a29 = e31.spatialReference, o24 = this._context.elevationProvider.spatialReference, n26 = this._context.renderCoordsHelper.spatialReference;
    for (const i23 of r30)
      t24 += i23.length;
    const l32 = new Float64Array(3 * t24), h25 = new Float64Array(3 * t24), c31 = new Float64Array(3 * t24);
    let p21 = 0;
    for (const i23 of r30) {
      s23.push({ index: p21, numVertices: i23.length });
      for (const t25 of i23)
        l32[p21++] = t25[0], l32[p21++] = t25[1], l32[p21++] = e31.hasZ ? t25[2] : 0;
    }
    let m19 = true;
    return r(o24) && !a29.equals(o24) ? m19 = xn(l32, a29, 0, h25, o24, 0, t24) : this._copyVertices(l32, 0, h25, 0, t24), r(o24) && !o24.equals(n26) ? xn(h25, o24, 0, c31, n26, 0, t24) : this._copyVertices(h25, 0, c31, 0, t24), { pathVertexDataInfos: s23, vertexDataGS: l32, vertexDataES: h25, vertexDataRS: c31, projectionSuccess: m19, terrainElevation: 0 };
  }
  _copyVertices(e31, t24, r30, i23, s23) {
    t24 *= 3, i23 *= 3;
    for (let a29 = 0; a29 < s23; ++a29)
      r30[i23++] = e31[t24++], r30[i23++] = e31[t24++], r30[i23++] = e31[t24++];
  }
  _createAs3DShape(e31, t24, r30, s23) {
    const a29 = e31.geometry, o24 = new Array(), n26 = new Array(), l32 = new Array(), h25 = a29.spatialReference, p21 = a6(), m19 = this._context.renderCoordsHelper;
    pe4.spatialReference = h25;
    const d27 = this.getVertexData(a29);
    if (!d27.projectionSuccess)
      return this.logger.warn("PathSymbol3DLayer geometry failed to be created (failed to project geometry to view spatial reference)"), null;
    if (d27.pathVertexDataInfos.length > 0) {
      for (let a30 = 0; a30 < d27.pathVertexDataInfos.length; ++a30) {
        const f25 = d27.pathVertexDataInfos[a30], u33 = f25.index, g21 = f25.numVertices;
        if (g21 < 2)
          continue;
        if (r(this._context.clippingExtent) && (A2(p21), M3(p21, d27.vertexDataES, 3 * u33, g21), !R2(p21, this._context.clippingExtent)))
          continue;
        const y17 = [];
        for (let e32 = u33; e32 < u33 + 3 * g21; ) {
          const t25 = e32++, i23 = e32++, s24 = e32++, a31 = new B8();
          o2(a31.posGS, d27.vertexDataGS[t25], d27.vertexDataGS[i23], d27.vertexDataGS[s24]), o2(a31.posES, d27.vertexDataES[t25], d27.vertexDataES[i23], d27.vertexDataES[s24]);
          const o25 = m9(a31.posES, this._context.elevationProvider, r30, m19);
          o2(me5, d27.vertexDataRS[t25], d27.vertexDataRS[i23], d27.vertexDataRS[s24]), m19.setAltitude(me5, o25), o2(a31.pos, me5[0], me5[1], me5[2]), y17.push(a31);
        }
        const _20 = new z4(y17);
        oe3(_20, this._upVectorAlignment, this._context.renderCoordsHelper);
        const b26 = new $4(_20, this._profile, this._extruder, this._startCap, this._endCap);
        let v23 = null;
        if (this._fastUpdates.enabled) {
          const t25 = this._fastUpdates.visualVariables, r31 = t25.size ? v15(t25.size.field, e31) : 0, i23 = t25.color ? v15(t25.color.field, e31) : 0, s24 = t25.opacity ? v15(t25.opacity.field, e31) : 0;
          v23 = new it(b26, r31, i23, s24);
        } else {
          const e32 = [this._intrinsicSize[0], this._intrinsicSize[1]];
          this._drivenProperties.size && (e32[0] *= ne3(t24.size[0], "symbol-value" === t24.size[2] ? this.symbolLayer.height || 0 : t24.size[2], this.symbolLayer.width || 0), e32[1] *= ne3(t24.size[2], "symbol-value" === t24.size[0] ? this.symbolLayer.width || 0 : t24.size[0], this.symbolLayer.height || 0));
          let r31 = null;
          this._drivenProperties.color && (r31 = t24.color), this._drivenProperties.opacity && null != t24.opacity && (r31 = r31 ? [r31[0], r31[1], r31[2], t24.opacity] : [1, 1, 1, t24.opacity]);
          const i23 = new et(b26);
          i23.bake(e32), r31 && i23.bakeVertexColors(r31), v23 = i23;
        }
        const { vertexAttributes: x20, indices: w16 } = v23.createGeometryData(), P11 = this._context.stage.renderView._getObjectAndLayerIdColor({ graphicUid: s23, layerUid: this._context.layer.uid }), j14 = new r27(x20, w16, v23, h25, this._upVectorAlignment, this._stencilWidth, P11);
        o24.push(j14), n26.push(this._material), l32.push(v23.xform);
      }
      if (o24.length > 0) {
        const e32 = { layerUid: this._context.layer.uid, graphicUid: s23 }, t25 = new x7({ geometries: o24, materials: n26, transformations: l32, metadata: e32 }), i23 = new _8(this, t25, o24, null, null, he4, r30);
        return i23.alignedSampledElevation = d27.terrainElevation, i23.needsElevationUpdates = v10(r30.mode), i23;
      }
    } else
      0 !== a29.paths.length && a29.paths.some((e32) => e32.length > 0) || this.logger.warn("PathSymbol3DLayer geometry failed to be created (no paths were defined)");
    return null;
  }
};
function oe3(e31, i23, s23) {
  switch (i23) {
    case "world":
      for (const t24 of e31.vertices)
        u(de4, t24.pos, e31.offset), s23.worldUpAtPosition(de4, me5), t24.setFrameFromUpVector(me5), t24.computeRotationAxisAndAngleFromUpVector();
      break;
    case "path":
      u(de4, e31.vertices[0].pos, e31.offset), s23.worldUpAtPosition(de4, me5), J5(e31, me5);
      for (const i24 of e31.vertices) {
        const e32 = Math.sign(P(i24.frame.right, i24.vRight));
        _(i24.rotationFrame.up, i24.vRight, i24.vLeft), g(i24.rotationFrame.up, i24.rotationFrame.up, e32), z(i24.rotationFrame.up, i24.rotationFrame.up);
        const s24 = P(i24.rotationFrame.up, i24.frame.up), o24 = P(i24.rotationFrame.up, i24.frame.right);
        if (g(de4, i24.frame.up, -o24), g(fe4, i24.frame.right, s24), u(de4, de4, fe4), z(i24.rotationFrame.right, de4), G6(i24.rotationRight, i24.frame, i24.rotationFrame.right), j(de4, i24.vLeft), i24.rotationAngle = -e32 * (Math.PI - l3(P(de4, i24.vRight))), Math.abs(i24.rotationAngle) > 0) {
          const e33 = F(Math.cos(0.5 * i24.rotationAngle));
          r26(i24.miterStretch, 1 + (e33 - 1) * i24.rotationRight[0] * i24.rotationRight[0], (e33 - 1) * i24.rotationRight[0] * i24.rotationRight[1], (e33 - 1) * i24.rotationRight[0] * i24.rotationRight[1], 1 + (e33 - 1) * i24.rotationRight[1] * i24.rotationRight[1]);
        }
        const n26 = Math.PI - i24.rotationAngle;
        i24.maxStretchDistance = Math.abs(Math.min(i24.vLeftLength, i24.vRightLength) * F(Math.cos(0.5 * n26)));
      }
  }
}
function ne3(e31, t24, r30) {
  switch (e31) {
    case "symbol-value":
      return r30;
    case "proportional":
      return t24;
    default:
      return e31;
  }
}
function le3(e31, t24, r30, i23) {
  let s23 = 0;
  for (const a29 of e31.vertices)
    d11(a29.posES, r30, t24, i23, ue5), s23 += ue5.sampledElevation, u(me5, a29.pos, e31.offset), i23.setAltitude(me5, ue5.z), e3(a29.pos, me5, e31.offset);
  return e31.updatePathVertexInformation(), s23 / e31.vertices.length;
}
function he4(e31, t24, r30, i23) {
  const s23 = e31.stageObject, a29 = s23.geometryRecords;
  let o24 = 0;
  ce3.spatialReference = i23.spatialReference;
  for (const n26 of a29) {
    const e32 = n26.geometry;
    if (!i20(e32))
      continue;
    const a30 = e32.path, l32 = a30.builder.path, h25 = e32.geometrySR;
    pe4.spatialReference = h25, o24 += le3(l32, t24, r30, i23), "world" !== e32.upVectorAlignment && oe3(l32, e32.upVectorAlignment, i23), a30.onPathChanged(), e32.invalidateBoundingInfo(), s23.geometryVertexAttrsUpdated(n26);
  }
  return o24 / a29.length;
}
var ce3 = v8(0, 0, 0, null);
var pe4 = v8(0, 0, 0, null);
var me5 = n2();
var de4 = n11();
var fe4 = n11();
var ue5 = new j8();
var ge3 = 3;
var ye4 = 3;
var _e5 = 10;

// node_modules/@arcgis/core/views/3d/layers/support/uvUtils.js
function T8(t24, o24, r30, s23, n26 = 1) {
  if (r30.isGeographic && s23 === l14.Global) {
    const t25 = new Float64Array(o24.typedBuffer.length), e31 = 3 * o24.count, s24 = u5(r30);
    for (let r31 = 0; r31 < e31; r31 += 3)
      ee(o24.typedBuffer, r31, t25, r31, s24);
    o24 = T.fromTypedArray(t25);
  }
  r10(k6, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
  for (let e31 = 0; e31 < o24.count; e31++)
    o24.getVec(e31, E20), k6[0] = Math.min(k6[0], E20[0]), k6[1] = Math.min(k6[1], E20[1]);
  const c31 = k6[0] % n26, a29 = k6[1] % n26;
  P9[0] = k6[0] - c31, P9[1] = k6[1] - a29;
  for (let e31 = 0; e31 < o24.count; e31++)
    o24.getVec(e31, E20), t24.setValues(e31, (E20[0] - P9[0]) / n26, (E20[1] - P9[1]) / n26, P9[0] / n26, P9[1] / n26);
}
function M11(t24, o24, r30, f25, i23 = 1) {
  o2(Y4, 1, 0, 0), o2(_16, 0, 1, 0), o2(d21, 0, 0, 1), C12(y12, o24), O12(o24, F10) && S16(F10, Y4, _16, d21, r30, y12), r10(k6, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY), r10(A9, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
  for (let e31 = 0; e31 < o24.count; e31++) {
    o24.getVec(e31, E20);
    const t25 = P(Y4, E20), r31 = P(_16, E20);
    k6[0] = Math.min(k6[0], t25), k6[1] = Math.min(k6[1], r31), A9[0] = Math.max(A9[0], t25), A9[1] = Math.max(A9[1], r31);
  }
  const u33 = P(d21, y12);
  H5(v19, k6[0], k6[1], u33, Y4, _16, d21), H5(x17, A9[0], k6[1], u33, Y4, _16, d21), H5(G7, k6[0], A9[1], u33, Y4, _16, d21), e3(x17, x17, v19), g(x17, x17, 0.5), e3(G7, G7, v19), g(G7, G7, 0.5), u(v19, v19, x17), u(v19, v19, G7);
  const I12 = k6[0] % i23, p21 = k6[1] % i23;
  P9[0] = k6[0] - I12, P9[1] = k6[1] - p21;
  for (let e31 = 0; e31 < o24.count; e31++) {
    o24.getVec(e31, E20), t24.setValues(e31, (P(Y4, E20) - P9[0]) / i23, (P(_16, E20) - P9[1]) / i23, P9[0] / i23, P9[1] / i23);
    for (let t25 = 0; t25 < 3; t25++)
      f25.set(e31, t25, v19[t25]), f25.set(e31, t25 + 3, x17[t25]), f25.set(e31, t25 + 6, G7[t25]);
  }
}
var y12 = n2();
var E20 = n2();
var F10 = p7();
var Y4 = n2();
var _16 = n2();
var d21 = n2();
var k6 = n12();
var A9 = n12();
var P9 = n12();
var v19 = n2();
var x17 = n2();
var G7 = n2();
function O12(t24, o24) {
  const e31 = t24.count - 1;
  return b9(t24, o24, 0, Math.floor(e31 / 3), Math.floor(e31 * (2 / 3)));
}
function S16(o24, e31, r30, c31, m19, p21) {
  r(m19) ? (m19.basisMatrixAtPosition(p21, w13), o2(B9, w13[0], w13[1], w13[2]), o2(z5, w13[4], w13[5], w13[6]), o2(q10, w13[8], w13[9], w13[10])) : (o2(B9, 1, 0, 0), o2(z5, 0, 1, 0), o2(q10, 0, 0, 1));
  const N6 = Y(o24);
  P(N6, q10) < 0 && g(N6, N6, -1), r4(c31, N6);
  const l32 = P(N6, z5), h25 = P(N6, B9);
  Math.abs(l32) < Math.abs(h25) ? (q2(e31, B9, N6, -h25), z(e31, e31), _(r30, e31, N6), z(r30, r30), g(r30, r30, -1)) : (q2(r30, z5, N6, -l32), z(r30, r30), _(e31, r30, N6), z(e31, e31));
}
var w13 = e9();
var B9 = n2();
var z5 = n2();
var q10 = n2();
function C12(t24, o24) {
  o2(D6, 0, 0, 0);
  for (let e31 = 0; e31 < o24.count - 1; e31++)
    o24.getVec(e31, E20), u(D6, D6, E20);
  g(t24, D6, 1 / (o24.count - 1));
}
var D6 = n2();
function H5(t24, o24, e31, r30, n26, c31, a29) {
  o2(t24, o24 * n26[0] + e31 * c31[0] + r30 * a29[0], o24 * n26[1] + e31 * c31[1] + r30 * a29[1], o24 * n26[2] + e31 * c31[2] + r30 * a29[2]);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/PatternTechnique.js
var C13 = class extends e12 {
  initializeConfiguration(e31, t24) {
    t24.hasWebGL2Context = e31.rctx.type === r13.WEBGL2;
  }
  initializeProgram(e31) {
    return new o10(e31.rctx, C13.shader.get().build(this.configuration), w14);
  }
  _setPipelineState(e31, o24) {
    const r30 = this.configuration, i23 = e31 === o8.NONE, s23 = e31 === o8.FrontFace;
    return W({ blending: r30.output === h9.Color || r30.output === h9.Alpha ? i23 ? c15 : A5(e31) : null, culling: h12(r30.cullFace), depthTest: { func: l17(e31) }, depthWrite: i23 ? r30.writeDepth && a12 : E7(e31), colorWrite: _5, stencilWrite: r30.hasOccludees ? e13 : null, stencilTest: r30.hasOccludees ? o24 ? o11 : f10 : null, polygonOffset: i23 || s23 ? r30.polygonOffset && N3 : a13(r30.enableOffset) });
  }
  initializePipeline() {
    return this._occludeePipelineState = this._setPipelineState(this.configuration.transparencyPassType, true), this._setPipelineState(this.configuration.transparencyPassType, false);
  }
  getPipelineState(e31, t24) {
    return t24 ? this._occludeePipelineState : super.getPipelineState(e31, t24);
  }
};
C13.shader = new t12(T5, () => import("./Pattern.glsl-5Y5RCBPC.js"));
var N3 = { factor: 1, units: 1 };
var x18 = class extends s9 {
  constructor() {
    super(...arguments), this.output = h9.Color, this.cullFace = n13.None, this.transparencyPassType = o8.NONE, this.hasSlicePlane = false, this.hasVertexColors = false, this.polygonOffset = false, this.writeDepth = true, this.hasOccludees = false, this.enableOffset = true, this.hasMultipassTerrain = false, this.cullAboveGround = false;
  }
};
e4([e14({ count: h9.COUNT })], x18.prototype, "output", void 0), e4([e14({ count: n13.COUNT })], x18.prototype, "cullFace", void 0), e4([e14({ count: a19.COUNT })], x18.prototype, "style", void 0), e4([e14({ count: o8.COUNT })], x18.prototype, "transparencyPassType", void 0), e4([e14()], x18.prototype, "hasSlicePlane", void 0), e4([e14()], x18.prototype, "hasVertexColors", void 0), e4([e14()], x18.prototype, "polygonOffset", void 0), e4([e14()], x18.prototype, "writeDepth", void 0), e4([e14()], x18.prototype, "hasOccludees", void 0), e4([e14()], x18.prototype, "patternSpacing", void 0), e4([e14()], x18.prototype, "lineWidth", void 0), e4([e14()], x18.prototype, "enableOffset", void 0), e4([e14()], x18.prototype, "draped", void 0), e4([e14()], x18.prototype, "hasMultipassTerrain", void 0), e4([e14()], x18.prototype, "cullAboveGround", void 0);
var w14 = /* @__PURE__ */ new Map([[O2.POSITION, 0], [O2.COLOR, 3], [O2.UVMAPSPACE, 4], [O2.BOUNDINGRECT, 5]]);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/PatternMaterial.js
var y13 = class extends d10 {
  constructor(t24) {
    super(t24, new j13()), this.supportsEdges = true, this._vertexAttributeLocations = w14, this._configuration = new x18();
  }
  getConfiguration(t24, e31) {
    return this._configuration.output = t24, this._configuration.cullFace = this.parameters.cullFace, this._configuration.hasVertexColors = this.parameters.hasVertexColors, this._configuration.hasSlicePlane = this.parameters.hasSlicePlane, this._configuration.polygonOffset = this.parameters.polygonOffset, this._configuration.writeDepth = this.parameters.writeDepth, this._configuration.style = this.parameters.style, this._configuration.patternSpacing = this.parameters.patternSpacing, this._configuration.lineWidth = this.parameters.lineWidth, this._configuration.draped = this.parameters.draped, this._configuration.transparencyPassType = e31.transparencyPassType, this._configuration.enableOffset = e31.camera.relativeElevation < S4, this._configuration.hasMultipassTerrain = e31.multipassTerrain.enabled, this._configuration.cullAboveGround = e31.multipassTerrain.cullAboveGround, this._configuration;
  }
  intersect(t24, e31, r30, i23, s23, a29, o24) {
    x6(t24, e31, i23, s23, a29, void 0, o24);
  }
  requiresSlot(t24, e31) {
    if (e31 === h9.Color || e31 === h9.Alpha || e31 === h9.Highlight || e31 === h9.Depth && this.parameters.writeLinearDepth) {
      if (t24 === E8.DRAPED_MATERIAL)
        return true;
      if (e31 === h9.Highlight)
        return t24 === E8.OPAQUE_MATERIAL;
      return t24 === (this.parameters.writeDepth ? E8.TRANSPARENT_MATERIAL : E8.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL);
    }
    return false;
  }
  createGLMaterial(t24) {
    return new E21(t24);
  }
  createBufferWriter() {
    const t24 = T2().vec3f(O2.POSITION).vec4u8(O2.COLOR).vec4f(O2.UVMAPSPACE);
    return this.parameters.draped || t24.mat3f(O2.BOUNDINGRECT), new R13(t24);
  }
};
var E21 = class extends t11 {
  _updateParameters(t24) {
    return this.ensureTechnique(C13, t24);
  }
  _updateOccludeeState(t24) {
    t24.hasOccludees !== this._material.parameters.hasOccludees && this._material.setParameters({ hasOccludees: t24.hasOccludees });
  }
  beginSlot(t24) {
    return this._output !== h9.Color && this._output !== h9.Alpha || this._updateOccludeeState(t24), this._updateParameters(t24);
  }
};
var R13 = class extends v11 {
  write(t24, a29, o24, n26, c31) {
    for (const h25 of this.vertexBufferLayout.fieldNames) {
      const a30 = o24.vertexAttributes.get(h25), l32 = o24.indices.get(h25);
      if (a30 && l32)
        switch (h25) {
          case O2.POSITION: {
            e11(3 === a30.size);
            const e31 = n26.getField(h25, i5);
            e31 && y4(l32, a30.data, t24, e31, c31);
            break;
          }
          case O2.COLOR: {
            e11(3 === a30.size || 4 === a30.size);
            const t25 = n26.getField(h25, x4);
            t25 && h13(l32, a30.data, a30.size, t25, c31);
            break;
          }
          case O2.UVMAPSPACE: {
            e11(4 === a30.size);
            const t25 = n26.getField(h25, c11);
            t25 && u14(l32, a30.data, t25, c31);
            break;
          }
          case O2.BOUNDINGRECT: {
            e11(9 === a30.size);
            const r30 = n26.getField(h25, l12);
            r30 && this.writeBoundingRect(l32, a30.data, t24, r30, c31);
            break;
          }
        }
    }
  }
  writeBoundingRect(t24, e31, r30, i23, s23) {
    const a29 = r30, o24 = i23.typedBuffer, n26 = i23.typedBufferStride, c31 = t24.length;
    s23 *= n26;
    for (let h25 = 0; h25 < c31; ++h25) {
      const r31 = 9 * t24[h25], i24 = e31[r31], c32 = e31[r31 + 1], l32 = e31[r31 + 2];
      o24[s23] = a29[0] * i24 + a29[4] * c32 + a29[8] * l32 + a29[12], o24[s23 + 1] = a29[1] * i24 + a29[5] * c32 + a29[9] * l32 + a29[13], o24[s23 + 2] = a29[2] * i24 + a29[6] * c32 + a29[10] * l32 + a29[14];
      for (let t25 = 3; t25 < 9; ++t25)
        o24[s23 + t25] = e31[r31 + t25];
      s23 += n26;
    }
  }
};
var j13 = class extends h11 {
  constructor() {
    super(...arguments), this.color = r8(1, 1, 1, 1), this.writeDepth = true, this.writeLinearDepth = false, this.hasVertexColors = false, this.polygonOffset = false, this.hasSlicePlane = false, this.cullFace = n13.None, this.hasOccludees = false, this.style = a19.Cross, this.patternSpacing = 10, this.lineWidth = 1, this.draped = true;
  }
};

// node_modules/@arcgis/core/views/3d/layers/support/patternUtils.js
function f24(r30, e31, t24) {
  return g17(u29(r30), e31, t24);
}
function u29(r30) {
  return r30 && r30.pattern || null;
}
function g17(t24, a29, o24) {
  return r(t24) ? "none" === t24.style || "solid" === t24.style ? ("none" === t24.style && (a29.color = r8(0, 0, 0, 0), a29.transparent = true), new m10(a29)) : (a29.style = p19(t24.style), a29.draped = o24.isDraped, new y13(a29)) : new m10(a29);
}
function p19(r30) {
  switch (r30) {
    case "horizontal":
      return a19.Horizontal;
    case "vertical":
      return a19.Vertical;
    case "cross":
      return a19.Cross;
    case "forward-diagonal":
      return a19.ForwardDiagonal;
    case "backward-diagonal":
      return a19.BackwardDiagonal;
    case "diagonal-cross":
      return a19.DiagonalCross;
    default:
      return;
  }
}
function d22(r30) {
  return r30.material instanceof y13 && !r30.material.parameters.draped;
}
function y14(r30, e31) {
  if (d22(r30)) {
    const n26 = r30.geometry.vertexAttributes, l32 = n26.get(O2.POSITION).data, m19 = n26.get(O2.UVMAPSPACE).data, c31 = n26.get(O2.BOUNDINGRECT).data;
    M11(c11.fromTypedArray(m19), T.fromTypedArray(l32), e31, a8.fromTypedArray(c31));
  }
}
function w15(r30, e31, t24, a29) {
  const o24 = p13(r30, e31, t24, a29), i23 = r30.stageObject.geometryRecords;
  for (let n26 = 0; n26 < i23.length; n26++)
    y14(i23[n26], a29);
  return o24;
}

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DPolygonFillSymbolLayer.js
var H6 = ["polyline", "polygon", "extent"];
var W3 = class extends y8 {
  constructor(e31, t24, r30, i23) {
    super(e31, t24, r30, i23), this._needsUV = false, this._hasOutline = false;
  }
  async doLoad() {
  }
  _ensureMaterials() {
    this._ensureFillMaterial(), this._ensureOutlineMaterial();
  }
  _ensureFillMaterial() {
    if (r(this._material))
      return;
    const e31 = q(this.symbolLayer, "material", "color"), i23 = this._getCombinedOpacityAndColor(e31);
    this._material = f24(this.symbolLayer, { color: i23, transparent: i23[3] < 1 || this.needsDrivenTransparentPass, polygonOffset: false, hasVertexColors: true, writeLinearDepth: true, hasSlicePlane: this._context.slicePlaneEnabled }, { isDraped: this.draped }), this._needsUV = this._material instanceof y13, this._context.stage.add(this._material);
  }
  _ensureOutlineMaterial() {
    const e31 = this.symbolLayer.outline;
    if (r(this._outlineMaterial) || !this._isValidOutline(e31))
      return;
    this._hasOutline = true;
    const r30 = (t24) => {
      const r31 = a18(e31.pattern);
      return new H2({ width: t24, color: this._getOutlineColor(), hasPolygonOffset: true, hasSlicePlane: this._context.slicePlaneEnabled, isClosed: true, stipplePattern: r31, stippleScaleWithLineWidth: true, cap: n20(e31.patternCap || "butt") });
    };
    this._outlineMaterial = r30(u4(e31.size)), this._context.stage.add(this._outlineMaterial);
  }
  _isValidOutline(e31) {
    return r(e31) && e31.size && e31.size > 0 && r(e31.color) && (t(e31.pattern) || "style" !== e31.pattern.type || "none" !== e31.pattern.style);
  }
  destroy() {
    super.destroy(), this._context.stage.remove(this._material), this._material = null, this._context.stage.remove(this._outlineMaterial), this._outlineMaterial = null;
  }
  createGraphics3DGraphic(e31) {
    const t24 = e31.graphic;
    if (!this._validateGeometry(t24.geometry, H6, this.symbolLayer.type))
      return null;
    const r30 = this._getVertexOpacityAndColor(e31.renderingInfo, 255), i23 = this.setGraphicElevationContext(t24, new h16());
    return this.ensureDrapedStatus("on-the-ground" === i23.mode), this._ensureMaterials(), this.draped ? this._createAsOverlay(t24, r30) : this._createAs3DShape(t24, r30, i23);
  }
  layerOpacityChanged() {
    if (r(this._material)) {
      const e31 = this._material.parameters.color, t24 = q(this.symbolLayer, "material", "color"), i23 = this._getCombinedOpacity(t24);
      this._material.setParameters({ color: [e31[0], e31[1], e31[2], i23], transparent: i23 < 1 || this.needsDrivenTransparentPass });
    }
    if (r(this._outlineMaterial)) {
      const e31 = this._outlineMaterial.parameters.color;
      this._outlineMaterial.setParameters({ color: [e31[0], e31[1], e31[2], this._getOutlineOpacity()] });
    }
  }
  layerElevationInfoChanged(e31, t24, r30) {
    const i23 = this._elevationContext.mode, o24 = p10(W3.elevationModeChangeTypes, r30, i23);
    if (o24 !== x9.UPDATE)
      return o24;
    const n26 = g9(i23);
    return this.updateGraphics3DGraphicElevationInfo(e31, t24, () => n26);
  }
  slicePlaneEnabledChanged() {
    if (r(this._material) && this._material.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled }), r(this._outlineMaterial)) {
      const e31 = { hasSlicePlane: this._context.slicePlaneEnabled };
      this._outlineMaterial.setParameters(e31);
    }
    return true;
  }
  physicalBasedRenderingChanged() {
    return true;
  }
  pixelRatioChanged() {
    return true;
  }
  _createAs3DShape(e31, t24, r30) {
    var _a;
    const o24 = u25(e31.geometry);
    if (t(o24))
      return null;
    const n26 = e24(o24, this._context.elevationProvider, this._context.renderCoordsHelper, r30), a29 = new z6(n26, t24, this._context.layer.uid, e31.uid), s23 = a29.renderData.position.length / 3;
    if (this._needsUV && (a29.uvMapSpace = new Float32Array(4 * s23), a29.boundingRect = new Float64Array(9 * s23)), a29.objectAndLayerIdColor = (_a = this._context.stage.renderView) == null ? void 0 : _a._getObjectAndLayerIdColor({ graphicUid: a29.graphicsUid, layerUid: a29.layerUid }), this._createAs3DShapeFill(a29), this._hasOutline && this._createAs3DShapeOutline(a29), this._logGeometryCreationWarnings(a29.renderData, o24.rings, "rings", "FillSymbol3DLayer"), 0 === a29.outGeometries.length)
      return null;
    this._needsUV && M11(c11.fromTypedArray(a29.uvMapSpace), T.fromTypedArray(a29.renderData.position), this._context.renderCoordsHelper, a8.fromTypedArray(a29.boundingRect));
    const l32 = new x7({ geometries: a29.outGeometries, materials: a29.outMaterials, transformations: a29.outTransforms, castShadow: false, metadata: { layerUid: this._context.layer.uid, graphicUid: e31.uid } }), c31 = new _8(this, l32, a29.outGeometries, null, null, w15, r30);
    return c31.alignedSampledElevation = a29.renderData.sampledElevation, c31.needsElevationUpdates = g9(r30.mode), c31;
  }
  _createAs3DShapeFill(e31) {
    const r30 = e31.renderData.polygons;
    for (const { position: i23, mapPosition: n26, holeIndices: l32, index: c31, count: d27 } of r30) {
      if (r(this._context.clippingExtent) && (A2(k7), M3(k7, n26), !R2(k7, this._context.clippingExtent)))
        continue;
      const r31 = x5(n26, l32, 3);
      if (0 === r31.length)
        continue;
      const m19 = n19({ indices: r31, attributeData: { position: i23, color: e31.color, mapPosition: n26, uvMapSpace: this._needsUV ? new Float32Array(e31.uvMapSpace.buffer, 4 * c31 * e31.uvMapSpace.BYTES_PER_ELEMENT, 4 * d27) : null, boundingRect: this._needsUV ? new Float64Array(e31.boundingRect.buffer, 9 * c31 * e31.boundingRect.BYTES_PER_ELEMENT, 9 * d27) : null, objectAndLayerIdColor: e31.objectAndLayerIdColor } });
      e31.outGeometries.push(m19), e31.outMaterials.push(e(this._material)), e31.outTransforms.push(o3);
    }
  }
  _createAs3DShapeOutline(e31) {
    if (!this._hasOutline)
      return;
    const r30 = e31.renderData.outlines;
    for (let i23 = 0; i23 < r30.length; ++i23) {
      const { mapPosition: n26, position: a29 } = r30[i23];
      if (r(this._context.clippingExtent) && (A2(k7), M3(k7, n26), !R2(k7, this._context.clippingExtent)))
        continue;
      const l32 = m11({ overlayInfo: null, removeDuplicateStartEnd: true, attributeData: { position: a29, mapPosition: n26 } }, e31.objectAndLayerIdColor), c31 = l32.vertexAttributes.get(O2.POSITION);
      c31.data === a29 && (c31.data = new Float64Array(a29)), e31.outGeometries.push(l32), e31.outMaterials.push(e(this._outlineMaterial)), e31.outTransforms.push(o3);
    }
  }
  _createAsOverlay(e31, r30) {
    var _a;
    const n26 = u25(e31.geometry);
    if (t(n26))
      return null;
    e(this._material).renderPriority = this._renderPriority + this._renderPriorityStep / 2, r(this._outlineMaterial) && (this._outlineMaterial.renderPriority = this._renderPriority);
    const a29 = r20(n26, this._context.overlaySR), s23 = new Y5(a29, r30, this._context.layer.uid, e31.uid), l32 = s23.renderData.position.length / 3;
    return this._needsUV && (s23.uvMapSpace = new Float32Array(4 * l32)), s23.outBoundingBox = A2(), s23.objectAndLayerIdColor = (_a = this._context.stage.renderView) == null ? void 0 : _a._getObjectAndLayerIdColor({ graphicUid: s23.graphicsUid, layerUid: s23.layerUid }), this._createAsOverlayFill(s23), this._hasOutline && this._createAsOverlayOutline(s23), this._logGeometryCreationWarnings(s23.renderData, n26.rings, "rings", "FillSymbol3DLayer"), 0 === s23.outGeometries.length ? null : (this._needsUV && T8(c11.fromTypedArray(s23.uvMapSpace), T.fromTypedArray(s23.renderData.position), this._context.overlaySR, this._context.graphicsCoreOwner.view.state.viewingMode), new l25(this, s23.outGeometries, s23.outBoundingBox, this._context.drapeSourceRenderer));
  }
  _createAsOverlayFill(e31) {
    const t24 = e31.renderData.polygons;
    for (const { position: r30, holeIndices: i23, index: n26, count: s23 } of t24) {
      if (A2(k7), M3(k7, r30), !R2(k7, this._context.clippingExtent))
        continue;
      const t25 = x5(r30, i23, 3);
      if (0 === t25.length)
        continue;
      f4(e31.outBoundingBox, k7);
      const c31 = n19({ indices: t25, attributeData: { position: r30, color: e31.color, uvMapSpace: this._needsUV ? new Float32Array(e31.uvMapSpace.buffer, 4 * n26 * e31.uvMapSpace.BYTES_PER_ELEMENT, 4 * s23) : null, objectAndLayerIdColor: e31.objectAndLayerIdColor } }), m19 = new T4(c31, e(this._material), { layerUid: e31.layerUid, graphicUid: e31.graphicsUid }), y17 = k7;
      r5(m19.boundingSphere, 0.5 * (y17[0] + y17[3]), 0.5 * (y17[1] + y17[4]), 0, 0.5 * Math.sqrt((y17[3] - y17[0]) * (y17[3] - y17[0]) + (y17[4] - y17[1]) * (y17[4] - y17[1]))), e31.outGeometries.push(m19);
    }
  }
  _createAsOverlayOutline(e31) {
    if (!this._hasOutline)
      return;
    const t24 = e31.renderData.outlines;
    for (let r30 = 0; r30 < t24.length; ++r30) {
      const { position: i23 } = t24[r30];
      if (A2(k7), M3(k7, i23), !R2(k7, this._context.clippingExtent))
        continue;
      f4(e31.outBoundingBox, k7);
      const n26 = m11({ overlayInfo: { spatialReference: this._context.overlaySR, renderCoordsHelper: this._context.renderCoordsHelper }, removeDuplicateStartEnd: true, attributeData: { position: i23 } }, e31.objectAndLayerIdColor), a29 = new T4(n26, e(this._outlineMaterial), { layerUid: e31.layerUid, graphicUid: e31.graphicsUid }), s23 = k7;
      r5(a29.boundingSphere, 0.5 * (s23[0] + s23[3]), 0.5 * (s23[1] + s23[4]), 0, 0.5 * Math.sqrt((s23[3] - s23[0]) * (s23[3] - s23[0]) + (s23[4] - s23[1]) * (s23[4] - s23[1]))), e31.outGeometries.push(a29);
    }
  }
  _getOutlineOpacity() {
    const e31 = q(this.symbolLayer, "outline", "color");
    return (this.draped ? 1 : this._getLayerOpacity()) * (r(e31) ? e31.a : 0);
  }
  _getOutlineColor() {
    const i23 = q(this.symbolLayer, "outline", "color"), o24 = this._getOutlineOpacity();
    return B4(r(i23) ? l4.toUnitRGB(i23) : null, o24);
  }
  test() {
    return { ...super.test(), createAsOverlay: (e31, t24) => this._createAsOverlay(e31, t24), createAs3DShape: (e31, t24, r30) => this._createAs3DShape(e31, t24, r30) };
  }
};
W3.elevationModeChangeTypes = { definedChanged: x9.RECREATE, staysOnTheGround: x9.NONE, onTheGroundChanged: x9.RECREATE };
var k7 = a6();
var z6 = class extends c23 {
  constructor(e31, t24, r30, i23) {
    super(e31, r30, i23), this.color = t24;
  }
};
var Y5 = class extends c23 {
  constructor(e31, t24, r30, i23) {
    super(e31, r30, i23), this.color = t24;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/TextRenderParameters.js
var s18 = class {
  constructor(o24) {
    this.definition = o24, this.key = JSON.stringify(o24), this.haloSize = Math.round(o24.halo.size), this.textStyle = this._colorToRGBA(o24.color), this.haloStyle = this._colorToRGB(o24.halo.color), this.backgroundStyle = 0 !== o24.background.color[3] ? this._colorToRGBA(o24.background.color) : null;
  }
  fontString(o24) {
    const r30 = this.definition.font;
    return `${r30.style} ${r30.weight} ${o24}px ${r30.family}, sans-serif`;
  }
  _colorToRGB(o24) {
    return `rgb(${o24.slice(0, 3).map((o25) => Math.floor(255 * o25)).toString()})`;
  }
  _colorToRGBA(o24) {
    return `rgba(${o24.slice(0, 3).map((o25) => Math.floor(255 * o25)).toString()},${o24[3]})`;
  }
  static async fromSymbol(a29, c31 = 1) {
    const g21 = q(a29, "material", "color"), f25 = b(g21, l10, l4.toUnitRGBA), d27 = b(a29.size, 12, u4), h25 = a29.lineHeight, m19 = r(a29.background) ? l4.toUnitRGBA(a29.background.color) : l10, u33 = { family: b(a29.font, "sans-serif", (o24) => o24.family), decoration: b(a29.font, "none", (o24) => o24.decoration), weight: b(a29.font, "normal", (o24) => o24.weight), style: b(a29.font, "normal", (o24) => o24.style) }, b26 = a29.halo, y17 = r(b26) && r(b26.color) && b26.size > 0 ? { size: u4(b26.size), color: l4.toUnitRGBA(b26.color) } : { size: 0, color: l10 }, p21 = new s18({ color: f25, size: d27, background: { color: m19, padding: r(a29.background) ? [0.65 * d27, 0.5 * d27] : [0, 0], borderRadius: r(a29.background) ? d27 * (6 / 16) : 0 }, lineSpacingFactor: h25, font: u33, halo: y17, pixelRatio: c31 }), S18 = p21.fontString(d27);
    try {
      await document.fonts.load(S18);
    } catch (R16) {
      s3.getLogger("esri.views.3d.webgl-engine.lib.TextRenderParameters").warnOnce(`Failed to preload font '${S18}'. Some text symbology may be rendered using the default browser font.`);
    }
    return p21;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/TextTextureFactory.js
var i21 = class {
  constructor(e31, t24, n26) {
    this._renderer = new s16(e31, t24, n26);
  }
  get key() {
    return this._renderer.key;
  }
  get baselineAnchorY() {
    return 1 - this._renderer.firstRenderedBaselinePosition / this._renderer.renderedHeight;
  }
  get displayWidth() {
    return this._renderer.displayWidth;
  }
  get displayHeight() {
    return this._renderer.displayHeight;
  }
  create() {
    const r30 = o19(d23, this._renderer.renderedWidth, this._renderer.renderedHeight), i23 = r30.getContext("2d");
    return i23.save(), this._renderer.render(i23, 0, 0), i23.restore(), new L2(r30, { wrap: { s: D3.CLAMP_TO_EDGE, t: D3.CLAMP_TO_EDGE }, noUnpackFlip: false, mipmap: true, preMultiplyAlpha: true, powerOfTwoResizeMode: c14.PAD });
  }
};
var d23 = { canvas: null };

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DTextSymbolLayer.js
var C14 = [0, 0, 1];
var R14 = class extends y8 {
  constructor(e31, t24, r30, n26) {
    super(e31, t24, r30, n26), this._elevationOptions = { supportsOffsetAdjustment: true, supportsOnTheGround: false }, this.ensureDrapedStatus(false);
  }
  async doLoad() {
    if (!this._drivenProperties.size) {
      const t24 = S5(this.symbolLayer.size);
      if (t24)
        throw new s4("graphics3dtextsymbollayer:invalid-size", t24);
    }
    await this._createTextRenderParameters();
  }
  async _createTextRenderParameters() {
    const e31 = this._context.graphicsCoreOwner.view.state.pixelRatio;
    this._textRenderParameters = await s18.fromSymbol(this.symbolLayer, e31);
  }
  destroy() {
    super.destroy();
  }
  createGraphics3DGraphic(e31) {
    const n26 = e31.graphic, s23 = d17(n26.geometry);
    if (t(s23))
      return this.logger.warn(`unsupported geometry type for text symbol: ${n26.geometry.type}`), null;
    const i23 = this.symbolLayer.text;
    if (t(i23) || "" === i23)
      return null;
    const o24 = i3(this.symbol) && this.symbol.hasVisibleVerticalOffset() ? this.symbol.verticalOffset : null;
    if (r(o24) && !l9(this.symbolLayer))
      return this.logger.errorOncePerTick(`Callouts and vertical offset on text symbols are currently only supported with 'center' horizontal alignment (not with '${this.symbolLayer.horizontalAlignment}' alignment)`), null;
    const a29 = { ...A10, verticalOffset: o24, horizontalPlacement: this.symbolLayer.horizontalAlignment, verticalPlacement: f20(this.symbolLayer.verticalAlignment) };
    return this._createAs3DShape(n26, s23, i23, a29);
  }
  createLabel(e31, r30, n26, s23) {
    const i23 = e31.graphic, o24 = d17(i23.geometry);
    if (t(o24))
      return this.logger.warn(`unsupported geometry type for label: ${i23.geometry.type}`), null;
    const a29 = r30.text;
    return !a29 || /^\s+$/.test(a29) ? null : this._createAs3DShape(i23, o24, a29, r30, n26, s23);
  }
  setGraphicElevationContext(e31, t24, r30 = 0) {
    const n26 = super.setGraphicElevationContext(e31, t24);
    return n26.addOffsetRenderUnits(r30), n26;
  }
  layerOpacityChanged() {
    return this.logger.warn("layer opacity change not yet implemented in Graphics3DTextSymbolLayer"), false;
  }
  layerElevationInfoChanged(e31, t24) {
    return U8(e31, t24, (e32, t25) => {
      this.updateGraphicElevationContext(t25, e32);
    }), x9.UPDATE;
  }
  slicePlaneEnabledChanged(e31, t24) {
    return U8(e31, t24, (e32) => {
      for (const t25 of e32.stageObject.geometryRecords)
        t25.material.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled });
    }), true;
  }
  physicalBasedRenderingChanged() {
    return true;
  }
  pixelRatioChanged() {
    return false;
  }
  updateGraphicElevationContext(e31, t24) {
    this.setGraphicElevationContext(e31, t24.elevationContext, t24.metadata.elevationOffset), t24.needsElevationUpdates = g9(t24.elevationContext.mode) || "absolute-height" === t24.elevationContext.mode;
  }
  _defaultElevationInfoNoZ() {
    return G8;
  }
  _createAs3DShape(e31, l32, c31, m19, f25, g21) {
    const y17 = this.setGraphicElevationContext(e31, new h16(), m19.elevationOffset), x20 = "polyline" === q(e31.geometry, "type"), b26 = e31.uid;
    let P11 = null, O13 = null;
    if (t(g21)) {
      const e32 = c25(m19.horizontalPlacement);
      P11 = new i21(c31, e32, this._textRenderParameters);
      let n26 = null;
      if (r(this._context.sharedResources.textures)) {
        O13 = this._context.sharedResources.textures.fromData(P11.key, () => e(P11).create(), () => {
          r(n26) && n26.release();
        });
        const e33 = this._context.stage.renderView.textureRepository.acquire(O13.texture.id);
        if (t(e33) || C2(e33))
          return O13.release(), null;
        n26 = e33;
      }
    }
    const w16 = D7(P11, m19), L8 = { occlusionTest: true, screenOffset: m19.screenOffset, anchorPosition: w16, polygonOffset: true, color: [1, 1, 1, 1], centerOffsetUnits: m19.centerOffsetUnits, debugDrawLabelBorder: m19.debugDrawLabelBorder, drawInSecondSlot: true };
    if (r(O13) && (L8.textureId = O13.texture.id), r(g21) && (L8.textureId = g21.id), r(m19.verticalOffset)) {
      const { screenLength: e32, minWorldLength: t24, maxWorldLength: n26 } = m19.verticalOffset;
      L8.verticalOffset = { screenLength: u4(e32), minWorldLength: t24 || 0, maxWorldLength: r(n26) ? n26 : 1 / 0 };
    }
    if (this._context.screenSizePerspectiveEnabled) {
      const { screenSizePerspectiveSettings: e32, screenSizePerspectiveSettingsLabels: t24 } = this._context.sharedResources;
      L8.screenSizePerspective = t24.overridePadding(this._textRenderParameters.haloSize + this._textRenderParameters.definition.background.padding[0]), L8.screenSizePerspectiveAlignment = e32;
    }
    let R16;
    if (x20 && (L8.shaderPolygonOffset = 1e-4), L8.hasSlicePlane = this._context.slicePlaneEnabled, r(f25)) {
      const e32 = JSON.stringify(L8);
      R16 = f25.get(e32), t(R16) && (R16 = new Q(L8), f25.add(e32, R16));
    } else
      R16 = new Q(L8);
    const U10 = [R16], G9 = m19.translation, A12 = r(P11) ? [P11.displayWidth, P11.displayHeight] : [0, 0], T9 = m19.centerOffset, W5 = [b11(C14, G9, null, A12, T9, [0, 0], null)], I12 = this._context.layer.uid, k11 = u24(this._context, l32, W5, U10, y17, I12, b26);
    if (null === k11)
      return null;
    const B10 = new _8(this, k11.object, W5, t(f25) ? U10 : null, O13, d15, y17);
    B10.alignedSampledElevation = k11.sampledElevation, B10.needsElevationUpdates = g9(y17.mode) || "absolute-height" === y17.mode;
    const { displayWidth: H8, displayHeight: $5 } = r(P11) ? P11 : m19;
    B10.getScreenSize = (e32 = n12()) => (e32[0] = H8, e32[1] = $5, e32);
    const V8 = { labelText: c31, elevationOffset: m19.elevationOffset };
    return B10.metadata = V8, f18(B10, l32, this._context.elevationProvider), B10;
  }
};
function U8(e31, t24, n26) {
  e31 && e31.forEach((e32) => {
    const s23 = t24(e32);
    r(s23) && n26(s23, e32.graphic);
  });
}
function D7(e31, t24) {
  if ("baseline" === t24.verticalPlacement) {
    const n27 = r22[t24.horizontalPlacement], s23 = r(e31) ? e31.baselineAnchorY : 0;
    return r12(n27, s23);
  }
  const n26 = i18(t24.horizontalPlacement, t24.verticalPlacement);
  return o20[n26];
}
var G8 = { mode: "relative-to-ground", offset: 0 };
var A10 = { text: null, translation: [0, 0, 0], elevationOffset: 0, centerOffset: [0, 0, 0, 1], screenOffset: [0, 0], horizontalPlacement: "center", verticalPlacement: "center", verticalOffset: null, centerOffsetUnits: null, debugDrawLabelBorder: false, displayWidth: 0, displayHeight: 0 };

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/internal/waterMaterialUtils.js
var e27 = { "calm-small": { waveStrength: 5e-3, perturbationStrength: 0.02, textureRepeat: 12, waveVelocity: 0.01 }, "rippled-small": { waveStrength: 0.02, perturbationStrength: 0.09, textureRepeat: 32, waveVelocity: 0.07 }, "slight-small": { waveStrength: 0.05, perturbationStrength: 0.07, textureRepeat: 28, waveVelocity: 0.1 }, "moderate-small": { waveStrength: 0.075, perturbationStrength: 0.07, textureRepeat: 24, waveVelocity: 0.1 }, "calm-medium": { waveStrength: 3125e-6, perturbationStrength: 0.01, textureRepeat: 8, waveVelocity: 0.02 }, "rippled-medium": { waveStrength: 0.035, perturbationStrength: 0.015, textureRepeat: 12, waveVelocity: 0.07 }, "slight-medium": { waveStrength: 0.06, perturbationStrength: 0.015, textureRepeat: 8, waveVelocity: 0.12 }, "moderate-medium": { waveStrength: 0.09, perturbationStrength: 0.03, textureRepeat: 4, waveVelocity: 0.12 }, "calm-large": { waveStrength: 0.01, perturbationStrength: 0, textureRepeat: 4, waveVelocity: 0.05 }, "rippled-large": { waveStrength: 0.025, perturbationStrength: 0.01, textureRepeat: 8, waveVelocity: 0.11 }, "slight-large": { waveStrength: 0.06, perturbationStrength: 0.02, textureRepeat: 3, waveVelocity: 0.13 }, "moderate-large": { waveStrength: 0.14, perturbationStrength: 0.03, textureRepeat: 2, waveVelocity: 0.15 } };

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DWaterSymbolLayer.js
var F11 = ["polyline", "polygon", "extent"];
var I10 = class extends y8 {
  constructor(e31, t24, r30, o24) {
    super(e31, t24, r30, o24);
  }
  async doLoad() {
  }
  destroy() {
    super.destroy(), this._context.stage.remove(this._material), this._material = null;
  }
  createGraphics3DGraphic(e31) {
    const t24 = e31.graphic;
    if (!this._validateGeometry(t24.geometry, F11, this.symbolLayer.type))
      return null;
    const r30 = this.setGraphicElevationContext(t24, new h16());
    return this.ensureDrapedStatus("on-the-ground" === r30.mode), this.ensureMaterial(), this.draped ? this._createAsOverlay(t24) : this._createAs3DShape(t24, r30, t24.uid);
  }
  ensureMaterial() {
    if (r(this._material))
      return;
    const r30 = new d13(), o24 = this.symbolLayer.color;
    r(o24) && (r30.color = l4.toUnitRGBA(o24));
    const i23 = this._getCombinedOpacity(o24, { hasIntrinsicColor: true });
    r30.color = [r30.color[0], r30.color[1], r30.color[2], i23], r30.transparent = i23 < 1 || this.needsDrivenTransparentPass, r30.waveDirection = r(this.symbolLayer.waveDirection) ? I10.headingVectorFromAngle(this.symbolLayer.waveDirection) : r12(0, 0);
    const s23 = this.symbolLayer.waveStrength + "-" + this.symbolLayer.waterbodySize, n26 = e27[s23];
    r30.waveStrength = n26.waveStrength, r30.waveTextureRepeat = n26.textureRepeat, r30.waveVelocity = n26.waveVelocity, r30.flowStrength = n26.perturbationStrength, r30.hasSlicePlane = this._context.slicePlaneEnabled, r30.isDraped = this.draped, this._material = new f15(r30), this._context.stage.add(this._material);
  }
  layerOpacityChanged() {
    if (t(this._material))
      return;
    const e31 = this._material.parameters.color, t24 = this._getCombinedOpacity(this.symbolLayer.color, { hasIntrinsicColor: true }), o24 = t24 < 1 || this.needsDrivenTransparentPass;
    this._material.setParameters({ color: [e31[0], e31[1], e31[2], t24], transparent: o24 });
  }
  layerElevationInfoChanged(e31, t24, r30) {
    const o24 = this._elevationContext.mode, i23 = p10(I10.elevationModeChangeTypes, r30, o24);
    if (i23 !== x9.UPDATE)
      return i23;
    const s23 = g9(o24);
    return this.updateGraphics3DGraphicElevationInfo(e31, t24, () => s23);
  }
  slicePlaneEnabledChanged() {
    return r(this._material) && this._material.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled }), true;
  }
  physicalBasedRenderingChanged() {
    return true;
  }
  pixelRatioChanged() {
    return true;
  }
  _createAs3DShape(e31, t24, o24) {
    const i23 = u25(e31.geometry);
    if (t(i23))
      return null;
    const s23 = e24(i23, this._context.elevationProvider, this._context.renderCoordsHelper, t24), n26 = s23.position.length / 3, a29 = new Float64Array(2 * n26), l32 = new Y6(s23, a29);
    if (this._create3DShapeGeometries(l32), this._logGeometryCreationWarnings(l32.renderData, i23.rings, "rings", "WaterSymbol3DLayer"), 0 === l32.outGeometries.length)
      return null;
    this._createUVCoordsFromVertices(l32.uvCoords, l32.renderData.mapPosition, n26, this._context.elevationProvider.spatialReference);
    const c31 = new x7({ geometries: l32.outGeometries, materials: l32.outMaterials, transformations: l32.outTransforms, castShadow: false, metadata: { layerUid: this._context.layer.uid, graphicUid: o24 } }), h25 = new _8(this, c31, l32.outGeometries, null, null, p13, t24);
    return h25.alignedSampledElevation = l32.renderData.sampledElevation, h25.needsElevationUpdates = g9(t24.mode), h25;
  }
  _createUVCoordsFromVertices(e31, t24, r30, o24) {
    const s23 = $(o24);
    D(k8);
    for (let i23 = 0; i23 < r30; i23++)
      r10(z7, t24[3 * i23 + 0], t24[3 * i23 + 1]), m2(k8, z7);
    l2(k8, k8, s23);
    const n26 = k8[0] % I10.unitSizeOfTexture, l32 = k8[1] % I10.unitSizeOfTexture;
    W4[0] = k8[0] - n26, W4[1] = k8[1] - l32;
    for (let i23 = 0; i23 < r30; i23++)
      e31[2 * i23 + 0] = (t24[3 * i23 + 0] * s23 - W4[0]) / I10.unitSizeOfTexture, e31[2 * i23 + 1] = (t24[3 * i23 + 1] * s23 - W4[1]) / I10.unitSizeOfTexture;
  }
  _create3DShapeGeometries(e31) {
    const r30 = e31.renderData.polygons, i23 = e31.uvCoords;
    for (const { count: a29, index: l32, position: c31, mapPosition: h25, holeIndices: m19 } of r30) {
      if (r(this._context.clippingExtent) && (A2(N4), M3(N4, h25), !R2(N4, this._context.clippingExtent)))
        continue;
      const r31 = x5(h25, m19, 3);
      if (0 === r31.length)
        continue;
      const u33 = new Float64Array(i23.buffer, 2 * l32 * i23.BYTES_PER_ELEMENT, 2 * a29), p21 = o18({ indices: r31, attributeData: { position: c31, uv0: u33, mapPosition: h25 } });
      e31.outGeometries.push(p21), e31.outMaterials.push(e(this._material)), e31.outTransforms.push(o3);
    }
  }
  _createAsOverlay(e31) {
    const t24 = u25(e31.geometry);
    if (t(t24))
      return null;
    e(this._material).renderPriority = this._renderPriority;
    const i23 = r20(t24, this._context.overlaySR), s23 = i23.position.length / 3, n26 = new Float64Array(2 * s23), a29 = new q11(i23, n26, this._context.layer.uid, e31.uid);
    return a29.outBoundingBox = A2(), this._createAsOverlayWater(a29), this._logGeometryCreationWarnings(a29.renderData, t24.rings, "rings", "WaterSymbol3DLayer"), 0 === a29.outGeometries.length ? null : (this._createUVCoordsFromVertices(a29.uvCoords, a29.renderData.position, s23, this._context.overlaySR), new l25(this, a29.outGeometries, a29.outBoundingBox, this._context.drapeSourceRenderer));
  }
  _createAsOverlayWater(e31) {
    const t24 = e31.uvCoords, r30 = e31.renderData.polygons;
    for (const { position: i23, holeIndices: n26, index: a29, count: l32 } of r30) {
      if (A2(N4), M3(N4, i23), !R2(N4, this._context.clippingExtent))
        continue;
      f4(e31.outBoundingBox, N4);
      const r31 = x5(i23, n26, 3);
      if (0 === r31.length)
        continue;
      const c31 = new Float64Array(t24.buffer, 2 * a29 * t24.BYTES_PER_ELEMENT, 2 * l32), h25 = o18({ indices: r31, attributeData: { position: i23, uv0: c31 } }), u33 = new T4(h25, e(this._material), { layerUid: e31.layerUid, graphicUid: e31.graphicsUid }), p21 = N4;
      r5(u33.boundingSphere, 0.5 * (p21[0] + p21[3]), 0.5 * (p21[1] + p21[4]), 0, 0.5 * Math.sqrt((p21[3] - p21[0]) * (p21[3] - p21[0]) + (p21[4] - p21[1]) * (p21[4] - p21[1]))), e31.outGeometries.push(u33);
    }
  }
  static headingVectorFromAngle(e31) {
    const t24 = n12(), r30 = r3(e31);
    return t24[0] = Math.sin(r30), t24[1] = Math.cos(r30), t24;
  }
  test() {
    return { ...super.test(), create3DShape: (e31) => this._createAs3DShape(e31.graphic, e31.elevationContext, e31.graphicUid), ensureMaterial: () => this.ensureMaterial() };
  }
};
I10.unitSizeOfTexture = 100, I10.elevationModeChangeTypes = { definedChanged: x9.RECREATE, staysOnTheGround: x9.NONE, onTheGroundChanged: x9.RECREATE };
var W4 = n12();
var k8 = u6();
var z7 = n12();
var N4 = a6();
var Y6 = class extends c23 {
  constructor(e31, t24) {
    super(e31, null, null), this.uvCoords = t24;
  }
};
var q11 = class extends c23 {
  constructor(e31, t24, r30, o24) {
    super(e31, r30, o24), this.uvCoords = t24;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DSymbolLayerFactory.js
function c29(o24, e31, t24, i23) {
  const m19 = h23[o24.type] && h23[o24.type][e31.type] || l28[e31.type];
  return m19 ? new m19(o24, e31, t24, i23) : (s3.getLogger("esri.views.3d.layers.graphics.Graphics3DSymbolLayerFactory").error("GraphicsLayerFactory#make", `unknown symbol type ${e31.type}`), null);
}
var l28 = { icon: me2, object: me4, line: J4, path: ae3, fill: W3, extrude: $2, text: R14, water: I10 };
var h23 = { "mesh-3d": { fill: he3 } };

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DSymbol.js
var p20 = class extends a23 {
  constructor(e31, t24, s23) {
    super(t24.schedule), this._symbol = e31, this._context = t24, this._backgroundLayers = s23, this._destroyed = false, this.symbolLayers = new Array(), this.referenced = 0, this._extentPadding = 0;
  }
  set symbol(e31) {
    this._symbol = e31;
    for (let s23 = 0; s23 < e31.symbolLayers.length; s23++) {
      const r30 = this.symbolLayers[s23];
      t(r30) || (r30.symbol = e31, r30.symbolLayer = e31.symbolLayers.items[s23]);
    }
  }
  get symbol() {
    return this._symbol;
  }
  async doLoad(t24) {
    let r30 = this._symbol.symbolLayers;
    this._extentPadding = 0, this._backgroundLayers && (r30 = this._backgroundLayers.concat(r30));
    const i23 = r30.length;
    for (; this.symbolLayers.length < r30.length; )
      this.symbolLayers.push(null);
    this.symbolLayers.length = r30.length;
    const n26 = [];
    for (let e31 = 0; e31 < i23; e31++) {
      const s23 = r30.getItemAt(e31);
      if (false === s23.enabled)
        continue;
      d24.renderPriority = 1 - (1 + e31) / i23, d24.renderPriorityStep = 1 / i23, d24.ignoreDrivers = s23._ignoreDrivers;
      const a29 = c29(this.symbol, s23, this._context, d24);
      n26.push(d(t24, () => {
        this.symbolLayers[e31] = null, a29.destroy();
      })), this.symbolLayers[e31] = a29;
    }
    await c3(this.symbolLayers, async (e31, t25) => {
      if (r(e31))
        try {
          await e31.load(), this._extentPadding += Math.max(this._extentPadding, e31.extentPadding);
        } catch {
          this.symbolLayers[t25] = null;
        }
    });
    for (const e31 of n26)
      e31 == null ? void 0 : e31.remove();
    if (n26.length = 0, f2(t24), this.symbolLayers.length && !this.symbolLayers.some((e31) => !!e31))
      throw new Error();
  }
  getSymbolLayerSize(e31) {
    const t24 = this.symbolLayers[e31];
    return r(t24) ? t24.getCachedSize() : null;
  }
  get extentPadding() {
    return this._extentPadding;
  }
  get symbologySnappingSupported() {
    return this.symbolLayers.some((e31) => r(e31) && e31.queryForSnapping);
  }
  createGraphics3DGraphic(e31, t24) {
    const r30 = e31.graphic, o24 = new Array(this.symbolLayers.length);
    for (let i23 = 0; i23 < this.symbolLayers.length; i23++) {
      const t25 = this.symbolLayers[i23];
      o24[i23] = r(t25) ? t25.createGraphics3DGraphic(e31) : null;
    }
    const a29 = this._context.arcade || this._context.featureExpressionInfoContext && this._context.featureExpressionInfoContext.arcade && this._context.featureExpressionInfoContext.arcade.modules || null;
    return new V4(r30, t24 || this, o24, e31.layer, a29);
  }
  get complexity() {
    return P5(this.symbolLayers.map((e31) => q(e31, "complexity")));
  }
  globalPropertyChanged(e31, t24) {
    const r30 = this.symbolLayers.length;
    for (let o24 = 0; o24 < r30; o24++) {
      const r31 = this.symbolLayers[o24], a29 = (e32) => {
        const t25 = e32.graphics[o24];
        return t25 instanceof _8 ? t25 : null;
      };
      if (r(r31) && !r31.globalPropertyChanged(e31, t24, a29))
        return false;
    }
    return true;
  }
  applyRendererDiff(e31, t24) {
    return this.loadStatus !== e21.LOADED ? e20.Recreate_Symbol : this.symbolLayers.reduce((r30, o24) => r30 !== e20.Recreate_Symbol && r(o24) ? Math.min(r30, o24.applyRendererDiff(e31, t24)) : r30, e20.Fast_Update);
  }
  prepareSymbolPatch(e31) {
    if (this.loadStatus === e21.FAILED)
      return;
    if ("partial" !== e31.diff.type)
      return;
    const r30 = e31.diff.diff;
    if (!r30.symbolLayers || "partial" !== r30.symbolLayers.type)
      return;
    const o24 = r30.symbolLayers.diff;
    this.symbolLayers.forEach((r31, a29) => {
      if (t(r31))
        return;
      const i23 = o24[a29];
      if (i23) {
        const t24 = { diff: i23, graphics3DGraphicPatches: [], symbolLayerStatePatches: [] };
        r31.prepareSymbolLayerPatch(t24), e31.symbolStatePatches.push(...t24.symbolLayerStatePatches), t24.graphics3DGraphicPatches.length && e31.graphics3DGraphicPatches.push((e32, r32) => {
          const o25 = e32.graphics[a29];
          r(o25) && t24.graphics3DGraphicPatches.forEach((e33) => e33(o25, r32));
        });
      }
    });
  }
  updateGeometry(e31, s23) {
    for (let r30 = 0; r30 < this.symbolLayers.length; r30++) {
      const o24 = this.symbolLayers[r30];
      if (t(o24))
        continue;
      const a29 = e31.graphics[r30];
      if (t(a29) || !o24.updateGeometry(a29, s23))
        return false;
    }
    return true;
  }
  onRemoveGraphic(e31) {
    for (let r30 = 0; r30 < this.symbolLayers.length; r30++) {
      const o24 = this.symbolLayers[r30];
      if (t(o24))
        continue;
      const a29 = e31.graphics[r30];
      r(a29) && o24.onRemoveGraphic(a29);
    }
  }
  getFastUpdateStatus() {
    let e31 = 0, s23 = 0, r30 = 0;
    return this.symbolLayers.forEach((o24) => {
      t(o24) || (o24.loadStatus === e21.LOADING ? e31++ : o24.isFastUpdatesEnabled() ? r30++ : s23++);
    }), { loading: e31, slow: s23, fast: r30 };
  }
  async queryForSnapping(e31, t24, r30, o24) {
    const i23 = this.symbolLayers.filter(r).filter((e32) => r(e32.queryForSnapping)).map((s23) => s23.queryForSnapping(e31, t24, r30, o24)), n26 = await Promise.all(i23);
    return f2(o24), n26.flat();
  }
  destroy() {
    if (this.destroyed)
      console.error("Graphics3DSymbol.destroy called when already destroyed!");
    else {
      super.destroy();
      for (const e31 of this.symbolLayers)
        r(e31) && e31.destroy();
      this.symbolLayers.length = 0, this._destroyed = true;
    }
  }
  get destroyed() {
    return this._destroyed;
  }
};
var d24 = { renderPriority: 0, renderPriorityStep: 1, ignoreDrivers: false };

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DPointSymbol.js
var s19 = class extends p20 {
  constructor(r30, t24, a29) {
    super(r30, t24, a29), this._calloutSymbolLayer = null, this.symbol.hasVisibleCallout() && (this._calloutSymbolLayer = e23(this.symbol, t24));
  }
  async doLoad(t24) {
    var _a;
    const a29 = this._calloutSymbolLayer ? b2(this._calloutSymbolLayer.load()) : null;
    try {
      await super.doLoad(t24), f2(t24);
    } catch (o24) {
      throw (_a = this._calloutSymbolLayer) == null ? void 0 : _a.abortLoad(), o24;
    }
    a29 && await a29;
  }
  destroy() {
    super.destroy(), this._calloutSymbolLayer = s(this._calloutSymbolLayer);
  }
  createGraphics3DGraphic(r30, t24) {
    const e31 = super.createGraphics3DGraphic(r30, t24);
    if (r(this._calloutSymbolLayer) && r(e31)) {
      const t25 = this._createCalloutGraphic(r30);
      r(t25) && e31.addAuxiliaryGraphic(t25);
    }
    return e31;
  }
  globalPropertyChanged(r30, t24) {
    return !!super.globalPropertyChanged(r30, t24) && (!this._calloutSymbolLayer || this._calloutSymbolLayer.globalPropertyChanged(r30, t24, (r31) => this._getCalloutGraphicLayer(r31)));
  }
  updateGeometry(r30, t24) {
    const a29 = super.updateGeometry(r30, t24);
    if (a29 && this._calloutSymbolLayer) {
      const a30 = this._getCalloutGraphicLayer(r30);
      if (a30)
        return this._calloutSymbolLayer.updateGeometry(a30, t24);
    }
    return a29;
  }
  _createCalloutGraphic(r30) {
    const t24 = r30.renderingInfo, a29 = { renderer: t24.renderer, symbol: t24.symbol, translation: [0, 0, 0], centerOffset: [0, 0, 0, 0], screenOffset: [0, 0], centerOffsetUnits: "world", elevationOffset: 0, materialCollection: null };
    return r30.renderingInfo = a29, this._calloutSymbolLayer.createGraphics3DGraphic(r30);
  }
  _getCalloutGraphicLayer(r30) {
    for (const t24 of r30._auxiliaryGraphics)
      if (t24.graphics3DSymbolLayer === this._calloutSymbolLayer)
        return t24;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DSymbolFactory.js
function t22(t24, i23, e31) {
  let p21;
  if ("point-3d" === t24.type)
    p21 = s19;
  else
    p21 = p20;
  return new p21(t24, i23, e31);
}

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DWebStyleSymbol.js
var e28 = class extends a23 {
  constructor(t24, s23, r30) {
    super(s23), this.symbol = t24, this._convert = r30, this.symbologySnappingSupported = false, this.graphics3DSymbol = null, this.referenced = 0;
  }
  getSymbolLayerSize(s23) {
    return r(this.graphics3DSymbol) ? this.graphics3DSymbol.getSymbolLayerSize(s23) : null;
  }
  get symbolLayers() {
    return r(this.graphics3DSymbol) ? this.graphics3DSymbol.symbolLayers : [];
  }
  get extentPadding() {
    return r(this.graphics3DSymbol) ? this.graphics3DSymbol.extentPadding : 0;
  }
  async doLoad(s23) {
    const r30 = await this.symbol.fetchSymbol({ signal: s23 });
    r30.id = this.symbol.id, this.graphics3DSymbol = this._convert(r30), r(this.graphics3DSymbol) && await this.graphics3DSymbol.load();
  }
  createGraphics3DGraphic(s23) {
    return r(this.graphics3DSymbol) ? this.graphics3DSymbol.createGraphics3DGraphic(s23, this) : null;
  }
  get complexity() {
    return r(this.graphics3DSymbol) ? this.graphics3DSymbol.complexity : b14;
  }
  globalPropertyChanged(s23, r30) {
    return !!r(this.graphics3DSymbol) && this.graphics3DSymbol.globalPropertyChanged(s23, r30);
  }
  applyRendererDiff(r30, i23) {
    return r(this.graphics3DSymbol) ? this.graphics3DSymbol.applyRendererDiff(r30, i23) : e20.Recreate_Symbol;
  }
  prepareSymbolPatch(s23) {
    r(this.graphics3DSymbol) && this.graphics3DSymbol.prepareSymbolPatch(s23);
  }
  updateGeometry(s23, r30) {
    return !!r(this.graphics3DSymbol) && this.graphics3DSymbol.updateGeometry(s23, r30);
  }
  onRemoveGraphic() {
  }
  getFastUpdateStatus() {
    return r(this.graphics3DSymbol) ? this.graphics3DSymbol.getFastUpdateStatus() : { loading: 1, fast: 0, slow: 0 };
  }
  destroy() {
    r(this.graphics3DSymbol) && this.graphics3DSymbol.destroy(), this.graphics3DSymbol = void 0, super.destroy();
  }
  get destroyed() {
    return void 0 === this.graphics3DSymbol;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/GraphicStateTracking.js
var s20 = class {
  constructor(t24) {
    this._graphicsCore = t24, this._idToState = /* @__PURE__ */ new Map(), this._states = /* @__PURE__ */ new Set();
    const i23 = t24.owner.layer && t24.owner.layer.objectIdField;
    i23 ? (this._getGraphicId = (t25) => O5(t25, i23), this._getGraphics3DGraphicById = (t25) => this._graphicsCore.getGraphics3DGraphicByObjectId(t25)) : (this._getGraphicId = (t25) => t25.uid, this._getGraphics3DGraphicById = (t25) => this._graphicsCore.getGraphics3DGraphicById(t25));
  }
  destroy() {
    this._idToState.clear(), this._states.forEach((t24, i23) => this.remove(i23));
  }
  add(t24) {
    const e31 = { remove: () => this.remove(t24) };
    if (this._states.has(t24))
      return e31;
    const s23 = this._getGraphicId(t24.graphic), a29 = this._getGraphics3DGraphicById(s23);
    this._states.has(t24) || this._states.add(t24);
    return this._ensureStateList(s23).push(t24), t24.displaying = !!r(a29) && a29.isVisible(), t24.isDraped = !!r(a29) && a29.isDraped, t24.tracking = true, r(a29) && t24.emit("changed", {}), e31;
  }
  remove(i23) {
    if (this._states.has(i23)) {
      if (this._idToState.size) {
        const e31 = this._getGraphicId(i23.graphic), s23 = this._idToState.get(e31);
        s23 && (C(s23, i23), 0 === s23.length && this._idToState.delete(e31));
      }
      this._states.delete(i23), i23.tracking = false, i23.displaying = false;
    }
  }
  addGraphic(t24) {
    this._forEachState(t24, (i23) => {
      i23.displaying = t24.isVisible(), i23.isDraped = t24.isDraped, i23.emit("changed", {});
    });
  }
  removeGraphic(t24) {
    this._forEachState(t24, (t25) => {
      t25.displaying = false, t25.isDraped = false;
    });
  }
  updateGraphicGeometry(t24) {
    this._forEachState(t24, (t25) => {
      t25.emit("changed", {});
    });
  }
  updateGraphicVisibility(t24) {
    this._forEachState(t24, (i23) => {
      i23.displaying = t24.isVisible();
    });
  }
  allGraphicsDeleted() {
    this._states.forEach((t24) => {
      t24.displaying = false;
    });
  }
  _ensureStateList(t24) {
    const i23 = this._idToState.get(t24);
    if (i23)
      return i23;
    const e31 = new Array();
    return this._idToState.set(t24, e31), e31;
  }
  _forEachState(t24, i23) {
    if (0 === this._states.size || 0 === this._idToState.size)
      return;
    const e31 = this._getGraphicId(t24.graphic), s23 = this._idToState.get(e31);
    null != s23 && s23.forEach(i23);
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/SpatialIndex2D.js
var d25 = class extends m {
  constructor(t24) {
    super(t24), this._index = new h14(9, has("esri-csp-restrictions") ? (t25) => ({ minX: t25.extent[0], minY: t25.extent[1], maxX: t25.extent[2], maxY: t25.extent[3] }) : [".extent[0]", ".extent[1]", ".extent[2]", ".extent[3]"]), this._missing = /* @__PURE__ */ new Set(), this._boundsByFeature = /* @__PURE__ */ new Map(), this.spatialReference = null, this.hasZ = null, this.hasM = null, this.objectIdField = null, this.updating = false;
  }
  setup(t24) {
    this._addMany(t24);
  }
  destroy() {
    this._missing.clear(), this._index.destroy(), this._index = null, this._boundsByFeature.clear(), this._boundsByFeature = null;
  }
  update() {
    this._missing.size > 0 && (this._addMany(Array.from(this._missing.values())), this.updating = false, this._missing.clear());
  }
  get updatingRemaining() {
    return this._missing.size;
  }
  queryGraphicUIDsInExtent(t24, e31, i23) {
    !t(e31) && e31.equals(this.spatialReference) && (u30.minX = t24[0], u30.minY = t24[1], u30.maxX = t24[2], u30.maxY = t24[3], this.update(), this._index.search(u30, (t25) => i23(t25.graphic.uid)));
  }
  add(t24) {
    this._missing.add(t24), this.updating = true;
  }
  remove(t24) {
    if (this._missing.delete(t24))
      return void (this.updating = this._missing.size > 0);
    this._index.remove(t24);
    const e31 = O5(t24.graphic, this._get("objectIdField"));
    null != e31 && this._boundsByFeature.delete(e31);
  }
  _addMany(t24) {
    if (0 === t24.length)
      return;
    const e31 = this._get("objectIdField");
    for (const s23 of t24) {
      s23.computeExtent(this.spatialReference);
      const t25 = O5(s23.graphic, e31);
      null != t25 && this._boundsByFeature.set(t25, s23.extent);
    }
    this._index.load(t24);
  }
  clear() {
    this._index.clear(), this._missing.clear(), this._boundsByFeature.clear(), this.updating = false;
  }
  forEachInBounds(t24, e31) {
    u30.minX = t24[0], u30.minY = t24[1], u30.maxX = t24[2], u30.maxY = t24[3], this.update(), this._index.search(u30, (t25) => {
      e31(t25);
    });
  }
  getBounds(t24, e31) {
    this.update();
    const s23 = this._boundsByFeature.get(t24);
    return s23 ? G2(e31, s23) : null;
  }
};
e4([y2({ constructOnly: true })], d25.prototype, "spatialReference", void 0), e4([y2({ constructOnly: true })], d25.prototype, "hasZ", void 0), e4([y2({ constructOnly: true })], d25.prototype, "hasM", void 0), e4([y2({ constructOnly: true })], d25.prototype, "objectIdField", void 0), e4([y2()], d25.prototype, "updating", void 0), e4([y2({ readOnly: true })], d25.prototype, "updatingRemaining", null), d25 = e4([n5("esri.views.3d.layers.graphics.SpatialIndex2D")], d25);
var u30 = { minX: 0, minY: 0, maxX: 0, maxY: 0 };

// node_modules/@arcgis/core/views/3d/layers/support/StageLayerElevationProvider.js
var v20 = 1;
var b23 = class extends n6.EventedMixin(m) {
  constructor(e31) {
    super(e31), this._elevationOffset = 0, this._layerHandes = new t3();
  }
  get spatialReference() {
    var _a;
    return (_a = this.view) == null ? void 0 : _a.spatialReference;
  }
  initialize() {
    this._renderCoordsHelper = this.view.renderCoordsHelper, this._intersectLayers = [this.stageLayer], this._intersector = x10(this.view.state.viewingMode), this._intersector.options.store = t16.MIN;
    const e31 = this._computeLayerExtent(this.spatialReference, this.stageLayer);
    this._zmin = e31[2], this._zmax = e31[5];
    const t24 = this.stageLayer.events;
    this._layerHandes.add([t24.on("layerObjectAdded", (e32) => this._objectChanged(e32.object)), t24.on("layerObjectRemoved", (e32) => this._objectChanged(e32.object)), t24.on("objectGeometryAdded", (e32) => this._objectChanged(e32.object)), t24.on("objectGeometryRemoved", (e32) => this._objectChanged(e32.object)), t24.on("vertexAttrsUpdated", (e32) => this._objectChanged(e32.object)), t24.on("objectTransformation", (e32) => this._objectChanged(e32))]);
  }
  dispose() {
    this._layerHandes.destroy();
  }
  elevationInfoChanged() {
    const e31 = null != this.layer ? this.layer.elevationInfo : null;
    if (null != e31 && "on-the-ground" !== e31.mode) {
      const t24 = L(this.layer.spatialReference), o24 = r7(e31.unit);
      this._elevationOffset = i(e31.offset, 0) * o24 / t24;
    } else
      this._elevationOffset = 0;
  }
  getElevation(e31, t24, o24, r30) {
    if (R15[0] = e31, R15[1] = t24, R15[2] = o24, !this._renderCoordsHelper.toRenderCoords(R15, r30, R15))
      return s3.getLogger(this.declaredClass).error("could not project point for elevation alignment"), null;
    const n26 = this._elevationOffset, i23 = this._zmin + n26, a29 = this._zmax + n26;
    this._renderCoordsHelper.setAltitude(H7, a29, R15), this._renderCoordsHelper.setAltitude(L6, i23, R15);
    const c31 = (e32) => e32.metadata && e32.metadata.isElevationSource;
    return this._intersector.reset(H7, L6, null), this._intersector.intersect(this._intersectLayers, null, v20, null, c31), this._intersector.results.min.getIntersectionPoint(R15) ? this._renderCoordsHelper.getAltitude(R15) : null;
  }
  _objectChanged(e31) {
    var _a;
    const t24 = this.spatialReference;
    if (!((_a = e31.metadata) == null ? void 0 : _a.isElevationSource) || t(t24))
      return;
    A2(x19);
    const { lastValidElevationBB: o24 } = e31.metadata;
    o24.isEmpty() || this._expandExtent(t24, o24.min, o24.max, x19);
    const { min: r30, max: s23 } = e31.boundingVolumeWorldSpace;
    this._expandExtent(t24, r30, s23, x19), B(x19, C15), this._zmin = Math.min(this._zmin, x19[2]), this._zmax = Math.max(this._zmax, x19[5]), E22.extent = C15, E22.spatialReference = t24, this.emit("elevation-change", E22), r4(o24.min, r30), r4(o24.max, s23);
  }
  _computeLayerExtent(e31, t24) {
    return A2(x19), r(e31) && t24.objects.forAll((t25) => this._expandExtent(e31, t25.boundingVolumeWorldSpace.min, t25.boundingVolumeWorldSpace.max, x19)), x19;
  }
  _expandExtent(e31, t24, o24, r30) {
    for (let s23 = 0; s23 < 8; ++s23)
      R15[0] = 1 & s23 ? t24[0] : o24[0], R15[1] = 2 & s23 ? t24[1] : o24[1], R15[2] = 4 & s23 ? t24[2] : o24[2], this._renderCoordsHelper.fromRenderCoords(R15, R15, e31), c6(r30, R15);
    return r30;
  }
};
e4([y2({ constructOnly: true })], b23.prototype, "layer", void 0), e4([y2({ constructOnly: true })], b23.prototype, "stageLayer", void 0), e4([y2({ constructOnly: true })], b23.prototype, "view", void 0), e4([y2()], b23.prototype, "spatialReference", null), b23 = e4([n5("esri.views.3d.layers.support.StageLayerElevationProvider")], b23);
var x19 = A2();
var C15 = D();
var E22 = { spatialReference: null, extent: C15, context: "scene" };
var R15 = n2();
var H7 = n2();
var L6 = n2();

// node_modules/@arcgis/core/views/3d/support/extentUtils.js
function e29(l32, x20, e31) {
  if (t(l32) || t(e31))
    return false;
  let u33 = true;
  return i22[0] = null != l32.xmin ? l32.xmin : 0, i22[1] = null != l32.ymin ? l32.ymin : 0, i22[2] = null != l32.zmin ? l32.zmin : 0, u33 = u33 && xn(i22, l32.spatialReference, 0, i22, e31, 0, 1), x20[0] = i22[0], x20[1] = i22[1], i22[0] = null != l32.xmax ? l32.xmax : 0, i22[1] = null != l32.ymax ? l32.ymax : 0, i22[2] = null != l32.zmax ? l32.zmax : 0, u33 = u33 && xn(i22, l32.spatialReference, 0, i22, e31, 0, 1), x20[2] = i22[0], x20[3] = i22[1], null == l32.xmin && (x20[0] = -1 / 0), null == l32.ymin && (x20[1] = -1 / 0), null == l32.xmax && (x20[2] = 1 / 0), null == l32.ymax && (x20[3] = 1 / 0), u33;
}
var i22 = n2();

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DCore.js
var Ue;
var Oe = n2();
var je = a6();
var Le = "esri.views.3d.layers.graphics.Graphics3DCore";
var Ve = s3.getLogger(Le);
var Fe = Ue = class extends m {
  constructor(e31) {
    super(e31), this._propertiesPool = new o14({ computedExtent: w4 }, this), this.computedExtent = null, this.currentRenderer = null, this.rendererHasGeometryOperations = false, this._graphicStateTracking = null, this.symbolCreationContext = new e19((e32, i23) => this._frameTask.schedule(e32, i23)), this.graphics3DGraphics = /* @__PURE__ */ new Map(), this.stageLayer = null, this.stage = null, this._graphicsDrapedUids = /* @__PURE__ */ new Set(), this._graphicsBySymbol = /* @__PURE__ */ new Map(), this._symbolConversionCache = /* @__PURE__ */ new Map(), this._symbols = /* @__PURE__ */ new Map(), this._graphicsWithoutSymbol = /* @__PURE__ */ new Map(), this._graphicsWaitingForSymbol = /* @__PURE__ */ new Map(), this._graphicsUpdateId = 0, this._handles = new t3(), this._frameTask = y5, this._suspendSymbolCleanup = false, this._viewSpatialReference = null, this._arcadeOnDemand = null, this._rendererChangeAbortController = null, this._elevationInfoChangeAbortController = null, this._initializeAbortController = null, this._scaleVisibility = null, this._filterVisibility = null, this._spatialIndex = null, this.extentPadding = 0, this._updatingPendingLoadedGraphicsChange = null, this._featureStore = null, this._deconflictor = null, this._labeler = null, this._objectStates = null, this._viewElevationProvider = null, this._stageLayerElevationProvider = null, this._sharedSymbolResourcesOwnerHandle = null, this._whenGraphics3DGraphicRequests = {}, this._pendingUpdates = /* @__PURE__ */ new Map(), this._numberOfGraphics = 0, this._numberOfGraphicsProvidingElevation = 0, this._pendingAdds = 0, this._pendingRemoves = 0, this._loadingSymbols = 0, this._pendingUpdatesPool = new l5({ allocator: (e32) => e32 || new ke(), deallocator: (e32) => (e32.clear(), e32) }), this._symbolWarningLogged = false, this._geometryWarningLogged = false, this._objectIdInvisibleSet = /* @__PURE__ */ new Set(), this._whenSymbolRemoved = new l5(), this.preferredUpdatePolicy = i6.SYNC, this.forcedUpdatePolicy = null, this.elevationFeatureExpressionEnabled = true, this.owner = null, this.layer = null, this.graphicSymbolSupported = true, this.getRenderingInfoWithoutRenderer = false, this.setUidToIdOnAdd = true, this.hasZ = null, this.hasM = null, this._usedMemory = 0, this._visible = void 0, this._startCreateGraphics = false;
  }
  get spatialIndex() {
    var _a;
    return this._spatialIndex || (this._spatialIndex = new d25({ objectIdField: (_a = this.owner.layer) == null ? void 0 : _a.objectIdField, spatialReference: this._viewSpatialReference, hasZ: this.hasZ, hasM: this.hasM }), this._spatialIndex.setup(Array.from(this.graphics3DGraphics.values()))), this._spatialIndex.update(), this._spatialIndex;
  }
  get numberOfGraphics() {
    return this._numberOfGraphics;
  }
  get effectiveUpdatePolicy() {
    return r(this.currentRenderer) && "dictionary" === this.currentRenderer.type ? i6.ASYNC : i(this.forcedUpdatePolicy, this.preferredUpdatePolicy);
  }
  get featureStore() {
    return this._featureStore;
  }
  get initializePromise() {
    return this._initializePromise;
  }
  get scaleVisibility() {
    return this._scaleVisibility;
  }
  get elevationAlignment() {
    return this._elevationAlignment;
  }
  get objectStates() {
    return this._objectStates;
  }
  get filterVisibility() {
    return this._filterVisibility;
  }
  get updating() {
    var _a;
    return !!(this._graphicsWaitingForSymbol.size > 0 || this.running || ((_a = this._elevationAlignment) == null ? void 0 : _a.updating) || r(this._scaleVisibility) && this._scaleVisibility.updating || r(this._filterVisibility) && this._filterVisibility.updating || this._rendererChangeAbortController || this._elevationInfoChangeAbortController || this._updatingPendingLoadedGraphicsChange || this._frameTask.updating || this._loadingSymbols > 0);
  }
  get running() {
    var _a;
    return this._pendingUpdates.size > 0 || !!((_a = this._spatialIndex) == null ? void 0 : _a.updating);
  }
  get suspendedOrOutsideOfView() {
    var _a;
    return this.owner.suspended || ((_a = this.owner.suspendInfo) == null ? void 0 : _a.outsideOfView);
  }
  get updatingRemaining() {
    var _a, _b;
    return this.updating ? this._pendingUpdates.size + 0.1 * (((_a = this._spatialIndex) == null ? void 0 : _a.updatingRemaining) || 0) + 0.1 * (((_b = this._elevationAlignment) == null ? void 0 : _b.updatingRemaining) || 0) : 0;
  }
  get displayFeatureLimit() {
    const e31 = this.owner && this.owner.view && this.owner.view.qualitySettings, i23 = e31 ? e31.graphics3D.minTotalNumberOfFeatures : 0, t24 = e31 ? e31.graphics3D.maxTotalNumberOfFeatures : 0, r30 = e31 ? e31.graphics3D.maxTotalNumberOfPrimitives : 0, s23 = this.averageSymbolComplexity, a29 = Math.max(1, r(s23) ? s23.primitivesPerFeature : 1), n26 = r(s23) && s23.drawCallsPerFeature > 0 ? t24 / s23.drawCallsPerFeature * 0.3 : t24, o24 = Math.ceil(r30 / a29), l32 = Math.max(i23, Math.min(t24, o24, n26)), d27 = this._get("displayFeatureLimit");
    return d27 && d27.minimumTotalNumberOfFeatures === i23 && d27.maximumTotalNumberOfFeatures === t24 && d27.maximumTotalNumberOfPrimitives === r30 && d27.averageSymbolComplexity === s23 && d27.maximumNumberOfFeatures === l32 ? d27 : { minimumTotalNumberOfFeatures: i23, maximumTotalNumberOfFeatures: t24, maximumTotalNumberOfPrimitives: r30, averageSymbolComplexity: s23, maximumNumberOfFeatures: l32 };
  }
  get averageSymbolComplexity() {
    const e31 = d16(this._symbolComplexities), i23 = this._get("averageSymbolComplexity");
    return 0 === e31.numComplexities || r(i23) && (e31.estimated && (i23.primitivesPerFeature >= e31.primitivesPerFeature || i23.primitivesPerCoordinate >= e31.primitivesPerCoordinate || i23.drawCallsPerFeature >= e31.drawCallsPerFeature) || i23.primitivesPerFeature === e31.primitivesPerFeature && i23.primitivesPerCoordinate === e31.primitivesPerCoordinate && i23.drawCallsPerFeature === e31.drawCallsPerFeature) ? i23 : e31;
  }
  get usedMemory() {
    const e31 = r(this.averageSymbolComplexity) && this.labelsEnabled ? this.averageSymbolComplexity.memory.bytesPerFeatureLabel * this._numberOfGraphics : 0, i23 = this._getSymbolComplexitiesUsed().reduce((e32, i24) => e32 + i24.memory.resourceBytes, 0);
    return this._usedMemory + e31 + i23;
  }
  get usedMemoryPerGraphic() {
    if (this._usedMemory && this._numberOfGraphics)
      return (this._pendingAdds + this._pendingRemoves) / this._numberOfGraphics > 20 ? 0 : this._usedMemory / this._numberOfGraphics;
    if (r(this.averageSymbolComplexity)) {
      const e31 = this.labelsEnabled ? this.averageSymbolComplexity.memory.bytesPerFeatureLabel : 0;
      return this.averageSymbolComplexity.memory.bytesPerFeature + e31;
    }
    return 0;
  }
  get unprocessedMemoryEstimate() {
    return Math.max(0, (this._pendingAdds - this._pendingRemoves) * this.usedMemoryPerGraphic);
  }
  get _symbolComplexities() {
    return this.currentRenderer ? this._getSymbolComplexitiesUsedOrRenderer(this.currentRenderer) : this._getSymbolComplexitiesUsed();
  }
  _getConvertedSymbol(e31) {
    var _a;
    if ("web-style" === e31.type)
      return e31.clone();
    const i23 = this._symbolConversionCache.get(e31.id);
    if (r(i23))
      return i23;
    const t24 = S3(e31, { geometryType: (_a = this.layer) == null ? void 0 : _a.geometryType, retainId: true, hasLabelingContext: this._hasLabelingContext(e31) }), r30 = t24.symbol || null;
    return t(r30) && t24.error && Ve.error(t24.error.message), this._symbolConversionCache.set(e31.id, r30), r30;
  }
  _getSymbolComplexitiesUsedOrRenderer(e31) {
    if (t(e31))
      return [];
    const i23 = e31.getSymbols(), t24 = "backgroundFillSymbol" in e31 && e31.backgroundFillSymbol;
    if (!(t24 || i23 && i23.length))
      return [];
    const r30 = [], s23 = this._getSymbolComplexityUsedOrRenderer(t24);
    r(s23) && r30.push(s23);
    for (const a29 of i23) {
      const e32 = this._getSymbolComplexityUsedOrRenderer(a29);
      r(e32) && r30.push(e32);
    }
    return r30;
  }
  _getSymbolComplexityUsedOrRenderer(e31) {
    if (t(e31))
      return null;
    const i23 = this._symbols.get(e31.id);
    if (r(i23))
      return i23.complexity;
    const t24 = this._getConvertedSymbol(e31);
    return r(t24) ? y7(t24) : null;
  }
  _getSymbolComplexitiesUsed() {
    const e31 = [];
    return this._symbols.forEach((i23) => {
      r(i23) && e31.push(i23.complexity);
    }), e31;
  }
  get _objectIdField() {
    return this.layer.objectIdField;
  }
  initialize() {
    this._viewSpatialReference = this.owner.view.spatialReference, this._featureStore = new l22({ objectIdField: this.owner.layer && this.owner.layer.objectIdField, hasZ: this.hasZ, hasM: this.hasM, viewSpatialReference: this._viewSpatialReference, featureSpatialReference: this.owner.featureSpatialReference, getSpatialIndex: () => this.spatialIndex, forEach: (e32) => this.graphics3DGraphics.forEach(e32), toArray: () => Array.from(this.graphics3DGraphics.values()) });
    const e31 = (e32, i24, t24) => this.spatialIndex.queryGraphicUIDsInExtent(e32, i24, t24), { componentFactories: i23 } = this;
    if (r(i23.elevationAlignment)) {
      const t24 = i23.elevationAlignment(this, e31);
      this._elevationAlignment = t24;
    }
    if (r(i23.scaleVisibility)) {
      const t24 = i23.scaleVisibility(this, e31);
      this._scaleVisibility = t24;
    }
    if (r(i23.filterVisibility)) {
      const e32 = i23.filterVisibility({ featureStore: this._featureStore, getFeatureCount: () => this.graphics3DGraphics.size, updateFeatureVisibilities: (e33) => this.modifyGraphics3DGraphicVisibilities((i24) => i24.setVisibilityFlag(C7.FILTER, e33(O5(i24.graphic, this._objectIdField)), E12.GRAPHIC)), setAllFeaturesVisibility: (e33) => this.modifyGraphics3DGraphicVisibilities((i24) => i24.setVisibilityFlag(C7.FILTER, e33, E12.GRAPHIC)), clearFeaturesVisibility: () => this.modifyGraphics3DGraphicVisibilities((e33) => e33.clearVisibilityFlag(C7.FILTER)) });
      this._filterVisibility = e32;
    }
    if (r(i23.deconflictor)) {
      const e32 = i23.deconflictor(this);
      this._deconflictor = e32;
    }
    if (r(i23.labeler) && r(this._scaleVisibility)) {
      const e32 = i23.labeler(this, this._scaleVisibility);
      this._labeler = e32;
    }
    if (r(i23.objectStates)) {
      const e32 = i23.objectStates(this);
      this._objectStates = e32;
    }
    this._initializeAbortController = new AbortController(), this._initializePromise = this._initializeAsync();
  }
  async _initializeAsync() {
    var _a, _b, _c;
    const e31 = this._initializeAbortController.signal, i23 = this.owner.view;
    this._viewElevationProvider = new n16(this._viewSpatialReference, i23), this._initializeStage(i23, this.layer.uid), this.symbolCreationContext.sharedResources = i23.sharedSymbolResources, this._sharedSymbolResourcesOwnerHandle = i23.sharedSymbolResources.addGraphicsOwner(this.owner), r(this.currentRenderer) && (this.symbolCreationContext.renderer = this.currentRenderer), this.symbolCreationContext.stage = this.stage, this.symbolCreationContext.streamDataRequester = i23.sharedSymbolResources.streamDataRequester, this.symbolCreationContext.renderCoordsHelper = i23.renderCoordsHelper, this.symbolCreationContext.layer = this.layer, this.symbolCreationContext.graphicsCoreOwner = this.owner, this.symbolCreationContext.localOriginFactory = new j9(i23.renderSpatialReference), this.symbolCreationContext.elevationProvider = i23.elevationProvider, this.symbolCreationContext.notifyGraphicGeometryChanged = (e32) => this.notifyGraphicGeometryChanged(e32), this.symbolCreationContext.notifyGraphicVisibilityChanged = (e32) => this.notifyGraphicVisibilityChanged(e32);
    const t24 = d12(this.layer.elevationInfo, this.elevationFeatureExpressionEnabled);
    if (this.symbolCreationContext.featureExpressionInfoContext = await u17(t24, this._viewSpatialReference, e31, Ve), f2(e31), this.symbolCreationContext.screenSizePerspectiveEnabled = i23.screenSizePerspectiveEnabled && this.layer.screenSizePerspectiveEnabled, this.symbolCreationContext.slicePlaneEnabled = !!this.owner.slicePlaneEnabled, this.symbolCreationContext.physicalBasedRenderingEnabled = !!((_a = this.owner.view.qualitySettings) == null ? void 0 : _a.physicallyBasedRenderingEnabled), this.symbolCreationContext.skipHighSymbolLods = !!((_c = (_b = this.owner.view.qualitySettings) == null ? void 0 : _b.graphics3D) == null ? void 0 : _c.skipHighSymbolLods), "drapeSourceType" in this.owner) {
      const { owner: e32 } = this;
      this.symbolCreationContext.drapeSourceRenderer = i23.basemapTerrain.overlayManager.registerGeometryDrapeSource(e32), this._handles.add(n4(() => i23.basemapTerrain.overlayManager.unregisterDrapeSource(e32)));
    }
    this._handles.add([l6(() => this.suspendedOrOutsideOfView, () => this._frameTask.reschedule(() => this._updateLayerVisibility())), l6(() => {
      var _a2;
      return [(_a2 = this.layer) == null ? void 0 : _a2.screenSizePerspectiveEnabled, this.owner.view.screenSizePerspectiveEnabled];
    }, () => {
      var _a2;
      const e32 = i23.screenSizePerspectiveEnabled && this.layer.screenSizePerspectiveEnabled;
      e32 !== this.symbolCreationContext.screenSizePerspectiveEnabled && (this.symbolCreationContext.screenSizePerspectiveEnabled = e32, (_a2 = this._labeler) == null ? void 0 : _a2.reset(), this.recreateAllGraphicsAndSymbols());
    }), l6(() => this.owner.slicePlaneEnabled, (e32) => this._slicePlaneEnabledChange(!!e32)), l6(() => {
      var _a2;
      return (_a2 = this.owner.view.state) == null ? void 0 : _a2.pixelRatio;
    }, () => this._pixelRatioChange()), l6(() => {
      var _a2;
      return !!((_a2 = this.owner.view.qualitySettings) == null ? void 0 : _a2.physicallyBasedRenderingEnabled);
    }, (e32) => this._physicalBasedRenderingChange(e32)), l6(() => {
      var _a2, _b2;
      return !!((_b2 = (_a2 = this.owner.view.qualitySettings) == null ? void 0 : _a2.graphics3D) == null ? void 0 : _b2.skipHighSymbolLods);
    }, (e32) => this._skipHighSymbolLoDsChange(e32)), f3(() => {
      var _a2;
      return (_a2 = i23.basemapTerrain) == null ? void 0 : _a2.tilingScheme;
    }, (e32) => {
      if (!e32.spatialReference.equals(this.symbolCreationContext.overlaySR) && r(i23.basemapTerrain.spatialReference) && (this.symbolCreationContext.overlaySR = i23.basemapTerrain.spatialReference), this._handles.has("loaded-graphics"))
        this.recreateAllGraphics();
      else {
        const e33 = () => {
          var _a2;
          return (_a2 = this.owner) == null ? void 0 : _a2.loadedGraphics;
        };
        this._handles.add([a4(e33, "change", (e34) => {
          this._graphicsCollectionChanged(e34), this._signalUpdatingDuringAsyncLoadedGraphicsChange();
        }, { onListenerAdd: () => {
          this.recreateAllGraphics(), this._signalUpdatingDuringAsyncLoadedGraphicsChange();
        } })], "loaded-graphics");
      }
    }, { initial: true }), l6(() => this.effectiveUpdatePolicy, (e32) => {
      r(this.stageLayer) && (this.stageLayer.updatePolicy = e32), this.symbolCreationContext.isAsync = this.effectiveUpdatePolicy === i6.ASYNC, e32 === i6.SYNC && this.runTask(F4);
    }, w5)]), this._frameTask = i23.resourceController.scheduler.registerTask(I2.GRAPHICS_CORE, this), this.layer && "featureReduction" in this.layer && this._handles.add(l6(() => this.layer.featureReduction, () => this._deconflictor.featureReductionChange())), this.notifyChange("averageSymbolComplexity"), this.rendererChange(this.owner.renderer).catch(() => {
    }), this._initializeAbortController = null;
  }
  _abortInitialize() {
    this._initializeAbortController && (this._initializeAbortController.abort(), this._initializeAbortController = null);
  }
  destroy() {
    this._abortInitialize(), this._abortRendererChange(), this._abortElevationInfoChange(), this.owner.view.deconflictor.removeGraphicsOwner(this), this.owner.view.labeler.removeGraphicsOwner(this), this._elevationAlignment = s(this._elevationAlignment), this._scaleVisibility = s(this._scaleVisibility), this._filterVisibility = s(this._filterVisibility), this._deconflictor = null, this._labeler = null, this._objectStates = s(this._objectStates), this.clear(), this._featureStore = s(this._featureStore), this._updatingPendingLoadedGraphicsChange = h(this._updatingPendingLoadedGraphicsChange), this._graphicStateTracking = s(this._graphicStateTracking), this.stage && (this.stage.remove(this.stageLayer), this.stageLayer = null, this.stage = null), this._handles = s(this._handles), this._frameTask.remove(), this._frameTask = y5, this._viewSpatialReference = null, this._set("owner", null);
    for (const e31 in this._whenGraphics3DGraphicRequests)
      this._whenGraphics3DGraphicRequests[e31].reject(new s4("graphic:layer-destroyed", "Layer has been destroyed"));
    this._whenGraphics3DGraphicRequests = null, this._sharedSymbolResourcesOwnerHandle = h(this._sharedSymbolResourcesOwnerHandle), this._propertiesPool = s(this._propertiesPool), this._pendingUpdatesPool = null, this._symbolConversionCache.clear(), this._objectIdInvisibleSet.clear(), this._spatialIndex = s(this._spatialIndex);
  }
  clear() {
    var _a, _b;
    (_a = this._objectStates) == null ? void 0 : _a.allGraphicsDeleted(), r(this._graphicStateTracking) && this._graphicStateTracking.allGraphicsDeleted(), this.graphics3DGraphics.forEach((e31) => e31.destroy()), (_b = this._spatialIndex) == null ? void 0 : _b.clear(), this.graphics3DGraphics.clear(), this._numberOfGraphics = 0, this._usedMemory = 0, this._updateLayerVisibility(), this._symbols.forEach(s), this._symbols.clear(), this._graphicsBySymbol.clear(), this._graphicsWithoutSymbol.clear(), this._graphicsWaitingForSymbol.clear(), this._pendingUpdates.clear(), this._pendingUpdatesPool.clear(), this._pendingAdds = 0, this._pendingRemoves = 0, this.notifyChange("updating"), this.notifyChange("running"), this.notifyChange("updatingRemaining"), this._featureStore.events.emit("changed");
  }
  _initializeStage(e31, i23) {
    this.stage = e31._stage, this.stageLayer = new l19({ isPickable: !this.suspendedOrOutsideOfView, updatePolicy: this.effectiveUpdatePolicy }, i23), this.stage.add(this.stageLayer);
    const t24 = this.stageLayer.events;
    t24.on("objectTransformation", (e32) => this.notifyGraphicGeometryChanged(e32.metadata.graphicUid)), t24.on("visibilityChanged", (e32) => this.notifyGraphicVisibilityChanged(e32.metadata.graphicUid)), t24.on("objectGeometryAdded", (e32) => this.notifyGraphicGeometryChanged(e32.object.metadata.graphicUid)), t24.on("objectGeometryRemoved", (e32) => this.notifyGraphicGeometryChanged(e32.object.metadata.graphicUid)), t24.on("vertexAttrsUpdated", (e32) => this.notifyGraphicGeometryChanged(e32.object.metadata.graphicUid));
  }
  notifyGraphicGeometryChanged(e31) {
    if (t(this._graphicStateTracking) || t(e31))
      return;
    const i23 = this.graphics3DGraphics.get(e31);
    i23 && this._graphicStateTracking.updateGraphicGeometry(i23);
  }
  notifyGraphicVisibilityChanged(e31) {
    if (t(this._graphicStateTracking) || t(e31))
      return;
    const i23 = this.graphics3DGraphics.get(e31);
    i23 && this._graphicStateTracking.updateGraphicVisibility(i23);
  }
  _updateLayerVisibility() {
    const e31 = this.displayFeatureLimit.maximumNumberOfFeatures, i23 = this._numberOfGraphics > e31 * ze, t24 = !this.suspendedOrOutsideOfView && !i23;
    t24 !== this._visible && (this._visible = t24, t24 ? (this.stageLayer.isPickable = true, this.updateAllGraphicsVisibility()) : (this.stageLayer.isPickable = false, this._hideAllGraphics()), this._updateStageLayerVisibility());
  }
  _updateStageLayerVisibility() {
    this.stageLayer.isVisible = this._visible && (null == this.layer.opacity || this.layer.opacity > 0);
  }
  getGraphics3DGraphicById(e31) {
    return this.graphics3DGraphics.get(e31);
  }
  getGraphics3DGraphicByObjectId(e31) {
    var _a;
    return ((_a = this.owner.layer) == null ? void 0 : _a.objectIdField) ? this._findGraphics3DGraphicByObjectId(e31) : null;
  }
  _getGraphicObjectID(e31, i23 = this.owner.layer && this.owner.layer.objectIdField) {
    return O5(e31, i23);
  }
  get graphics3DGraphicsByObjectID() {
    const e31 = this.owner.layer && this.owner.layer.objectIdField;
    if (!e31)
      return null;
    const i23 = /* @__PURE__ */ new Map();
    return this.graphics3DGraphics.forEach((t24) => {
      if (!t24)
        return;
      const r30 = t24.graphic, s23 = this._getGraphicObjectID(r30, e31);
      r(s23) && i23.set(s23, t24);
    }), i23;
  }
  get labelsEnabled() {
    return !(!this._labeler || !this._labeler.layerLabelsEnabled());
  }
  async updateLabelingInfo(e31) {
    const i23 = this._deconflictor && this._deconflictor.labelingInfoChange(e31), t24 = this._labeler && this._labeler.labelingInfoChange(e31);
    await E([i23, t24]);
  }
  updateVisibilityInfo() {
    this._deconflictor && this._deconflictor.labelingInfoChange(), this._labeler && this._labeler.visibilityInfoChange();
  }
  get symbolUpdateType() {
    if (this._pendingUpdates.size > 0)
      return "unknown";
    let e31 = 0, i23 = 0;
    return n3(this._symbols, (t24, r30) => {
      if (r(t24)) {
        const s23 = t24.getFastUpdateStatus();
        if (s23.loading > 0)
          return true;
        this._graphicsBySymbol.has(r30) && (i23 += s23.fast, e31 += s23.slow);
      }
      return false;
    }) ? "unknown" : i23 >= 0 && 0 === e31 ? "fast" : e31 >= 0 && 0 === i23 ? "slow" : "mixed";
  }
  runTask(e31) {
    this._frameTask.processQueue(e31), this._applyPendingUpdates(e31), this.notifyChange("running"), this.running || this.notifyChange("updating"), this.notifyChange("updatingRemaining");
  }
  setObjectIdVisibility(e31, i23) {
    i23 ? this._objectIdInvisibleSet.delete(e31) : this._objectIdInvisibleSet.add(e31);
    const t24 = this._findGraphics3DGraphicByObjectId(e31);
    r(t24) && this._updateUserVisibility(t24);
  }
  _findGraphics3DGraphicByObjectId(e31) {
    return t2(this.graphics3DGraphics, (i23) => this._getGraphicObjectID(i23.graphic) === e31);
  }
  _updateUserVisibility(e31) {
    if (t(e31))
      return false;
    const i23 = e31.graphic, t24 = this._getGraphicObjectID(i23), r30 = i23.visible && !this.owner.suspended && (t(t24) || !this._objectIdInvisibleSet.has(t24));
    return e31.setVisibilityFlag(C7.USER_SETTING, r30, E12.GRAPHIC);
  }
  _whenGraphics3DGraphic(e31) {
    const i23 = this.graphics3DGraphics.get(e31.uid);
    if (i23)
      return Promise.resolve(i23);
    const t24 = this._whenGraphics3DGraphicRequests[e31.uid];
    if (t24)
      return t24.promise;
    const r30 = A();
    return this._whenGraphics3DGraphicRequests[e31.uid] = r30, r30.promise;
  }
  async _boundsForGraphics3DGraphic(e31, i23) {
    const t24 = this._viewSpatialReference, r30 = this.owner.view.renderSpatialReference, s23 = this.owner.view.basemapTerrain.spatialReference, a29 = (e32, i24, s24) => xn(e32, r30, i24, e32, t24, i24, s24), n26 = (e32, i24, r31) => xn(e32, s23, i24, e32, t24, i24, r31), o24 = this._viewElevationProvider ? { service: this._viewElevationProvider, useViewElevation: r(i23) && i23.useViewElevation, minDemResolution: r(i23) && i23.minDemResolution, minDemResolutionForPoints: this.owner.view.resolution } : null, l32 = await e31.getProjectedBoundingBox(a29, n26, o24, q(i23, "signal"));
    if (!l32)
      return null;
    const c31 = l32.boundingBox;
    if (l32.requiresDrapedElevation) {
      const e32 = this.symbolCreationContext.elevationProvider;
      if (e32) {
        p4(c31, Oe);
        const i24 = i(e32.getElevation(Oe[0], Oe[1], 0, t24, "ground"), 0);
        c31[2] = Math.min(c31[2], i24), c31[5] = Math.max(c31[5], i24);
      }
    }
    return { boundingBox: c31, screenSpaceObjects: l32.screenSpaceObjects };
  }
  async whenGraphicBounds(e31, i23) {
    await j3(() => {
      var _a;
      return (_a = this.owner) == null ? void 0 : _a.loadedGraphics;
    });
    const t24 = this.owner.layer && this.owner.layer.objectIdField, s23 = this.owner.loadedGraphics.find((i24) => i24 === e31 || t24 && i24.attributes && e31.attributes && i24.attributes[t24] === e31.attributes[t24]);
    if (!s23)
      throw new s4("internal:graphic-not-part-of-view", "Graphic is not part of this view");
    const a29 = await this._whenGraphics3DGraphic(s23);
    return this._boundsForGraphics3DGraphic(a29, i23);
  }
  computeAttachmentOrigin(e31, i23) {
    const t24 = this.graphics3DGraphics.get(e31.uid);
    if (!t24)
      return null;
    const r30 = t24.computeAttachmentOrigin();
    if (0 === r30.render.num && 0 === r30.draped.num)
      return null;
    o2(We, 0, 0, 0);
    let s23 = 0;
    if (r30.render.num > 0) {
      if (!jn(r30.render.origin, this.symbolCreationContext.renderCoordsHelper.spatialReference, Me, i23))
        return null;
      u(We, We, Me), s23++;
    }
    if (r30.draped.num > 0) {
      const [e32, t25] = r30.draped.origin, a29 = i(this._viewElevationProvider.getElevation(e32, t25, "ground"), 0);
      if (o2(Me, e32, t25, a29), !jn(Me, this._viewElevationProvider.spatialReference, Me, i23))
        return null;
      u(We, We, Me), s23++;
    }
    return s23 > 1 && g(We, We, 1 / s23), new w3({ x: We[0], y: We[1], z: We[2], spatialReference: i23 });
  }
  getSymbolLayerSize(e31, i23) {
    const t24 = this._symbols.get(e31.id);
    if (t(t24))
      throw new s4("internal:symbol-not-part-of-view", "Symbol is not part of this view");
    const s23 = e31.symbolLayers.indexOf(i23);
    if (-1 === s23)
      throw new s4("internal:missing-symbol-layer", "Symbol layer is not in symbol");
    const a29 = t24.getSymbolLayerSize(s23);
    if (null == a29)
      throw new s4("internal:missing-size", "Symbol layer has no valid size");
    return a29;
  }
  _graphicsCollectionChanged(e31) {
    this._startCreateGraphics && (this.add(e31.added), this.remove(e31.removed));
  }
  graphicUpdateHandler(e31) {
    const i23 = e31.graphic.uid, t24 = this.graphics3DGraphics.get(i23);
    if (!t(t24) || !t(this._graphicsWithoutSymbol.get(i23)))
      switch (e31.property) {
        case "visible":
          this._graphicUpdateVisibleHandler(t24);
          break;
        case "geometry":
          this._graphicUpdateGeometryHandler(t24, e31);
          break;
        case "symbol":
          this._graphicUpdateSymbolHandler(t24, e31);
          break;
        case "attributes":
          break;
        case "transform":
          this._graphicUpdateTransformHandler(t24, e31);
      }
  }
  _graphicUpdateGeometryHandler(e31, i23) {
    const t24 = i23.graphic.geometry;
    if (t(t24))
      return void this._recreateGraphic(i23.graphic);
    if (t(e31)) {
      const e32 = i23.graphic.symbol && i23.graphic.symbol.id;
      if (e32) {
        const i24 = this._symbols.get(e32);
        if (r(i24) && i24.loadStatus === e21.LOADING)
          return;
      }
      return void this._recreateGraphic(i23.graphic);
    }
    const r30 = e31.graphics3DSymbol;
    !t(i23.newValue) && r30.updateGeometry(e31, i23.newValue) || this._recreateGraphic(e31.graphic), this._expandComputedExtent(t24);
  }
  _graphicUpdateSymbolHandler(e31, i23) {
    const t24 = i23.graphic, r30 = r(e31) ? e31.graphics3DSymbol : r(i23.oldValue) ? this._symbols.get(i23.oldValue.id) : null;
    if (t(r30) || t(i23.newValue))
      return void this._recreateGraphic(t24);
    const s23 = r30.symbol, a29 = this._getConvertedSymbol(i23.newValue);
    if (r(a29) && (a29.type !== s23.type || "web-style" === a29.type) || "web-style" === s23.type)
      return void this._recreateGraphic(t24);
    const n26 = this._graphicsBySymbol.get(s23.id);
    if (n26 && 1 !== n26.size)
      return void this._recreateGraphic(t24);
    const o24 = m6(s23, a29);
    if (t(o24))
      return void this._updateSymbolMapping(s23.id, a29);
    const l32 = { diff: o24, graphics3DGraphicPatches: [], symbolStatePatches: [] };
    if (r30.prepareSymbolPatch(l32), !d5(l32.diff))
      return void this._recreateGraphic(t24);
    const d27 = this._getRenderingInfo(t24);
    if (t(d27))
      return void this._recreateGraphic(t24);
    const p21 = r30.extentPadding;
    for (const h25 of l32.symbolStatePatches)
      h25();
    if (p21 !== r30.extentPadding && this._recomputeExtentPadding(), r(e31))
      for (const h25 of l32.graphics3DGraphicPatches)
        h25(e31, d27);
    this._updateSymbolMapping(s23.id, a29);
  }
  _graphicUpdateVisibleHandler(e31) {
    this._updateUserVisibility(e31) && (this._labeler && this.owner.view.labeler.setDirty(), this.owner.view.deconflictor.setDirty());
  }
  _graphicUpdateTransformHandler(e31, i23) {
  }
  recreateGraphics(e31) {
    this._suspendSymbolCleanup = true, this.remove(e31), this.add(e31), this._suspendSymbolCleanup = false, this.effectiveUpdatePolicy === i6.SYNC && this._cleanupSymbols();
  }
  _recreateGraphic(e31) {
    this.recreateGraphics([e31]);
  }
  _beginGraphicUpdate(e31) {
    const i23 = this._graphicsUpdateId;
    return this._graphicsUpdateId++, this._graphicsWaitingForSymbol.set(e31.uid, i23), 1 === this._graphicsWaitingForSymbol.size && this.notifyChange("updating"), i23;
  }
  _endGraphicUpdate(e31) {
    e31 && (this._graphicsWaitingForSymbol.delete(e31.uid), 0 === this._graphicsWaitingForSymbol.size && (this._cleanupSymbols(), this.notifyChange("updating")));
  }
  _recomputeExtentPadding() {
    let e31 = 0;
    this._symbols.forEach((i23) => {
      r(i23) && (e31 = Math.max(e31, i23.extentPadding));
    }), this._set("extentPadding", e31);
  }
  _expandComputedExtent(e31) {
    const i23 = je, t24 = e31.spatialReference;
    T3(e31, i23);
    const r30 = this._viewSpatialReference, s23 = Ue.tmpVec;
    if (E2(t24, r30) || Bn(i23[0], i23[1], 0, t24, s23, r30) && (i23[0] = s23[0], i23[1] = s23[1], Bn(i23[3], i23[4], 0, t24, s23, r30), i23[3] = s23[0], i23[4] = s23[1]), !(isFinite(i23[0]) && isFinite(i23[3]) && isFinite(i23[1]) && isFinite(i23[4])))
      return;
    const a29 = this.computedExtent;
    let n26 = null;
    const o24 = isFinite(i23[2]) && isFinite(i23[5]), l32 = o24 && (!a29 || null == a29.zmin || i23[2] < a29.zmin), h25 = o24 && (!a29 || null == a29.zmax || i23[5] > a29.zmax);
    if (a29) {
      (i23[0] < a29.xmin || i23[1] < a29.ymin || i23[3] > a29.xmax || i23[4] > a29.ymax || l32 || h25) && (n26 = this._propertiesPool.get("computedExtent"), n26.xmin = Math.min(i23[0], a29.xmin), n26.ymin = Math.min(i23[1], a29.ymin), n26.xmax = Math.max(i23[3], a29.xmax), n26.ymax = Math.max(i23[4], a29.ymax), n26.spatialReference = r30);
    } else
      n26 = this._propertiesPool.get("computedExtent"), n26.xmin = i23[0], n26.ymin = i23[1], n26.xmax = i23[3], n26.ymax = i23[4], n26.spatialReference = r30;
    n26 && (l32 && (n26.zmin = i23[2]), h25 && (n26.zmax = i23[5]), this._set("computedExtent", n26));
  }
  _abortElevationInfoChange() {
    this._elevationInfoChangeAbortController && (this._elevationInfoChangeAbortController.abort(), this._elevationInfoChangeAbortController = null);
  }
  async elevationInfoChange() {
    var _a, _b;
    this._abortElevationInfoChange();
    const e31 = new AbortController();
    this._elevationInfoChangeAbortController = e31;
    const i23 = d12(this.layer.elevationInfo, this.elevationFeatureExpressionEnabled);
    this.symbolCreationContext.featureExpressionInfoContext = await u17(i23, this._viewSpatialReference, e31.signal, Ve), f2(e31.signal), this._elevationInfoChangeAbortController = null, (_a = this._labeler) == null ? void 0 : _a.elevationInfoChange(), this.forEachGraphics3DSymbol((e32, i24, t24) => {
      e32.globalPropertyChanged("elevationInfo", i24) ? i24.forEach((e33) => {
        const i25 = e33.graphic, t25 = e33.labelGraphics;
        for (const r30 of t25) {
          r30.graphics3DSymbolLayer.updateGraphicElevationContext(i25, r30);
        }
      }) : this._recreateSymbol(t24);
    }), this.updateStageLayerElevationProvider(), (_b = this._elevationAlignment) == null ? void 0 : _b.elevationInfoChange();
  }
  updateStageLayerElevationProvider() {
    this._stageLayerElevationProvider ? (this.layer.elevationInfo && "relative-to-scene" === this.layer.elevationInfo.mode || 0 === this._numberOfGraphicsProvidingElevation) && (this.owner.view.elevationProvider.unregister(this._stageLayerElevationProvider), this._stageLayerElevationProvider.dispose(), this._stageLayerElevationProvider = null) : (!this.layer.elevationInfo || this.layer.elevationInfo && "relative-to-scene" !== this.layer.elevationInfo.mode) && this._numberOfGraphicsProvidingElevation > 0 && (this._stageLayerElevationProvider = new b23({ layer: this.layer, stageLayer: this.stageLayer, view: this.owner.view }), this.owner.view.elevationProvider.register("scene", this._stageLayerElevationProvider));
  }
  _clearSymbolsAndGraphics() {
    var _a, _b, _c, _d;
    this.clear(), r(this._filterVisibility) && this._filterVisibility.clear(), (_a = this._labeler) == null ? void 0 : _a.reset(), (_b = this._deconflictor) == null ? void 0 : _b.clear(), (_c = this._elevationAlignment) == null ? void 0 : _c.clear(), (_d = this.stageLayer) == null ? void 0 : _d.invalidateSpatialQueryAccelerator(), this._stageLayerElevationProvider && (this.owner.view.elevationProvider.unregister(this._stageLayerElevationProvider), this._stageLayerElevationProvider.dispose(), this._stageLayerElevationProvider = null);
  }
  startCreateGraphics() {
    this._startCreateGraphics = true, this.recreateAllGraphics();
  }
  recreateAllGraphics() {
    this._recreateAllGraphics(false);
  }
  recreateAllGraphicsAndSymbols() {
    this._recreateAllGraphics(true);
  }
  _recreateAllGraphics(e31 = false) {
    if (!this._startCreateGraphics)
      return;
    const { loadedGraphics: i23, view: t24 } = this.owner, r30 = t24.basemapTerrain.tilingScheme && i23 && i23.length ? i23.toArray() : null;
    !e31 && r30 || this._clearSymbolsAndGraphics(), this.symbolCreationContext.screenSizePerspectiveEnabled = this.owner.view.screenSizePerspectiveEnabled && this.layer.screenSizePerspectiveEnabled, this.symbolCreationContext.slicePlaneEnabled = !!this.owner.slicePlaneEnabled, this._set("computedExtent", null), r30 && (e31 ? this.add(r30) : this.recreateGraphics(r30));
  }
  _recreateSymbol(e31) {
    const i23 = this._graphicsBySymbol.get(e31), t24 = [];
    i23 && (i23.forEach((e32, i24) => {
      var _a;
      const r31 = e32.usedMemory;
      this._conditionalRemove(e32, i24), (_a = this._spatialIndex) == null ? void 0 : _a.remove(e32), t24.push(e32.graphic), e32.destroy(), this._removeGraphics3DGraphic(i24, r31), this._updateLayerVisibility(), this._featureStore.events.emit("changed");
    }), this._graphicsBySymbol.set(e31, /* @__PURE__ */ new Map()));
    const r30 = this._symbols.get(e31);
    s(r30), this._symbols.delete(e31), this.add(t24);
  }
  _recreateGraphicsForSymbol(e31) {
    const i23 = this._graphicsBySymbol.get(e31);
    if (i23) {
      const e32 = [];
      i23.forEach((i24) => e32.push(i24.graphic)), this.recreateGraphics(e32);
    }
  }
  _conditionalRemove(e31, i23) {
    var _a, _b, _c;
    this._graphicsDrapedUids.delete(i23), (_a = this._objectStates) == null ? void 0 : _a.removeGraphic(e31), (_b = this._labeler) == null ? void 0 : _b.removeGraphic(e31), (_c = this._deconflictor) == null ? void 0 : _c.removeGraphic(e31), r(this._graphicStateTracking) && this._graphicStateTracking.removeGraphic(e31);
  }
  add(e31) {
    e31 && 0 !== e31.length && (this.owner.view.basemapTerrain && this.owner.view.basemapTerrain.tilingScheme ? (this._updatePolicyForGraphics(e31) === i6.ASYNC ? this._addDelayed(e31) : this._addImmediate(e31), this.notifyChange("updating")) : Ve.error("#add()", "Cannot add graphics before terrain surface has been initialized"));
  }
  _updatePolicyForGraphics(e31) {
    if (this.effectiveUpdatePolicy === i6.SYNC && ("mesh" === this.layer.geometryType || null == this.layer.geometryType)) {
      for (const i23 of e31)
        if (r(i23.geometry) && "mesh" === i23.geometry.type && !i23.geometry.loaded)
          return i6.ASYNC;
    }
    return this.effectiveUpdatePolicy;
  }
  _addImmediate(e31) {
    this._geometryWarningLogged = false, this._symbolWarningLogged = false;
    for (const i23 of e31)
      this._addGraphic(i23, this._getRenderingInfo(i23, Ve), i6.SYNC);
    this._cleanupSymbols(), this._labeler && (this.owner.view.labeler.setDirty(), this._cleanupSymbols()), this.owner.view.deconflictor.setDirty();
  }
  _addDelayed(e31) {
    for (const i23 of e31) {
      const e32 = i23.uid;
      let t24 = this._pendingUpdates.get(e32);
      t24 ? t24.add ? t24.state !== Te2.NEW && t24.abortController.abort() : this._pendingAdds++ : (t24 = this._pendingUpdatesPool.pushNew(), this._pendingAdds++, this._pendingUpdates.set(e32, t24)), t24.add = i23;
    }
    this.notifyChange("running"), this.notifyChange("updatingRemaining");
  }
  remove(e31) {
    this.effectiveUpdatePolicy === i6.ASYNC ? this._removeDelayed(e31) : this._removeImmediate(e31), this.notifyChange("updating");
  }
  _removeImmediate(e31) {
    for (const i23 of e31)
      this._removeGraphic(i23);
    this._cleanupSymbols(), this._labeler && this.owner.view.labeler.setDirty(), this.owner.view.deconflictor.setDirty();
  }
  _removeDelayed(e31) {
    for (const i23 of e31) {
      const e32 = i23.uid, t24 = this._pendingUpdates.get(e32);
      if (t24)
        t24.add && (t24.remove ? t24.add = null : this._pendingUpdates.delete(e32), t24.state === Te2.LOADING && t24.abortController.abort(), this._pendingAdds--);
      else {
        const t25 = this._pendingUpdatesPool.pushNew();
        t25.remove = i23, this._pendingUpdates.set(e32, t25), this._pendingRemoves++;
      }
    }
    0 === this._pendingUpdates.size && this._finishPendingUpdates(), this.notifyChange("running"), this.notifyChange("updatingRemaining");
  }
  _finishPendingUpdates() {
    this._pendingUpdatesPool.clear(), this._cleanupSymbols(), (this._pendingAdds || this._pendingRemoves) && Ve.warn("pendingAdds/Removes in inconsistent state!"), this._pendingAdds = 0, this._pendingRemoves = 0;
  }
  _applyPendingUpdates(e31) {
    var _a;
    if (this._geometryWarningLogged = false, this._symbolWarningLogged = false, 0 === this._pendingUpdates.size && ((_a = this._spatialIndex) == null ? void 0 : _a.updating))
      this._spatialIndex.update();
    else {
      for (const [i23, t24] of this._pendingUpdates) {
        if (e31.done)
          break;
        t24.add && t24.state === Te2.NEW && this._processPendingUpdateNew(t24);
        let r30 = this.effectiveUpdatePolicy;
        if (!t24.remove || t24.add && t24.state !== Te2.READY || (this._pendingRemoves--, e31.madeProgress(), this._removeGraphic(t24.remove), t24.remove = null, r30 = i6.SYNC), t24.add)
          switch (t24.state) {
            case Te2.READY:
              this._addGraphic(t24.add, t24.renderingInfo, r30), t24.add = null, this._pendingAdds--, e31.madeProgress();
              break;
            case Te2.REJECTED:
              t24.add = null, this._pendingAdds--;
            case Te2.LOADING:
          }
        null == t24.remove && null == t24.add && this._pendingUpdates.delete(i23);
      }
      0 === this._pendingUpdates.size && (this._finishPendingUpdates(), this.notifyChange("running"));
    }
  }
  _processPendingUpdateNew(e31) {
    if (!e31.add)
      return void (e31.state = Te2.READY);
    const i23 = e31.add.geometry;
    r(i23) && "mesh" === i23.type && !i23.loaded ? this._processPendingUpdateNewMesh(e31, i23) : this._processPendingUpdateNewRenderingInfo(e31);
  }
  async _processPendingUpdateNewMesh(e31, i23) {
    e31.state = Te2.LOADING, e31.abortController = new AbortController();
    const t24 = e31.abortController.signal;
    try {
      await i23.load({ signal: t24 });
    } catch (r30) {
      return this._processPendingUpdateNewError(e31, r30);
    }
    e31.abortController = null, this._processPendingUpdateNewRenderingInfo(e31);
  }
  _processPendingUpdateNewError(e31, i23) {
    e31.abortController = null, j2(i23) ? e31.state = Te2.NEW : e31.state = Te2.REJECTED;
  }
  async _processPendingUpdateNewRenderingInfo(e31) {
    if (t(this.layer.renderer) || "dictionary" !== this.layer.renderer.type)
      return e31.renderingInfo = this._getRenderingInfo(e31.add, Ve), void (e31.state = Te2.READY);
    e31.state = Te2.LOADING, e31.abortController = new AbortController();
    let i23 = null;
    try {
      i23 = await this._getRenderingInfoAsync(e31.add, { signal: e31.abortController.signal });
    } catch (t24) {
      return e31.abortController = null, void (j2(t24) ? e31.state = Te2.NEW : e31.state = Te2.REJECTED);
    }
    t(i23) || t(i23.symbol) ? (Ve && !this._symbolWarningLogged && (this._symbolWarningLogged = true, Ve.warn(`Graphic in layer ${this.layer.id} has no symbol and will not render`)), e31.renderingInfo = null) : e31.renderingInfo = i23, e31.state = Te2.READY;
  }
  _addGraphic(e31, i23, t24) {
    if (this._graphicsWithoutSymbol.set(e31.uid, e31), t(i23) || t(i23.symbol) || !M4(e31))
      return;
    has("enable-feature:objectAndLayerId-rendering") && this.setUidToIdOnAdd && this.stage.renderView._objectAndLayerIdRenderHelper.setUidToObjectAndLayerId(e31.objectId, e31.uid, this.layer.id, this.layer.uid, this.layer.popupEnabled);
    const r30 = i23.symbol, s23 = this.getOrCreateGraphics3DSymbol(r30, i23.renderer);
    if (t(s23))
      return;
    this._expandComputedExtent(e31.geometry);
    const a29 = this._beginGraphicUpdate(e31), n26 = new r17(e31, i23, this.layer);
    let o24 = false;
    const l32 = (e32) => {
      e32 === s23.symbol.id && (o24 = true);
    };
    this._whenSymbolRemoved.push(l32);
    const d27 = () => {
      if (--this._loadingSymbols, this.destroyed)
        return;
      this._whenSymbolRemoved.removeUnordered(l32);
      if (this._graphicsWaitingForSymbol.get(e31.uid) !== a29 || o24 || s23.destroyed || this.graphicSymbolSupported && e31.symbol && e31.symbol.id !== s23.symbol.id)
        --s23.referenced, this._cleanupSymbols();
      else {
        const i24 = this._createGraphics3DGraphic(s23, n26);
        this._spatialIndex && r(i24) && this._spatialIndex.add(i24), --s23.referenced, this._endGraphicUpdate(e31);
      }
      this._featureStore.events.emit("changed"), this._labeler && this.owner.view.labeler.setDirty();
    }, p21 = (i24) => {
      --this._loadingSymbols, this.destroyed || (this._whenSymbolRemoved.removeUnordered(l32), o24 || (j2(i24) ? this.add([e31]) : s23.destroyed || this._endGraphicUpdate(e31)));
    };
    ++this._loadingSymbols, t24 === i6.ASYNC ? s23.load(() => this._frameTask.schedule(d27), (e32) => this._frameTask.schedule(() => p21(e32))) : s23.load(d27, p21);
  }
  _removeGraphic(e31) {
    var _a;
    const i23 = e31.uid, t24 = this.graphics3DGraphics.get(i23);
    if (t24) {
      t24.graphics3DSymbol.onRemoveGraphic(t24);
      const e32 = t24.usedMemory, r30 = t24.isElevationSource;
      this._conditionalRemove(t24, i23), (_a = this._spatialIndex) == null ? void 0 : _a.remove(t24);
      const s23 = t24.graphics3DSymbol.symbol.id;
      this._graphicsBySymbol.get(s23).delete(i23), this._graphicsWithoutSymbol.delete(i23), this._removeGraphics3DGraphic(i23, e32, r30), t24.destroy(), this._featureStore.events.emit("changed");
    } else
      this._graphicsWithoutSymbol.delete(i23), this._graphicsWaitingForSymbol.delete(i23), 0 === this._graphicsWaitingForSymbol.size && (this._cleanupSymbols(), this.notifyChange("updating"));
  }
  _hasLabelingContext(e31) {
    if (e31 instanceof b6 || e31 instanceof m5) {
      const i23 = this.symbolCreationContext.layer;
      return !!i23.labelingInfo && i23.labelingInfo.some((i24) => i24.symbol === e31);
    }
    return false;
  }
  _hasValidSymbolCreationContext(e31) {
    return !(e31 instanceof b6 && !this._hasLabelingContext(e31)) || (Ve.error("LabelSymbol3D is only valid as part of a LabelClass. Using LabelSymbol3D as a renderer symbol is not supported."), false);
  }
  _getRenderingInfo(e31, i23) {
    const t24 = e31.geometry;
    if (t(t24))
      return i23 && !this._geometryWarningLogged && (this._geometryWarningLogged = true, i23.warn(`Graphic in layer ${this.layer.id} has no geometry and will not render`)), null;
    if (!An(t24.spatialReference, this._viewSpatialReference))
      return i23 && !this._geometryWarningLogged && (this._geometryWarningLogged = true, i23.warn(`Graphic in layer ${this.layer.id} has incompatible spatial reference and will not render`)), null;
    if (!this.graphicSymbolSupported && r(e31.symbol))
      return i23 && !this._symbolWarningLogged && (this._symbolWarningLogged = true, i23.warn(`Graphic in layer ${this.layer.id} is not allowed to have a symbol, use a renderer instead`)), null;
    const r30 = this.rendererHasGeometryOperations ? f11(e31, this.layer) : e31;
    let s23;
    if (this.owner.getRenderingInfo && (this.getRenderingInfoWithoutRenderer || r(this.currentRenderer)))
      s23 = this.owner.getRenderingInfo(r30, this.currentRenderer, this._arcadeOnDemand);
    else {
      s23 = { symbol: r30.symbol || b12(r30.geometry) };
    }
    return t(s23) || t(s23.symbol) ? (i23 && !this._symbolWarningLogged && (this._symbolWarningLogged = true, i23.warn(`Graphic in layer ${this.layer.id} has no symbol and will not render`)), null) : s23;
  }
  _getRenderingInfoAsync(e31, i23) {
    const t24 = e31.geometry;
    if (t(t24))
      return Ve && !this._geometryWarningLogged && (this._geometryWarningLogged = true, Ve.warn(`Graphic in layer ${this.layer.id} has no geometry and will not render`)), null;
    if (!this.graphicSymbolSupported && r(e31.symbol))
      return Ve && !this._symbolWarningLogged && (this._symbolWarningLogged = true, Ve.warn(`Graphic in layer ${this.layer.id} is not allowed to have a symbol, use a renderer instead`)), null;
    const r30 = this.rendererHasGeometryOperations ? f11(e31, this.layer) : e31;
    return this.owner.getRenderingInfoAsync(r30, this.currentRenderer, this._arcadeOnDemand, i23);
  }
  _createGraphics3DSymbol(e31, i23) {
    if (!this._hasValidSymbolCreationContext(e31))
      return null;
    const t24 = this._getConvertedSymbol(e31);
    if (!t24)
      return null;
    let r30;
    if (r(i23) && "backgroundFillSymbol" in i23 && i23.backgroundFillSymbol) {
      const e32 = S3(i23.backgroundFillSymbol, { ignoreDrivers: true });
      r(e32.symbol) && "web-style" !== e32.symbol.type && "cim" !== e32.symbol.type && (r30 = e32.symbol.symbolLayers);
    }
    const s23 = t22(t24, this.symbolCreationContext, r30);
    return s23.load(() => {
      const e32 = s23.extentPadding;
      e32 > this.extentPadding && this._set("extentPadding", e32), this.notifyChange("averageSymbolComplexity");
    }, () => {
    }), s23;
  }
  getOrCreateGraphics3DSymbol(e31, i23) {
    let t24 = this._symbols.get(e31.id);
    return void 0 === t24 && (t24 = e31 instanceof f6 ? new e28(e31, (e32) => this._frameTask.schedule(e32), (e32) => this._createGraphics3DSymbol(e32, i23)) : this._createGraphics3DSymbol(e31, i23), this._symbols.set(e31.id, t24)), r(t24) && ++t24.referenced, t24;
  }
  trackGraphicState(e31) {
    return t(this._graphicStateTracking) && (this._graphicStateTracking = new s20(this)), this._graphicStateTracking.add(e31);
  }
  _addGraphics3DGraphic(e31) {
    this._usedMemory += e31.usedMemory, this.graphics3DGraphics.set(e31.graphic.uid, e31), this._numberOfGraphics++, e31.isElevationSource && (this._numberOfGraphicsProvidingElevation++, this.updateStageLayerElevationProvider()), this._updateLayerVisibility();
  }
  _removeGraphics3DGraphic(e31, i23, t24 = false) {
    this._usedMemory -= i23, this.graphics3DGraphics.delete(e31), this._numberOfGraphics--, t24 && (this._numberOfGraphicsProvidingElevation--, this.updateStageLayerElevationProvider()), this._updateLayerVisibility();
  }
  _createGraphics3DGraphic(e31, i23) {
    var _a, _b, _c;
    const t24 = i23.graphic;
    if (this._graphicsWithoutSymbol.delete(t24.uid), !this._symbols.has(e31.symbol.id))
      return this.add([t24]), null;
    if (this.graphics3DGraphics.has(t24.uid))
      return null;
    const r30 = e31.createGraphics3DGraphic(i23);
    if (t(r30))
      return null;
    this._addGraphics3DGraphic(r30);
    const s23 = e31.symbol.id;
    this._graphicsBySymbol.has(s23) || this._graphicsBySymbol.set(s23, /* @__PURE__ */ new Map()), this._graphicsBySymbol.get(s23).set(t24.uid, r30);
    if (r30.isDraped && this._graphicsDrapedUids.add(t24.uid), r30.centroid = null, r(t24.geometry) && "point" !== t24.geometry.type && (r30.centroid = A6(t24.geometry, this._viewSpatialReference)), this._updateUserVisibility(r30), r(this._scaleVisibility) && this._scaleVisibility.updateVisibility(r30), r(this._filterVisibility)) {
      const { defaultVisibility: e32 } = this._filterVisibility;
      r30.setVisibilityFlag(C7.FILTER, e32, E12.GRAPHIC), e32 || this._filterVisibility.reapply();
    }
    (_a = this._deconflictor) == null ? void 0 : _a.addGraphic(r30), (_b = this._labeler) == null ? void 0 : _b.addGraphic(r30), (_c = this._objectStates) == null ? void 0 : _c.addGraphic(r30), this._deconflictor && this.owner.view.deconflictor.setInitialIconVisibilityFlag(this, r30), r30.initialize(this.stage, this.stageLayer, this.owner), r(this._graphicStateTracking) && this._graphicStateTracking.addGraphic(r30);
    const a29 = this._whenGraphics3DGraphicRequests[t24.uid];
    return a29 && (delete this._whenGraphics3DGraphicRequests[t24.uid], a29.resolve(r30)), r30;
  }
  _abortRendererChange() {
    this._rendererChangeAbortController && (this._rendererChangeAbortController.abort(), this._rendererChangeAbortController = null);
  }
  async rendererChange(e31) {
    if (this._abortRendererChange(), e31 !== this.currentRenderer)
      if (this._validateRenderer(e31), t(e31) && this._currentRendererChange(null, false), s10(e31))
        if (r(e31) && e31.arcadeRequired) {
          const i23 = new AbortController();
          this._rendererChangeAbortController = i23;
          const { arcadeUtils: t24 } = await this._ensureArcade();
          f2(i23);
          const r30 = t24.hasGeometryOperations(e31);
          r30 && (await t24.enableGeometryOperations(), f2(i23)), this.effectiveUpdatePolicy === i6.ASYNC ? await this._frameTask.schedule(() => this._currentRendererChange(e31, r30), i23.signal) : this._currentRendererChange(e31, r30), this._rendererChangeAbortController = null;
        } else if (this.effectiveUpdatePolicy === i6.ASYNC) {
          const i23 = new AbortController();
          this._rendererChangeAbortController = i23, await this._frameTask.schedule(() => this._currentRendererChange(e31, false), i23.signal), this._rendererChangeAbortController = null;
        } else
          this._currentRendererChange(e31, false);
      else
        this._currentRendererChange(e31, false);
  }
  async _ensureArcade() {
    return t(this._arcadeOnDemand) ? (this._arcadeOnDemand = await i10(), this._arcadeOnDemand) : this._arcadeOnDemand;
  }
  _currentRendererChange(e31, i23) {
    this.currentRenderer = e31, this.rendererHasGeometryOperations = i23, this.symbolCreationContext.arcade = e(this._arcadeOnDemand);
    const t24 = this.symbolCreationContext.renderer;
    if (e31 === t24)
      return;
    if (this._symbolConversionCache.clear(), t(e31))
      return this.symbolCreationContext.renderer = null, void this.recreateAllGraphicsAndSymbols();
    const r30 = m6(t24, e31);
    this._updateUnchangedSymbolMappings(r30, e31, t24), this.symbolCreationContext.renderer = e31, t(r30) || ("complete" === r30.type ? this.recreateAllGraphicsAndSymbols() : "partial" === r30.type && (this._applyRendererDiff(r30, e31, t24) ? this._volatileGraphicsUpdated() : this.recreateAllGraphicsAndSymbols()), this.notifyChange("averageSymbolComplexity"));
  }
  _diffHasSymbolChange(e31) {
    for (const i23 in e31.diff)
      switch (i23) {
        case "visualVariables":
        case "defaultSymbol":
        case "uniqueValueInfos":
          break;
        case "uniqueValueGroups":
        case "authoringInfo":
        case "fieldDelimiter":
          delete e31.diff[i23];
          break;
        default:
          return true;
      }
    return false;
  }
  _applySymbolSetDiff(e31, i23, t24) {
    e31 = e31 || [], i23 = i23 || [];
    const r30 = [];
    for (const s23 of i23) {
      const i24 = this._graphicsBySymbol.get(s23.id);
      i24 && i24.forEach((a29, n26) => {
        const o24 = a29.graphic, l32 = this.layer instanceof b5 ? this.layer : null, h25 = e(this._arcadeOnDemand);
        if (s23 === t24.defaultSymbol && t24.getSymbol(f11(o24, l32), { arcade: h25 }) === t24.defaultSymbol)
          return;
        const d27 = a29.usedMemory;
        e31.length || t24.defaultSymbol ? r30.push(o24) : this._graphicsWithoutSymbol.set(n26, o24);
        const c31 = this.graphics3DGraphics.get(n26);
        this._conditionalRemove(c31, n26), a29.destroy(), i24.delete(n26), this._removeGraphics3DGraphic(n26, d27), this._updateLayerVisibility();
      }), this._whenSymbolRemoved.forAll((e32) => e32(s23.id));
    }
    (e31.length || r30.length) && (this._graphicsWithoutSymbol.forEach((e32) => r30.push(e32)), this._graphicsWithoutSymbol.clear(), this.add(r30)), this._cleanupSymbols(), this._labeler && this.owner.view.labeler.setDirty(), this.owner.view.deconflictor.setDirty();
  }
  _applyUniqueValueRendererDiff(e31, i23, t24) {
    const r30 = e31.diff.defaultSymbol, s23 = e31.diff.uniqueValueInfos;
    if (r30 || s23) {
      const a29 = s23 ? s23.added.map((e32) => e32.symbol) : [], n26 = s23 ? s23.removed.map((e32) => e32.symbol) : [];
      if (s23)
        for (let e32 = 0; e32 < s23.changed.length; e32++)
          a29.push(s23.changed[e32].newValue.symbol), n26.push(s23.changed[e32].oldValue.symbol);
      return r30 ? (t24.defaultSymbol && n26.push(t24.defaultSymbol), i23.defaultSymbol && a29.push(i23.defaultSymbol)) : t24.defaultSymbol && a29.length && n26.push(i23.defaultSymbol), this._applySymbolSetDiff(a29, n26, i23), delete e31.diff.defaultSymbol, delete e31.diff.uniqueValueInfos, true;
    }
    return false;
  }
  _calculateUnchangedSymbolMapping(e31, i23, t24) {
    if ("unique-value" !== (i23 == null ? void 0 : i23.type) || "unique-value" !== (t24 == null ? void 0 : t24.type) || r(e31) && "partial" !== e31.type)
      return [];
    const r30 = (e32) => r(e32) ? e32.id : null, s23 = e31 && e31.diff, a29 = s23 && s23.defaultSymbol, n26 = s23 && s23.uniqueValueInfos;
    let o24;
    if (n26)
      o24 = n26.unchanged.map((e32) => ({ oldId: r30(e32.oldValue.symbol), newId: r30(e32.newValue.symbol) }));
    else {
      o24 = [];
      for (const e32 of t24.uniqueValueInfos) {
        const t25 = r30(e32.symbol), s24 = i23.uniqueValueInfos.find((i24) => i24.value === e32.value);
        s24 && t25 !== r30(s24.symbol) && o24.push({ oldId: t25, newId: r30(s24.symbol) });
      }
    }
    return !a29 && t24.defaultSymbol && o24.push({ oldId: r30(t24.defaultSymbol), newId: r30(i23.defaultSymbol) }), o24;
  }
  _updateSymbolMapping(e31, i23) {
    const t24 = r(i23) && i23 ? "string" == typeof i23 ? i23 : i23.id : null;
    if (!e31 || e31 === t24)
      return;
    const r30 = this._graphicsBySymbol.get(e31);
    this._graphicsBySymbol.delete(e31), void 0 !== r30 && this._graphicsBySymbol.set(t24, r30);
    const s23 = this._symbols.get(e31);
    if (void 0 !== s23 && (this._symbols.delete(e31), this._symbols.set(t24, s23), r(s23))) {
      const e32 = "string" == typeof i23 ? null : i23;
      r(e32) ? s23.symbol = e32 : s23.symbol.id = t24;
    }
  }
  _updateUnchangedSymbolMappings(e31, i23, t24) {
    const r30 = this._calculateUnchangedSymbolMapping(e31, i23, t24);
    for (const { oldId: s23, newId: a29 } of r30)
      this._updateSymbolMapping(s23, a29);
  }
  _applyRendererDiff(e31, t24, r30) {
    if (this._diffHasSymbolChange(e31))
      return false;
    if (t24 instanceof C3 && r30 instanceof C3 && this._applyUniqueValueRendererDiff(e31, t24, r30) && 0 === Object.keys(e31.diff).length)
      return true;
    for (const [i23] of this._graphicsBySymbol) {
      const r31 = this._symbols.get(i23);
      if (r(r31))
        switch (r31.applyRendererDiff(e31, t24)) {
          case e20.Recreate_Symbol:
            this._recreateSymbol(i23);
            break;
          case e20.Recreate_Graphics:
            this._recreateGraphicsForSymbol(i23);
          case e20.Fast_Update:
        }
    }
    return true;
  }
  opacityChange() {
    this.forEachGraphics3DSymbol((e31, i23) => e31.globalPropertyChanged("opacity", i23)), this._updateStageLayerVisibility();
  }
  _slicePlaneEnabledChange(e31) {
    e31 !== this.symbolCreationContext.slicePlaneEnabled && (this.symbolCreationContext.slicePlaneEnabled = e31, this.stageLayer.isSliceable = e31, this.forEachGraphics3DSymbol((e32, i23) => e32.globalPropertyChanged("slicePlaneEnabled", i23)), this._deconflictor && this._deconflictor.slicePlaneEnabledChange(), this._labeler && this._labeler.slicePlaneEnabledChange());
  }
  _physicalBasedRenderingChange(e31) {
    this.symbolCreationContext.physicalBasedRenderingEnabled = e31, this.forEachGraphics3DSymbol((e32, i23, t24) => {
      e32.globalPropertyChanged("physicalBasedRenderingEnabled", i23) || this._recreateSymbol(t24);
    });
  }
  _skipHighSymbolLoDsChange(e31) {
    this.symbolCreationContext.skipHighSymbolLods = e31, this.forEachGraphics3DSymbol((e32, i23, t24) => this._recreateSymbol(t24));
  }
  _pixelRatioChange() {
    this.forEachGraphics3DSymbol((e31, i23, t24) => {
      e31.globalPropertyChanged("pixelRatio", i23) || this._recreateSymbol(t24);
    });
  }
  _signalUpdatingDuringAsyncLoadedGraphicsChange() {
    this._updatingPendingLoadedGraphicsChange && this._updatingPendingLoadedGraphicsChange.remove(), this._updatingPendingLoadedGraphicsChange = v(() => {
      this._updatingPendingLoadedGraphicsChange = null;
    });
  }
  setClippingExtent(e31, i23) {
    const t24 = this.symbolCreationContext.clippingExtent, r30 = u6();
    return e29(e31, r30, i23) ? this.symbolCreationContext.clippingExtent = G2(a6(), r30) : this.symbolCreationContext.clippingExtent = null, !S(this.symbolCreationContext.clippingExtent, t24);
  }
  modifyGraphics3DGraphicVisibilities(e31) {
    var _a;
    let i23 = false;
    this.graphics3DGraphics.forEach((t24) => {
      e31(t24) && (i23 = true);
    }), i23 && ((_a = this.owner.view.labeler) == null ? void 0 : _a.setDirty(), this.owner.view.deconflictor.setDirty());
  }
  forEachGraphics3DSymbol(e31) {
    for (const [i23, t24] of this._symbols) {
      if (t(t24))
        return;
      e31(t24, this._graphicsBySymbol.get(i23) || Ne, i23);
    }
  }
  updateAllGraphicsVisibility() {
    r(this._filterVisibility) && this._filterVisibility.reapply(), this.modifyGraphics3DGraphicVisibilities((e31) => {
      const i23 = this._updateUserVisibility(e31), t24 = r(this._scaleVisibility) && this._scaleVisibility.updateVisibility(e31);
      return i23 || t24;
    });
  }
  _hideAllGraphics() {
    this.modifyGraphics3DGraphicVisibilities((e31) => e31.setVisibilityFlag(C7.USER_SETTING, false, E12.GRAPHIC));
  }
  _validateRenderer(e31) {
    var _a;
    const i23 = u16(e31, { geometryType: (_a = this.layer) == null ? void 0 : _a.geometryType });
    if (i23) {
      const e32 = `Renderer for layer '${this.layer.title ? `${this.layer.title}, ` : ""}, id:${this.layer.id}' is not supported in a SceneView`;
      Ve.warn(e32, i23.message);
    }
  }
  _volatileGraphicsUpdated() {
    var _a;
    (_a = this._labeler) == null ? void 0 : _a.reset(), this.stageLayer.shaderTransformationChanged(), this.notifyChange("updating");
  }
  _cleanupSymbols() {
    if (this._graphicsWaitingForSymbol.size > 0 || this._suspendSymbolCleanup)
      return;
    let e31 = false;
    this._symbols.forEach((i23, t24) => {
      if (t(i23) || i23.referenced > 0)
        return;
      const r30 = this._graphicsBySymbol.get(t24);
      r30 && 0 !== r30.size || (this._graphicsBySymbol.delete(t24), this._symbols.delete(t24), s(i23), e31 = true);
    }), e31 && (this._recomputeExtentPadding(), this.notifyChange("averageSymbolComplexity"));
  }
  get test() {
    return { snapshotInternals: () => ({ graphics: [...this.graphics3DGraphics.keys()].sort(), symbols: [...this._symbols.keys()].sort(), graphicsBySymbol: [...this._graphicsBySymbol.keys()].sort().map((e31) => ({ symbolId: e31, graphics: [...this._graphicsBySymbol.get(e31).keys()].sort() })), graphicsWithoutSymbol: [...this._graphicsWithoutSymbol.keys()].sort(), graphicsDrapedUids: [...this._graphicsDrapedUids].sort(), pendingUpdates: this._pendingUpdates }), symbols: this._symbols, filterVisibility: this._filterVisibility, numPending: this._pendingUpdates.size, forceUpdatePolicy: (e31) => {
      this.forcedUpdatePolicy = e31;
    } };
  }
  get performanceInfo() {
    return { visible: this.graphics3DGraphics.size, missing: this._graphicsWithoutSymbol.size, pending: this._pendingUpdates.size };
  }
};
var Te2;
Fe.tmpVec = n2(), e4([y2({ readOnly: true })], Fe.prototype, "computedExtent", void 0), e4([y2()], Fe.prototype, "currentRenderer", void 0), e4([y2()], Fe.prototype, "rendererHasGeometryOperations", void 0), e4([y2()], Fe.prototype, "_frameTask", void 0), e4([y2()], Fe.prototype, "_rendererChangeAbortController", void 0), e4([y2()], Fe.prototype, "_elevationInfoChangeAbortController", void 0), e4([y2()], Fe.prototype, "_initializeAbortController", void 0), e4([y2()], Fe.prototype, "_elevationAlignment", void 0), e4([y2()], Fe.prototype, "_scaleVisibility", void 0), e4([y2()], Fe.prototype, "_filterVisibility", void 0), e4([y2()], Fe.prototype, "_initializePromise", void 0), e4([y2()], Fe.prototype, "_spatialIndex", void 0), e4([y2({ readOnly: true })], Fe.prototype, "extentPadding", void 0), e4([y2()], Fe.prototype, "_updatingPendingLoadedGraphicsChange", void 0), e4([y2()], Fe.prototype, "_featureStore", void 0), e4([y2()], Fe.prototype, "_deconflictor", void 0), e4([y2()], Fe.prototype, "_labeler", void 0), e4([y2()], Fe.prototype, "_objectStates", void 0), e4([y2()], Fe.prototype, "_loadingSymbols", void 0), e4([y2()], Fe.prototype, "preferredUpdatePolicy", void 0), e4([y2()], Fe.prototype, "forcedUpdatePolicy", void 0), e4([y2({ readOnly: true })], Fe.prototype, "effectiveUpdatePolicy", null), e4([y2({ constructOnly: true })], Fe.prototype, "elevationFeatureExpressionEnabled", void 0), e4([y2({ constructOnly: true })], Fe.prototype, "owner", void 0), e4([y2({ constructOnly: true })], Fe.prototype, "layer", void 0), e4([y2({ constructOnly: true })], Fe.prototype, "graphicSymbolSupported", void 0), e4([y2({ constructOnly: true })], Fe.prototype, "getRenderingInfoWithoutRenderer", void 0), e4([y2({ constructOnly: true })], Fe.prototype, "componentFactories", void 0), e4([y2({ constructOnly: true })], Fe.prototype, "setUidToIdOnAdd", void 0), e4([y2()], Fe.prototype, "featureStore", null), e4([y2()], Fe.prototype, "initializePromise", null), e4([y2()], Fe.prototype, "scaleVisibility", null), e4([y2()], Fe.prototype, "elevationAlignment", null), e4([y2()], Fe.prototype, "objectStates", null), e4([y2()], Fe.prototype, "filterVisibility", null), e4([y2({ readOnly: true })], Fe.prototype, "updating", null), e4([y2({ readOnly: true })], Fe.prototype, "running", null), e4([y2({ readOnly: true })], Fe.prototype, "suspendedOrOutsideOfView", null), e4([y2({ readOnly: true, dependsOn: [] })], Fe.prototype, "updatingRemaining", null), e4([y2({ readOnly: true, dependsOn: ["owner.view.qualitySettings.graphics3D.maxTotalNumberOfPrimitives", "owner.view.qualitySettings.graphics3D.maxTotalNumberOfFeatures", "averageSymbolComplexity"] })], Fe.prototype, "displayFeatureLimit", null), e4([y2({ readOnly: true, dependsOn: [] })], Fe.prototype, "averageSymbolComplexity", null), e4([y2({ constructOnly: true })], Fe.prototype, "hasZ", void 0), e4([y2({ constructOnly: true })], Fe.prototype, "hasM", void 0), e4([y2()], Fe.prototype, "_objectIdField", null), Fe = Ue = e4([n5(Le)], Fe), function(e31) {
  e31[e31.NEW = 0] = "NEW", e31[e31.LOADING = 1] = "LOADING", e31[e31.READY = 2] = "READY", e31[e31.REJECTED = 3] = "REJECTED";
}(Te2 || (Te2 = {}));
var ke = class {
  constructor() {
    this.add = null, this.renderingInfo = null, this.state = Te2.NEW, this.remove = null;
  }
  clear() {
    this.add = null, this.renderingInfo = null, this.state = Te2.NEW, this.abortController = null, this.remove = null;
  }
};
var ze = 10;
var We = n2();
var Me = n2();
var Ne = /* @__PURE__ */ new Map();

// node_modules/@arcgis/core/views/3d/layers/graphics/ExtentSet.js
var l29 = 0.05;
var _17 = class {
  constructor() {
    this._extents = new l5({ allocator: (t24) => t24 || u6() }), this._tmpExtent = u6(), this._dirty = false;
  }
  get empty() {
    return 0 === this._extents.length;
  }
  get size() {
    return this._extents.length;
  }
  clear() {
    this._extents.clear();
  }
  add(t24) {
    this._contains(t24) || (this._removeContained(t24), a5(this._extents.pushNew(), t24), this._dirty = true);
  }
  pop() {
    return this._dirty && this._mergeTight(), this._extents.pop();
  }
  merge(t24) {
    return this._mergeTight(t24), t24.hasProgressed;
  }
  _mergeTight(t24 = F4) {
    const e31 = this._extents, o24 = /* @__PURE__ */ new Set();
    let i23 = 0;
    for (; i23 !== e31.length; ) {
      e31.sort((t25, e32) => t25[0] - e32[0]), i23 = e31.length, o24.clear();
      for (let i24 = 0; i24 < e31.length; ++i24) {
        if (t24.done)
          return;
        const h25 = e31.getItemAt(i24);
        if (h25) {
          for (let t25 = i24 + 1; t25 < e31.length; ++t25) {
            const r30 = e31.getItemAt(t25);
            if (null == r30 || r30[0] >= h25[2])
              break;
            o24.add(r30);
          }
          o24.forEach((i25) => {
            if (h25 === i25)
              return;
            if (i25[2] <= h25[0])
              return void o24.delete(i25);
            const _20 = y3(h25), a29 = y3(i25), c31 = this._tmpExtent;
            h4(h25, i25, c31);
            const g21 = _20 + a29;
            (y3(c31) - g21) / g21 < l29 && (a5(h25, c31), o24.delete(i25), e31.remove(i25), t24.madeProgress());
          }), o24.add(h25);
        }
      }
    }
    this._dirty = false;
  }
  _contains(t24) {
    return this._extents.some((e31) => R(e31, t24));
  }
  _removeContained(t24) {
    this._extents.filterInPlace((e31) => !R(t24, e31));
  }
  get test() {
    const t24 = this;
    return { containsPoint: (e31) => t24._extents.some((t25) => b3(t25, e31)) };
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DElevationAlignment.js
var c30 = class extends m {
  constructor(e31) {
    super(e31), this._dirtyExtents = new _17(), this._globalDirty = false, this._averageExtentUpdateSize = 0, this._dirtyGraphicsSet = /* @__PURE__ */ new Set(), this._handles = new t3(), this._updateElevation = false, this.graphicsCoreOwner = null, this.graphicsCore = null, this.events = new n6();
  }
  initialize() {
    const e31 = this.elevationProvider, t24 = this.graphicsCoreOwner.view.resourceController.scheduler;
    this._handles.add([e31.on("elevation-change", (e32) => this._elevationChanged(e32)), l6(() => this.graphicsCoreOwner.suspended, () => this._suspendedChange()), t24.registerTask(I2.ELEVATION_ALIGNMENT, this)]);
  }
  destroy() {
    this._dirtyGraphicsSet.clear(), this._handles.destroy(), this._handles = null, this.graphicsCoreOwner = null, this.graphicsCore = null, this.queryGraphicUIDsInExtent = null, this.elevationProvider = null;
  }
  clear() {
    this._dirtyGraphicsSet.clear(), this.notifyChange("updating");
  }
  _suspendedChange() {
    true === this.graphicsCoreOwner.suspended ? this._updateElevation = false : false === this.graphicsCoreOwner.suspended && this._updateElevation && (this._globalDirty = true, this.notifyChange("updating"));
  }
  elevationInfoChange() {
    this._globalDirty = true, this.notifyChange("updating");
  }
  get updating() {
    return this.running;
  }
  get running() {
    return this._dirtyGraphicsSet.size > 0 || this._dirtyExtents && !this._dirtyExtents.empty || this._globalDirty;
  }
  get updatingRemaining() {
    return this._dirtyGraphicsSet.size + this._dirtyExtents.size * this._averageExtentUpdateSize;
  }
  runTask(e31) {
    for (this._globalDirty && (this._markAllGraphicsElevationDirty(), this._globalDirty = false, e31.madeProgress()), e31.run(() => this._dirtyExtents.merge(e31)); this.running && !e31.done; )
      this._updateDirtyGraphics(e31), this._updateDirtyExtents(e31);
    this.graphicsCoreOwner.view.deconflictor.setDirty(), this.notifyChange("updating");
  }
  _updateDirtyGraphics(e31) {
    const t24 = this.graphicsCoreOwner.view.renderCoordsHelper, i23 = this.graphicsCore.effectiveUpdatePolicy === i6.ASYNC;
    for (const r30 of this._dirtyGraphicsSet.keys()) {
      const a29 = this.graphicsCore.getGraphics3DGraphicById(r30);
      if (this._dirtyGraphicsSet.delete(r30), r(a29) && (a29.alignWithElevation(this.elevationProvider, t24, i23), e31.madeProgress()), e31.done)
        return;
    }
  }
  _updateDirtyExtents(e31) {
    for (; !this._dirtyExtents.empty && !e31.done; ) {
      const t24 = this._dirtyExtents.pop(), i23 = this.elevationProvider.spatialReference;
      this.events.emit("invalidate-elevation", { extent: t24, spatialReference: i23 });
      const r30 = this._dirtyGraphicsSet.size;
      this.queryGraphicUIDsInExtent(t24, i23, (e32) => {
        const t25 = this.graphicsCore.getGraphics3DGraphicById(e32);
        r(t25) && t25.needsElevationUpdates() && this._dirtyGraphicsSet.add(e32);
      }), this._averageExtentUpdateSize = 0.1 * (this._dirtyGraphicsSet.size - r30) + 0.9 * this._averageExtentUpdateSize, e31.madeProgress();
    }
  }
  _markAllGraphicsElevationDirty() {
    this._dirtyExtents.clear(), this._dirtyGraphicsSet.clear(), this.graphicsCore.graphics3DGraphics.forEach((e31, t24) => this._dirtyGraphicsSet.add(t24));
  }
  _elevationChanged(e31) {
    if ("scene" === e31.context && (!this.graphicsCore.layer.elevationInfo || "relative-to-scene" !== this.graphicsCore.layer.elevationInfo.mode))
      return;
    const { extent: t24, spatialReference: i23 } = e31;
    if (this.graphicsCoreOwner.suspended) {
      if (!this._updateElevation) {
        const e32 = this.graphicsCore.computedExtent;
        e32 && t24[2] > e32.xmin && t24[0] < e32.xmax && t24[3] > e32.ymin && t24[1] < e32.ymax && (this._updateElevation = true);
      }
      this.events.emit("invalidate-elevation", { extent: t24, spatialReference: i23 });
    } else
      t24[0] === -1 / 0 ? this._globalDirty = true : this._dirtyExtents.add(t24), this.notifyChange("updating");
  }
};
e4([y2()], c30.prototype, "graphicsCoreOwner", void 0), e4([y2()], c30.prototype, "graphicsCore", void 0), e4([y2()], c30.prototype, "queryGraphicUIDsInExtent", void 0), e4([y2()], c30.prototype, "elevationProvider", void 0), e4([y2({ readOnly: true })], c30.prototype, "updating", null), e4([y2({ readOnly: true })], c30.prototype, "updatingRemaining", null), c30 = e4([n5("esri.views.3d.layers.graphics.Graphics3DElevationAlignment")], c30);
var l30 = c30;

// node_modules/@arcgis/core/views/3d/support/intersectionUtils.js
function h24(r30, n26, t24, i23) {
  return b24(r30, n26, t24, k9(i23, n26, t24, true));
}
var g18 = { dir: n2(), len: 0, clip: n12() };
function k9(r30, n26, i23, s23) {
  const f25 = g18;
  return r30 ? (i23 && s23 && (f25.len = x(n26, i23)), r4(f25.dir, r30)) : s23 ? (f25.len = x(n26, i23), e3(f25.dir, i23, n26), g(f25.dir, f25.dir, 1 / f25.len)) : (e3(f25.dir, i23, n26), z(f25.dir, f25.dir)), f25;
}
function v21(r30, t24, i23) {
  const e31 = P(Y(r30), i23.dir), c31 = -R6(r30, t24);
  if (c31 < 0 && e31 >= 0)
    return false;
  if (e31 > -1e-6 && e31 < 1e-6)
    return c31 > 0;
  if ((c31 < 0 || e31 < 0) && !(c31 < 0 && e31 < 0))
    return true;
  const u33 = c31 / e31;
  return e31 > 0 ? u33 < i23.clip[1] && (i23.clip[1] = u33) : u33 > i23.clip[0] && (i23.clip[0] = u33), i23.clip[0] <= i23.clip[1];
}
function b24(r30, n26, t24, i23) {
  i23.clip[0] = 0, i23.clip[1] = t24 ? i23.len : Number.MAX_VALUE;
  for (let e31 = 0; e31 < r30.length; e31++)
    if (!v21(r30[e31], n26, i23))
      return false;
  return true;
}

// node_modules/@arcgis/core/views/3d/support/FrustumExtentIntersection.js
var M12 = 0.5 * Math.PI;
var F12 = M12 / Math.PI * 180;
var N5 = class {
  constructor(t24) {
    this._renderCoordsHelper = t24.renderCoordsHelper, this._extent = new Array(4), this._planes = new Array(6), this._maxSpan = 0, this._center = { origin: n2(), direction: n2() };
    for (let e31 = 0; e31 < 4; e31++)
      this._extent[e31] = { origin: n2(), direction: n2(), cap: { next: null, direction: n2() } }, this._planes[e31] = p7();
    this._planes[U3.NEAR] = p7(), this._planes[U3.FAR] = p7(), this._planesWithoutFar = this._planes.slice(0, 5);
  }
  update(t24, e31, i23, r30 = true) {
    const a29 = this._extent;
    this._toRenderBoundingExtent(t24, e31, i23), u(this._center.origin, a29[0].origin, a29[2].origin), g(this._center.origin, this._center.origin, 0.5), this._renderCoordsHelper.worldUpAtPosition(this._center.origin, this._center.direction), r30 || g(this._center.direction, this._center.direction, -1);
    for (let n26 = 0; n26 < 4; n26++) {
      const t25 = a29[n26];
      this._renderCoordsHelper.worldUpAtPosition(t25.origin, t25.direction);
      const e32 = a29[3 === n26 ? 0 : n26 + 1];
      t25.cap.next = e32.origin, H(t25.cap.direction, t25.origin, e32.origin), O3(t25.direction, t25.cap.direction, t25.origin, this._planes[n26]), r30 || g(t25.direction, t25.direction, -1);
    }
    O3(a29[0].cap.direction, a29[1].cap.direction, a29[0].origin, this._planes[U3.NEAR]), r30 ? P3(this._planes[U3.NEAR], this._planes[U3.FAR]) : (A4(this._planes[U3.FAR], this._planes[U3.NEAR]), P3(this._planes[U3.NEAR], this._planes[U3.NEAR])), this._maxSpan = Math.max(Math.abs(t24[0] - t24[2]), Math.abs(t24[1] - t24[3])), this._maxSpanSpatialReference = e31, this._minGlobalAltitude = 0.9 * u5(this._maxSpanSpatialReference).radius;
  }
  isVisibleInFrustum(t24, e31, i23 = false) {
    if (null == t24)
      return false;
    if (this._renderCoordsHelper.viewingMode === l14.Global) {
      const i24 = this._maxSpanSpatialReference.isGeographic ? F12 : M12 * e31;
      if (this._maxSpan > i24)
        return true;
      if (null != t24.altitude && t24.altitude >= this._minGlobalAltitude)
        return this._isVisibleInFrustumGlobal(t24);
    }
    if (0 === this._maxSpan) {
      const e32 = this._extent[0];
      return !(i23 || !t24.intersectsRay(p5(e32.origin, e32.direction)));
    }
    for (let n26 = 0; n26 < this._extent.length; n26++) {
      const e32 = this._extent[n26];
      if (!i23 && t24.intersectsRay(p5(e32.origin, e32.direction)))
        return true;
      if (t24.intersectsLineSegment(b10(e32.origin, e32.cap.next, V7), e32.cap.direction))
        return true;
    }
    const r30 = i23 ? this._planes : this._planesWithoutFar;
    for (let n26 = 0; n26 < t24.lines.length; n26++) {
      const e32 = t24.lines[n26];
      if (h24(r30, e32.origin, e32.endpoint, e32.direction))
        return true;
    }
    return false;
  }
  _toRenderBoundingExtentGlobal(t24, r30, n26) {
    const o24 = 5;
    p3(t24, v22), v22[2] = n26, Zn(r30, v22, I11, this._renderCoordsHelper.spatialReference), h5(U9, I11), A2(L7);
    for (const { x0: i23, x1: s23, y0: c31, y1: l32 } of k10)
      for (let p21 = 0; p21 < o24; p21++) {
        const h25 = p21 / (o24 - 1);
        v22[0] = h2(t24[i23], t24[s23], h25), v22[1] = h2(t24[c31], t24[l32], h25), v22[2] = n26, jn(v22, r30, v22, this._renderCoordsHelper.spatialReference), O(v22, v22, U9), c6(L7, v22);
      }
    o2(this._extent[0].origin, L7[0], L7[1], L7[2]), o2(this._extent[1].origin, L7[3], L7[1], L7[2]), o2(this._extent[2].origin, L7[3], L7[4], L7[2]), o2(this._extent[3].origin, L7[0], L7[4], L7[2]);
    for (let e31 = 0; e31 < 4; ++e31)
      O(this._extent[e31].origin, this._extent[e31].origin, I11);
  }
  _toRenderBoundingExtentLocal(t24, e31, i23) {
    vn(t24, e31, P10, this._renderCoordsHelper.spatialReference), o2(this._extent[0].origin, P10[0], P10[1], i23), o2(this._extent[1].origin, P10[2], P10[1], i23), o2(this._extent[2].origin, P10[2], P10[3], i23), o2(this._extent[3].origin, P10[0], P10[3], i23);
  }
  _toRenderBoundingExtent(e31, i23, r30) {
    switch (this._renderCoordsHelper.viewingMode) {
      case l14.Global:
        this._toRenderBoundingExtentGlobal(e31, i23, r30);
        break;
      case l14.Local:
        this._toRenderBoundingExtentLocal(e31, i23, r30);
        break;
      default:
        n8(this._renderCoordsHelper.viewingMode);
    }
  }
  _isVisibleInFrustumGlobal(t24) {
    if (R6(t24.planes[U3.NEAR], this._center.origin) < 0 && P(this._center.direction, t24.direction) < 0)
      return true;
    for (let e31 = 0; e31 < 4; e31++) {
      const i23 = this._extent[e31];
      if (R6(t24.planes[U3.NEAR], i23.origin) < 0 && P(i23.direction, t24.direction) < 0)
        return true;
    }
    return false;
  }
};
var k10 = [{ x0: 0, y0: 1, x1: 2, y1: 1 }, { x0: 0, y0: 3, x1: 2, y1: 3 }, { x0: 0, y0: 1, x1: 0, y1: 3 }, { x0: 2, y0: 1, x1: 2, y1: 3 }];
var v22 = n2();
var I11 = e9();
var U9 = e9();
var L7 = a6();
var P10 = u6();
var V7 = v5();

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DFrustumVisibility.js
var u31 = 1.2;
var d26 = class extends m {
  constructor(e31) {
    super(e31), this.suspended = false, this._extent = null, this._extentIntersectionDirty = true, this._isVisibleBelowSurfaceInternal = false, this._handles = new t3(), this.graphicsCoreOwner = null, this.updating = true;
  }
  initialize() {
    const { graphicsCoreOwner: e31 } = this;
    this._extentIntersection = new N5({ renderCoordsHelper: e31.view.renderCoordsHelper });
    const t24 = e31.view, s23 = t24.basemapTerrain, i23 = t24.resourceController.scheduler;
    this._handles.add([t24.on("resize", () => this._viewChange()), l6(() => t24.state.camera, () => this._viewChange(), U), i23.registerTask(I2.FRUSTUM_VISIBILITY, this), l6(() => s23.visibleElevationBounds, () => this._elevationBoundsChange())]), "local" === t24.viewingMode ? this._isVisibleBelowSurface = true : this._handles.add([l6(() => {
      var _a, _b, _c;
      return [s23.baseOpacity, s23.wireframe, (_c = (_b = (_a = t24.map) == null ? void 0 : _a.ground) == null ? void 0 : _b.navigationConstraint) == null ? void 0 : _c.type];
    }, () => this._updateIsVisibleBelowSurface(), h3)]);
  }
  destroy() {
    this._set("graphicsCoreOwner", null), this._extent = null, this._extentIntersection = null, this._handles = s(this._handles);
  }
  _setDirty() {
    this.updating || this._set("updating", true);
  }
  setExtent(e31) {
    this._extent = e31, this._extentIntersectionDirty = true, this._setDirty();
  }
  _viewChange() {
    this._setDirty();
  }
  _elevationBoundsChange() {
    this._setDirty(), this._extentIntersectionDirty = true;
  }
  set _isVisibleBelowSurface(e31) {
    this._isVisibleBelowSurfaceInternal = e31, this._setDirty(), this._extentIntersectionDirty = true;
  }
  _updateIsVisibleBelowSurface() {
    const e31 = this.graphicsCoreOwner.view, t24 = e31.basemapTerrain, s23 = "local" === e31.viewingMode, i23 = e31.map.ground && e31.map.ground.navigationConstraint && "none" === e31.map.ground.navigationConstraint.type;
    this._isVisibleBelowSurface = s23 || !t24.opaque || i23;
  }
  _updateExtentIntersection() {
    if (!this._extentIntersectionDirty)
      return;
    this._extentIntersectionDirty = false;
    const e31 = this.graphicsCoreOwner.view;
    let t24;
    if (this._isVisibleBelowSurfaceInternal)
      t24 = -0.3 * u5(e31.spatialReference).radius;
    else {
      const { min: s23, max: i23 } = e31.basemapTerrain.visibleElevationBounds;
      t24 = s23 - Math.max(1, (i23 - s23) * (u31 - 1));
    }
    this._extentIntersection.update(this._extent, e31.spatialReference, t24);
  }
  get running() {
    return this.updating;
  }
  runTask() {
    if (this._set("updating", false), !this._extent)
      return void this._set("suspended", false);
    this._updateExtentIntersection();
    const e31 = this.graphicsCoreOwner.view.frustum, t24 = u5(this.graphicsCoreOwner.view.spatialReference).radius;
    this._set("suspended", !this._extentIntersection.isVisibleInFrustum(e31, t24));
  }
};
e4([y2({ readOnly: true })], d26.prototype, "suspended", void 0), e4([y2({ constructOnly: true })], d26.prototype, "graphicsCoreOwner", void 0), e4([y2({ readOnly: true })], d26.prototype, "updating", void 0), d26 = e4([n5("esri.views.3d.layers.graphics.Graphics3DFrustumVisibility")], d26);
var _18 = d26;

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Object3DStateSet.js
var t23;
!function(e31) {
  e31[e31.Object = 0] = "Object", e31[e31.RenderGeometry = 1] = "RenderGeometry", e31[e31.External = 2] = "External", e31[e31.COUNT = 3] = "COUNT";
}(t23 || (t23 = {}));
var r29 = class {
  constructor() {
    this._items = [];
  }
  addObject(e31, r30) {
    this._items.push({ type: t23.Object, objectStateId: r30, object: e31 });
  }
  addRenderGeometry(e31, r30, o24) {
    this._items.push({ type: t23.RenderGeometry, objectStateId: r30, renderGeometry: e31, owner: o24 });
  }
  addExternal(e31, r30) {
    this._items.push({ type: t23.External, objectStateId: r30, remove: e31 });
  }
  remove(e31) {
    for (let t24 = this._items.length - 1; t24 >= 0; --t24) {
      const r30 = this._items[t24];
      r30.objectStateId === e31 && (this._removeObjectStateItem(r30), this._items.splice(t24, 1));
    }
  }
  removeObject(e31) {
    for (let r30 = this._items.length - 1; r30 >= 0; --r30) {
      const o24 = this._items[r30];
      o24.type === t23.Object && o24.object === e31 && (this._removeObjectStateItem(o24), this._items.splice(r30, 1));
    }
  }
  removeRenderGeometry(e31) {
    for (let r30 = this._items.length - 1; r30 >= 0; --r30) {
      const o24 = this._items[r30];
      o24.type === t23.RenderGeometry && o24.renderGeometry === e31 && (this._removeObjectStateItem(o24), this._items.splice(r30, 1));
    }
  }
  removeAll() {
    this._items.forEach((e31) => {
      this._removeObjectStateItem(e31);
    }), this._items = [];
  }
  _removeObjectStateItem(r30) {
    switch (r30.type) {
      case t23.Object:
        r30.objectStateId.channel === u13.Highlight ? r30.object.removeHighlight(r30.objectStateId) : r30.objectStateId.channel === u13.MaskOccludee && r30.object.removeOcclude(r30.objectStateId);
        break;
      case t23.RenderGeometry:
        r30.owner.removeRenderGeometryObjectState(r30.renderGeometry, r30.objectStateId);
        break;
      case t23.External:
        r30.remove(r30.objectStateId);
    }
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DObjectStateSet.js
var e30 = class {
  constructor(e31, i23) {
    this.stateType = e31, this.objectIdField = i23, this.objectStateSet = new r29(), this.ids = /* @__PURE__ */ new Set(), this.paused = false;
  }
  hasGraphic(t24) {
    if (this.objectIdField) {
      const e31 = t24.graphic.attributes[this.objectIdField];
      return this.ids.has(e31);
    }
    return this.ids.has(t24.graphic.uid);
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DObjectStates.js
var s21 = class {
  constructor(t24) {
    this._graphicsCore = t24, this._stateSets = new Array();
  }
  destroy() {
    this._stateSets && this._stateSets.forEach((t24) => t24.objectStateSet.removeAll()), this._stateSets = null;
  }
  acquireSet(s23, a29) {
    const i23 = new e30(s23, a29);
    this._stateSets.push(i23);
    const h25 = n4(() => this.releaseSet(i23));
    return { set: i23, handle: h25 };
  }
  releaseSet(t24) {
    t24.objectStateSet.removeAll();
    const e31 = this._stateSets ? this._stateSets.indexOf(t24) : -1;
    -1 !== e31 && this._stateSets.splice(e31, 1);
  }
  _addObjectStateSet(t24, e31) {
    t24.addObjectStateSet(e31.stateType, e31.objectStateSet);
  }
  _removeObjectStateSet(t24, e31) {
    t24.removeObjectState(e31.objectStateSet);
  }
  setUid(t24, e31) {
    t24.ids.add(e31);
    const s23 = this._graphicsCore.graphics3DGraphics.get(e31);
    s23 && this._addObjectStateSet(s23, t24);
  }
  setUids(t24, e31) {
    e31.forEach((e32) => this.setUid(t24, e32));
  }
  setObjectIds(t24, e31) {
    e31.forEach((e32) => t24.ids.add(e32)), this._initializeSet(t24);
  }
  addGraphic(t24) {
    this._stateSets.forEach((e31) => {
      !e31.paused && e31.hasGraphic(t24) && this._addObjectStateSet(t24, e31);
    });
  }
  removeGraphic(t24) {
    this._stateSets.forEach((e31) => {
      e31.hasGraphic(t24) && this._removeObjectStateSet(t24, e31);
    });
  }
  allGraphicsDeleted() {
    this._stateSets && this._stateSets.forEach((t24) => t24.objectStateSet.removeAll());
  }
  _initializeSet(t24) {
    const e31 = this._graphicsCore.graphics3DGraphics;
    t24.objectIdField ? e31.forEach((e32) => {
      e32 && t24.hasGraphic(e32) && this._addObjectStateSet(e32, t24);
    }) : t24.ids.forEach((s23) => {
      const a29 = e31.get(s23);
      a29 && this._addObjectStateSet(a29, t24);
    });
  }
  get test() {
    return { states: this._stateSets };
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DScaleVisibility.js
var y15 = s3.getLogger("esri.views.3d.layers.graphics.Graphics3DScaleVisibility");
var g19 = class extends d6 {
  constructor(e31) {
    super(e31), this._scaleRangeActive = false, this._layerScaleRangeVisibilityQuery = false, this._extent = null, this.graphicsCoreOwner = null, this.layer = null, this.queryGraphicUIDsInExtent = null, this.graphicsCore = null, this.basemapTerrain = null, this.layerScaleEnabled = true, this.suspended = false, this._dirty = true;
  }
  initialize() {
    this.updateScaleRangeActive();
    const e31 = this.graphicsCoreOwner.view.resourceController.scheduler;
    this.handles.add(e31.registerTask(I2.SCALE_VISIBILITY, this)), this.updatingHandles.add(() => this.layer.effectiveScaleRange, () => this.layerMinMaxScaleChangeHandler());
  }
  destroy() {
    this.updatingHandles.removeAll(), this.handles.removeAll(), this._dirty = false, this._extent = null, this.graphicsCoreOwner = null, this.layer = null, this.queryGraphicUIDsInExtent = null, this.graphicsCore = null, this.basemapTerrain = null;
  }
  get updating() {
    return this._dirty || this.updatingHandles.updating;
  }
  _setDirty() {
    this._dirty = true;
  }
  setExtent(e31) {
    const i23 = this.graphicsCoreOwner.view.spatialReference, t24 = this.graphicsCoreOwner.view.basemapTerrain.spatialReference;
    if (i23 === t24)
      this._extent = e31;
    else {
      const r30 = u6();
      vn(e31, i23, r30, t24) ? this._extent = r30 : this._extent = null;
    }
    this._setDirty();
  }
  scaleRangeActive() {
    return this._scaleRangeActive;
  }
  updateScaleRangeActive() {
    const e31 = this.layer, i23 = e31.effectiveScaleRange;
    let t24 = this.layerScaleEnabled && u32(i23.minScale, i23.maxScale);
    e31.labelingInfo && !t24 && (t24 = e31.labelingInfo.some((e32) => e32 && u32(e32.minScale, e32.maxScale)));
    const r30 = this._scaleRangeActive !== t24;
    return this._scaleRangeActive = t24, t24 && !this.handles.has(b25) && this.basemapTerrain ? (this.handles.add(this.basemapTerrain.on("scale-change", (e32) => this._scaleUpdateHandler(e32)), b25), this.layerScaleEnabled && this.handles.add(this.basemapTerrain.on("tiles-visibility-changed", () => this._setDirty()), b25)) : !t24 && this.handles.has(b25) && this.handles.remove(b25), r30;
  }
  get running() {
    return !(!this.graphicsCoreOwner.view.basemapTerrain || !this.updating);
  }
  runTask() {
    const e31 = this.graphicsCoreOwner.view.basemapTerrain;
    if (this._extent && e31 && e31.ready && this._scaleRangeActive && this.layerScaleEnabled) {
      if (!this._layerScaleRangeVisibilityQuery) {
        this._layerScaleRangeVisibilityQuery = true;
        const i23 = this.layer.effectiveScaleRange;
        e31.queryVisibleScaleRange(this._extent, i23.minScale, i23.maxScale, (e32) => this._finishUpdate(e32));
      }
    } else
      this._finishUpdate(true);
  }
  _finishUpdate(e31) {
    this._layerScaleRangeVisibilityQuery = false, this._set("suspended", !e31), this._dirty = false;
  }
  _visibleAtLayerScale(e31) {
    const i23 = this.layer.effectiveScaleRange;
    return !this.layerScaleEnabled || c16(e31, i23.minScale || 0, i23.maxScale || 0);
  }
  _visibleAtLabelScale(e31, i23) {
    return c16(e31, i23.minScale || 0, i23.maxScale || 0);
  }
  _graphicScale(e31) {
    let i23;
    if (r(e31.centroid) ? i23 = e31.centroid : r(e31.graphic.geometry) && "point" === e31.graphic.geometry.type && (i23 = e31.graphic.geometry), i23) {
      return this.graphicsCoreOwner.view.basemapTerrain ? this.graphicsCoreOwner.view.basemapTerrain.getScale(i23) : 1;
    }
    return null;
  }
  _graphicVisible(e31) {
    if (!this.layerScaleEnabled)
      return true;
    const i23 = this._graphicScale(e31);
    return this._visibleAtLayerScale(i23);
  }
  updateVisibility(e31) {
    if (this._scaleRangeActive) {
      const i23 = this._graphicVisible(e31);
      return e31.setVisibilityFlag(C7.SCALE_RANGE, i23, E12.GRAPHIC);
    }
    return false;
  }
  updateGraphicLabelScaleVisibility(e31) {
    if (!this._scaleRangeActive)
      return false;
    if (!e31.labelGraphics || 0 === e31.labelGraphics.length)
      return false;
    const i23 = this._graphicScale(e31), t24 = this._updateLabelScaleVisibility(e31, i23);
    return t24 && (this.graphicsCoreOwner.view.deconflictor.setDirty(), this.graphicsCoreOwner.view.labeler.setDirty()), t24;
  }
  _updateLabelScaleVisibility(e31, i23) {
    if (!e31.labelGraphics || 0 === e31.labelGraphics.length)
      return false;
    const t24 = e31.labelGraphics[0]._labelClass;
    if (t24 && null != t24.minScale && null != t24.maxScale) {
      const r30 = this._visibleAtLabelScale(i23, t24);
      if (e31.setVisibilityFlag(C7.SCALE_RANGE, r30, E12.LABEL))
        return true;
    }
    return false;
  }
  _scaleUpdateHandler(e31) {
    if (this._setDirty(), this.graphicsCoreOwner.suspended)
      return;
    const i23 = e31.extent, t24 = e31.scale, s23 = this._visibleAtLayerScale(t24);
    let l32 = false;
    const c31 = this.graphicsCoreOwner.view.spatialReference, p21 = e31.spatialReference;
    if (t(p21))
      return void y15.error("scaleUpdate: Internal error, no SpatialReference given for tiles");
    const d27 = !p21.equals(c31);
    if (d27) {
      if (!vn(i23, p21, m18, c31))
        return void y15.error("scaleUpdate: Internal error, cannot project AABR from " + p21 + " to wkid " + c31);
    }
    const g21 = d27 ? m18 : i23;
    this.queryGraphicUIDsInExtent(g21, c31, (e32) => {
      const n26 = this.graphicsCore.getGraphics3DGraphicById(e32);
      if (t(n26))
        return;
      const c32 = n26.centroid;
      r(c32) && (i23[0] > c32.x || i23[1] > c32.y || i23[2] < c32.x || i23[3] < c32.y) || (n26.setVisibilityFlag(C7.SCALE_RANGE, s23, E12.GRAPHIC) && (l32 = true), this._updateLabelScaleVisibility(n26, t24) && (l32 = true));
    }), l32 && (this.graphicsCoreOwner.view.deconflictor.setDirty(), this.graphicsCoreOwner.view.labeler.setDirty());
  }
  layerMinMaxScaleChangeHandler() {
    this.updateScaleRangeActive() && !this._scaleRangeActive ? this.graphicsCore.modifyGraphics3DGraphicVisibilities((e31) => e31.clearVisibilityFlag(C7.SCALE_RANGE)) : this._scaleRangeActive && this.graphicsCore.updateAllGraphicsVisibility(), this._setDirty();
  }
};
function u32(e31, i23) {
  return e31 > 0 || i23 > 0;
}
e4([y2()], g19.prototype, "graphicsCoreOwner", void 0), e4([y2()], g19.prototype, "layer", void 0), e4([y2()], g19.prototype, "queryGraphicUIDsInExtent", void 0), e4([y2()], g19.prototype, "graphicsCore", void 0), e4([y2()], g19.prototype, "basemapTerrain", void 0), e4([y2({ constructOnly: true })], g19.prototype, "layerScaleEnabled", void 0), e4([y2({ readOnly: true })], g19.prototype, "suspended", void 0), e4([y2({ readOnly: true })], g19.prototype, "updating", null), e4([y2()], g19.prototype, "_dirty", void 0), g19 = e4([n5("esri.views.3d.layers.graphics.Graphics3DScaleVisibility")], g19);
var b25 = "terrain-events";
var m18 = u6();
var S17 = g19;

// node_modules/@arcgis/core/views/3d/layers/graphics/GraphicsProcessor.js
var A11 = class extends d6 {
  constructor(t24) {
    super(t24), this.type = "graphics-3d", this.graphicsCore = null, this.drapeSourceType = e17.Features, this.scaleVisibilityEnabled = false, this.frustumVisibilityEnabled = false, this._suspendResumeExtent = null;
  }
  initialize() {
    const { layer: t24 } = this, e31 = "effectiveScaleRange" in t24 ? t24 : null, i23 = this.scaleVisibilityEnabled && r(e31), s23 = new Fe({ owner: this, layer: this.owner.layer, preferredUpdatePolicy: i6.SYNC, graphicSymbolSupported: true, componentFactories: { elevationAlignment: (t25, e32) => new l30({ graphicsCoreOwner: this, graphicsCore: t25, queryGraphicUIDsInExtent: e32, elevationProvider: this.view.elevationProvider }), scaleVisibility: i23 ? (t25, i24) => new S17({ graphicsCoreOwner: this, layer: e31, queryGraphicUIDsInExtent: i24, graphicsCore: t25, basemapTerrain: this.owner.view.basemapTerrain }) : null, objectStates: (t25) => new s21(t25) } });
    if (this._set("graphicsCore", s23), this.frustumVisibilityEnabled && this._set("frustumVisibility", new _18({ graphicsCoreOwner: this })), "fullOpacity" in this.owner) {
      const t25 = this.owner;
      this.updatingHandles.add(() => t25.fullOpacity, () => this.graphicsCore.opacityChange());
    }
    if ("elevationInfo" in t24) {
      const e32 = t24;
      this.updatingHandles.add(() => e32.elevationInfo, (t25, e33) => {
        m6(t25, e33) && this.updatingHandles.addPromise(this.graphicsCore.elevationInfoChange());
      });
    }
    this._set("initializePromise", this._initializeAsync()), this.updatingHandles.addPromise(this.initializePromise);
  }
  async _initializeAsync() {
    try {
      await this.graphicsCore.initializePromise;
    } catch (t24) {
      if (j2(t24))
        return;
      throw t24;
    }
    this.destroyed || (this.handles.add(l6(() => this.view.clippingArea, () => this._updateClippingExtent(), U)), this._updateClippingExtent(), this._setupSuspendResumeExtent(), this.graphicsCore.startCreateGraphics());
  }
  destroy() {
    this.handles.removeAll(), this.updatingHandles.removeAll(), this._set("frustumVisibility", s(this.frustumVisibility)), this._set("graphicsCore", s(this.graphicsCore));
  }
  get layer() {
    return this.owner.layer;
  }
  get view() {
    return this.owner.view;
  }
  get scaleVisibility() {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.scaleVisibility;
  }
  get elevationAlignment() {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.elevationAlignment;
  }
  get objectStates() {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.objectStates;
  }
  get scaleVisibilitySuspended() {
    return !(!r(this.scaleVisibility) || !this.scaleVisibility.suspended);
  }
  get frustumVisibilitySuspended() {
    return r(this.frustumVisibility) && this.frustumVisibility.suspended;
  }
  get suspended() {
    var _a;
    return (_a = this.owner.suspended) != null ? _a : false;
  }
  get updating() {
    var _a;
    return !!(((_a = this.graphicsCore) == null ? void 0 : _a.updating) || r(this.scaleVisibility) && this.scaleVisibility.updating || r(this.frustumVisibility) && this.frustumVisibility.updating || this.updatingHandles.updating);
  }
  get graphics3DGraphics() {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.graphics3DGraphics;
  }
  get graphics3DGraphicsByObjectID() {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.graphics3DGraphicsByObjectID;
  }
  get loadedGraphics() {
    return this.owner.loadedGraphics;
  }
  get fullOpacity() {
    var _a;
    return (_a = this.owner.fullOpacity) != null ? _a : 1;
  }
  get slicePlaneEnabled() {
    return this.owner.slicePlaneEnabled;
  }
  get updatePolicy() {
    return this.owner.updatePolicy;
  }
  notifyGraphicGeometryChanged(t24) {
    this.graphicsCore.notifyGraphicGeometryChanged(t24);
  }
  notifyGraphicVisibilityChanged(t24) {
    this.graphicsCore.notifyGraphicVisibilityChanged(t24);
  }
  getRenderingInfo(t24, e31, i23) {
    const s23 = a20(t24, { renderer: e31, arcade: i23 });
    if (r(s23) && s23.color) {
      const t25 = s23.color;
      t25[0] = t25[0] / 255, t25[1] = t25[1] / 255, t25[2] = t25[2] / 255;
    }
    return s23;
  }
  getRenderingInfoAsync(t24, e31, i23, s23) {
    return s14(t24, { renderer: e31, arcade: i23, ...s23 });
  }
  getHit(t24) {
    if (this.owner.loadedGraphics) {
      const e31 = this.owner.loadedGraphics.find((e32) => e32.uid === t24);
      if (e31) {
        const t25 = this.layer instanceof b5 ? this.layer : null, i23 = f11(e31, t25);
        return { type: "graphic", graphic: i23, layer: i23.layer };
      }
    }
    return null;
  }
  whenGraphicBounds(t24, e31) {
    return this.graphicsCore ? this.graphicsCore.whenGraphicBounds(t24, e31) : Promise.reject();
  }
  computeAttachmentOrigin(t24, e31) {
    return this.graphicsCore ? this.graphicsCore.computeAttachmentOrigin(t24, e31) : null;
  }
  getSymbolLayerSize(t24, e31) {
    return this.graphicsCore ? this.graphicsCore.getSymbolLayerSize(t24, e31) : null;
  }
  maskOccludee(t24) {
    const { set: e31, handle: i23 } = this.objectStates.acquireSet(u13.MaskOccludee, null);
    return this.objectStates.setUid(e31, t24.uid), i23;
  }
  highlight(t24) {
    if (t24 instanceof x3)
      return _19;
    if ("number" == typeof t24)
      return this.highlight([t24]);
    if (t24 instanceof g4)
      return this.highlight([t24]);
    if (t24 instanceof j4 && (t24 = t24.toArray()), Array.isArray(t24) && t24.length > 0) {
      if (t24[0] instanceof g4) {
        const e31 = t24.map((t25) => t25.uid), { set: i23, handle: s23 } = this.objectStates.acquireSet(u13.Highlight, null);
        return this.objectStates.setUids(i23, e31), s23;
      }
      if ("number" == typeof t24[0]) {
        const e31 = t24, { set: i23, handle: s23 } = this.objectStates.acquireSet(u13.Highlight, null);
        return this.objectStates.setObjectIds(i23, e31), s23;
      }
    }
    return _19;
  }
  _setupSuspendResumeExtent() {
    const { scaleVisibility: t24, frustumVisibility: e31 } = this;
    if (t(t24) && t(e31))
      return;
    const i23 = ({ computedExtent: i24, extentPadding: s23 }) => {
      this._suspendResumeExtent = z2(i24, this._suspendResumeExtent, s15, s23), r(t24) && t24.setExtent(this._suspendResumeExtent), r(e31) && e31.setExtent(this._suspendResumeExtent);
    };
    this.handles.add(l6(() => {
      var _a, _b;
      return { computedExtent: (_a = this.graphicsCore) == null ? void 0 : _a.computedExtent, extentPadding: (_b = this.graphicsCore) == null ? void 0 : _b.extentPadding };
    }, (t25) => i23(t25), w5));
  }
  _updateClippingExtent() {
    const t24 = this.view.clippingArea;
    this.graphicsCore.setClippingExtent(t24, this.view.spatialReference) && this.graphicsCore.recreateAllGraphics();
  }
};
e4([y2()], A11.prototype, "type", void 0), e4([y2({ constructOnly: true })], A11.prototype, "owner", void 0), e4([y2()], A11.prototype, "layer", null), e4([y2()], A11.prototype, "view", null), e4([y2({ constructOnly: true })], A11.prototype, "graphicsCore", void 0), e4([y2()], A11.prototype, "scaleVisibility", null), e4([y2({ constructOnly: true })], A11.prototype, "frustumVisibility", void 0), e4([y2()], A11.prototype, "elevationAlignment", null), e4([y2()], A11.prototype, "objectStates", null), e4([y2()], A11.prototype, "scaleVisibilitySuspended", null), e4([y2({ readOnly: true })], A11.prototype, "frustumVisibilitySuspended", null), e4([y2()], A11.prototype, "suspended", null), e4([y2({ readOnly: true })], A11.prototype, "updating", null), e4([y2()], A11.prototype, "loadedGraphics", null), e4([y2()], A11.prototype, "fullOpacity", null), e4([y2()], A11.prototype, "slicePlaneEnabled", null), e4([y2()], A11.prototype, "drapeSourceType", void 0), e4([y2()], A11.prototype, "updatePolicy", null), e4([y2({ constructOnly: true })], A11.prototype, "scaleVisibilityEnabled", void 0), e4([y2({ constructOnly: true })], A11.prototype, "frustumVisibilityEnabled", void 0), e4([y2()], A11.prototype, "initializePromise", void 0), A11 = e4([n5("esri.views.3d.layers.graphics.GraphicsProcessor")], A11);
var _19 = n4();

// node_modules/@arcgis/core/views/3d/layers/graphics/queryForSymbologySnapping.js
async function a28(a29, o24, i23) {
  var _a;
  if (t(a29) || 0 === o24.candidates.length)
    return s22;
  const c31 = (_a = a29.graphics3DGraphicsByObjectID) != null ? _a : a29.graphics3DGraphics, p21 = [], d27 = [], { renderer: u33 } = a29, g21 = r(u33) && "arcadeRequired" in u33 && u33.arcadeRequired ? i10() : null, l32 = async (n26, { graphic: r30, graphics3DSymbol: t24 }) => {
    const s23 = await g21, o25 = await a29.getRenderingInfoAsync(r30, u33, s23, { signal: i23 });
    return t(o25) ? [] : t24.queryForSnapping(n26, f25, o25, i23);
  }, { candidates: h25, spatialReference: f25 } = o24;
  for (let n26 = 0; n26 < h25.length; ++n26) {
    const r30 = h25[n26], { objectId: t24 } = r30, a30 = "number" == typeof t24 ? c31.get(t24) : void 0;
    if (t(a30))
      continue;
    const { graphics3DSymbol: s23 } = a30;
    s23.symbologySnappingSupported && (p21.push(l32(r30, a30)), d27.push(n26));
  }
  if (0 === p21.length)
    return s22;
  const m19 = await Promise.all(p21);
  f2(i23);
  const y17 = [], b26 = [];
  for (let e31 = 0; e31 < m19.length; ++e31) {
    const n26 = m19[e31], r30 = d27[e31];
    for (const e32 of n26)
      y17.push(e32), b26.push(r30);
  }
  return { candidates: y17, sourceCandidateIndices: b26 };
}
var s22 = { candidates: [], sourceCandidateIndices: [] };

// node_modules/@arcgis/core/views/3d/layers/support/projectExtentUtils.js
function l31(l32) {
  const s23 = l32.view.spatialReference, i23 = l32.layer.fullExtent, n26 = r(i23) && i23.spatialReference;
  if (t(i23) || !n26)
    return Promise.resolve(null);
  if (n26.equals(s23))
    return Promise.resolve(i23.clone());
  const a29 = M(i23, s23);
  return r(a29) ? Promise.resolve(a29) : l32.view.state.isLocal ? a15(i23, s23, l32.layer.portalItem).then((e31) => !l32.destroyed && e31 ? e31 : void 0).catch(() => null) : Promise.resolve(null);
}

// node_modules/@arcgis/core/views/3d/layers/GraphicsLayerView3D.js
var g20 = class extends n14(u15) {
  constructor() {
    super(...arguments), this.type = "graphics-3d", this.symbologySnappingSupported = true, this.slicePlaneEnabled = false, this.fullExtentInLocalViewSpatialReference = null;
  }
  initialize() {
    this._set("processor", new A11({ owner: this, scaleVisibilityEnabled: true, frustumVisibilityEnabled: true })), this.addResolvingPromise(this.processor.initializePromise), this.handles.add(this.layer.on("graphic-update", (e31) => this.processor.graphicsCore.graphicUpdateHandler(e31))), this.addResolvingPromise(l31(this).then((e31) => this.fullExtentInLocalViewSpatialReference = e31)), this.layer.internal ? this.notifyChange("updating") : this.handles.add(f3(() => {
      var _a, _b;
      return (_b = (_a = this.view) == null ? void 0 : _a.basemapTerrain) == null ? void 0 : _b.ready;
    }, () => () => this.notifyChange("updating"), { once: true }));
  }
  destroy() {
    this.handles.removeAll(), this.updatingHandles.removeAll(), this._set("processor", s(this.processor));
  }
  get loadedGraphics() {
    return this.layer.graphics;
  }
  get legendEnabled() {
    var _a;
    return this.canResume() && !((_a = this.processor) == null ? void 0 : _a.frustumVisibilitySuspended);
  }
  getSuspendInfo() {
    var _a, _b, _c, _d;
    const e31 = super.getSuspendInfo();
    return e31.outsideScaleRange = (_b = (_a = this.processor) == null ? void 0 : _a.scaleVisibilitySuspended) != null ? _b : false, e31.outsideOfView = (_d = (_c = this.processor) == null ? void 0 : _c.frustumVisibilitySuspended) != null ? _d : false, e31;
  }
  async fetchPopupFeatures(e31, r30) {
    return r(r30) ? r30.clientGraphics : null;
  }
  getHit(e31) {
    return this.processor.getHit(e31);
  }
  whenGraphicBounds(e31, r30) {
    return this.processor.whenGraphicBounds(e31, r30);
  }
  computeAttachmentOrigin(e31, r30) {
    var _a;
    return (_a = this.processor) == null ? void 0 : _a.computeAttachmentOrigin(e31, r30);
  }
  getSymbolLayerSize(e31, r30) {
    return this.processor.getSymbolLayerSize(e31, r30);
  }
  queryGraphics() {
    return Promise.resolve(this.loadedGraphics);
  }
  maskOccludee(e31) {
    return this.processor.maskOccludee(e31);
  }
  highlight(e31) {
    return this.processor.highlight(e31);
  }
  async elevationAlignPointsInFeatures(e31, s23) {
    const { processor: i23 } = this;
    if (t(i23))
      throw new s4("graphicslayerview3d:missing-processor", "A Graphics3D processor is needed to resolve graphics elevation.");
    return m12(this.view, this.layer, (e32) => "number" == typeof e32 ? i23.graphics3DGraphics.get(e32) : null, e31, s23);
  }
  async queryForSymbologySnapping(e31, r30) {
    return a28(this.processor, e31, r30);
  }
  get updatePolicy() {
    var _a;
    return ((_a = this.processor) == null ? void 0 : _a.graphicsCore.effectiveUpdatePolicy) || i6.SYNC;
  }
  canResume() {
    var _a;
    return super.canResume() && !((_a = this.processor) == null ? void 0 : _a.scaleVisibilitySuspended);
  }
  isUpdating() {
    var _a, _b, _c;
    return !(!((_a = this.processor) == null ? void 0 : _a.updating) && (this.layer.internal || ((_c = (_b = this.view) == null ? void 0 : _b.basemapTerrain) == null ? void 0 : _c.ready)));
  }
  get performanceInfo() {
    var _a, _b, _c;
    return { displayedNumberOfFeatures: this.loadedGraphics.length, maximumNumberOfFeatures: -1, totalNumberOfFeatures: -1, nodes: 0, core: null, updating: this.updating, elevationUpdating: (_b = (_a = this.processor) == null ? void 0 : _a.elevationAlignment.updating) != null ? _b : false, visibilityFrustum: !((_c = this.processor) == null ? void 0 : _c.frustumVisibilitySuspended) };
  }
  getUsedMemory() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this.processor) == null ? void 0 : _a.graphicsCore) == null ? void 0 : _b.usedMemory) != null ? _c : 0;
  }
  getUnloadedMemory() {
    var _a, _b;
    return (_b = (_a = this.processor) == null ? void 0 : _a.graphicsCore) == null ? void 0 : _b.unprocessedMemoryEstimate;
  }
  ignoresMemoryFactor() {
    return true;
  }
};
e4([y2()], g20.prototype, "loadedGraphics", null), e4([y2({ readOnly: true })], g20.prototype, "legendEnabled", null), e4([y2()], g20.prototype, "layer", void 0), e4([y2({ readOnly: true })], g20.prototype, "processor", void 0), e4([y2({ type: Boolean })], g20.prototype, "slicePlaneEnabled", void 0), g20 = e4([n5("esri.views.3d.layers.GraphicsLayerView3D")], g20);
var y16 = g20;
export {
  y16 as default
};
//# sourceMappingURL=GraphicsLayerView3D-6GNN4PQ4.js.map
