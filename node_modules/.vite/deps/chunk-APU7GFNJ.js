import {
  l
} from "./chunk-E4KPV765.js";
import {
  b
} from "./chunk-SOEQPPQP.js";
import {
  n as n2
} from "./chunk-B4DKBAM3.js";
import {
  j
} from "./chunk-UDND2Z3V.js";
import {
  e,
  n2 as n,
  y
} from "./chunk-OOLCFNXJ.js";
import {
  C
} from "./chunk-MJXQTGI2.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";

// node_modules/@arcgis/core/support/collectionUtils.js
function t(t2) {
  return new l({ getCollections: () => [t2.tables, t2.layers], getChildrenFunction: (e2) => {
    const t3 = [];
    return "tables" in e2 && t3.push(e2.tables), "layers" in e2 && t3.push(e2.layers), t3;
  }, itemFilterFunction: (e2) => {
    const t3 = e2.parent;
    return t3 && "tables" in t3 && t3.tables.includes(e2);
  } });
}

// node_modules/@arcgis/core/support/LayersMixin.js
function n3(e2, r, t2) {
  let s2, o;
  if (e2)
    for (let a2 = 0, i = e2.length; a2 < i; a2++) {
      if (s2 = e2.getItemAt(a2), s2[r] === t2)
        return s2;
      if ("group" === (s2 == null ? void 0 : s2.type) && (o = n3(s2.layers, r, t2), o))
        return o;
    }
}
var d = (d2) => {
  let y2 = class extends d2 {
    constructor(...e2) {
      super(...e2), this.layers = new j();
      const t2 = (e3) => {
        e3.parent && "remove" in e3.parent && e3.parent.remove(e3);
      }, o = (e3) => {
        e3.parent = this, this.layerAdded(e3), "elevation" !== e3.type && "base-elevation" !== e3.type || s.getLogger(this.declaredClass).error(`Layer 'title:${e3.title}, id:${e3.id}' of type '${e3.type}' is not supported as an operational layer and will therefore be ignored.`);
      }, a2 = (e3) => {
        e3.parent = null, this.layerRemoved(e3);
      };
      this.layers.on("before-add", (e3) => t2(e3.item)), this.layers.on("after-add", (e3) => o(e3.item)), this.layers.on("after-remove", (e3) => a2(e3.item));
    }
    destroy() {
      const e2 = this.layers.removeAll();
      for (const r of e2)
        this.layerRemoved(r), r.destroy();
      this.layers.destroy();
    }
    set layers(e2) {
      this._set("layers", n2(e2, this._get("layers")));
    }
    add(e2, r) {
      const t2 = this.layers;
      if (r = t2.getNextIndex(r), e2 instanceof b) {
        const s2 = e2;
        s2.parent === this ? this.reorder(s2, r) : t2.add(s2, r);
      } else
        C(e2) ? e2.then((e3) => {
          this.destroyed || this.add(e3, r);
        }) : s.getLogger(this.declaredClass).error("#add()", "The item being added is not a Layer or a Promise that resolves to a Layer.");
    }
    addMany(e2, r) {
      const t2 = this.layers;
      r = t2.getNextIndex(r), e2.slice().forEach((e3) => {
        e3.parent !== this ? (t2.add(e3, r), r += 1) : this.reorder(e3, r);
      });
    }
    findLayerById(e2) {
      return n3(this.layers, "id", e2);
    }
    findLayerByUid(e2) {
      return n3(this.layers, "uid", e2);
    }
    remove(e2) {
      return this.layers.remove(e2);
    }
    removeMany(e2) {
      return this.layers.removeMany(e2);
    }
    removeAll() {
      return this.layers.removeAll();
    }
    reorder(e2, r) {
      return this.layers.reorder(e2, r);
    }
    layerAdded(e2) {
    }
    layerRemoved(e2) {
    }
  };
  return e([y()], y2.prototype, "layers", null), y2 = e([n("esri.support.LayersMixin")], y2), y2;
};

// node_modules/@arcgis/core/support/TablesMixin.js
function a(t2, e2, r) {
  if (t2)
    for (let s2 = 0, o = t2.length; s2 < o; s2++) {
      const o2 = t2.getItemAt(s2);
      if (o2[e2] === r)
        return o2;
      if ("group" === (o2 == null ? void 0 : o2.type)) {
        const t3 = a(o2.tables, e2, r);
        if (t3)
          return t3;
      }
    }
}
var l2 = (l3) => {
  let n4 = class extends l3 {
    constructor(...t2) {
      super(...t2), this.tables = new j(), this.tables.on("after-add", (t3) => {
        const e2 = t3.item;
        e2.parent && e2.parent !== this && "tables" in e2.parent && e2.parent.tables.remove(e2), e2.parent = this, "feature" !== e2.type && s.getLogger(this.declaredClass).error(`Layer 'title:${e2.title}, id:${e2.id}' of type '${e2.type}' is not supported as a table and will therefore be ignored.`);
      }), this.tables.on("after-remove", (t3) => {
        t3.item.parent = null;
      });
    }
    destroy() {
      const t2 = this.tables.removeAll();
      for (const e2 of t2)
        e2.destroy();
      this.tables.destroy();
    }
    set tables(t2) {
      this._set("tables", n2(t2, this._get("tables")));
    }
    findTableById(t2) {
      return a(this.tables, "id", t2);
    }
    findTableByUid(t2) {
      return a(this.tables, "uid", t2);
    }
  };
  return e([y()], n4.prototype, "tables", null), n4 = e([n("esri.support.TablesMixin")], n4), n4;
};

export {
  t,
  d,
  l2 as l
};
//# sourceMappingURL=chunk-APU7GFNJ.js.map
