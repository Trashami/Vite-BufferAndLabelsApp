import {
  n as n4,
  s as s3
} from "./chunk-T5JB7HTP.js";
import {
  m,
  n2 as n5
} from "./chunk-GRWIJKD6.js";
import {
  r as r5
} from "./chunk-DWAZ7HI7.js";
import {
  s as s2
} from "./chunk-5SEVEYDG.js";
import {
  M as M2,
  W as W2
} from "./chunk-MOPTUDCV.js";
import {
  t as t4
} from "./chunk-6VLXCUNV.js";
import {
  E2 as E3,
  a as a2,
  i as i2,
  x
} from "./chunk-O4DPVR3F.js";
import {
  E as E2,
  a,
  n as n3
} from "./chunk-MATM5L52.js";
import {
  t as t3
} from "./chunk-4OM3EX6P.js";
import {
  A,
  C,
  D,
  E,
  F,
  G,
  I,
  L,
  M,
  N,
  O,
  P,
  R,
  S,
  T,
  U as U2,
  V,
  W,
  X,
  Y,
  _,
  f,
  n as n2,
  r as r3,
  t as t2
} from "./chunk-3OFVLRSL.js";
import {
  r as r4
} from "./chunk-4JNOVZUK.js";
import {
  r as r2
} from "./chunk-D4V6J5BT.js";
import {
  n5 as n
} from "./chunk-OOLCFNXJ.js";
import {
  U
} from "./chunk-MJXQTGI2.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";
import {
  i,
  o,
  r,
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/MaterialPrograms.js
var e = (r9) => {
  let t6 = "";
  t6 += r9[0].toUpperCase();
  for (let e5 = 1; e5 < r9.length; e5++) {
    const s6 = r9[e5];
    s6 === s6.toUpperCase() ? (t6 += "_", t6 += s6) : t6 += s6.toUpperCase();
  }
  return t6;
};
var s4 = (r9) => {
  const s6 = {};
  for (const t6 in r9) {
    s6[e(t6)] = r9[t6];
  }
  return n4(s6);
};
var o2 = (t6, e5, o6, n7) => {
  const a3 = t6 + t6.substring(t6.lastIndexOf("/")), p = e5 + e5.substring(e5.lastIndexOf("/")), f3 = s4(n7);
  return { attributes: o6, shaders: { vertexShader: f3 + n5(`${a3}.vert`), fragmentShader: f3 + n5(`${p}.frag`) } };
};

// node_modules/@arcgis/core/views/webgl/ContextState.js
var h = class {
  constructor() {
    this.blend = false, this.blendColor = { r: 0, g: 0, b: 0, a: 0 }, this.blendFunction = { srcRGB: R.ONE, dstRGB: R.ZERO, srcAlpha: R.ONE, dstAlpha: R.ZERO }, this.blendEquation = { mode: T.ADD, modeAlpha: T.ADD }, this.colorMask = { r: true, g: true, b: true, a: true }, this.faceCulling = false, this.cullFace = N.BACK, this.frontFace = S.CCW, this.scissorTest = false, this.scissorRect = { x: 0, y: 0, width: 0, height: 0 }, this.depthTest = false, this.depthFunction = I.LESS, this.clearDepth = 1, this.depthWrite = true, this.depthRange = { zNear: 0, zFar: 1 }, this.viewport = null, this.stencilTest = false, this.polygonOffsetFill = false, this.polygonOffset = [0, 0], this.stencilFunction = { face: N.FRONT_AND_BACK, func: I.ALWAYS, ref: 0, mask: 1 }, this.clearStencil = 0, this.stencilWriteMask = 1, this.stencilOperation = { face: N.FRONT_AND_BACK, fail: O.KEEP, zFail: O.KEEP, zPass: O.KEEP }, this.clearColor = { r: 0, g: 0, b: 0, a: 0 }, this.program = null, this.vertexBuffer = null, this.indexBuffer = null, this.uniformBuffer = null, this.pixelPackBuffer = null, this.pixelUnpackBuffer = null, this.copyReadBuffer = null, this.copyWriteBuffer = null, this.uniformBufferBindingPoints = new Array(), this.readFramebuffer = null, this.drawFramebuffer = null, this.renderbuffer = null, this.activeTexture = 0, this.textureUnitMap = new Array(), this.vertexArrayObject = null;
  }
};

// node_modules/@arcgis/core/views/support/AllocationTracer.js
var o3 = class {
  constructor(o6) {
    this._allocations = /* @__PURE__ */ new Map(), o6 ? Error.stackTraceLimit = 1 / 0 : (this.add = () => {
    }, this.remove = () => {
    });
  }
  add(o6) {
    this._allocations.set(o6, new Error().stack);
  }
  remove(o6) {
    this._allocations.delete(o6);
  }
  print() {
    if (this._allocations.size > 0) {
      console.log(`${this._allocations.size} live object allocations:`);
      const o6 = /* @__PURE__ */ new Map();
      this._allocations.forEach((s6) => {
        var _a;
        o6.set(s6, ((_a = o6.get(s6)) != null ? _a : 0) + 1);
      }), o6.forEach((o7, s6) => {
        const t6 = s6.split("\n");
        t6.shift(), t6.shift(), console.log(`${o7}: ${t6.shift()}`), t6.forEach((o8) => console.log("   ", o8));
      });
    }
  }
};

// node_modules/@arcgis/core/views/webgl/InstanceCounter.js
var e2 = { RECORD_ALLOCATIONS: false };
var s5 = class {
  constructor() {
    for (this._current = new Array(), this._max = new Array(), this._allocations = new o3(e2.RECORD_ALLOCATIONS); this._current.length < t2.COUNT; )
      this._current.push(0), this._max.push(0);
  }
  resetMax() {
    for (this._max.length = 0; this._max.length < this._current.length; )
      this._max.push(0);
  }
  increment(t6, r9) {
    const e5 = ++this._current[t6];
    this._max[t6] = Math.max(e5, this._max[t6]), this._allocations.add(r9);
  }
  decrement(t6, r9) {
    --this._current[t6], this._allocations.remove(r9);
  }
  get max() {
    return this._max;
  }
  get current() {
    return this._current;
  }
  get total() {
    return this.current.reduce((t6, r9) => t6 + r9, 0);
  }
  printResourceCount() {
    if (this.total > 0) {
      console.log("Live objects:");
      for (let t6 = 0; t6 < t2.COUNT; ++t6) {
        const e5 = this._current[t6];
        e5 > 0 && console.log(`${t2[t6]}: ${e5}`);
      }
    }
    this._allocations.print();
  }
};

// node_modules/@arcgis/core/views/webgl/testDoublePrecisionArithmetic.js
function d(t6, d2) {
  t6.resetState();
  const B = new x(t6, { colorTarget: Y.TEXTURE, depthStencilTarget: V.NONE }, { target: M.TEXTURE_2D, wrapMode: D.CLAMP_TO_EDGE, pixelFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, samplingMode: L.NEAREST, width: 1, height: 1 }), E6 = E3.createVertex(t6, F.STATIC_DRAW, new Uint16Array([0, 0, 1, 0, 0, 1, 1, 1])), g = new a2(t6, /* @__PURE__ */ new Map([["position", 0]]), { geometry: [new t3("position", 2, C.UNSIGNED_SHORT, 0, 4)] }, { geometry: E6 }), T4 = r2(5633261287538229e-9, 2626832878767164e-9, 1.4349880495278358e6), b = r2(563327146742708e-8, 2.6268736381334523e6, 1434963231608387e-9), F3 = _2(t6, T4, b, d2);
  t6.bindFramebuffer(B), t6.setViewport(0, 0, 1, 1), t6.bindVAO(g), t6.drawArrays(E.TRIANGLE_STRIP, 0, 4);
  const U3 = new Uint8Array(4);
  B.readPixels(0, 0, 1, 1, P.RGBA, G.UNSIGNED_BYTE, U3), F3.dispose(), g.dispose(false), E6.dispose(), B.dispose();
  const w2 = (T4[2] - b[2]) / 25, O2 = r5(U3);
  return Math.abs(w2 - O2);
}
function _2(n7, e5, o6, r9) {
  const i3 = `

  precision highp float;

  attribute vec2 position;

  uniform vec3 u_highA;
  uniform vec3 u_lowA;
  uniform vec3 u_highB;
  uniform vec3 u_lowB;

  varying vec4 v_color;

  ${r9 ? "#define DOUBLE_PRECISION_REQUIRES_OBFUSCATION" : ""}

  #ifdef DOUBLE_PRECISION_REQUIRES_OBFUSCATION

  vec3 dpPlusFrc(vec3 a, vec3 b) {
    return mix(a, a + b, vec3(notEqual(b, vec3(0))));
  }

  vec3 dpMinusFrc(vec3 a, vec3 b) {
    return mix(vec3(0), a - b, vec3(notEqual(a, b)));
  }

  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {
    vec3 t1 = dpPlusFrc(hiA, hiB);
    vec3 e = dpMinusFrc(t1, hiA);
    vec3 t2 = dpMinusFrc(hiB, e) + dpMinusFrc(hiA, dpMinusFrc(t1, e)) + loA + loB;
    return t1 + t2;
  }

  #else

  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {
    vec3 t1 = hiA + hiB;
    vec3 e = t1 - hiA;
    vec3 t2 = ((hiB - e) + (hiA - (t1 - e))) + loA + loB;
    return t1 + t2;
  }

  #endif

  const float MAX_RGBA_FLOAT =
    255.0 / 256.0 +
    255.0 / 256.0 / 256.0 +
    255.0 / 256.0 / 256.0 / 256.0 +
    255.0 / 256.0 / 256.0 / 256.0 / 256.0;

  const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);

  vec4 float2rgba(const float value) {
    // Make sure value is in the domain we can represent
    float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);

    // Decompose value in 32bit fixed point parts represented as
    // uint8 rgba components. Decomposition uses the fractional part after multiplying
    // by a power of 256 (this removes the bits that are represented in the previous
    // component) and then converts the fractional part to 8bits.
    vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);

    // Convert uint8 values (from 0 to 255) to floating point representation for
    // the shader
    const float toU8AsFloat = 1.0 / 255.0;

    return fixedPointU8 * toU8AsFloat;
  }

  void main() {
    vec3 val = dpAdd(u_highA, u_lowA, -u_highB, -u_lowB);

    v_color = float2rgba(val.z / 25.0);

    gl_Position = vec4(position * 2.0 - 1.0, 0.0, 1.0);
  }
  `, a3 = "\n  precision highp float;\n\n  varying vec4 v_color;\n\n  void main() {\n    gl_FragColor = v_color;\n  }\n  ", c = n7.programCache.acquire(i3, a3, /* @__PURE__ */ new Map([["position", 0]])), s6 = new Float32Array(6);
  t4(e5, s6, 3);
  const l2 = new Float32Array(6);
  return t4(o6, l2, 3), n7.useProgram(c), c.setUniform3f("u_highA", s6[0], s6[2], s6[4]), c.setUniform3f("u_lowA", s6[1], s6[3], s6[5]), c.setUniform3f("u_highB", l2[0], l2[2], l2[4]), c.setUniform3f("u_lowB", l2[1], l2[3], l2[5]), c;
}

// node_modules/@arcgis/core/views/webgl/testFloatBufferBlend.js
var T2;
var _3;
var F2;
var x2 = { exports: {} };
function A2(T4) {
  var _a, _b, _c, _d, _e;
  if (!T4.gl)
    return false;
  if (T4.type === r4.WEBGL1)
    return !(!((_a = T4.capabilities.textureFloat) == null ? void 0 : _a.textureFloat) || !((_b = T4.capabilities.colorBufferFloat) == null ? void 0 : _b.textureFloat));
  if (!(((_c = T4.capabilities.textureFloat) == null ? void 0 : _c.textureFloat) && ((_d = T4.capabilities.colorBufferFloat) == null ? void 0 : _d.textureFloat) && ((_e = T4.capabilities.colorBufferFloat) == null ? void 0 : _e.floatBlend)))
    return false;
  const _5 = new x(T4, { colorTarget: Y.TEXTURE, depthStencilTarget: V.NONE }, { target: M.TEXTURE_2D, wrapMode: D.CLAMP_TO_EDGE, pixelFormat: P.RGBA, dataType: G.FLOAT, internalFormat: U2.RGBA32F, samplingMode: L.NEAREST, width: 1, height: 1 }), F3 = E3.createVertex(T4, F.STATIC_DRAW, new Uint16Array([0, 0, 1, 0, 0, 1, 1, 1])), A4 = new a2(T4, /* @__PURE__ */ new Map([["a_pos", 0]]), { geometry: [new t3("a_pos", 2, C.UNSIGNED_SHORT, 0, 4)] }, { geometry: F3 }), R3 = "\n  precision highp float;\n  attribute vec2 a_pos;\n\n  void main() {\n    gl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);\n  }\n  ", v2 = "\n   precision highp float;\n\n   void main() {\n    gl_FragColor = vec4(0.5, 0.5, 0.5, 0.5);\n   }\n  ", S2 = T4.programCache.acquire(R3, v2, /* @__PURE__ */ new Map([["a_pos", 0]]));
  T4.useProgram(S2);
  const h2 = T4.getBoundFramebufferObject(), { x: P2, y: L2, width: B, height: C2 } = T4.getViewport();
  T4.bindFramebuffer(_5), T4.setViewport(0, 0, 1, 1), T4.bindVAO(A4), T4.drawArrays(E.TRIANGLE_STRIP, 0, 4);
  const w2 = W2({ blending: s2 });
  T4.setPipelineState(w2), T4.drawArrays(E.TRIANGLE_STRIP, 0, 4), x2.exports.init(T4);
  const O2 = T4.gl.getError();
  return T4.setViewport(P2, L2, B, C2), T4.bindFramebuffer(h2), S2.dispose(), A4.dispose(false), F3.dispose(), _5.dispose(), 1282 !== O2 || (console.warn("Device claims support for WebGL extension EXT_float_blend but does not support it. Using fall back."), false);
}
T2 = x2, _3 = function() {
  var e5 = function(e6) {
    window.console && window.console.log && window.console.log(e6);
  }, t6 = function(t7) {
    window.console && window.console.error ? window.console.error(t7) : e5(t7);
  }, r9 = { enable: { 1: { 0: true } }, disable: { 1: { 0: true } }, getParameter: { 1: { 0: true } }, drawArrays: { 3: { 0: true } }, drawElements: { 4: { 0: true, 2: true } }, createShader: { 1: { 0: true } }, getShaderParameter: { 2: { 1: true } }, getProgramParameter: { 2: { 1: true } }, getShaderPrecisionFormat: { 2: { 0: true, 1: true } }, getVertexAttrib: { 2: { 1: true } }, vertexAttribPointer: { 6: { 2: true } }, bindTexture: { 2: { 0: true } }, activeTexture: { 1: { 0: true } }, getTexParameter: { 2: { 0: true, 1: true } }, texParameterf: { 3: { 0: true, 1: true } }, texParameteri: { 3: { 0: true, 1: true, 2: true } }, texImage2D: { 9: { 0: true, 2: true, 6: true, 7: true }, 6: { 0: true, 2: true, 3: true, 4: true } }, texSubImage2D: { 9: { 0: true, 6: true, 7: true }, 7: { 0: true, 4: true, 5: true } }, copyTexImage2D: { 8: { 0: true, 2: true } }, copyTexSubImage2D: { 8: { 0: true } }, generateMipmap: { 1: { 0: true } }, compressedTexImage2D: { 7: { 0: true, 2: true } }, compressedTexSubImage2D: { 8: { 0: true, 6: true } }, bindBuffer: { 2: { 0: true } }, bufferData: { 3: { 0: true, 2: true } }, bufferSubData: { 3: { 0: true } }, getBufferParameter: { 2: { 0: true, 1: true } }, pixelStorei: { 2: { 0: true, 1: true } }, readPixels: { 7: { 4: true, 5: true } }, bindRenderbuffer: { 2: { 0: true } }, bindFramebuffer: { 2: { 0: true } }, checkFramebufferStatus: { 1: { 0: true } }, framebufferRenderbuffer: { 4: { 0: true, 1: true, 2: true } }, framebufferTexture2D: { 5: { 0: true, 1: true, 2: true } }, getFramebufferAttachmentParameter: { 3: { 0: true, 1: true, 2: true } }, getRenderbufferParameter: { 2: { 0: true, 1: true } }, renderbufferStorage: { 4: { 0: true, 1: true } }, clear: { 1: { 0: { enumBitwiseOr: ["COLOR_BUFFER_BIT", "DEPTH_BUFFER_BIT", "STENCIL_BUFFER_BIT"] } } }, depthFunc: { 1: { 0: true } }, blendFunc: { 2: { 0: true, 1: true } }, blendFuncSeparate: { 4: { 0: true, 1: true, 2: true, 3: true } }, blendEquation: { 1: { 0: true } }, blendEquationSeparate: { 2: { 0: true, 1: true } }, stencilFunc: { 3: { 0: true } }, stencilFuncSeparate: { 4: { 0: true, 1: true } }, stencilMaskSeparate: { 2: { 0: true } }, stencilOp: { 3: { 0: true, 1: true, 2: true } }, stencilOpSeparate: { 4: { 0: true, 1: true, 2: true, 3: true } }, cullFace: { 1: { 0: true } }, frontFace: { 1: { 0: true } }, drawArraysInstancedANGLE: { 4: { 0: true } }, drawElementsInstancedANGLE: { 5: { 0: true, 2: true } }, blendEquationEXT: { 1: { 0: true } } }, n7 = null, o6 = null;
  function a3(e6) {
    if (null == n7)
      for (var t7 in n7 = {}, o6 = {}, e6)
        "number" == typeof e6[t7] && (n7[e6[t7]] = t7, o6[t7] = e6[t7]);
  }
  function i3() {
    if (null == n7)
      throw "WebGLDebugUtils.init(ctx) not called";
  }
  function f3(e6) {
    return i3(), void 0 !== n7[e6];
  }
  function u(e6) {
    i3();
    var t7 = n7[e6];
    return void 0 !== t7 ? "gl." + t7 : "/*UNKNOWN WebGL ENUM*/ 0x" + e6.toString(16);
  }
  function l2(e6, t7, n8, a4) {
    var i4;
    if (void 0 !== (i4 = r9[e6]) && void 0 !== (i4 = i4[t7]) && i4[n8]) {
      if ("object" == typeof i4[n8] && void 0 !== i4[n8].enumBitwiseOr) {
        for (var f4 = i4[n8].enumBitwiseOr, l3 = 0, c2 = [], s7 = 0; s7 < f4.length; ++s7) {
          var d3 = o6[f4[s7]];
          0 != (a4 & d3) && (l3 |= d3, c2.push(u(d3)));
        }
        return l3 === a4 ? c2.join(" | ") : u(a4);
      }
      return u(a4);
    }
    return null === a4 ? "null" : void 0 === a4 ? "undefined" : a4.toString();
  }
  function c(e6, t7) {
    for (var r10 = "", n8 = t7.length, o7 = 0; o7 < n8; ++o7)
      r10 += (0 == o7 ? "" : ", ") + l2(e6, n8, o7, t7[o7]);
    return r10;
  }
  function s6(e6, t7, r10) {
    e6.__defineGetter__(r10, function() {
      return t7[r10];
    }), e6.__defineSetter__(r10, function(e7) {
      t7[r10] = e7;
    });
  }
  function d2(e6, r10, n8, o7) {
    o7 = o7 || e6, a3(e6), r10 = r10 || function(e7, r11, n9) {
      for (var o8 = "", a4 = n9.length, i5 = 0; i5 < a4; ++i5)
        o8 += (0 == i5 ? "" : ", ") + l2(r11, a4, i5, n9[i5]);
      t6("WebGL error " + u(e7) + " in " + r11 + "(" + o8 + ")");
    };
    var i4 = {};
    function f4(e7, t7) {
      return function() {
        n8 && n8(t7, arguments);
        var a4 = e7[t7].apply(e7, arguments), f5 = o7.getError();
        return 0 != f5 && (i4[f5] = true, r10(f5, t7, arguments)), a4;
      };
    }
    var c2 = {};
    for (var g2 in e6)
      if ("function" == typeof e6[g2])
        if ("getExtension" != g2)
          c2[g2] = f4(e6, g2);
        else {
          var b2 = f4(e6, g2);
          c2[g2] = function() {
            return d2(b2.apply(e6, arguments), r10, n8, o7);
          };
        }
      else
        s6(c2, e6, g2);
    return c2.getError = function() {
      for (var t7 in i4)
        if (i4.hasOwnProperty(t7) && i4[t7])
          return i4[t7] = false, t7;
      return e6.NO_ERROR;
    }, c2;
  }
  function g(e6) {
    var t7 = e6.getParameter(e6.MAX_VERTEX_ATTRIBS), r10 = e6.createBuffer();
    e6.bindBuffer(e6.ARRAY_BUFFER, r10);
    for (var n8 = 0; n8 < t7; ++n8)
      e6.disableVertexAttribArray(n8), e6.vertexAttribPointer(n8, 4, e6.FLOAT, false, 0, 0), e6.vertexAttrib1f(n8, 0);
    e6.deleteBuffer(r10);
    var o7 = e6.getParameter(e6.MAX_TEXTURE_IMAGE_UNITS);
    for (n8 = 0; n8 < o7; ++n8)
      e6.activeTexture(e6.TEXTURE0 + n8), e6.bindTexture(e6.TEXTURE_CUBE_MAP, null), e6.bindTexture(e6.TEXTURE_2D, null);
    for (e6.activeTexture(e6.TEXTURE0), e6.useProgram(null), e6.bindBuffer(e6.ARRAY_BUFFER, null), e6.bindBuffer(e6.ELEMENT_ARRAY_BUFFER, null), e6.bindFramebuffer(e6.FRAMEBUFFER, null), e6.bindRenderbuffer(e6.RENDERBUFFER, null), e6.disable(e6.BLEND), e6.disable(e6.CULL_FACE), e6.disable(e6.DEPTH_TEST), e6.disable(e6.DITHER), e6.disable(e6.SCISSOR_TEST), e6.blendColor(0, 0, 0, 0), e6.blendEquation(e6.FUNC_ADD), e6.blendFunc(e6.ONE, e6.ZERO), e6.clearColor(0, 0, 0, 0), e6.clearDepth(1), e6.clearStencil(-1), e6.colorMask(true, true, true, true), e6.cullFace(e6.BACK), e6.depthFunc(e6.LESS), e6.depthMask(true), e6.depthRange(0, 1), e6.frontFace(e6.CCW), e6.hint(e6.GENERATE_MIPMAP_HINT, e6.DONT_CARE), e6.lineWidth(1), e6.pixelStorei(e6.PACK_ALIGNMENT, 4), e6.pixelStorei(e6.UNPACK_ALIGNMENT, 4), e6.pixelStorei(e6.UNPACK_FLIP_Y_WEBGL, false), e6.pixelStorei(e6.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false), e6.UNPACK_COLORSPACE_CONVERSION_WEBGL && e6.pixelStorei(e6.UNPACK_COLORSPACE_CONVERSION_WEBGL, e6.BROWSER_DEFAULT_WEBGL), e6.polygonOffset(0, 0), e6.sampleCoverage(1, false), e6.scissor(0, 0, e6.canvas.width, e6.canvas.height), e6.stencilFunc(e6.ALWAYS, 0, 4294967295), e6.stencilMask(4294967295), e6.stencilOp(e6.KEEP, e6.KEEP, e6.KEEP), e6.viewport(0, 0, e6.canvas.width, e6.canvas.height), e6.clear(e6.COLOR_BUFFER_BIT | e6.DEPTH_BUFFER_BIT | e6.STENCIL_BUFFER_BIT); e6.getError(); )
      ;
  }
  function b(e6) {
    var t7, r10, n8 = [], o7 = [], a4 = {}, i4 = 1, f4 = false, u2 = [], l3 = 0, c2 = 0, d3 = false, b2 = 0, E6 = {};
    function p(e7) {
      return "function" == typeof e7 ? e7 : function(t8) {
        e7.handleEvent(t8);
      };
    }
    e6.getContext = (r10 = e6.getContext, function() {
      var n9 = r10.apply(e6, arguments);
      if (n9 instanceof WebGLRenderingContext) {
        if (n9 != t7) {
          if (t7)
            throw "got different context";
          a4 = S2(t7 = n9);
        }
        return a4;
      }
      return n9;
    });
    var m2 = function(e7) {
      n8.push(p(e7));
    }, T4 = function(e7) {
      o7.push(p(e7));
    };
    function _5(e7) {
      var t8 = e7.addEventListener;
      e7.addEventListener = function(r11, n9, o8) {
        switch (r11) {
          case "webglcontextlost":
            m2(n9);
            break;
          case "webglcontextrestored":
            T4(n9);
            break;
          default:
            t8.apply(e7, arguments);
        }
      };
    }
    function F3() {
      for (var e7 = Object.keys(E6), t8 = 0; t8 < e7.length; ++t8)
        delete E6[e7];
    }
    function x4() {
      ++c2, f4 || l3 == c2 && e6.loseContext();
    }
    function A4(e7, t8) {
      var r11 = e7[t8];
      return function() {
        if (x4(), !f4)
          return r11.apply(e7, arguments);
      };
    }
    function R3() {
      for (var e7 = 0; e7 < u2.length; ++e7) {
        var r11 = u2[e7];
        r11 instanceof WebGLBuffer ? t7.deleteBuffer(r11) : r11 instanceof WebGLFramebuffer ? t7.deleteFramebuffer(r11) : r11 instanceof WebGLProgram ? t7.deleteProgram(r11) : r11 instanceof WebGLRenderbuffer ? t7.deleteRenderbuffer(r11) : r11 instanceof WebGLShader ? t7.deleteShader(r11) : r11 instanceof WebGLTexture && t7.deleteTexture(r11);
      }
    }
    function v2(e7) {
      return { statusMessage: e7, preventDefault: function() {
        d3 = true;
      } };
    }
    return _5(e6), e6.loseContext = function() {
      if (!f4) {
        for (f4 = true, l3 = 0, ++i4; t7.getError(); )
          ;
        F3(), E6[t7.CONTEXT_LOST_WEBGL] = true;
        var r11 = v2("context lost"), o8 = n8.slice();
        setTimeout(function() {
          for (var t8 = 0; t8 < o8.length; ++t8)
            o8[t8](r11);
          b2 >= 0 && setTimeout(function() {
            e6.restoreContext();
          }, b2);
        }, 0);
      }
    }, e6.restoreContext = function() {
      f4 && o7.length && setTimeout(function() {
        if (!d3)
          throw "can not restore. webglcontestlost listener did not call event.preventDefault";
        R3(), g(t7), f4 = false, c2 = 0, d3 = false;
        for (var e7 = o7.slice(), r11 = v2("context restored"), n9 = 0; n9 < e7.length; ++n9)
          e7[n9](r11);
      }, 0);
    }, e6.loseContextInNCalls = function(e7) {
      if (f4)
        throw "You can not ask a lost contet to be lost";
      l3 = c2 + e7;
    }, e6.getNumCalls = function() {
      return c2;
    }, e6.setRestoreTimeout = function(e7) {
      b2 = e7;
    }, e6;
    function S2(e7) {
      for (var r11 in e7)
        "function" == typeof e7[r11] ? a4[r11] = A4(e7, r11) : s6(a4, e7, r11);
      a4.getError = function() {
        if (x4(), !f4)
          for (; e8 = t7.getError(); )
            E6[e8] = true;
        for (var e8 in E6)
          if (E6[e8])
            return delete E6[e8], e8;
        return a4.NO_ERROR;
      };
      for (var n9 = ["createBuffer", "createFramebuffer", "createProgram", "createRenderbuffer", "createShader", "createTexture"], o8 = 0; o8 < n9.length; ++o8) {
        var l4 = n9[o8];
        a4[l4] = function(t8) {
          return function() {
            if (x4(), f4)
              return null;
            var r12 = t8.apply(e7, arguments);
            return r12.__webglDebugContextLostId__ = i4, u2.push(r12), r12;
          };
        }(e7[l4]);
      }
      var c3 = ["getActiveAttrib", "getActiveUniform", "getBufferParameter", "getContextAttributes", "getAttachedShaders", "getFramebufferAttachmentParameter", "getParameter", "getProgramParameter", "getProgramInfoLog", "getRenderbufferParameter", "getShaderParameter", "getShaderInfoLog", "getShaderSource", "getTexParameter", "getUniform", "getUniformLocation", "getVertexAttrib"];
      for (o8 = 0; o8 < c3.length; ++o8)
        l4 = c3[o8], a4[l4] = function(t8) {
          return function() {
            return x4(), f4 ? null : t8.apply(e7, arguments);
          };
        }(a4[l4]);
      var d4 = ["isBuffer", "isEnabled", "isFramebuffer", "isProgram", "isRenderbuffer", "isShader", "isTexture"];
      for (o8 = 0; o8 < d4.length; ++o8)
        l4 = d4[o8], a4[l4] = function(t8) {
          return function() {
            return x4(), !f4 && t8.apply(e7, arguments);
          };
        }(a4[l4]);
      return a4.checkFramebufferStatus = function(t8) {
        return function() {
          return x4(), f4 ? a4.FRAMEBUFFER_UNSUPPORTED : t8.apply(e7, arguments);
        };
      }(a4.checkFramebufferStatus), a4.getAttribLocation = function(t8) {
        return function() {
          return x4(), f4 ? -1 : t8.apply(e7, arguments);
        };
      }(a4.getAttribLocation), a4.getVertexAttribOffset = function(t8) {
        return function() {
          return x4(), f4 ? 0 : t8.apply(e7, arguments);
        };
      }(a4.getVertexAttribOffset), a4.isContextLost = function() {
        return f4;
      }, a4;
    }
  }
  return { init: a3, mightBeEnum: f3, glEnumToString: u, glFunctionArgToString: l2, glFunctionArgsToString: c, makeDebugContext: d2, makeLostContextSimulatingCanvas: b, resetToInitialState: g };
}, void 0 !== (F2 = _3()) && (T2.exports = F2);

// node_modules/@arcgis/core/views/webgl/testSamplerPrecision.js
function w(w2) {
  const h2 = new x(w2, { colorTarget: Y.TEXTURE, depthStencilTarget: V.NONE }, { target: M.TEXTURE_2D, wrapMode: D.CLAMP_TO_EDGE, pixelFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, samplingMode: L.NEAREST, width: 1, height: 1 }), _5 = "\nprecision highp float;\nattribute vec2 a_pos;\nuniform highp sampler2D u_texture;\nvarying vec4 v_color;\n\nfloat getBit(in float bitset, in int bitIndex) {\n  float offset = pow(2.0, float(bitIndex));\n  return mod(floor(bitset / offset), 2.0);\n}\n\nvoid main() {\n  vec4 value = texture2D(u_texture, vec2(0.0));\n  float bit = getBit(value.x * 255.0, 1);\n\n  v_color = bit * vec4(1.0);\n  gl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);\n}\n", T4 = "\nprecision highp float;\nvarying vec4 v_color;\n\nvoid main() {\n  gl_FragColor = v_color;\n}\n", b = new Uint8Array(4), v2 = E3.createVertex(w2, F.STATIC_DRAW, new Uint16Array([0, 0, 1, 0, 0, 1, 1, 1])), E6 = new a2(w2, /* @__PURE__ */ new Map([["a_position", 0]]), { geometry: [new t3("a_position", 2, C.SHORT, 0, 4)] }, { geometry: v2 }), A4 = w2.programCache.acquire(_5, T4, /* @__PURE__ */ new Map([["a_pos", 0]]));
  w2.useProgram(A4);
  const x4 = new E2(w2, { target: M.TEXTURE_2D, wrapMode: D.CLAMP_TO_EDGE, pixelFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, samplingMode: L.NEAREST, width: 1, height: 1 }, new Uint8Array([2, 255, 0, 0]));
  A4.setUniform1i("u_texture", 0), w2.bindTexture(x4, 0);
  const y2 = w2.getBoundFramebufferObject();
  w2.bindFramebuffer(h2), w2.useProgram(A4);
  const { x: R3, y: j, width: D2, height: N2 } = w2.getViewport();
  w2.setViewport(0, 0, 1, 1), w2.bindVAO(E6), w2.drawArrays(E.TRIANGLE_STRIP, 0, 4), w2.setViewport(R3, j, D2, N2), h2.readPixels(0, 0, 1, 1, P.RGBA, G.UNSIGNED_BYTE, b), A4.dispose(), E6.dispose(false), v2.dispose(), h2.dispose();
  const B = 255 !== b[0] || 255 !== b[1] || 255 !== b[2] || 255 !== b[3];
  return B && s.getLogger("esri.views.webgl.testSamplerPrecision").warn(`A problem was detected with your graphics driver. Your driver does not appear to honor sampler precision specifiers, which may result in rendering issues due to numerical instability. We recommend ensuring that your drivers have been updated to the latest version. Applying lowp sampler workaround. [${b[0]}.${b[1]}.${b[2]}.${b[3]}]`), w2.bindFramebuffer(y2), B;
}

// node_modules/@arcgis/core/views/webgl/testSVGPremultipliedAlpha.js
async function f2(f3) {
  const w2 = new Image();
  if (w2.src = "data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='5' height='5' version='1.1' viewBox='0 0 5 5' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='5' height='5' fill='%23f00' fill-opacity='.5'/%3E%3C/svg%3E%0A", w2.width = 5, w2.height = 5, await w2.decode(), !f3.gl)
    return true;
  const _5 = new x(f3, { colorTarget: Y.TEXTURE, depthStencilTarget: V.NONE }, { target: M.TEXTURE_2D, wrapMode: D.CLAMP_TO_EDGE, pixelFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, samplingMode: L.NEAREST, width: 1, height: 1 }), E6 = E3.createVertex(f3, F.STATIC_DRAW, new Uint16Array([0, 0, 1, 0, 0, 1, 1, 1])), h2 = new a2(f3, /* @__PURE__ */ new Map([["a_pos", 0]]), m, { geometry: E6 }), v2 = "\n  precision highp float;\n\n  attribute vec2 a_pos;\n  varying vec2 v_uv;\n\n  void main() {\n    v_uv = a_pos;\n    gl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);\n  }\n  ", T4 = "\n  precision highp float;\n\n  varying vec2 v_uv;\n  uniform sampler2D u_texture;\n\n  void main() {\n    gl_FragColor = texture2D(u_texture, v_uv);\n  }\n  ", x4 = f3.programCache.acquire(v2, T4, /* @__PURE__ */ new Map([["a_pos", 0]]));
  f3.useProgram(x4);
  const A4 = new E2(f3, { dataType: G.UNSIGNED_BYTE, pixelFormat: P.RGBA, preMultiplyAlpha: false, wrapMode: D.CLAMP_TO_EDGE, samplingMode: L.LINEAR }, w2);
  f3.bindTexture(A4, 0), x4.setUniform1i("u_texture", 0);
  const b = f3.getBoundFramebufferObject(), { x: y2, y: B, width: C2, height: F3 } = f3.getViewport();
  f3.bindFramebuffer(_5), f3.setViewport(0, 0, 1, 1), f3.setClearColor(0, 0, 0, 0), f3.setBlendingEnabled(false), f3.clearSafe(_.COLOR_BUFFER_BIT), f3.bindVAO(h2), f3.drawArrays(E.TRIANGLE_STRIP, 0, 4);
  const R3 = new Uint8Array(4);
  return _5.readPixels(0, 0, 1, 1, P.RGBA, G.UNSIGNED_BYTE, R3), x4.dispose(), h2.dispose(false), E6.dispose(), _5.dispose(), A4.dispose(), f3.setViewport(y2, B, C2, F3), f3.bindFramebuffer(b), w2.src = "", 255 === R3[0];
}

// node_modules/@arcgis/core/views/webgl/WebGLDriverTest.js
var o4 = class {
  constructor(e5) {
    this.context = e5, this._floatBufferBlendWorking = A2(e5), f2(e5).then((e6) => this._svgAlwaysPremultipliesAlpha = !e6);
  }
  get floatBufferBlendWorking() {
    if (t(this._floatBufferBlendWorking))
      throw new Error("floatBufferBlendWorking test not yet available");
    return this._floatBufferBlendWorking;
  }
  get svgAlwaysPremultipliesAlpha() {
    if (t(this._svgAlwaysPremultipliesAlpha))
      throw new Error("svgAlwaysPremultipliesAlpha test not yet available");
    return this._svgAlwaysPremultipliesAlpha;
  }
  get doublePrecisionRequiresObfuscation() {
    if (t(this._doublePrecisionRequiresObfuscation)) {
      const e5 = d(this.context, false), i3 = d(this.context, true);
      this._doublePrecisionRequiresObfuscation = 0 !== e5 && (0 === i3 || e5 / i3 > 5);
    }
    return this._doublePrecisionRequiresObfuscation;
  }
  get ignoresSamplerPrecision() {
    return t(this._ignoresSamplerPrecision) && (this._ignoresSamplerPrecision = w(this.context)), this._ignoresSamplerPrecision;
  }
};

// node_modules/@arcgis/core/views/webgl/capabilities/DisjointTimerQuery.js
var t5 = class {
  constructor(e5, t6, E6, T4, r9, _5, i3, u, s6) {
    this.createQuery = e5, this.deleteQuery = t6, this.resultAvailable = E6, this.getResult = T4, this.disjoint = r9, this.beginTimeElapsed = _5, this.endTimeElapsed = i3, this.createTimestamp = u, this.timestampBits = s6;
  }
};
var E4 = false;
function T3(T4, r9) {
  if (r9.disjointTimerQuery)
    return null;
  let _5 = T4.getExtension("EXT_disjoint_timer_query_webgl2");
  return _5 && n3(T4) ? new t5(() => T4.createQuery(), (e5) => {
    T4.deleteQuery(e5), E4 = false;
  }, (e5) => T4.getQueryParameter(e5, T4.QUERY_RESULT_AVAILABLE), (e5) => T4.getQueryParameter(e5, T4.QUERY_RESULT), () => T4.getParameter(_5.GPU_DISJOINT_EXT), (e5) => {
    E4 || (E4 = true, T4.beginQuery(_5.TIME_ELAPSED_EXT, e5));
  }, () => {
    T4.endQuery(_5.TIME_ELAPSED_EXT), E4 = false;
  }, (e5) => _5.queryCounterEXT(e5, _5.TIMESTAMP_EXT), () => T4.getQuery(_5.TIMESTAMP_EXT, _5.QUERY_COUNTER_BITS_EXT)) : (_5 = T4.getExtension("EXT_disjoint_timer_query"), _5 ? new t5(() => _5.createQueryEXT(), (e5) => {
    _5.deleteQueryEXT(e5), E4 = false;
  }, (e5) => _5.getQueryObjectEXT(e5, _5.QUERY_RESULT_AVAILABLE_EXT), (e5) => _5.getQueryObjectEXT(e5, _5.QUERY_RESULT_EXT), () => T4.getParameter(_5.GPU_DISJOINT_EXT), (e5) => {
    E4 || (E4 = true, _5.beginQueryEXT(_5.TIME_ELAPSED_EXT, e5));
  }, () => {
    _5.endQueryEXT(_5.TIME_ELAPSED_EXT), E4 = false;
  }, (e5) => _5.queryCounterEXT(e5, _5.TIMESTAMP_EXT), () => _5.getQueryEXT(_5.TIMESTAMP_EXT, _5.QUERY_COUNTER_BITS_EXT)) : null);
}

// node_modules/@arcgis/core/views/webgl/capabilities/DrawBuffers.js
function A3(A4, _5) {
  if (_5.disjointTimerQuery)
    return null;
  if (n3(A4))
    return { drawBuffers: A4.drawBuffers.bind(A4), MAX_DRAW_BUFFERS: A4.MAX_DRAW_BUFFERS, MAX_COLOR_ATTACHMENTS: A4.MAX_COLOR_ATTACHMENTS };
  if (_5.drawBuffers)
    return null;
  const e5 = A4.getExtension("WEBGL_draw_buffers");
  return e5 ? { drawBuffers: e5.drawBuffersWEBGL.bind(e5), MAX_DRAW_BUFFERS: e5.MAX_DRAW_BUFFERS_WEBGL, MAX_COLOR_ATTACHMENTS: e5.MAX_COLOR_ATTACHMENTS_WEBGL } : null;
}

// node_modules/@arcgis/core/views/webgl/capabilities/Instancing.js
function r6(r9) {
  if (n3(r9))
    return r9;
  const t6 = r9.getExtension("ANGLE_instanced_arrays");
  return t6 ? { drawArraysInstanced: t6.drawArraysInstancedANGLE.bind(t6), drawElementsInstanced: t6.drawElementsInstancedANGLE.bind(t6), vertexAttribDivisor: t6.vertexAttribDivisorANGLE.bind(t6) } : null;
}

// node_modules/@arcgis/core/views/webgl/capabilities/load.js
function _4(t6, _5) {
  if (_5.compressedTextureETC)
    return null;
  const e5 = t6.getExtension("WEBGL_compressed_texture_etc");
  return e5 ? { COMPRESSED_R11_EAC: e5.COMPRESSED_R11_EAC, COMPRESSED_SIGNED_R11_EAC: e5.COMPRESSED_SIGNED_R11_EAC, COMPRESSED_RG11_EAC: e5.COMPRESSED_RG11_EAC, COMPRESSED_SIGNED_RG11_EAC: e5.COMPRESSED_SIGNED_RG11_EAC, COMPRESSED_RGB8_ETC2: e5.COMPRESSED_RGB8_ETC2, COMPRESSED_SRGB8_ETC2: e5.COMPRESSED_SRGB8_ETC2, COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: e5.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: e5.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2, COMPRESSED_RGBA8_ETC2_EAC: e5.COMPRESSED_RGBA8_ETC2_EAC, COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: e5.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC } : null;
}
function e3(t6, _5) {
  if (_5.compressedTextureS3TC)
    return null;
  const e5 = t6.getExtension("WEBGL_compressed_texture_s3tc");
  return e5 ? { COMPRESSED_RGB_S3TC_DXT1: e5.COMPRESSED_RGB_S3TC_DXT1_EXT, COMPRESSED_RGBA_S3TC_DXT1: e5.COMPRESSED_RGBA_S3TC_DXT1_EXT, COMPRESSED_RGBA_S3TC_DXT3: e5.COMPRESSED_RGBA_S3TC_DXT3_EXT, COMPRESSED_RGBA_S3TC_DXT5: e5.COMPRESSED_RGBA_S3TC_DXT5_EXT } : null;
}
function E5(_5, e5) {
  if (n3(_5))
    return { MIN: _5.MIN, MAX: _5.MAX };
  if (e5.blendMinMax)
    return null;
  {
    const t6 = _5.getExtension("EXT_blend_minmax");
    return t6 ? { MIN: t6.MIN_EXT, MAX: t6.MAX_EXT } : null;
  }
}
function n6(t6, _5) {
  if (_5.textureFilterAnisotropic)
    return null;
  const e5 = t6.getExtension("EXT_texture_filter_anisotropic") || t6.getExtension("MOZ_EXT_texture_filter_anisotropic") || t6.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
  return e5 ? { MAX_TEXTURE_MAX_ANISOTROPY: e5.MAX_TEXTURE_MAX_ANISOTROPY_EXT, TEXTURE_MAX_ANISOTROPY: e5.TEXTURE_MAX_ANISOTROPY_EXT } : null;
}
function R2(_5, e5) {
  if (n3(_5))
    return { textureFloat: true, textureFloatLinear: !e5.textureFloatLinear && !!_5.getExtension("OES_texture_float_linear"), textureHalfFloat: true, textureHalfFloatLinear: true, HALF_FLOAT: _5.HALF_FLOAT, R16F: _5.R16F, RG16F: _5.RG16F, RGBA16F: _5.RGBA16F, R32F: _5.R32F, RG32F: _5.RG32F, RGBA32F: _5.RGBA32F, R11F_G11F_B10F: _5.R11F_G11F_B10F, RGB16F: _5.RGB16F };
  if (_5 instanceof WebGLRenderingContext) {
    const t6 = !e5.textureHalfFloat && _5.getExtension("OES_texture_half_float");
    return { textureFloat: !e5.textureFloat && !!_5.getExtension("OES_texture_float"), textureFloatLinear: !e5.textureFloatLinear && !!_5.getExtension("OES_texture_float_linear"), textureHalfFloat: !!t6, textureHalfFloatLinear: !e5.textureHalfFloatLinear && !!_5.getExtension("OES_texture_half_float_linear"), HALF_FLOAT: t6 ? t6.HALF_FLOAT_OES : void 0 };
  }
  return null;
}
function r7(_5, e5) {
  if (n3(_5)) {
    const t6 = !e5.colorBufferHalfFloat && _5.getExtension("EXT_color_buffer_half_float") || !e5.colorBufferFloat && _5.getExtension("EXT_color_buffer_float"), E6 = !e5.colorBufferFloat && _5.getExtension("EXT_color_buffer_float"), n7 = !e5.floatBlend && !e5.colorBufferFloat && _5.getExtension("EXT_float_blend");
    return t6 || E6 || n7 ? { textureFloat: !!E6, textureHalfFloat: !!t6, floatBlend: !!n7, R16F: _5.R16F, RG16F: _5.RG16F, RGBA16F: _5.RGBA16F, R32F: _5.R32F, RG32F: _5.RG32F, RGBA32F: _5.RGBA32F, R11F_G11F_B10F: _5.R11F_G11F_B10F, RGB16F: _5.RGB16F } : null;
  }
  if (_5 instanceof WebGLRenderingContext) {
    const t6 = !e5.colorBufferHalfFloat && _5.getExtension("EXT_color_buffer_half_float"), E6 = !e5.colorBufferFloat && _5.getExtension("WEBGL_color_buffer_float"), n7 = !e5.floatBlend && !e5.colorBufferFloat && _5.getExtension("EXT_float_blend");
    return t6 || E6 || n7 ? { textureFloat: !!E6, textureHalfFloat: !!t6, floatBlend: !!n7, RGBA16F: t6 ? t6.RGBA16F_EXT : void 0, RGB16F: t6 ? t6.RGB16F_EXT : void 0, RGBA32F: E6 ? E6.RGBA32F_EXT : void 0 } : null;
  }
  return null;
}
function o5(_5, e5, E6, n7, R3) {
  if (n7 && n3(_5))
    return true;
  if (e5[E6])
    return false;
  for (const t6 of R3)
    if (_5.getExtension(t6))
      return true;
  return false;
}
function l(_5, e5) {
  if (!n3(_5))
    return null;
  if (e5.textureNorm16)
    return null;
  const E6 = _5.getExtension("EXT_texture_norm16");
  return E6 ? { R16: E6.R16_EXT, RG16: E6.RG16_EXT, RGB16: E6.RGB16_EXT, RGBA16: E6.RGBA16_EXT, R16_SNORM: E6.R16_SNORM_EXT, RG16_SNORM: E6.RG16_SNORM_EXT, RGB16_SNORM: E6.RGB16_SNORM_EXT, RGBA16_SNORM: E6.RGBA16_SNORM_EXT } : null;
}

// node_modules/@arcgis/core/views/webgl/capabilities/LoseContext.js
function e4(e5, t6) {
  const n7 = t6.loseContext && e5.getExtension("WEBGL_lose_context");
  return n7 ? { loseRenderingContext: () => n7.loseContext() } : null;
}

// node_modules/@arcgis/core/views/webgl/capabilities/VertexArrayObjects.js
function r8(r9, t6) {
  if (n3(r9))
    return { createVertexArray: r9.createVertexArray.bind(r9), deleteVertexArray: r9.deleteVertexArray.bind(r9), bindVertexArray: r9.bindVertexArray.bind(r9) };
  if (t6.vao)
    return null;
  const n7 = r9.getExtension("OES_vertex_array_object") || r9.getExtension("MOZ_OES_vertex_array_object") || r9.getExtension("WEBKIT_OES_vertex_array_object");
  return n7 ? { createVertexArray: n7.createVertexArrayOES.bind(n7), deleteVertexArray: n7.deleteVertexArrayOES.bind(n7), bindVertexArray: n7.bindVertexArrayOES.bind(n7) } : null;
}

// node_modules/@arcgis/core/views/webgl/capabilities/Capabilities.js
var x3 = class {
  constructor(t6, e5) {
    this._gl = t6, this._instancing = null, this._vertexArrayObject = null, this._compressedTextureETC = null, this._compressedTextureS3TC = null, this._textureFilterAnisotropic = null, this._textureFloat = null, this._colorBufferFloat = null, this._minMaxBlending = null, this._loseContext = null, this._drawBuffers = null, this._textureNorm16 = null, this._depthTexture = null, this._standardDerivatives = null, this._shaderTextureLOD = null, this._fragDepth = null, this._textureFloatLinear = null, this._disabledExtensions = e5.disabledExtensions || {}, this._debugWebGLExtensions = e5.debugWebGLExtensions || {};
  }
  get drawBuffers() {
    return this._drawBuffers || (this._drawBuffers = A3(this._gl, this._disabledExtensions)), this._drawBuffers;
  }
  get instancing() {
    return this._instancing || (this._instancing = r6(this._gl)), this._instancing;
  }
  get vao() {
    return this._vertexArrayObject || (this._vertexArrayObject = r8(this._gl, this._disabledExtensions)), this._vertexArrayObject;
  }
  get compressedTextureETC() {
    return this._compressedTextureETC || (this._compressedTextureETC = _4(this._gl, this._disabledExtensions)), this._compressedTextureETC;
  }
  get compressedTextureS3TC() {
    return this._compressedTextureS3TC || (this._compressedTextureS3TC = e3(this._gl, this._disabledExtensions)), this._compressedTextureS3TC;
  }
  get textureFilterAnisotropic() {
    return this._textureFilterAnisotropic || (this._textureFilterAnisotropic = n6(this._gl, this._disabledExtensions)), this._textureFilterAnisotropic;
  }
  get disjointTimerQuery() {
    return this._disjointTimerQuery || (this._disjointTimerQuery = T3(this._gl, this._disabledExtensions)), this._disjointTimerQuery;
  }
  get textureFloat() {
    return this._textureFloat || (this._textureFloat = R2(this._gl, this._disabledExtensions)), this._textureFloat;
  }
  get colorBufferFloat() {
    return this._colorBufferFloat || (this._colorBufferFloat = r7(this._gl, this._disabledExtensions)), this._colorBufferFloat;
  }
  get blendMinMax() {
    return this._minMaxBlending || (this._minMaxBlending = E5(this._gl, this._disabledExtensions)), this._minMaxBlending;
  }
  get depthTexture() {
    return null === this._depthTexture && (this._depthTexture = o5(this._gl, this._disabledExtensions, "depthTexture", true, ["WEBGL_depth_texture", "MOZ_WEBGL_depth_texture", "WEBKIT_WEBGL_depth_texture"])), this._depthTexture;
  }
  get standardDerivatives() {
    return null === this._standardDerivatives && (this._standardDerivatives = o5(this._gl, this._disabledExtensions, "standardDerivatives", true, ["OES_standard_derivatives"])), this._standardDerivatives;
  }
  get shaderTextureLOD() {
    return null === this._shaderTextureLOD && (this._shaderTextureLOD = o5(this._gl, this._disabledExtensions, "shaderTextureLOD", true, ["EXT_shader_texture_lod"])), this._shaderTextureLOD;
  }
  get fragDepth() {
    return null === this._fragDepth && (this._fragDepth = o5(this._gl, this._disabledExtensions, "fragDepth", true, ["EXT_frag_depth"])), this._fragDepth;
  }
  get loseContext() {
    return this._loseContext || (this._loseContext = e4(this._gl, this._debugWebGLExtensions)), this._loseContext;
  }
  get textureNorm16() {
    return this._textureNorm16 || (this._textureNorm16 = l(this._gl, this._disabledExtensions)), this._textureNorm16;
  }
  get textureFloatLinear() {
    return null === this._textureFloatLinear && (this._textureFloatLinear = o5(this._gl, this._disabledExtensions, "textureFloatLinear", false, ["OES_texture_float_linear"])), this._textureFloatLinear;
  }
  enable(t6) {
    return this[t6];
  }
};

// node_modules/@arcgis/core/views/webgl/RenderingContext.js
var y = class {
  constructor(t6, e5) {
    this.gl = t6, this.instanceCounter = new s5(), this.programCache = new s3(this), this._state = new h(), this._numOfDrawCalls = 0, this._numOfTriangles = 0, this.type = n3(t6) ? r4.WEBGL2 : r4.WEBGL1, this._loadExtensions(), this.configure(e5);
  }
  configure(t6) {
    this._capabilities = new x3(this.gl, t6), this._parameters = this._loadParameters(t6);
    const e5 = this.gl.getParameter(this.gl.VIEWPORT);
    this._state = new h(), this._state.viewport = { x: e5[0], y: e5[1], width: e5[2], height: e5[3] }, this._stateTracker = new M2({ setBlending: (t7) => {
      if (t7) {
        this.setBlendingEnabled(true), this.setBlendEquationSeparate(t7.opRgb, t7.opAlpha), this.setBlendFunctionSeparate(t7.srcRgb, t7.dstRgb, t7.srcAlpha, t7.dstAlpha);
        const e6 = t7.color;
        this.setBlendColor(e6.r, e6.g, e6.b, e6.a);
      } else
        this.setBlendingEnabled(false);
    }, setCulling: (t7) => {
      t7 ? (this.setFaceCullingEnabled(true), this.setCullFace(t7.face), this.setFrontFace(t7.mode)) : this.setFaceCullingEnabled(false);
    }, setPolygonOffset: (t7) => {
      t7 ? (this.setPolygonOffsetFillEnabled(true), this.setPolygonOffset(t7.factor, t7.units)) : this.setPolygonOffsetFillEnabled(false);
    }, setDepthTest: (t7) => {
      t7 ? (this.setDepthTestEnabled(true), this.setDepthFunction(t7.func)) : this.setDepthTestEnabled(false);
    }, setStencilTest: (t7) => {
      if (t7) {
        this.setStencilTestEnabled(true);
        const e6 = t7.function;
        this.setStencilFunction(e6.func, e6.ref, e6.mask);
        const s6 = t7.operation;
        this.setStencilOp(s6.fail, s6.zFail, s6.zPass);
      } else
        this.setStencilTestEnabled(false);
    }, setDepthWrite: (t7) => {
      t7 ? (this.setDepthWriteEnabled(true), this.setDepthRange(t7.zNear, t7.zFar)) : this.setDepthWriteEnabled(false);
    }, setColorWrite: (t7) => {
      t7 ? this.setColorMask(t7.r, t7.g, t7.b, t7.a) : this.setColorMask(false, false, false, false);
    }, setStencilWrite: (t7) => {
      t7 ? this.setStencilWriteMask(t7.mask) : this.setStencilWriteMask(0);
    } }), this.enforceState(), this._driverTest = new o4(this);
  }
  get driverTest() {
    return this._driverTest;
  }
  get contextAttributes() {
    return this.gl.getContextAttributes();
  }
  get parameters() {
    return this._parameters;
  }
  dispose() {
    this.programCache.dispose(), this.bindVAO(null), this.unbindBuffer(A.ARRAY_BUFFER), this.unbindBuffer(A.ELEMENT_ARRAY_BUFFER), n3(this.gl) && (this.unbindBuffer(A.UNIFORM_BUFFER), this._state.uniformBufferBindingPoints.length = 0, this.unbindBuffer(A.PIXEL_PACK_BUFFER), this.unbindBuffer(A.PIXEL_UNPACK_BUFFER), this.unbindBuffer(A.COPY_READ_BUFFER), this.unbindBuffer(A.COPY_WRITE_BUFFER)), this._state.textureUnitMap.length = 0, a() && this.instanceCounter.printResourceCount();
  }
  setPipelineState(t6) {
    this._stateTracker.setPipeline(t6);
  }
  setBlendingEnabled(t6) {
    this._state.blend !== t6 && (true === t6 ? this.gl.enable(this.gl.BLEND) : this.gl.disable(this.gl.BLEND), this._state.blend = t6, this._stateTracker.invalidateBlending());
  }
  externalProgramUpdate() {
    var _a;
    (_a = this._state.program) == null ? void 0 : _a.stop(), this._state.program = null;
  }
  externalTextureUnitUpdate(t6, e5) {
    for (let s6 = 0; s6 < t6.length; ++s6)
      this._state.textureUnitMap[t6[s6]] = null;
    e5 >= 0 && (this._state.activeTexture = e5);
  }
  externalVertexArrayObjectUpdate() {
    const t6 = this.capabilities.vao;
    t6 && (t6.bindVertexArray(null), this._state.vertexArrayObject = null), this._state.vertexBuffer = null, this._state.indexBuffer = null;
  }
  externalVertexBufferUpdate() {
    this._state.vertexBuffer = null;
  }
  externalIndexBufferUpdate() {
    this._state.indexBuffer = null;
  }
  setBlendColor(t6, e5, s6, i3) {
    t6 === this._state.blendColor.r && e5 === this._state.blendColor.g && s6 === this._state.blendColor.b && i3 === this._state.blendColor.a || (this.gl.blendColor(t6, e5, s6, i3), this._state.blendColor.r = t6, this._state.blendColor.g = e5, this._state.blendColor.b = s6, this._state.blendColor.a = i3, this._stateTracker.invalidateBlending());
  }
  setBlendFunction(t6, e5) {
    t6 === this._state.blendFunction.srcRGB && e5 === this._state.blendFunction.dstRGB || (this.gl.blendFunc(t6, e5), this._state.blendFunction.srcRGB = t6, this._state.blendFunction.srcAlpha = t6, this._state.blendFunction.dstRGB = e5, this._state.blendFunction.dstAlpha = e5, this._stateTracker.invalidateBlending());
  }
  setBlendFunctionSeparate(t6, e5, s6, i3) {
    this._state.blendFunction.srcRGB === t6 && this._state.blendFunction.srcAlpha === s6 && this._state.blendFunction.dstRGB === e5 && this._state.blendFunction.dstAlpha === i3 || (this.gl.blendFuncSeparate(t6, e5, s6, i3), this._state.blendFunction.srcRGB = t6, this._state.blendFunction.srcAlpha = s6, this._state.blendFunction.dstRGB = e5, this._state.blendFunction.dstAlpha = i3, this._stateTracker.invalidateBlending());
  }
  setBlendEquation(t6) {
    this._state.blendEquation.mode !== t6 && (this.gl.blendEquation(t6), this._state.blendEquation.mode = t6, this._state.blendEquation.modeAlpha = t6, this._stateTracker.invalidateBlending());
  }
  setBlendEquationSeparate(t6, e5) {
    this._state.blendEquation.mode === t6 && this._state.blendEquation.modeAlpha === e5 || (this.gl.blendEquationSeparate(t6, e5), this._state.blendEquation.mode = t6, this._state.blendEquation.modeAlpha = e5, this._stateTracker.invalidateBlending());
  }
  setColorMask(t6, e5, s6, i3) {
    this._state.colorMask.r === t6 && this._state.colorMask.g === e5 && this._state.colorMask.b === s6 && this._state.colorMask.a === i3 || (this.gl.colorMask(t6, e5, s6, i3), this._state.colorMask.r = t6, this._state.colorMask.g = e5, this._state.colorMask.b = s6, this._state.colorMask.a = i3, this._stateTracker.invalidateColorWrite());
  }
  setClearColor(t6, e5, s6, i3) {
    this._state.clearColor.r === t6 && this._state.clearColor.g === e5 && this._state.clearColor.b === s6 && this._state.clearColor.a === i3 || (this.gl.clearColor(t6, e5, s6, i3), this._state.clearColor.r = t6, this._state.clearColor.g = e5, this._state.clearColor.b = s6, this._state.clearColor.a = i3);
  }
  setFaceCullingEnabled(t6) {
    this._state.faceCulling !== t6 && (true === t6 ? this.gl.enable(this.gl.CULL_FACE) : this.gl.disable(this.gl.CULL_FACE), this._state.faceCulling = t6, this._stateTracker.invalidateCulling());
  }
  setPolygonOffsetFillEnabled(t6) {
    this._state.polygonOffsetFill !== t6 && (true === t6 ? this.gl.enable(this.gl.POLYGON_OFFSET_FILL) : this.gl.disable(this.gl.POLYGON_OFFSET_FILL), this._state.polygonOffsetFill = t6, this._stateTracker.invalidatePolygonOffset());
  }
  setPolygonOffset(t6, e5) {
    this._state.polygonOffset[0] === t6 && this._state.polygonOffset[1] === e5 || (this._state.polygonOffset[0] = t6, this._state.polygonOffset[1] = e5, this.gl.polygonOffset(t6, e5), this._stateTracker.invalidatePolygonOffset());
  }
  setCullFace(t6) {
    this._state.cullFace !== t6 && (this.gl.cullFace(t6), this._state.cullFace = t6, this._stateTracker.invalidateCulling());
  }
  setFrontFace(t6) {
    this._state.frontFace !== t6 && (this.gl.frontFace(t6), this._state.frontFace = t6, this._stateTracker.invalidateCulling());
  }
  setScissorTestEnabled(t6) {
    this._state.scissorTest !== t6 && (true === t6 ? this.gl.enable(this.gl.SCISSOR_TEST) : this.gl.disable(this.gl.SCISSOR_TEST), this._state.scissorTest = t6);
  }
  setScissorRect(t6, e5, s6, i3) {
    this._state.scissorRect.x === t6 && this._state.scissorRect.y === e5 && this._state.scissorRect.width === s6 && this._state.scissorRect.height === i3 || (this.gl.scissor(t6, e5, s6, i3), this._state.scissorRect.x = t6, this._state.scissorRect.y = e5, this._state.scissorRect.width = s6, this._state.scissorRect.height = i3);
  }
  setDepthTestEnabled(t6) {
    this._state.depthTest !== t6 && (true === t6 ? this.gl.enable(this.gl.DEPTH_TEST) : this.gl.disable(this.gl.DEPTH_TEST), this._state.depthTest = t6, this._stateTracker.invalidateDepthTest());
  }
  setClearDepth(t6) {
    this._state.clearDepth !== t6 && (this.gl.clearDepth(t6), this._state.clearDepth = t6);
  }
  setDepthFunction(t6) {
    this._state.depthFunction !== t6 && (this.gl.depthFunc(t6), this._state.depthFunction = t6, this._stateTracker.invalidateDepthTest());
  }
  setDepthWriteEnabled(t6) {
    this._state.depthWrite !== t6 && (this.gl.depthMask(t6), this._state.depthWrite = t6, this._stateTracker.invalidateDepthWrite());
  }
  setDepthRange(t6, e5) {
    this._state.depthRange.zNear === t6 && this._state.depthRange.zFar === e5 || (this.gl.depthRange(t6, e5), this._state.depthRange.zNear = t6, this._state.depthRange.zFar = e5, this._stateTracker.invalidateDepthWrite());
  }
  setStencilTestEnabled(t6) {
    this._state.stencilTest !== t6 && (true === t6 ? this.gl.enable(this.gl.STENCIL_TEST) : this.gl.disable(this.gl.STENCIL_TEST), this._state.stencilTest = t6, this._stateTracker.invalidateStencilTest());
  }
  setClearStencil(t6) {
    t6 !== this._state.clearStencil && (this.gl.clearStencil(t6), this._state.clearStencil = t6);
  }
  setStencilFunction(t6, e5, s6) {
    this._state.stencilFunction.func === t6 && this._state.stencilFunction.ref === e5 && this._state.stencilFunction.mask === s6 || (this.gl.stencilFunc(t6, e5, s6), this._state.stencilFunction.face = N.FRONT_AND_BACK, this._state.stencilFunction.func = t6, this._state.stencilFunction.ref = e5, this._state.stencilFunction.mask = s6, this._stateTracker.invalidateStencilTest());
  }
  setStencilFunctionSeparate(t6, e5, s6, i3) {
    this._state.stencilFunction.face === t6 && this._state.stencilFunction.func === e5 && this._state.stencilFunction.ref === s6 && this._state.stencilFunction.mask === i3 || (this.gl.stencilFuncSeparate(t6, e5, s6, i3), this._state.stencilFunction.face = t6, this._state.stencilFunction.func = e5, this._state.stencilFunction.ref = s6, this._state.stencilFunction.mask = i3, this._stateTracker.invalidateStencilTest());
  }
  setStencilWriteMask(t6) {
    this._state.stencilWriteMask !== t6 && (this.gl.stencilMask(t6), this._state.stencilWriteMask = t6, this._stateTracker.invalidateStencilWrite());
  }
  setStencilOp(t6, e5, s6) {
    this._state.stencilOperation.face === N.FRONT_AND_BACK && this._state.stencilOperation.fail === t6 && this._state.stencilOperation.zFail === e5 && this._state.stencilOperation.zPass === s6 || (this.gl.stencilOp(t6, e5, s6), this._state.stencilOperation.face = N.FRONT_AND_BACK, this._state.stencilOperation.fail = t6, this._state.stencilOperation.zFail = e5, this._state.stencilOperation.zPass = s6, this._stateTracker.invalidateStencilTest());
  }
  setStencilOpSeparate(t6, e5, s6, i3) {
    this._state.stencilOperation.face === t6 && this._state.stencilOperation.fail === e5 && this._state.stencilOperation.zFail === s6 && this._state.stencilOperation.zPass === i3 || (this.gl.stencilOpSeparate(t6, e5, s6, i3), this._state.stencilOperation.face = t6, this._state.stencilOperation.fail = e5, this._state.stencilOperation.zFail = s6, this._state.stencilOperation.zPass = i3, this._stateTracker.invalidateStencilTest());
  }
  setActiveTexture(t6, e5 = false) {
    const s6 = this._state.activeTexture;
    return t6 >= 0 && (e5 || t6 !== this._state.activeTexture) && (this.gl.activeTexture(X + t6), this._state.activeTexture = t6), s6;
  }
  clear(t6) {
    t6 && this.gl.clear(t6);
  }
  clearSafe(t6, e5 = 255) {
    t6 && (t6 & _.COLOR_BUFFER_BIT && this.setColorMask(true, true, true, true), t6 & _.DEPTH_BUFFER_BIT && this.setDepthWriteEnabled(true), t6 & _.STENCIL_BUFFER_BIT && this.setStencilWriteMask(e5), this.gl.clear(t6));
  }
  drawArrays(t6, e5, s6) {
    if (a() && (this._numOfDrawCalls++, this._numOfTriangles += v(t6, s6)), this.gl.drawArrays(t6, e5, s6), a()) {
      const t7 = i2(this);
      t7 && console.error("drawArrays:", t7);
    }
  }
  drawElements(e5, s6, i3, a3) {
    var _a;
    if (a() && (this._numOfDrawCalls++, this._numOfTriangles += v(e5, s6)), this.gl.drawElements(e5, s6, i3, a3), a()) {
      const r9 = i2(this);
      if (r9) {
        const n7 = this.getBoundVAO(), l2 = n7 == null ? void 0 : n7.indexBuffer, h2 = n7 == null ? void 0 : n7.vertexBuffers, f3 = { indexBuffer: l2, vertexBuffers: h2 }, o6 = { mode: e5, count: s6, type: i3, offset: a3 }, _5 = (_a = o(l2, (t6) => t6.size)) != null ? _a : 0, u = a3 + s6, c = _5 < u ? `. Buffer is too small. Attempted to draw index ${u} of ${_5}` : "";
        console.error(`drawElements: ${r9}${c}`, { args: o6, vao: f3 });
      }
    }
  }
  logInfo() {
    a() && console.log(`DrawCalls: ${this._numOfDrawCalls}, Triangles: ${this._numOfTriangles}`);
  }
  resetInfo() {
    a() && (this._numOfDrawCalls = 0, this._numOfTriangles = 0);
  }
  get capabilities() {
    return this._capabilities;
  }
  setViewport(t6, e5, s6, i3) {
    s6 = Math.max(Math.round(s6), 1), i3 = Math.max(Math.round(i3), 1);
    const a3 = this._state.viewport;
    a3.x === t6 && a3.y === e5 && a3.width === s6 && a3.height === i3 || (a3.x = t6, a3.y = e5, a3.width = s6, a3.height = i3, this.gl.viewport(t6, e5, s6, i3));
  }
  getViewport() {
    const t6 = this._state.viewport;
    return { x: t6.x, y: t6.y, width: t6.width, height: t6.height };
  }
  useProgram(t6) {
    var _a, _b;
    this._state.program !== t6 && ((_a = this._state.program) == null ? void 0 : _a.stop(), this._state.program = t6, this.gl.useProgram((_b = t6 == null ? void 0 : t6.glName) != null ? _b : null));
  }
  bindTexture(t6, i3, a3 = false) {
    (i3 >= this.parameters.maxTextureImageUnits || i3 < 0) && console.error("Input texture unit is out of range of available units!");
    const r9 = this._state.textureUnitMap[i3];
    return t(t6) || null == t6.glName ? (r(r9) && (this.setActiveTexture(i3, a3), this.gl.bindTexture(r9.descriptor.target, null)), this._state.textureUnitMap[i3] = null, r9) : a3 || r9 !== t6 ? (this.setActiveTexture(i3, a3), this.gl.bindTexture(t6.descriptor.target, t6.glName), t6.applyChanges(), this._state.textureUnitMap[i3] = t6, r9) : (t6.isDirty && (this.setActiveTexture(i3, a3), t6.applyChanges()), r9);
  }
  unbindTexture(t6) {
    if (!t(t6))
      for (let e5 = 0; e5 < this.parameters.maxTextureImageUnits; e5++)
        this._state.textureUnitMap[e5] === t6 && (this.bindTexture(null, e5), this._state.textureUnitMap[e5] = null);
  }
  bindFramebuffer(t6, s6 = false) {
    if (s6 || this._state.readFramebuffer !== t6 || this._state.drawFramebuffer !== t6) {
      if (t(t6))
        return this.gl.bindFramebuffer(n2.FRAMEBUFFER, null), this._state.readFramebuffer = null, void (this._state.drawFramebuffer = null);
      t6.initializeAndBind(n2.FRAMEBUFFER), this._state.readFramebuffer = t6, this._state.drawFramebuffer = t6;
    }
  }
  bindFramebufferSeparate(t6, s6, a3 = false) {
    const r9 = s6 === n2.READ_FRAMEBUFFER, n7 = r9 ? this._state.readFramebuffer : this._state.drawFramebuffer;
    (a3 || n7 !== t6) && (t(t6) ? this.gl.bindFramebuffer(s6, null) : t6.initializeAndBind(s6), r9 ? this._state.readFramebuffer = i(t6, null) : this._state.drawFramebuffer = i(t6, null));
  }
  blitFramebuffer(t6, e5, s6 = 0, i3 = 0, a3 = t6.width, r9 = t6.height, n7 = 0, l2 = 0, h2 = e5.width, f3 = e5.height, o6 = _.COLOR_BUFFER_BIT, _5 = L.NEAREST) {
    this.bindFramebufferSeparate(t6, n2.READ_FRAMEBUFFER), this.bindFramebufferSeparate(e5, n2.DRAW_FRAMEBUFFER);
    this.gl.blitFramebuffer(s6, i3, a3, r9, n7, l2, h2, f3, o6, _5);
  }
  bindBuffer(t6, e5) {
    if (t6)
      switch (e5 != null ? e5 : e5 = t6.bufferType, e5) {
        case A.ARRAY_BUFFER:
          this._state.vertexBuffer = I2(this.gl, t6, e5, this._state.vertexBuffer);
          break;
        case A.ELEMENT_ARRAY_BUFFER:
          this._state.indexBuffer = I2(this.gl, t6, e5, this._state.indexBuffer);
          break;
        case A.UNIFORM_BUFFER:
          this._state.uniformBuffer = I2(this.gl, t6, e5, this._state.uniformBuffer);
          break;
        case A.PIXEL_PACK_BUFFER:
          this._state.pixelPackBuffer = I2(this.gl, t6, e5, this._state.pixelPackBuffer);
          break;
        case A.PIXEL_UNPACK_BUFFER:
          this._state.pixelUnpackBuffer = I2(this.gl, t6, e5, this._state.pixelUnpackBuffer);
          break;
        case A.COPY_READ_BUFFER:
          this._state.copyReadBuffer = I2(this.gl, t6, e5, this._state.copyReadBuffer);
          break;
        case A.COPY_WRITE_BUFFER:
          this._state.copyWriteBuffer = I2(this.gl, t6, e5, this._state.copyWriteBuffer);
      }
  }
  bindRenderbuffer(t6) {
    const e5 = this.gl;
    t6 || (e5.bindRenderbuffer(e5.RENDERBUFFER, null), this._state.renderbuffer = null), this._state.renderbuffer !== t6 && (e5.bindRenderbuffer(e5.RENDERBUFFER, t6.glName), this._state.renderbuffer = t6);
  }
  _getBufferBinding(t6, s6) {
    if (s6 >= this.parameters.maxUniformBufferBindings || s6 < 0)
      return console.error("Uniform buffer binding point is out of range!"), null;
    const i3 = this._state.uniformBufferBindingPoints;
    let a3 = i3[s6];
    return t(a3) && (a3 = { buffer: null, offset: 0, size: 0 }, i3[s6] = a3), a3;
  }
  bindBufferBase(t6, s6, i3) {
    const a3 = this._getBufferBinding(t6, s6);
    if (t(a3))
      return;
    if (a3.buffer === i3 && 0 === a3.offset && 0 === a3.size)
      return;
    this.gl.bindBufferBase(t6, s6, i3 ? i3.glName : null), a3.buffer = i3, a3.offset = 0, a3.size = 0;
  }
  bindBufferRange(t6, s6, i3, a3, r9) {
    const n7 = this._getBufferBinding(t6, s6);
    if (t(n7))
      return;
    if (n7.buffer === i3 && n7.offset === a3 && n7.size === r9)
      return;
    if (a3 % this._parameters.uniformBufferOffsetAlignment != 0)
      return void console.error("Uniform buffer binding offset is not a multiple of the context offset alignment");
    this.gl.bindBufferRange(t6, s6, i3.glName, a3, r9), n7.buffer = i3, n7.offset = a3, n7.size = r9;
  }
  bindUBO(t6, s6, i3, a3) {
    t(s6) ? this.bindBufferBase(A.UNIFORM_BUFFER, t6, null) : (a() && (a3 != null ? a3 : s6.byteLength) > this._parameters.maxUniformBlockSize && console.error("Attempting to bind more data than the maximum uniform block size"), s6.initialize(), void 0 !== i3 && void 0 !== a3 ? this.bindBufferRange(A.UNIFORM_BUFFER, t6, s6.buffer, i3, a3) : this.bindBufferBase(A.UNIFORM_BUFFER, t6, s6.buffer));
  }
  unbindUBO(t6) {
    for (let e5 = 0, i3 = this._state.uniformBufferBindingPoints.length; e5 < i3; e5++) {
      const i4 = this._state.uniformBufferBindingPoints[e5];
      r(i4) && i4.buffer === t6.buffer && this.bindBufferBase(A.UNIFORM_BUFFER, e5, null);
    }
  }
  unbindBuffer(t6) {
    switch (t6) {
      case A.ARRAY_BUFFER:
        this._state.vertexBuffer = I2(this.gl, null, t6, this._state.vertexBuffer);
        break;
      case A.ELEMENT_ARRAY_BUFFER:
        this._state.indexBuffer = I2(this.gl, null, t6, this._state.indexBuffer);
        break;
      case A.UNIFORM_BUFFER:
        this._state.uniformBuffer = I2(this.gl, null, t6, this._state.uniformBuffer);
        break;
      case A.PIXEL_PACK_BUFFER:
        this._state.pixelPackBuffer = I2(this.gl, null, t6, this._state.pixelPackBuffer);
        break;
      case A.PIXEL_UNPACK_BUFFER:
        this._state.pixelUnpackBuffer = I2(this.gl, null, t6, this._state.pixelUnpackBuffer);
        break;
      case A.COPY_READ_BUFFER:
        this._state.copyReadBuffer = I2(this.gl, null, t6, this._state.copyReadBuffer);
        break;
      case A.COPY_WRITE_BUFFER:
        this._state.copyWriteBuffer = I2(this.gl, null, t6, this._state.copyWriteBuffer);
    }
  }
  bindVAO(t6 = null) {
    t(t6) ? this._state.vertexArrayObject && (this._state.vertexArrayObject.unbind(), this._state.vertexArrayObject = null) : this._state.vertexArrayObject !== t6 && (t6.bind(), this._state.vertexArrayObject = t6);
  }
  async clientWaitAsync(t6 = n(10)) {
    const e5 = this.gl, s6 = e5.fenceSync(W.SYNC_GPU_COMMANDS_COMPLETE, 0);
    if (!s6)
      throw new Error("Client wait failed, could not create sync object");
    let i3;
    this.instanceCounter.increment(t2.Sync, s6), e5.flush();
    do {
      await U(t6), i3 = e5.clientWaitSync(s6, 0, 0);
    } while (i3 === r3.TIMEOUT_EXPIRED);
    if (this.instanceCounter.decrement(t2.Sync, s6), e5.deleteSync(s6), i3 === r3.WAIT_FAILED)
      throw new Error("Client wait failed");
  }
  getBoundFramebufferObject(t6 = n2.FRAMEBUFFER) {
    return t6 === n2.READ_FRAMEBUFFER ? this._state.readFramebuffer : this._state.drawFramebuffer;
  }
  getBoundVAO() {
    return this._state.vertexArrayObject;
  }
  resetState() {
    this.useProgram(null), this.bindVAO(null), this.bindFramebuffer(null, true), this.unbindBuffer(A.ARRAY_BUFFER), this.unbindBuffer(A.ELEMENT_ARRAY_BUFFER), n3(this.gl) && (this.unbindBuffer(A.UNIFORM_BUFFER), this._state.uniformBufferBindingPoints.length = 0, this.unbindBuffer(A.PIXEL_PACK_BUFFER), this.unbindBuffer(A.PIXEL_UNPACK_BUFFER), this.unbindBuffer(A.COPY_READ_BUFFER), this.unbindBuffer(A.COPY_WRITE_BUFFER));
    for (let t6 = 0; t6 < this.parameters.maxTextureImageUnits; ++t6)
      this.bindTexture(null, t6);
    this.setBlendingEnabled(false), this.setBlendFunction(R.ONE, R.ZERO), this.setBlendEquation(T.ADD), this.setBlendColor(0, 0, 0, 0), this.setFaceCullingEnabled(false), this.setCullFace(N.BACK), this.setFrontFace(S.CCW), this.setPolygonOffsetFillEnabled(false), this.setPolygonOffset(0, 0), this.setScissorTestEnabled(false), this.setScissorRect(0, 0, this.gl.canvas.width, this.gl.canvas.height), this.setDepthTestEnabled(false), this.setDepthFunction(I.LESS), this.setDepthRange(0, 1), this.setStencilTestEnabled(false), this.setStencilFunction(I.ALWAYS, 0, 0), this.setStencilOp(O.KEEP, O.KEEP, O.KEEP), this.setClearColor(0, 0, 0, 0), this.setClearDepth(1), this.setClearStencil(0), this.setColorMask(true, true, true, true), this.setStencilWriteMask(4294967295), this.setDepthWriteEnabled(true), this.setViewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
  }
  enforceState() {
    var _a, _b, _c, _d, _e, _f;
    const t6 = this.gl, e5 = this.capabilities.vao;
    e5 && e5.bindVertexArray(null);
    for (let s6 = 0; s6 < this.parameters.maxVertexAttributes; s6++)
      t6.disableVertexAttribArray(s6);
    if (this._state.vertexBuffer ? t6.bindBuffer(this._state.vertexBuffer.bufferType, this._state.vertexBuffer.glName) : t6.bindBuffer(A.ARRAY_BUFFER, null), this._state.indexBuffer ? t6.bindBuffer(this._state.indexBuffer.bufferType, this._state.indexBuffer.glName) : t6.bindBuffer(A.ELEMENT_ARRAY_BUFFER, null), n3(t6)) {
      this._state.uniformBuffer ? t6.bindBuffer(this._state.uniformBuffer.bufferType, this._state.uniformBuffer.glName) : t6.bindBuffer(A.UNIFORM_BUFFER, null);
      for (let e6 = 0; e6 < this._parameters.maxUniformBufferBindings; e6++) {
        const i4 = this._state.uniformBufferBindingPoints[e6];
        if (r(i4)) {
          const { buffer: s6, offset: a3, size: r9 } = i4;
          null !== s6 ? 0 === a3 && 0 === r9 ? t6.bindBufferBase(A.UNIFORM_BUFFER, e6, s6.glName) : t6.bindBufferRange(A.UNIFORM_BUFFER, e6, s6.glName, a3, r9) : t6.bindBufferBase(A.UNIFORM_BUFFER, e6, null);
        }
      }
      this._state.pixelPackBuffer ? t6.bindBuffer(this._state.pixelPackBuffer.bufferType, this._state.pixelPackBuffer.glName) : t6.bindBuffer(A.PIXEL_PACK_BUFFER, null), this._state.pixelUnpackBuffer ? t6.bindBuffer(this._state.pixelUnpackBuffer.bufferType, this._state.pixelUnpackBuffer.glName) : t6.bindBuffer(A.PIXEL_UNPACK_BUFFER, null), this._state.copyReadBuffer ? t6.bindBuffer(this._state.copyReadBuffer.bufferType, this._state.copyReadBuffer.glName) : t6.bindBuffer(A.COPY_READ_BUFFER, null), this._state.copyWriteBuffer ? t6.bindBuffer(this._state.copyWriteBuffer.bufferType, this._state.copyWriteBuffer.glName) : t6.bindBuffer(A.COPY_WRITE_BUFFER, null), t6.bindFramebuffer(n2.READ_FRAMEBUFFER, null), t6.readBuffer(t6.BACK), this._state.readFramebuffer && (t6.bindFramebuffer(n2.READ_FRAMEBUFFER, this._state.readFramebuffer.glName), t6.readBuffer(f.COLOR_ATTACHMENT0)), t6.bindFramebuffer(n2.DRAW_FRAMEBUFFER, (_b = (_a = this._state.drawFramebuffer) == null ? void 0 : _a.glName) != null ? _b : null);
    } else
      this._state.readFramebuffer = this._state.drawFramebuffer, t6.bindFramebuffer(n2.FRAMEBUFFER, (_d = (_c = this._state.drawFramebuffer) == null ? void 0 : _c.glName) != null ? _d : null);
    if (e5 && this._state.vertexArrayObject) {
      const t7 = this._state.vertexArrayObject;
      this._state.vertexArrayObject && (this._state.vertexArrayObject.unbind(), this._state.vertexArrayObject = null), this.bindVAO(t7);
    }
    t6.useProgram((_f = (_e = this._state.program) == null ? void 0 : _e.glName) != null ? _f : null), t6.blendColor(this._state.blendColor.r, this._state.blendColor.g, this._state.blendColor.b, this._state.blendColor.a), t6.bindRenderbuffer(t6.RENDERBUFFER, this._state.renderbuffer ? this._state.renderbuffer.glName : null), true === this._state.blend ? t6.enable(this.gl.BLEND) : t6.disable(this.gl.BLEND), t6.blendEquationSeparate(this._state.blendEquation.mode, this._state.blendEquation.modeAlpha), t6.blendFuncSeparate(this._state.blendFunction.srcRGB, this._state.blendFunction.dstRGB, this._state.blendFunction.srcAlpha, this._state.blendFunction.dstAlpha), t6.clearColor(this._state.clearColor.r, this._state.clearColor.g, this._state.clearColor.b, this._state.clearColor.a), t6.clearDepth(this._state.clearDepth), t6.clearStencil(this._state.clearStencil), t6.colorMask(this._state.colorMask.r, this._state.colorMask.g, this._state.colorMask.b, this._state.colorMask.a), t6.cullFace(this._state.cullFace), t6.depthFunc(this._state.depthFunction), t6.depthRange(this._state.depthRange.zNear, this._state.depthRange.zFar), true === this._state.depthTest ? t6.enable(t6.DEPTH_TEST) : t6.disable(t6.DEPTH_TEST), t6.depthMask(this._state.depthWrite), t6.frontFace(this._state.frontFace), t6.lineWidth(1), true === this._state.faceCulling ? t6.enable(t6.CULL_FACE) : t6.disable(t6.CULL_FACE), t6.polygonOffset(this._state.polygonOffset[0], this._state.polygonOffset[1]), true === this._state.polygonOffsetFill ? t6.enable(t6.POLYGON_OFFSET_FILL) : t6.disable(t6.POLYGON_OFFSET_FILL), t6.scissor(this._state.scissorRect.x, this._state.scissorRect.y, this._state.scissorRect.width, this._state.scissorRect.height), true === this._state.scissorTest ? t6.enable(t6.SCISSOR_TEST) : t6.disable(t6.SCISSOR_TEST), t6.stencilFunc(this._state.stencilFunction.func, this._state.stencilFunction.ref, this._state.stencilFunction.mask), t6.stencilOpSeparate(this._state.stencilOperation.face, this._state.stencilOperation.fail, this._state.stencilOperation.zFail, this._state.stencilOperation.zPass), true === this._state.stencilTest ? t6.enable(t6.STENCIL_TEST) : t6.disable(t6.STENCIL_TEST), t6.stencilMask(this._state.stencilWriteMask);
    for (let a3 = 0; a3 < this.parameters.maxTextureImageUnits; a3++) {
      t6.activeTexture(X + a3), t6.bindTexture(M.TEXTURE_2D, null), t6.bindTexture(M.TEXTURE_CUBE_MAP, null), n3(t6) && (t6.bindTexture(M.TEXTURE_3D, null), t6.bindTexture(M.TEXTURE_2D_ARRAY, null));
      const e6 = this._state.textureUnitMap[a3];
      r(e6) && t6.bindTexture(e6.descriptor.target, e6.glName);
    }
    t6.activeTexture(X + this._state.activeTexture);
    const i3 = this._state.viewport;
    t6.viewport(i3.x, i3.y, i3.width, i3.height), this.resetInfo();
  }
  _loadExtensions() {
    this.type === r4.WEBGL1 && this.gl.getExtension("OES_element_index_uint"), this.gl.getExtension("KHR_parallel_shader_compile");
  }
  _loadParameters(t6) {
    var _a;
    const e5 = this.capabilities.textureFilterAnisotropic, s6 = (_a = t6.maxAnisotropy) != null ? _a : 1 / 0, i3 = n3(this.gl), a3 = this.gl, r9 = { versionString: this.gl.getParameter(this.gl.VERSION), maxVertexTextureImageUnits: this.gl.getParameter(this.gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS), maxVertexAttributes: this.gl.getParameter(this.gl.MAX_VERTEX_ATTRIBS), maxMaxAnisotropy: e5 ? Math.min(this.gl.getParameter(e5.MAX_TEXTURE_MAX_ANISOTROPY), s6) : 1, maxTextureImageUnits: this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS), maxTextureSize: this.gl.getParameter(this.gl.MAX_TEXTURE_SIZE), maxUniformBufferBindings: i3 ? a3.getParameter(a3.MAX_UNIFORM_BUFFER_BINDINGS) : 0, maxVertexUniformBlocks: i3 ? a3.getParameter(a3.MAX_VERTEX_UNIFORM_BLOCKS) : 0, maxFragmentUniformBlocks: i3 ? a3.getParameter(a3.MAX_FRAGMENT_UNIFORM_BLOCKS) : 0, maxUniformBlockSize: i3 ? a3.getParameter(a3.MAX_UNIFORM_BLOCK_SIZE) : 0, uniformBufferOffsetAlignment: i3 ? a3.getParameter(a3.UNIFORM_BUFFER_OFFSET_ALIGNMENT) : 1, maxArrayTextureLayers: i3 ? a3.getParameter(a3.MAX_ARRAY_TEXTURE_LAYERS) : 1, maxSamples: i3 ? a3.getParameter(a3.MAX_SAMPLES) : 1 };
    return E2.TEXTURE_UNIT_FOR_UPDATES = r9.maxTextureImageUnits - 1, r9;
  }
};
function I2(t6, e5, s6, i3) {
  return e5 ? i3 !== e5 && t6.bindBuffer(s6, e5.glName) : t6.bindBuffer(s6, null), e5;
}
function v(t6, e5) {
  switch (t6) {
    case E.POINTS:
      return 2 * e5;
    case E.TRIANGLES:
      return e5 / 3;
    case E.TRIANGLE_STRIP:
    case E.TRIANGLE_FAN:
      return e5 - 2;
    default:
      return 0;
  }
}

export {
  o2 as o,
  T3 as T,
  y
};
//# sourceMappingURL=chunk-D7GFA2UU.js.map
