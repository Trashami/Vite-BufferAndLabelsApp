import {
  h
} from "./chunk-JLDKIFMH.js";
import {
  s as s2
} from "./chunk-PY3FVAQV.js";
import "./chunk-7F2ZL2BI.js";
import "./chunk-OJ2HHY2O.js";
import "./chunk-OOOPZLJE.js";
import "./chunk-U2WD23Z5.js";
import {
  v as v2
} from "./chunk-YTOF4Z6B.js";
import {
  p
} from "./chunk-HAVCYBU2.js";
import {
  v
} from "./chunk-G3HEFWHV.js";
import {
  c
} from "./chunk-FX6IXM55.js";
import {
  O
} from "./chunk-QFFP6A5Q.js";
import "./chunk-J5VTDQTQ.js";
import {
  f as f2
} from "./chunk-YGVY4EIZ.js";
import "./chunk-E52E6T7N.js";
import "./chunk-N43PI2UO.js";
import "./chunk-HUQX7WZO.js";
import "./chunk-BYSA56OH.js";
import "./chunk-US2IWMHE.js";
import "./chunk-ZL4T4NIV.js";
import "./chunk-NAKEKTIK.js";
import "./chunk-QWNKYSI4.js";
import "./chunk-FMJZBZWF.js";
import "./chunk-GOYVJTGW.js";
import "./chunk-ZPYDYUP5.js";
import {
  b
} from "./chunk-SOEQPPQP.js";
import "./chunk-YM6PUX7G.js";
import "./chunk-QEYOWTXD.js";
import "./chunk-KDO6J2FO.js";
import "./chunk-WJCI2CGX.js";
import "./chunk-REIQNAQW.js";
import "./chunk-BLJKKR5D.js";
import "./chunk-X2S4RQJ4.js";
import "./chunk-376OPXM4.js";
import "./chunk-DER356EU.js";
import "./chunk-6M2AHKYV.js";
import "./chunk-SZIJNKCV.js";
import "./chunk-6O43OEU5.js";
import "./chunk-J2K7ZDSV.js";
import "./chunk-2UML3WQZ.js";
import "./chunk-23Y3DIC6.js";
import "./chunk-C5H57NTD.js";
import "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import "./chunk-YWAQYJRC.js";
import "./chunk-B356PXLT.js";
import "./chunk-EHPBHJYZ.js";
import "./chunk-3MNMDUQZ.js";
import "./chunk-UWG37XSU.js";
import "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import "./chunk-HLM6QCL2.js";
import {
  o
} from "./chunk-RXYULINL.js";
import "./chunk-5NXILPDI.js";
import "./chunk-THVR7IAM.js";
import "./chunk-ZWJJTUFL.js";
import "./chunk-XQN7F674.js";
import {
  U
} from "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import {
  I
} from "./chunk-KAN4HXCG.js";
import "./chunk-4FEGON7M.js";
import "./chunk-VWYWOOPX.js";
import "./chunk-M5VHU5LK.js";
import "./chunk-7QMMKGW4.js";
import {
  e as e2,
  n2 as n,
  y
} from "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import {
  f,
  w as w2
} from "./chunk-MJXQTGI2.js";
import {
  s
} from "./chunk-LIZHLHNA.js";
import "./chunk-BTUHYGXO.js";
import "./chunk-UA3YPL2R.js";
import "./chunk-HVKDYDPP.js";
import "./chunk-6QC7MLLS.js";
import {
  e,
  r,
  w
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/layers/support/LercDecoder.js
var s3 = class extends h {
  constructor(e3 = null) {
    super("LercWorker", "_decode", { _decode: (e4) => [e4.buffer] }, e3, { strategy: "dedicated" }), this.schedule = e3, this.ref = 0;
  }
  decode(e3, r2, t) {
    return e3 && 0 !== e3.byteLength ? this.invoke({ buffer: e3, options: r2 }, t) : Promise.resolve(null);
  }
  release() {
    --this.ref <= 0 && (o2.forEach((e3, r2) => {
      e3 === this && o2.delete(r2);
    }), this.destroy());
  }
};
var o2 = /* @__PURE__ */ new Map();
function n2(t = null) {
  let n3 = o2.get(e(t));
  return n3 || (r(t) ? (n3 = new s3((e3) => t.schedule(e3)), o2.set(t, n3)) : (n3 = new s3(), o2.set(null, n3))), ++n3.ref, n3;
}

// node_modules/@arcgis/core/layers/ElevationLayer.js
var j = class extends s2(p(c(v(O(b))))) {
  constructor(...e3) {
    super(...e3), this.copyright = null, this.heightModelInfo = null, this.path = null, this.minScale = void 0, this.maxScale = void 0, this.opacity = 1, this.operationalLayerType = "ArcGISTiledElevationServiceLayer", this.sourceJSON = null, this.type = "elevation", this.url = null, this.version = null, this._lercDecoder = n2();
  }
  normalizeCtorArgs(e3, r2) {
    return "string" == typeof e3 ? { url: e3, ...r2 } : e3;
  }
  destroy() {
    this._lercDecoder = w(this._lercDecoder);
  }
  readVersion(e3, r2) {
    let t = r2.currentVersion;
    return t || (t = 9.3), t;
  }
  load(e3) {
    const r2 = r(e3) ? e3.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Image Service"], supportsData: false, validateItem: (e4) => {
      for (let r3 = 0; r3 < e4.typeKeywords.length; r3++)
        if ("elevation 3d layer" === e4.typeKeywords[r3].toLowerCase())
          return true;
      throw new s("portal:invalid-layer-item-type", "Invalid layer item type '${type}', expected '${expectedType}' ", { type: "Image Service", expectedType: "Image Service Elevation 3D Layer" });
    } }, e3).catch(w2).then(() => this._fetchImageService(r2))), Promise.resolve(this);
  }
  fetchTile(e3, t, o3, s4) {
    const a = r((s4 = s4 || { signal: null }).signal) ? s4.signal : s4.signal = new AbortController().signal, l = { responseType: "array-buffer", signal: a }, p2 = { noDataValue: s4.noDataValue, returnFileInfo: true };
    return this.load().then(() => this._fetchTileAvailability(e3, t, o3, s4)).then(() => U(this.getTileUrl(e3, t, o3), l)).then((e4) => this._lercDecoder.decode(e4.data, p2, a)).then((e4) => {
      var _a;
      return { values: e4.pixelData, width: e4.width, height: e4.height, maxZError: (_a = e4.fileInfo) == null ? void 0 : _a.maxZError, noDataValue: e4.noDataValue, minValue: e4.minValue, maxValue: e4.maxValue };
    });
  }
  getTileUrl(e3, r2, t) {
    const o3 = !this.tilemapCache && this.supportsBlankTile, i = I({ ...this.parsedUrl.query, blankTile: !o3 && null });
    return `${this.parsedUrl.path}/tile/${e3}/${r2}/${t}${i ? "?" + i : ""}`;
  }
  async queryElevation(e3, r2) {
    const { ElevationQuery: t } = await import("./ElevationQuery-47X73CC6.js");
    f(r2);
    return new t().query(this, e3, r2);
  }
  async createElevationSampler(e3, r2) {
    const { ElevationQuery: t } = await import("./ElevationQuery-47X73CC6.js");
    f(r2);
    return new t().createSampler(this, e3, r2);
  }
  _fetchTileAvailability(e3, r2, t, o3) {
    return this.tilemapCache ? this.tilemapCache.fetchAvailability(e3, r2, t, o3) : Promise.resolve("unknown");
  }
  async _fetchImageService(e3) {
    var _a;
    if (this.sourceJSON)
      return this.sourceJSON;
    const t = { query: { f: "json", ...this.parsedUrl.query }, responseType: "json", signal: e3 }, o3 = await U(this.parsedUrl.path, t);
    o3.ssl && (this.url = (_a = this.url) == null ? void 0 : _a.replace(/^http:/i, "https:")), this.sourceJSON = o3.data, this.read(o3.data, { origin: "service", url: this.parsedUrl });
  }
  get hasOverriddenFetchTile() {
    return !this.fetchTile.__isDefault__;
  }
};
e2([y({ json: { read: { source: "copyrightText" } } })], j.prototype, "copyright", void 0), e2([y({ readOnly: true, type: v2 })], j.prototype, "heightModelInfo", void 0), e2([y({ type: String, json: { origins: { "web-scene": { read: true, write: true } }, read: false } })], j.prototype, "path", void 0), e2([y({ type: ["show", "hide"] })], j.prototype, "listMode", void 0), e2([y({ json: { read: false, write: false, origins: { service: { read: false, write: false }, "portal-item": { read: false, write: false }, "web-document": { read: false, write: false } } }, readOnly: true })], j.prototype, "minScale", void 0), e2([y({ json: { read: false, write: false, origins: { service: { read: false, write: false }, "portal-item": { read: false, write: false }, "web-document": { read: false, write: false } } }, readOnly: true })], j.prototype, "maxScale", void 0), e2([y({ json: { read: false, write: false, origins: { "web-document": { read: false, write: false } } } })], j.prototype, "opacity", void 0), e2([y({ type: ["ArcGISTiledElevationServiceLayer"] })], j.prototype, "operationalLayerType", void 0), e2([y()], j.prototype, "sourceJSON", void 0), e2([y({ json: { read: false }, value: "elevation", readOnly: true })], j.prototype, "type", void 0), e2([y(f2)], j.prototype, "url", void 0), e2([y()], j.prototype, "version", void 0), e2([o("version", ["currentVersion"])], j.prototype, "readVersion", null), j = e2([n("esri.layers.ElevationLayer")], j), j.prototype.fetchTile.__isDefault__ = true;
var w3 = j;
export {
  w3 as default
};
//# sourceMappingURL=ElevationLayer-YQ6XJQ6G.js.map
