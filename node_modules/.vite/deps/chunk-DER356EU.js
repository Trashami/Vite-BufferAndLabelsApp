import {
  k2 as k
} from "./chunk-LNZAOBFW.js";
import {
  s as s2
} from "./chunk-LIZHLHNA.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";
import {
  r
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/support/arcadeOnDemand.js
var s3 = s.getLogger("esri.support.arcadeOnDemand");
var c;
function i() {
  return c || (c = (async () => {
    const e = await import("./arcadeUtils-E27FLIND.js");
    return { arcade: e.arcade, arcadeUtils: e, Dictionary: e.Dictionary, Feature: e.arcadeFeature };
  })()), c;
}
var n = (e, r2, t) => p.create(e, r2, t, null, ["$feature"]);
var o = (e, r2, t) => p.create(e, r2, t, null, ["$feature", "$view"]);
var u = (e, r2, t, a) => p.create(e, r2, t, a, ["$feature", "$view"]);
var p = class {
  constructor(e, r2, t, a, s4, c2, i2, n2) {
    this.script = e, this.evaluate = s4;
    const o2 = Array.isArray(i2) ? i2 : i2.fields;
    this.fields = o2, this._syntaxTree = a, this._arcade = r2, this._arcadeDictionary = t, this._arcadeFeature = c2, this._spatialReference = n2, this._referencesGeometry = r2.scriptTouchesGeometry(this._syntaxTree), this._referencesScale = this._arcade.referencesMember(this._syntaxTree, "scale");
  }
  static async create(r2, c2, n2, o2, l, u2) {
    const { arcade: d, Feature: m, Dictionary: f } = await i(), y = k.fromJSON(c2);
    let h = null;
    try {
      h = d.parseScript(r2, u2);
    } catch (R) {
      return s3.error(new s2("arcade-bad-expression", "Failed to parse arcade script", { script: r2, error: R })), null;
    }
    const _ = l.reduce((e, r3) => ({ ...e, [r3]: null }), {});
    let w = null;
    r(o2) && (w = new f(o2), w.immutable = true, _.$config = null);
    const F = d.scriptUsesGeometryEngine(h), g = F && d.enableGeometrySupport(), S = d.scriptUsesFeatureSet(h) && d.enableFeatureSetSupport(), b = d.scriptIsAsync(h), x = b && d.enableAsyncSupport(), $ = { vars: _, spatialReference: y, useAsync: !!x };
    await Promise.all([g, S, x]);
    const v = /* @__PURE__ */ new Set();
    await d.loadDependentModules(v, h, null, b, F);
    const D = new f();
    D.immutable = false, D.setField("scale", 0);
    const j = d.compileScript(h, $), G = (e) => ("$view" in e && e.$view && (D.setField("scale", e.$view.scale), e.$view = D), w && (e.$config = w), j({ vars: e, spatialReference: y }));
    return new p(r2, d, f, h, G, new m(), n2, y);
  }
  repurposeFeature(e) {
    return e.geometry && !e.geometry.spatialReference && (e.geometry.spatialReference = this._spatialReference), this._arcadeFeature.repurposeFromGraphicLikeObject(e.geometry, e.attributes, { fields: this.fields }), this._arcadeFeature;
  }
  createDictionary() {
    return new this._arcadeDictionary();
  }
  referencesMember(e) {
    return this._arcade.referencesMember(this._syntaxTree, e);
  }
  referencesFunction(e) {
    return this._arcade.referencesFunction(this._syntaxTree, e);
  }
  referencesGeometry() {
    return this._referencesGeometry;
  }
  referencesScale() {
    return this._referencesScale;
  }
  extractFieldLiterals() {
    return this._arcade.extractExpectedFieldLiterals(this._syntaxTree);
  }
};

export {
  i,
  n,
  o,
  u,
  p
};
//# sourceMappingURL=chunk-DER356EU.js.map
