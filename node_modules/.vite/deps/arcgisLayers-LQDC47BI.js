import {
  a,
  r as r2
} from "./chunk-3XUZDMLH.js";
import {
  a as a2
} from "./chunk-RLIH5RCN.js";
import {
  m,
  w
} from "./chunk-J5VTDQTQ.js";
import "./chunk-X2S4RQJ4.js";
import "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import {
  Ut,
  j
} from "./chunk-KAN4HXCG.js";
import "./chunk-MJXQTGI2.js";
import {
  s
} from "./chunk-LIZHLHNA.js";
import "./chunk-UA3YPL2R.js";
import "./chunk-HVKDYDPP.js";
import "./chunk-6QC7MLLS.js";
import {
  r,
  t
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/layers/support/arcgisLayers.js
async function c(e) {
  var _a;
  const r3 = (_a = e.properties) == null ? void 0 : _a.customParameters, a3 = await m2(e.url, r3), t2 = { ...e.properties, url: e.url };
  if (!a3.sublayerIds)
    return null != a3.layerOrTableId && (t2.layerId = a3.layerOrTableId, t2.sourceJSON = a3.sourceJSON), new a3.Constructor(t2);
  const s2 = new (0, (await import("./GroupLayer-4AAELAZL.js")).default)({ title: a3.parsedUrl.title });
  return d(s2, a3, t2), s2;
}
function i(e, r3) {
  return e ? e.find((e2) => e2.id === r3) : null;
}
function d(e, r3, t2) {
  function s2(e2, s3) {
    const n = { ...t2, layerId: e2, sublayerTitleMode: "service-name" };
    return r(s3) && (n.sourceJSON = s3), new r3.Constructor(n);
  }
  r3.sublayerIds.forEach((a3) => {
    const t3 = s2(a3, i(r3.sublayerInfos, a3));
    e.add(t3);
  }), r3.tableIds.forEach((a3) => {
    const t3 = s2(a3, i(r3.tableInfos, a3));
    e.tables.add(t3);
  });
}
async function m2(a3, t2) {
  var _a, _b;
  let s2 = m(a3);
  if (t(s2) && (s2 = await f(a3, t2)), t(s2))
    throw new s("arcgis-layers:url-mismatch", "The url '${url}' is not a valid arcgis resource", { url: a3 });
  const { serverType: l, sublayer: u } = s2;
  let y;
  const c2 = { FeatureServer: "FeatureLayer", StreamServer: "StreamLayer", VectorTileServer: "VectorTileLayer" };
  switch (l) {
    case "MapServer":
      y = null != u ? "FeatureLayer" : b(a3, t2).then((e) => e ? "TileLayer" : "MapImageLayer");
      break;
    case "ImageServer":
      y = a(a3, { customParameters: t2 }).then((e) => {
        const r3 = e.tileInfo && e.tileInfo.format;
        return e.tileInfo ? "LERC" !== (r3 == null ? void 0 : r3.toUpperCase()) || e.cacheType && "elevation" !== e.cacheType.toLowerCase() ? "ImageryTileLayer" : "ElevationLayer" : "ImageryLayer";
      });
      break;
    case "SceneServer":
      y = a(s2.url.path, { customParameters: t2 }).then((e) => {
        var _a2;
        if (e) {
          if ("Voxel" === (e == null ? void 0 : e.layerType))
            return "VoxelLayer";
          if ((e == null ? void 0 : e.layers) && Array.isArray(e.layers) && e.layers.length > 0) {
            const r3 = { Point: "SceneLayer", "3DObject": "SceneLayer", IntegratedMesh: "IntegratedMeshLayer", PointCloud: "PointCloudLayer", Building: "BuildingSceneLayer" }, a4 = (_a2 = e.layers[0]) == null ? void 0 : _a2.layerType;
            if (null != r3[a4])
              return r3[a4];
          }
        }
        return "SceneLayer";
      });
      break;
    default:
      y = c2[l];
  }
  const i2 = { FeatureLayer: true, SceneLayer: true }, d2 = "FeatureServer" === l, m3 = { parsedUrl: s2, Constructor: null, layerOrTableId: d2 ? u : null, sublayerIds: null, tableIds: null }, p2 = await y;
  if (i2[p2] && null == u) {
    const e = await I(a3, l, t2);
    d2 && (m3.sublayerInfos = e.layerInfos, m3.tableInfos = e.tableInfos);
    1 !== e.layerIds.length + e.tableIds.length ? (m3.sublayerIds = e.layerIds, m3.tableIds = e.tableIds) : d2 && (m3.layerOrTableId = (_a = e.layerIds[0]) != null ? _a : e.tableIds[0], m3.sourceJSON = (_b = e.layerInfos[0]) != null ? _b : e.tableInfos[0]);
  }
  return m3.Constructor = await S(p2), m3;
}
async function f(e, r3) {
  var _a;
  const n = await a(e, { customParameters: r3 });
  let u = null, y = null;
  const c2 = n.type;
  if ("Feature Layer" === c2 || "Table" === c2 ? (u = "FeatureServer", y = n.id) : "indexedVector" === c2 ? u = "VectorTileServer" : n.hasOwnProperty("mapName") ? u = "MapServer" : n.hasOwnProperty("bandCount") && n.hasOwnProperty("pixelSizeX") ? u = "ImageServer" : n.hasOwnProperty("maxRecordCount") && n.hasOwnProperty("allowGeometryUpdates") ? u = "FeatureServer" : n.hasOwnProperty("streamUrls") ? u = "StreamServer" : p(n) ? (u = "SceneServer", y = n.id) : n.hasOwnProperty("layers") && p((_a = n.layers) == null ? void 0 : _a[0]) && (u = "SceneServer"), !u)
    return null;
  const i2 = null != y ? w(e) : null;
  return { title: r(i2) && n.name || Ut(e), serverType: u, sublayer: y, url: { path: r(i2) ? i2.serviceUrl : j(e).path } };
}
function p(e) {
  return (e == null ? void 0 : e.hasOwnProperty("store")) && e.hasOwnProperty("id") && "number" == typeof e.id;
}
async function I(e, r3, a3) {
  let t2, s2 = false;
  if ("FeatureServer" === r3) {
    const r4 = await r2(e, { customParameters: a3 });
    s2 = !!r4.layersJSON, t2 = r4.layersJSON || r4.serviceJSON;
  } else
    t2 = await a(e, { customParameters: a3 });
  const n = t2 == null ? void 0 : t2.layers, l = t2 == null ? void 0 : t2.tables;
  return { layerIds: (n == null ? void 0 : n.map((e2) => e2.id).reverse()) || [], tableIds: (l == null ? void 0 : l.map((e2) => e2.id).reverse()) || [], layerInfos: s2 ? n : [], tableInfos: s2 ? l : [] };
}
async function S(e) {
  return (0, a2[e])();
}
async function b(e, r3) {
  return (await a(e, { customParameters: r3 })).tileInfo;
}
export {
  c as fromUrl
};
//# sourceMappingURL=arcgisLayers-LQDC47BI.js.map
