import {
  g,
  t as t3
} from "./chunk-AKA4FJNZ.js";
import {
  e as e2
} from "./chunk-P6POPBMF.js";
import {
  l as l2
} from "./chunk-U7A2AWFU.js";
import {
  J as J2
} from "./chunk-ZB4SIC65.js";
import {
  M,
  P as P3,
  Z as Z2,
  d,
  p as p3
} from "./chunk-YHCS4AQC.js";
import {
  Ae,
  Ce,
  DateTime,
  E,
  F2 as F,
  Fe,
  G,
  H,
  I,
  Ie,
  J,
  K,
  L,
  O,
  P,
  P2,
  R,
  Re,
  Se,
  U,
  V,
  W,
  X,
  Y,
  Z,
  _,
  ae,
  e,
  h as h2,
  i2 as i,
  ie,
  k as k2,
  le,
  pe,
  re,
  se,
  t,
  t2,
  te,
  ue,
  v2 as v3,
  w as w3,
  z
} from "./chunk-GDBM63TX.js";
import {
  p as p2
} from "./chunk-6UMNMSQC.js";
import {
  v as v2
} from "./chunk-EHPBHJYZ.js";
import {
  h,
  m2 as m,
  u,
  v2 as v
} from "./chunk-3MNMDUQZ.js";
import {
  p,
  w,
  w2
} from "./chunk-UWG37XSU.js";
import {
  k2 as k
} from "./chunk-LNZAOBFW.js";
import {
  l
} from "./chunk-4FEGON7M.js";
import {
  C
} from "./chunk-MJXQTGI2.js";
import {
  c
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/arcade/treeAnalysis.js
var e3 = { all: { min: 2, max: 2 }, none: { min: 2, max: 2 }, any: { min: 2, max: 2 }, reduce: { min: 2, max: 3 }, map: { min: 2, max: 2 }, filter: { min: 2, max: 2 }, fromcodepoint: { min: 1, max: -1 }, fromcharcode: { min: 1, max: -1 }, tocodepoint: { min: 1, max: 2 }, tocharcode: { min: 1, max: 2 }, concatenate: { min: 0, max: -1 }, expects: { min: 1, max: -1 }, getfeatureset: { min: 1, max: 2 }, week: { min: 1, max: 2 }, fromjson: { min: 1, max: 1 }, length3d: { min: 1, max: 2 }, tohex: { min: 1, max: 1 }, hash: { min: 1, max: 1 }, isoweek: { min: 1, max: 1 }, isoweekday: { min: 1, max: 1 }, hasvalue: { min: 2, max: 2 }, isomonth: { min: 1, max: 1 }, isoyear: { min: 1, max: 1 }, resize: { min: 2, max: 3 }, slice: { min: 0, max: -1 }, splice: { min: 0, max: -1 }, push: { min: 2, max: 2 }, pop: { min: 1, max: 1 }, includes: { min: 2, max: 2 }, array: { min: 1, max: 2 }, front: { min: 1, max: 1 }, back: { min: 1, max: 1 }, insert: { min: 3, max: 3 }, erase: { min: 2, max: 2 }, split: { min: 2, max: 4 }, guid: { min: 0, max: 1 }, standardizeguid: { min: 2, max: 2 }, today: { min: 0, max: 0 }, angle: { min: 2, max: 3 }, bearing: { min: 2, max: 3 }, urlencode: { min: 1, max: 1 }, now: { min: 0, max: 0 }, timestamp: { min: 0, max: 0 }, day: { min: 1, max: 1 }, month: { min: 1, max: 1 }, year: { min: 1, max: 1 }, hour: { min: 1, max: 1 }, second: { min: 1, max: 1 }, millisecond: { min: 1, max: 1 }, minute: { min: 1, max: 1 }, weekday: { min: 1, max: 1 }, toutc: { min: 1, max: 1 }, tolocal: { min: 1, max: 1 }, date: { min: 0, max: 7 }, datediff: { min: 2, max: 3 }, dateadd: { min: 2, max: 3 }, trim: { min: 1, max: 1 }, text: { min: 1, max: 2 }, left: { min: 2, max: 2 }, right: { min: 2, max: 2 }, mid: { min: 2, max: 3 }, upper: { min: 1, max: 1 }, proper: { min: 1, max: 2 }, lower: { min: 1, max: 1 }, find: { min: 2, max: 3 }, iif: { min: 3, max: 3 }, decode: { min: 2, max: -1 }, when: { min: 2, max: -1 }, defaultvalue: { min: 2, max: 2 }, isempty: { min: 1, max: 1 }, domaincode: { min: 2, max: 4 }, domainname: { min: 2, max: 4 }, polygon: { min: 1, max: 1 }, point: { min: 1, max: 1 }, polyline: { min: 1, max: 1 }, extent: { min: 1, max: 1 }, multipoint: { min: 1, max: 1 }, ringisclockwise: { min: 1, max: 1 }, geometry: { min: 1, max: 1 }, count: { min: 0, max: -1 }, number: { min: 1, max: 2 }, acos: { min: 1, max: 1 }, asin: { min: 1, max: 1 }, atan: { min: 1, max: 1 }, atan2: { min: 2, max: 2 }, ceil: { min: 1, max: 2 }, floor: { min: 1, max: 2 }, round: { min: 1, max: 2 }, cos: { min: 1, max: 1 }, exp: { min: 1, max: 1 }, log: { min: 1, max: 1 }, min: { min: 0, max: -1 }, constrain: { min: 3, max: 3 }, console: { min: 0, max: -1 }, max: { min: 0, max: -1 }, pow: { min: 2, max: 2 }, random: { min: 0, max: 0 }, sqrt: { min: 1, max: 1 }, sin: { min: 1, max: 1 }, tan: { min: 1, max: 1 }, abs: { min: 1, max: 1 }, isnan: { min: 1, max: 1 }, stdev: { min: 0, max: -1 }, average: { min: 0, max: -1 }, mean: { min: 0, max: -1 }, sum: { min: 0, max: -1 }, variance: { min: 0, max: -1 }, distinct: { min: 0, max: -1 }, first: { min: 1, max: 1 }, top: { min: 2, max: 2 }, boolean: { min: 1, max: 1 }, dictionary: { min: 0, max: -1 }, typeof: { min: 1, max: 1 }, reverse: { min: 1, max: 1 }, replace: { min: 3, max: 4 }, sort: { min: 1, max: 2 }, feature: { min: 1, max: -1 }, haskey: { min: 2, max: 2 }, indexof: { min: 2, max: 2 }, disjoint: { min: 2, max: 2 }, intersects: { min: 2, max: 2 }, touches: { min: 2, max: 2 }, crosses: { min: 2, max: 2 }, within: { min: 2, max: 2 }, contains: { min: 2, max: 2 }, overlaps: { min: 2, max: 2 }, equals: { min: 2, max: 2 }, relate: { min: 3, max: 3 }, intersection: { min: 2, max: 2 }, union: { min: 1, max: 2 }, difference: { min: 2, max: 2 }, symmetricdifference: { min: 2, max: 2 }, clip: { min: 2, max: 2 }, cut: { min: 2, max: 2 }, area: { min: 1, max: 2 }, areageodetic: { min: 1, max: 2 }, length: { min: 1, max: 2 }, lengthgeodetic: { min: 1, max: 2 }, distancegeodetic: { min: 2, max: 3 }, distance: { min: 2, max: 3 }, densify: { min: 2, max: 3 }, densifygeodetic: { min: 2, max: 3 }, generalize: { min: 2, max: 4 }, buffer: { min: 2, max: 3 }, buffergeodetic: { min: 2, max: 3 }, offset: { min: 2, max: 6 }, rotate: { min: 2, max: 3 }, issimple: { min: 1, max: 1 }, simplify: { min: 1, max: 1 }, convexhull: { min: 1, max: 1 }, centroid: { min: 1, max: 1 }, isselfintersecting: { min: 1, max: 1 }, multiparttosinglepart: { min: 1, max: 1 }, setgeometry: { min: 2, max: 2 }, portal: { min: 1, max: 1 }, getuser: { min: 0, max: 2 }, subtypes: { min: 1, max: 1 }, subtypecode: { min: 1, max: 1 }, subtypename: { min: 1, max: 1 }, domain: { min: 2, max: 3 }, convertdirection: { min: 3, max: 3 }, schema: { min: 1, max: 1 } };
var n = { functionDefinitions: /* @__PURE__ */ new Map(), constantDefinitions: /* @__PURE__ */ new Map() };
var a = { functionDefinitions: /* @__PURE__ */ new Map(), constantDefinitions: /* @__PURE__ */ new Map() };
for (const b2 of ["pi", "infinity"])
  a.constantDefinitions.set(b2, { type: "constant" }), n.constantDefinitions.set(b2, { type: "constant" });
a.constantDefinitions.set("textformatting", { type: "namespace", key: "textformatting", members: [{ key: "backwardslash", type: "constant" }, { key: "doublequote", type: "constant" }, { key: "forwardslash", type: "constant" }, { key: "tab", type: "constant" }, { key: "singlequote", type: "constant" }, { key: "newline", type: "constant" }] }), n.constantDefinitions.set("textformatting", { type: "namespace", key: "textformatting", members: [{ key: "backwardslash", type: "constant" }, { key: "tab", type: "constant" }, { key: "singlequote", type: "constant" }, { key: "doublequote", type: "constant" }, { key: "forwardslash", type: "constant" }, { key: "newline", type: "constant" }] });
for (const b2 in e3) {
  const t6 = e3[b2];
  a.functionDefinitions.set(b2, { overloads: [{ type: "function", parametersInfo: { min: t6.min, max: t6.max } }] }), n.functionDefinitions.set(b2, { overloads: [{ type: "function", parametersInfo: { min: t6.min, max: t6.max } }] });
}
var t4 = ["featureset", "getuser", "featuresetbyid", "featuresetbyname", "featuresetbyassociation", "featuresetbyrelationshipname", "featuresetbyurl", "getfeatureset", "attachments", "featuresetbyportalitem"];
var i2 = ["disjoint", "intersects", "touches", "crosses", "within", "contains", "overlaps", "equals", "relate", "intersection", "union", "difference", "symmetricdifference", "clip", "cut", "area", "areageodetic", "length", "length3d", "lengthgeodetic", "distance", "distancegeodetic", "densify", "densifygeodetic", "generalize", "buffer", "buffergeodetic", "offset", "rotate", "issimple", "convexhull", "simplify", "multiparttosinglepart"];
function m2(e5) {
  return "string" == typeof e5 || e5 instanceof String;
}
function o(e5, t6) {
  var _a;
  const i4 = "sync" === t6 ? n : a;
  i4.functionDefinitions.has(e5.name.toLowerCase()) ? (_a = i4.functionDefinitions.get(e5.name.toLowerCase())) == null ? void 0 : _a.overloads.push({ type: "function", parametersInfo: { min: e5.min, max: e5.max } }) : i4.functionDefinitions.set(e5.name.toLowerCase(), { overloads: [{ type: "function", parametersInfo: { min: e5.min, max: e5.max } }] });
}
function s(e5, n3) {
  if (e5)
    for (const a3 of e5)
      r(a3, n3);
}
function r(e5, n3) {
  if (e5 && false !== n3(e5))
    switch (e5.type) {
      case "ImportDeclaration":
        s(e5.specifiers, n3), r(e5.source, n3);
        break;
      case "ExportNamedDeclaration":
        r(e5.declaration, n3);
        break;
      case "ArrayExpression":
        s(e5.elements, n3);
        break;
      case "AssignmentExpression":
      case "BinaryExpression":
      case "LogicalExpression":
        r(e5.left, n3), r(e5.right, n3);
        break;
      case "BlockStatement":
      case "Program":
        s(e5.body, n3);
        break;
      case "BreakStatement":
      case "ContinueStatement":
      case "EmptyStatement":
      case "Identifier":
      case "Literal":
        break;
      case "CallExpression":
        r(e5.callee, n3), s(e5.arguments, n3);
        break;
      case "ExpressionStatement":
        r(e5.expression, n3);
        break;
      case "ForInStatement":
        r(e5.left, n3), r(e5.right, n3), r(e5.body, n3);
        break;
      case "ForStatement":
        r(e5.init, n3), r(e5.test, n3), r(e5.update, n3), r(e5.body, n3);
        break;
      case "WhileStatement":
        r(e5.test, n3), r(e5.body, n3);
        break;
      case "FunctionDeclaration":
        r(e5.id, n3), s(e5.params, n3), r(e5.body, n3);
        break;
      case "IfStatement":
        r(e5.test, n3), r(e5.consequent, n3), r(e5.alternate, n3);
        break;
      case "MemberExpression":
        r(e5.object, n3), r(e5.property, n3);
        break;
      case "ObjectExpression":
        s(e5.properties, n3);
        break;
      case "Property":
        r(e5.key, n3), r(e5.value, n3);
        break;
      case "ReturnStatement":
      case "UnaryExpression":
      case "UpdateExpression":
        r(e5.argument, n3);
        break;
      case "VariableDeclaration":
        s(e5.declarations, n3);
        break;
      case "VariableDeclarator":
        r(e5.id, n3), r(e5.init, n3);
        break;
      case "TemplateLiteral":
        s(e5.expressions, n3), s(e5.quasis, n3);
    }
}
function c2(e5, n3) {
  let a3 = false;
  const t6 = n3.toLowerCase();
  return r(e5, (e6) => !a3 && ("Identifier" === e6.type && e6.name && e6.name.toLowerCase() === t6 && (a3 = true), true)), a3;
}
function x(e5) {
  const n3 = [];
  return r(e5, (e6) => ("ImportDeclaration" === e6.type && e6.source && e6.source.value && n3.push({ libname: e6.specifiers[0].local.name.toLowerCase(), source: e6.source.value }), true)), n3;
}
function p4(e5, n3) {
  let a3 = false;
  const t6 = n3.toLowerCase();
  return r(e5, (e6) => !a3 && ("CallExpression" !== e6.type || "Identifier" !== e6.callee.type || !e6.callee.name || e6.callee.name.toLowerCase() !== t6 || (a3 = true, false))), a3;
}
function l3(e5) {
  const n3 = [];
  return r(e5, (e6) => {
    var _a;
    return "MemberExpression" !== e6.type || "Identifier" !== e6.object.type || (false === e6.computed && e6.object && e6.object.name && e6.property && "Identifier" === e6.property.type && e6.property.name ? n3.push(e6.object.name.toLowerCase() + "." + e6.property.name.toLowerCase()) : e6.object && e6.object.name && e6.property && "Literal" === e6.property.type && "string" == typeof e6.property.value && n3.push(e6.object.name.toLowerCase() + "." + ((_a = e6.property.value) == null ? void 0 : _a.toString().toLowerCase())), false);
  }), n3;
}
function u2(e5) {
  const n3 = [];
  return r(e5, (e6) => {
    var _a;
    if ("CallExpression" === e6.type) {
      if ("Identifier" === e6.callee.type && "expects" === e6.callee.name.toLowerCase()) {
        let a3 = "";
        for (let t6 = 0; t6 < (e6.arguments || []).length; t6++)
          0 === t6 ? "Identifier" === e6.arguments[t6].type && (a3 = e6.arguments[t6].name.toLowerCase()) : a3 && "Literal" === e6.arguments[t6].type && m2(e6.arguments[t6].value) && n3.push(a3 + "." + e6.arguments[t6].value.toLowerCase());
        return false;
      }
      if ("Identifier" === e6.callee.type && ["domainname", "domaincode", "domain", "haskey"].includes(e6.callee.name.toLowerCase()) && e6.arguments.length >= 2) {
        let a3 = "";
        return "Identifier" === e6.arguments[0].type && (a3 = e6.arguments[0].name.toLowerCase()), a3 && "Literal" === e6.arguments[1].type && m2(e6.arguments[1].value) && n3.push(a3 + "." + e6.arguments[1].value.toLowerCase()), false;
      }
    }
    return "MemberExpression" !== e6.type || "Identifier" !== e6.object.type || (false === e6.computed && e6.object && e6.object.name && e6.property && "Identifier" === e6.property.type && e6.property.name ? n3.push(e6.object.name.toLowerCase() + "." + e6.property.name.toLowerCase()) : e6.object && e6.object.name && e6.property && "Literal" === e6.property.type && "string" == typeof e6.property.value && n3.push(e6.object.name.toLowerCase() + "." + ((_a = e6.property.value) == null ? void 0 : _a.toString().toLowerCase())), false);
  }), n3;
}
function y(e5) {
  const n3 = [];
  return r(e5, (e6) => ("CallExpression" === e6.type && "Identifier" === e6.callee.type && n3.push(e6.callee.name.toLowerCase()), true)), n3;
}
function d2(e5, n3 = []) {
  let a3 = null;
  if (void 0 === e5.usesFeatureSet) {
    null === a3 && (a3 = y(e5)), e5.usesFeatureSet = false;
    for (let n4 = 0; n4 < a3.length; n4++)
      t4.includes(a3[n4]) && (e5.usesFeatureSet = true, e5.isAsync = true);
    if (false === e5.usesFeatureSet && n3 && n3.length > 0) {
      for (const a4 of n3)
        if (c2(e5, a4)) {
          e5.usesFeatureSet = true, e5.isAsync = true;
          break;
        }
    }
  }
  if (void 0 === e5.usesModules) {
    e5.usesModules = false;
    x(e5).length > 0 && (e5.usesModules = true);
  }
  if (void 0 === e5.usesGeometry) {
    e5.usesGeometry = false, null === a3 && (a3 = y(e5));
    for (let n4 = 0; n4 < a3.length; n4++)
      i2.includes(a3[n4]) && (e5.usesGeometry = true);
  }
}

// node_modules/@arcgis/core/chunks/array.js
function F2(F4) {
  function m6(e5, o2, i4) {
    if (e5 instanceof t2)
      return e5.toArray();
    if (Y(e5))
      return e5;
    throw new t(o2, e.InvalidParameter, i4);
  }
  function p6(n3, t6) {
    const r3 = n3.length, e5 = Math.floor(r3 / 2);
    return 0 === r3 ? [] : 1 === r3 ? [n3[0]] : y4(p6(n3.slice(0, e5), t6), p6(n3.slice(e5, r3), t6), t6);
  }
  function y4(n3, t6, r3) {
    const e5 = [];
    for (; n3.length > 0 || t6.length > 0; )
      if (n3.length > 0 && t6.length > 0) {
        let o2 = r3(n3[0], t6[0]);
        isNaN(o2) && (o2 = 0), o2 <= 0 ? (e5.push(n3[0]), n3 = n3.slice(1)) : (e5.push(t6[0]), t6 = t6.slice(1));
      } else
        n3.length > 0 ? (e5.push(n3[0]), n3 = n3.slice(1)) : t6.length > 0 && (e5.push(t6[0]), t6 = t6.slice(1));
    return e5;
  }
  async function v5(n3, t6) {
    const r3 = n3.length, e5 = Math.floor(r3 / 2);
    if (0 === r3)
      return [];
    if (1 === r3)
      return [n3[0]];
    const o2 = [await v5(n3.slice(0, e5), t6), await v5(n3.slice(e5, r3), t6)];
    return P5(o2[0], o2[1], t6, []);
  }
  async function P5(n3, t6, r3, e5) {
    const o2 = e5;
    if (!(n3.length > 0 || t6.length > 0))
      return e5;
    if (n3.length > 0 && t6.length > 0) {
      let i4 = await r3(n3[0], t6[0]);
      return isNaN(i4) && (i4 = 1), i4 <= 0 ? (o2.push(n3[0]), n3 = n3.slice(1)) : (o2.push(t6[0]), t6 = t6.slice(1)), P5(n3, t6, r3, e5);
    }
    return n3.length > 0 ? (o2.push(n3[0]), P5(n3 = n3.slice(1), t6, r3, e5)) : t6.length > 0 ? (o2.push(t6[0]), P5(n3, t6 = t6.slice(1), r3, e5)) : void 0;
  }
  function I3(r3, o2, i4, u3) {
    V(i4, 1, 2, r3, o2);
    let l6 = i4[0];
    if (E(l6) && (l6 = l6.toArray()), false === Y(l6))
      throw new t(r3, e.InvalidParameter, o2);
    if (i4.length > 1) {
      if (false === F(i4[1]))
        throw new t(r3, e.InvalidParameter, o2);
      let e5 = l6;
      const a3 = i4[1].createFunction(r3);
      return u3 ? v5(e5, a3) : (e5 = p6(e5, (n3, t6) => a3(n3, t6)), e5);
    }
    let f2 = l6;
    if (0 === f2.length)
      return [];
    const g3 = {};
    for (let n3 = 0; n3 < f2.length; n3++) {
      const t6 = O(f2[n3]);
      "" !== t6 && (g3[t6] = true);
    }
    if (true === g3.Array || true === g3.Dictionary || true === g3.Feature || true === g3.Point || true === g3.Polygon || true === g3.Polyline || true === g3.Multipoint || true === g3.Extent || true === g3.Function)
      return f2.slice(0);
    let F5 = 0, m7 = "";
    for (const n3 in g3)
      F5++, m7 = n3;
    return f2 = F5 > 1 || "String" === m7 ? p6(f2, (n3, t6) => {
      if (null == n3 || n3 === k2)
        return null == t6 || t6 === k2 ? 0 : 1;
      if (null == t6 || t6 === k2)
        return -1;
      const r4 = K(n3), e5 = K(t6);
      return r4 < e5 ? -1 : r4 === e5 ? 0 : 1;
    }) : "Number" === m7 ? p6(f2, (n3, t6) => n3 - t6) : "Boolean" === m7 ? p6(f2, (n3, t6) => n3 === t6 ? 0 : t6 ? -1 : 1) : "Date" === m7 ? p6(f2, (n3, t6) => t6 - n3) : f2.slice(0), f2;
  }
  F4.functions.array = function(r3, a3) {
    return F4.standardFunction(r3, a3, (c3, s4, l6) => {
      V(l6, 1, 2, r3, a3);
      const f2 = re(l6[0]);
      if (isNaN(f2) || false === L(f2))
        throw new t(r3, e.InvalidParameter, a3);
      const d5 = v3(l6[1], null), h5 = new Array(f2);
      return h5.fill(d5), h5;
    });
  }, F4.functions.front = function(r3, o2) {
    return F4.standardFunction(r3, o2, (i4, u3, s4) => {
      if (V(s4, 1, 1, r3, o2), E(s4[0])) {
        if (s4[0].length() <= 0)
          throw new t(r3, e.OutOfBounds, o2);
        return s4[0].get(0);
      }
      if (Y(s4[0])) {
        if (s4[0].length <= 0)
          throw new t(r3, e.OutOfBounds, o2);
        return s4[0][0];
      }
      throw new t(r3, e.InvalidParameter, o2);
    });
  }, F4.functions.back = function(r3, o2) {
    return F4.standardFunction(r3, o2, (i4, u3, s4) => {
      if (V(s4, 1, 1, r3, o2), E(s4[0])) {
        if (s4[0].length() <= 0)
          throw new t(r3, e.OutOfBounds, o2);
        return s4[0].get(s4[0].length() - 1);
      }
      if (Y(s4[0])) {
        if (s4[0].length <= 0)
          throw new t(r3, e.OutOfBounds, o2);
        return s4[0][s4[0].length - 1];
      }
      throw new t(r3, e.InvalidParameter, o2);
    });
  }, F4.functions.push = function(r3, o2) {
    return F4.standardFunction(r3, o2, (i4, u3, a3) => {
      if (V(a3, 1, 2, r3, o2), Y(a3[0]))
        return a3[0][a3[0].length] = a3[1], a3[0].length;
      throw new t(r3, e.InvalidParameter, o2);
    });
  }, F4.functions.pop = function(r3, o2) {
    return F4.standardFunction(r3, o2, (i4, u3, a3) => {
      if (V(a3, 1, 1, r3, o2), Y(a3[0])) {
        if (a3[0].length <= 0)
          throw new t(r3, e.OutOfBounds, o2);
        const e5 = a3[0][a3[0].length - 1];
        return a3[0].length = a3[0].length - 1, e5;
      }
      throw new t(r3, e.InvalidParameter, o2);
    });
  }, F4.functions.erase = function(r3, u3) {
    return F4.standardFunction(r3, u3, (a3, l6, f2) => {
      if (V(f2, 2, 2, r3, u3), Y(f2[0])) {
        let e5 = re(f2[1]);
        if (isNaN(e5) || false === L(e5))
          throw new t(r3, e.InvalidParameter, u3);
        const a4 = f2[0];
        if (a4.length <= 0)
          throw new t(r3, e.OutOfBounds, u3);
        if (e5 < 0 && (e5 = a4.length + e5), e5 < 0)
          throw new t(r3, e.OutOfBounds, u3);
        if (e5 >= a4.length)
          throw new t(r3, e.OutOfBounds, u3);
        return a4.splice(e5, 1), k2;
      }
      throw new t(r3, e.InvalidParameter, u3);
    });
  }, F4.functions.insert = function(r3, u3) {
    return F4.standardFunction(r3, u3, (a3, l6, f2) => {
      if (V(f2, 3, 3, r3, u3), Y(f2[0])) {
        const e5 = re(f2[1]);
        if (isNaN(e5) || false === L(e5))
          throw new t(r3, e.InvalidParameter, u3);
        const a4 = f2[2], c3 = f2[0];
        if (e5 > c3.length)
          throw new t(r3, e.OutOfBounds, u3);
        if (e5 < 0 && e5 < -1 * c3.length)
          throw new t(r3, e.OutOfBounds, u3);
        return e5 === c3.length ? (c3[e5] = a4, k2) : (c3.splice(e5, 0, a4), k2);
      }
      throw new t(r3, e.InvalidParameter, u3);
    });
  }, F4.functions.resize = function(r3, a3) {
    return F4.standardFunction(r3, a3, (l6, f2, d5) => {
      if (V(d5, 2, 3, r3, a3), Y(d5[0])) {
        const e5 = re(d5[1]);
        if (isNaN(e5) || false === L(e5))
          throw new t(r3, e.InvalidParameter, a3);
        if (e5 < 0)
          throw new t(r3, e.InvalidParameter, a3);
        const c3 = v3(d5[2], null), l7 = d5[0];
        if (l7.length >= e5)
          return l7.length = e5, k2;
        const f3 = l7.length;
        l7.length = e5;
        for (let n3 = f3; n3 < l7.length; n3++)
          l7[n3] = c3;
        return k2;
      }
      throw new t(r3, e.InvalidParameter, a3);
    });
  }, F4.functions.includes = function(r3, o2) {
    return F4.standardFunction(r3, o2, (i4, u3, s4) => {
      if (V(s4, 2, 2, r3, o2), Y(s4[0])) {
        const n3 = s4[1];
        return s4[0].findIndex((t6) => X(t6, n3)) > -1;
      }
      if (E(s4[0])) {
        const n3 = s4[1];
        return s4[0].toArray().findIndex((t6) => X(t6, n3)) > -1;
      }
      throw new t(r3, e.InvalidParameter, o2);
    });
  }, F4.functions.slice = function(r3, s4) {
    return F4.standardFunction(r3, s4, (l6, f2, d5) => {
      if (V(d5, 1, 3, r3, s4), Y(d5[0])) {
        const e5 = re(v3(d5[1], 0)), a3 = re(v3(d5[2], d5[0].length));
        if (isNaN(e5) || false === L(e5))
          throw new t(r3, e.InvalidParameter, s4);
        if (isNaN(a3) || false === L(a3))
          throw new t(r3, e.InvalidParameter, s4);
        return d5[0].slice(e5, a3);
      }
      if (E(d5[0])) {
        const e5 = d5[0], a3 = re(v3(d5[1], 0)), c3 = re(v3(d5[2], e5.length()));
        if (isNaN(a3) || false === L(a3))
          throw new t(r3, e.InvalidParameter, s4);
        if (isNaN(c3) || false === L(c3))
          throw new t(r3, e.InvalidParameter, s4);
        return e5.toArray().slice(a3, c3);
      }
      throw new t(r3, e.InvalidParameter, s4);
    });
  }, F4.functions.splice = function(n3, t6) {
    return F4.standardFunction(n3, t6, (n4, t7, r3) => {
      const e5 = [];
      for (let o2 = 0; o2 < r3.length; o2++)
        Y(r3[o2]) ? e5.push(...r3[o2]) : E(r3[o2]) ? e5.push(...r3[o2].toArray()) : e5.push(r3[o2]);
      return e5;
    });
  }, F4.functions.top = function(r3, i4) {
    return F4.standardFunction(r3, i4, (u3, s4, l6) => {
      if (V(l6, 2, 2, r3, i4), Y(l6[0]))
        return re(l6[1]) >= l6[0].length ? l6[0].slice(0) : l6[0].slice(0, re(l6[1]));
      if (E(l6[0]))
        return re(l6[1]) >= l6[0].length() ? l6[0].slice(0) : l6[0].slice(0, re(l6[1]));
      throw new t(r3, e.InvalidParameter, i4);
    });
  }, F4.functions.first = function(n3, t6) {
    return F4.standardFunction(n3, t6, (r3, o2, i4) => (V(i4, 1, 1, n3, t6), Y(i4[0]) ? 0 === i4[0].length ? null : i4[0][0] : E(i4[0]) ? 0 === i4[0].length() ? null : i4[0].get(0) : null));
  }, "sync" === F4.mode && (F4.functions.sort = function(n3, t6) {
    return F4.standardFunction(n3, t6, (r3, e5, o2) => I3(n3, t6, o2, false));
  }, F4.functions.any = function(n3, t6) {
    return F4.standardFunction(n3, t6, (r3, o2, i4) => {
      V(i4, 2, 2, n3, t6);
      const u3 = i4[1].createFunction(n3), a3 = m6(i4[0], n3, t6);
      for (const n4 of a3) {
        const t7 = u3(n4);
        if (_(t7) && true === t7)
          return true;
      }
      return false;
    });
  }, F4.functions.all = function(n3, t6) {
    return F4.standardFunction(n3, t6, (r3, o2, i4) => {
      V(i4, 2, 2, n3, t6);
      const u3 = i4[1].createFunction(n3), a3 = m6(i4[0], n3, t6);
      for (const n4 of a3) {
        if (true !== u3(n4))
          return false;
      }
      return true;
    });
  }, F4.functions.none = function(n3, t6) {
    return F4.standardFunction(n3, t6, (r3, o2, i4) => {
      V(i4, 2, 2, n3, t6);
      const u3 = i4[1].createFunction(n3), a3 = m6(i4[0], n3, t6);
      for (const n4 of a3) {
        if (true === u3(n4))
          return false;
      }
      return true;
    });
  }, F4.functions.reduce = function(n3, t6) {
    return F4.standardFunction(n3, t6, (r3, o2, i4) => {
      V(i4, 2, 3, n3, t6);
      const u3 = i4[1].createFunction(n3), a3 = m6(i4[0], n3, t6);
      return 2 === i4.length ? 0 === a3.length ? null : a3.reduce((n4, t7) => {
        const r4 = u3(n4, t7);
        return n4 = void 0 !== r4 && r4 !== k2 ? r4 : null;
      }) : a3.reduce((n4, t7) => {
        const r4 = u3(n4, t7);
        return n4 = void 0 !== r4 && r4 !== k2 ? r4 : null;
      }, i4[2]);
    });
  }, F4.functions.map = function(n3, t6) {
    return F4.standardFunction(n3, t6, (r3, o2, i4) => {
      V(i4, 2, 2, n3, t6);
      const u3 = i4[1].createFunction(n3), a3 = m6(i4[0], n3, t6), c3 = [];
      for (const n4 of a3) {
        const t7 = u3(n4);
        void 0 !== t7 && t7 !== k2 ? c3.push(t7) : c3.push(null);
      }
      return c3;
    });
  }, F4.functions.filter = function(n3, t6) {
    return F4.standardFunction(n3, t6, (r3, o2, i4) => {
      V(i4, 2, 2, n3, t6);
      const u3 = i4[1].createFunction(n3), a3 = m6(i4[0], n3, t6), c3 = [];
      for (const n4 of a3) {
        true === u3(n4) && c3.push(n4);
      }
      return c3;
    });
  }), "async" === F4.mode && (F4.functions.sort = function(n3, t6) {
    return F4.standardFunctionAsync(n3, t6, (r3, e5, o2) => I3(n3, t6, o2, true));
  }, F4.functions.any = function(n3, t6) {
    return F4.standardFunctionAsync(n3, t6, async (r3, o2, i4) => {
      V(i4, 2, 2, n3, t6);
      const u3 = i4[1].createFunction(n3), a3 = m6(i4[0], n3, t6);
      for (const n4 of a3) {
        const t7 = await u3(n4);
        let r4 = null;
        if (r4 = C(r4) ? await t7 : t7, _(r4) && true === r4)
          return true;
      }
      return false;
    });
  }, F4.functions.all = function(n3, t6) {
    return F4.standardFunctionAsync(n3, t6, async (r3, o2, i4) => {
      V(i4, 2, 2, n3, t6);
      const u3 = i4[1].createFunction(n3), a3 = m6(i4[0], n3, t6);
      for (const n4 of a3) {
        const t7 = await u3(n4);
        let r4 = null;
        if (r4 = C(r4) ? await t7 : t7, true !== r4)
          return false;
      }
      return true;
    });
  }, F4.functions.none = function(n3, t6) {
    return F4.standardFunctionAsync(n3, t6, async (r3, o2, i4) => {
      V(i4, 2, 2, n3, t6);
      const u3 = i4[1].createFunction(n3), a3 = m6(i4[0], n3, t6);
      for (const n4 of a3) {
        const t7 = await u3(n4);
        let r4 = null;
        if (r4 = C(r4) ? await t7 : t7, true === r4)
          return false;
      }
      return true;
    });
  }, F4.functions.filter = function(n3, t6) {
    return F4.standardFunctionAsync(n3, t6, async (r3, o2, i4) => {
      V(i4, 2, 2, n3, t6);
      const u3 = i4[1].createFunction(n3), a3 = m6(i4[0], n3, t6), c3 = [];
      for (const n4 of a3) {
        const t7 = await u3(n4);
        let r4 = null;
        r4 = C(r4) ? await t7 : t7, true === r4 && c3.push(n4);
      }
      return c3;
    });
  }, F4.functions.reduce = function(n3, t6) {
    return F4.standardFunctionAsync(n3, t6, (r3, o2, i4) => {
      V(i4, 2, 3, n3, t6);
      const a3 = i4[1].createFunction(n3), c3 = m6(i4[0], n3, t6);
      let l6 = null;
      if (i4.length > 2) {
        const n4 = v3(i4[2], null);
        l6 = c3.reduce(async (n5, t7) => {
          let r4 = await n5;
          return void 0 !== r4 && r4 !== k2 || (r4 = null), a3(r4, t7);
        }, Promise.resolve(n4));
      } else {
        if (0 === c3.length)
          return null;
        l6 = c3.reduce(async (n4, t7, r4) => {
          if (r4 <= 1)
            return a3(n4, t7);
          let e5 = await n4;
          return void 0 !== e5 && e5 !== k2 || (e5 = null), a3(e5, t7);
        });
      }
      return l6.then((n4) => void 0 !== n4 && n4 !== k2 ? n4 : null);
    });
  }, F4.functions.map = function(n3, t6) {
    return F4.standardFunctionAsync(n3, t6, async (r3, o2, i4) => {
      V(i4, 2, 2, n3, t6);
      const u3 = i4[1].createFunction(n3), a3 = m6(i4[0], n3, t6), c3 = [];
      for (const n4 of a3) {
        const t7 = await u3(n4);
        let r4 = null;
        r4 = C(r4) ? await t7 : t7, void 0 !== r4 && r4 !== k2 ? c3.push(r4) : c3.push(null);
      }
      return c3;
    });
  });
}
var m3 = Object.freeze(Object.defineProperty({ __proto__: null, registerFunctions: F2 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/arcade/functions/date.js
function m4(e5) {
  const t6 = new Date(e5.getTime()), n3 = t6.getFullYear(), r3 = new Date(0);
  r3.setFullYear(n3 + 1, 0, 4), r3.setHours(0, 0, 0, 0);
  const s4 = d3(r3), u3 = new Date(0);
  u3.setFullYear(n3, 0, 4), u3.setHours(0, 0, 0, 0);
  const o2 = d3(u3);
  return t6.getTime() >= s4.getTime() ? n3 + 1 : t6.getTime() >= o2.getTime() ? n3 : n3 - 1;
}
function d3(e5) {
  const t6 = 1, n3 = new Date(e5.getTime()), r3 = n3.getDay(), s4 = (r3 < t6 ? 7 : 0) + r3 - t6;
  return n3.setDate(n3.getDate() - s4), n3.setHours(0, 0, 0, 0), n3;
}
function h3(e5) {
  const t6 = m4(e5), n3 = new Date(0);
  n3.setFullYear(t6, 0, 4), n3.setHours(0, 0, 0, 0);
  return d3(n3);
}
function N(e5, t6, n3) {
  return e5 + (D(n3) ? y2 : w4)[t6];
}
function D(e5) {
  return e5 % 4 == 0 && (e5 % 100 != 0 || e5 % 400 == 0);
}
var w4 = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
var y2 = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function T(e5) {
  return null === e5 ? e5 : isNaN(e5.getTime()) ? null : e5;
}
function M2(D4, w6) {
  D4.today = function(t6, n3) {
    return w6(t6, n3, (r3, s4, u3) => {
      V(u3, 0, 0, t6, n3);
      const o2 = new Date();
      return o2.setHours(0, 0, 0, 0), o2;
    });
  }, D4.now = function(t6, n3) {
    return w6(t6, n3, (r3, s4, u3) => {
      V(u3, 0, 0, t6, n3);
      return new Date();
    });
  }, D4.timestamp = function(t6, n3) {
    return w6(t6, n3, (r3, s4, u3) => {
      V(u3, 0, 0, t6, n3);
      let o2 = new Date();
      return o2 = new Date(o2.getUTCFullYear(), o2.getUTCMonth(), o2.getUTCDate(), o2.getUTCHours(), o2.getUTCMinutes(), o2.getUTCSeconds(), o2.getUTCMilliseconds()), o2;
    });
  }, D4.toutc = function(n3, r3) {
    return w6(n3, r3, (s4, u3, o2) => {
      V(o2, 1, 1, n3, r3);
      const a3 = ae(o2[0]);
      return null === a3 ? null : new Date(a3.getUTCFullYear(), a3.getUTCMonth(), a3.getUTCDate(), a3.getUTCHours(), a3.getUTCMinutes(), a3.getUTCSeconds(), a3.getUTCMilliseconds());
    });
  }, D4.tolocal = function(n3, r3) {
    return w6(n3, r3, (s4, u3, o2) => {
      V(o2, 1, 1, n3, r3);
      const a3 = ae(o2[0]);
      return null === a3 ? null : DateTime.utc(a3.getFullYear(), a3.getMonth() + 1, a3.getDate(), a3.getHours(), a3.getMinutes(), a3.getSeconds(), a3.getMilliseconds()).toJSDate();
    });
  }, D4.day = function(n3, r3) {
    return w6(n3, r3, (s4, u3, o2) => {
      V(o2, 1, 1, n3, r3);
      const a3 = ae(o2[0]);
      return null === a3 ? NaN : a3.getDate();
    });
  }, D4.month = function(n3, r3) {
    return w6(n3, r3, (s4, u3, o2) => {
      V(o2, 1, 1, n3, r3);
      const a3 = ae(o2[0]);
      return null === a3 ? NaN : a3.getMonth();
    });
  }, D4.year = function(n3, r3) {
    return w6(n3, r3, (s4, u3, o2) => {
      V(o2, 1, 1, n3, r3);
      const a3 = ae(o2[0]);
      return null === a3 ? NaN : a3.getFullYear();
    });
  }, D4.hour = function(n3, r3) {
    return w6(n3, r3, (s4, u3, o2) => {
      V(o2, 1, 1, n3, r3);
      const a3 = ae(o2[0]);
      return null === a3 ? NaN : a3.getHours();
    });
  }, D4.second = function(n3, r3) {
    return w6(n3, r3, (s4, u3, o2) => {
      V(o2, 1, 1, n3, r3);
      const a3 = ae(o2[0]);
      return null === a3 ? NaN : a3.getSeconds();
    });
  }, D4.millisecond = function(n3, r3) {
    return w6(n3, r3, (s4, u3, o2) => {
      V(o2, 1, 1, n3, r3);
      const a3 = ae(o2[0]);
      return null === a3 ? NaN : a3.getMilliseconds();
    });
  }, D4.minute = function(n3, r3) {
    return w6(n3, r3, (s4, u3, o2) => {
      V(o2, 1, 1, n3, r3);
      const a3 = ae(o2[0]);
      return null === a3 ? NaN : a3.getMinutes();
    });
  }, D4.week = function(s4, u3) {
    return w6(s4, u3, (o2, a3, c3) => {
      V(c3, 1, 2, s4, u3);
      const f2 = ae(c3[0]);
      if (null === f2)
        return NaN;
      const g3 = re(v3(c3[1], 0));
      if (g3 < 0 || g3 > 6)
        throw new t(s4, e.InvalidParameter, u3);
      const m6 = f2.getDate(), d5 = f2.getMonth(), h5 = f2.getFullYear(), D5 = f2.getDay(), w7 = N(m6, d5, h5) - 1, y4 = Math.floor(w7 / 7);
      return D5 - g3 + (D5 - g3 < 0 ? 7 : 0) < w7 - 7 * y4 ? y4 + 1 : y4;
    });
  }, D4.weekday = function(n3, r3) {
    return w6(n3, r3, (s4, u3, o2) => {
      V(o2, 1, 1, n3, r3);
      const a3 = ae(o2[0]);
      return null === a3 ? NaN : a3.getDay();
    });
  }, D4.isoweekday = function(n3, r3) {
    return w6(n3, r3, (s4, u3, o2) => {
      V(o2, 1, 1, n3, r3);
      const a3 = ae(o2[0]);
      if (null === a3)
        return NaN;
      let c3 = a3.getDay();
      return 0 === c3 && (c3 = 7), c3;
    });
  }, D4.isomonth = function(n3, r3) {
    return w6(n3, r3, (s4, u3, o2) => {
      V(o2, 1, 1, n3, r3);
      const a3 = ae(o2[0]);
      return null === a3 ? NaN : a3.getMonth() + 1;
    });
  }, D4.isoweek = function(n3, r3) {
    return w6(n3, r3, (s4, u3, o2) => {
      V(o2, 1, 1, n3, r3);
      const a3 = ae(o2[0]);
      if (null === a3)
        return NaN;
      const c3 = d3(a3).getTime() - h3(a3).getTime();
      return Math.round(c3 / 6048e5) + 1;
    });
  }, D4.isoyear = function(n3, r3) {
    return w6(n3, r3, (s4, u3, o2) => {
      V(o2, 1, 1, n3, r3);
      const a3 = ae(o2[0]);
      return null === a3 ? NaN : m4(a3);
    });
  }, D4.date = function(r3, a3) {
    return w6(r3, a3, (c3, l6, i4) => {
      if (V(i4, 0, 7, r3, a3), 3 === i4.length)
        return T(new Date(re(i4[0]), re(i4[1]), re(i4[2]), 0, 0, 0, 0));
      if (4 === i4.length)
        return T(new Date(re(i4[0]), re(i4[1]), re(i4[2]), re(i4[3]), 0, 0, 0));
      if (5 === i4.length)
        return T(new Date(re(i4[0]), re(i4[1]), re(i4[2]), re(i4[3]), re(i4[4]), 0, 0));
      if (6 === i4.length)
        return T(new Date(re(i4[0]), re(i4[1]), re(i4[2]), re(i4[3]), re(i4[4]), re(i4[5]), 0));
      if (7 === i4.length)
        return T(new Date(re(i4[0]), re(i4[1]), re(i4[2]), re(i4[3]), re(i4[4]), re(i4[5]), re(i4[6])));
      if (2 === i4.length) {
        let e5, t6 = K(i4[1]);
        return "" === t6 ? null : (t6 = W(t6), e5 = "X" === t6 ? DateTime.fromSeconds(re(i4[0])) : "x" === t6 ? DateTime.fromMillis(re(i4[0])) : DateTime.fromFormat(K(i4[0]), t6, { locale: l(), numberingSystem: "latn" }), e5.isValid ? e5.toJSDate() : null);
      }
      if (1 === i4.length) {
        if (w3(i4[0])) {
          if ("" === i4[0].replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""))
            return null;
          if (true === /^[0-9][0-9][0-9][0-9]$/.test(i4[0]))
            return ae(i4[0] + "-01-01");
        }
        const e5 = re(i4[0]);
        if (false === isNaN(e5))
          return T(new Date(e5));
        return ae(i4[0]);
      }
      return 0 === i4.length ? new Date() : void 0;
    });
  }, D4.datediff = function(t6, n3) {
    return w6(t6, n3, (r3, u3, o2) => {
      V(o2, 2, 3, t6, n3);
      const c3 = ie(o2[0]), l6 = ie(o2[1]);
      if (null === c3 || null === l6)
        return NaN;
      switch (K(o2[2]).toLowerCase()) {
        case "days":
        case "day":
        case "d":
          return c3.diff(l6, "days").days;
        case "months":
        case "month":
          return c3.diff(l6, "months").months;
        case "minutes":
        case "minute":
        case "m":
          return "M" === o2[2] ? c3.diff(l6, "months").months : c3.diff(l6, "minutes").minutes;
        case "seconds":
        case "second":
        case "s":
          return c3.diff(l6, "seconds").seconds;
        case "milliseconds":
        case "millisecond":
        case "ms":
        default:
          return c3.diff(l6).milliseconds;
        case "hours":
        case "hour":
        case "h":
          return c3.diff(l6, "hours").hours;
        case "years":
        case "year":
        case "y":
          return c3.diff(l6, "years").years;
      }
    });
  }, D4.dateadd = function(t6, r3) {
    return w6(t6, r3, (u3, o2, l6) => {
      V(l6, 2, 3, t6, r3);
      const i4 = ie(l6[0]);
      if (null === i4)
        return null;
      let f2 = re(l6[1]);
      if (isNaN(f2))
        return i4.toJSDate();
      let g3 = "milliseconds";
      switch (K(l6[2]).toLowerCase()) {
        case "days":
        case "day":
        case "d":
          g3 = "days", f2 = H(f2);
          break;
        case "months":
        case "month":
          g3 = "months", f2 = H(f2);
          break;
        case "minutes":
        case "minute":
        case "m":
          g3 = "M" === l6[2] ? "months" : "minutes";
          break;
        case "seconds":
        case "second":
        case "s":
          g3 = "seconds";
          break;
        case "milliseconds":
        case "millisecond":
        case "ms":
          g3 = "milliseconds";
          break;
        case "hours":
        case "hour":
        case "h":
          g3 = "hours";
          break;
        case "years":
        case "year":
        case "y":
          g3 = "years";
      }
      return i4.plus({ [g3]: f2 }).toJSDate();
    });
  };
}

// node_modules/@arcgis/core/arcade/functions/geometry.js
function M3(e5) {
  return e5 && "esri.arcade.Feature" === e5.arcadeDeclaredClass;
}
function C2(D4, C4) {
  D4.ringisclockwise = function(e5, n3) {
    return C4(e5, n3, (o2, s4, l6) => {
      V(l6, 1, 1, e5, n3);
      let c3 = [], f2 = false, u3 = false;
      if (null === l6[0])
        return false;
      if (Y(l6[0])) {
        for (const t6 of l6[0]) {
          if (!(t6 instanceof w))
            throw new t(e5, e.InvalidParameter, n3);
          c3.push(t6.hasZ ? t6.hasM ? [t6.x, t6.y, t6.z, t6.m] : [t6.x, t6.y, t6.z] : [t6.x, t6.y]);
        }
        c3.length > 0 && (f2 = l6[0][0].hasZ, u3 = l6[0][0].hasM);
      } else if (l6[0] instanceof i)
        c3 = l6[0]._elements, c3.length > 0 && (f2 = l6[0]._hasZ, u3 = l6[0]._hasM);
      else {
        if (!E(l6[0]))
          throw new t(e5, e.InvalidParameter, n3);
        for (const t6 of l6[0].toArray()) {
          if (!(t6 instanceof w))
            throw new t(e5, e.InvalidParameter, n3);
          c3.push(t6.hasZ ? t6.hasM ? [t6.x, t6.y, t6.z, t6.m] : [t6.x, t6.y, t6.z] : [t6.x, t6.y]);
        }
        c3.length > 0 && (f2 = l6[0].get(0).hasZ, u3 = l6[0].get(0).hasM);
      }
      return !(c3.length < 3) && h(c3, u3, f2);
    });
  }, D4.polygon = function(t6, a3) {
    return C4(t6, a3, (i4, l6, c3) => {
      V(c3, 1, 1, t6, a3);
      let f2 = null;
      if (c3[0] instanceof J2) {
        if (f2 = se(g.parseGeometryFromDictionary(c3[0]), t6.spatialReference), f2 instanceof v == false)
          throw new t(t6, e.InvalidParameter, a3);
      } else
        f2 = c3[0] instanceof v ? v2(c3[0].toJSON()) : se(new v(JSON.parse(c3[0])), t6.spatialReference);
      if (null !== f2 && false === f2.spatialReference.equals(t6.spatialReference))
        throw new t(t6, e.WrongSpatialReference, a3);
      return ue(f2);
    });
  }, D4.polyline = function(t6, a3) {
    return C4(t6, a3, (i4, l6, c3) => {
      V(c3, 1, 1, t6, a3);
      let f2 = null;
      if (c3[0] instanceof J2) {
        if (f2 = se(g.parseGeometryFromDictionary(c3[0]), t6.spatialReference), f2 instanceof m == false)
          throw new t(t6, e.InvalidParameter, a3);
      } else
        f2 = c3[0] instanceof m ? v2(c3[0].toJSON()) : se(new m(JSON.parse(c3[0])), t6.spatialReference);
      if (null !== f2 && false === f2.spatialReference.equals(t6.spatialReference))
        throw new t(t6, e.WrongSpatialReference, a3);
      return ue(f2);
    });
  }, D4.point = function(t6, a3) {
    return C4(t6, a3, (i4, l6, c3) => {
      V(c3, 1, 1, t6, a3);
      let f2 = null;
      if (c3[0] instanceof J2) {
        if (f2 = se(g.parseGeometryFromDictionary(c3[0]), t6.spatialReference), f2 instanceof w == false)
          throw new t(t6, e.InvalidParameter, a3);
      } else
        f2 = c3[0] instanceof w ? v2(c3[0].toJSON()) : se(new w(JSON.parse(c3[0])), t6.spatialReference);
      if (null !== f2 && false === f2.spatialReference.equals(t6.spatialReference))
        throw new t(t6, e.WrongSpatialReference, a3);
      return ue(f2);
    });
  }, D4.multipoint = function(t6, a3) {
    return C4(t6, a3, (i4, l6, c3) => {
      V(c3, 1, 1, t6, a3);
      let f2 = null;
      if (c3[0] instanceof J2) {
        if (f2 = se(g.parseGeometryFromDictionary(c3[0]), t6.spatialReference), f2 instanceof u == false)
          throw new t(t6, e.InvalidParameter, a3);
      } else
        f2 = c3[0] instanceof u ? v2(c3[0].toJSON()) : se(new u(JSON.parse(c3[0])), t6.spatialReference);
      if (null !== f2 && false === f2.spatialReference.equals(t6.spatialReference))
        throw new t(t6, e.WrongSpatialReference, a3);
      return ue(f2);
    });
  }, D4.extent = function(t6, a3) {
    return C4(t6, a3, (i4, c3, f2) => {
      var _a;
      f2 = pe(f2), V(f2, 1, 1, t6, a3);
      let u3 = null;
      if (f2[0] instanceof J2)
        u3 = se(g.parseGeometryFromDictionary(f2[0]), t6.spatialReference);
      else if (f2[0] instanceof w) {
        const e5 = { xmin: f2[0].x, ymin: f2[0].y, xmax: f2[0].x, ymax: f2[0].y, spatialReference: f2[0].spatialReference.toJSON() }, n3 = f2[0];
        n3.hasZ ? (e5.zmin = n3.z, e5.zmax = n3.z) : n3.hasM && (e5.mmin = n3.m, e5.mmax = n3.m), u3 = v2(e5);
      } else
        u3 = f2[0] instanceof v || f2[0] instanceof m || f2[0] instanceof u ? v2((_a = f2[0].extent) == null ? void 0 : _a.toJSON()) : f2[0] instanceof w2 ? v2(f2[0].toJSON()) : se(new w2(JSON.parse(f2[0])), t6.spatialReference);
      if (null !== u3 && false === u3.spatialReference.equals(t6.spatialReference))
        throw new t(t6, e.WrongSpatialReference, a3);
      return ue(u3);
    });
  }, D4.geometry = function(t6, a3) {
    return C4(t6, a3, (i4, l6, c3) => {
      V(c3, 1, 1, t6, a3);
      let f2 = null;
      if (null === c3[0])
        return null;
      if (f2 = M3(c3[0]) ? se(c3[0].geometry(), t6.spatialReference) : c3[0] instanceof J2 ? se(g.parseGeometryFromDictionary(c3[0]), t6.spatialReference) : se(v2(JSON.parse(c3[0])), t6.spatialReference), null !== f2 && false === f2.spatialReference.equals(t6.spatialReference))
        throw new t(t6, e.WrongSpatialReference, a3);
      return ue(f2);
    });
  }, D4.setgeometry = function(e5, n3) {
    return C4(e5, n3, (t6, a3, i4) => {
      if (V(i4, 2, 2, e5, n3), !M3(i4[0]))
        throw new t(e5, e.InvalidParameter, n3);
      if (true === i4[0].immutable)
        throw new t(e5, e.Immutable, n3);
      if (!(i4[1] instanceof p || null === i4[1]))
        throw new t(e5, e.InvalidParameter, n3);
      return i4[0]._geometry = i4[1], k2;
    });
  }, D4.feature = function(t6, r3) {
    return C4(t6, r3, (a3, i4, s4) => {
      if (0 === s4.length)
        throw new t(t6, e.WrongNumberOfParameters, r3);
      let l6 = null;
      if (1 === s4.length)
        if (w3(s4[0]))
          l6 = g.fromJson(JSON.parse(s4[0]));
        else if (M3(s4[0]))
          l6 = g.createFromArcadeFeature(s4[0]);
        else if (s4[0] instanceof p)
          l6 = g.createFromGraphicLikeObject(s4[0], null, null);
        else {
          if (!(s4[0] instanceof J2))
            throw new t(t6, e.InvalidParameter, r3);
          {
            let t7 = s4[0].hasField("geometry") ? s4[0].field("geometry") : null, r4 = s4[0].hasField("attributes") ? s4[0].field("attributes") : null;
            null !== t7 && t7 instanceof J2 && (t7 = g.parseGeometryFromDictionary(t7)), null !== r4 && (r4 = g.parseAttributesFromDictionary(r4)), l6 = g.createFromGraphicLikeObject(t7, r4, null);
          }
        }
      else if (2 === s4.length) {
        let a4 = null, i5 = null;
        if (null !== s4[0])
          if (s4[0] instanceof p)
            a4 = s4[0];
          else {
            if (!(a4 instanceof J2))
              throw new t(t6, e.InvalidParameter, r3);
            a4 = g.parseGeometryFromDictionary(s4[0]);
          }
        if (null !== s4[1]) {
          if (!(s4[1] instanceof J2))
            throw new t(t6, e.InvalidParameter, r3);
          i5 = g.parseAttributesFromDictionary(s4[1]);
        }
        l6 = g.createFromGraphicLikeObject(a4, i5, null);
      } else {
        let a4 = null;
        const i5 = {};
        if (null !== s4[0])
          if (s4[0] instanceof p)
            a4 = s4[0];
          else {
            if (!(a4 instanceof J2))
              throw new t(t6, e.InvalidParameter, r3);
            a4 = g.parseGeometryFromDictionary(s4[0]);
          }
        for (let e5 = 1; e5 < s4.length; e5 += 2) {
          const n3 = K(s4[e5]), a5 = s4[e5 + 1];
          if (!(null == a5 || w3(a5) || isNaN(a5) || z(a5) || Z(a5) || _(a5)))
            throw new t(t6, e.InvalidParameter, r3);
          if (F(a5) || false === I(a5))
            throw new t(t6, e.InvalidParameter, r3);
          i5[n3] = a5 === k2 ? null : a5;
        }
        l6 = g.createFromGraphicLikeObject(a4, i5, null);
      }
      return l6._geometry = se(l6.geometry(), t6.spatialReference), l6.immutable = false, l6;
    });
  }, D4.dictionary = function(n3, t6) {
    return C4(n3, t6, (r3, o2, s4) => {
      if (0 === s4.length) {
        const n4 = new J2();
        return n4.immutable = false, n4;
      }
      if (1 === s4.length && w3(s4[0]))
        try {
          const n4 = JSON.parse(s4[0]), t7 = J2.convertObjectToArcadeDictionary(n4, false);
          return t7.immutable = false, t7;
        } catch (y4) {
          throw new t(n3, e.InvalidParameter, t6);
        }
      if (s4.length % 2 != 0)
        throw new t(n3, e.WrongNumberOfParameters, t6);
      const l6 = {};
      for (let e5 = 0; e5 < s4.length; e5 += 2) {
        const r4 = K(s4[e5]), o3 = s4[e5 + 1];
        if (!(null == o3 || w3(o3) || isNaN(o3) || z(o3) || Z(o3) || _(o3) || Y(o3) || E(o3)))
          throw new t(n3, e.InvalidParameter, t6);
        if (F(o3))
          throw new t(n3, e.InvalidParameter, t6);
        l6[r4] = o3 === k2 ? null : o3;
      }
      const d5 = new J2(l6);
      return d5.immutable = false, d5;
    });
  }, D4.haskey = function(n3, t6) {
    return C4(n3, t6, (a3, i4, o2) => {
      V(o2, 2, 2, n3, t6);
      const s4 = K(o2[1]);
      if (M3(o2[0]))
        return o2[0].hasField(s4);
      if (o2[0] instanceof J2)
        return o2[0].hasField(s4);
      if (o2[0] instanceof p) {
        const e5 = W2(o2[0], s4, null, null, 2);
        return !e5 || "notfound" !== e5.keystate;
      }
      throw new t(n3, e.InvalidParameter, t6);
    });
  }, D4.hasvalue = function(n3, t6) {
    return C4(n3, t6, (a3, i4, o2) => {
      if (V(o2, 2, 2, n3, t6), null === o2[0] || null === o2[1])
        return false;
      const s4 = K(o2[1]);
      if (J(o2[0]))
        return !!o2[0].hasField(s4) && null !== o2[0].field(s4);
      if (o2[0] instanceof J2)
        return !!o2[0].hasField(s4) && null !== o2[0].field(s4);
      if (o2[0] instanceof p) {
        return null !== W2(o2[0], s4, null, null, 0);
      }
      return false;
    });
  }, D4.indexof = function(e5, n3) {
    return C4(e5, n3, (t6, o2, s4) => {
      V(s4, 2, 2, e5, n3);
      const l6 = s4[1];
      if (Y(s4[0])) {
        for (let e6 = 0; e6 < s4[0].length; e6++)
          if (X(l6, s4[0][e6]))
            return e6;
        return -1;
      }
      if (E(s4[0])) {
        const e6 = s4[0].length();
        for (let n4 = 0; n4 < e6; n4++)
          if (X(l6, s4[0].get(n4)))
            return n4;
        return -1;
      }
      throw new t(e5, e.InvalidParameter, n3);
    });
  }, D4.angle = function(e5, n3) {
    return C4(e5, n3, (t6, a3, i4) => {
      if (i4 = pe(i4), V(i4, 2, 3, e5, n3), !(i4[0] instanceof w))
        throw new t(e5, e.InvalidParameter, n3);
      if (!(i4[1] instanceof w))
        throw new t(e5, e.InvalidParameter, n3);
      if (i4.length > 2 && !(i4[2] instanceof w))
        throw new t(e5, e.InvalidParameter, n3);
      return 2 === i4.length ? p3(i4[0], i4[1]) : P3(i4[0], i4[1], i4[2]);
    });
  }, D4.bearing = function(e5, n3) {
    return C4(e5, n3, (t6, a3, i4) => {
      if (i4 = pe(i4), V(i4, 2, 3, e5, n3), !(i4[0] instanceof w))
        throw new t(e5, e.InvalidParameter, n3);
      if (!(i4[1] instanceof w))
        throw new t(e5, e.InvalidParameter, n3);
      if (i4.length > 2 && !(i4[2] instanceof w))
        throw new t(e5, e.InvalidParameter, n3);
      return 2 === i4.length ? M(i4[0], i4[1]) : d(i4[0], i4[1], i4[2]);
    });
  }, D4.isselfintersecting = function(e5, n3) {
    return C4(e5, n3, (t6, o2, s4) => {
      s4 = pe(s4), V(s4, 1, 1, e5, n3);
      let c3 = s4[0];
      if (c3 instanceof v)
        return c3.isSelfIntersecting;
      if (c3 instanceof m)
        return c3 = c3.paths, Z2(c3);
      if (c3 instanceof u) {
        const e6 = c3.points;
        for (let n4 = 0; n4 < e6.length; n4++)
          for (let t7 = 0; t7 < e6.length; t7++)
            if (t7 !== n4) {
              let r3 = true;
              for (let a3 = 0; a3 < e6[n4].length; a3++)
                if (e6[n4][a3] !== e6[t7][a3]) {
                  r3 = false;
                  break;
                }
              if (true === r3)
                return true;
            }
      }
      return !(!Y(c3) && !E(c3)) && (c3 = Se(c3, e5.spatialReference), null !== c3 && (c3 = c3.paths), Z2(c3));
    });
  };
}
var Z3 = 0;
function W2(n3, r3, a3, i4, o2 = 1) {
  let s4;
  switch (r3 = r3.toLowerCase()) {
    case "hasz": {
      const e5 = n3.hasZ;
      return void 0 !== e5 && e5;
    }
    case "hasm": {
      const e5 = n3.hasM;
      return void 0 !== e5 && e5;
    }
    case "spatialreference": {
      let t6 = n3.spatialReference._arcadeCacheId;
      if (void 0 === t6) {
        let e5 = true;
        Object.freeze && Object.isFrozen(n3.spatialReference) && (e5 = false), e5 && (Z3++, n3.spatialReference._arcadeCacheId = Z3, t6 = Z3);
      }
      const r4 = new J2({ wkt: n3.spatialReference.wkt, wkid: n3.spatialReference.wkid });
      return void 0 !== t6 && (r4._arcadeCacheId = "SPREF" + t6.toString()), r4;
    }
  }
  switch (n3.type) {
    case "extent":
      switch (r3) {
        case "xmin":
        case "xmax":
        case "ymin":
        case "ymax":
        case "zmin":
        case "zmax":
        case "mmin":
        case "mmax": {
          const e5 = n3[r3];
          return void 0 !== e5 ? e5 : null;
        }
        case "type":
          return "Extent";
      }
      break;
    case "polygon":
      switch (r3) {
        case "rings":
          s4 = n3.cache._arcadeCacheId, void 0 === s4 && (Z3++, s4 = Z3, n3.cache._arcadeCacheId = s4);
          return new h2(n3.rings, n3.spatialReference, true === n3.hasZ, true === n3.hasM, s4);
        case "type":
          return "Polygon";
      }
      break;
    case "point":
      switch (r3) {
        case "x":
        case "y":
        case "z":
        case "m":
          return void 0 !== n3[r3] ? n3[r3] : null;
        case "type":
          return "Point";
      }
      break;
    case "polyline":
      switch (r3) {
        case "paths":
          s4 = n3.cache._arcadeCacheId, void 0 === s4 && (Z3++, s4 = Z3, n3.cache._arcadeCacheId = s4);
          return new h2(n3.paths, n3.spatialReference, true === n3.hasZ, true === n3.hasM, s4);
        case "type":
          return "Polyline";
      }
      break;
    case "multipoint":
      switch (r3) {
        case "points":
          s4 = n3.cache._arcadeCacheId, void 0 === s4 && (Z3++, s4 = Z3, n3.cache._arcadeCacheId = s4);
          return new i(n3.points, n3.spatialReference, true === n3.hasZ, true === n3.hasM, s4, 1);
        case "type":
          return "Multipoint";
      }
  }
  if (1 === o2)
    throw new t(a3, e.InvalidIdentifier, i4);
  return 2 === o2 ? { keystate: "notfound" } : null;
}

// node_modules/@arcgis/core/arcade/functions/maths.js
function l4(n3, t6, r3) {
  return void 0 === r3 || 0 == +r3 ? Math[n3](t6) : (t6 = +t6, r3 = +r3, isNaN(t6) || "number" != typeof r3 || r3 % 1 != 0 ? NaN : (t6 = t6.toString().split("e"), +((t6 = (t6 = Math[n3](+(t6[0] + "e" + (t6[1] ? +t6[1] - r3 : -r3)))).toString().split("e"))[0] + "e" + (t6[1] ? +t6[1] + r3 : r3))));
}
function N2(N4, h5) {
  function m6(n3, t6, r3) {
    const u3 = re(n3);
    return isNaN(u3) ? u3 : isNaN(t6) || isNaN(r3) || t6 > r3 ? NaN : u3 < t6 ? t6 : u3 > r3 ? r3 : u3;
  }
  N4.number = function(a3, f2) {
    return h5(a3, f2, (s4, l6, N5) => {
      V(N5, 1, 2, a3, f2);
      const h6 = N5[0];
      if (Z(h6))
        return h6;
      if (null === h6)
        return 0;
      if (z(h6))
        return Number(h6);
      if (_(h6))
        return Number(h6);
      if (Y(h6))
        return NaN;
      if ("" === h6)
        return Number(h6);
      if (void 0 === h6)
        return Number(h6);
      if (w3(h6)) {
        if (void 0 !== N5[1]) {
          let n3 = R(N5[1], "\u2030", "");
          return n3 = R(n3, "\xA4", ""), p2(h6, { pattern: n3 });
        }
        return Number(h6.trim());
      }
      return Number(h6);
    });
  }, N4.abs = function(t6, r3) {
    return h5(t6, r3, (u3, e5, o2) => (V(o2, 1, 1, t6, r3), Math.abs(re(o2[0]))));
  }, N4.acos = function(t6, r3) {
    return h5(t6, r3, (u3, e5, o2) => (V(o2, 1, 1, t6, r3), Math.acos(re(o2[0]))));
  }, N4.asin = function(t6, r3) {
    return h5(t6, r3, (u3, e5, o2) => (V(o2, 1, 1, t6, r3), Math.asin(re(o2[0]))));
  }, N4.atan = function(t6, r3) {
    return h5(t6, r3, (u3, e5, o2) => (V(o2, 1, 1, t6, r3), Math.atan(re(o2[0]))));
  }, N4.atan2 = function(t6, r3) {
    return h5(t6, r3, (u3, e5, o2) => (V(o2, 2, 2, t6, r3), Math.atan2(re(o2[0]), re(o2[1]))));
  }, N4.ceil = function(t6, r3) {
    return h5(t6, r3, (u3, e5, o2) => {
      if (V(o2, 1, 2, t6, r3), 2 === o2.length) {
        let n3 = re(o2[1]);
        return isNaN(n3) && (n3 = 0), l4("ceil", re(o2[0]), -1 * n3);
      }
      return Math.ceil(re(o2[0]));
    });
  }, N4.round = function(t6, r3) {
    return h5(t6, r3, (u3, e5, o2) => {
      if (V(o2, 1, 2, t6, r3), 2 === o2.length) {
        let n3 = re(o2[1]);
        return isNaN(n3) && (n3 = 0), l4("round", re(o2[0]), -1 * n3);
      }
      return Math.round(re(o2[0]));
    });
  }, N4.floor = function(t6, r3) {
    return h5(t6, r3, (u3, e5, o2) => {
      if (V(o2, 1, 2, t6, r3), 2 === o2.length) {
        let n3 = re(o2[1]);
        return isNaN(n3) && (n3 = 0), l4("floor", re(o2[0]), -1 * n3);
      }
      return Math.floor(re(o2[0]));
    });
  }, N4.cos = function(t6, r3) {
    return h5(t6, r3, (u3, e5, o2) => (V(o2, 1, 1, t6, r3), Math.cos(re(o2[0]))));
  }, N4.isnan = function(t6, r3) {
    return h5(t6, r3, (u3, e5, o2) => (V(o2, 1, 1, t6, r3), "number" == typeof o2[0] && isNaN(o2[0])));
  }, N4.exp = function(t6, r3) {
    return h5(t6, r3, (u3, e5, o2) => (V(o2, 1, 1, t6, r3), Math.exp(re(o2[0]))));
  }, N4.log = function(t6, r3) {
    return h5(t6, r3, (u3, e5, o2) => (V(o2, 1, 1, t6, r3), Math.log(re(o2[0]))));
  }, N4.pow = function(t6, r3) {
    return h5(t6, r3, (u3, e5, o2) => (V(o2, 2, 2, t6, r3), re(o2[0]) ** re(o2[1])));
  }, N4.random = function(t6, r3) {
    return h5(t6, r3, (u3, e5, o2) => (V(o2, 0, 0, t6, r3), Math.random()));
  }, N4.sin = function(t6, r3) {
    return h5(t6, r3, (u3, e5, o2) => (V(o2, 1, 1, t6, r3), Math.sin(re(o2[0]))));
  }, N4.sqrt = function(t6, r3) {
    return h5(t6, r3, (u3, e5, o2) => (V(o2, 1, 1, t6, r3), Math.sqrt(re(o2[0]))));
  }, N4.tan = function(t6, r3) {
    return h5(t6, r3, (u3, e5, o2) => (V(o2, 1, 1, t6, r3), Math.tan(re(o2[0]))));
  }, N4.defaultvalue = function(t6, r3) {
    return h5(t6, r3, (u3, e5, o2) => (V(o2, 2, 2, t6, r3), null === o2[0] || "" === o2[0] || void 0 === o2[0] ? o2[1] : o2[0]));
  }, N4.isempty = function(t6, r3) {
    return h5(t6, r3, (u3, e5, o2) => (V(o2, 1, 1, t6, r3), null === o2[0] || ("" === o2[0] || void 0 === o2[0])));
  }, N4.boolean = function(t6, r3) {
    return h5(t6, r3, (u3, e5, o2) => {
      V(o2, 1, 1, t6, r3);
      const i4 = o2[0];
      return le(i4);
    });
  }, N4.constrain = function(t6, r3) {
    return h5(t6, r3, (u3, o2, i4) => {
      V(i4, 3, 3, t6, r3);
      const f2 = re(i4[1]), c3 = re(i4[2]);
      if (Y(i4[0])) {
        const n3 = [];
        for (const t7 of i4[0])
          n3.push(m6(t7, f2, c3));
        return n3;
      }
      if (E(i4[0])) {
        const n3 = [];
        for (let t7 = 0; t7 < i4[0].length(); t7++)
          n3.push(m6(i4[0].get(t7), f2, c3));
        return n3;
      }
      return m6(i4[0], f2, c3);
    });
  };
}

// node_modules/@arcgis/core/arcade/functions/stats.js
function a2(n3, r3, t6, i4) {
  if (1 === i4.length) {
    if (Y(i4[0]))
      return l2(n3, i4[0], -1);
    if (E(i4[0]))
      return l2(n3, i4[0].toArray(), -1);
  }
  return l2(n3, i4, -1);
}
function f(o2, f2) {
  o2.stdev = function(n3, r3) {
    return f2(n3, r3, (n4, r4, t6) => a2("stdev", n4, r4, t6));
  }, o2.variance = function(n3, r3) {
    return f2(n3, r3, (n4, r4, t6) => a2("variance", n4, r4, t6));
  }, o2.average = function(n3, r3) {
    return f2(n3, r3, (n4, r4, t6) => a2("mean", n4, r4, t6));
  }, o2.mean = function(n3, r3) {
    return f2(n3, r3, (n4, r4, t6) => a2("mean", n4, r4, t6));
  }, o2.sum = function(n3, r3) {
    return f2(n3, r3, (n4, r4, t6) => a2("sum", n4, r4, t6));
  }, o2.min = function(n3, r3) {
    return f2(n3, r3, (n4, r4, t6) => a2("min", n4, r4, t6));
  }, o2.max = function(n3, r3) {
    return f2(n3, r3, (n4, r4, t6) => a2("max", n4, r4, t6));
  }, o2.distinct = function(n3, r3) {
    return f2(n3, r3, (n4, r4, t6) => a2("distinct", n4, r4, t6));
  }, o2.count = function(o3, a3) {
    return f2(o3, a3, (f3, c3, m6) => {
      if (V(m6, 1, 1, o3, a3), Y(m6[0]) || w3(m6[0]))
        return m6[0].length;
      if (E(m6[0]))
        return m6[0].length();
      throw new t(o3, e.InvalidParameter, a3);
    });
  };
}

// node_modules/@arcgis/core/arcade/functions/convertdirection.js
var l5 = (e5) => (n3, t6, r3) => (r3 = r3 || 14, +e5(n3, t6).toFixed(r3));
var d4 = (e5, n3) => e5 + n3;
var m5 = (e5, n3) => e5 * n3;
var g2 = (e5, n3) => e5 / n3;
var _2 = (e5, n3, t6) => l5(d4)(e5, n3, t6);
var w5 = (e5, n3, t6) => l5(m5)(e5, n3, t6);
var A = (e5, n3, t6) => l5(g2)(e5, n3, t6);
var D2 = 360;
var p5 = 400;
var E2 = 2 * Math.PI;
var T2 = 3600;
var S = 3240;
var R2 = 60;
var M4 = 60;
var F3 = 180 * T2 / Math.PI;
var v4 = D2 * R2 * M4;
var L2 = 90 * T2;
var U2 = 180 * T2;
var N3 = 270 * T2;
var x2 = String.fromCharCode(7501);
var z2 = "\xB0";
function O2(e5) {
  if (false === w3(e5))
    throw new t(null, e.InvalidParameter, null);
  return e5;
}
function G2(e5, n3) {
  const t6 = 10 ** n3;
  return Math.round(e5 * t6) / t6;
}
function I2(e5, n3) {
  return e5 % n3;
}
function b(e5) {
  const n3 = parseFloat(e5.toString().replace(Math.trunc(e5).toString(), "0")) * Math.sign(e5);
  if (e5 < 0) {
    return { fraction: n3, integer: Math.ceil(e5) };
  }
  return { fraction: n3, integer: Math.floor(e5) };
}
var H2;
var y3;
var q;
var k3;
function C3(e5, n3) {
  switch (e5) {
    case H2.north:
      return "SHORT" === n3 ? "N" : "North";
    case H2.east:
      return "SHORT" === n3 ? "E" : "East";
    case H2.south:
      return "SHORT" === n3 ? "S" : "South";
    case H2.west:
      return "SHORT" === n3 ? "W" : "West";
  }
}
function P4(e5, n3, t6) {
  for (; e5.length < t6; )
    e5 = n3 + e5;
  return e5;
}
function Q(e5, n3) {
  return e5 - Math.floor(e5 / n3) * n3;
}
function j(e5) {
  switch (e5) {
    case y3.truncated_degrees:
    case y3.decimal_degrees:
      return D2;
    case y3.radians:
      return E2;
    case y3.gradians:
      return p5;
    case y3.seconds:
      return v4;
    case y3.fractional_degree_minutes:
      return R2;
    case y3.fractional_minute_seconds:
      return M4;
    default:
      throw new t(null, e.LogicError, null, { reason: "unsupported evaluations" });
  }
}
function W3(e5) {
  switch (e5.toUpperCase().trim()) {
    case "NORTH":
    case "NORTHAZIMUTH":
    case "NORTH AZIMUTH":
      return q.north_azimuth;
    case "POLAR":
      return q.polar;
    case "QUADRANT":
      return q.quadrant;
    case "SOUTH":
    case "SOUTHAZIMUTH":
    case "SOUTH AZIMUTH":
      return q.south_azimuth;
  }
  throw new t(null, e.LogicError, null, { reason: "unsupported directionType" });
}
function Z4(e5) {
  switch (e5.toUpperCase().trim()) {
    case "D":
    case "DD":
    case "DECIMALDEGREE":
    case "DECIMAL DEGREE":
    case "DEGREE":
    case "DECIMALDEGREES":
    case "DECIMAL DEGREES":
    case "DEGREES":
      return y3.decimal_degrees;
    case "DMS":
    case "DEGREESMINUTESSECONDS":
    case "DEGREES MINUTES SECONDS":
      return y3.degrees_minutes_seconds;
    case "R":
    case "RAD":
    case "RADS":
    case "RADIAN":
    case "RADIANS":
      return y3.radians;
    case "G":
    case "GON":
    case "GONS":
    case "GRAD":
    case "GRADS":
    case "GRADIAN":
    case "GRADIANS":
      return y3.gradians;
  }
  throw new t(null, e.LogicError, null, { reason: "unsupported units" });
}
!function(e5) {
  e5[e5.north = 0] = "north", e5[e5.east = 1] = "east", e5[e5.south = 2] = "south", e5[e5.west = 3] = "west";
}(H2 || (H2 = {})), function(e5) {
  e5[e5.decimal_degrees = 1] = "decimal_degrees", e5[e5.seconds = 2] = "seconds", e5[e5.degrees_minutes_seconds = 3] = "degrees_minutes_seconds", e5[e5.radians = 4] = "radians", e5[e5.gradians = 5] = "gradians", e5[e5.truncated_degrees = 6] = "truncated_degrees", e5[e5.fractional_degree_minutes = 7] = "fractional_degree_minutes", e5[e5.fractional_minute_seconds = 8] = "fractional_minute_seconds";
}(y3 || (y3 = {})), function(e5) {
  e5[e5.north_azimuth = 1] = "north_azimuth", e5[e5.polar = 2] = "polar", e5[e5.quadrant = 3] = "quadrant", e5[e5.south_azimuth = 4] = "south_azimuth";
}(q || (q = {})), function(e5) {
  e5[e5.meridian = 0] = "meridian", e5[e5.direction = 1] = "direction";
}(k3 || (k3 = {}));
var B = class {
  constructor(e5, n3, t6) {
    this.m_degrees = e5, this.m_minutes = n3, this.m_seconds = t6;
  }
  getField(e5) {
    switch (e5) {
      case y3.decimal_degrees:
      case y3.truncated_degrees:
        return this.m_degrees;
      case y3.fractional_degree_minutes:
        return this.m_minutes;
      case y3.seconds:
      case y3.fractional_minute_seconds:
        return this.m_seconds;
      default:
        throw new t(null, e.LogicError, null, { reason: "unexpected evaluation" });
    }
  }
  static secondsToDMS(e5) {
    const n3 = b(e5).fraction;
    let t6 = b(e5).integer;
    const r3 = Math.floor(t6 / T2);
    t6 -= r3 * T2;
    const s4 = Math.floor(t6 / M4);
    return t6 -= s4 * M4, new B(r3, s4, t6 + n3);
  }
  static numberToDms(e5) {
    const n3 = b(e5).fraction, t6 = b(e5).integer, r3 = w5(b(100 * n3).fraction, 100), s4 = b(100 * n3).integer;
    return new B(t6, s4, r3);
  }
  format(e5, n3) {
    let t6 = G2(this.m_seconds, n3), r3 = this.m_minutes, s4 = this.m_degrees;
    if (e5 === y3.seconds || e5 === y3.fractional_minute_seconds)
      M4 <= t6 && (t6 -= M4, ++r3), R2 <= r3 && (r3 = 0, ++s4), D2 <= s4 && (s4 = 0);
    else if (e5 === y3.fractional_degree_minutes)
      t6 = 0, r3 = 30 <= this.m_seconds ? this.m_minutes + 1 : this.m_minutes, s4 = this.m_degrees, R2 <= r3 && (r3 = 0, ++s4), D2 <= s4 && (s4 = 0);
    else if (e5 === y3.decimal_degrees || e5 === y3.truncated_degrees) {
      const e6 = A(this.m_seconds, T2), n4 = A(this.m_minutes, R2);
      s4 = Math.round(this.m_degrees + n4 + e6), r3 = 0, t6 = 0;
    }
    return new B(s4, r3, t6);
  }
  static dmsToSeconds(e5, n3, t6) {
    return e5 * T2 + n3 * M4 + t6;
  }
};
var V2 = class {
  constructor(e5, n3, t6) {
    this.meridian = e5, this.angle = n3, this.direction = t6;
  }
  fetchAzimuth(e5) {
    return e5 === k3.meridian ? this.meridian : this.direction;
  }
};
var X2 = class {
  constructor(e5) {
    this._angle = e5;
  }
  static createFromAngleAndDirection(e5, n3) {
    return new X2(new K2(X2._convertDirectionFormat(e5.extractAngularUnits(y3.seconds), n3, q.north_azimuth)));
  }
  getAngle(e5) {
    const n3 = this._angle.extractAngularUnits(y3.seconds);
    switch (e5) {
      case q.north_azimuth:
      case q.south_azimuth:
      case q.polar:
        return new K2(X2._convertDirectionFormat(n3, q.north_azimuth, e5));
      case q.quadrant: {
        const e6 = X2.secondsNorthAzimuthToQuadrant(n3);
        return new K2(e6.angle);
      }
    }
  }
  getMeridian(e5) {
    const n3 = this._angle.extractAngularUnits(y3.seconds);
    switch (e5) {
      case q.north_azimuth:
        return H2.north;
      case q.south_azimuth:
        return H2.south;
      case q.polar:
        return H2.east;
      case q.quadrant:
        return X2.secondsNorthAzimuthToQuadrant(n3).meridian;
    }
  }
  getDirection(e5) {
    const n3 = this._angle.extractAngularUnits(y3.seconds);
    switch (e5) {
      case q.north_azimuth:
        return H2.east;
      case q.south_azimuth:
        return H2.west;
      case q.polar:
        return H2.north;
      case q.quadrant:
        return X2.secondsNorthAzimuthToQuadrant(n3).direction;
    }
  }
  static secondsNorthAzimuthToQuadrant(e5) {
    const n3 = e5 <= L2 || e5 >= N3 ? H2.north : H2.south, t6 = n3 === H2.north ? Math.min(v4 - e5, e5) : Math.abs(e5 - U2), r3 = e5 > U2 ? H2.west : H2.east;
    return new V2(n3, t6, r3);
  }
  static createFromAngleMeridianAndDirection(e5, n3, t6) {
    return new X2(new K2(X2.secondsQuadrantToNorthAzimuth(e5.extractAngularUnits(y3.seconds), n3, t6)));
  }
  static secondsQuadrantToNorthAzimuth(e5, n3, t6) {
    return n3 === H2.north ? t6 === H2.east ? e5 : v4 - e5 : t6 === H2.east ? U2 - e5 : U2 + e5;
  }
  static _convertDirectionFormat(e5, r3, s4) {
    let a3 = 0;
    switch (r3) {
      case q.north_azimuth:
        a3 = e5;
        break;
      case q.polar:
        a3 = L2 - e5;
        break;
      case q.quadrant:
        throw new t(null, e.LogicError, null, { reason: "unexpected evaluation" });
      case q.south_azimuth:
        a3 = e5 + U2;
    }
    let i4 = 0;
    switch (s4) {
      case q.north_azimuth:
        i4 = a3;
        break;
      case q.polar:
        i4 = L2 - a3;
        break;
      case q.quadrant:
        throw new t(null, e.LogicError, null, { reason: "unexpected evaluation" });
      case q.south_azimuth:
        i4 = a3 - U2;
    }
    return i4 = I2(i4, v4), i4 < 0 ? v4 + i4 : i4;
  }
};
function J3(e5, r3, s4) {
  let a3 = null;
  switch (r3) {
    case y3.decimal_degrees:
      a3 = w5(e5, T2);
      break;
    case y3.seconds:
      a3 = e5;
      break;
    case y3.gradians:
      a3 = w5(e5, S);
      break;
    case y3.radians:
      a3 = w5(e5, F3);
      break;
    default:
      throw new t(null, e.LogicError, null, { reason: "unexpected evaluation" });
  }
  switch (s4) {
    case y3.decimal_degrees:
      return A(a3, T2);
    case y3.seconds:
      return a3;
    case y3.gradians:
      return A(a3, S);
    case y3.radians:
      return a3 / F3;
    default:
      throw new t(null, e.LogicError, null, { reason: "unexpected evaluation" });
  }
}
var K2 = class {
  constructor(e5) {
    this._seconds = e5;
  }
  static createFromAngleAndUnits(e5, n3) {
    return new K2(J3(e5, n3, y3.seconds));
  }
  extractAngularUnits(e5) {
    return J3(this._seconds, y3.seconds, Y2(e5));
  }
  static createFromDegreesMinutesSeconds(e5, n3, t6) {
    return new K2(_2(_2(w5(e5, T2), w5(n3, M4)), t6));
  }
};
function Y2(e5) {
  switch (c(e5), e5) {
    case y3.decimal_degrees:
    case y3.truncated_degrees:
    case y3.degrees_minutes_seconds:
      return y3.decimal_degrees;
    case y3.gradians:
      return y3.gradians;
    case y3.fractional_degree_minutes:
      return y3.fractional_degree_minutes;
    case y3.radians:
      return y3.radians;
    case y3.seconds:
    case y3.fractional_minute_seconds:
      return y3.seconds;
  }
}
var $ = class {
  constructor(e5, n3, t6, r3) {
    this.view = e5, this.angle = n3, this.merdian = t6, this.direction = r3, this._dms = null, this._formattedDms = null;
  }
  static createFromStringAndBearing(e5, n3, t6) {
    return new $(e5, n3.getAngle(t6), n3.getMeridian(t6), n3.getDirection(t6));
  }
  fetchAngle() {
    return this.angle;
  }
  fetchMeridian() {
    return this.merdian;
  }
  fetchDirection() {
    return this.direction;
  }
  fetchView() {
    return this.view;
  }
  fetchDms() {
    return null === this._dms && this._calculateDms(), this._dms;
  }
  fetchFormattedDms() {
    return null === this._formattedDms && this._calculateDms(), this._formattedDms;
  }
  _calculateDms() {
    let e5 = null, n3 = y3.truncated_degrees, t6 = 0;
    for (let r3 = 0; r3 < this.view.length; r3++) {
      const s4 = this.view[r3];
      switch (s4) {
        case "m":
          e5 = de(this.view, r3, s4), n3 = n3 === y3.truncated_degrees ? y3.fractional_degree_minutes : n3, r3 = e5.newpos;
          continue;
        case "s":
          e5 = de(this.view, r3, s4), n3 = y3.fractional_minute_seconds, t6 = t6 < e5.rounding ? e5.rounding : t6, r3 = e5.newpos;
          continue;
        default:
          continue;
      }
    }
    this._dms = B.secondsToDMS(this.angle.extractAngularUnits(y3.seconds)), this._formattedDms = B.secondsToDMS(this.angle.extractAngularUnits(y3.seconds)).format(n3, t6);
  }
};
function ee(e5, r3, s4, a3, i4) {
  let o2 = null;
  switch (r3) {
    case y3.decimal_degrees:
    case y3.radians:
    case y3.gradians:
      return o2 = Q(G2(e5.extractAngularUnits(r3), a3), j(r3)), P4(o2.toFixed(a3), "0", s4 + a3 + (a3 > 0 ? 1 : 0));
    case y3.truncated_degrees:
    case y3.fractional_degree_minutes:
      return o2 = Q(i4.fetchFormattedDms().getField(r3), j(r3)), P4(o2.toFixed(a3), "0", s4 + a3 + (a3 > 0 ? 1 : 0));
    case y3.fractional_minute_seconds:
      return o2 = Q(G2(i4.fetchDms().getField(r3), a3), j(r3)), P4(o2.toFixed(a3), "0", s4 + a3 + (a3 > 0 ? 1 : 0));
    default:
      throw new t(null, e.LogicError, null, { reason: "unexpected evaluation" });
  }
}
function ne(e5, r3, s4) {
  if (s4 === q.quadrant)
    throw new t(null, e.LogicError, null, { reason: "conversion error" });
  if (r3 === y3.degrees_minutes_seconds) {
    const n3 = B.numberToDms(e5);
    return X2.createFromAngleAndDirection(K2.createFromDegreesMinutesSeconds(n3.m_degrees, n3.m_minutes, n3.m_seconds), s4);
  }
  return X2.createFromAngleAndDirection(K2.createFromAngleAndUnits(e5, Y2(r3)), s4);
}
function te2(e5) {
  switch (re(e5)) {
    case 1:
      return { first: H2.north, second: H2.east };
    case 2:
      return { first: H2.south, second: H2.east };
    case 3:
      return { first: H2.south, second: H2.west };
    case 4:
      return { first: H2.north, second: H2.west };
  }
  return null;
}
function re2(e5) {
  switch (e5.toUpperCase().trim()) {
    case "N":
    case "NORTH":
      return H2.north;
    case "E":
    case "EAST":
      return H2.east;
    case "S":
    case "SOUTH":
      return H2.south;
    case "W":
    case "WEST":
      return H2.west;
  }
  return null;
}
function se2(e5) {
  const r3 = parseFloat(e5);
  if (Z(r3)) {
    if (isNaN(r3))
      throw new t(null, e.LogicError, null, { reason: "invalid conversion" });
    return r3;
  }
  throw new t(null, e.LogicError, null, { reason: "invalid conversion" });
}
function ae2(e5, s4, a3) {
  const i4 = a3 === q.quadrant;
  let o2 = null, c3 = null, u3 = 0, l6 = 0, d5 = 0;
  if (i4) {
    if (e5.length < 2)
      throw new t(null, e.LogicError, null, { reason: "conversion error" });
    d5 = 1;
    const s5 = te2(K(e5[e5.length - 1]));
    if (s5 ? (o2 = s5.first, c3 = s5.second) : (u3 = 1, o2 = re2(K(e5[0])), c3 = re2(K(e5[e5.length - 1]))), null === o2 || null === c3)
      throw new t(null, e.LogicError, null, { reason: "invalid conversion" });
  }
  switch (s4) {
    case y3.decimal_degrees:
    case y3.radians:
    case y3.gradians:
      if (0 === e5.length)
        throw new t(null, e.LogicError, null, { reason: "invalid conversion" });
      return i4 ? X2.createFromAngleMeridianAndDirection(K2.createFromAngleAndUnits(se2(e5[u3]), Y2(s4)), o2, c3) : X2.createFromAngleAndDirection(K2.createFromAngleAndUnits(se2(e5[u3]), Y2(s4)), a3);
    case y3.degrees_minutes_seconds:
      if (l6 = e5.length - d5 - u3, 3 === l6) {
        const n3 = K2.createFromDegreesMinutesSeconds(se2(e5[u3]), se2(e5[u3 + 1]), se2(e5[u3 + 2]));
        return i4 ? X2.createFromAngleMeridianAndDirection(n3, o2, c3) : X2.createFromAngleAndDirection(n3, a3);
      }
      if (1 === l6) {
        const n3 = se2(e5[u3]), t6 = B.numberToDms(n3), r3 = K2.createFromDegreesMinutesSeconds(t6.m_degrees, t6.m_minutes, t6.m_seconds);
        return i4 ? X2.createFromAngleMeridianAndDirection(r3, o2, c3) : X2.createFromAngleAndDirection(r3, a3);
      }
  }
  throw new t(null, e.LogicError, null, { reason: "invalid conversion" });
}
function ie2(e5) {
  const n3 = [" ", "-", "/", "'", '"', "\\", "^", z2, x2, "	", "\r", "\n", "*"];
  let t6 = "";
  for (let r3 = 0; r3 < e5.length; r3++) {
    const s4 = e5.charAt(r3);
    n3.includes(s4) ? t6 += "RRSPLITRRSPLITRR" : t6 += s4;
  }
  return t6.split("RRSPLITRRSPLITRR").filter((e6) => "" !== e6);
}
function oe(e5, r3, u3) {
  if (Z(e5))
    return ne(re(e5), r3, u3);
  if (w3(e5))
    return ae2(ie2(e5), r3, u3);
  if (Y(e5))
    return ae2(e5, r3, u3);
  if (E(e5))
    return ae2(e5.toArray(), r3, u3);
  throw new t(null, e.LogicError, null, { reason: "conversion error" });
}
function ce(e5, r3, s4) {
  const a3 = Y2(s4);
  if (a3 && s4 !== y3.degrees_minutes_seconds) {
    return e5.getAngle(r3).extractAngularUnits(a3);
  }
  throw new t(null, e.LogicError, null, { reason: "conversion error" });
}
function ue2(e5, n3, t6) {
  const r3 = e5.getAngle(n3);
  if (n3 === q.quadrant && t6 === y3.degrees_minutes_seconds) {
    const t7 = B.secondsToDMS(r3.extractAngularUnits(y3.seconds));
    return [C3(e5.getMeridian(n3), "SHORT"), t7.m_degrees, t7.m_minutes, t7.m_seconds, C3(e5.getDirection(n3), "SHORT")];
  }
  if (t6 === y3.degrees_minutes_seconds) {
    const e6 = B.secondsToDMS(r3.extractAngularUnits(y3.seconds));
    return [e6.m_degrees, e6.m_minutes, e6.m_seconds];
  }
  return n3 === q.quadrant ? [C3(e5.getMeridian(n3), "SHORT"), r3.extractAngularUnits(t6), C3(e5.getDirection(n3), "SHORT")] : [r3.extractAngularUnits(t6)];
}
function le2(e5, r3) {
  let s4 = "";
  switch (e5) {
    case y3.decimal_degrees:
      s4 = r3 === q.quadrant ? "DD.DD" + z2 : "DDD.DD" + z2;
      break;
    case y3.degrees_minutes_seconds:
      s4 = r3 === q.quadrant ? "dd" + z2 + ` mm' ss"` : "ddd" + z2 + ` mm' ss.ss"`;
      break;
    case y3.radians:
      s4 = "R.RR";
      break;
    case y3.gradians:
      s4 = "GGG.GG" + x2;
      break;
    default:
      throw new t(null, e.LogicError, null, { reason: "conversion error" });
  }
  return r3 === q.quadrant && (s4 = "p " + s4 + " b"), s4;
}
function de(e5, n3, t6) {
  const r3 = { padding: 0, rounding: 0, newpos: n3 };
  let s4 = false;
  for (; n3 < e5.length; ) {
    const a3 = e5[n3];
    if (a3 === t6)
      s4 ? r3.rounding++ : r3.padding++, n3++;
    else {
      if ("." !== a3)
        break;
      s4 = true, n3++;
    }
  }
  return r3.newpos = n3 - 1, r3;
}
function he(e5, n3, t6) {
  const r3 = { escaped: "", newpos: n3 };
  for (n3++; n3 < e5.length; ) {
    const t7 = e5[n3];
    if (n3++, "]" === t7)
      break;
    r3.escaped += t7;
  }
  return r3.newpos = n3 - 1, r3;
}
function me(e5, n3, t6) {
  let r3 = "", s4 = null, a3 = null;
  const i4 = $.createFromStringAndBearing(n3, e5, t6), o2 = { D: y3.decimal_degrees, d: y3.truncated_degrees, m: y3.fractional_degree_minutes, s: y3.fractional_minute_seconds, R: y3.radians, G: y3.gradians };
  for (let c3 = 0; c3 < n3.length; c3++) {
    const u3 = n3[c3];
    switch (u3) {
      case "[":
        s4 = he(n3, c3), r3 += s4.escaped, c3 = s4.newpos;
        continue;
      case "D":
      case "d":
      case "m":
      case "s":
      case "R":
      case "G":
        s4 = de(n3, c3, u3), a3 = e5.getAngle(t6), r3 += ee(a3, o2[u3], s4.padding, s4.rounding, i4), c3 = s4.newpos;
        continue;
      case "P":
      case "p":
        r3 += C3(i4.fetchMeridian(), "p" === u3 ? "SHORT" : "LONG");
        continue;
      case "B":
      case "b":
        r3 += C3(i4.fetchDirection(), "b" === u3 ? "SHORT" : "LONG");
        continue;
      default:
        r3 += u3;
    }
  }
  return r3;
}
function ge(s4, a3, i4) {
  if (!(a3 instanceof J2))
    throw new t(null, e.InvalidParameter, null);
  if (false === a3.hasField("directionType"))
    throw new t(null, e.LogicError, null, { reason: "missing directionType" });
  if (false === a3.hasField("angleType"))
    throw new t(null, e.LogicError, null, { reason: "missing angleType" });
  const o2 = W3(O2(a3.field("directiontype"))), c3 = oe(s4, Z4(O2(a3.field("angletype"))), o2);
  if (!(i4 instanceof J2))
    throw new t(null, e.InvalidParameter, null);
  if (false === i4.hasField("directionType"))
    throw new t(null, e.LogicError, null, { reason: "missing directionType" });
  if (false === i4.hasField("outputType"))
    throw new t(null, e.LogicError, null, { reason: "missing angleType" });
  const u3 = W3(O2(i4.field("directiontype"))), l6 = i4.hasField("angleType") ? Z4(O2(i4.field("angletype"))) : null, d5 = O2(i4.field("outputType")).toUpperCase().trim();
  if (!u3 || !d5)
    throw new t(null, e.LogicError, null, { reason: "conversion error" });
  if (!(l6 || "TEXT" === d5 && i4.hasField("format")))
    throw new t(null, e.LogicError, null, { reason: "invalid unit" });
  switch (d5) {
    case "VALUE":
      return u3 === q.quadrant || l6 === y3.degrees_minutes_seconds ? ue2(c3, u3, l6) : ce(c3, u3, l6);
    case "TEXT": {
      let e5 = "";
      return i4.hasField("format") && (e5 = K(i4.field("format"))), null !== e5 && "" !== e5 || (e5 = le2(l6, u3)), me(c3, e5, u3);
    }
    default:
      throw new t(null, e.InvalidParameter, null);
  }
}

// node_modules/@arcgis/core/arcade/functions/hash.js
var t5 = 2654435761;
var s2 = 2246822519;
var n2 = 3266489917;
var e4 = 668265263;
var r2 = 374761393;
function h4(t6) {
  const s4 = [];
  for (let n3 = 0, e5 = t6.length; n3 < e5; n3++) {
    let e6 = t6.charCodeAt(n3);
    e6 < 128 ? s4.push(e6) : e6 < 2048 ? s4.push(192 | e6 >> 6, 128 | 63 & e6) : e6 < 55296 || e6 >= 57344 ? s4.push(224 | e6 >> 12, 128 | e6 >> 6 & 63, 128 | 63 & e6) : (n3++, e6 = 65536 + ((1023 & e6) << 10 | 1023 & t6.charCodeAt(n3)), s4.push(240 | e6 >> 18, 128 | e6 >> 12 & 63, 128 | e6 >> 6 & 63, 128 | 63 & e6));
  }
  return new Uint8Array(s4);
}
var i3 = class {
  constructor(t6) {
    this._seed = t6, this._totallen = 0, this._bufs = [], this.init();
  }
  init() {
    return this._bufs = [], this._totallen = 0, this;
  }
  updateFloatArray(t6) {
    const s4 = [];
    for (const n3 of t6)
      isNaN(n3) ? s4.push("NaN") : n3 === 1 / 0 ? s4.push("Infinity") : n3 === -1 / 0 ? s4.push("-Infinity") : 0 === n3 ? s4.push("0") : s4.push(n3.toString(16));
    this.update(h4(s4.join("")));
  }
  updateIntArray(t6) {
    const s4 = Int32Array.from(t6);
    this.update(new Uint8Array(s4.buffer));
  }
  updateUint8Array(t6) {
    this.update(Uint8Array.from(t6));
  }
  updateWithString(t6) {
    return this.update(h4(t6));
  }
  update(t6) {
    return this._bufs.push(t6), this._totallen += t6.length, this;
  }
  digest() {
    const t6 = new Uint8Array(this._totallen);
    let s4 = 0;
    for (const n3 of this._bufs)
      t6.set(n3, s4), s4 += n3.length;
    return this.init(), this._xxHash32(t6, this._seed);
  }
  _xxHash32(h5, i4 = 0) {
    const o2 = h5;
    let u3 = i4 + r2 & 4294967295, a3 = 0;
    if (o2.length >= 16) {
      const n3 = [i4 + t5 + s2 & 4294967295, i4 + s2 & 4294967295, i4 + 0 & 4294967295, i4 - t5 & 4294967295], e5 = h5, r3 = e5.length - 16;
      let o3 = 0;
      for (a3 = 0; (4294967280 & a3) <= r3; a3 += 4) {
        const r4 = a3, h6 = e5[r4 + 0] + (e5[r4 + 1] << 8), i5 = e5[r4 + 2] + (e5[r4 + 3] << 8), u4 = h6 * s2 + (i5 * s2 << 16);
        let l7 = n3[o3] + u4 & 4294967295;
        l7 = l7 << 13 | l7 >>> 19;
        const f2 = 65535 & l7, p6 = l7 >>> 16;
        n3[o3] = f2 * t5 + (p6 * t5 << 16) & 4294967295, o3 = o3 + 1 & 3;
      }
      u3 = (n3[0] << 1 | n3[0] >>> 31) + (n3[1] << 7 | n3[1] >>> 25) + (n3[2] << 12 | n3[2] >>> 20) + (n3[3] << 18 | n3[3] >>> 14) & 4294967295;
    }
    u3 = u3 + h5.length & 4294967295;
    const l6 = h5.length - 4;
    for (; a3 <= l6; a3 += 4) {
      const t6 = a3, s4 = o2[t6 + 0] + (o2[t6 + 1] << 8), r3 = o2[t6 + 2] + (o2[t6 + 3] << 8);
      u3 = u3 + (s4 * n2 + (r3 * n2 << 16)) & 4294967295, u3 = u3 << 17 | u3 >>> 15, u3 = (65535 & u3) * e4 + ((u3 >>> 16) * e4 << 16) & 4294967295;
    }
    for (; a3 < o2.length; ++a3) {
      u3 += o2[a3] * r2, u3 = u3 << 11 | u3 >>> 21, u3 = (65535 & u3) * t5 + ((u3 >>> 16) * t5 << 16) & 4294967295;
    }
    return u3 ^= u3 >>> 15, u3 = ((65535 & u3) * s2 & 4294967295) + ((u3 >>> 16) * s2 << 16), u3 ^= u3 >>> 13, u3 = ((65535 & u3) * n2 & 4294967295) + ((u3 >>> 16) * n2 << 16), u3 ^= u3 >>> 16, u3 < 0 ? u3 + 4294967296 : u3;
  }
};

// node_modules/@arcgis/core/arcade/functions/string.js
function D3(t6, e5) {
  if (!t6 || !e5)
    return t6 === e5;
  if (t6.x === e5.x && t6.y === e5.y) {
    if (t6.hasZ) {
      if (t6.z !== e5.z)
        return false;
    } else if (e5.hasZ)
      return false;
    if (t6.hasM) {
      if (t6.m !== e5.m)
        return false;
    } else if (e5.hasM)
      return false;
    return true;
  }
  return false;
}
function W4(o2, i4, u3) {
  if (null !== o2)
    if (Y(o2)) {
      if (i4.updateUint8Array([61]), u3.map.has(o2)) {
        const t6 = u3.map.get(o2);
        i4.updateIntArray([61237541 ^ t6]);
      } else {
        u3.map.set(o2, u3.currentLength++);
        for (const t6 of o2)
          W4(t6, i4, u3);
        u3.map.delete(o2), u3.currentLength--;
      }
      i4.updateUint8Array([199]);
    } else if (E(o2)) {
      if (i4.updateUint8Array([61]), u3.map.has(o2)) {
        const t6 = u3.map.get(o2);
        i4.updateIntArray([61237541 ^ t6]);
      } else {
        u3.map.set(o2, u3.currentLength++);
        for (const t6 of o2.toArray())
          W4(t6, i4, u3);
        u3.map.delete(o2), u3.currentLength--;
      }
      i4.updateUint8Array([199]);
    } else {
      if (z(o2))
        return i4.updateIntArray([o2.getTime()]), void i4.updateUint8Array([241]);
      if (w3(o2))
        return i4.updateIntArray([o2.length]), i4.updateWithString(o2), void i4.updateUint8Array([41]);
      if (_(o2))
        i4.updateUint8Array([true === o2 ? 1 : 0, 113]);
      else {
        if (Z(o2))
          return i4.updateFloatArray([o2]), void i4.updateUint8Array([173]);
        if (o2 instanceof e2)
          throw new t(u3.context, e.UnsupportedHashType, u3.node);
        if (o2 instanceof t3)
          throw new t(u3.context, e.UnsupportedHashType, u3.node);
        if (!(o2 instanceof J2)) {
          if (J(o2))
            throw new t(u3.context, e.UnsupportedHashType, u3.node);
          if (o2 instanceof w)
            return i4.updateIntArray([3833836621]), i4.updateIntArray([0]), i4.updateFloatArray([o2.x]), i4.updateIntArray([1]), i4.updateFloatArray([o2.y]), o2.hasZ && (i4.updateIntArray([2]), i4.updateFloatArray([o2.z])), o2.hasM && (i4.updateIntArray([3]), i4.updateFloatArray([o2.m])), i4.updateIntArray([3765347959]), void W4(o2.spatialReference.wkid, i4, u3);
          if (o2 instanceof v) {
            i4.updateIntArray([1266616829]);
            for (let t6 = 0; t6 < o2.rings.length; t6++) {
              const e5 = o2.rings[t6], r3 = [];
              let n3 = null, a3 = null;
              for (let i5 = 0; i5 < e5.length; i5++) {
                const u4 = o2.getPoint(t6, i5);
                if (0 === i5)
                  n3 = u4;
                else if (D3(a3, u4))
                  continue;
                a3 = u4, i5 === e5.length - 1 && D3(n3, u4) || r3.push(u4);
              }
              i4.updateIntArray([1397116793, r3.length]);
              for (let t7 = 0; t7 < r3.length; t7++) {
                const e6 = r3[t7];
                i4.updateIntArray([3962308117, t7]), W4(e6, i4, u3), i4.updateIntArray([2716288009]);
              }
              i4.updateIntArray([2278822459]);
            }
            return i4.updateIntArray([3878477243]), void W4(o2.spatialReference.wkid, i4, u3);
          }
          if (o2 instanceof m) {
            i4.updateIntArray([4106883559]);
            for (let t6 = 0; t6 < o2.paths.length; t6++) {
              const e5 = o2.paths[t6];
              i4.updateIntArray([1397116793, e5.length]);
              for (let r3 = 0; r3 < e5.length; r3++)
                i4.updateIntArray([3962308117, r3]), W4(o2.getPoint(t6, r3), i4, u3), i4.updateIntArray([2716288009]);
              i4.updateIntArray([2278822459]);
            }
            return i4.updateIntArray([2568784753]), void W4(o2.spatialReference.wkid, i4, u3);
          }
          if (o2 instanceof u) {
            i4.updateIntArray([588535921, o2.points.length]);
            for (let t6 = 0; t6 < o2.points.length; t6++) {
              const e5 = o2.getPoint(t6);
              i4.updateIntArray([t6]), W4(e5, i4, u3);
            }
            return i4.updateIntArray([1700171621]), void W4(o2.spatialReference.wkid, i4, u3);
          }
          if (o2 instanceof w2)
            return i4.updateIntArray([3483648373]), i4.updateIntArray([0]), i4.updateFloatArray([o2.xmax]), i4.updateIntArray([1]), i4.updateFloatArray([o2.xmin]), i4.updateIntArray([2]), i4.updateFloatArray([o2.ymax]), i4.updateIntArray([3]), i4.updateFloatArray([o2.ymin]), o2.hasZ && (i4.updateIntArray([4]), i4.updateFloatArray([o2.zmax]), i4.updateIntArray([5]), i4.updateFloatArray([o2.zmin])), o2.hasM && (i4.updateIntArray([6]), i4.updateFloatArray([o2.mmax]), i4.updateIntArray([7]), i4.updateFloatArray([o2.mmin])), i4.updateIntArray([3622027469]), void W4(o2.spatialReference.wkid, i4, u3);
          if (o2 instanceof k)
            return i4.updateIntArray([14]), void 0 !== o2.wkid && null !== o2.wkid && i4.updateIntArray([o2.wkid]), void (o2.wkt && i4.updateWithString(o2.wkt));
          if (F(o2))
            throw new t(u3.context, e.UnsupportedHashType, u3.node);
          if (P2(o2))
            throw new t(u3.context, e.UnsupportedHashType, u3.node);
          if (G(o2))
            throw new t(u3.context, e.UnsupportedHashType, u3.node);
          if (o2 === k2)
            throw new t(u3.context, e.UnsupportedHashType, u3.node);
          throw new t(u3.context, e.UnsupportedHashType, u3.node);
        }
        if (i4.updateUint8Array([223]), u3.map.has(o2)) {
          const t6 = u3.map.get(o2);
          i4.updateIntArray([61237541 ^ t6]);
        } else {
          u3.map.set(o2, u3.currentLength++);
          for (const t6 of o2.keys()) {
            i4.updateIntArray([t6.length]), i4.updateWithString(t6), i4.updateUint8Array([251]);
            W4(o2.field(t6), i4, u3), i4.updateUint8Array([239]);
          }
          u3.map.delete(o2), u3.currentLength--;
        }
        i4.updateUint8Array([73]);
      }
    }
  else
    i4.updateUint8Array([0, 139]);
}
function B2(e5, b2) {
  e5.portal = function(e6, r3) {
    return b2(e6, r3, (n3, a3, u3) => (V(u3, 1, 1, e6, r3), new t3(K(u3[0]))));
  }, e5.typeof = function(t6, e6) {
    return b2(t6, e6, (r3, i4, s4) => {
      V(s4, 1, 1, t6, e6);
      const p6 = O(s4[0]);
      if ("Unrecognised Type" === p6)
        throw new t(t6, e.UnrecognisedType, e6);
      return p6;
    });
  }, e5.trim = function(t6, e6) {
    return b2(t6, e6, (r3, n3, a3) => (V(a3, 1, 1, t6, e6), K(a3[0]).trim()));
  }, e5.tohex = function(t6, e6) {
    return b2(t6, e6, (r3, n3, a3) => {
      V(a3, 1, 1, t6, e6);
      const i4 = re(a3[0]);
      return isNaN(i4) ? i4 : i4.toString(16);
    });
  }, e5.upper = function(t6, e6) {
    return b2(t6, e6, (r3, n3, a3) => (V(a3, 1, 1, t6, e6), K(a3[0]).toUpperCase()));
  }, e5.proper = function(t6, e6) {
    return b2(t6, e6, (r3, n3, a3) => {
      V(a3, 1, 2, t6, e6);
      let u3 = 1;
      2 === a3.length && "firstword" === K(a3[1]).toLowerCase() && (u3 = 2);
      const s4 = /\s/, p6 = K(a3[0]);
      let d5 = "", c3 = true;
      for (let t7 = 0; t7 < p6.length; t7++) {
        let e7 = p6[t7];
        if (s4.test(e7))
          1 === u3 && (c3 = true);
        else {
          e7.toUpperCase() !== e7.toLowerCase() && (c3 ? (e7 = e7.toUpperCase(), c3 = false) : e7 = e7.toLowerCase());
        }
        d5 += e7;
      }
      return d5;
    });
  }, e5.lower = function(t6, e6) {
    return b2(t6, e6, (r3, n3, a3) => (V(a3, 1, 1, t6, e6), K(a3[0]).toLowerCase()));
  }, e5.guid = function(t6, e6) {
    return b2(t6, e6, (r3, n3, a3) => {
      if (V(a3, 0, 1, t6, e6), a3.length > 0)
        switch (K(a3[0]).toLowerCase()) {
          case "digits":
            return U().replace("-", "").replace("-", "").replace("-", "").replace("-", "");
          case "digits-hyphen":
            return U();
          case "digits-hyphen-braces":
            return "{" + U() + "}";
          case "digits-hyphen-parentheses":
            return "(" + U() + ")";
        }
      return "{" + U() + "}";
    });
  }, e5.standardizeguid = function(t6, e6) {
    return b2(t6, e6, (r3, n3, a3) => {
      V(a3, 2, 2, t6, e6);
      let u3 = K(a3[0]);
      if ("" === u3 || null === u3)
        return "";
      const s4 = /^(\{|\()?(?<partA>[0-9a-z]{8})(\-?)(?<partB>[0-9a-z]{4})(\-?)(?<partC>[0-9a-z]{4})(\-?)(?<partD>[0-9a-z]{4})(\-?)(?<partE>[0-9a-z]{12})(\}|\))?$/gim.exec(u3);
      if (!s4)
        return "";
      const p6 = s4.groups;
      switch (u3 = p6.partA + "-" + p6.partB + "-" + p6.partC + "-" + p6.partD + "-" + p6.partE, K(a3[1]).toLowerCase()) {
        case "digits":
          return u3.replace("-", "").replace("-", "").replace("-", "").replace("-", "");
        case "digits-hyphen":
          return u3;
        case "digits-hyphen-braces":
          return "{" + u3 + "}";
        case "digits-hyphen-parentheses":
          return "(" + u3 + ")";
      }
      return "{" + u3 + "}";
    });
  }, e5.console = function(t6, e6) {
    return b2(t6, e6, (e7, r3, n3) => (0 === n3.length || (1 === n3.length ? t6.console(K(n3[0])) : t6.console(K(n3))), k2));
  }, e5.mid = function(t6, e6) {
    return b2(t6, e6, (r3, n3, a3) => {
      V(a3, 2, 3, t6, e6);
      let u3 = re(a3[1]);
      if (isNaN(u3))
        return "";
      if (u3 < 0 && (u3 = 0), 2 === a3.length)
        return K(a3[0]).substr(u3);
      let p6 = re(a3[2]);
      return isNaN(p6) ? "" : (p6 < 0 && (p6 = 0), K(a3[0]).substr(u3, p6));
    });
  }, e5.find = function(t6, e6) {
    return b2(t6, e6, (r3, n3, a3) => {
      V(a3, 2, 3, t6, e6);
      let u3 = 0;
      if (a3.length > 2) {
        if (u3 = re(v3(a3[2], 0)), isNaN(u3))
          return -1;
        u3 < 0 && (u3 = 0);
      }
      return K(a3[1]).indexOf(K(a3[0]), u3);
    });
  }, e5.left = function(t6, e6) {
    return b2(t6, e6, (r3, n3, a3) => {
      V(a3, 2, 2, t6, e6);
      let u3 = re(a3[1]);
      return isNaN(u3) ? "" : (u3 < 0 && (u3 = 0), K(a3[0]).substr(0, u3));
    });
  }, e5.right = function(t6, e6) {
    return b2(t6, e6, (r3, n3, a3) => {
      V(a3, 2, 2, t6, e6);
      let u3 = re(a3[1]);
      return isNaN(u3) ? "" : (u3 < 0 && (u3 = 0), K(a3[0]).substr(-1 * u3, u3));
    });
  }, e5.split = function(t6, e6) {
    return b2(t6, e6, (r3, n3, a3) => {
      let u3;
      V(a3, 2, 4, t6, e6);
      let p6 = re(v3(a3[2], -1));
      const d5 = le(v3(a3[3], false));
      if (-1 === p6 || null === p6 || true === d5 ? u3 = K(a3[0]).split(K(a3[1])) : (isNaN(p6) && (p6 = -1), p6 < -1 && (p6 = -1), u3 = K(a3[0]).split(K(a3[1]), p6)), false === d5)
        return u3;
      const f2 = [];
      for (let t7 = 0; t7 < u3.length && !(-1 !== p6 && f2.length >= p6); t7++)
        "" !== u3[t7] && void 0 !== u3[t7] && f2.push(u3[t7]);
      return f2;
    });
  }, e5.text = function(t6, e6) {
    return b2(t6, e6, (r3, n3, a3) => (V(a3, 1, 2, t6, e6), te(a3[0], a3[1])));
  }, e5.concatenate = function(t6, e6) {
    return b2(t6, e6, (t7, e7, r3) => {
      const n3 = [];
      if (r3.length < 1)
        return "";
      if (Y(r3[0])) {
        const t8 = v3(r3[2], "");
        for (let e8 = 0; e8 < r3[0].length; e8++)
          n3[e8] = te(r3[0][e8], t8);
        return r3.length > 1 ? n3.join(r3[1]) : n3.join("");
      }
      if (E(r3[0])) {
        const t8 = v3(r3[2], "");
        for (let e8 = 0; e8 < r3[0].length(); e8++)
          n3[e8] = te(r3[0].get(e8), t8);
        return r3.length > 1 ? n3.join(r3[1]) : n3.join("");
      }
      for (let a3 = 0; a3 < r3.length; a3++)
        n3[a3] = te(r3[a3]);
      return n3.join("");
    });
  }, e5.reverse = function(t6, e6) {
    return b2(t6, e6, (r3, i4, u3) => {
      if (V(u3, 1, 1, t6, e6), Y(u3[0])) {
        const t7 = u3[0].slice(0);
        return t7.reverse(), t7;
      }
      if (E(u3[0])) {
        const t7 = u3[0].toArray().slice(0);
        return t7.reverse(), t7;
      }
      throw new t(t6, e.InvalidParameter, e6);
    });
  }, e5.replace = function(t6, e6) {
    return b2(t6, e6, (r3, n3, a3) => {
      V(a3, 3, 4, t6, e6);
      const u3 = K(a3[0]), s4 = K(a3[1]), p6 = K(a3[2]);
      return 4 !== a3.length || le(a3[3]) ? R(u3, s4, p6) : u3.replace(s4, p6);
    });
  }, e5.schema = function(t6, e6) {
    return b2(t6, e6, (o2, i4, u3) => {
      if (J(u3[0])) {
        const t7 = Ie(u3[0]);
        return t7 ? J2.convertObjectToArcadeDictionary(t7) : null;
      }
      throw new t(t6, e.InvalidParameter, e6);
    });
  }, e5.subtypes = function(t6, e6) {
    return b2(t6, e6, (i4, u3, s4) => {
      if (V(s4, 1, 1, t6, e6), J(s4[0])) {
        const t7 = Re(s4[0]);
        return t7 ? J2.convertObjectToArcadeDictionary(t7) : null;
      }
      throw new t(t6, e.InvalidParameter, e6);
    });
  }, e5.subtypecode = function(t6, e6) {
    return b2(t6, e6, (r3, i4, u3) => {
      if (V(u3, 1, 1, t6, e6), J(u3[0])) {
        const t7 = Re(u3[0]);
        if (!t7)
          return null;
        if (t7.subtypeField && u3[0].hasField(t7.subtypeField)) {
          const e7 = u3[0].field(t7.subtypeField);
          for (const r4 of t7.subtypes)
            if (r4.code === e7)
              return r4.code;
          return null;
        }
        return null;
      }
      throw new t(t6, e.InvalidParameter, e6);
    });
  }, e5.subtypename = function(t6, e6) {
    return b2(t6, e6, (r3, i4, u3) => {
      if (V(u3, 1, 1, t6, e6), J(u3[0])) {
        const t7 = Re(u3[0]);
        if (!t7)
          return "";
        if (t7.subtypeField && u3[0].hasField(t7.subtypeField)) {
          const e7 = u3[0].field(t7.subtypeField);
          for (const r4 of t7.subtypes)
            if (r4.code === e7)
              return r4.name;
          return "";
        }
        return "";
      }
      throw new t(t6, e.InvalidParameter, e6);
    });
  }, e5.gdbversion = function(t6, e6) {
    return b2(t6, e6, (r3, i4, u3) => {
      if (V(u3, 1, 1, t6, e6), J(u3[0]))
        return u3[0].gdbVersion();
      throw new t(t6, e.InvalidParameter, e6);
    });
  }, e5.domain = function(t6, e6) {
    return b2(t6, e6, (u3, p6, d5) => {
      if (V(d5, 2, 3, t6, e6), J(d5[0])) {
        const t7 = Ae(d5[0], K(d5[1]), void 0 === d5[2] ? void 0 : re(d5[2]));
        return t7 && t7.domain ? "coded-value" === t7.domain.type || "codedValue" === t7.domain.type ? J2.convertObjectToArcadeDictionary({ type: "codedValue", name: t7.domain.name, dataType: P[t7.field.type], codedValues: t7.domain.codedValues.map((t8) => ({ name: t8.name, code: t8.code })) }) : J2.convertObjectToArcadeDictionary({ type: "range", name: t7.domain.name, dataType: P[t7.field.type], min: t7.domain.min, max: t7.domain.max }) : null;
      }
      throw new t(t6, e.InvalidParameter, e6);
    });
  }, e5.domainname = function(t6, e6) {
    return b2(t6, e6, (r3, u3, p6) => {
      if (V(p6, 2, 4, t6, e6), J(p6[0]))
        return Fe(p6[0], K(p6[1]), p6[2], void 0 === p6[3] ? void 0 : re(p6[3]));
      throw new t(t6, e.InvalidParameter, e6);
    });
  }, e5.domaincode = function(t6, e6) {
    return b2(t6, e6, (r3, u3, p6) => {
      if (V(p6, 2, 4, t6, e6), J(p6[0]))
        return Ce(p6[0], K(p6[1]), p6[2], void 0 === p6[3] ? void 0 : re(p6[3]));
      throw new t(t6, e.InvalidParameter, e6);
    });
  }, e5.urlencode = function(t6, e6) {
    return b2(t6, e6, (n3, a3, u3) => {
      if (V(u3, 1, 1, t6, e6), null === u3[0])
        return "";
      if (u3[0] instanceof J2) {
        let t7 = "";
        for (const e7 of u3[0].keys()) {
          const r3 = u3[0].field(e7);
          "" !== t7 && (t7 += "&"), t7 += null === r3 ? encodeURIComponent(e7) + "=" : encodeURIComponent(e7) + "=" + encodeURIComponent(r3);
        }
        return t7;
      }
      return encodeURIComponent(K(u3[0]));
    });
  }, e5.hash = function(t6, e6) {
    return b2(t6, e6, (r3, n3, a3) => {
      V(a3, 1, 1, t6, e6);
      const i4 = new i3(0);
      return W4(a3[0], i4, { context: t6, node: e6, map: /* @__PURE__ */ new Map(), currentLength: 0 }), i4.digest();
    });
  }, e5.convertdirection = function(t6, e6) {
    return b2(t6, e6, (r3, n3, a3) => (V(a3, 3, 3, t6, e6), ge(a3[0], a3[1], a3[2])));
  }, e5.fromjson = function(t6, e6) {
    return b2(t6, e6, (u3, s4, p6) => {
      if (V(p6, 1, 1, t6, e6), false === w3(p6[0]))
        throw new t(t6, e.InvalidParameter, e6);
      return J2.convertJsonToArcade(JSON.parse(K(p6[0])));
    });
  }, e5.expects = function(t6, e6) {
    return b2(t6, e6, (r3, o2, i4) => {
      if (i4.length < 1)
        throw new t(t6, e.WrongNumberOfParameters, e6);
      return k2;
    });
  }, e5.tocharcode = function(t6, e6) {
    return b2(t6, e6, (r3, u3, p6) => {
      V(p6, 1, 2, t6, e6);
      const d5 = re(v3(p6[1], 0)), l6 = K(p6[0]);
      if (0 === l6.length && 1 === p6.length)
        return null;
      if (l6.length <= d5 || d5 < 0)
        throw new t(t6, e.OutOfBounds, e6);
      return l6.charCodeAt(d5);
    });
  }, e5.tocodepoint = function(t6, e6) {
    return b2(t6, e6, (r3, u3, p6) => {
      V(p6, 1, 2, t6, e6);
      const d5 = re(v3(p6[1], 0)), l6 = K(p6[0]);
      if (0 === l6.length && 1 === p6.length)
        return null;
      if (l6.length <= d5 || d5 < 0)
        throw new t(t6, e.OutOfBounds, e6);
      return l6.codePointAt(d5);
    });
  }, e5.fromcharcode = function(t6, e6) {
    return b2(t6, e6, (r3, o2, i4) => {
      if (i4.length < 1)
        throw new t(t6, e.WrongNumberOfParameters, e6);
      const u3 = i4.map((t7) => Math.trunc(re(t7))).filter((t7) => t7 >= 0 && t7 <= 65535);
      return 0 === u3.length ? null : String.fromCharCode.apply(null, u3);
    });
  }, e5.fromcodepoint = function(t6, e6) {
    return b2(t6, e6, (r3, o2, i4) => {
      if (i4.length < 1)
        throw new t(t6, e.WrongNumberOfParameters, e6);
      let u3;
      try {
        u3 = i4.map((t7) => Math.trunc(re(t7))).filter((t7) => t7 <= 1114111 && t7 >>> 0 === t7);
      } catch (p6) {
        return null;
      }
      return 0 === u3.length ? null : String.fromCodePoint.apply(null, u3);
    });
  };
}

// node_modules/@arcgis/core/arcade/ArcadeModuleLoader.js
var s3 = class {
  constructor(s4, t6) {
    this._moduleSingletons = s4, this._syntaxModules = t6;
  }
  loadLibrary(s4) {
    if (null == this._syntaxModules)
      return null;
    const t6 = this._syntaxModules[s4.toLowerCase()];
    return t6 ? { syntax: t6.script, uri: t6.uri } : null;
  }
};

export {
  o,
  c2 as c,
  x,
  p4 as p,
  l3 as l,
  u2 as u,
  y,
  d2 as d,
  m3 as m,
  M2 as M,
  C2 as C,
  W2 as W,
  N2 as N,
  f,
  B2 as B,
  s3 as s
};
//# sourceMappingURL=chunk-NOCUJJC3.js.map
