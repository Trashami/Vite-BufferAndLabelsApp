import {
  s as s3
} from "./chunk-VWYWOOPX.js";
import {
  l
} from "./chunk-7QMMKGW4.js";
import {
  e as e2,
  n2 as n,
  y as y2
} from "./chunk-OOLCFNXJ.js";
import {
  s as s2
} from "./chunk-LIZHLHNA.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";
import {
  y
} from "./chunk-HVKDYDPP.js";
import {
  e,
  r,
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/layers/support/SimpleBandStatistics.js
var l2 = class {
  constructor(l3 = null, a2 = null, t2 = null) {
    this.minValue = l3, this.maxValue = a2, this.noDataValue = t2;
  }
};

// node_modules/@arcgis/core/layers/support/PixelBlock.js
var p;
var u = p = class extends l {
  constructor(t2) {
    super(t2), this.width = null, this.height = null, this.pixelType = "f32", this.validPixelCount = null, this.mask = null, this.maskIsAlpha = false, this.statistics = null;
  }
  static createEmptyBand(t2, e3) {
    return new (p.getPixelArrayConstructor(t2))(e3);
  }
  static getPixelArrayConstructor(t2) {
    let e3;
    switch (t2) {
      case "u1":
      case "u2":
      case "u4":
      case "u8":
        e3 = Uint8Array;
        break;
      case "u16":
        e3 = Uint16Array;
        break;
      case "u32":
        e3 = Uint32Array;
        break;
      case "s8":
        e3 = Int8Array;
        break;
      case "s16":
        e3 = Int16Array;
        break;
      case "s32":
        e3 = Int32Array;
        break;
      case "f32":
      case "c64":
      case "c128":
      case "unknown":
        e3 = Float32Array;
        break;
      case "f64":
        e3 = Float64Array;
    }
    return e3;
  }
  castPixelType(t2) {
    if (!t2)
      return "f32";
    let e3 = t2.toLowerCase();
    return ["u1", "u2", "u4"].includes(e3) ? e3 = "u8" : ["unknown", "u8", "s8", "u16", "s16", "u32", "s32", "f32", "f64"].includes(e3) || (e3 = "f32"), e3;
  }
  getPlaneCount() {
    var _a;
    return (_a = this.pixels) == null ? void 0 : _a.length;
  }
  addData(t2) {
    var _a;
    if (!t2.pixels || t2.pixels.length !== this.width * this.height)
      throw new s2("pixelblock:invalid-or-missing-pixels", "add data requires valid pixels array that has same length defined by pixel block width * height");
    this.pixels || (this.pixels = []), this.statistics || (this.statistics = []), this.pixels.push(t2.pixels), this.statistics.push((_a = t2.statistics) != null ? _a : new l2());
  }
  getAsRGBA() {
    const t2 = new ArrayBuffer(this.width * this.height * 4);
    switch (this.pixelType) {
      case "s8":
      case "s16":
      case "u16":
      case "s32":
      case "u32":
      case "f32":
      case "f64":
        this._fillFromNon8Bit(t2);
        break;
      default:
        this._fillFrom8Bit(t2);
    }
    return new Uint8ClampedArray(t2);
  }
  getAsRGBAFloat() {
    const t2 = new Float32Array(this.width * this.height * 4);
    return this._fillFrom32Bit(t2), t2;
  }
  updateStatistics() {
    if (!this.pixels)
      return;
    this.statistics = this.pixels.map((t3) => this._calculateBandStatistics(t3, this.mask));
    const t2 = this.mask;
    let e3 = 0;
    if (r(t2))
      for (let s5 = 0; s5 < t2.length; s5++)
        t2[s5] && e3++;
    else
      e3 = this.width * this.height;
    this.validPixelCount = e3;
  }
  clamp(t2) {
    if (!t2 || "f64" === t2 || "f32" === t2 || !this.pixels)
      return;
    let e3;
    switch (t2) {
      case "u8":
        e3 = [0, 255];
        break;
      case "u16":
        e3 = [0, 65535];
        break;
      case "u32":
        e3 = [0, 4294967295];
        break;
      case "s8":
        e3 = [-128, 127];
        break;
      case "s16":
        e3 = [-32768, 32767];
        break;
      case "s32":
        e3 = [-2147483648, 2147483647];
        break;
      default:
        e3 = [-34e38, 34e38];
    }
    const [s5, i2] = e3, r3 = this.pixels, l3 = this.width * this.height, a2 = r3.length;
    let o2, h2, n2;
    const c2 = [];
    for (let u3 = 0; u3 < a2; u3++) {
      n2 = p.createEmptyBand(t2, l3), o2 = r3[u3];
      for (let t3 = 0; t3 < l3; t3++)
        h2 = o2[t3], n2[t3] = h2 > i2 ? i2 : h2 < s5 ? s5 : h2;
      c2.push(n2);
    }
    this.pixels = c2, this.pixelType = t2;
  }
  extractBands(t2) {
    const { pixels: e3, statistics: s5 } = this;
    if (t(t2) || 0 === t2.length || !e3 || 0 === e3.length)
      return this;
    const i2 = e3.length, r3 = t2.some((t3) => t3 >= e3.length), l3 = i2 === t2.length && !t2.some((t3, e4) => t3 !== e4);
    return r3 || l3 ? this : new p({ pixelType: this.pixelType, width: this.width, height: this.height, mask: this.mask, validPixelCount: this.validPixelCount, maskIsAlpha: this.maskIsAlpha, pixels: t2.map((t3) => e3[t3]), statistics: s5 && t2.map((t3) => s5[t3]) });
  }
  clone() {
    const t2 = new p({ width: this.width, height: this.height, pixelType: this.pixelType, maskIsAlpha: this.maskIsAlpha, validPixelCount: this.validPixelCount });
    let e3;
    r(this.mask) && (this.mask instanceof Uint8Array ? t2.mask = new Uint8Array(this.mask) : t2.mask = this.mask.slice(0));
    const s5 = p.getPixelArrayConstructor(this.pixelType);
    if (this.pixels && this.pixels.length > 0) {
      t2.pixels = [];
      const i2 = !!this.pixels[0].slice;
      for (e3 = 0; e3 < this.pixels.length; e3++)
        t2.pixels[e3] = i2 ? this.pixels[e3].slice(0, this.pixels[e3].length) : new s5(this.pixels[e3]);
    }
    if (this.statistics)
      for (t2.statistics = [], e3 = 0; e3 < this.statistics.length; e3++)
        t2.statistics[e3] = y(this.statistics[e3]);
    return t2;
  }
  _fillFrom8Bit(t2) {
    const { mask: e3, maskIsAlpha: s5, pixels: i2 } = this;
    if (!t2 || !i2 || !i2.length)
      return void s.getLogger(this.declaredClass).error("getAsRGBA()", "Unable to convert to RGBA. The input pixel block is empty.");
    let a2, o2, h2, n2;
    a2 = o2 = h2 = i2[0], i2.length >= 3 ? (o2 = i2[1], h2 = i2[2]) : 2 === i2.length && (o2 = i2[1]);
    const c2 = new Uint32Array(t2), p3 = this.width * this.height;
    if (a2.length === p3)
      if (r(e3) && e3.length === p3)
        if (s5)
          for (n2 = 0; n2 < p3; n2++)
            e3[n2] && (c2[n2] = e3[n2] << 24 | h2[n2] << 16 | o2[n2] << 8 | a2[n2]);
        else
          for (n2 = 0; n2 < p3; n2++)
            e3[n2] && (c2[n2] = 255 << 24 | h2[n2] << 16 | o2[n2] << 8 | a2[n2]);
      else
        for (n2 = 0; n2 < p3; n2++)
          c2[n2] = 255 << 24 | h2[n2] << 16 | o2[n2] << 8 | a2[n2];
    else
      s.getLogger(this.declaredClass).error("getAsRGBA()", "Unable to convert to RGBA. The pixelblock is invalid.");
  }
  _fillFromNon8Bit(t2) {
    const { pixels: e3, mask: s5, statistics: i2 } = this;
    if (!t2 || !e3 || !e3.length)
      return void s.getLogger(this.declaredClass).error("getAsRGBA()", "Unable to convert to RGBA. The input pixel block is empty.");
    const a2 = this.pixelType;
    let o2 = 1, h2 = 0, n2 = 1;
    if (i2 && i2.length > 0) {
      for (const t3 of i2)
        if (null != t3.minValue && (h2 = Math.min(h2, t3.minValue)), null != t3.maxValue && null != t3.minValue) {
          const e4 = t3.maxValue - t3.minValue;
          n2 = Math.max(n2, e4);
        }
      o2 = 255 / n2;
    } else {
      let t3 = 255;
      "s8" === a2 ? (h2 = -128, t3 = 127) : "u16" === a2 ? t3 = 65535 : "s16" === a2 ? (h2 = -32768, t3 = 32767) : "u32" === a2 ? t3 = 4294967295 : "s32" === a2 ? (h2 = -2147483648, t3 = 2147483647) : "f32" === a2 ? (h2 = -34e38, t3 = 34e38) : "f64" === a2 && (h2 = -Number.MAX_VALUE, t3 = Number.MAX_VALUE), o2 = 255 / (t3 - h2);
    }
    const c2 = new Uint32Array(t2), p3 = this.width * this.height;
    let u3, g3, f2, m2, d2;
    if (u3 = g3 = f2 = e3[0], u3.length !== p3)
      return s.getLogger(this.declaredClass).error("getAsRGBA()", "Unable to convert to RGBA. The pixelblock is invalid.");
    if (e3.length >= 2)
      if (g3 = e3[1], e3.length >= 3 && (f2 = e3[2]), r(s5) && s5.length === p3)
        for (m2 = 0; m2 < p3; m2++)
          s5[m2] && (c2[m2] = 255 << 24 | (f2[m2] - h2) * o2 << 16 | (g3[m2] - h2) * o2 << 8 | (u3[m2] - h2) * o2);
      else
        for (m2 = 0; m2 < p3; m2++)
          c2[m2] = 255 << 24 | (f2[m2] - h2) * o2 << 16 | (g3[m2] - h2) * o2 << 8 | (u3[m2] - h2) * o2;
    else if (r(s5) && s5.length === p3)
      for (m2 = 0; m2 < p3; m2++)
        d2 = (u3[m2] - h2) * o2, s5[m2] && (c2[m2] = 255 << 24 | d2 << 16 | d2 << 8 | d2);
    else
      for (m2 = 0; m2 < p3; m2++)
        d2 = (u3[m2] - h2) * o2, c2[m2] = 255 << 24 | d2 << 16 | d2 << 8 | d2;
  }
  _fillFrom32Bit(t2) {
    const { pixels: e3, mask: s5 } = this;
    if (!t2 || !e3 || !e3.length)
      return s.getLogger(this.declaredClass).error("getAsRGBAFloat()", "Unable to convert to RGBA. The input pixel block is empty.");
    let i2, a2, o2, h2;
    i2 = a2 = o2 = e3[0], e3.length >= 3 ? (a2 = e3[1], o2 = e3[2]) : 2 === e3.length && (a2 = e3[1]);
    const n2 = this.width * this.height;
    if (i2.length !== n2)
      return s.getLogger(this.declaredClass).error("getAsRGBAFloat()", "Unable to convert to RGBA. The pixelblock is invalid.");
    let c2 = 0;
    if (r(s5) && s5.length === n2)
      for (h2 = 0; h2 < n2; h2++)
        t2[c2++] = i2[h2], t2[c2++] = a2[h2], t2[c2++] = o2[h2], t2[c2++] = 1 & s5[h2];
    else
      for (h2 = 0; h2 < n2; h2++)
        t2[c2++] = i2[h2], t2[c2++] = a2[h2], t2[c2++] = o2[h2], t2[c2++] = 1;
  }
  _calculateBandStatistics(t2, e3) {
    let s5 = 1 / 0, i2 = -1 / 0;
    const r3 = t2.length;
    let a2, o2 = 0;
    if (r(e3))
      for (a2 = 0; a2 < r3; a2++)
        e3[a2] && (o2 = t2[a2], s5 = o2 < s5 ? o2 : s5, i2 = o2 > i2 ? o2 : i2);
    else
      for (a2 = 0; a2 < r3; a2++)
        o2 = t2[a2], s5 = o2 < s5 ? o2 : s5, i2 = o2 > i2 ? o2 : i2;
    return new l2(s5, i2);
  }
};
e2([y2({ json: { write: true } })], u.prototype, "width", void 0), e2([y2({ json: { write: true } })], u.prototype, "height", void 0), e2([y2({ json: { write: true } })], u.prototype, "pixelType", void 0), e2([s3("pixelType")], u.prototype, "castPixelType", null), e2([y2({ json: { write: true } })], u.prototype, "validPixelCount", void 0), e2([y2({ json: { write: true } })], u.prototype, "mask", void 0), e2([y2({ json: { write: true } })], u.prototype, "maskIsAlpha", void 0), e2([y2({ json: { write: true } })], u.prototype, "pixels", void 0), e2([y2({ json: { write: true } })], u.prototype, "statistics", void 0), u = p = e2([n("esri.layers.support.PixelBlock")], u);
var g = u;

// node_modules/@arcgis/core/layers/support/rasterFunctions/pixelUtils.js
var i;
var o;
function r2(e3) {
  return r(e3) && "esri.layers.support.PixelBlock" === e3.declaredClass && e3.pixels && e3.pixels.length > 0;
}
function s4(t2, e3) {
  if (!(e3 == null ? void 0 : e3.length) || !r2(t2))
    return t2;
  const n2 = t2.pixels.length;
  return e3 && e3.some((t3) => t3 >= n2) || 1 === n2 && 1 === e3.length && 0 === e3[0] ? t2 : n2 !== e3.length || e3.some((t3, e4) => t3 !== e4) ? new g({ pixelType: t2.pixelType, width: t2.width, height: t2.height, mask: t2.mask, validPixelCount: t2.validPixelCount, maskIsAlpha: t2.maskIsAlpha, pixels: e3.map((e4) => t2.pixels[e4]), statistics: t2.statistics && e3.map((e4) => t2.statistics[e4]) }) : t2;
}
function h(e3) {
  if (!(e3 == null ? void 0 : e3.length) || e3.some((t2) => !r2(t2)))
    return null;
  if (1 === e3.length)
    return r(e3[0]) ? e3[0].clone() : null;
  const n2 = e3, { width: i2, height: o2, pixelType: s5 } = n2[0];
  if (n2.some((t2) => t2.width !== i2 || t2.height !== o2))
    return null;
  const h2 = n2.map(({ mask: t2 }) => t2).filter((t2) => null != t2);
  let a2 = null;
  h2.length && (a2 = new Uint8Array(i2 * o2), a2.set(h2[0]), h2.length > 1 && g2(h2.slice(1), a2));
  const f2 = [];
  n2.forEach(({ pixels: t2 }) => f2.push(...t2));
  const c2 = n2.map(({ statistics: t2 }) => t2).filter((t2) => t2 == null ? void 0 : t2.length), u3 = [];
  return c2.forEach((t2) => u3.push(...t2)), new g({ pixelType: s5, width: i2, height: o2, mask: a2, pixels: f2, statistics: u3.length ? u3 : null });
}
function a(t2) {
  if (!t2)
    return;
  const e3 = t2.colormap;
  if (!e3 || 0 === e3.length)
    return;
  const n2 = e3.sort((t3, e4) => t3[0] - e4[0]);
  let l3 = 0;
  n2[0][0] < 0 && (l3 = n2[0][0]);
  const i2 = Math.max(256, n2[n2.length - 1][0] - l3 + 1), o2 = new Uint8Array(4 * i2), r3 = [];
  let s5, h2 = 0, a2 = 0;
  const f2 = 5 === n2[0].length;
  if (i2 > 65536)
    return n2.forEach((t3) => {
      r3[t3[0] - l3] = f2 ? t3.slice(1) : t3.slice(1).concat([255]);
    }), { indexed2DColormap: r3, offset: l3, alphaSpecified: f2 };
  if (t2.fillUnspecified)
    for (s5 = n2[a2], h2 = s5[0] - l3; h2 < i2; h2++)
      o2[4 * h2] = s5[1], o2[4 * h2 + 1] = s5[2], o2[4 * h2 + 2] = s5[3], o2[4 * h2 + 3] = f2 ? s5[4] : 255, h2 === s5[0] - l3 && (s5 = a2 === n2.length - 1 ? s5 : n2[++a2]);
  else
    for (h2 = 0; h2 < n2.length; h2++)
      s5 = n2[h2], a2 = 4 * (s5[0] - l3), o2[a2] = s5[1], o2[a2 + 1] = s5[2], o2[a2 + 2] = s5[3], o2[a2 + 3] = f2 ? s5[4] : 255;
  return { indexedColormap: o2, offset: l3, alphaSpecified: f2 };
}
function f(e3, n2) {
  if (!r2(e3))
    return e3;
  if (!n2 || !n2.indexedColormap && !n2.indexed2DColormap)
    return e3;
  const l3 = e3.clone(), i2 = l3.pixels;
  let o2 = l3.mask;
  const s5 = l3.width * l3.height;
  if (1 !== i2.length)
    return e3;
  const { indexedColormap: h2, indexed2DColormap: a2, offset: f2, alphaSpecified: c2 } = n2;
  let u3 = 0;
  const p3 = i2[0], x2 = new Uint8Array(p3.length), m2 = new Uint8Array(p3.length), d2 = new Uint8Array(p3.length);
  let g3, y4 = 0;
  if (h2) {
    const e4 = h2.length - 1;
    if (r(o2))
      for (u3 = 0; u3 < s5; u3++)
        o2[u3] && (y4 = 4 * (p3[u3] - f2), y4 < f2 || y4 > e4 ? o2[u3] = 0 : (x2[u3] = h2[y4], m2[u3] = h2[y4 + 1], d2[u3] = h2[y4 + 2], o2[u3] = h2[y4 + 3]));
    else {
      for (o2 = new Uint8Array(s5), u3 = 0; u3 < s5; u3++)
        y4 = 4 * (p3[u3] - f2), y4 < f2 || y4 > e4 ? o2[u3] = 0 : (x2[u3] = h2[y4], m2[u3] = h2[y4 + 1], d2[u3] = h2[y4 + 2], o2[u3] = h2[y4 + 3]);
      l3.mask = o2;
    }
  } else if (a2)
    if (r(o2))
      for (u3 = 0; u3 < s5; u3++)
        o2[u3] && (g3 = a2[p3[u3]], x2[u3] = g3[0], m2[u3] = g3[1], d2[u3] = g3[2], o2[u3] = g3[3]);
    else {
      for (o2 = new Uint8Array(s5), u3 = 0; u3 < s5; u3++)
        g3 = a2[p3[u3]], x2[u3] = g3[0], m2[u3] = g3[1], d2[u3] = g3[2], o2[u3] = g3[3];
      l3.mask = o2;
    }
  return l3.pixels = [x2, m2, d2], l3.statistics = null, l3.pixelType = "u8", l3.maskIsAlpha = c2, l3;
}
function c(t2, e3) {
  if (!r2(t2))
    return null;
  const { pixels: n2, mask: i2 } = t2, o2 = n2.length;
  let s5 = e3.lut;
  const { offset: h2 } = e3;
  s5 && 1 === s5[0].length && (s5 = n2.map(() => s5));
  const a2 = [], f2 = e3.outputPixelType || "u8";
  for (let l3 = 0; l3 < o2; l3++) {
    const t3 = u2(n2[l3], i2, s5[l3], h2 || 0, f2);
    a2.push(t3);
  }
  const c2 = new g({ width: t2.width, height: t2.height, pixels: a2, mask: i2, pixelType: f2 });
  return c2.updateStatistics(), c2;
}
function u2(t2, e3, n2, i2, o2) {
  const r3 = t2.length, s5 = g.createEmptyBand(o2, r3);
  if (e3)
    for (let l3 = 0; l3 < r3; l3++)
      e3[l3] && (s5[l3] = n2[t2[l3] - i2]);
  else
    for (let l3 = 0; l3 < r3; l3++)
      s5[l3] = n2[t2[l3] - i2];
  return s5;
}
function p2(t2, e3) {
  if (!r2(t2))
    return null;
  const n2 = t2.clone(), { pixels: l3 } = n2, i2 = n2.width * n2.height, o2 = e3.length, s5 = Math.floor(o2 / 2), h2 = e3[Math.floor(s5)], a2 = l3[0];
  let f2, c2, u3, p3, x2, m2, d2 = false;
  const g3 = new Uint8Array(i2), y4 = new Uint8Array(i2), w2 = new Uint8Array(i2);
  let k2 = n2.mask;
  const M2 = 4 === e3[0].mappedColor.length;
  for (k2 || (k2 = new Uint8Array(i2), k2.fill(M2 ? 255 : 1), n2.mask = k2), x2 = 0; x2 < i2; x2++)
    if (k2[x2]) {
      for (f2 = a2[x2], d2 = false, m2 = s5, c2 = h2, u3 = 0, p3 = o2 - 1; p3 - u3 > 1; ) {
        if (f2 === c2.value) {
          d2 = true;
          break;
        }
        f2 > c2.value ? u3 = m2 : p3 = m2, m2 = Math.floor((u3 + p3) / 2), c2 = e3[Math.floor(m2)];
      }
      d2 || (f2 === e3[u3].value ? (c2 = e3[u3], d2 = true) : f2 === e3[p3].value ? (c2 = e3[p3], d2 = true) : f2 < e3[u3].value ? (d2 = false, c2 = null) : f2 > e3[u3].value && (f2 < e3[p3].value ? (c2 = e3[u3], d2 = true) : p3 === o2 - 1 ? (d2 = false, c2 = null) : (c2 = e3[p3], d2 = true))), d2 ? (g3[x2] = c2.mappedColor[0], y4[x2] = c2.mappedColor[1], w2[x2] = c2.mappedColor[2], k2[x2] = c2.mappedColor[3]) : g3[x2] = y4[x2] = w2[x2] = k2[x2] = 0;
    }
  return n2.pixels = [g3, y4, w2], n2.mask = k2, n2.pixelType = "u8", n2.maskIsAlpha = M2, n2;
}
function x(t2, e3) {
  if (!r2(t2))
    return null;
  const { width: n2, height: i2 } = t2, { inputRanges: o2, outputValues: s5, outputPixelType: h2, noDataRanges: a2, allowUnmatched: f2 } = e3, c2 = t2.pixels[0], u3 = g.createEmptyBand(h2, c2.length);
  f2 && u3.set(c2);
  const p3 = t2.mask, x2 = o2.length / 2;
  for (let l3 = 0; l3 < i2; l3++)
    for (let t3 = 0; t3 < n2; t3++) {
      const e4 = l3 * n2 + t3;
      if (!p3 || p3[e4]) {
        const t4 = c2[e4];
        for (let n3 = x2 - 1; n3 >= 0; n3--)
          if (t4 >= o2[2 * n3] && t4 <= o2[2 * n3 + 1]) {
            u3[e4] = s5[n3];
            break;
          }
      }
    }
  let m2 = p3;
  if (a2 == null ? void 0 : a2.length) {
    m2 = new Uint8Array(n2 * i2), p3 && m2.set(p3);
    for (let t3 = 0; t3 < i2; t3++)
      for (let e4 = 0; e4 < n2; e4++) {
        const l3 = t3 * n2 + e4;
        if (!p3 || p3[l3]) {
          const t4 = c2[l3];
          for (let e5 = 0; e5 < x2; e5 += 2)
            if (t4 >= a2[e5] && t4 <= a2[e5 + 1]) {
              u3[l3] = 0, m2[l3] = 0;
              break;
            }
        }
      }
  }
  return new g({ width: n2, height: i2, pixelType: h2, pixels: [u3], mask: m2 });
}
function m(t2, e3, n2, l3) {
  const i2 = null != n2 && n2.length >= 2 ? new Set(n2) : null, o2 = 1 === (n2 == null ? void 0 : n2.length) ? n2[0] : null, r3 = !!(e3 == null ? void 0 : e3.length);
  for (let s5 = 0; s5 < t2.length; s5++)
    if (l3[s5]) {
      const n3 = t2[s5];
      if (r3) {
        let t3 = false;
        for (let l4 = 0; l4 < e3.length; l4 += 2)
          if (n3 >= e3[l4] && n3 <= e3[l4 + 1]) {
            t3 = true;
            break;
          }
        t3 || (l3[s5] = 0);
      }
      l3[s5] && (n3 === o2 || (i2 == null ? void 0 : i2.has(n3))) && (l3[s5] = 0);
    }
}
function d(t2, e3) {
  const n2 = t2[0].length;
  for (let l3 = 0; l3 < n2; l3++)
    if (e3[l3]) {
      let n3 = false;
      for (let e4 = 0; e4 < t2.length; e4++)
        if (t2[e4][l3]) {
          n3 = true;
          break;
        }
      n3 || (e3[l3] = 0);
    }
}
function g2(t2, e3) {
  const n2 = t2[0].length;
  for (let l3 = 0; l3 < n2; l3++)
    if (e3[l3]) {
      let n3 = false;
      for (let e4 = 0; e4 < t2.length; e4++)
        if (0 === t2[e4][l3]) {
          n3 = true;
          break;
        }
      n3 && (e3[l3] = 0);
    }
}
function y3(t2, e3) {
  if (!r2(t2))
    return null;
  const { width: n2, height: i2, pixels: o2 } = t2, s5 = n2 * i2, h2 = new Uint8Array(s5);
  t2.mask ? h2.set(t2.mask) : h2.fill(255);
  const a2 = o2.length, { includedRanges: f2, noDataValues: c2, outputPixelType: p3, matchAll: x2, lookup: y4 } = e3;
  if (y4) {
    const t3 = [];
    for (let e4 = 0; e4 < a2; e4++) {
      const n3 = u2(o2[e4], h2, y4.lut, y4.offset || 0, "u8");
      t3.push(n3);
    }
    1 === t3.length ? h2.set(t3[0]) : x2 ? d(t3, h2) : g2(t3, h2);
  } else if (x2) {
    const t3 = [];
    for (let e4 = 0; e4 < a2; e4++) {
      const n3 = new Uint8Array(s5);
      n3.set(h2), m(o2[e4], f2, c2, n3), t3.push(n3);
    }
    1 === t3.length ? h2.set(t3[0]) : d(t3, h2);
  } else
    for (let l3 = 0; l3 < a2; l3++)
      m(o2[l3], f2, c2, h2);
  return new g({ width: n2, height: i2, pixelType: p3, pixels: o2, mask: h2 });
}
function w(t2, e3, n2) {
  if ("u8" !== t2 && "s8" !== t2 && "u16" !== t2 && "s16" !== t2)
    return null;
  const i2 = t2.includes("16") ? 65536 : 256, o2 = t2.includes("s") ? -i2 / 2 : 0, r3 = g.createEmptyBand(t2, i2);
  for (let l3 = 0; l3 < e3.length; l3++) {
    const t3 = n2[l3], i3 = Math.ceil(e3[2 * l3] - o2), s5 = Math.floor(e3[2 * l3 + 1] - o2);
    for (let e4 = i3; e4 <= s5; e4++)
      r3[e4] = t3;
  }
  return { lut: r3, offset: o2 };
}
function k(t2, e3, n2) {
  if ("u8" !== t2 && "s8" !== t2 && "u16" !== t2 && "s16" !== t2)
    return null;
  const l3 = t2.includes("16") ? 65536 : 256, i2 = t2.includes("s") ? -l3 / 2 : 0, o2 = new Uint8Array(l3);
  if (e3)
    for (let r3 = 0; r3 < e3.length; r3++) {
      const t3 = Math.ceil(e3[2 * r3] - i2), n3 = Math.floor(e3[2 * r3 + 1] - i2);
      for (let e4 = t3; e4 <= n3; e4++)
        o2[e4] = 255;
    }
  if (n2)
    for (let r3 = 0; r3 < n2.length; r3++)
      o2[n2[r3] - i2] = 0;
  return { lut: o2, offset: i2 };
}
function M(t2, e3, n2, l3, i2, o2, r3, s5) {
  return { xmin: i2 <= n2 * t2 ? 0 : i2 < n2 * t2 + t2 ? i2 - n2 * t2 : t2, ymin: o2 <= l3 * e3 ? 0 : o2 < l3 * e3 + e3 ? o2 - l3 * e3 : e3, xmax: i2 + r3 <= n2 * t2 ? 0 : i2 + r3 < n2 * t2 + t2 ? i2 + r3 - n2 * t2 : t2, ymax: o2 + s5 <= l3 * e3 ? 0 : o2 + s5 < l3 * e3 + e3 ? o2 + s5 - l3 * e3 : e3 };
}
function A(t2, n2) {
  if (!t2 || 0 === t2.length)
    return null;
  const l3 = t2.find((t3) => t3.pixelBlock);
  if (!l3 || t(l3.pixelBlock))
    return null;
  const i2 = (l3.extent.xmax - l3.extent.xmin) / l3.pixelBlock.width, o2 = (l3.extent.ymax - l3.extent.ymin) / l3.pixelBlock.height, r3 = 0.01 * Math.min(i2, o2), s5 = t2.sort((t3, e3) => Math.abs(t3.extent.ymax - e3.extent.ymax) > r3 ? e3.extent.ymax - t3.extent.ymax : Math.abs(t3.extent.xmin - e3.extent.xmin) > r3 ? t3.extent.xmin - e3.extent.xmin : 0), h2 = Math.min.apply(null, s5.map((t3) => t3.extent.xmin)), a2 = Math.min.apply(null, s5.map((t3) => t3.extent.ymin)), f2 = Math.max.apply(null, s5.map((t3) => t3.extent.xmax)), c2 = Math.max.apply(null, s5.map((t3) => t3.extent.ymax)), u3 = { x: Math.round((n2.xmin - h2) / i2), y: Math.round((c2 - n2.ymax) / o2) }, p3 = { width: Math.round((f2 - h2) / i2), height: Math.round((c2 - a2) / o2) }, x2 = { width: Math.round((n2.xmax - n2.xmin) / i2), height: Math.round((n2.ymax - n2.ymin) / o2) };
  if (Math.round(p3.width / l3.pixelBlock.width) * Math.round(p3.height / l3.pixelBlock.height) !== s5.length || u3.x < 0 || u3.y < 0 || p3.width < x2.width || p3.height < x2.height)
    return null;
  return { extent: n2, pixelBlock: T(s5.map((t3) => t3.pixelBlock), p3, { clipOffset: u3, clipSize: x2 }) };
}
function U(t2, e3, n2, l3, i2, o2) {
  var _a;
  const { width: r3, height: s5 } = n2.block, { x: h2, y: a2 } = n2.offset, { width: f2, height: c2 } = n2.mosaic, u3 = M(r3, s5, l3, i2, h2, a2, f2, c2);
  let p3 = 0, x2 = 0;
  if (o2) {
    const t3 = o2.hasGCSSShiftTransform ? 360 : (_a = o2.halfWorldWidth) != null ? _a : 0, e4 = r3 * o2.resolutionX, n3 = o2.startX + l3 * e4, i3 = n3 + e4;
    n3 < t3 && i3 > t3 ? x2 = o2.rightPadding : n3 >= t3 && (p3 = o2.leftMargin - o2.rightPadding, x2 = 0);
  }
  if (u3.xmax -= x2, "number" != typeof e3)
    for (let m2 = u3.ymin; m2 < u3.ymax; m2++) {
      const n3 = (i2 * s5 + m2 - a2) * f2 + (l3 * r3 - h2) + p3, o3 = m2 * r3;
      for (let l4 = u3.xmin; l4 < u3.xmax; l4++)
        t2[n3 + l4] = e3[o3 + l4];
    }
  else
    for (let m2 = u3.ymin; m2 < u3.ymax; m2++) {
      const n3 = (i2 * s5 + m2 - a2) * f2 + (l3 * r3 - h2) + p3;
      for (let l4 = u3.xmin; l4 < u3.xmax; l4++)
        t2[n3 + l4] = e3;
    }
}
function T(n2, i2, o2 = {}) {
  const { clipOffset: s5, clipSize: h2, alignmentInfo: a2, blockWidths: f2 } = o2;
  if (f2)
    return C(n2, i2, { blockWidths: f2 });
  const c2 = n2.find((t2) => r2(t2));
  if (t(c2))
    return null;
  const u3 = h2 ? h2.width : i2.width, p3 = h2 ? h2.height : i2.height, x2 = c2.width, m2 = c2.height, d2 = i2.width / x2, g3 = i2.height / m2, y4 = { offset: s5 || { x: 0, y: 0 }, mosaic: h2 || i2, block: { width: x2, height: m2 } }, w2 = c2.pixelType, k2 = g.getPixelArrayConstructor(w2), M2 = c2.pixels.length, A2 = [];
  let T2, b2;
  for (let t2 = 0; t2 < M2; t2++) {
    b2 = new k2(u3 * p3);
    for (let e3 = 0; e3 < g3; e3++)
      for (let l3 = 0; l3 < d2; l3++) {
        const i3 = n2[e3 * d2 + l3];
        r2(i3) && (T2 = i3.pixels[t2], U(b2, T2, y4, l3, e3, a2));
      }
    A2.push(b2);
  }
  let S2;
  if (n2.some((n3) => t(n3) || r(n3.mask) && n3.mask.length > 0)) {
    S2 = new Uint8Array(u3 * p3);
    for (let e3 = 0; e3 < g3; e3++)
      for (let l3 = 0; l3 < d2; l3++) {
        const i3 = n2[e3 * d2 + l3], o3 = r(i3) ? i3.mask : null;
        r(o3) ? U(S2, o3, y4, l3, e3, a2) : U(S2, i3 ? 1 : 0, y4, l3, e3, a2);
      }
  }
  const B2 = new g({ width: u3, height: p3, pixels: A2, pixelType: w2, mask: S2 });
  return B2.updateStatistics(), B2;
}
function C(i2, o2, s5) {
  const h2 = i2.find((e3) => r(e3));
  if (t(h2))
    return null;
  const a2 = i2.some((e3) => !r(e3) || !!e3.mask), { width: f2, height: c2 } = o2, u3 = a2 ? new Uint8Array(f2 * c2) : null, { blockWidths: p3 } = s5, x2 = [], m2 = h2.getPlaneCount(), d2 = g.getPixelArrayConstructor(h2.pixelType);
  if (a2)
    for (let t2 = 0, e3 = 0; t2 < i2.length; e3 += p3[t2], t2++) {
      const l3 = i2[t2];
      if (!r2(l3))
        continue;
      const o3 = e(l3.mask);
      for (let n2 = 0; n2 < c2; n2++)
        for (let i3 = 0; i3 < p3[t2]; i3++)
          u3[n2 * f2 + i3 + e3] = null == o3 ? 255 : o3[n2 * l3.width + i3];
    }
  for (let t2 = 0; t2 < m2; t2++) {
    const e3 = new d2(f2 * c2);
    for (let n2 = 0, l3 = 0; n2 < i2.length; l3 += p3[n2], n2++) {
      const o3 = i2[n2];
      if (!r2(o3))
        continue;
      const s6 = o3.pixels[t2];
      if (null != s6)
        for (let t3 = 0; t3 < c2; t3++)
          for (let i3 = 0; i3 < p3[n2]; i3++)
            e3[t3 * f2 + i3 + l3] = s6[t3 * o3.width + i3];
    }
    x2.push(e3);
  }
  const g3 = new g({ width: f2, height: c2, mask: u3, pixels: x2, pixelType: h2.pixelType });
  return g3.updateStatistics(), g3;
}
function b(t2, e3, n2) {
  if (!r2(t2))
    return null;
  const { width: l3, height: i2 } = t2, o2 = e3.x, s5 = e3.y, h2 = n2.width + o2, a2 = n2.height + s5;
  if (o2 < 0 || s5 < 0 || h2 > l3 || a2 > i2)
    return t2;
  if (0 === o2 && 0 === s5 && h2 === l3 && a2 === i2)
    return t2;
  t2.mask || (t2.mask = new Uint8Array(l3 * i2));
  const f2 = t2.mask;
  for (let r3 = 0; r3 < i2; r3++) {
    const t3 = r3 * l3;
    for (let e4 = 0; e4 < l3; e4++)
      f2[t3 + e4] = r3 < s5 || r3 >= a2 || e4 < o2 || e4 >= h2 ? 0 : 1;
  }
  return t2.updateStatistics(), t2;
}
function S(t2) {
  if (!r2(t2))
    return null;
  const e3 = t2.clone(), { width: l3, height: i2, pixels: o2 } = t2, s5 = o2[0], h2 = e3.pixels[0], a2 = e(t2.mask);
  for (let n2 = 2; n2 < i2 - 1; n2++) {
    const t3 = /* @__PURE__ */ new Map();
    for (let i3 = n2 - 2; i3 < n2 + 2; i3++)
      for (let e5 = 0; e5 < 4; e5++) {
        const n3 = i3 * l3 + e5;
        v(t3, s5[n3], a2 ? a2[n3] : 1);
      }
    h2[n2 * l3] = B(t3), h2[n2 * l3 + 1] = h2[n2 * l3 + 2] = h2[n2 * l3];
    let e4 = 3;
    for (; e4 < l3 - 1; e4++) {
      let i3 = (n2 - 2) * l3 + e4 + 1;
      v(t3, s5[i3], a2 ? a2[i3] : 1), i3 = (n2 - 1) * l3 + e4 + 1, v(t3, s5[i3], a2 ? a2[i3] : 1), i3 = n2 * l3 + e4 + 1, v(t3, s5[i3], a2 ? a2[i3] : 1), i3 = (n2 + 1) * l3 + e4 + 1, v(t3, s5[i3], a2 ? a2[i3] : 1), i3 = (n2 - 2) * l3 + e4 - 3, P(t3, s5[i3], a2 ? a2[i3] : 1), i3 = (n2 - 1) * l3 + e4 - 3, P(t3, s5[i3], a2 ? a2[i3] : 1), i3 = n2 * l3 + e4 - 3, P(t3, s5[i3], a2 ? a2[i3] : 1), i3 = (n2 + 1) * l3 + e4 - 3, P(t3, s5[i3], a2 ? a2[i3] : 1), h2[n2 * l3 + e4] = B(t3);
    }
    h2[n2 * l3 + e4 + 1] = h2[n2 * l3 + e4];
  }
  for (let n2 = 0; n2 < l3; n2++)
    h2[n2] = h2[l3 + n2] = h2[2 * l3 + n2], h2[(i2 - 1) * l3 + n2] = h2[(i2 - 2) * l3 + n2];
  return e3.updateStatistics(), e3;
}
function B(t2) {
  if (0 === t2.size)
    return 0;
  let e3 = 0, n2 = -1, l3 = 0;
  const i2 = t2.keys();
  let o2 = i2.next();
  for (; !o2.done; )
    l3 = t2.get(o2.value), l3 > e3 && (n2 = o2.value, e3 = l3), o2 = i2.next();
  return n2;
}
function P(t2, e3, n2) {
  if (0 === n2)
    return;
  const l3 = t2.get(e3);
  1 === l3 ? t2.delete(e3) : t2.set(e3, l3 - 1);
}
function v(t2, e3, n2) {
  0 !== n2 && t2.set(e3, t2.has(e3) ? t2.get(e3) + 1 : 1);
}
function _(t2, e3, i2) {
  let { x: o2, y: s5 } = e3;
  const { width: h2, height: a2 } = i2;
  if (0 === o2 && 0 === s5 && a2 === t2.height && h2 === t2.width)
    return t2;
  const { width: f2, height: c2 } = t2, u3 = Math.max(0, s5), p3 = Math.max(0, o2), x2 = Math.min(o2 + h2, f2), m2 = Math.min(s5 + a2, c2);
  if (x2 < 0 || m2 < 0 || !r2(t2))
    return null;
  o2 = Math.max(0, -o2), s5 = Math.max(0, -s5);
  const { pixels: d2 } = t2, g3 = h2 * a2, y4 = d2.length, w2 = [];
  for (let n2 = 0; n2 < y4; n2++) {
    const e4 = d2[n2], i3 = g.createEmptyBand(t2.pixelType, g3);
    for (let t3 = u3; t3 < m2; t3++) {
      const n3 = t3 * f2;
      let l3 = (t3 + s5 - u3) * h2 + o2;
      for (let t4 = p3; t4 < x2; t4++)
        i3[l3++] = e4[n3 + t4];
    }
    w2.push(i3);
  }
  const k2 = new Uint8Array(g3), M2 = e(t2.mask);
  for (let n2 = u3; n2 < m2; n2++) {
    const t3 = n2 * f2;
    let e4 = (n2 + s5 - u3) * h2 + o2;
    for (let n3 = p3; n3 < x2; n3++)
      k2[e4++] = M2 ? M2[t3 + n3] : 1;
  }
  const A2 = new g({ width: i2.width, height: i2.height, pixelType: t2.pixelType, pixels: w2, mask: k2 });
  return A2.updateStatistics(), A2;
}
function E(e3, n2 = true) {
  if (!r2(e3))
    return null;
  const { pixels: i2, width: o2, height: s5, mask: h2, pixelType: a2 } = e3, f2 = [], c2 = Math.round(o2 / 2), u3 = Math.round(s5 / 2), p3 = s5 - 1, x2 = o2 - 1;
  for (let t2 = 0; t2 < i2.length; t2++) {
    const e4 = i2[t2], r3 = g.createEmptyBand(a2, c2 * u3);
    let h3 = 0;
    for (let t3 = 0; t3 < s5; t3 += 2)
      for (let l3 = 0; l3 < o2; l3 += 2) {
        const i3 = e4[t3 * o2 + l3];
        if (n2) {
          const n3 = l3 === x2 ? i3 : e4[t3 * o2 + l3 + 1], s6 = t3 === p3 ? i3 : e4[t3 * o2 + l3 + o2], a3 = l3 === x2 ? s6 : t3 === p3 ? n3 : e4[t3 * o2 + l3 + o2 + 1];
          r3[h3++] = (i3 + n3 + s6 + a3) / 4;
        } else
          r3[h3++] = i3;
      }
    f2.push(r3);
  }
  let m2 = null;
  if (r(h2)) {
    m2 = new Uint8Array(c2 * u3);
    let t2 = 0;
    for (let e4 = 0; e4 < s5; e4 += 2)
      for (let l3 = 0; l3 < o2; l3 += 2) {
        const i3 = h2[e4 * o2 + l3];
        if (n2) {
          const n3 = l3 === x2 ? i3 : h2[e4 * o2 + l3 + 1], r3 = e4 === p3 ? i3 : h2[e4 * o2 + l3 + o2], s6 = l3 === x2 ? r3 : e4 === p3 ? n3 : h2[e4 * o2 + l3 + o2 + 1];
          m2[t2++] = i3 * n3 * r3 * s6 ? 1 : 0;
        } else
          m2[t2++] = i3;
      }
  }
  return new g({ width: c2, height: u3, pixelType: a2, pixels: f2, mask: m2 });
}
function W(t2, e3, n2) {
  if (!r2(t2))
    return null;
  const { width: l3, height: i2 } = e3;
  let { width: o2, height: s5 } = t2;
  const h2 = /* @__PURE__ */ new Map(), a2 = { x: 0, y: 0 }, f2 = null == n2 ? 1 : 1 + n2;
  let c2 = t2;
  for (let r3 = 0; r3 < f2; r3++) {
    const t3 = Math.ceil(o2 / l3), n3 = Math.ceil(s5 / i2);
    for (let o3 = 0; o3 < n3; o3++) {
      a2.y = o3 * i2;
      for (let n4 = 0; n4 < t3; n4++) {
        a2.x = n4 * l3;
        const t4 = _(c2, a2, e3);
        h2.set(`${r3}/${o3}/${n4}`, t4);
      }
    }
    r3 < f2 - 1 && (c2 = E(c2)), o2 = Math.round(o2 / 2), s5 = Math.round(s5 / 2);
  }
  return h2;
}
function I(t2, e3, n2, l3, i2 = 0.5) {
  const { width: o2, height: r3 } = t2, { width: s5, height: h2 } = e3, a2 = l3.cols, f2 = l3.rows, c2 = Math.ceil(s5 / a2 - 0.1 / a2), u3 = Math.ceil(h2 / f2 - 0.1 / f2);
  let p3, x2, m2, d2, g3, y4, w2;
  const k2 = c2 * a2, M2 = k2 * u3 * f2, A2 = new Float32Array(M2), U2 = new Float32Array(M2), T2 = new Uint32Array(M2), C2 = new Uint32Array(M2);
  let b2, S2, B2 = 0;
  for (let P2 = 0; P2 < u3; P2++)
    for (let t3 = 0; t3 < c2; t3++) {
      p3 = 12 * (P2 * c2 + t3), x2 = n2[p3], m2 = n2[p3 + 1], d2 = n2[p3 + 2], g3 = n2[p3 + 3], y4 = n2[p3 + 4], w2 = n2[p3 + 5];
      for (let e4 = 0; e4 < f2; e4++) {
        B2 = (P2 * f2 + e4) * k2 + t3 * a2, S2 = (e4 + 0.5) / f2;
        for (let t4 = 0; t4 < e4; t4++)
          b2 = (t4 + 0.5) / a2, A2[B2 + t4] = (x2 * b2 + m2 * S2 + d2) * o2 - i2, U2[B2 + t4] = (g3 * b2 + y4 * S2 + w2) * r3 - i2, T2[B2 + t4] = Math.round(A2[B2 + t4]), C2[B2 + t4] = Math.round(U2[B2 + t4]);
      }
      p3 += 6, x2 = n2[p3], m2 = n2[p3 + 1], d2 = n2[p3 + 2], g3 = n2[p3 + 3], y4 = n2[p3 + 4], w2 = n2[p3 + 5];
      for (let e4 = 0; e4 < f2; e4++) {
        B2 = (P2 * f2 + e4) * k2 + t3 * a2, S2 = (e4 + 0.5) / f2;
        for (let t4 = e4; t4 < a2; t4++)
          b2 = (t4 + 0.5) / a2, A2[B2 + t4] = (x2 * b2 + m2 * S2 + d2) * o2 - i2, U2[B2 + t4] = (g3 * b2 + y4 * S2 + w2) * r3 - i2, T2[B2 + t4] = Math.round(A2[B2 + t4]), C2[B2 + t4] = Math.round(U2[B2 + t4]);
      }
    }
  return { offsets_x: A2, offsets_y: U2, offsets_xi: T2, offsets_yi: C2, gridWidth: k2 };
}
function j(t2, e3) {
  const { coefficients: n2, spacing: l3 } = e3, { offsets_x: i2, offsets_y: o2, gridWidth: r3 } = I(t2, t2, n2, { rows: l3[0], cols: l3[1] }, 0.5), { width: s5, height: h2 } = t2, a2 = new Float32Array(s5 * h2), f2 = 180 / Math.PI;
  for (let c2 = 0; c2 < h2; c2++)
    for (let t3 = 0; t3 < s5; t3++) {
      const e4 = c2 * r3 + t3, n3 = 0 === c2 ? e4 : e4 - r3, l4 = c2 === h2 - 1 ? e4 : e4 + r3, u3 = i2[n3] - i2[l4], p3 = o2[l4] - o2[n3];
      if (isNaN(u3) || isNaN(p3))
        a2[c2 * s5 + t3] = 90;
      else {
        let e5 = Math.atan2(p3, u3) * f2;
        e5 = (360 + e5) % 360, a2[c2 * s5 + t3] = e5;
      }
    }
  return a2;
}
function D(e3, n2, i2, o2, s5 = "nearest") {
  if (!r2(e3))
    return null;
  "majority" === s5 && (e3 = S(e3));
  const { pixels: h2, mask: a2, pixelType: f2 } = e3, c2 = e3.width, u3 = e3.height, p3 = g.getPixelArrayConstructor(f2), x2 = h2.length, { width: m2, height: d2 } = n2;
  let g3 = false;
  for (let t2 = 0; t2 < i2.length; t2 += 3)
    -1 === i2[t2] && -1 === i2[t2 + 1] && -1 === i2[t2 + 2] && (g3 = true);
  const { offsets_x: y4, offsets_y: w2, offsets_xi: k2, offsets_yi: M2, gridWidth: A2 } = I({ width: c2, height: u3 }, n2, i2, o2, "majority" === s5 ? 0 : 0.5);
  let U2;
  const T2 = (t2, e4, n3) => {
    const l3 = t2 instanceof Float32Array || t2 instanceof Float64Array ? 0 : 0.5;
    for (let i3 = 0; i3 < d2; i3++) {
      U2 = i3 * A2;
      for (let o3 = 0; o3 < m2; o3++) {
        if (y4[U2] < 0 || w2[U2] < 0)
          t2[i3 * m2 + o3] = 0;
        else if (n3)
          t2[i3 * m2 + o3] = e4[k2[U2] + M2[U2] * c2];
        else {
          const n4 = Math.floor(y4[U2]), r3 = Math.floor(w2[U2]), s6 = Math.ceil(y4[U2]), h3 = Math.ceil(w2[U2]), f3 = y4[U2] - n4, u4 = w2[U2] - r3;
          if (!a2 || a2[n4 + r3 * c2] && a2[n4 + r3 * c2] && a2[n4 + h3 * c2] && a2[s6 + h3 * c2]) {
            const a3 = (1 - f3) * e4[n4 + r3 * c2] + f3 * e4[s6 + r3 * c2], p4 = (1 - f3) * e4[n4 + h3 * c2] + f3 * e4[s6 + h3 * c2];
            t2[i3 * m2 + o3] = (1 - u4) * a3 + u4 * p4 + l3;
          } else
            t2[i3 * m2 + o3] = e4[k2[U2] + M2[U2] * c2];
        }
        U2++;
      }
    }
  }, C2 = [];
  let b2;
  for (let t2 = 0; t2 < x2; t2++)
    b2 = new p3(m2 * d2), T2(b2, h2[t2], "nearest" === s5 || "majority" === s5), C2.push(b2);
  const B2 = new g({ width: m2, height: d2, pixelType: f2, pixels: C2 });
  if (r(a2))
    B2.mask = new Uint8Array(m2 * d2), T2(B2.mask, a2, true);
  else if (g3) {
    B2.mask = new Uint8Array(m2 * d2);
    for (let t2 = 0; t2 < m2 * d2; t2++)
      B2.mask[t2] = y4[t2] < 0 || w2[t2] < 0 ? 0 : 1;
  }
  return B2.updateStatistics(), B2;
}
!function(t2) {
  t2[t2.matchAny = 0] = "matchAny", t2[t2.matchAll = 1] = "matchAll";
}(i || (i = {})), function(t2) {
  t2[t2.bestMatch = 0] = "bestMatch", t2[t2.fail = 1] = "fail";
}(o || (o = {}));

export {
  g,
  i,
  o,
  r2 as r,
  s4 as s,
  h,
  a,
  f,
  c,
  p2 as p,
  x,
  y3 as y,
  w,
  k,
  A,
  T,
  b,
  W,
  j,
  D
};
//# sourceMappingURL=chunk-OAXPH6DL.js.map
