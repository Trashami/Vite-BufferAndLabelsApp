// node_modules/@arcgis/core/symbols/cim/utils.js
function e(e2) {
  return "function" == typeof e2;
}
function t(t2, r2, n2, o2) {
  return e(t2) ? t2(r2, n2, o2) : t2;
}
function r(e2) {
  return [e2.r, e2.g, e2.b, e2.a];
}
var n = " /-,\n";
function o(e2) {
  let t2 = e2.length;
  for (; t2--; )
    if (!n.includes(e2.charAt(t2)))
      return false;
  return true;
}
function i(e2, t2) {
  const r2 = [];
  let n2 = 0, i2 = -1;
  do {
    if (i2 = e2.indexOf("[", n2), i2 >= n2) {
      if (i2 > n2) {
        const t3 = e2.substr(n2, i2 - n2);
        r2.push([t3, null, o(t3)]);
      }
      if (n2 = i2 + 1, i2 = e2.indexOf("]", n2), i2 >= n2) {
        if (i2 > n2) {
          const o2 = t2[e2.substr(n2, i2 - n2)];
          o2 && r2.push([null, o2, false]);
        }
        n2 = i2 + 1;
      }
    }
  } while (-1 !== i2);
  if (n2 < e2.length - 1) {
    const t3 = e2.substr(n2);
    r2.push([t3, null, o(t3)]);
  }
  return r2;
}
function l(e2, t2, r2) {
  let n2 = "", o2 = null;
  for (const i2 of t2) {
    const [t3, r3, l2] = i2;
    if (t3)
      l2 ? o2 = t3 : (o2 && (n2 += o2, o2 = null), n2 += t3);
    else {
      const t4 = e2.attributes[r3];
      t4 && (o2 && (n2 += o2, o2 = null), n2 += t4);
    }
  }
  return s(n2, r2);
}
function c(e2, t2, r2) {
  const n2 = i(t2, e2);
  return (e3) => l(e3, n2, r2);
}
function s(e2, t2) {
  switch ("string" != typeof e2 && (e2 = String(e2)), t2) {
    case "LowerCase":
      return e2.toLowerCase();
    case "Allcaps":
      return e2.toUpperCase();
    default:
      return e2;
  }
}
function a(e2, t2, r2, n2, o2, i2, l2 = true) {
  const c2 = t2 / o2, s2 = r2 / i2, a2 = Math.ceil(c2 / 2), u2 = Math.ceil(s2 / 2);
  for (let f2 = 0; f2 < i2; f2++)
    for (let r3 = 0; r3 < o2; r3++) {
      const y2 = 4 * (r3 + (l2 ? i2 - f2 - 1 : f2) * o2);
      let M2 = 0, C2 = 0, m2 = 0, b2 = 0, d2 = 0, p2 = 0, I2 = 0;
      const h2 = (f2 + 0.5) * s2;
      for (let n3 = Math.floor(f2 * s2); n3 < (f2 + 1) * s2; n3++) {
        const o3 = Math.abs(h2 - (n3 + 0.5)) / u2, i3 = (r3 + 0.5) * c2, l3 = o3 * o3;
        for (let s3 = Math.floor(r3 * c2); s3 < (r3 + 1) * c2; s3++) {
          let r4 = Math.abs(i3 - (s3 + 0.5)) / a2;
          const o4 = Math.sqrt(l3 + r4 * r4);
          o4 >= -1 && o4 <= 1 && (M2 = 2 * o4 * o4 * o4 - 3 * o4 * o4 + 1, M2 > 0 && (r4 = 4 * (s3 + n3 * t2), I2 += M2 * e2[r4 + 3], m2 += M2, e2[r4 + 3] < 255 && (M2 = M2 * e2[r4 + 3] / 250), b2 += M2 * e2[r4], d2 += M2 * e2[r4 + 1], p2 += M2 * e2[r4 + 2], C2 += M2));
        }
      }
      n2[y2] = b2 / C2, n2[y2 + 1] = d2 / C2, n2[y2 + 2] = p2 / C2, n2[y2 + 3] = I2 / m2;
    }
}
function u(e2) {
  return e2 ? { r: e2[0], g: e2[1], b: e2[2], a: e2[3] / 255 } : { r: 0, g: 0, b: 0, a: 0 };
}
function f(e2) {
  var _a, _b;
  return (_b = (_a = e2.data) == null ? void 0 : _a.symbol) != null ? _b : null;
}
function y(e2) {
  return "CIMVectorMarker" === e2.type || "CIMPictureMarker" === e2.type || "CIMBarChartMarker" === e2.type || "CIMCharacterMarker" === e2.type || "CIMPieChartMarker" === e2.type || "CIMStackedBarChartMarker" === e2.type;
}
function M(e2) {
  return "CIMGradientStroke" === e2.type || "CIMPictureStroke" === e2.type || "CIMSolidStroke" === e2.type;
}
function C(e2) {
  return "CIMGradientFill" === e2.type || "CIMHatchFill" === e2.type || "CIMPictureFill" === e2.type || "CIMSolidFill" === e2.type || "CIMWaterFill" === e2.type;
}
function m(e2) {
  return "CIMMarkerPlacementAlongLineRandomSize" === e2.type || "CIMMarkerPlacementAlongLineSameSize" === e2.type || "CIMMarkerPlacementAlongLineVariableSize" === e2.type || "CIMMarkerPlacementAtExtremities" === e2.type || "CIMMarkerPlacementAtMeasuredUnits" === e2.type || "CIMMarkerPlacementAtRatioPositions" === e2.type || "CIMMarkerPlacementOnLine" === e2.type || "CIMMarkerPlacementOnVertices" === e2.type;
}
var b = (e2, t2 = 0) => isNaN(e2) || null == e2 ? t2 : e2;
var d = (e2) => {
  if (!e2)
    return false;
  for (const t2 of e2)
    switch (t2.type) {
      case "CIMGeometricEffectBuffer":
      case "CIMGeometricEffectOffset":
        return true;
    }
  return false;
};
function p() {
  return import("./geometryEngineJSON-ABWJ235Y.js");
}
function I(e2) {
  if (!e2)
    return "normal";
  switch (e2.toLowerCase()) {
    case "italic":
      return "italic";
    case "oblique":
      return "oblique";
    default:
      return "normal";
  }
}
function h(e2) {
  if (!e2)
    return "normal";
  switch (e2.toLowerCase()) {
    case "bold":
      return "bold";
    case "bolder":
      return "bolder";
    case "lighter":
      return "lighter";
    default:
      return "normal";
  }
}
function S(e2) {
  let t2 = "", r2 = "";
  if (e2) {
    const n2 = e2.toLowerCase();
    n2.includes("italic") ? t2 = "italic" : n2.includes("oblique") && (t2 = "oblique"), n2.includes("bold") ? r2 = "bold" : n2.includes("light") && (r2 = "lighter");
  }
  return { style: t2, weight: r2 };
}
function g(e2) {
  return e2.underline ? "underline" : e2.strikethrough ? "line-through" : "none";
}
function k(e2) {
  if (!e2)
    return null;
  switch (e2.type) {
    case "CIMPolygonSymbol":
      if (e2.symbolLayers)
        for (const t2 of e2.symbolLayers) {
          const e3 = k(t2);
          if (null != e3)
            return e3;
        }
      break;
    case "CIMTextSymbol":
      return k(e2.symbol);
    case "CIMSolidFill":
      return e2.color;
  }
}
function P(e2) {
  if (e2)
    switch (e2.type) {
      case "CIMPolygonSymbol":
      case "CIMLineSymbol":
        if (e2.symbolLayers)
          for (const t2 of e2.symbolLayers) {
            const e3 = P(t2);
            if (void 0 !== e3)
              return e3;
          }
        break;
      case "CIMTextSymbol":
        return P(e2.symbol);
      case "CIMSolidStroke":
      case "CIMSolidFill":
        return e2.color;
    }
}
function L(e2) {
  if (e2)
    switch (e2.type) {
      case "CIMPolygonSymbol":
      case "CIMLineSymbol":
        if (e2.symbolLayers)
          for (const t2 of e2.symbolLayers) {
            const e3 = L(t2);
            if (void 0 !== e3)
              return e3;
          }
        break;
      case "CIMTextSymbol":
        return L(e2.symbol);
      case "CIMSolidStroke":
      case "CIMGradientStroke":
      case "CIMPictureStroke":
        return e2.width;
    }
}
function w(e2) {
  switch (e2) {
    case "Left":
    default:
      return "left";
    case "Right":
      return "right";
    case "Center":
    case "Justify":
      return "center";
  }
}
function x(e2) {
  switch (e2) {
    case "Top":
    default:
      return "top";
    case "Center":
      return "middle";
    case "Baseline":
      return "baseline";
    case "Bottom":
      return "bottom";
  }
}
function F(e2) {
  return (e2 ? Object.keys(e2) : []).map((t2) => ({ name: t2, alias: t2, type: "string" == typeof e2[t2] ? "esriFieldTypeString" : "esriFieldTypeDouble" }));
}
var A = (e2) => e2.includes("data:image/svg+xml");
function G(e2) {
  if (!e2)
    return null;
  switch (e2.type) {
    case "CIMPointSymbol":
    case "CIMTextSymbol":
      return "esriGeometryPoint";
    case "CIMLineSymbol":
      return "esriGeometryPolyline";
    case "CIMPolygonSymbol":
      return "esriGeometryPolygon";
    default:
      return null;
  }
}

export {
  t,
  r,
  i,
  l,
  c,
  s,
  a,
  u,
  f,
  y,
  M,
  C,
  m,
  b,
  d,
  p,
  I,
  h,
  S,
  g,
  k,
  P,
  L,
  w,
  x,
  F,
  A,
  G
};
//# sourceMappingURL=chunk-SQSR6K2M.js.map
