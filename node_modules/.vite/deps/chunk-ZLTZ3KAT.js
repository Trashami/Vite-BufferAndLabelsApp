import {
  s as s2
} from "./chunk-LIZHLHNA.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";
import {
  r,
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/interfaces.js
var t2 = class {
};
function n(t3, ...n2) {
  let o2 = "";
  for (let r2 = 0; r2 < n2.length; r2++)
    o2 += t3[r2] + n2[r2];
  return o2 += t3[t3.length - 1], o2;
}
!function(t3) {
  function n2(t4) {
    return Math.round(t4).toString();
  }
  function o2(t4) {
    return t4.toPrecision(8);
  }
  t3.int = n2, t3.float = o2;
}(n || (n = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js
var s3 = s.getLogger("esri.views.3d.webgl-engine.core.shaderModules.shaderBuilder");
var i = class {
  constructor() {
    this._includedModules = /* @__PURE__ */ new Map();
  }
  include(e, r2) {
    if (this._includedModules.has(e)) {
      const t3 = this._includedModules.get(e);
      if (t3 !== r2) {
        s3.error("Trying to include shader module multiple times with different sets of options.");
        const r3 = /* @__PURE__ */ new Set();
        for (const n2 of Object.keys(t3))
          t3[n2] !== e[n2] && r3.add(n2);
        for (const n2 of Object.keys(e))
          t3[n2] !== e[n2] && r3.add(n2);
        r3.forEach((r4) => console.error(`  ${r4}: current ${t3[r4]} new ${e[r4]}`));
      }
    } else
      this._includedModules.set(e, r2), e(this.builder, r2);
  }
};
var o = class extends i {
  constructor() {
    super(...arguments), this.vertex = new u(), this.fragment = new u(), this.attributes = new m(), this.varyings = new h(), this.extensions = new d(), this.constants = new l();
  }
  get fragmentUniforms() {
    return this.fragment.uniforms.entries;
  }
  get builder() {
    return this;
  }
  generate(e) {
    const r2 = this.extensions.generateSource(e), t3 = this.attributes.generateSource(e), n2 = this.varyings.generateSource(), s4 = "vertex" === e ? this.vertex : this.fragment, i3 = s4.uniforms.generateSource(), o2 = s4.code.generateSource(), a3 = "vertex" === e ? f : _, c2 = this.constants.generateSource().concat(s4.constants.generateSource());
    return `
${r2.join("\n")}

${a3}

${c2.join("\n")}

${i3.join("\n")}

${t3.join("\n")}

${n2.join("\n")}

${o2.join("\n")}`;
  }
  generateBind(e, r2) {
    const n2 = /* @__PURE__ */ new Map();
    this.vertex.uniforms.entries.forEach((r3) => {
      const s5 = r3.bind[e];
      r(s5) && n2.set(r3.name, s5);
    }), this.fragment.uniforms.entries.forEach((r3) => {
      const s5 = r3.bind[e];
      r(s5) && n2.set(r3.name, s5);
    });
    const s4 = Array.from(n2.values()), i3 = s4.length;
    return (e2, t3, n3) => {
      for (let o2 = 0; o2 < i3; ++o2)
        s4[o2](r2, e2, t3, n3);
    };
  }
};
var a = class {
  constructor() {
    this._entries = /* @__PURE__ */ new Map();
  }
  add(e) {
    if (!Array.isArray(e))
      return this._add(e);
    for (const r2 of e)
      this._add(r2);
  }
  get(e) {
    return this._entries.get(e);
  }
  _add(r2) {
    if (t(r2))
      s3.error(`Trying to add null Uniform from ${new Error().stack}.`);
    else {
      if (this._entries.has(r2.name) && !this._entries.get(r2.name).equals(r2))
        throw new s2(`Duplicate uniform name ${r2.name} for different uniform type`);
      this._entries.set(r2.name, r2);
    }
  }
  generateSource() {
    return Array.from(this._entries.values()).map((e) => r(e.arraySize) ? `uniform ${e.type} ${e.name}[${e.arraySize}];` : `uniform ${e.type} ${e.name};`);
  }
  get entries() {
    return Array.from(this._entries.values());
  }
};
var c = class {
  constructor() {
    this._entries = new Array();
  }
  add(e) {
    this._entries.push(e);
  }
  generateSource() {
    return this._entries;
  }
};
var u = class extends i {
  constructor() {
    super(...arguments), this.uniforms = new a(), this.code = new c(), this.constants = new l();
  }
  get builder() {
    return this;
  }
};
var m = class {
  constructor() {
    this._entries = new Array();
  }
  add(e, r2) {
    this._entries.push([e, r2]);
  }
  generateSource(e) {
    return "fragment" === e ? [] : this._entries.map((e2) => `attribute ${e2[1]} ${e2[0]};`);
  }
};
var h = class {
  constructor() {
    this._entries = new Array();
  }
  add(e, r2) {
    this._entries.push([e, r2]);
  }
  generateSource() {
    return this._entries.map((e) => `varying ${e[1]} ${e[0]};`);
  }
};
var d = class {
  constructor() {
    this._entries = /* @__PURE__ */ new Set();
  }
  add(e) {
    this._entries.add(e);
  }
  generateSource(e) {
    const r2 = "vertex" === e ? d.ALLOWLIST_VERTEX : d.ALLOWLIST_FRAGMENT;
    return Array.from(this._entries).filter((e2) => r2.includes(e2)).map((e2) => `#extension ${e2} : enable`);
  }
};
d.ALLOWLIST_FRAGMENT = ["GL_EXT_shader_texture_lod", "GL_OES_standard_derivatives"], d.ALLOWLIST_VERTEX = [];
var l = class {
  constructor() {
    this._entries = /* @__PURE__ */ new Set();
  }
  add(e, r2, t3) {
    let n2 = "ERROR_CONSTRUCTOR_STRING";
    switch (r2) {
      case "float":
        n2 = l._numberToFloatStr(t3);
        break;
      case "int":
        n2 = l._numberToIntStr(t3);
        break;
      case "bool":
        n2 = t3.toString();
        break;
      case "vec2":
        n2 = `vec2(${l._numberToFloatStr(t3[0])},                            ${l._numberToFloatStr(t3[1])})`;
        break;
      case "vec3":
        n2 = `vec3(${l._numberToFloatStr(t3[0])},                            ${l._numberToFloatStr(t3[1])},                            ${l._numberToFloatStr(t3[2])})`;
        break;
      case "vec4":
        n2 = `vec4(${l._numberToFloatStr(t3[0])},                            ${l._numberToFloatStr(t3[1])},                            ${l._numberToFloatStr(t3[2])},                            ${l._numberToFloatStr(t3[3])})`;
        break;
      case "ivec2":
        n2 = `ivec2(${l._numberToIntStr(t3[0])},                             ${l._numberToIntStr(t3[1])})`;
        break;
      case "ivec3":
        n2 = `ivec3(${l._numberToIntStr(t3[0])},                             ${l._numberToIntStr(t3[1])},                             ${l._numberToIntStr(t3[2])})`;
        break;
      case "ivec4":
        n2 = `ivec4(${l._numberToIntStr(t3[0])},                             ${l._numberToIntStr(t3[1])},                             ${l._numberToIntStr(t3[2])},                             ${l._numberToIntStr(t3[3])})`;
        break;
      case "mat2":
      case "mat3":
      case "mat4":
        n2 = `${r2}(${Array.prototype.map.call(t3, (e2) => l._numberToFloatStr(e2)).join(", ")})`;
    }
    return this._entries.add(`const ${r2} ${e} = ${n2};`), this;
  }
  static _numberToIntStr(e) {
    return e.toFixed(0);
  }
  static _numberToFloatStr(e) {
    return Number.isInteger(e) ? e.toFixed(1) : e.toString();
  }
  generateSource() {
    return Array.from(this._entries);
  }
};
var _ = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  precision highp sampler2D;\n#else\n  precision mediump float;\n  precision mediump sampler2D;\n#endif";
var f = "precision highp float;\nprecision highp sampler2D;";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderTechnique/BindType.js
var a2;
!function(a3) {
  a3[a3.Pass = 0] = "Pass", a3[a3.Draw = 1] = "Draw";
}(a2 || (a2 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Uniform.js
var i2 = class {
  constructor(i3, s4, t3, a3, n2 = null) {
    this.name = i3, this.type = s4, this.arraySize = n2, this.bind = { [a2.Pass]: null, [a2.Draw]: null }, r(t3) && r(a3) && (this.bind[t3] = a3);
  }
  equals(e) {
    return this.type === e.type && this.name === e.name && this.arraySize === e.arraySize;
  }
};

export {
  t2 as t,
  n,
  a2 as a,
  i2 as i,
  o
};
//# sourceMappingURL=chunk-ZLTZ3KAT.js.map
