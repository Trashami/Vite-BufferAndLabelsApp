import {
  e
} from "./chunk-IOZMLQTF.js";
import {
  rt
} from "./chunk-TJ2I6XQT.js";
import {
  t as t2
} from "./chunk-34YPGGJT.js";
import {
  v
} from "./chunk-EHPBHJYZ.js";
import {
  has
} from "./chunk-HVKDYDPP.js";
import {
  f,
  i,
  r,
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/views/2d/layers/features/support/StaticBitSet.js
var t3 = class {
  constructor(t4, e2) {
    this._mask = 0, this._buf = t4, this._mask = e2;
  }
  static fromBuffer(e2, s) {
    return new t3(e2, s);
  }
  static create(e2, s = 4294967295) {
    const r2 = new Uint32Array(Math.ceil(e2 / 32));
    return new t3(r2, s);
  }
  _getIndex(t4) {
    return Math.floor(t4 / 32);
  }
  has(t4) {
    const e2 = this._mask & t4;
    return !!(this._buf[this._getIndex(e2)] & 1 << e2 % 32);
  }
  hasRange(t4, e2) {
    let s = t4, r2 = e2;
    for (; s % 32 && s !== r2; ) {
      if (this.has(s))
        return true;
      s++;
    }
    for (; r2 % 32 && s !== r2; ) {
      if (this.has(s))
        return true;
      r2--;
    }
    if (s === r2)
      return false;
    for (let h2 = s / 32; h2 !== r2 / 32; h2++) {
      if (this._buf[h2])
        return true;
    }
    return false;
  }
  set(t4) {
    const e2 = this._mask & t4, s = this._getIndex(e2), r2 = 1 << e2 % 32;
    this._buf[s] |= r2;
  }
  setRange(t4, e2) {
    let s = t4, r2 = e2;
    for (; s % 32 && s !== r2; )
      this.set(s++);
    for (; r2 % 32 && s !== r2; )
      this.set(r2--);
    if (s !== r2)
      for (let h2 = s / 32; h2 !== r2 / 32; h2++)
        this._buf[h2] = 4294967295;
  }
  unset(t4) {
    const e2 = this._mask & t4, s = this._getIndex(e2), r2 = 1 << e2 % 32;
    this._buf[s] &= 4294967295 ^ r2;
  }
  resize(t4) {
    const e2 = this._buf, s = new Uint32Array(Math.ceil(t4 / 32));
    s.set(e2), this._buf = s;
  }
  or(t4) {
    for (let e2 = 0; e2 < this._buf.length; e2++)
      this._buf[e2] |= t4._buf[e2];
    return this;
  }
  and(t4) {
    for (let e2 = 0; e2 < this._buf.length; e2++)
      this._buf[e2] &= t4._buf[e2];
    return this;
  }
  xor(t4) {
    for (let e2 = 0; e2 < this._buf.length; e2++)
      this._buf[e2] ^= t4._buf[e2];
    return this;
  }
  ior(t4) {
    for (let e2 = 0; e2 < this._buf.length; e2++)
      this._buf[e2] |= ~t4._buf[e2];
    return this;
  }
  iand(t4) {
    for (let e2 = 0; e2 < this._buf.length; e2++)
      this._buf[e2] &= ~t4._buf[e2];
    return this;
  }
  ixor(t4) {
    for (let e2 = 0; e2 < this._buf.length; e2++)
      this._buf[e2] ^= ~t4._buf[e2];
    return this;
  }
  any() {
    for (let t4 = 0; t4 < this._buf.length; t4++)
      if (this._buf[t4])
        return true;
    return false;
  }
  copy(t4) {
    for (let e2 = 0; e2 < this._buf.length; e2++)
      this._buf[e2] = t4._buf[e2];
    return this;
  }
  clone() {
    return new t3(this._buf.slice(), this._mask);
  }
  clear() {
    for (let t4 = 0; t4 < this._buf.length; t4++)
      this._buf[t4] = 0;
  }
  forEachSet(t4) {
    for (let e2 = 0; e2 < this._buf.length; e2++) {
      let s = this._buf[e2], r2 = 32 * e2;
      if (s)
        for (; s; ) {
          1 & s && t4(r2), s >>>= 1, r2++;
        }
    }
  }
  countSet() {
    let t4 = 0;
    return this.forEachSet((e2) => {
      t4++;
    }), t4;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReader.js
var h = 0;
var _a;
var u = (_a = has("featurelayer-simplify-thresholds")) != null ? _a : [0.5, 0.5, 0.5, 0.5];
var l = u[0];
var c = u[1];
var m = u[2];
var g = u[3];
var _a2;
var y = (_a2 = has("featurelayer-simplify-payload-size-factors")) != null ? _a2 : [1, 2, 4];
var _ = y[0];
var f2 = y[1];
var p = y[2];
var _a3;
var x = (_a3 = has("featurelayer-simplify-mobile-factor")) != null ? _a3 : 2;
var I = has("esri-mobile");
var b = class {
  constructor(e2, t4) {
    this.type = "FeatureSetReader", this.arcadeDeclaredClass = "esri.arcade.Feature", this.seen = false, this.instance = 0, this._tx = 0, this._ty = 0, this._sx = 1, this._sy = 1, this._deleted = null, this._joined = [], this._objectIdToIndex = null, this._level = 0, this.instance = e2, this._layerSchema = t4;
  }
  static createInstance() {
    return h++, h = h > 65535 ? 0 : h, h;
  }
  get isEmpty() {
    return r(this._deleted) && this._deleted.countSet() === this.getSize();
  }
  set level(e2) {
    this._level = e2;
  }
  getAreaSimplificationThreshold(e2, t4) {
    let r2 = 1;
    const s = I ? x : 1;
    t4 > 4e6 ? r2 = p * s : t4 > 1e6 ? r2 = f2 * s : t4 > 5e5 ? r2 = _ * s : t4 > 1e5 && (r2 = s);
    let i2 = 0;
    e2 > 4e3 ? i2 = g * r2 : e2 > 2e3 ? i2 = m * r2 : e2 > 100 ? i2 = c : e2 > 15 && (i2 = l);
    let o = 8;
    return this._level < 4 ? o = 1 : this._level < 5 ? o = 2 : this._level < 6 && (o = 4), i2 * o;
  }
  createQuantizedExtrudedQuad(e2, t4) {
    return new t2([5], [e2 - 1, t4, 1, -1, 1, 1, -1, 1, -1, -1]);
  }
  setArcadeSpatialReference(e2) {
    this._arcadeSpatialReference = e2;
  }
  attachStorage(e2) {
    this._storage = e2;
  }
  getQuantizationTransform() {
    throw new Error("Unable to find transform for featureSet");
  }
  getStorage() {
    return this._storage;
  }
  getComputedNumeric(e2) {
    return this.getComputedNumericAtIndex(0);
  }
  setComputedNumeric(e2, t4) {
    return this.setComputedNumericAtIndex(t4, 0);
  }
  getComputedString(e2) {
    return this.getComputedStringAtIndex(0);
  }
  setComputedString(e2, t4) {
    return this.setComputedStringAtIndex(0, t4);
  }
  getComputedNumericAtIndex(e2) {
    return this._storage.getComputedNumericAtIndex(this.getDisplayId(), e2);
  }
  setComputedNumericAtIndex(e2, t4) {
    this._storage.setComputedNumericAtIndex(this.getDisplayId(), e2, t4);
  }
  getComputedStringAtIndex(e2) {
    return this._storage.getComputedStringAtIndex(this.getDisplayId(), e2);
  }
  setComputedStringAtIndex(e2, t4) {
    return this._storage.setComputedStringAtIndex(this.getDisplayId(), e2, t4);
  }
  transform(e2, t4, r2, s) {
    const i2 = this.copy();
    return i2._tx += e2, i2._ty += t4, i2._sx *= r2, i2._sy *= s, i2;
  }
  readAttribute(e2, t4 = false) {
    const r2 = this._readAttribute(e2, t4);
    if (void 0 !== r2)
      return r2;
    for (const s of this._joined) {
      s.setIndex(this.getIndex());
      const r3 = s._readAttribute(e2, t4);
      if (void 0 !== r3)
        return r3;
    }
  }
  readAttributes() {
    const e2 = this._readAttributes();
    for (const t4 of this._joined) {
      t4.setIndex(this.getIndex());
      const r2 = t4._readAttributes();
      for (const t5 of Object.keys(r2))
        e2[t5] = r2[t5];
    }
    return e2;
  }
  joinAttributes(e2) {
    this._joined.push(e2);
  }
  readArcadeFeature() {
    return this;
  }
  geometry() {
    const e2 = this.readHydratedGeometry(), t4 = rt(e2, this.geometryType, this.hasZ, this.hasM), r2 = v(t4);
    return r2 && (r2.spatialReference = this._arcadeSpatialReference), r2;
  }
  field(e2) {
    if (this.hasField(e2))
      return this.readAttribute(e2, true);
    for (const t4 of this._joined)
      if (t4.setIndex(this.getIndex()), t4.hasField(e2)) {
        return t4._readAttribute(e2, true);
      }
    throw new Error(`Field ${e2} does not exist`);
  }
  setField(e2, t4) {
    throw new Error("Unable to update feature attribute values, feature is readonly");
  }
  keys() {
    return this.getFieldNames();
  }
  castToText(e2 = false) {
    if (!e2)
      return JSON.stringify(this.readLegacyFeature());
    const t4 = this.readLegacyFeature();
    if (!t4)
      return JSON.stringify(null);
    const r2 = { geometry: t4.geometry, attributes: { ...t4.attributes ? t4.attributes : {} } };
    for (const s in r2.attributes) {
      const e3 = r2.attributes[s];
      e3 instanceof Date && (r2.attributes[s] = e3.getTime());
    }
    return JSON.stringify(r2);
  }
  gdbVersion() {
    return null;
  }
  fullSchema() {
    return this._layerSchema;
  }
  castAsJson(e2 = null) {
    return { attributes: this._readAttributes(), geometry: true === (e2 == null ? void 0 : e2.keepGeometryType) ? this.geometry() : this.geometry().toJSON() };
  }
  castAsJsonAsync(e2 = null, t4 = null) {
    return Promise.resolve(this.castAsJson(t4));
  }
  removeIds(e2) {
    if (t(this._objectIdToIndex)) {
      const e3 = /* @__PURE__ */ new Map(), t4 = this.getCursor();
      for (; t4.next(); ) {
        const s2 = f(t4.getObjectId());
        e3.set(s2, t4.getIndex());
      }
      this._objectIdToIndex = e3;
    }
    const s = this._objectIdToIndex;
    for (const t4 of e2)
      s.has(t4) && this.removeAtIndex(s.get(t4));
  }
  removeAtIndex(e2) {
    t(this._deleted) && (this._deleted = t3.create(this.getSize())), this._deleted.set(e2);
  }
  readGeometryForDisplay() {
    return this.readUnquantizedGeometry(true);
  }
  readLegacyGeometryForDisplay() {
    return this.readLegacyGeometry(true);
  }
  *features() {
    const e2 = this.getCursor();
    for (; e2.next(); )
      yield e2.readOptimizedFeature();
  }
  _getExists() {
    return t(this._deleted) || !this._deleted.has(this.getIndex());
  }
  _computeCentroid() {
    if ("esriGeometryPolygon" !== this.geometryType)
      return null;
    const e2 = this.readUnquantizedGeometry();
    if (!e2 || e2.hasIndeterminateRingOrder)
      return null;
    const t4 = i(this.getQuantizationTransform(), null);
    return e(new t2(), e2, this.hasM, this.hasZ, t4);
  }
  copyInto(e2) {
    e2.seen = this.seen, e2._storage = this._storage, e2._arcadeSpatialReference = this._arcadeSpatialReference, e2._joined = this._joined, e2._tx = this._tx, e2._ty = this._ty, e2._sx = this._sx, e2._sy = this._sy, e2._deleted = this._deleted, e2._objectIdToIndex = this._objectIdToIndex;
  }
};

export {
  t3 as t,
  b
};
//# sourceMappingURL=chunk-ESF7LLEL.js.map
