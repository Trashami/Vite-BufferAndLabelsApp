import {
  G,
  Q,
  es
} from "./chunk-WWDLDTQB.js";
import {
  a as a2,
  r as r2
} from "./chunk-RU3WEQBN.js";
import "./chunk-GQHKPMYA.js";
import "./chunk-YBAOLQVA.js";
import "./chunk-77RDPZ67.js";
import "./chunk-ZX55SO5Y.js";
import "./chunk-FCIHN4UG.js";
import {
  h as h4
} from "./chunk-JLDKIFMH.js";
import "./chunk-XFDO4CMR.js";
import "./chunk-IVLBGTXL.js";
import "./chunk-GHN7C53L.js";
import "./chunk-VRX4W75V.js";
import "./chunk-2J2YGTXG.js";
import {
  E,
  y as y3
} from "./chunk-C6BDJNUQ.js";
import "./chunk-OJ2HHY2O.js";
import {
  c
} from "./chunk-4RQKL5NC.js";
import "./chunk-75RMBUYZ.js";
import {
  p as p2
} from "./chunk-SERWCSJG.js";
import {
  j,
  p
} from "./chunk-OOOPZLJE.js";
import {
  t as t4
} from "./chunk-U2WD23Z5.js";
import {
  t as t5
} from "./chunk-RW4M3CI3.js";
import "./chunk-ZEEU5HOK.js";
import {
  n as n3
} from "./chunk-NDQ5FHGV.js";
import "./chunk-ZL4T4NIV.js";
import "./chunk-NAKEKTIK.js";
import "./chunk-QWNKYSI4.js";
import "./chunk-FMJZBZWF.js";
import "./chunk-GOYVJTGW.js";
import "./chunk-ZPYDYUP5.js";
import "./chunk-QEYOWTXD.js";
import "./chunk-KDO6J2FO.js";
import "./chunk-RT3T2K4S.js";
import "./chunk-WJCI2CGX.js";
import {
  a,
  d
} from "./chunk-REIQNAQW.js";
import {
  g
} from "./chunk-J6LQZWZI.js";
import {
  h as h3,
  j2,
  m as m2
} from "./chunk-OD3FDQCI.js";
import "./chunk-J2PJNRU7.js";
import "./chunk-56SPM3WK.js";
import "./chunk-XMZAPOBR.js";
import "./chunk-BLJKKR5D.js";
import "./chunk-ZGNCYHMZ.js";
import "./chunk-X2S4RQJ4.js";
import "./chunk-FUPLN7UM.js";
import "./chunk-376OPXM4.js";
import "./chunk-DER356EU.js";
import "./chunk-MZIWIEIR.js";
import {
  S
} from "./chunk-TQEOEDAZ.js";
import "./chunk-SHFHZMHO.js";
import "./chunk-NRP45AHD.js";
import "./chunk-IWQ7452U.js";
import "./chunk-NAN5J6QS.js";
import "./chunk-B4DKBAM3.js";
import {
  f as f2,
  o as o3
} from "./chunk-6M2AHKYV.js";
import "./chunk-SZIJNKCV.js";
import "./chunk-6O43OEU5.js";
import "./chunk-J2K7ZDSV.js";
import "./chunk-2UML3WQZ.js";
import "./chunk-KXVMEIWT.js";
import "./chunk-UDND2Z3V.js";
import "./chunk-23Y3DIC6.js";
import "./chunk-JUVQV3R3.js";
import {
  l
} from "./chunk-RAX2HD42.js";
import "./chunk-ZYRIJWLX.js";
import {
  h
} from "./chunk-C5H57NTD.js";
import {
  o as o2
} from "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import "./chunk-YWAQYJRC.js";
import {
  i
} from "./chunk-B356PXLT.js";
import "./chunk-EHPBHJYZ.js";
import {
  v2 as v
} from "./chunk-3MNMDUQZ.js";
import {
  w
} from "./chunk-UWG37XSU.js";
import "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import "./chunk-HLM6QCL2.js";
import "./chunk-RXYULINL.js";
import {
  U,
  h as h2,
  l as l2
} from "./chunk-5NXILPDI.js";
import "./chunk-THVR7IAM.js";
import "./chunk-ZWJJTUFL.js";
import "./chunk-XQN7F674.js";
import "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import "./chunk-KAN4HXCG.js";
import "./chunk-4FEGON7M.js";
import "./chunk-VWYWOOPX.js";
import "./chunk-M5VHU5LK.js";
import "./chunk-CXFRNDG4.js";
import "./chunk-7QMMKGW4.js";
import {
  e,
  m,
  n,
  n2,
  t as t2,
  t5 as t3,
  y
} from "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import {
  f,
  y as y2
} from "./chunk-MJXQTGI2.js";
import "./chunk-LIZHLHNA.js";
import "./chunk-BTUHYGXO.js";
import "./chunk-UA3YPL2R.js";
import "./chunk-HVKDYDPP.js";
import "./chunk-6QC7MLLS.js";
import {
  b,
  o,
  r,
  t
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/tileUtils.js
function c2(n4, o4) {
  return Q(o4.extent, e2), es(e2, o2(a3, n4.x, n4.y, 0));
}
var e2 = G();
var a3 = n3();

// node_modules/@arcgis/core/views/2d/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTiles2D.js
var u = class extends m {
  constructor(e3) {
    super(e3), this.pointOfInterest = null;
  }
  get tiles() {
    const e3 = this.tilesCoveringView, t6 = r(this.pointOfInterest) ? this.pointOfInterest : this.view.center;
    return e3.sort((e4, r3) => c2(t6, e4) - c2(t6, r3)), e3;
  }
  _scaleEnabled() {
    return c(this.view.scale, this.layer.minScale || 0, this.layer.maxScale || 0);
  }
  get tilesCoveringView() {
    if (!this.view.ready || !this.view.featuresTilingScheme || !this.view.state || t(this.tileInfo))
      return [];
    if (!this._scaleEnabled)
      return [];
    const { spans: e3, lodInfo: t6 } = this.view.featuresTilingScheme.getTileCoverage(this.view.state, 0), { level: r3 } = t6, o4 = [];
    for (const { row: i2, colFrom: s2, colTo: l4 } of e3)
      for (let e4 = s2; e4 <= l4; e4++) {
        const s3 = t6.normalizeCol(e4), l5 = new t4(null, r3, i2, s3);
        this.tileInfo.updateTileInfo(l5), o4.push(l5);
      }
    return o4;
  }
  get tileInfo() {
    var _a, _b;
    return (_b = (_a = this.view.featuresTilingScheme) == null ? void 0 : _a.tileInfo) != null ? _b : null;
  }
  get tileSize() {
    return r(this.tileInfo) ? this.tileInfo.size[0] : 256;
  }
  initialize() {
    this.addHandles(l2(() => {
      var _a, _b;
      return (_b = (_a = this.view) == null ? void 0 : _a.state) == null ? void 0 : _b.viewpoint;
    }, () => this.notifyChange("tilesCoveringView"), U));
  }
};
e([y({ readOnly: true })], u.prototype, "tiles", null), e([y({ readOnly: true })], u.prototype, "_scaleEnabled", null), e([y({ readOnly: true })], u.prototype, "tilesCoveringView", null), e([y({ readOnly: true })], u.prototype, "tileInfo", null), e([y({ readOnly: true })], u.prototype, "tileSize", null), e([y({ constructOnly: true })], u.prototype, "view", void 0), e([y({ constructOnly: true })], u.prototype, "layer", void 0), e([y()], u.prototype, "pointOfInterest", void 0), u = e([n2("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTiles2D")], u);

// node_modules/@arcgis/core/views/3d/layers/support/FeatureTileDescriptor3D.js
var s;
!function(i2) {
  i2[i2.INVISIBLE = 0] = "INVISIBLE", i2[i2.VISIBLE_WHEN_EXTENDED = 1] = "VISIBLE_WHEN_EXTENDED", i2[i2.VISIBLE_ON_SURFACE = 2] = "VISIBLE_ON_SURFACE";
}(s || (s = {}));

// node_modules/@arcgis/core/views/3d/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTiles3D.js
var u3 = class extends d {
  constructor(e3) {
    super(e3), this.pointOfInterest = null;
  }
  get tiles() {
    const e3 = this.tilesCoveringView, t6 = this._effectivePointOfInterest;
    if (r(t6)) {
      const r3 = e3.map((e4) => c2(t6, e4));
      for (let i2 = 1; i2 < r3.length; i2++)
        if (r3[i2 - 1] > r3[i2])
          return e3.sort((e4, r4) => c2(t6, e4) - c2(t6, r4)), e3.slice();
    }
    return e3;
  }
  get tilesCoveringView() {
    var _a, _b;
    return this._filterTiles((_b = (_a = this.view.featureTiles) == null ? void 0 : _a.tiles) == null ? void 0 : _b.toArray()).map(f3);
  }
  get tileInfo() {
    var _a, _b;
    return (_b = (_a = this.view.featureTiles) == null ? void 0 : _a.tilingScheme.toTileInfo()) != null ? _b : null;
  }
  get tileSize() {
    var _a, _b;
    return (_b = (_a = this.view.featureTiles) == null ? void 0 : _a.tileSize) != null ? _b : 256;
  }
  get _effectivePointOfInterest() {
    var _a;
    const e3 = this.pointOfInterest;
    return r(e3) ? e3 : (_a = this.view.pointsOfInterest) == null ? void 0 : _a.focus.location;
  }
  initialize() {
    this.handles.add(l2(() => this.view.featureTiles, (e3) => {
      this.handles.remove(v2), e3 && this.handles.add(e3.addClient(), v2);
    }, h2));
  }
  _filterTiles(e3) {
    if (t(e3))
      return [];
    return e3.filter((e4) => Math.abs(e4.measures.screenRect[3] - e4.measures.screenRect[1]) > m3 && e4.measures.visibility === s.VISIBLE_ON_SURFACE);
  }
};
function f3({ lij: [e3, t6, r3], extent: i2 }) {
  return new t4(`${e3}/${t6}/${r3}`, e3, t6, r3, i2);
}
e([y({ readOnly: true })], u3.prototype, "tiles", null), e([y({ readOnly: true })], u3.prototype, "tilesCoveringView", null), e([y({ readOnly: true })], u3.prototype, "tileInfo", null), e([y({ readOnly: true })], u3.prototype, "tileSize", null), e([y({ constructOnly: true })], u3.prototype, "view", void 0), e([y()], u3.prototype, "pointOfInterest", void 0), e([y()], u3.prototype, "_effectivePointOfInterest", null), u3 = e([n2("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTiles3D")], u3);
var m3 = 50;
var v2 = "feature-tiles";

// node_modules/@arcgis/core/views/support/TileTreeDebugger.js
var m4 = [[0, 179, 255], [117, 62, 128], [0, 104, 255], [215, 189, 166], [32, 0, 193], [98, 162, 206], [102, 112, 129], [52, 125, 0], [142, 118, 246], [138, 83, 0], [92, 122, 255], [122, 55, 83], [0, 142, 255], [81, 40, 179], [0, 200, 244], [13, 24, 127], [0, 170, 147], [19, 58, 241], [22, 44, 35]];
var b2 = class extends m {
  constructor(e3) {
    super(e3), this.updating = false, this.enablePolygons = true, this.enableLabels = true, this._polygons = /* @__PURE__ */ new Map(), this._labels = /* @__PURE__ */ new Map(), this._enabled = true;
  }
  initialize() {
    this._symbols = m4.map((e3) => new S({ color: [e3[0], e3[1], e3[2], 0.6], outline: { color: "black", width: 1 } })), this.update();
  }
  destroy() {
    this._enabled = false, this.clear();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e3) {
    this._enabled !== e3 && (this._enabled = e3, this.update());
  }
  update() {
    if (!this._enabled)
      return void this.clear();
    const e3 = (e4) => {
      if (r(e4.label))
        return e4.label;
      let s2 = e4.lij.toString();
      return r(e4.loadPriority) && (s2 += ` (${e4.loadPriority})`), s2;
    }, o4 = this.getTiles(), a6 = new Array(), n4 = new Set((this._labels.size, this._labels.keys()));
    o4.forEach((p5, m5) => {
      const b3 = p5.lij.toString();
      n4.delete(b3);
      const d3 = p5.lij[0], g2 = p5.geometry;
      if (this.enablePolygons && !this._polygons.has(b3)) {
        const e4 = new g({ geometry: g2, symbol: this._symbols[d3 % this._symbols.length] });
        this._polygons.set(b3, e4), a6.push(e4);
      }
      if (this.enableLabels) {
        const n5 = e3(p5), d4 = m5 / (o4.length - 1), u4 = h(0, 200, d4), _ = h(20, 6, d4) / 0.75, f4 = r(p5.loadPriority) && p5.loadPriority >= o4.length, w2 = new l([u4, f4 ? 0 : u4, f4 ? 0 : u4]), j3 = "3d" === this.view.type ? () => new h3({ verticalOffset: { screenLength: 40 / 0.75 }, callout: { type: "line", color: "white", border: { color: "black" } }, symbolLayers: [new j2({ text: n5, halo: { color: "white", size: 1 / 0.75 }, material: { color: w2 }, size: _ })] }) : () => new m2({ text: n5, haloColor: "white", haloSize: 1 / 0.75, color: w2, size: _ });
        if (this._labels.has(b3)) {
          const e4 = this._labels.get(b3), s2 = j3();
          (t(e4.symbol) || JSON.stringify(s2) !== JSON.stringify(e4.symbol)) && (e4.symbol = s2);
        } else {
          const e4 = new g({ geometry: g2.extent.center, symbol: j3() });
          this._labels.set(b3, e4), a6.push(e4);
        }
      }
    });
    const p4 = new Array();
    n4.forEach((e4) => {
      this._polygons.has(e4) && (p4.push(this._polygons.get(e4)), this._polygons.delete(e4)), this._labels.has(e4) && (p4.push(this._labels.get(e4)), this._labels.delete(e4));
    }), this.view.graphics.removeMany(p4), this.view.graphics.addMany(a6);
  }
  clear() {
    this.view.graphics.removeMany(Array.from(this._polygons.values())), this.view.graphics.removeMany(Array.from(this._labels.values())), this._polygons.clear(), this._labels.clear();
  }
};
e([y({ constructOnly: true })], b2.prototype, "view", void 0), e([y({ readOnly: true })], b2.prototype, "updating", void 0), e([y()], b2.prototype, "enabled", null), b2 = e([n2("esri.views.support.TileTreeDebugger")], b2);

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/WorkerTileTreeDebugger.js
var d2 = class extends b2 {
  constructor(e3) {
    super(e3), this._handles = new t3();
  }
  initialize() {
    const e3 = setInterval(() => this._fetchDebugInfo(), 2e3);
    this._handles.add(n(() => clearInterval(e3)));
  }
  destroy() {
    this._handles.destroy();
  }
  getTiles() {
    if (!this._debugInfo)
      return [];
    const e3 = /* @__PURE__ */ new Map(), t6 = /* @__PURE__ */ new Map();
    this._debugInfo.storedTiles.forEach((t7) => {
      e3.set(t7.data.id, t7.featureCount);
    }), this._debugInfo.pendingTiles.forEach((r4) => {
      e3.set(r4.data.id, r4.featureCount), t6.set(r4.data.id, r4.state);
    });
    const r3 = (r4) => {
      var _a;
      const o5 = t6.get(r4), s2 = (_a = e3.get(r4)) != null ? _a : "?";
      return o5 ? `${o5}:${s2}
${r4}` : `store:${s2}
${r4}`;
    }, o4 = /* @__PURE__ */ new Map();
    return this._debugInfo.storedTiles.forEach((e4) => {
      o4.set(e4.data.id, e4.data);
    }), this._debugInfo.pendingTiles.forEach((e4) => {
      o4.set(e4.data.id, e4.data);
    }), Array.from(o4.values()).map((e4) => ({ lij: [e4.level, e4.row, e4.col], geometry: v.fromExtent(f2(e4.extent, this.view.spatialReference)), label: r3(e4.id) }));
  }
  _fetchDebugInfo() {
    this.handle.getDebugInfo(null).then((e3) => {
      this._debugInfo = e3, this.update();
    });
  }
};
e([y({ constructOnly: true })], d2.prototype, "handle", void 0), d2 = e([n2("esri.views.interactive.snapping.featureSources.WorkerTileTreeDebugger")], d2);

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceSnappingSourceWorkerHandle.js
var l3 = class extends d {
  constructor(e3) {
    super(e3), this.schedule = null, this.hasZ = false, this.elevationAlignPointsInFeatures = async (e4) => {
      const t6 = [];
      for (const { points: i2 } of e4)
        for (const { z: e5 } of i2)
          t6.push(e5);
      return { elevations: t6, drapedObjectIds: /* @__PURE__ */ new Set(), failedObjectIds: /* @__PURE__ */ new Set() };
    }, this.queryForSymbologySnapping = async () => ({ candidates: [], sourceCandidateIndices: [] }), this.availability = 0, this._workerHandleUpdating = true, this._editId = 0;
  }
  get updating() {
    return this.updatingHandles.updating || this._workerHandleUpdating;
  }
  destroy() {
    this._workerHandle.destroy();
  }
  initialize() {
    this._workerHandle = new p3(this.schedule, { alignElevation: async (e3, { signal: t6 }) => ({ result: await this.elevationAlignPointsInFeatures(e3.points, t6) }), getSymbologyCandidates: async (e3, { signal: t6 }) => ({ result: await this.queryForSymbologySnapping(e3, t6) }) }), this.handles.add([this._workerHandle.on("notify-updating", ({ updating: e3 }) => this._workerHandleUpdating = e3), this._workerHandle.on("notify-availability", ({ availability: e3 }) => this._set("availability", e3))]);
  }
  async setup(e3, t6) {
    var _a;
    const o4 = this._serviceInfoFromLayer(e3.layer);
    if (t(o4))
      return;
    const a6 = { configuration: this._convertConfiguration(e3.configuration), serviceInfo: o4, spatialReference: e3.spatialReference.toJSON(), hasZ: this.hasZ, elevationInfo: (_a = e3.layer.elevationInfo) == null ? void 0 : _a.toJSON() };
    await this.updatingHandles.addPromise(this._workerHandle.invokeMethod("setup", a6, t6)), this.updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, t6));
  }
  async configure(e3, t6) {
    const i2 = this._convertConfiguration(e3);
    await this.updatingHandles.addPromise(this._workerHandle.invokeMethod("configure", i2, t6)), this.updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, t6));
  }
  async refresh(e3) {
    await this.updatingHandles.addPromise(this._workerHandle.invokeMethod("refresh", {}, e3)), this.updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, e3));
  }
  async fetchCandidates(e3, t6) {
    const i2 = { distance: e3.distance, point: e3.coordinateHelper.vectorToPoint(e3.point).toJSON(), types: e3.types, filter: r(e3.filter) ? e3.filter.toJSON() : null };
    return this._workerHandle.invoke(i2, t6);
  }
  async updateTiles(e3, t6) {
    const i2 = { tiles: e3.tiles, tileInfo: r(e3.tileInfo) ? e3.tileInfo.toJSON() : null, tileSize: e3.tileSize };
    await this.updatingHandles.addPromise(this._workerHandle.invokeMethod("updateTiles", i2, t6)), this.updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, t6));
  }
  async applyEdits(e3, t6) {
    var _a, _b, _c, _d, _e, _f;
    const i2 = this._editId++, n4 = { id: i2 };
    await this.updatingHandles.addPromise(this._workerHandle.invokeMethod("beginApplyEdits", n4, t6));
    const r3 = await this.updatingHandles.addPromise(y2(e3.result, t6)), s2 = { id: i2, edits: { addedFeatures: (_b = (_a = r3.addedFeatures) == null ? void 0 : _a.map(({ objectId: e4 }) => e4).filter(r)) != null ? _b : [], deletedFeatures: (_d = (_c = r3.deletedFeatures) == null ? void 0 : _c.map(({ objectId: e4, globalId: t7 }) => ({ objectId: e4, globalId: t7 }))) != null ? _d : [], updatedFeatures: (_f = (_e = r3.updatedFeatures) == null ? void 0 : _e.map(({ objectId: e4 }) => e4).filter(r)) != null ? _f : [] } };
    await this.updatingHandles.addPromise(this._workerHandle.invokeMethod("endApplyEdits", s2, t6)), this.updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, t6));
  }
  getDebugInfo(e3) {
    return this._workerHandle.invokeMethod("getDebugInfo", {}, e3);
  }
  async notifyElevationSourceChange() {
    await this._workerHandle.invokeMethod("notifyElevationSourceChange", {});
  }
  async notifySymbologyChange() {
    await this._workerHandle.invokeMethod("notifySymbologyChange", {});
  }
  async setSymbologySnappingSupported(e3) {
    await this._workerHandle.invokeMethod("setSymbologySnappingSupported", e3);
  }
  _convertConfiguration(e3) {
    return { filter: r(e3.filter) ? e3.filter.toJSON() : null, customParameters: e3.customParameters, viewType: e3.viewType };
  }
  _serviceInfoFromLayer(e3) {
    var _a, _b, _c;
    return "multipatch" === e3.geometryType || "mesh" === e3.geometryType ? null : { url: (_b = (_a = e3.parsedUrl) == null ? void 0 : _a.path) != null ? _b : "", fields: e3.fields.map((e4) => e4.toJSON()), geometryType: i.toJSON(e3.geometryType), capabilities: e3.capabilities, objectIdField: e3.objectIdField, globalIdField: e3.globalIdField, spatialReference: e3.spatialReference.toJSON(), timeInfo: (_c = e3.timeInfo) == null ? void 0 : _c.toJSON() };
  }
};
e([y({ constructOnly: true })], l3.prototype, "schedule", void 0), e([y({ constructOnly: true })], l3.prototype, "hasZ", void 0), e([y({ constructOnly: true })], l3.prototype, "elevationAlignPointsInFeatures", void 0), e([y({ constructOnly: true })], l3.prototype, "queryForSymbologySnapping", void 0), e([y({ readOnly: true })], l3.prototype, "updating", null), e([y({ readOnly: true })], l3.prototype, "availability", void 0), e([y()], l3.prototype, "_workerHandleUpdating", void 0), l3 = e([n2("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceSnappingSourceWorkerHandle")], l3);
var p3 = class extends h4 {
  constructor(e3, t6) {
    super("FeatureServiceSnappingSourceWorker", "fetchCandidates", {}, e3, { strategy: "dedicated", client: t6 });
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTilesSimple.js
var a5 = class extends m {
  constructor(e3) {
    super(e3), this.pointOfInterest = null;
  }
  get tiles() {
    return [new t4("0/0/0", 0, 0, 0, o3(-1e8, -1e8, 1e8, 1e8))];
  }
  get tileInfo() {
    return new j({ origin: new w({ x: -1e8, y: 1e8, spatialReference: this.layer.spatialReference }), size: [512, 512], lods: [new p({ level: 0, scale: 1, resolution: 390625 })], spatialReference: this.layer.spatialReference });
  }
  get tileSize() {
    return this.tileInfo.size[0];
  }
};
e([y({ readOnly: true })], a5.prototype, "tiles", null), e([y({ readOnly: true })], a5.prototype, "tileInfo", null), e([y({ readOnly: true })], a5.prototype, "tileSize", null), e([y({ constructOnly: true })], a5.prototype, "layer", void 0), e([y()], a5.prototype, "pointOfInterest", void 0), a5 = e([n2("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTilesSimple")], a5);

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/FeatureServiceSnappingSource.js
var k = class extends a(m) {
  constructor(e3) {
    super(e3);
  }
  get _updateTilesParameters() {
    return { tiles: this._tilesOfInterest.tiles, tileInfo: this._tilesOfInterest.tileInfo, tileSize: this._tilesOfInterest.tileSize };
  }
  get updating() {
    return this._workerHandle.updating || this.updatingHandles.updating;
  }
  get configuration() {
    const { view: e3 } = this, t6 = r(e3) ? e3.type : "2d";
    return { filter: this._layer.createQuery(), customParameters: this._layer.customParameters, viewType: t6 };
  }
  get availability() {
    return this._workerHandle.availability;
  }
  get _layer() {
    return this.layerSource.layer;
  }
  initialize() {
    var _a;
    const e3 = this.view;
    if (r(e3))
      switch (e3.type) {
        case "2d":
          this._tilesOfInterest = new u({ view: e3, layer: this._layer }), this._workerHandle = new l3();
          break;
        case "3d": {
          const { resourceController: t6 } = e3, r3 = this._layer, i2 = e3.whenLayerView(r3);
          this._tilesOfInterest = new u3({ view: e3 }), this._workerHandle = new l3({ schedule: (e4) => t6.schedule(e4), hasZ: this._layer.hasZ && ((_a = this._layer.returnZ) != null ? _a : true), elevationAlignPointsInFeatures: async (e4, t7) => {
            const r4 = await i2;
            return f(t7), r4.elevationAlignPointsInFeatures(e4, t7);
          }, queryForSymbologySnapping: async (e4, t7) => {
            const r4 = await i2;
            return f(t7), r4.queryForSymbologySnapping(e4, t7);
          } });
          const o4 = new t5(null);
          i2.then((e4) => o4.set(e4)), this.addHandles([e3.elevationProvider.on("elevation-change", ({ context: e4 }) => {
            var _a2;
            const { elevationInfo: t7 } = r3;
            y3(e4, t7) && ((_a2 = this._workerHandle) == null ? void 0 : _a2.notifyElevationSourceChange());
          }), l2(() => r3.elevationInfo, () => {
            var _a2;
            return (_a2 = this._workerHandle) == null ? void 0 : _a2.notifyElevationSourceChange();
          }, h2), l2(() => o(o4.get(), ({ processor: e4 }) => e4 == null ? void 0 : e4.renderer), () => {
            var _a2;
            return (_a2 = this._workerHandle) == null ? void 0 : _a2.notifySymbologyChange();
          }, h2), l2(() => b(o4.get(), false, (e4) => e4.symbologySnappingSupported), (e4) => {
            var _a2;
            return (_a2 = this._workerHandle) == null ? void 0 : _a2.setSymbologySnappingSupported(e4);
          }, h2)]);
          break;
        }
      }
    else
      this._tilesOfInterest = new a5({ layer: this._layer }), this._workerHandle = new l3();
    this.handles.add([t2(this._workerHandle)]), this._workerHandle.setup({ layer: this._layer, spatialReference: this.spatialReference, configuration: this.configuration }, null), this.updatingHandles.add(() => this._updateTilesParameters, () => this._workerHandle.updateTiles(this._updateTilesParameters, null), h2), this.handles.add([l2(() => this.configuration, (e4) => this._workerHandle.configure(e4, null), U)]), r(e3) && this.handles.add(l2(() => p2.FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES, (t6) => {
      t6 && !this._debug ? (this._debug = new d2({ view: e3, handle: this._workerHandle }), this.handles.add(t2(this._debug), "debug")) : !t6 && this._debug && this.handles.remove("debug");
    }, h2)), this.handles.add(this.layerSource.layer.on("apply-edits", (e4) => {
      this._workerHandle.applyEdits(e4, null);
    }));
  }
  refresh() {
    this._workerHandle.refresh(null);
  }
  async fetchCandidates(e3, t6) {
    const { coordinateHelper: r3, elevationInfo: i2, point: o4 } = e3;
    this._tilesOfInterest.pointOfInterest = r3.vectorToPoint(o4);
    const s2 = r3.hasZ() ? E : i2, n4 = this._getGroundElevation;
    return (await this._workerHandle.fetchCandidates({ ...e3 }, t6)).candidates.map((e4) => r2(e4, r3, s2, n4));
  }
  getDebugInfo(e3) {
    return this._workerHandle.getDebugInfo(e3);
  }
  get _getGroundElevation() {
    return a2(this.view);
  }
};
e([y({ constructOnly: true })], k.prototype, "spatialReference", void 0), e([y({ constructOnly: true })], k.prototype, "layerSource", void 0), e([y({ constructOnly: true })], k.prototype, "view", void 0), e([y()], k.prototype, "_tilesOfInterest", void 0), e([y({ readOnly: true })], k.prototype, "_updateTilesParameters", null), e([y({ readOnly: true })], k.prototype, "updating", null), e([y({ readOnly: true })], k.prototype, "configuration", null), e([y({ readOnly: true })], k.prototype, "availability", null), e([y()], k.prototype, "_getGroundElevation", null), k = e([n2("esri.views.interactive.snapping.featureSources.FeatureServiceSnappingSource")], k);
export {
  k as FeatureServiceSnappingSource
};
//# sourceMappingURL=FeatureServiceSnappingSource-UCJFVNDY.js.map
