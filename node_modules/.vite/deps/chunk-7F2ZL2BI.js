import {
  s as s4
} from "./chunk-OJ2HHY2O.js";
import {
  j as j2
} from "./chunk-OOOPZLJE.js";
import {
  t
} from "./chunk-U2WD23Z5.js";
import {
  e as e2
} from "./chunk-E52E6T7N.js";
import {
  a as a2
} from "./chunk-REIQNAQW.js";
import {
  l as l2,
  w
} from "./chunk-5NXILPDI.js";
import {
  U
} from "./chunk-DMI7A7TC.js";
import {
  I
} from "./chunk-KAN4HXCG.js";
import {
  s as s3
} from "./chunk-VWYWOOPX.js";
import {
  e,
  l,
  m as m2,
  n2 as n,
  y as y2,
  y3
} from "./chunk-OOLCFNXJ.js";
import {
  a,
  j,
  p,
  v
} from "./chunk-MJXQTGI2.js";
import {
  s as s2
} from "./chunk-LIZHLHNA.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";
import {
  y
} from "./chunk-HVKDYDPP.js";
import {
  m
} from "./chunk-6QC7MLLS.js";

// node_modules/@arcgis/core/layers/support/serviceTileInfoProperty.js
var r = { type: j2, json: { origins: { service: { read: { source: ["tileInfo", "minScale", "maxScale", "minLOD", "maxLOD"], reader: n2 } } } } };
function n2(r2, n4, l4, o2) {
  if (!r2)
    return null;
  const { minScale: i, maxScale: t2, minLOD: m3, maxLOD: s5 } = n4;
  if (null != m3 && null != s5)
    return o2 && o2.ignoreMinMaxLOD ? j2.fromJSON(r2) : j2.fromJSON({ ...r2, lods: r2.lods.filter(({ level: e3 }) => null != e3 && e3 >= m3 && e3 <= s5) });
  if (0 !== i && 0 !== t2) {
    const n5 = (e3) => Math.round(1e4 * e3) / 1e4, l5 = i ? n5(i) : 1 / 0, o3 = t2 ? n5(t2) : -1 / 0;
    return j2.fromJSON({ ...r2, lods: r2.lods.filter((e3) => {
      const r3 = n5(e3.scale);
      return r3 <= l5 && r3 >= o3;
    }) });
  }
  return j2.fromJSON(r2);
}

// node_modules/@arcgis/core/layers/support/Tilemap.js
var l3 = class {
  constructor() {
    this.location = { left: 0, top: 0, width: 0, height: 0 }, this._allAvailability = "unknown", this.byteSize = 40;
  }
  getAvailability(t2, i) {
    if ("unknown" !== this._allAvailability)
      return this._allAvailability;
    const e3 = (t2 - this.location.top) * this.location.width + (i - this.location.left), a3 = e3 % 8, l4 = e3 >> 3, o2 = this._tileAvailabilityBitSet;
    return l4 < 0 || l4 > o2.length ? "unknown" : o2[l4] & 1 << a3 ? "available" : "unavailable";
  }
  _updateFromData(t2) {
    const i = this.location.width, e3 = this.location.height;
    let a3 = true, l4 = true;
    const o2 = Math.ceil(i * e3 / 8), n4 = new Uint8Array(o2);
    let r2 = 0;
    for (let s5 = 0; s5 < t2.length; s5++) {
      const i2 = s5 % 8;
      t2[s5] ? (l4 = false, n4[r2] |= 1 << i2) : a3 = false, 7 === i2 && ++r2;
    }
    l4 ? this._allAvailability = "unavailable" : a3 ? this._allAvailability = "available" : (this._allAvailability = "unknown", this._tileAvailabilityBitSet = n4, this.byteSize += n4.length);
  }
  static fromDefinition(a3, o2) {
    const r2 = a3.service.request || U, { row: s5, col: h, width: c, height: m3 } = a3, d = { query: { f: "json" } };
    return o2 = o2 ? { ...d, ...o2 } : d, r2(n3(a3), o2).then((t2) => t2.data).catch((t2) => {
      if (t2 && t2.details && 422 === t2.details.httpStatus)
        return { location: { top: s5, left: h, width: c, height: m3 }, valid: true, data: m(c * m3, 0) };
      throw t2;
    }).then((t2) => {
      if (t2.location && (t2.location.top !== s5 || t2.location.left !== h || t2.location.width !== c || t2.location.height !== m3))
        throw new s2("tilemap:location-mismatch", "Tilemap response for different location than requested", { response: t2, definition: { top: s5, left: h, width: c, height: m3 } });
      return l3.fromJSON(t2);
    });
  }
  static fromJSON(t2) {
    l3._validateJSON(t2);
    const i = new l3();
    return i.location = Object.freeze(y(t2.location)), i._updateFromData(t2.data), Object.freeze(i);
  }
  static _validateJSON(t2) {
    if (!t2 || !t2.location)
      throw new s2("tilemap:missing-location", "Location missing from tilemap response");
    if (false === t2.valid)
      throw new s2("tilemap:invalid", "Tilemap response was marked as invalid");
    if (!t2.data)
      throw new s2("tilemap:missing-data", "Data missing from tilemap response");
    if (!Array.isArray(t2.data))
      throw new s2("tilemap:data-mismatch", "Data must be an array of numbers");
    if (t2.data.length !== t2.location.width * t2.location.height)
      throw new s2("tilemap:data-mismatch", "Number of data items does not match width/height of tilemap");
  }
};
function o(t2) {
  return `${t2.level}/${t2.row}/${t2.col}/${t2.width}/${t2.height}`;
}
function n3(t2) {
  let i;
  if ("vector-tile" === t2.service.type)
    i = `${t2.service.url}/tilemap/${t2.level}/${t2.row}/${t2.col}/${t2.width}/${t2.height}`;
  else {
    const e4 = t2.service.tileServers;
    i = `${e4 && e4.length ? e4[t2.row % e4.length] : t2.service.url}/tilemap/${t2.level}/${t2.row}/${t2.col}/${t2.width}/${t2.height}`;
  }
  const e3 = t2.service.query;
  return e3 && (i = `${i}?${e3}`), i;
}

// node_modules/@arcgis/core/layers/support/TilemapCache.js
var j3;
var z = j3 = class extends a2(m2) {
  constructor(e3) {
    super(e3), this._pendingTilemapRequests = {}, this._availableLevels = {}, this.levels = 5, this.cacheByteSize = 2 * s4.MEGABYTES, this.request = U, this._prefetchingEnabled = true;
  }
  initialize() {
    this._tilemapCache = new e2(this.cacheByteSize), this.addHandles([l2(() => {
      const { layer: e3 } = this;
      return [e3 == null ? void 0 : e3.parsedUrl, e3 == null ? void 0 : e3.tileServers, e3 == null ? void 0 : e3.apiKey, e3 == null ? void 0 : e3.customParameters];
    }, () => this._initializeTilemapDefinition()), l2(() => {
      var _a, _b;
      return (_b = (_a = this.layer) == null ? void 0 : _a.tileInfo) == null ? void 0 : _b.lods;
    }, (e3) => this._initializeAvailableLevels(e3), w)]), this._initializeTilemapDefinition();
  }
  castLevels(e3) {
    return e3 <= 2 ? (s.getLogger(this.declaredClass).error("Minimum levels for Tilemap is 3, but got ", e3), 3) : e3;
  }
  get size() {
    return 1 << this.levels;
  }
  fetchTilemap(e3, t2, i, r2) {
    if (!this._availableLevels[e3])
      return Promise.reject(new s2("tilemap-cache:level-unavailable", `Level ${e3} is unavailable in the service`));
    const l4 = this._tmpTilemapDefinition, a3 = this._tilemapFromCache(e3, t2, i, l4);
    if (a3)
      return Promise.resolve(a3);
    const o2 = r2 && r2.signal;
    return r2 = { ...r2, signal: null }, new Promise((e4, t3) => {
      v(o2, () => t3(a()));
      const i2 = o(l4);
      let s5 = this._pendingTilemapRequests[i2];
      if (!s5) {
        s5 = l3.fromDefinition(l4, r2).then((e6) => (this._tilemapCache.put(i2, e6, e6.byteSize), e6));
        const e5 = () => delete this._pendingTilemapRequests[i2];
        this._pendingTilemapRequests[i2] = s5, s5.then(e5, e5);
      }
      s5.then(e4, t3);
    });
  }
  getAvailability(e3, t2, i) {
    if (!this._availableLevels[e3])
      return "unavailable";
    const r2 = this._tilemapFromCache(e3, t2, i, this._tmpTilemapDefinition);
    return r2 ? r2.getAvailability(t2, i) : "unknown";
  }
  fetchAvailability(e3, t2, i, r2) {
    return this._availableLevels[e3] ? this.fetchTilemap(e3, t2, i, r2).catch((e4) => e4).then((r3) => {
      if (r3 instanceof l3) {
        const l4 = r3.getAvailability(t2, i);
        if ("unavailable" === l4)
          throw new s2("tile-map:tile-unavailable", "Tile is not available", { level: e3, row: t2, col: i });
        return l4;
      }
      if (j(r3))
        throw r3;
      return "unknown";
    }) : Promise.reject(new s2("tilemap-cache:level-unavailable", `Level ${e3} is unavailable in the service`));
  }
  fetchAvailabilityUpsample(e3, t2, i, r2, s5) {
    r2.level = e3, r2.row = t2, r2.col = i;
    const l4 = this.layer.tileInfo;
    l4.updateTileInfo(r2);
    const a3 = this.fetchAvailability(e3, t2, i, s5).catch((e4) => {
      if (j(e4))
        throw e4;
      if (l4.upsampleTile(r2))
        return this.fetchAvailabilityUpsample(r2.level, r2.row, r2.col, r2);
      throw e4;
    });
    return this._fetchAvailabilityUpsamplePrefetch(r2.id, e3, t2, i, s5, a3), a3;
  }
  async _fetchAvailabilityUpsamplePrefetch(e3, t2, i, r2, s5, l4) {
    if (!this._prefetchingEnabled)
      return;
    const a3 = `prefetch-${e3}`;
    if (this.handles.has(a3))
      return;
    const o2 = new AbortController();
    l4.then(() => o2.abort(), () => o2.abort());
    let n4 = false;
    const c = { remove() {
      n4 || (n4 = true, o2.abort());
    } };
    if (this.handles.add(c, a3), await y3(10, o2.signal).catch(() => {
    }), n4 || (n4 = true, this.handles.remove(a3)), p(o2))
      return;
    const h = new t(e3, t2, i, r2), m3 = { ...s5, signal: o2.signal }, f = this.layer.tileInfo;
    for (let p2 = 0; j3._prefetches.length < j3._maxPrefetch && f.upsampleTile(h); ++p2) {
      const e4 = this.fetchAvailability(h.level, h.row, h.col, m3);
      j3._prefetches.push(e4);
      const t3 = () => {
        j3._prefetches.removeUnordered(e4);
      };
      e4.then(t3, t3);
    }
  }
  _initializeTilemapDefinition() {
    var _a;
    if (!this.layer.parsedUrl)
      return;
    const { parsedUrl: e3, apiKey: t2, customParameters: i } = this.layer;
    this._tilemapCache.clear(), this._tmpTilemapDefinition = { service: { url: e3.path, query: I({ ...e3.query, ...i, token: t2 != null ? t2 : (_a = e3.query) == null ? void 0 : _a.token }), tileServers: this.layer.tileServers, request: this.request, type: this.layer.type }, width: this.size, height: this.size, level: 0, row: 0, col: 0 };
  }
  _tilemapFromCache(e3, t2, i, r2) {
    r2.level = e3, r2.row = t2 - t2 % this.size, r2.col = i - i % this.size;
    const s5 = o(r2);
    return this._tilemapCache.get(s5);
  }
  _initializeAvailableLevels(e3) {
    this._availableLevels = {}, e3 && e3.forEach((e4) => this._availableLevels[e4.level] = true);
  }
  get test() {
    const e3 = this;
    return { get prefetchingEnabled() {
      return e3._prefetchingEnabled;
    }, set prefetchingEnabled(t2) {
      e3._prefetchingEnabled = t2;
    }, hasTilemap: (t2, i, r2) => !!e3._tilemapFromCache(t2, i, r2, e3._tmpTilemapDefinition) };
  }
};
z._maxPrefetch = 4, z._prefetches = new l({ initialSize: j3._maxPrefetch }), e([y2({ constructOnly: true, type: Number })], z.prototype, "levels", void 0), e([s3("levels")], z.prototype, "castLevels", null), e([y2({ readOnly: true, type: Number })], z.prototype, "size", null), e([y2({ constructOnly: true, type: Number })], z.prototype, "cacheByteSize", void 0), e([y2({ constructOnly: true })], z.prototype, "layer", void 0), e([y2({ constructOnly: true })], z.prototype, "request", void 0), z = j3 = e([n("esri.layers.support.TilemapCache")], z);

export {
  r,
  n2 as n,
  z
};
//# sourceMappingURL=chunk-7F2ZL2BI.js.map
