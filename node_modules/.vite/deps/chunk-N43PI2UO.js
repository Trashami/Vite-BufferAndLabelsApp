import {
  l
} from "./chunk-OOLCFNXJ.js";
import {
  r
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/core/MemCache.js
var s = -3;
var i;
!function(t) {
  t[t.ALL = 0] = "ALL", t[t.SOME = 1] = "SOME";
}(i || (i = {}));
var r2 = class {
  constructor(t, e, s2) {
    this._namespace = t, this._storage = e, this._removeFunc = false, this._hit = 0, this._miss = 0, this._storage.register(this), this._namespace += ":", s2 && (this._storage.registerRemoveFunc(this._namespace, s2), this._removeFunc = true);
  }
  destroy() {
    this._storage.clear(this._namespace), this._removeFunc && this._storage.deregisterRemoveFunc(this._namespace), this._storage.deregister(this), this._storage = null;
  }
  get namespace() {
    return this._namespace.slice(0, -1);
  }
  get hitRate() {
    return this._hit / (this._hit + this._miss);
  }
  get size() {
    return this._storage.size;
  }
  get maxSize() {
    return this._storage.maxSize;
  }
  resetHitRate() {
    this._hit = this._miss = 0;
  }
  put(t, e, s2, i2 = 0) {
    this._storage.put(this._namespace + t, e, s2, i2);
  }
  get(t) {
    const e = this._storage.get(this._namespace + t);
    return void 0 === e ? ++this._miss : ++this._hit, e;
  }
  pop(t) {
    const e = this._storage.pop(this._namespace + t);
    return void 0 === e ? ++this._miss : ++this._hit, e;
  }
  updateSize(t, e, s2) {
    this._storage.updateSize(this._namespace + t, e, s2);
  }
  clear() {
    this._storage.clear(this._namespace);
  }
  clearAll() {
    this._storage.clearAll();
  }
  getStats() {
    return this._storage.getStats();
  }
  resetStats() {
    this._storage.resetStats();
  }
};
var h = class {
  constructor(t = 10485760) {
    this._maxSize = t, this._db = /* @__PURE__ */ new Map(), this._size = 0, this._hit = 0, this._miss = 0, this._removeFuncs = new l(), this._users = new l();
  }
  destroy() {
    this.clearAll(), this._removeFuncs.clear(), this._users.clear(), this._db = null;
  }
  register(t) {
    this._users.push(t);
  }
  deregister(t) {
    this._users.removeUnordered(t);
  }
  registerRemoveFunc(t, e) {
    this._removeFuncs.push([t, e]);
  }
  deregisterRemoveFunc(t) {
    this._removeFuncs.filterInPlace((e) => e[0] !== t);
  }
  get size() {
    return this._size;
  }
  get maxSize() {
    return this._maxSize;
  }
  set maxSize(t) {
    this._maxSize = Math.max(t, 0), this._checkSizeLimit();
  }
  put(t, e, r3, h2) {
    const _ = this._db.get(t);
    if (_ && (this._size -= _.size, this._db.delete(t), _.entry !== e && this._notifyRemove(t, _.entry, i.ALL)), r3 > this._maxSize)
      return void this._notifyRemove(t, e, i.ALL);
    if (void 0 === e)
      return void console.warn("Refusing to cache undefined entry ");
    if (!r3 || r3 < 0)
      return void console.warn("Refusing to cache entry with invalid size " + r3);
    const o = 1 + Math.max(h2, s) - s;
    this._db.set(t, { entry: e, size: r3, lifetime: o, lives: o }), this._size += r3, this._checkSizeLimit();
  }
  updateSize(e, s2, r3) {
    const h2 = this._db.get(e);
    if (h2 && h2.entry === s2) {
      for (this._size -= h2.size; r3 > this._maxSize; ) {
        const h3 = this._notifyRemove(e, s2, i.SOME);
        if (!(r(h3) && h3 > 0))
          return void this._db.delete(e);
        r3 = h3;
      }
      h2.size = r3, this._size += r3, this._checkSizeLimit();
    }
  }
  pop(t) {
    const e = this._db.get(t);
    if (e)
      return this._size -= e.size, this._db.delete(t), ++this._hit, e.entry;
    ++this._miss;
  }
  get(t) {
    const e = this._db.get(t);
    if (void 0 !== e)
      return this._db.delete(t), e.lives = e.lifetime, this._db.set(t, e), ++this._hit, e.entry;
    ++this._miss;
  }
  getStats() {
    const t = { Size: Math.round(this._size / 1048576) + "/" + Math.round(this._maxSize / 1048576) + "MB", "Hit rate": Math.round(100 * this._getHitRate()) + "%", Entries: this._db.size.toString() }, e = {}, i2 = new Array();
    this._db.forEach((t2, s2) => {
      const r4 = t2.lifetime;
      i2[r4] = (i2[r4] || 0) + t2.size, this._users.forAll((i3) => {
        const r5 = i3.namespace;
        if (s2.startsWith(r5)) {
          const s3 = e[r5] || 0;
          e[r5] = s3 + t2.size;
        }
      });
    });
    const r3 = {};
    this._users.forAll((t2) => {
      const s2 = t2.namespace;
      if (!isNaN(t2.hitRate) && t2.hitRate > 0) {
        const i3 = e[s2] || 0;
        e[s2] = i3, r3[s2] = Math.round(100 * t2.hitRate) + "%";
      } else
        r3[s2] = "0%";
    });
    const h2 = Object.keys(e);
    h2.sort((t2, s2) => e[s2] - e[t2]), h2.forEach((s2) => t[s2] = Math.round(e[s2] / 2 ** 20) + "MB / " + r3[s2]);
    for (let _ = i2.length - 1; _ >= 0; --_) {
      const e2 = i2[_];
      e2 && (t["Priority " + (_ + s - 1)] = Math.round(e2 / this.size * 100) + "%");
    }
    return t;
  }
  resetStats() {
    this._hit = this._miss = 0, this._users.forAll((t) => t.resetHitRate());
  }
  clear(t) {
    this._db.forEach((e, s2) => {
      s2.startsWith(t) && (this._size -= e.size, this._db.delete(s2), this._notifyRemove(s2, e.entry, i.ALL));
    });
  }
  clearAll() {
    this._db.forEach((t, e) => this._notifyRemove(e, t.entry, i.ALL)), this._size = 0, this._db.clear();
  }
  _getHitRate() {
    return this._hit / (this._hit + this._miss);
  }
  _notifyRemove(t, e, s2) {
    let i2;
    return this._removeFuncs.some((r3) => {
      if (t.startsWith(r3[0])) {
        const t2 = r3[1](e, s2);
        return "number" == typeof t2 && (i2 = t2), true;
      }
      return false;
    }), i2;
  }
  _checkSizeLimit() {
    if (!(this._size <= this._maxSize))
      for (const [e, s2] of this._db) {
        if (this._db.delete(e), s2.lives <= 1) {
          this._size -= s2.size;
          const r3 = this._notifyRemove(e, s2.entry, i.SOME);
          r(r3) && r3 > 0 && (this._size += r3, s2.lives = s2.lifetime, s2.size = r3, this._db.set(e, s2));
        } else
          --s2.lives, this._db.set(e, s2);
        if (this._size <= 0.9 * this.maxSize)
          return;
      }
  }
};

export {
  s,
  i,
  r2 as r,
  h
};
//# sourceMappingURL=chunk-N43PI2UO.js.map
