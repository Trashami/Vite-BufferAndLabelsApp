import {
  A,
  C as C2,
  D,
  E as E2,
  F as F2,
  F2 as F3,
  G,
  N,
  W,
  a,
  a2,
  c,
  d,
  e as e2,
  e2 as e3,
  k,
  q,
  v as v2,
  x
} from "./chunk-BH4BTHIU.js";
import {
  u,
  w as w2
} from "./chunk-MRJEGZAZ.js";
import {
  g,
  t as t3
} from "./chunk-AKA4FJNZ.js";
import "./chunk-P6POPBMF.js";
import {
  l
} from "./chunk-U7A2AWFU.js";
import {
  J as J2
} from "./chunk-ZB4SIC65.js";
import "./chunk-P53ZRUMX.js";
import "./chunk-QOM6O2E2.js";
import {
  E,
  F2 as F,
  J,
  K,
  P2 as P,
  R,
  V,
  Y,
  e,
  le,
  n2 as n,
  re,
  t,
  t2,
  v2 as v,
  w,
  xe
} from "./chunk-GDBM63TX.js";
import "./chunk-6UMNMSQC.js";
import {
  f
} from "./chunk-36RXM3AP.js";
import "./chunk-GNLPM47O.js";
import "./chunk-UKETAWZI.js";
import "./chunk-HKYKZCGY.js";
import "./chunk-5MBCFCGH.js";
import "./chunk-TJ2I6XQT.js";
import "./chunk-EDHROVWI.js";
import "./chunk-34YPGGJT.js";
import "./chunk-NCXAKZRR.js";
import "./chunk-DUCSW4OU.js";
import "./chunk-WVDA5Z37.js";
import "./chunk-2ZKX6TXA.js";
import {
  Ze
} from "./chunk-53VWTVL2.js";
import "./chunk-6CR2FXC5.js";
import "./chunk-VYG3YGZX.js";
import "./chunk-65SMURZR.js";
import "./chunk-VGNX3TFX.js";
import "./chunk-TZTENXCS.js";
import "./chunk-RQPDRERN.js";
import "./chunk-MBLYC2KR.js";
import "./chunk-XGEPEYGB.js";
import "./chunk-6BYMCM5A.js";
import "./chunk-BR5PSTJI.js";
import "./chunk-2T7LFOXQ.js";
import "./chunk-NCONZRBI.js";
import "./chunk-76CXRT5P.js";
import "./chunk-LZKCWJVH.js";
import "./chunk-7Q5M7ANT.js";
import "./chunk-LPRQBCQL.js";
import "./chunk-QR4K7IDQ.js";
import "./chunk-7N45W3EA.js";
import "./chunk-MQVQXXLV.js";
import "./chunk-YTOF4Z6B.js";
import "./chunk-HAVCYBU2.js";
import "./chunk-4HXPP4EA.js";
import "./chunk-M3NPSHCI.js";
import "./chunk-SBKKCBDN.js";
import "./chunk-MLVV3H5S.js";
import "./chunk-A4HIS5ZJ.js";
import "./chunk-AMLHWG76.js";
import "./chunk-OFQYIOO7.js";
import "./chunk-ZJZBAYFU.js";
import "./chunk-G3HEFWHV.js";
import "./chunk-3GENFQBG.js";
import "./chunk-FX6IXM55.js";
import "./chunk-QFFP6A5Q.js";
import "./chunk-O5PXWHV2.js";
import "./chunk-J5VTDQTQ.js";
import "./chunk-YF2CRSQX.js";
import "./chunk-JP3KAUQB.js";
import "./chunk-INL7BDTP.js";
import "./chunk-PDEVQZ7U.js";
import "./chunk-7XXQ7762.js";
import "./chunk-DVGM5RQS.js";
import "./chunk-R6OA44DQ.js";
import "./chunk-QTYVDCOW.js";
import "./chunk-YGVY4EIZ.js";
import "./chunk-HSDU7DIL.js";
import "./chunk-FWRLW4G5.js";
import "./chunk-JNNRJ7GQ.js";
import "./chunk-E52E6T7N.js";
import "./chunk-UK3I5WXR.js";
import {
  y
} from "./chunk-GLGOVVCK.js";
import "./chunk-BUVDI6S7.js";
import "./chunk-6Z6ZAVRA.js";
import "./chunk-PK4W65H4.js";
import "./chunk-GY2AJLN6.js";
import "./chunk-W62B63EU.js";
import "./chunk-N43PI2UO.js";
import "./chunk-O6VYMEIX.js";
import "./chunk-NDQ5FHGV.js";
import "./chunk-HUQX7WZO.js";
import "./chunk-BYSA56OH.js";
import "./chunk-ZWUEORSX.js";
import "./chunk-US2IWMHE.js";
import "./chunk-ZL4T4NIV.js";
import "./chunk-NAKEKTIK.js";
import "./chunk-QWNKYSI4.js";
import "./chunk-FMJZBZWF.js";
import "./chunk-GOYVJTGW.js";
import "./chunk-ZPYDYUP5.js";
import "./chunk-TDV3ZXCQ.js";
import "./chunk-XJCUKRCO.js";
import "./chunk-SOEQPPQP.js";
import "./chunk-22F6X66Z.js";
import "./chunk-AIDV7EKX.js";
import "./chunk-FZQZIM7U.js";
import "./chunk-YM6PUX7G.js";
import "./chunk-QEYOWTXD.js";
import "./chunk-CZBRZ6SU.js";
import "./chunk-KDO6J2FO.js";
import "./chunk-RT3T2K4S.js";
import "./chunk-WJCI2CGX.js";
import "./chunk-REIQNAQW.js";
import "./chunk-J6LQZWZI.js";
import "./chunk-OD3FDQCI.js";
import "./chunk-J2PJNRU7.js";
import "./chunk-56SPM3WK.js";
import "./chunk-XMZAPOBR.js";
import "./chunk-BLJKKR5D.js";
import "./chunk-ZGNCYHMZ.js";
import "./chunk-X2S4RQJ4.js";
import "./chunk-FUPLN7UM.js";
import "./chunk-376OPXM4.js";
import "./chunk-DER356EU.js";
import "./chunk-MZIWIEIR.js";
import "./chunk-TQEOEDAZ.js";
import "./chunk-SHFHZMHO.js";
import "./chunk-NRP45AHD.js";
import "./chunk-IWQ7452U.js";
import "./chunk-NAN5J6QS.js";
import "./chunk-B4DKBAM3.js";
import "./chunk-6M2AHKYV.js";
import "./chunk-SZIJNKCV.js";
import "./chunk-6O43OEU5.js";
import "./chunk-J2K7ZDSV.js";
import "./chunk-2UML3WQZ.js";
import "./chunk-KXVMEIWT.js";
import "./chunk-UDND2Z3V.js";
import "./chunk-23Y3DIC6.js";
import "./chunk-JUVQV3R3.js";
import "./chunk-RAX2HD42.js";
import "./chunk-ZYRIJWLX.js";
import "./chunk-C5H57NTD.js";
import "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import "./chunk-YWAQYJRC.js";
import "./chunk-B356PXLT.js";
import "./chunk-EHPBHJYZ.js";
import "./chunk-3MNMDUQZ.js";
import "./chunk-UWG37XSU.js";
import "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import "./chunk-HLM6QCL2.js";
import "./chunk-RXYULINL.js";
import "./chunk-5NXILPDI.js";
import "./chunk-THVR7IAM.js";
import "./chunk-ZWJJTUFL.js";
import "./chunk-XQN7F674.js";
import "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import "./chunk-KAN4HXCG.js";
import "./chunk-4FEGON7M.js";
import "./chunk-VWYWOOPX.js";
import "./chunk-M5VHU5LK.js";
import "./chunk-CXFRNDG4.js";
import "./chunk-7QMMKGW4.js";
import "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import {
  C
} from "./chunk-MJXQTGI2.js";
import "./chunk-LIZHLHNA.js";
import "./chunk-BTUHYGXO.js";
import "./chunk-UA3YPL2R.js";
import "./chunk-HVKDYDPP.js";
import "./chunk-6QC7MLLS.js";
import "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/arcade/functions/featuresetbase.js
function J3(e4, t4, n2, i) {
  if (1 === i.length) {
    if (Y(i[0]))
      return l(e4, i[0], -1);
    if (E(i[0]))
      return l(e4, i[0].toArray(), -1);
  }
  return l(e4, i, -1);
}
async function V2(e4, t4, n2) {
  const i = e4.getVariables();
  if (i.length > 0) {
    const a3 = [];
    for (let e5 = 0; e5 < i.length; e5++) {
      const r2 = { name: i[e5] };
      a3.push(await t4.evaluateIdentifier(n2, r2));
    }
    const r = {};
    for (let e5 = 0; e5 < i.length; e5++)
      r[i[e5]] = a3[e5];
    return e4.parameters = r, e4;
  }
  return e4;
}
function q2(e4, t4, n2 = null) {
  for (const i in e4)
    if (i.toLowerCase() === t4.toLowerCase())
      return e4[i];
  return n2;
}
function K2(e4) {
  if (null === e4)
    return null;
  const t4 = { type: q2(e4, "type", ""), name: q2(e4, "name", "") };
  if ("range" === t4.type)
    t4.range = q2(e4, "range", []);
  else {
    t4.codedValues = [];
    for (const n2 of q2(e4, "codedValues", []))
      t4.codedValues.push({ name: q2(n2, "name", ""), code: q2(n2, "code", null) });
  }
  return t4;
}
function X(e4) {
  if (null === e4)
    return null;
  const t4 = {}, n2 = q2(e4, "wkt", null);
  null !== n2 && (t4.wkt = n2);
  const i = q2(e4, "wkid", null);
  return null !== i && (t4.wkid = i), t4;
}
function Y2(e4) {
  if (null === e4)
    return null;
  const t4 = { hasZ: q2(e4, "hasz", false), hasM: q2(e4, "hasm", false) }, n2 = q2(e4, "spatialreference", null);
  n2 && (t4.spatialReference = X(n2));
  const i = q2(e4, "x", null);
  if (null !== i)
    return t4.x = i, t4.y = q2(e4, "y", null), t4;
  const a3 = q2(e4, "rings", null);
  if (null !== a3)
    return t4.rings = a3, t4;
  const r = q2(e4, "paths", null);
  if (null !== r)
    return t4.paths = r, t4;
  const s = q2(e4, "points", null);
  if (null !== s)
    return t4.points = s, t4;
  for (const o of ["xmin", "xmax", "ymin", "ymax", "zmin", "zmax", "mmin", "mmax"]) {
    const n3 = q2(e4, o, null);
    null !== n3 && (t4[o] = n3);
  }
  return t4;
}
function Z(e4, t4) {
  for (const n2 of t4)
    if (n2 === e4)
      return true;
  return false;
}
function Q(e4) {
  return !!e4.layerDefinition && (!!e4.featureSet && (false !== Z(e4.layerDefinition.geometryType, ["", "esriGeometryPoint", "esriGeometryPolyline", "esriGeometryPolygon", "esriGeometryMultipoint", "esriGeometryEnvelope"]) && (null !== e4.layerDefinition.objectIdField && "" !== e4.layerDefinition.objectIdField && (false !== Y(e4.layerDefinition.fields) && false !== Y(e4.featureSet.features)))));
}
function ee(G2) {
  "async" === G2.mode && (G2.functions.getuser = function(a3, r) {
    return G2.standardFunctionAsync(a3, r, async (l2, f2, c2) => {
      V(c2, 0, 2, a3, r);
      let u2 = v(c2[1], ""), d2 = true === u2;
      if (u2 = true === u2 || false === u2 ? "" : K(u2), 0 === c2.length || c2[0] instanceof t3) {
        let e4 = null;
        a3.services && a3.services.portal && (e4 = a3.services.portal), c2.length > 0 && (e4 = D(c2[0], e4));
        const n2 = await q(e4, u2, d2);
        if (n2) {
          const e5 = JSON.parse(JSON.stringify(n2));
          for (const t4 of ["lastLogin", "created", "modified"])
            void 0 !== e5[t4] && null !== e5[t4] && (e5[t4] = new Date(e5[t4]));
          return J2.convertObjectToArcadeDictionary(e5);
        }
        return null;
      }
      let m = null;
      if (P(c2[0]) && (m = c2[0]), m) {
        if (d2 = false, u2)
          return null;
        await m.load();
        const n2 = await m.getOwningSystemUrl();
        if (!n2) {
          if (!u2) {
            const e4 = await m.getIdentityUser();
            return e4 ? J2.convertObjectToArcadeDictionary({ username: e4 }) : null;
          }
          return null;
        }
        let i = null;
        a3.services && a3.services.portal && (i = a3.services.portal), i = D(new t3(n2), i);
        const r2 = await q(i, u2, d2);
        if (r2) {
          const e4 = JSON.parse(JSON.stringify(r2));
          for (const t4 of ["lastLogin", "created", "modified"])
            void 0 !== e4[t4] && null !== e4[t4] && (e4[t4] = new Date(e4[t4]));
          return J2.convertObjectToArcadeDictionary(e4);
        }
        return null;
      }
      throw new t(a3, e.InvalidParameter, r);
    });
  }, G2.signatures.push({ name: "getuser", min: 1, max: 2 }), G2.functions.featuresetbyid = function(e4, t4) {
    return G2.standardFunctionAsync(e4, t4, (a3, s, o) => {
      if (V(o, 2, 4, e4, t4), o[0] instanceof e2) {
        const a4 = K(o[1]);
        let r = v(o[2], null);
        const s2 = le(v(o[3], true));
        if (null === r && (r = ["*"]), false === Y(r))
          throw new t(e4, e.InvalidParameter, t4);
        return o[0].featureSetById(a4, s2, r);
      }
      throw new t(e4, e.InvalidParameter, t4);
    });
  }, G2.signatures.push({ name: "featuresetbyid", min: 2, max: 4 }), G2.functions.getfeatureset = function(e4, t4) {
    return G2.standardFunctionAsync(e4, t4, (a3, r, s) => {
      if (V(s, 1, 2, e4, t4), J(s[0])) {
        let t5 = v(s[1], "datasource");
        return null === t5 && (t5 = "datasource"), t5 = K(t5).toLowerCase(), v2(s[0].fullSchema(), t5, e4.lrucache, e4.interceptor, e4.spatialReference);
      }
      throw new t(e4, e.InvalidParameter, t4);
    });
  }, G2.signatures.push({ name: "getfeatureset", min: 1, max: 2 }), G2.functions.featuresetbyportalitem = function(t4, a3) {
    return G2.standardFunctionAsync(t4, a3, (r, o, l2) => {
      if (V(l2, 2, 5, t4, a3), null === l2[0])
        throw new t(t4, e.PortalRequired, a3);
      if (l2[0] instanceof t3) {
        const e4 = K(l2[1]), r2 = K(l2[2]);
        let o2 = v(l2[3], null);
        const c3 = le(v(l2[4], true));
        if (null === o2 && (o2 = ["*"]), false === Y(o2))
          throw new t(t4, e.InvalidParameter, a3);
        let u3 = null;
        return t4.services && t4.services.portal && (u3 = t4.services.portal), u3 = D(l2[0], u3), G(e4, r2, t4.spatialReference, o2, c3, u3, t4.lrucache, t4.interceptor);
      }
      if (false === w(l2[0]))
        throw new t(t4, e.PortalRequired, a3);
      const c2 = K(l2[0]), u2 = K(l2[1]);
      let d2 = v(l2[2], null);
      const m = le(v(l2[3], true));
      if (null === d2 && (d2 = ["*"]), false === Y(d2))
        throw new t(t4, e.InvalidParameter, a3);
      if (t4.services && t4.services.portal)
        return G(c2, u2, t4.spatialReference, d2, m, t4.services.portal, t4.lrucache, t4.interceptor);
      throw new t(t4, e.PortalRequired, a3);
    });
  }, G2.signatures.push({ name: "featuresetbyportalitem", min: 2, max: 5 }), G2.functions.featuresetbyname = function(e4, t4) {
    return G2.standardFunctionAsync(e4, t4, (a3, s, o) => {
      if (V(o, 2, 4, e4, t4), o[0] instanceof e2) {
        const a4 = K(o[1]);
        let r = v(o[2], null);
        const s2 = le(v(o[3], true));
        if (null === r && (r = ["*"]), false === Y(r))
          throw new t(e4, e.InvalidParameter, t4);
        return o[0].featureSetByName(a4, s2, r);
      }
      throw new t(e4, e.InvalidParameter, t4);
    });
  }, G2.signatures.push({ name: "featuresetbyname", min: 2, max: 4 }), G2.functions.featureset = function(e4, a3) {
    return G2.standardFunction(e4, a3, (r, s, o) => {
      V(o, 1, 1, e4, a3);
      let l2 = o[0];
      const f2 = { layerDefinition: { geometryType: "", objectIdField: "", globalIdField: "", typeIdField: "", fields: [] }, featureSet: { geometryType: "", features: [] } };
      if (w(l2))
        l2 = JSON.parse(l2), void 0 !== l2.layerDefinition ? (f2.layerDefinition = l2.layerDefinition, f2.featureSet = l2.featureSet, l2.layerDefinition.spatialReference && (f2.layerDefinition.spatialReference = l2.layerDefinition.spatialReference)) : (f2.featureSet.features = l2.features, f2.featureSet.geometryType = l2.geometryType, f2.layerDefinition.geometryType = f2.featureSet.geometryType, f2.layerDefinition.objectIdField = l2.objectIdFieldName, f2.layerDefinition.typeIdField = l2.typeIdFieldName, f2.layerDefinition.globalIdField = l2.globalIdFieldName, f2.layerDefinition.fields = l2.fields, l2.spatialReference && (f2.layerDefinition.spatialReference = l2.spatialReference));
      else {
        if (!(o[0] instanceof J2))
          throw new t(e4, e.InvalidParameter, a3);
        {
          l2 = JSON.parse(o[0].castToText(true));
          const e5 = q2(l2, "layerdefinition");
          if (null !== e5) {
            f2.layerDefinition.geometryType = q2(e5, "geometrytype", ""), f2.featureSet.geometryType = f2.layerDefinition.geometryType, f2.layerDefinition.globalIdField = q2(e5, "globalidfield", ""), f2.layerDefinition.objectIdField = q2(e5, "objectidfield", ""), f2.layerDefinition.typeIdField = q2(e5, "typeidfield", "");
            const t4 = q2(e5, "spatialreference", null);
            t4 && (f2.layerDefinition.spatialReference = X(t4));
            for (const i of q2(e5, "fields", [])) {
              const e6 = { name: q2(i, "name", ""), alias: q2(i, "alias", ""), type: q2(i, "type", ""), nullable: q2(i, "nullable", true), editable: q2(i, "editable", true), length: q2(i, "length", null), domain: K2(q2(i, "domain")) };
              f2.layerDefinition.fields.push(e6);
            }
            const n2 = q2(l2, "featureset", null);
            if (n2) {
              const e6 = {};
              for (const t5 of f2.layerDefinition.fields)
                e6[t5.name.toLowerCase()] = t5.name;
              for (const t5 of q2(n2, "features", [])) {
                const n3 = {}, i = q2(t5, "attributes", {});
                for (const t6 in i)
                  n3[e6[t6.toLowerCase()]] = i[t6];
                f2.featureSet.features.push({ attributes: n3, geometry: Y2(q2(t5, "geometry", null)) });
              }
            }
          } else {
            f2.layerDefinition.geometryType = q2(l2, "geometrytype", ""), f2.featureSet.geometryType = f2.layerDefinition.geometryType, f2.layerDefinition.objectIdField = q2(l2, "objectidfieldname", ""), f2.layerDefinition.typeIdField = q2(l2, "typeidfieldname", "");
            const e6 = q2(l2, "spatialreference", null);
            e6 && (f2.layerDefinition.spatialReference = X(e6));
            for (const n2 of q2(l2, "fields", [])) {
              const e7 = { name: q2(n2, "name", ""), alias: q2(n2, "alias", ""), type: q2(n2, "type", ""), nullable: q2(n2, "nullable", true), editable: q2(n2, "editable", true), length: q2(n2, "length", null), domain: K2(q2(n2, "domain")) };
              f2.layerDefinition.fields.push(e7);
            }
            const t4 = {};
            for (const n2 of f2.layerDefinition.fields)
              t4[n2.name.toLowerCase()] = n2.name;
            for (const n2 of q2(l2, "features", [])) {
              const e7 = {}, i = q2(n2, "attributes", {});
              for (const n3 in i)
                e7[t4[n3.toLowerCase()]] = i[n3];
              f2.featureSet.features.push({ attributes: e7, geometry: Y2(q2(n2, "geometry", null)) });
            }
          }
        }
      }
      if (false === Q(f2))
        throw new t(e4, e.InvalidParameter, a3);
      return d.create(f2, e4.spatialReference);
    });
  }, G2.signatures.push({ name: "featureset", min: 1, max: 1 }), G2.functions.filter = function(e4, t4) {
    return G2.standardFunctionAsync(e4, t4, async (a3, r, s) => {
      if (V(s, 2, 2, e4, t4), Y(s[0]) || E(s[0])) {
        const a4 = [];
        let r2 = s[0];
        r2 instanceof t2 && (r2 = r2.toArray());
        let o = null;
        if (!F(s[1]))
          throw new t(e4, e.InvalidParameter, t4);
        o = s[1].createFunction(e4);
        for (const e5 of r2) {
          const t5 = o(e5);
          C(t5) ? true === await t5 && a4.push(e5) : true === t5 && a4.push(e5);
        }
        return a4;
      }
      if (P(s[0])) {
        const t5 = await s[0].load(), n2 = f.create(s[1], t5.getFieldsIndex()), i = n2.getVariables();
        if (i.length > 0) {
          const t6 = [];
          for (let n3 = 0; n3 < i.length; n3++) {
            const a5 = { name: i[n3] };
            t6.push(await G2.evaluateIdentifier(e4, a5));
          }
          const a4 = {};
          for (let e5 = 0; e5 < i.length; e5++)
            a4[i[e5]] = t6[e5];
          return n2.parameters = a4, new c({ parentfeatureset: s[0], whereclause: n2 });
        }
        return new c({ parentfeatureset: s[0], whereclause: n2 });
      }
      throw new t(e4, e.InvalidParameter, t4);
    });
  }, G2.signatures.push({ name: "filter", min: 2, max: 2 }), G2.functions.orderby = function(e4, t4) {
    return G2.standardFunctionAsync(e4, t4, async (a3, r, s) => {
      if (V(s, 2, 2, e4, t4), P(s[0])) {
        const e5 = new e3(s[1]);
        return new a({ parentfeatureset: s[0], orderbyclause: e5 });
      }
      throw new t(e4, e.InvalidParameter, t4);
    });
  }, G2.signatures.push({ name: "orderby", min: 2, max: 2 }), G2.functions.top = function(e4, t4) {
    return G2.standardFunctionAsync(e4, t4, async (a3, r, s) => {
      if (V(s, 2, 2, e4, t4), P(s[0]))
        return new a2({ parentfeatureset: s[0], topnum: s[1] });
      if (Y(s[0]))
        return re(s[1]) >= s[0].length ? s[0].slice(0) : s[0].slice(0, re(s[1]));
      if (E(s[0]))
        return re(s[1]) >= s[0].length() ? s[0].slice(0) : s[0].slice(0, re(s[1]));
      throw new t(e4, e.InvalidParameter, t4);
    });
  }, G2.signatures.push({ name: "top", min: 2, max: 2 }), G2.functions.first = function(e4, t4) {
    return G2.standardFunctionAsync(e4, t4, async (n2, i, r) => {
      if (V(r, 1, 1, e4, t4), P(r[0])) {
        const e5 = await r[0].first(n2.abortSignal);
        if (null !== e5) {
          const t5 = g.createFromGraphicLikeObject(e5.geometry, e5.attributes, r[0]);
          return t5._underlyingGraphic = e5, t5;
        }
        return e5;
      }
      return Y(r[0]) ? 0 === r[0].length ? null : r[0][0] : E(r[0]) ? 0 === r[0].length() ? null : r[0].get(0) : null;
    });
  }, G2.signatures.push({ name: "first", min: 1, max: 1 }), G2.functions.attachments = function(e4, a3) {
    return G2.standardFunctionAsync(e4, a3, async (r, s, o) => {
      V(o, 1, 2, e4, a3);
      const l2 = { minsize: -1, maxsize: -1, types: null, returnMetadata: false };
      if (o.length > 1) {
        if (o[1] instanceof J2) {
          if (o[1].hasField("minsize") && (l2.minsize = re(o[1].field("minsize"))), o[1].hasField("metadata") && (l2.returnMetadata = le(o[1].field("metadata"))), o[1].hasField("maxsize") && (l2.maxsize = re(o[1].field("maxsize"))), o[1].hasField("types")) {
            const e5 = xe(o[1].field("types"), false);
            e5.length > 0 && (l2.types = e5);
          }
        } else if (null !== o[1])
          throw new t(e4, e.InvalidParameter, a3);
      }
      if (J(o[0])) {
        let t4 = o[0]._layer;
        return t4 instanceof Ze && (t4 = F3(t4, e4.spatialReference, ["*"], true, e4.lrucache, e4.interceptor)), null === t4 ? [] : false === P(t4) ? [] : (await t4.load(), t4.queryAttachments(o[0].field(t4.objectIdField), l2.minsize, l2.maxsize, l2.types, l2.returnMetadata));
      }
      if (null === o[0])
        return [];
      throw new t(e4, e.InvalidParameter, a3);
    });
  }, G2.signatures.push({ name: "attachments", min: 1, max: 2 }), G2.functions.featuresetbyrelationshipname = function(e4, t4) {
    return G2.standardFunctionAsync(e4, t4, async (a3, r, s) => {
      V(s, 2, 4, e4, t4);
      const o = s[0], l2 = K(s[1]);
      let f2 = v(s[2], null);
      const m = le(v(s[3], true));
      if (null === f2 && (f2 = ["*"]), false === Y(f2))
        throw new t(e4, e.InvalidParameter, t4);
      if (null === s[0])
        return null;
      if (!J(s[0]))
        throw new t(e4, e.InvalidParameter, t4);
      let p = o._layer;
      if (p instanceof Ze && (p = F3(p, e4.spatialReference, ["*"], true, e4.lrucache, e4.interceptor)), null === p)
        return null;
      if (false === P(p))
        return null;
      p = await p.load();
      const D2 = p.relationshipMetaData().filter((e5) => e5.name === l2);
      if (0 === D2.length)
        return null;
      if (void 0 !== D2[0].relationshipTableId && null !== D2[0].relationshipTableId && D2[0].relationshipTableId > -1)
        return k(p, D2[0], o.field(p.objectIdField), p.spatialReference, f2, m, e4.lrucache, e4.interceptor);
      let b = p.serviceUrl();
      if (!b)
        return null;
      b = "/" === b.charAt(b.length - 1) ? b + D2[0].relatedTableId.toString() : b + "/" + D2[0].relatedTableId.toString();
      const A2 = await N(b, p.spatialReference, f2, m, e4.lrucache, e4.interceptor);
      await A2.load();
      let N2 = A2.relationshipMetaData();
      if (N2 = N2.filter((e5) => e5.id === D2[0].id), false === o.hasField(D2[0].keyField) || null === o.field(D2[0].keyField)) {
        const e5 = await p.getFeatureByObjectId(o.field(p.objectIdField), [D2[0].keyField]);
        if (e5) {
          const t5 = f.create(N2[0].keyField + "= @id", A2.getFieldsIndex());
          return t5.parameters = { id: e5.attributes[D2[0].keyField] }, A2.filter(t5);
        }
        return new u({ parentfeatureset: A2 });
      }
      const x2 = f.create(N2[0].keyField + "= @id", A2.getFieldsIndex());
      return x2.parameters = { id: o.field(D2[0].keyField) }, A2.filter(x2);
    });
  }, G2.signatures.push({ name: "featuresetbyrelationshipname", min: 2, max: 4 }), G2.functions.featuresetbyassociation = function(e4, t4) {
    return G2.standardFunctionAsync(e4, t4, async (a3, r, s) => {
      V(s, 2, 3, e4, t4);
      const o = s[0], l2 = K(v(s[1], "")).toLowerCase(), f2 = w(s[2]) ? K(s[2]) : null;
      if (null === s[0])
        return null;
      if (!J(s[0]))
        throw new t(e4, e.InvalidParameter, t4);
      let u2 = o._layer;
      if (u2 instanceof Ze && (u2 = F3(u2, e4.spatialReference, ["*"], true, e4.lrucache, e4.interceptor)), null === u2)
        return null;
      if (false === P(u2))
        return null;
      await u2.load();
      const d2 = u2.serviceUrl(), p = await C2(d2, e4.spatialReference);
      let I = null, F4 = null, b = false;
      if (null !== f2 && "" !== f2 && void 0 !== f2) {
        for (const e5 of p.terminals)
          e5.terminalName === f2 && (F4 = e5.terminalId);
        null === F4 && (b = true);
      }
      const A2 = p.associations.getFieldsIndex(), N2 = A2.get("TOGLOBALID").name, x2 = A2.get("FROMGLOBALID").name, P2 = A2.get("TOTERMINALID").name, R2 = A2.get("FROMTERMINALID").name, O = A2.get("FROMNETWORKSOURCEID").name, C3 = A2.get("TONETWORKSOURCEID").name, M = A2.get("ASSOCIATIONTYPE").name, k2 = A2.get("ISCONTENTVISIBLE").name, z = A2.get("OBJECTID").name;
      for (const e5 of u2.fields)
        if ("global-id" === e5.type) {
          I = o.field(e5.name);
          break;
        }
      let G3 = null, U = new x(new y({ name: "percentalong", alias: "percentalong", type: "double" }), f.create("0", p.associations.getFieldsIndex())), J4 = new x(new y({ name: "side", alias: "side", type: "string" }), f.create("''", p.associations.getFieldsIndex()));
      const V3 = "globalid", q3 = "globalId", K3 = {};
      for (const e5 in p.lkp)
        K3[e5] = p.lkp[e5].sourceId;
      const X2 = new E2(new y({ name: "classname", alias: "classname", type: "string" }), null, K3);
      let Y3 = "";
      switch (l2) {
        case "midspan": {
          Y3 = `((${N2}='${I}') OR ( ${x2}='${I}')) AND (${M} IN (5))`, X2.codefield = f.create(`CASE WHEN (${N2}='${I}') THEN ${O} ELSE ${C3} END`, p.associations.getFieldsIndex());
          const e5 = n(A.findField(p.associations.fields, x2));
          e5.name = V3, e5.alias = V3, G3 = new x(e5, f.create(`CASE WHEN (${x2}='${I}') THEN ${N2} ELSE ${x2} END`, p.associations.getFieldsIndex())), U = p.unVersion >= 4 ? new F2(A.findField(p.associations.fields, A2.get("PERCENTALONG").name)) : new x(new y({ name: "percentalong", alias: "percentalong", type: "double" }), f.create("0", p.associations.getFieldsIndex()));
          break;
        }
        case "junctionedge": {
          Y3 = `((${N2}='${I}') OR ( ${x2}='${I}')) AND (${M} IN (4,6))`, X2.codefield = f.create(`CASE WHEN (${N2}='${I}') THEN ${O} ELSE ${C3} END`, p.associations.getFieldsIndex());
          const e5 = n(A.findField(p.associations.fields, x2));
          e5.name = V3, e5.alias = V3, G3 = new x(e5, f.create(`CASE WHEN (${x2}='${I}') THEN ${N2} ELSE ${x2} END`, p.associations.getFieldsIndex())), J4 = new x(new y({ name: "side", alias: "side", type: "string" }), f.create(`CASE WHEN (${M}=4) THEN 'from' ELSE 'to' END`, p.associations.getFieldsIndex()));
          break;
        }
        case "connected": {
          let e5 = `${N2}='@T'`, t5 = `${x2}='@T'`;
          null !== F4 && (e5 += ` AND ${P2}=@A`, t5 += ` AND ${R2}=@A`), Y3 = "((" + e5 + ") OR (" + t5 + "))", Y3 = R(Y3, "@T", I != null ? I : ""), e5 = R(e5, "@T", I != null ? I : ""), null !== F4 && (e5 = R(e5, "@A", F4.toString()), Y3 = R(Y3, "@A", F4.toString())), X2.codefield = f.create("CASE WHEN " + e5 + ` THEN ${O} ELSE ${C3} END`, p.associations.getFieldsIndex());
          const n2 = n(A.findField(p.associations.fields, x2));
          n2.name = V3, n2.alias = V3, G3 = new x(n2, f.create("CASE WHEN " + e5 + ` THEN ${x2} ELSE ${N2} END`, p.associations.getFieldsIndex()));
          break;
        }
        case "container":
          Y3 = `${N2}='${I}' AND ${M} = 2`, null !== F4 && (Y3 += ` AND ${P2} = ` + F4.toString()), X2.codefield = O, Y3 = "( " + Y3 + " )", G3 = new W(A.findField(p.associations.fields, x2), V3, V3);
        case "content":
          Y3 = `(${x2}='${I}' AND ${M} = 2)`, null !== F4 && (Y3 += ` AND ${R2} = ` + F4.toString()), X2.codefield = C3, Y3 = "( " + Y3 + " )", G3 = new W(A.findField(p.associations.fields, N2), V3, V3);
          break;
        case "structure":
          Y3 = `(${N2}='${I}' AND ${M} = 3)`, null !== F4 && (Y3 += ` AND ${P2} = ` + F4.toString()), X2.codefield = O, Y3 = "( " + Y3 + " )", G3 = new W(A.findField(p.associations.fields, x2), V3, q3);
          break;
        case "attached":
          Y3 = `(${x2}='${I}' AND ${M} = 3)`, null !== F4 && (Y3 += ` AND ${R2} = ` + F4.toString()), X2.codefield = C3, Y3 = "( " + Y3 + " )", G3 = new W(A.findField(p.associations.fields, N2), V3, q3);
          break;
        default:
          throw new t(e4, e.InvalidParameter, t4);
      }
      b && (Y3 = "1 <> 1");
      return new A({ parentfeatureset: p.associations, adaptedFields: [new F2(A.findField(p.associations.fields, z)), new F2(A.findField(p.associations.fields, k2)), G3, J4, X2, U], extraFilter: Y3 ? f.create(Y3, p.associations.getFieldsIndex()) : null });
    });
  }, G2.signatures.push({ name: "featuresetbyassociation", min: 2, max: 6 }), G2.functions.groupby = function(e4, a3) {
    return G2.standardFunctionAsync(e4, a3, async (r, s, o) => {
      if (V(o, 3, 3, e4, a3), !P(o[0]))
        throw new t(e4, e.InvalidParameter, a3);
      const l2 = await o[0].load(), f2 = [], c2 = [];
      let u2 = false, d2 = [];
      if (w(o[1]))
        d2.push(o[1]);
      else if (o[1] instanceof J2)
        d2.push(o[1]);
      else if (Y(o[1]))
        d2 = o[1];
      else {
        if (!E(o[1]))
          throw new t(e4, e.InvalidParameter, a3);
        d2 = o[1].toArray();
      }
      for (const m of d2)
        if (w(m)) {
          const e5 = f.create(K(m), l2.getFieldsIndex()), t4 = true === w2(e5) ? K(m) : "%%%%FIELDNAME";
          f2.push({ name: t4, expression: e5 }), "%%%%FIELDNAME" === t4 && (u2 = true);
        } else {
          if (!(m instanceof J2))
            throw new t(e4, e.InvalidParameter, a3);
          {
            const t4 = m.hasField("name") ? m.field("name") : "%%%%FIELDNAME", r2 = m.hasField("expression") ? m.field("expression") : "";
            if ("%%%%FIELDNAME" === t4 && (u2 = true), !t4)
              throw new t(e4, e.InvalidParameter, a3);
            f2.push({ name: t4, expression: f.create(r2 || t4, l2.getFieldsIndex()) });
          }
        }
      if (d2 = [], w(o[2]))
        d2.push(o[2]);
      else if (Y(o[2]))
        d2 = o[2];
      else if (E(o[2]))
        d2 = o[2].toArray();
      else {
        if (!(o[2] instanceof J2))
          throw new t(e4, e.InvalidParameter, a3);
        d2.push(o[2]);
      }
      for (const m of d2) {
        if (!(m instanceof J2))
          throw new t(e4, e.InvalidParameter, a3);
        {
          const t4 = m.hasField("name") ? m.field("name") : "", r2 = m.hasField("statistic") ? m.field("statistic") : "", s2 = m.hasField("expression") ? m.field("expression") : "";
          if (!t4 || !r2 || !s2)
            throw new t(e4, e.InvalidParameter, a3);
          c2.push({ name: t4, statistic: r2.toLowerCase(), expression: f.create(s2, l2.getFieldsIndex()) });
        }
      }
      if (u2) {
        const e5 = {};
        for (const n2 of l2.fields)
          e5[n2.name.toLowerCase()] = 1;
        for (const n2 of f2)
          "%%%%FIELDNAME" !== n2.name && (e5[n2.name.toLowerCase()] = 1);
        for (const n2 of c2)
          "%%%%FIELDNAME" !== n2.name && (e5[n2.name.toLowerCase()] = 1);
        let t4 = 0;
        for (const n2 of f2)
          if ("%%%%FIELDNAME" === n2.name) {
            for (; 1 === e5["field_" + t4.toString()]; )
              t4++;
            e5["field_" + t4.toString()] = 1, n2.name = "FIELD_" + t4.toString();
          }
      }
      for (const t4 of f2)
        await V2(t4.expression, G2, e4);
      for (const t4 of c2)
        await V2(t4.expression, G2, e4);
      return o[0].groupby(f2, c2);
    });
  }, G2.signatures.push({ name: "groupby", min: 3, max: 3 }), G2.functions.distinct = function(e4, a3) {
    return G2.standardFunctionAsync(e4, a3, async (r, s, o) => {
      if (P(o[0])) {
        V(o, 2, 2, e4, a3);
        const r2 = await o[0].load(), s2 = [];
        let l2 = [];
        if (w(o[1]))
          l2.push(o[1]);
        else if (o[1] instanceof J2)
          l2.push(o[1]);
        else if (Y(o[1]))
          l2 = o[1];
        else {
          if (!E(o[1]))
            throw new t(e4, e.InvalidParameter, a3);
          l2 = o[1].toArray();
        }
        let f2 = false;
        for (const o2 of l2)
          if (w(o2)) {
            const e5 = f.create(K(o2), r2.getFieldsIndex()), t4 = true === w2(e5) ? K(o2) : "%%%%FIELDNAME";
            s2.push({ name: t4, expression: e5 }), "%%%%FIELDNAME" === t4 && (f2 = true);
          } else {
            if (!(o2 instanceof J2))
              throw new t(e4, e.InvalidParameter, a3);
            {
              const t4 = o2.hasField("name") ? o2.field("name") : "%%%%FIELDNAME", l3 = o2.hasField("expression") ? o2.field("expression") : "";
              if ("%%%%FIELDNAME" === t4 && (f2 = true), !t4)
                throw new t(e4, e.InvalidParameter, a3);
              s2.push({ name: t4, expression: f.create(l3 || t4, r2.getFieldsIndex()) });
            }
          }
        if (f2) {
          const e5 = {};
          for (const n2 of r2.fields)
            e5[n2.name.toLowerCase()] = 1;
          for (const n2 of s2)
            "%%%%FIELDNAME" !== n2.name && (e5[n2.name.toLowerCase()] = 1);
          let t4 = 0;
          for (const n2 of s2)
            if ("%%%%FIELDNAME" === n2.name) {
              for (; 1 === e5["field_" + t4.toString()]; )
                t4++;
              e5["field_" + t4.toString()] = 1, n2.name = "FIELD_" + t4.toString();
            }
        }
        for (const t4 of s2)
          await V2(t4.expression, G2, e4);
        return o[0].groupby(s2, []);
      }
      return J3("distinct", r, s, o);
    });
  });
}
export {
  ee as registerFunctions
};
//# sourceMappingURL=featuresetbase-QYVV76WK.js.map
