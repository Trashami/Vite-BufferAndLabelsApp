import {
  o,
  r as r2
} from "./chunk-DUCSW4OU.js";
import {
  f
} from "./chunk-WVDA5Z37.js";
import {
  c,
  v as v2,
  y
} from "./chunk-EHPBHJYZ.js";
import {
  m2 as m,
  v2 as v
} from "./chunk-3MNMDUQZ.js";
import {
  R as R2,
  j
} from "./chunk-UWG37XSU.js";
import {
  R,
  k2 as k
} from "./chunk-LNZAOBFW.js";
import {
  U
} from "./chunk-DMI7A7TC.js";
import {
  j as j2
} from "./chunk-KAN4HXCG.js";
import {
  s as s3
} from "./chunk-LIZHLHNA.js";
import {
  s,
  s2
} from "./chunk-UA3YPL2R.js";
import {
  r,
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/geometry/support/normalizeUtilsCommon.js
var r3 = { 102100: { maxX: 20037508342788905e-9, minX: -20037508342788905e-9, plus180Line: new m({ paths: [[[20037508342788905e-9, -20037508342788905e-9], [20037508342788905e-9, 20037508342788905e-9]]], spatialReference: k.WebMercator }), minus180Line: new m({ paths: [[[-20037508342788905e-9, -20037508342788905e-9], [-20037508342788905e-9, 20037508342788905e-9]]], spatialReference: k.WebMercator }) }, 4326: { maxX: 180, minX: -180, plus180Line: new m({ paths: [[[180, -180], [180, 180]]], spatialReference: k.WGS84 }), minus180Line: new m({ paths: [[[-180, -180], [-180, 180]]], spatialReference: k.WGS84 }) } };
function i(e, n) {
  return Math.ceil((e - n) / (2 * n));
}
function s4(e, n) {
  const t2 = o2(e);
  for (const r4 of t2)
    for (const e2 of r4)
      e2[0] += n;
  return e;
}
function o2(e) {
  return y(e) ? e.rings : e.paths;
}

// node_modules/@arcgis/core/rest/geometryService/cut.js
async function o3(o5, i2, n, m2) {
  const a = f(o5), p = i2[0].spatialReference, u = { ...m2, query: { ...a.query, f: "json", sr: JSON.stringify(p), target: JSON.stringify({ geometryType: c(i2[0]), geometries: i2 }), cutter: JSON.stringify(n) } }, c2 = await U(a.path + "/cut", u), { cutIndexes: f2, geometries: g = [] } = c2.data;
  return { cutIndexes: f2, geometries: g.map((e) => {
    const t2 = v2(e);
    return t2.spatialReference = p, t2;
  }) };
}

// node_modules/@arcgis/core/rest/geometryService/simplify.js
async function o4(o5, m2, f2) {
  const n = "string" == typeof o5 ? j2(o5) : o5, p = m2[0].spatialReference, a = c(m2[0]), u = { ...f2, query: { ...n.query, f: "json", sr: p.wkid ? p.wkid : JSON.stringify(p), geometries: JSON.stringify(r2(m2)) } }, { data: y3 } = await U(n.path + "/simplify", u);
  return o(y3.geometries, a, p);
}

// node_modules/@arcgis/core/geometry/support/normalizeUtils.js
var y2 = s2.getLogger("esri.geometry.support.normalizeUtils");
function x(e) {
  return "polygon" === e.type;
}
function d(e) {
  return "polygon" === e[0].type;
}
function w(e) {
  return "polyline" === e[0].type;
}
function M(e, n) {
  if (!(e instanceof m || e instanceof v)) {
    const e2 = "straightLineDensify: the input geometry is neither polyline nor polygon";
    throw y2.error(e2), new s3(e2);
  }
  const o5 = o2(e), s5 = [];
  for (const t2 of o5) {
    const e2 = [];
    s5.push(e2), e2.push([t2[0][0], t2[0][1]]);
    for (let o6 = 0; o6 < t2.length - 1; o6++) {
      const s6 = t2[o6][0], r4 = t2[o6][1], i2 = t2[o6 + 1][0], l = t2[o6 + 1][1], f2 = Math.sqrt((i2 - s6) * (i2 - s6) + (l - r4) * (l - r4)), c2 = (l - r4) / f2, p = (i2 - s6) / f2, u = f2 / n;
      if (u > 1) {
        for (let l2 = 1; l2 <= u - 1; l2++) {
          const t4 = l2 * n, o8 = p * t4 + s6, i4 = c2 * t4 + r4;
          e2.push([o8, i4]);
        }
        const t3 = (f2 + Math.floor(u - 1) * n) / 2, o7 = p * t3 + s6, i3 = c2 * t3 + r4;
        e2.push([o7, i3]);
      }
      e2.push([i2, l]);
    }
  }
  return x(e) ? new v({ rings: s5, spatialReference: e.spatialReference }) : new m({ paths: s5, spatialReference: e.spatialReference });
}
function R3(e, t2, n) {
  if (t2) {
    const t3 = M(e, 1e6);
    e = j(t3, true);
  }
  return n && (e = s4(e, n)), e;
}
function b(e, t2, n) {
  if (Array.isArray(e)) {
    const o5 = e[0];
    if (o5 > t2) {
      const n2 = i(o5, t2);
      e[0] = o5 + n2 * (-2 * t2);
    } else if (o5 < n) {
      const t3 = i(o5, n);
      e[0] = o5 + t3 * (-2 * n);
    }
  } else {
    const o5 = e.x;
    if (o5 > t2) {
      const n2 = i(o5, t2);
      e = e.clone().offset(n2 * (-2 * t2), 0);
    } else if (o5 < n) {
      const t3 = i(o5, n);
      e = e.clone().offset(t3 * (-2 * n), 0);
    }
  }
  return e;
}
function P(e, t2) {
  let n = -1;
  for (let o5 = 0; o5 < t2.cutIndexes.length; o5++) {
    const s5 = t2.cutIndexes[o5], r4 = t2.geometries[o5], i2 = o2(r4);
    for (let e2 = 0; e2 < i2.length; e2++) {
      const t3 = i2[e2];
      t3.some((n2) => {
        if (n2[0] < 180)
          return true;
        {
          let n3 = 0;
          for (let e3 = 0; e3 < t3.length; e3++) {
            const o7 = t3[e3][0];
            n3 = o7 > n3 ? o7 : n3;
          }
          n3 = Number(n3.toFixed(9));
          const o6 = -360 * i(n3, 180);
          for (let s6 = 0; s6 < t3.length; s6++) {
            const t4 = r4.getPoint(e2, s6);
            r4.setPoint(e2, s6, t4.clone().offset(o6, 0));
          }
          return true;
        }
      });
    }
    if (s5 === n) {
      if (d(e))
        for (const t3 of o2(r4))
          e[s5] = e[s5].addRing(t3);
      else if (w(e))
        for (const t3 of o2(r4))
          e[s5] = e[s5].addPath(t3);
    } else
      n = s5, e[s5] = r4;
  }
  return e;
}
async function v3(t2, n, l) {
  var _a;
  if (!Array.isArray(t2))
    return v3([t2], n);
  n && "string" != typeof n && y2.warn("normalizeCentralMeridian()", "The url object is deprecated, use the url string instead");
  const h = "string" == typeof n ? n : (_a = n == null ? void 0 : n.url) != null ? _a : s.geometryServiceUrl;
  let x2, d2, w2, j3, M2, L, U3, z, A = 0;
  const S = [], k2 = [];
  for (const e of t2)
    if (t(e))
      k2.push(e);
    else if (x2 || (x2 = e.spatialReference, d2 = R(x2), w2 = x2.isWebMercator, L = w2 ? 102100 : 4326, j3 = r3[L].maxX, M2 = r3[L].minX, U3 = r3[L].plus180Line, z = r3[L].minus180Line), d2)
      if ("mesh" === e.type)
        k2.push(e);
      else if ("point" === e.type)
        k2.push(b(e.clone(), j3, M2));
      else if ("multipoint" === e.type) {
        const t3 = e.clone();
        t3.points = t3.points.map((e2) => b(e2, j3, M2)), k2.push(t3);
      } else if ("extent" === e.type) {
        const t3 = e.clone()._normalize(false, false, d2);
        k2.push(t3.rings ? new v(t3) : t3);
      } else if (e.extent) {
        const t3 = e.extent, n2 = i(t3.xmin, M2) * (2 * j3);
        let o5 = 0 === n2 ? e.clone() : s4(e.clone(), n2);
        t3.offset(n2, 0), t3.intersects(U3) && t3.xmax !== j3 ? (A = t3.xmax > A ? t3.xmax : A, o5 = R3(o5, w2), S.push(o5), k2.push("cut")) : t3.intersects(z) && t3.xmin !== M2 ? (A = t3.xmax * (2 * j3) > A ? t3.xmax * (2 * j3) : A, o5 = R3(o5, w2, 360), S.push(o5), k2.push("cut")) : k2.push(o5);
      } else
        k2.push(e.clone());
    else
      k2.push(e);
  let C = i(A, j3), I = -90;
  const X = C, q = new m();
  for (; C > 0; ) {
    const e = 360 * C - 180;
    q.addPath([[e, I], [e, -1 * I]]), I *= -1, C--;
  }
  if (S.length > 0 && X > 0) {
    const e = P(S, await o3(h, S, q, l)), n2 = [], o5 = [];
    for (let l2 = 0; l2 < k2.length; l2++) {
      const r5 = k2[l2];
      if ("cut" !== r5)
        o5.push(r5);
      else {
        const r6 = e.shift(), i3 = t2[l2];
        r(i3) && "polygon" === i3.type && i3.rings && i3.rings.length > 1 && r6.rings.length >= i3.rings.length ? (n2.push(r6), o5.push("simplify")) : o5.push(w2 ? R2(r6) : r6);
      }
    }
    if (!n2.length)
      return o5;
    const r4 = await o4(h, n2, l), i2 = [];
    for (let t3 = 0; t3 < o5.length; t3++) {
      const e2 = o5[t3];
      "simplify" !== e2 ? i2.push(e2) : i2.push(w2 ? R2(r4.shift()) : r4.shift());
    }
    return i2;
  }
  const D = [];
  for (let e = 0; e < k2.length; e++) {
    const t3 = k2[e];
    if ("cut" !== t3)
      D.push(t3);
    else {
      const e2 = S.shift();
      D.push(true === w2 ? R2(e2) : e2);
    }
  }
  return D;
}
function U2(e, t2) {
  const n = R(t2);
  if (n) {
    const [t3, o5] = n.valid, s5 = o5 - t3;
    if (e < t3)
      for (; e < t3; )
        e += s5;
    if (e > o5)
      for (; e > o5; )
        e -= s5;
  }
  return e;
}

export {
  r3 as r,
  i,
  s4 as s,
  v3 as v,
  U2 as U
};
//# sourceMappingURL=chunk-NCXAKZRR.js.map
