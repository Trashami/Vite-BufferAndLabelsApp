import {
  c
} from "./chunk-7QNA4ADD.js";
import {
  e
} from "./chunk-C6PUUIY2.js";
import {
  n as n2
} from "./chunk-ZLTZ3KAT.js";
import {
  n
} from "./chunk-NDQ5FHGV.js";
import {
  r
} from "./chunk-GDVNKPJ7.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/ScreenSizePerspective.glsl.js
function c2(e2) {
  e2.vertex.code.add(n2`float screenSizePerspectiveMinSize(float size, vec4 factor) {
float nonZeroSize = 1.0 - step(size, 0.0);
return (
factor.z * (
1.0 +
nonZeroSize *
2.0 * factor.w / (
size + (1.0 - nonZeroSize)
)
)
);
}`), e2.vertex.code.add(n2`float screenSizePerspectiveViewAngleDependentFactor(float absCosAngle) {
return absCosAngle * absCosAngle * absCosAngle;
}`), e2.vertex.code.add(n2`vec4 screenSizePerspectiveScaleFactor(float absCosAngle, float distanceToCamera, vec4 params) {
return vec4(
min(params.x / (distanceToCamera - params.y), 1.0),
screenSizePerspectiveViewAngleDependentFactor(absCosAngle),
params.z,
params.w
);
}`), e2.vertex.code.add(n2`float applyScreenSizePerspectiveScaleFactorFloat(float size, vec4 factor) {
return max(mix(size * factor.x, size, factor.y), screenSizePerspectiveMinSize(size, factor));
}`), e2.vertex.code.add(n2`float screenSizePerspectiveScaleFloat(float size, float absCosAngle, float distanceToCamera, vec4 params) {
return applyScreenSizePerspectiveScaleFactorFloat(
size,
screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params)
);
}`), e2.vertex.code.add(n2`vec2 applyScreenSizePerspectiveScaleFactorVec2(vec2 size, vec4 factor) {
return mix(size * clamp(factor.x, screenSizePerspectiveMinSize(size.y, factor) / max(1e-5, size.y), 1.0), size, factor.y);
}`), e2.vertex.code.add(n2`vec2 screenSizePerspectiveScaleVec2(vec2 size, float absCosAngle, float distanceToCamera, vec4 params) {
return applyScreenSizePerspectiveScaleFactorVec2(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));
}`);
}
function t(e2) {
  e2.uniforms.add(new e("screenSizePerspective", (e3) => o(e3.screenSizePerspective)));
}
function i(e2) {
  e2.uniforms.add(new e("screenSizePerspectiveAlignment", (e3) => o(e3.screenSizePerspectiveAlignment || e3.screenSizePerspective)));
}
function o(a2) {
  return r(n3, a2.parameters.divisor, a2.parameters.offset, a2.parameters.minPixelSize, a2.paddingPixelsOverride);
}
var n3 = n();

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VerticalOffset.glsl.js
function a(e2, r2) {
  const c3 = e2.vertex;
  r2.hasVerticalOffset ? (f(c3), r2.hasScreenSizePerspective && (e2.include(c2), i(c3), c(e2.vertex, r2)), c3.code.add(n2`
      vec3 calculateVerticalOffset(vec3 worldPos, vec3 localOrigin) {
        float viewDistance = length((view * vec4(worldPos, 1.0)).xyz);
        ${r2.spherical ? n2`vec3 worldNormal = normalize(worldPos + localOrigin);` : n2`vec3 worldNormal = vec3(0.0, 0.0, 1.0);`}
        ${r2.hasScreenSizePerspective ? n2`
            float cosAngle = dot(worldNormal, normalize(worldPos - cameraPosition));
            float verticalOffsetScreenHeight = screenSizePerspectiveScaleFloat(verticalOffset.x, abs(cosAngle), viewDistance, screenSizePerspectiveAlignment);` : n2`
            float verticalOffsetScreenHeight = verticalOffset.x;`}
        // Screen sized offset in world space, used for example for line callouts
        float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * viewDistance, verticalOffset.z, verticalOffset.w);
        return worldNormal * worldOffset;
      }

      vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) {
        return worldPos + calculateVerticalOffset(worldPos, localOrigin);
      }
    `)) : c3.code.add(n2`vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) { return worldPos; }`);
}
var i2 = n();
function f(r2) {
  r2.uniforms.add(new e("verticalOffset", (r3, t2) => {
    const { minWorldLength: l, maxWorldLength: o2, screenLength: c3 } = r3.verticalOffset, s = Math.tan(0.5 * t2.camera.fovY) / (0.5 * t2.camera.fullViewport[3]), a2 = t2.camera.pixelRatio || 1;
    return r(i2, c3 * a2, s, l, o2);
  }));
}

export {
  c2 as c,
  t,
  i,
  a,
  f
};
//# sourceMappingURL=chunk-PNLWREZJ.js.map
