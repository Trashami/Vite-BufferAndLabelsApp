import {
  i as i5
} from "./chunk-J42Y5N2P.js";
import {
  o as o6
} from "./chunk-DWAZ7HI7.js";
import {
  a as a3
} from "./chunk-POI555WS.js";
import {
  C as C2
} from "./chunk-UCPKJYXN.js";
import {
  t as t6
} from "./chunk-KFLNKWNF.js";
import {
  e as e5,
  t as t5
} from "./chunk-27YO3FKC.js";
import {
  w as w3
} from "./chunk-UO3LS2M5.js";
import {
  n as n3
} from "./chunk-YQBYWPBD.js";
import {
  A as A2,
  B,
  C,
  K,
  O,
  P as P2,
  R,
  U,
  X,
  Y,
  Z,
  a,
  e as e4,
  i as i3,
  ie,
  k as k2,
  l as l4,
  m as m3,
  n as n2,
  ne,
  o as o3,
  oe,
  u as u6,
  w as w2,
  y as y3
} from "./chunk-QISOH77W.js";
import {
  dt,
  f as f2,
  j
} from "./chunk-XO5VJRK4.js";
import {
  n,
  t as t4
} from "./chunk-UDYHZLTE.js";
import {
  a as a2,
  n as n4
} from "./chunk-JEA4MMTV.js";
import {
  e as e6,
  h as h2,
  i as i4,
  o as o5
} from "./chunk-RG3AHHRL.js";
import {
  A,
  F,
  I,
  L,
  P,
  S,
  b,
  c as c3,
  d,
  g as g2,
  h,
  i as i2,
  k,
  l as l3,
  m as m2,
  p,
  s as s5,
  t as t3,
  u as u5,
  w,
  x
} from "./chunk-SQSR6K2M.js";
import {
  r as r3,
  z
} from "./chunk-75RMBUYZ.js";
import {
  o as o4,
  p as p2
} from "./chunk-DER356EU.js";
import {
  e as e3,
  u as u3
} from "./chunk-NRP45AHD.js";
import {
  m,
  o as o2,
  u as u4
} from "./chunk-6M2AHKYV.js";
import {
  l
} from "./chunk-RAX2HD42.js";
import {
  f,
  l as l2,
  s as s4,
  u as u2,
  y as y2
} from "./chunk-EHPBHJYZ.js";
import {
  M,
  c2,
  g2 as g,
  i,
  o,
  r2,
  s as s2,
  s2 as s3,
  u3 as u
} from "./chunk-3MNMDUQZ.js";
import {
  G
} from "./chunk-UWG37XSU.js";
import {
  e as e2
} from "./chunk-U2XHEJM7.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";
import {
  c,
  has,
  y
} from "./chunk-HVKDYDPP.js";
import {
  t as t2
} from "./chunk-6QC7MLLS.js";
import {
  e,
  r,
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/core/BidiText.js
var i6 = new C2();
function n5(r19) {
  if (!i6.hasBidiChar(r19))
    return [r19, false];
  let n17;
  return n17 = "rtl" === i6.checkContextual(r19) ? "IDNNN" : "ICNNN", [i6.bidiTransform(r19, n17, "VLYSN"), true];
}

// node_modules/@arcgis/core/symbols/cim/TextRasterizer.js
function e7(t12) {
  return `rgb(${t12.slice(0, 3).toString()})`;
}
function i7(t12) {
  return `rgba(${t12.slice(0, 3).toString()},${t12[3]})`;
}
var s6 = class {
  constructor(t12) {
    t12 && (this._textRasterizationCanvas = t12);
  }
  rasterizeText(t12, s12) {
    var _a;
    this._textRasterizationCanvas || (this._textRasterizationCanvas = document.createElement("canvas"));
    const r19 = this._textRasterizationCanvas, o12 = r19.getContext("2d");
    this._setFontProperties(o12, s12), this._parameters = s12, this._textLines = t12.split(/\r?\n/), this._lineHeight = this._computeLineHeight();
    const h8 = this._computeTextWidth(o12, s12), { decoration: a15, weight: l12 } = s12.font;
    this._lineThroughWidthOffset = a15 && "line-through" === a15 ? 0.1 * this._lineHeight : 0;
    const d4 = this._lineHeight * this._textLines.length;
    r19.width = h8 + 2 * this._lineThroughWidthOffset, r19.height = d4, this._renderedLineHeight = Math.round(this._lineHeight * s12.pixelRatio), this._renderedHaloSize = s12.halo.size * s12.pixelRatio, this._renderedWidth = h8 * s12.pixelRatio, this._renderedHeight = d4 * s12.pixelRatio, this._lineThroughWidthOffset *= s12.pixelRatio;
    const c11 = (_a = s12.color) != null ? _a : [0, 0, 0, 0], _4 = s12.halo && s12.halo.color ? s12.halo.color : [0, 0, 0, 0];
    this._fillStyle = i7(c11), this._haloStyle = e7(_4);
    const g8 = this._renderedLineHeight, f9 = this._renderedHaloSize;
    o12.save(), o12.clearRect(0, 0, r19.width, r19.height), this._setFontProperties(o12, s12);
    const u14 = n6(o12.textAlign, this._renderedWidth) + f9, p6 = f9, x5 = f9 > 0;
    let m8 = this._lineThroughWidthOffset, b5 = 0;
    x5 && this._renderHalo(o12, u14, p6, m8, b5, s12), b5 += p6, m8 += u14;
    for (const e15 of this._textLines)
      x5 ? (o12.globalCompositeOperation = "destination-out", o12.fillStyle = "rgb(0, 0, 0)", o12.fillText(e15, m8, b5), o12.globalCompositeOperation = "source-over", o12.fillStyle = this._fillStyle, o12.fillText(e15, m8, b5)) : (o12.fillStyle = this._fillStyle, o12.fillText(e15, m8, b5)), a15 && "none" !== a15 && this._renderDecoration(o12, m8, b5, a15, l12), b5 += g8;
    o12.restore();
    const z3 = this._renderedWidth + 2 * this._lineThroughWidthOffset, w6 = this._renderedHeight, v2 = o12.getImageData(0, 0, z3, w6), H2 = new Uint8Array(v2.data);
    if (s12.premultiplyColors) {
      let t13;
      for (let e15 = 0; e15 < H2.length; e15 += 4)
        t13 = H2[e15 + 3] / 255, H2[e15] = H2[e15] * t13, H2[e15 + 1] = H2[e15 + 1] * t13, H2[e15 + 2] = H2[e15 + 2] * t13;
    }
    let y7, R3;
    switch (s12.horizontalAlignment) {
      case "left":
        y7 = -0.5;
        break;
      case "right":
        y7 = 0.5;
        break;
      default:
        y7 = 0;
    }
    switch (s12.verticalAlignment) {
      case "bottom":
        R3 = -0.5;
        break;
      case "top":
        R3 = 0.5;
        break;
      default:
        R3 = 0;
    }
    return { size: [z3, w6], image: new Uint32Array(H2.buffer), sdf: false, simplePattern: false, anchorX: y7, anchorY: R3, canvas: r19 };
  }
  _renderHalo(t12, e15, i11, s12, n17, r19) {
    const o12 = this._renderedWidth, h8 = this._renderedHeight;
    this._haloRasterizationCanvas || (this._haloRasterizationCanvas = document.createElement("canvas")), this._haloRasterizationCanvas.width = o12, this._haloRasterizationCanvas.height = h8;
    const a15 = this._haloRasterizationCanvas, l12 = a15.getContext("2d");
    l12.clearRect(0, 0, o12, h8), this._setFontProperties(l12, r19);
    const { decoration: d4, weight: c11 } = r19.font;
    l12.fillStyle = this._haloStyle, l12.strokeStyle = this._haloStyle, l12.lineJoin = "round", this._renderHaloNative(l12, e15, i11, d4, c11), t12.globalAlpha = this._parameters.halo.color[3], t12.drawImage(a15, 0, 0, o12, h8, s12, n17, o12, h8), t12.globalAlpha = 1;
  }
  _renderHaloNative(t12, e15, i11, s12, n17) {
    const r19 = this._renderedLineHeight, o12 = this._renderedHaloSize;
    for (const h8 of this._textLines) {
      const a15 = 2 * o12, l12 = 5, d4 = 0.1;
      for (let r20 = 0; r20 < l12; r20++) {
        const o13 = (1 - (l12 - 1) * d4 + r20 * d4) * a15;
        t12.lineWidth = o13, t12.strokeText(h8, e15, i11), s12 && "none" !== s12 && this._renderDecoration(t12, e15, i11, s12, n17, o13);
      }
      i11 += r19;
    }
  }
  _setFontProperties(e15, i11) {
    const s12 = Math.max(i11.size, 0.5), n17 = i11.font, r19 = `${n17.style} ${n17.weight} ${u3(s12 * i11.pixelRatio).toFixed(1)}px ${n17.family}, sans-serif`;
    let o12;
    switch (e15.font = r19, e15.textBaseline = "top", i11.horizontalAlignment) {
      case "left":
      default:
        o12 = "left";
        break;
      case "right":
        o12 = "right";
        break;
      case "center":
        o12 = "center";
    }
    e15.textAlign = o12;
  }
  computeTextSize(t12, e15) {
    this._textRasterizationCanvas || (this._textRasterizationCanvas = document.createElement("canvas"));
    const i11 = this._textRasterizationCanvas, s12 = i11.getContext("2d");
    this._setFontProperties(s12, e15), this._parameters = e15, this._textLines = t12.split(/\r?\n/), this._lineHeight = this._computeLineHeight();
    const n17 = this._computeTextWidth(s12, e15), r19 = this._lineHeight * this._textLines.length;
    return i11.width = n17, i11.height = r19, [n17 * e15.pixelRatio, r19 * e15.pixelRatio];
  }
  _computeTextWidth(t12, e15) {
    let i11 = 0;
    for (const n17 of this._textLines)
      i11 = Math.max(i11, t12.measureText(n17).width);
    const s12 = e15.font;
    return ("italic" === s12.style || "oblique" === s12.style || "string" == typeof s12.weight && ("bold" === s12.weight || "bolder" === s12.weight) || "number" == typeof s12.weight && s12.weight > 600) && (i11 += 0.3 * t12.measureText("w").width), i11 += 2 * this._parameters.halo.size, Math.round(i11);
  }
  _computeLineHeight() {
    let t12 = 1.275 * this._parameters.size;
    const e15 = this._parameters.font.decoration;
    return e15 && "underline" === e15 && (t12 *= 1.3), Math.round(t12 + 2 * this._parameters.halo.size);
  }
  _renderDecoration(t12, e15, i11, s12, n17, r19) {
    const o12 = 0.9 * this._lineHeight, h8 = "bold" === n17 ? 0.06 : "bolder" === n17 ? 0.09 : 0.04;
    switch (t12.textAlign) {
      case "center":
        e15 -= this._renderedWidth / 2;
        break;
      case "right":
        e15 -= this._renderedWidth;
    }
    const a15 = t12.textBaseline;
    if ("underline" === s12)
      switch (a15) {
        case "top":
          i11 += o12;
          break;
        case "middle":
          i11 += o12 / 2;
      }
    else if ("line-through" === s12)
      switch (a15) {
        case "top":
          i11 += o12 / 1.5;
          break;
        case "middle":
          i11 += o12 / 3;
      }
    const l12 = r19 ? 1.5 * r19 : Math.ceil(o12 * h8);
    t12.save(), t12.beginPath(), t12.strokeStyle = t12.fillStyle, t12.lineWidth = l12, t12.moveTo(e15 - this._lineThroughWidthOffset, i11), t12.lineTo(e15 + this._renderedWidth + 2 * this._lineThroughWidthOffset, i11), t12.stroke(), t12.restore();
  }
};
function n6(t12, e15) {
  return "center" === t12 ? 0.5 * e15 : "right" === t12 ? e15 : 0;
}

// node_modules/@arcgis/core/symbols/cim/CIMEffects.js
var r4 = class {
  constructor(t12) {
    this._geometry = t12;
  }
  next() {
    const t12 = this._geometry;
    return this._geometry = null, t12;
  }
};

// node_modules/@arcgis/core/symbols/cim/CIMImageColorSubstitutionHelper.js
var a4 = class {
  applyColorSubstituition(t12, a15) {
    if (!a15)
      return t12;
    this._rasterizationCanvas || (this._rasterizationCanvas = document.createElement("canvas"));
    const { width: e15, height: n17 } = t12, o12 = this._rasterizationCanvas, r19 = o12.getContext("2d");
    t12 !== o12 && (o12.width = e15, o12.height = n17, r19.drawImage(t12, 0, 0, e15, n17));
    const i11 = r19.getImageData(0, 0, e15, n17).data;
    if (a15) {
      for (const l12 of a15)
        if (l12 && l12.oldColor && 4 === l12.oldColor.length && l12.newColor && 4 === l12.newColor.length) {
          const [t13, a16, e16, n18] = l12.oldColor, [o13, r20, s13, g8] = l12.newColor;
          if (t13 === o13 && a16 === r20 && e16 === s13 && n18 === g8)
            continue;
          for (let l13 = 0; l13 < i11.length; l13 += 4)
            t13 === i11[l13] && a16 === i11[l13 + 1] && e16 === i11[l13 + 2] && n18 === i11[l13 + 3] && (i11[l13] = o13, i11[l13 + 1] = r20, i11[l13 + 2] = s13, i11[l13 + 3] = g8);
        }
    }
    const s12 = new ImageData(i11, e15, n17);
    return r19.putImageData(s12, 0, 0), o12;
  }
  tintImageData(a15, e15) {
    if (!e15)
      return a15;
    this._rasterizationCanvas || (this._rasterizationCanvas = document.createElement("canvas"));
    const { width: n17, height: o12 } = a15, r19 = this._rasterizationCanvas, i11 = r19.getContext("2d");
    a15 !== r19 && (r19.width = n17, r19.height = o12, i11.drawImage(a15, 0, 0, n17, o12));
    const s12 = i11.getImageData(0, 0, n17, o12), l12 = new Uint8Array(s12.data), g8 = new l(e15), h8 = [g8.r / 255, g8.g / 255, g8.b / 255, g8.a];
    for (let t12 = 0; t12 < l12.length; t12 += 4)
      l12[t12 + 0] *= h8[0], l12[t12 + 1] *= h8[1], l12[t12 + 2] *= h8[2], l12[t12 + 3] *= h8[3];
    const d4 = new ImageData(new Uint8ClampedArray(l12.buffer), n17, o12);
    return i11.putImageData(d4, 0, 0), r19;
  }
};

// node_modules/@arcgis/core/symbols/cim/CIMPlacements.js
var t7 = class {
  constructor() {
    this.setIdentity();
  }
  getAngle() {
    return (null == this.rz || 0 === this.rz && 1 !== this.rzCos && 0 !== this.rzSin) && (this.rz = Math.atan2(this.rzSin, this.rzCos)), this.rz;
  }
  setIdentity() {
    this.tx = 0, this.ty = 0, this.tz = 0, this.s = 1, this.rx = 0, this.ry = 0, this.rz = 0, this.rzCos = 1, this.rzSin = 0;
  }
  setTranslate(t12, s12) {
    this.tx = t12, this.ty = s12;
  }
  setTranslateZ(t12) {
    this.tz = t12;
  }
  setRotateCS(t12, s12) {
    this.rz = void 0, this.rzCos = t12, this.rzSin = s12;
  }
  setRotate(t12) {
    this.rz = t12, this.rzCos = void 0, this.rzSin = void 0;
  }
  setRotateY(t12) {
    this.ry = t12;
  }
  setScale(t12) {
    this.s = t12;
  }
  setMeasure(t12) {
    this.m = t12;
  }
};

// node_modules/@arcgis/core/symbols/cim/CIMCursor.js
function a5(i11) {
  const n17 = y(i11);
  return P3(n17), n17;
}
function l5(t12) {
  t12 && (s4(t12) ? t12.y = -t12.y : y2(t12) ? u7(t12.rings) : f(t12) ? u7(t12.paths) : l2(t12) && r5(t12.points));
}
function r5(t12) {
  if (t12) {
    const i11 = t12.length;
    for (let n17 = 0; n17 < i11; n17++)
      t12[n17][1] = -t12[n17][1];
  }
}
function u7(t12) {
  if (t12)
    for (const i11 of t12)
      r5(i11);
}
function c4(t12) {
  if (t12) {
    for (let i11 = t12.length - 1; i11 > 0; --i11)
      t12[i11][0] -= t12[i11 - 1][0], t12[i11][1] -= t12[i11 - 1][1];
  }
}
function f3(t12) {
  if (t12)
    for (const i11 of t12)
      c4(i11);
}
function p3(t12) {
  if (t12) {
    const i11 = t12.length;
    for (let n17 = 1; n17 < i11; ++n17)
      t12[n17][0] += t12[n17 - 1][0], t12[n17][1] += t12[n17 - 1][1];
  }
}
function m4(t12) {
  if (t12)
    for (const i11 of t12)
      p3(i11);
}
function P3(t12) {
  t12 && (y2(t12) ? m4(t12.rings) : f(t12) ? m4(t12.paths) : l2(t12) && p3(t12.points), l5(t12));
}
function x2(t12) {
  t12 && (l5(t12), y2(t12) ? f3(t12.rings) : f(t12) ? f3(t12.paths) : l2(t12) && c4(t12.points));
}
function g3(t12) {
  if (t12)
    for (const i11 of t12)
      d2(i11);
}
function d2(t12) {
  t12 && t12.reverse();
}
function C3(t12, i11, n17) {
  return [t12[0] + (i11[0] - t12[0]) * n17, t12[1] + (i11[1] - t12[1]) * n17];
}
function y4(t12) {
  return !(!t12 || 0 === t12.length) && (t12[0][0] === t12[t12.length - 1][0] && t12[0][1] === t12[t12.length - 1][1]);
}
function I2(t12) {
  return t12[4];
}
function j2(t12, i11) {
  t12[4] = i11;
}
var G2 = class {
  constructor(t12, s12, e15, a15 = 0) {
    this.isClosed = false, this.multiPath = null, this.acceptPolygon = s12, this.acceptPolyline = e15, this.geomUnitsPerPoint = a15, this.pathCount = -1, this.pathIndex = -1, this.iteratePath = false, t12 && (y2(t12) ? s12 && (this.multiPath = t12.rings, this.isClosed = true) : f(t12) ? e15 && (this.multiPath = t12.paths, this.isClosed = false) : u2(t12) && s12 && (this.multiPath = b2(t12).rings, this.isClosed = true), this.multiPath && (this.pathCount = this.multiPath.length)), this.internalPlacement = new t7();
  }
  next() {
    if (!this.multiPath)
      return null;
    for (; this.iteratePath || this.pathIndex < this.pathCount - 1; ) {
      this.iteratePath || this.pathIndex++;
      const t12 = this.processPath(this.multiPath[this.pathIndex]);
      if (t12)
        return t12;
    }
    return this.pathCount = -1, this.pathIndex = -1, this.multiPath = null, null;
  }
};
var U2 = class {
  constructor(t12, i11, n17, s12 = 0) {
    this.isClosed = false, this.multiPath = null, this.inputGeometries = t12, this.acceptPolygon = i11, this.acceptPolyline = n17, this.geomUnitsPerPoint = s12, this.pathCount = -1, this.pathIndex = -1, this.iteratePath = false;
  }
  next() {
    for (; ; ) {
      if (!this.multiPath) {
        let t12 = this.inputGeometries.next();
        for (; t12; ) {
          if (y2(t12) ? this.acceptPolygon && (this.multiPath = t12.rings, this.isClosed = true) : f(t12) ? this.acceptPolyline && (this.multiPath = t12.paths, this.isClosed = false) : u2(t12) && this.acceptPolygon && (this.multiPath = b2(t12).rings, this.isClosed = true), this.multiPath) {
            this.pathCount = this.multiPath.length, this.pathIndex = -1;
            break;
          }
          t12 = this.inputGeometries.next();
        }
        if (!this.multiPath)
          return null;
      }
      for (; this.iteratePath || this.pathIndex < this.pathCount - 1; ) {
        this.iteratePath || this.pathIndex++;
        const t12 = this.processPath(this.multiPath[this.pathIndex]);
        if (t12)
          return t12;
      }
      this.pathCount = -1, this.pathIndex = -1, this.multiPath = null;
    }
  }
};
function b2(t12) {
  return { rings: [[[t12.xmin, t12.ymin], [t12.xmin, t12.ymax], [t12.xmax, t12.ymax], [t12.xmax, t12.ymin], [t12.xmin, t12.ymin]]] };
}

// node_modules/@arcgis/core/symbols/cim/effects/EffectAddControlPoints.js
var o7 = class {
  static local() {
    return null === o7.instance && (o7.instance = new o7()), o7.instance;
  }
  execute(s12, t12, e15, i11) {
    return new r6(s12, t12, e15);
  }
};
o7.instance = null;
var r6 = class {
  constructor(s12, t12, e15) {
    this._inputGeometries = s12, this._angleTolerance = void 0 !== t12.angleTolerance ? t12.angleTolerance : 120, this._maxCosAngle = Math.cos((1 - Math.abs(this._angleTolerance) / 180) * Math.PI);
  }
  next() {
    let n17 = this._inputGeometries.next();
    for (; n17; ) {
      if (y2(n17)) {
        this._isClosed = true;
        const t12 = y(n17);
        return this._processMultipath(t12.rings), t12;
      }
      if (f(n17)) {
        this._isClosed = false;
        const t12 = y(n17);
        return this._processMultipath(t12.paths), t12;
      }
      if (u2(n17)) {
        if (this._maxCosAngle)
          return n17;
        this._isClosed = true;
        const s12 = [[n17.xmin, n17.ymin], [n17.xmin, n17.ymax], [n17.xmax, n17.ymax], [n17.xmax, n17.ymin], [n17.xmin, n17.ymin]];
        return this._processPath(s12), { rings: [s12] };
      }
      n17 = this._inputGeometries.next();
    }
    return null;
  }
  _processMultipath(s12) {
    if (s12)
      for (const t12 of s12)
        this._processPath(t12);
  }
  _processPath(s12) {
    if (s12) {
      let t12, e15, i11, o12, r19, l12, a15 = s12.length, h8 = s12[0];
      this._isClosed && ++a15;
      for (let c11 = 1; c11 < a15; ++c11) {
        let m8;
        m8 = this._isClosed && c11 === a15 - 1 ? s12[0] : s12[c11];
        const _4 = m8[0] - h8[0], u14 = m8[1] - h8[1], p6 = Math.sqrt(_4 * _4 + u14 * u14);
        if (c11 > 1 && p6 > 0 && i11 > 0) {
          (t12 * _4 + e15 * u14) / p6 / i11 <= this._maxCosAngle && j2(h8, 1);
        }
        1 === c11 && (o12 = _4, r19 = u14, l12 = p6), p6 > 0 && (h8 = m8, t12 = _4, e15 = u14, i11 = p6);
      }
      if (this._isClosed && i11 > 0 && l12 > 0) {
        (t12 * o12 + e15 * r19) / l12 / i11 <= this._maxCosAngle && j2(s12[0], 1);
      }
    }
  }
};

// node_modules/@arcgis/core/symbols/cim/CurveHelper.js
var e8 = 0.03;
var s7 = class {
  constructor() {
    this._path = [];
  }
  path() {
    return this._path;
  }
  addPath(t12, e15) {
    e15 || t12.reverse(), Array.prototype.push.apply(this._path, t12), e15 || t12.reverse();
  }
  static mergePath(t12, e15) {
    e15 && Array.prototype.push.apply(t12, e15);
  }
  startPath(t12) {
    this._path.push(t12);
  }
  lineTo(t12) {
    this._path.push(t12);
  }
  close() {
    const t12 = this._path;
    t12.length > 1 && (t12[0][0] === t12[t12.length - 1][0] && t12[0][1] === t12[t12.length - 1][1] || t12.push([t12[0][0], t12[0][1]]));
  }
};
var n7 = class {
  constructor(t12 = 0, e15 = false) {
  }
  normalize(t12) {
    const e15 = Math.sqrt(t12[0] * t12[0] + t12[1] * t12[1]);
    0 !== e15 && (t12[0] /= e15, t12[1] /= e15);
  }
  calculateLength(t12, e15) {
    const s12 = e15[0] - t12[0], n17 = e15[1] - t12[1];
    return Math.sqrt(s12 * s12 + n17 * n17);
  }
  calculateSegLength(t12, e15) {
    return this.calculateLength(t12[e15], t12[e15 + 1]);
  }
  calculatePathLength(t12) {
    let e15 = 0;
    const s12 = t12 ? t12.length : 0;
    for (let n17 = 0; n17 < s12 - 1; ++n17)
      e15 += this.calculateSegLength(t12, n17);
    return e15;
  }
  calculatePathArea(t12) {
    let e15 = 0;
    const s12 = t12 ? t12.length : 0;
    for (let n17 = 0; n17 < s12 - 1; ++n17)
      e15 += (t12[n17 + 1][0] - t12[n17][0]) * (t12[n17 + 1][1] + t12[n17][1]);
    return e15 / 2;
  }
  getCoord2D(t12, e15, s12) {
    return [t12[0] + (e15[0] - t12[0]) * s12, t12[1] + (e15[1] - t12[1]) * s12];
  }
  getSegCoord2D(t12, e15, s12) {
    return this.getCoord2D(t12[e15], t12[e15 + 1], s12);
  }
  getAngle(t12, e15, s12) {
    const n17 = e15[0] - t12[0], r19 = e15[1] - t12[1];
    return Math.atan2(r19, n17);
  }
  getSegAngle(t12, e15, s12) {
    return this.getAngle(t12[e15], t12[e15 + 1], s12);
  }
  getAngleCS(t12, e15, s12) {
    const n17 = e15[0] - t12[0], r19 = e15[1] - t12[1], h8 = Math.sqrt(n17 * n17 + r19 * r19);
    return h8 > 0 ? [n17 / h8, r19 / h8] : [1, 0];
  }
  getSegAngleCS(t12, e15, s12) {
    return this.getAngleCS(t12[e15], t12[e15 + 1], s12);
  }
  cut(t12, e15, s12, n17) {
    return [s12 <= 0 ? t12[e15] : this.getSegCoord2D(t12, e15, s12), n17 >= 1 ? t12[e15 + 1] : this.getSegCoord2D(t12, e15, n17)];
  }
  addSegment(t12, e15, s12) {
    s12 && t12.push(e15[0]), t12.push(e15[1]);
  }
  getSubCurve(t12, e15, s12) {
    const n17 = [];
    return this.appendSubCurve(n17, t12, e15, s12) ? n17 : null;
  }
  appendSubCurve(t12, e15, s12, n17) {
    const r19 = e15 ? e15.length - 1 : 0;
    let h8 = 0, l12 = true, o12 = 0;
    for (; o12 < r19; ) {
      const r20 = this.calculateSegLength(e15, o12);
      if (0 !== r20) {
        if (l12) {
          if (h8 + r20 > s12) {
            const a15 = (s12 - h8) / r20;
            let u14 = 1, c11 = false;
            h8 + r20 >= n17 && (u14 = (n17 - h8) / r20, c11 = true);
            const i11 = this.cut(e15, o12, a15, u14);
            if (i11 && this.addSegment(t12, i11, l12), c11)
              break;
            l12 = false;
          }
        } else {
          if (h8 + r20 > n17) {
            const s13 = this.cut(e15, o12, 0, (n17 - h8) / r20);
            s13 && this.addSegment(t12, s13, l12);
            break;
          }
          this.addSegment(t12, [e15[o12], e15[o12 + 1]], l12);
        }
        h8 += r20, ++o12;
      } else
        ++o12;
    }
    return true;
  }
  getCIMPointAlong(t12, e15) {
    const s12 = t12 ? t12.length - 1 : 0;
    let n17 = 0, r19 = -1;
    for (; r19 < s12; ) {
      ++r19;
      const s13 = this.calculateSegLength(t12, r19);
      if (0 !== s13) {
        if (n17 + s13 > e15) {
          const h8 = (e15 - n17) / s13;
          return this.getCoord2D(t12[r19], t12[r19 + 1], h8);
        }
        n17 += s13;
      }
    }
    return null;
  }
  isEmpty(t12, e15) {
    if (!t12 || t12.length <= 1)
      return true;
    const s12 = t12 ? t12.length - 1 : 0;
    let n17 = -1;
    for (; n17 < s12; ) {
      if (++n17, t12[n17 + 1][0] !== t12[n17][0] || t12[n17 + 1][1] !== t12[n17][1])
        return false;
      if (e15 && t12[n17 + 1][2] !== t12[n17][2])
        return false;
    }
    return true;
  }
  offset(e15, s12, n17, r19, h8) {
    if (!e15 || e15.length < 2)
      return null;
    let l12 = 0, o12 = e15[l12++], a15 = l12;
    for (; l12 < e15.length; ) {
      const t12 = e15[l12];
      t12[0] === o12[0] && t12[1] === o12[1] || (l12 !== a15 && (e15[a15] = e15[l12]), o12 = e15[a15++]), l12++;
    }
    const u14 = e15[0][0] === e15[a15 - 1][0] && e15[0][1] === e15[a15 - 1][1];
    if (u14 && --a15, a15 < (u14 ? 3 : 2))
      return null;
    const c11 = [];
    o12 = u14 ? e15[a15 - 1] : null;
    let i11 = e15[0];
    for (let g8 = 0; g8 < a15; g8++) {
      const h9 = g8 === a15 - 1 ? u14 ? e15[0] : null : e15[g8 + 1];
      if (o12)
        if (h9) {
          const e16 = [h9[0] - i11[0], h9[1] - i11[1]];
          this.normalize(e16);
          const l13 = [i11[0] - o12[0], i11[1] - o12[1]];
          this.normalize(l13);
          const a16 = l13[0] * e16[1] - l13[1] * e16[0], u15 = l13[0] * e16[0] + l13[1] * e16[1];
          if (0 === a16 && 1 === u15) {
            i11 = h9;
            continue;
          }
          if (a16 >= 0 == s12 <= 0) {
            if (u15 < 1) {
              const t12 = [e16[0] - l13[0], e16[1] - l13[1]];
              this.normalize(t12);
              const n18 = Math.sqrt((1 + u15) / 2);
              if (n18 > 1 / r19) {
                const e17 = -Math.abs(s12) / n18;
                c11.push([i11[0] - t12[0] * e17, i11[1] - t12[1] * e17]);
              }
            }
          } else
            switch (n17) {
              case O.Mitered: {
                const t12 = Math.sqrt((1 + u15) / 2);
                if (t12 > 0 && 1 / t12 < r19) {
                  const n18 = [e16[0] - l13[0], e16[1] - l13[1]];
                  this.normalize(n18);
                  const r20 = Math.abs(s12) / t12;
                  c11.push([i11[0] - n18[0] * r20, i11[1] - n18[1] * r20]);
                  break;
                }
              }
              case O.Bevelled:
                c11.push([i11[0] + l13[1] * s12, i11[1] - l13[0] * s12]), c11.push([i11[0] + e16[1] * s12, i11[1] - e16[0] * s12]);
                break;
              case O.Rounded:
                if (u15 < 1) {
                  c11.push([i11[0] + l13[1] * s12, i11[1] - l13[0] * s12]);
                  const t12 = Math.floor(2.5 * (1 - u15));
                  if (t12 > 0) {
                    const n18 = 1 / t12;
                    let r20 = n18;
                    for (let h10 = 1; h10 < t12; h10++, r20 += n18) {
                      const t13 = [l13[1] * (1 - r20) + e16[1] * r20, -l13[0] * (1 - r20) - e16[0] * r20];
                      this.normalize(t13), c11.push([i11[0] + t13[0] * s12, i11[1] + t13[1] * s12]);
                    }
                  }
                  c11.push([i11[0] + e16[1] * s12, i11[1] - e16[0] * s12]);
                }
                break;
              case O.Square:
              default:
                if (a16 < 0)
                  c11.push([i11[0] + (l13[1] + l13[0]) * s12, i11[1] + (l13[1] - l13[0]) * s12]), c11.push([i11[0] + (e16[1] - e16[0]) * s12, i11[1] - (e16[0] + e16[1]) * s12]);
                else {
                  const t12 = Math.sqrt((1 + Math.abs(u15)) / 2), n18 = [e16[0] - l13[0], e16[1] - l13[1]];
                  this.normalize(n18);
                  const r20 = s12 / t12;
                  c11.push([i11[0] - n18[0] * r20, i11[1] - n18[1] * r20]);
                }
            }
        } else {
          const t12 = [i11[0] - o12[0], i11[1] - o12[1]];
          this.normalize(t12), c11.push([i11[0] + t12[1] * s12, i11[1] - t12[0] * s12]);
        }
      else {
        const t12 = [h9[0] - i11[0], h9[1] - i11[1]];
        this.normalize(t12), c11.push([i11[0] + t12[1] * s12, i11[1] - t12[0] * s12]);
      }
      o12 = i11, i11 = h9;
    }
    return c11.length < (u14 ? 3 : 2) ? null : (u14 && c11.push([c11[0][0], c11[0][1]]), c11);
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectArrow.js
var l6 = 1.7320508075688772;
var c5 = 5;
var u8 = P2.OpenEnded;
var h3 = class {
  static local() {
    return null === h3.instance && (h3.instance = new h3()), h3.instance;
  }
  execute(t12, e15, r19, n17) {
    return new a6(t12, e15, r19);
  }
};
h3.instance = null;
var a6 = class extends U2 {
  constructor(t12, e15, o12) {
    super(t12, false, true), this._curveHelper = new n7(), this._width = (void 0 !== e15.width ? e15.width : c5) * o12, this._arrowType = void 0 !== e15.geometricEffectArrowType ? e15.geometricEffectArrowType : void 0 !== e15.arrowType ? e15.arrowType : u8, this._offsetFlattenError = e8 * o12;
  }
  processPath(t12) {
    switch (this._arrowType) {
      case P2.OpenEnded:
      default:
        return this._constructSimpleArrow(t12, true);
      case P2.Block:
        return this._constructSimpleArrow(t12, false);
      case P2.Crossed:
        return this._constructCrossedArrow(t12);
    }
  }
  _constructSimpleArrow(t12, e15) {
    const r19 = this._curveHelper.calculatePathLength(t12);
    let n17 = this._width;
    r19 < 2 * n17 && (n17 = r19 / 2);
    const s12 = this._curveHelper.getSubCurve(t12, 0, r19 - n17);
    if (!s12)
      return null;
    const i11 = n17 / 2;
    if (this._curveHelper.isEmpty(s12, false))
      return null;
    const l12 = this._constructOffset(s12, -i11);
    if (!l12)
      return null;
    const c11 = this._constructOffset(s12, i11);
    if (!c11)
      return null;
    const u14 = this._constructArrowBasePoint(l12, -i11 / 2);
    if (!u14)
      return null;
    const h8 = this._constructArrowBasePoint(c11, i11 / 2);
    if (!h8)
      return null;
    const a15 = t12[t12.length - 1];
    e15 || (this._makeControlPoint(c11, true), this._makeControlPoint(l12, true));
    const _4 = new s7();
    return _4.addPath(c11, true), _4.lineTo(h8), this._makeControlPoint(_4.path()), _4.lineTo(a15), this._makeControlPoint(_4.path()), _4.lineTo(u14), this._makeControlPoint(_4.path()), _4.addPath(l12, false), e15 ? { paths: [_4.path()] } : (_4.close(), { rings: [_4.path()] });
  }
  _constructCrossedArrow(t12) {
    const e15 = this._curveHelper.calculatePathLength(t12);
    let r19 = this._width;
    e15 < r19 * (1 + l6 + 1) && (r19 = e15 / (1 + l6 + 1));
    const n17 = this._curveHelper.getSubCurve(t12, 0, e15 - r19 * (1 + l6));
    if (!n17)
      return null;
    const s12 = r19 / 2;
    if (this._curveHelper.isEmpty(n17, false))
      return null;
    const i11 = this._constructOffset(n17, s12);
    if (!i11)
      return null;
    const c11 = this._constructOffset(n17, -s12);
    if (!c11)
      return null;
    const u14 = this._curveHelper.getSubCurve(t12, 0, e15 - r19);
    if (!u14)
      return null;
    if (this._curveHelper.isEmpty(u14, false))
      return null;
    const h8 = this._constructOffset(u14, s12);
    if (!h8)
      return null;
    const a15 = this._constructOffset(u14, -s12);
    if (!a15)
      return null;
    const _4 = h8[h8.length - 1], f9 = this._constructArrowBasePoint(h8, s12 / 2);
    if (!f9)
      return null;
    const p6 = a15[a15.length - 1], m8 = this._constructArrowBasePoint(a15, -s12 / 2);
    if (!m8)
      return null;
    const d4 = t12[t12.length - 1];
    this._makeControlPoint(i11, false), this._makeControlPoint(c11, false);
    const w6 = new s7();
    return w6.addPath(i11, true), this._makeControlPoint(w6.path()), w6.lineTo(p6), w6.lineTo(m8), this._makeControlPoint(w6.path()), w6.lineTo(d4), this._makeControlPoint(w6.path()), w6.lineTo(f9), this._makeControlPoint(w6.path()), w6.lineTo(_4), this._makeControlPoint(w6.path()), w6.addPath(c11, false), { paths: [w6.path()] };
  }
  _constructOffset(t12, e15) {
    return this._curveHelper.offset(t12, e15, O.Rounded, 4, this._offsetFlattenError);
  }
  _constructArrowBasePoint(t12, e15) {
    if (!t12 || t12.length < 2)
      return null;
    const r19 = t12[t12.length - 2], n17 = t12[t12.length - 1], o12 = [n17[0] - r19[0], n17[1] - r19[1]];
    return this._curveHelper.normalize(o12), [n17[0] + o12[1] * e15, n17[1] - o12[0] * e15];
  }
  _makeControlPoint(t12, r19 = false) {
    j2(r19 ? t12[0] : t12[t12.length - 1], 1);
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectBuffer.js
var f4 = class {
  static local() {
    return null === f4.instance && (f4.instance = new f4()), f4.instance;
  }
  execute(e15, t12, s12, i11) {
    return new h4(e15, t12, s12, i11);
  }
};
f4.instance = null;
var h4 = class {
  constructor(e15, t12, s12, i11) {
    this._inputGeometries = e15, this._curveHelper = new n7(), this._size = (void 0 !== t12.size ? t12.size : 1) * s12, this._offsetFlattenError = e8 * s12;
  }
  next() {
    let n17 = this._inputGeometries.next();
    for (; n17; ) {
      if (u2(n17))
        if (this._size > 0) {
          const e15 = [[n17.xmin, n17.ymin], [n17.xmin, n17.ymax], [n17.xmax, n17.ymax], [n17.xmax, n17.ymin], [n17.xmin, n17.ymin]], t12 = this._curveHelper.offset(e15, this._size, O.Rounded, 4, this._offsetFlattenError);
          if (t12)
            return { rings: [t12] };
        } else {
          if (!(this._size < 0))
            return n17;
          if (Math.min(n17.xmax - n17.xmin, n17.ymax - n17.ymin) + 2 * this._size > 0)
            return { xmin: n17.xmin - this._size, xmax: n17.xmax + this._size, ymin: n17.ymin - this._size, ymax: n17.ymax + this._size };
        }
      if (y2(n17)) {
        if (0 === this._size)
          return n17;
        const e15 = [];
        for (const t12 of n17.rings) {
          const s12 = this._curveHelper.offset(t12, this._size, O.Rounded, 4, this._offsetFlattenError);
          s12 && e15.push(s12);
        }
        if (e15.length)
          return { rings: e15 };
      }
      if (f(n17) && this._size > 0) {
        const e15 = [];
        for (const t12 of n17.paths)
          if (t12 && t12.length > 1) {
            const s12 = this._curveHelper.offset(t12, this._size, O.Rounded, 4, this._offsetFlattenError), i11 = this._curveHelper.offset(t12, -this._size, O.Rounded, 4, this._offsetFlattenError);
            if (s12 && i11) {
              for (let e16 = i11.length - 1; e16 >= 0; e16--)
                s12.push(i11[e16]);
              s12.push([s12[0][0], s12[0][1]]), e15.push(s12);
            }
          }
        if (e15.length)
          return { rings: e15 };
      }
      s4(n17) && this._size, n17 = this._inputGeometries.next();
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectControlMeasureLine.js
var _ = class {
  static local() {
    return null === _.instance && (_.instance = new _()), _.instance;
  }
  execute(s12, t12, i11, h8) {
    return new c6(s12, t12, i11);
  }
};
_.instance = null;
var c6 = class {
  constructor(s12, t12, i11) {
    var _a;
    this._defaultPointSize = 20, this._inputGeometries = s12, this._geomUnitsPerPoint = i11, this._rule = (_a = t12.rule) != null ? _a : R.FullGeometry, this._defaultSize = this._defaultPointSize * i11;
  }
  next() {
    let e15;
    for (; e15 = this._inputGeometries.next(); ) {
      let r19;
      if (s4(e15) ? r19 = this._processGeom([[[e15.x, e15.y]]]) : l2(e15) ? r19 = this._processGeom([e15.points]) : f(e15) ? r19 = this._processGeom(e15.paths) : y2(e15) && (r19 = this._processGeom(e15.rings)), r19 && r19.length)
        return { paths: r19 };
    }
    return null;
  }
  _clone(s12) {
    return [s12[0], s12[1]];
  }
  _mid(s12, t12) {
    return [(s12[0] + t12[0]) / 2, (s12[1] + t12[1]) / 2];
  }
  _mix(s12, t12, i11, h8) {
    return [s12[0] * t12 + i11[0] * h8, s12[1] * t12 + i11[1] * h8];
  }
  _add(s12, t12) {
    return [s12[0] + t12[0], s12[1] + t12[1]];
  }
  _add2(s12, t12, i11) {
    return [s12[0] + t12, s12[1] + i11];
  }
  _sub(s12, t12) {
    return [s12[0] - t12[0], s12[1] - t12[1]];
  }
  _dist(s12, t12) {
    return Math.sqrt((s12[0] - t12[0]) * (s12[0] - t12[0]) + (s12[1] - t12[1]) * (s12[1] - t12[1]));
  }
  _norm(s12) {
    return Math.sqrt(s12[0] * s12[0] + s12[1] * s12[1]);
  }
  _normalize(s12, t12 = 1) {
    const i11 = t12 / this._norm(s12);
    s12[0] *= i11, s12[1] *= i11;
  }
  _leftPerpendicular(s12) {
    const t12 = -s12[1], i11 = s12[0];
    s12[0] = t12, s12[1] = i11;
  }
  _leftPerp(s12) {
    return [-s12[1], s12[0]];
  }
  _rightPerpendicular(s12) {
    const t12 = s12[1], i11 = -s12[0];
    s12[0] = t12, s12[1] = i11;
  }
  _rightPerp(s12) {
    return [s12[1], -s12[0]];
  }
  _dotProduct(s12, t12) {
    return s12[0] * t12[0] + s12[1] * t12[1];
  }
  _crossProduct(s12, t12) {
    return s12[0] * t12[1] - s12[1] * t12[0];
  }
  _rotateDirect(s12, t12, i11) {
    const h8 = s12[0] * t12 - s12[1] * i11, e15 = s12[0] * i11 + s12[1] * t12;
    s12[0] = h8, s12[1] = e15;
  }
  _makeCtrlPt(s12) {
    const t12 = [s12[0], s12[1]];
    return j2(t12, 1), t12;
  }
  _addAngledTicks(s12, t12, i11, h8) {
    const e15 = this._sub(i11, t12);
    this._normalize(e15);
    const r19 = this._crossProduct(e15, this._sub(h8, t12));
    let _4;
    _4 = r19 > 0 ? this._rightPerp(e15) : this._leftPerp(e15);
    const c11 = Math.abs(r19) / 2, u14 = [];
    u14.push([t12[0] + (_4[0] - e15[0]) * c11, t12[1] + (_4[1] - e15[1]) * c11]), u14.push(t12), u14.push(i11), u14.push([i11[0] + (_4[0] + e15[0]) * c11, i11[1] + (_4[1] + e15[1]) * c11]), s12.push(u14);
  }
  _addBezier2(s12, t12, i11, h8, e15) {
    if (0 == e15--)
      return void s12.push(h8);
    const r19 = this._mid(t12, i11), _4 = this._mid(i11, h8), c11 = this._mid(r19, _4);
    this._addBezier2(s12, t12, r19, c11, e15), this._addBezier2(s12, c11, _4, h8, e15);
  }
  _addBezier3(s12, t12, i11, h8, e15, r19) {
    if (0 == r19--)
      return void s12.push(e15);
    const _4 = this._mid(t12, i11), c11 = this._mid(i11, h8), u14 = this._mid(h8, e15), o12 = this._mid(_4, c11), n17 = this._mid(c11, u14), a15 = this._mid(o12, n17);
    this._addBezier3(s12, t12, _4, o12, a15, r19), this._addBezier3(s12, a15, n17, u14, e15, r19);
  }
  _add90DegArc(s12, t12, i11, h8, e15) {
    const r19 = e15 != null ? e15 : this._crossProduct(this._sub(i11, t12), this._sub(h8, t12)) > 0, _4 = this._mid(t12, i11), c11 = this._sub(_4, t12);
    r19 ? this._leftPerpendicular(c11) : this._rightPerpendicular(c11), _4[0] += c11[0], _4[1] += c11[1], this._addBezier3(s12, t12, this._mix(t12, 0.33333, _4, 0.66667), this._mix(i11, 0.33333, _4, 0.66667), i11, 4);
  }
  _addArrow(s12, t12, i11) {
    const h8 = t12[0], e15 = t12[1], r19 = t12[t12.length - 1], _4 = this._sub(h8, e15);
    this._normalize(_4);
    const c11 = this._crossProduct(_4, this._sub(r19, e15)), u14 = 0.5 * c11, o12 = this._leftPerp(_4), n17 = [r19[0] - o12[0] * c11, r19[1] - o12[1] * c11], a15 = t12.length - 1, p6 = [];
    p6.push(i11 ? [-o12[0], -o12[1]] : o12);
    let l12 = [-_4[0], -_4[1]];
    for (let d4 = 1; d4 < a15 - 1; d4++) {
      const s13 = this._sub(t12[d4 + 1], t12[d4]);
      this._normalize(s13);
      const i12 = this._dotProduct(s13, l12), h9 = this._crossProduct(s13, l12), e16 = Math.sqrt((1 + i12) / 2), r20 = this._sub(s13, l12);
      this._normalize(r20), r20[0] /= e16, r20[1] /= e16, p6.push(h9 < 0 ? [-r20[0], -r20[1]] : r20), l12 = s13;
    }
    p6.push(this._rightPerp(l12));
    for (let d4 = p6.length - 1; d4 > 0; d4--)
      s12.push([t12[d4][0] + p6[d4][0] * u14, t12[d4][1] + p6[d4][1] * u14]);
    s12.push([n17[0] + p6[0][0] * u14, n17[1] + p6[0][1] * u14]), s12.push([n17[0] + p6[0][0] * c11, n17[1] + p6[0][1] * c11]), s12.push(h8), s12.push([n17[0] - p6[0][0] * c11, n17[1] - p6[0][1] * c11]), s12.push([n17[0] - p6[0][0] * u14, n17[1] - p6[0][1] * u14]);
    for (let d4 = 1; d4 < p6.length; d4++)
      s12.push([t12[d4][0] - p6[d4][0] * u14, t12[d4][1] - p6[d4][1] * u14]);
  }
  _cp2(s12, t12, i11) {
    return s12.length >= 2 ? s12[1] : this._add2(s12[0], t12 * this._defaultSize, i11 * this._defaultSize);
  }
  _cp3(s12, t12, i11, h8) {
    if (s12.length >= 3)
      return s12[2];
    const e15 = this._mix(s12[0], 1 - i11, t12, i11), r19 = this._sub(t12, s12[0]);
    return this._normalize(r19), this._rightPerpendicular(r19), [e15[0] + r19[0] * h8 * this._defaultSize, e15[1] + r19[1] * h8 * this._defaultSize];
  }
  _arrowPath(s12) {
    if (s12.length > 2)
      return s12;
    const t12 = s12[0], i11 = this._cp2(s12, -4, 0), h8 = this._sub(t12, i11);
    this._normalize(h8);
    const e15 = this._rightPerp(h8);
    return [t12, i11, [t12[0] + (e15[0] - h8[0]) * this._defaultSize, t12[1] + (e15[1] - h8[1]) * this._defaultSize]];
  }
  _arrowLastSeg(s12) {
    const t12 = s12[0], i11 = this._cp2(s12, -4, 0);
    let h8;
    if (s12.length >= 3)
      h8 = s12[s12.length - 1];
    else {
      const s13 = this._sub(t12, i11);
      this._normalize(s13);
      const e15 = this._rightPerp(s13);
      h8 = [t12[0] + (e15[0] - s13[0]) * this._defaultSize, t12[1] + (e15[1] - s13[1]) * this._defaultSize];
    }
    return [i11, h8];
  }
  _processGeom(s12) {
    if (!s12)
      return null;
    const t12 = [];
    for (const i11 of s12) {
      if (!i11 || 0 === i11.length)
        continue;
      const s13 = i11.length;
      let h8 = i11[0];
      switch (this._rule) {
        case R.PerpendicularFromFirstSegment: {
          const s14 = this._cp2(i11, 0, -1), e15 = this._cp3(i11, s14, 0.5, 4), r19 = [];
          r19.push(e15), r19.push(this._mid(h8, s14)), t12.push(r19);
          break;
        }
        case R.ReversedFirstSegment: {
          const s14 = this._cp2(i11, 0, -1);
          t12.push([s14, h8]);
          break;
        }
        case R.PerpendicularToSecondSegment: {
          const s14 = this._cp2(i11, -4, 1), e15 = this._cp3(i11, s14, 0.882353, -1.94), r19 = [];
          r19.push(this._mid(s14, e15)), r19.push(h8), t12.push(r19);
          break;
        }
        case R.SecondSegmentWithTicks: {
          const s14 = this._cp2(i11, -4, 1), e15 = this._cp3(i11, s14, 0.882353, -1.94), r19 = this._sub(e15, s14);
          let _4;
          _4 = this._crossProduct(r19, this._sub(h8, s14)) > 0 ? this._rightPerp(_4) : this._leftPerp(r19);
          const c11 = [];
          c11.push([s14[0] + (_4[0] - r19[0]) / 3, s14[1] + (_4[1] - r19[1]) / 3]), c11.push(s14), c11.push(e15), c11.push([e15[0] + (_4[0] + r19[0]) / 3, e15[1] + (_4[1] + r19[1]) / 3]), t12.push(c11);
          break;
        }
        case R.DoublePerpendicular: {
          const s14 = this._cp2(i11, 0, -1), e15 = this._cp3(i11, s14, 0.5, 3), r19 = this._mid(h8, s14), _4 = this._sub(r19, e15);
          this._normalize(_4);
          const c11 = this._crossProduct(_4, this._sub(h8, e15));
          this._leftPerpendicular(_4);
          const u14 = [];
          u14.push(h8), u14.push([e15[0] + _4[0] * c11, e15[1] + _4[1] * c11]), t12.push(u14);
          const o12 = [];
          o12.push([e15[0] - _4[0] * c11, e15[1] - _4[1] * c11]), o12.push(s14), t12.push(o12);
          break;
        }
        case R.OppositeToFirstSegment: {
          const s14 = this._cp2(i11, 0, -1), e15 = this._cp3(i11, s14, 0.5, 3), r19 = this._mid(h8, s14), _4 = this._sub(r19, e15);
          this._normalize(_4);
          const c11 = this._crossProduct(_4, this._sub(h8, e15));
          this._leftPerpendicular(_4);
          const u14 = [];
          u14.push([e15[0] + _4[0] * c11, e15[1] + _4[1] * c11]), u14.push([e15[0] - _4[0] * c11, e15[1] - _4[1] * c11]), t12.push(u14);
          break;
        }
        case R.TriplePerpendicular: {
          const s14 = this._cp2(i11, 0, -1), e15 = this._cp3(i11, s14, 0.5, 4), r19 = this._mid(h8, s14), _4 = this._sub(r19, e15);
          this._normalize(_4);
          const c11 = this._crossProduct(_4, this._sub(h8, e15));
          this._leftPerpendicular(_4);
          const u14 = [];
          u14.push([e15[0] + _4[0] * c11 * 0.8, e15[1] + _4[1] * c11 * 0.8]), u14.push([r19[0] + 0.8 * (h8[0] - r19[0]), r19[1] + 0.8 * (h8[1] - r19[1])]), t12.push(u14), t12.push([e15, r19]);
          const o12 = [];
          o12.push([e15[0] - _4[0] * c11 * 0.8, e15[1] - _4[1] * c11 * 0.8]), o12.push([r19[0] + 0.8 * (s14[0] - r19[0]), r19[1] + 0.8 * (s14[1] - r19[1])]), t12.push(o12);
          break;
        }
        case R.HalfCircleFirstSegment: {
          const s14 = this._cp2(i11, 0, -1), e15 = this._cp3(i11, s14, 0.5, 4), r19 = this._mid(h8, s14);
          let _4 = this._sub(s14, h8);
          const c11 = Math.cos(Math.PI / 18), u14 = Math.sin(Math.PI / 18), o12 = Math.sqrt((1 + c11) / 2), n17 = Math.sqrt((1 - c11) / 2), a15 = [];
          let p6;
          this._crossProduct(_4, this._sub(e15, h8)) > 0 ? (a15.push(h8), _4 = this._sub(h8, r19), p6 = s14) : (a15.push(s14), _4 = this._sub(s14, r19), p6 = h8), this._rotateDirect(_4, o12, n17), _4[0] /= o12, _4[1] /= o12;
          for (let t13 = 1; t13 <= 18; t13++)
            a15.push(this._add(r19, _4)), this._rotateDirect(_4, c11, u14);
          a15.push(p6), t12.push(a15);
          break;
        }
        case R.HalfCircleSecondSegment: {
          const s14 = this._cp2(i11, 0, -1), e15 = this._cp3(i11, s14, 1, -1);
          let r19 = this._sub(h8, s14);
          this._normalize(r19);
          const _4 = this._crossProduct(r19, this._sub(e15, s14)) / 2;
          this._leftPerpendicular(r19);
          const c11 = [s14[0] + r19[0] * _4, s14[1] + r19[1] * _4];
          r19 = this._sub(s14, c11);
          const u14 = Math.cos(Math.PI / 18);
          let o12 = Math.sin(Math.PI / 18);
          _4 > 0 && (o12 = -o12);
          const n17 = [s14];
          for (let t13 = 1; t13 <= 18; t13++)
            this._rotateDirect(r19, u14, o12), n17.push(this._add(c11, r19));
          t12.push(n17);
          break;
        }
        case R.HalfCircleExtended: {
          const e15 = this._cp2(i11, 0, -2), r19 = this._cp3(i11, e15, 1, -1);
          let _4;
          if (s13 >= 4)
            _4 = i11[3];
          else {
            const s14 = this._sub(h8, e15);
            _4 = this._add(r19, s14);
          }
          const c11 = this._dist(e15, r19) / 2 / 0.75, u14 = this._sub(e15, h8);
          this._normalize(u14, c11);
          const o12 = this._sub(r19, _4);
          this._normalize(o12, c11);
          const n17 = [_4, r19];
          t12.push(n17);
          const a15 = [this._clone(r19)];
          this._addBezier3(a15, r19, this._add(r19, o12), this._add(e15, u14), e15, 4), a15.push(h8), t12.push(a15);
          break;
        }
        case R.OpenCircle: {
          const s14 = this._cp2(i11, -2, 0), e15 = this._sub(s14, h8), r19 = Math.cos(Math.PI / 18), _4 = -Math.sin(Math.PI / 18), c11 = [s14];
          for (let t13 = 1; t13 <= 33; t13++)
            this._rotateDirect(e15, r19, _4), c11.push(this._add(h8, e15));
          t12.push(c11);
          break;
        }
        case R.CoverageEdgesWithTicks: {
          const e15 = this._cp2(i11, 0, -1);
          let r19, _4;
          if (s13 >= 3)
            r19 = i11[2];
          else {
            const s14 = this._sub(e15, h8), t13 = this._leftPerp(s14);
            r19 = [h8[0] + t13[0] - 0.25 * s14[0], h8[1] + t13[1] - 0.25 * s14[1]];
          }
          if (s13 >= 4)
            _4 = i11[3];
          else {
            const s14 = this._mid(h8, e15), t13 = this._sub(h8, e15);
            this._normalize(t13), this._leftPerpendicular(t13);
            const i12 = this._crossProduct(t13, this._sub(r19, s14));
            this._rightPerpendicular(t13), _4 = [r19[0] + t13[0] * i12 * 2, r19[1] + t13[1] * i12 * 2];
          }
          const c11 = this._sub(e15, h8);
          let u14, o12;
          u14 = this._crossProduct(c11, this._sub(r19, h8)) > 0 ? this._rightPerp(c11) : this._leftPerp(c11), o12 = [], o12.push(r19), o12.push(h8), o12.push([h8[0] + (u14[0] - c11[0]) / 3, h8[1] + (u14[1] - c11[1]) / 3]), t12.push(o12), u14 = this._crossProduct(c11, this._sub(_4, e15)) > 0 ? this._rightPerp(u14) : this._leftPerp(c11), o12 = [], o12.push([e15[0] + (u14[0] + c11[0]) / 3, e15[1] + (u14[1] + c11[1]) / 3]), o12.push(e15), o12.push(_4), t12.push(o12);
          break;
        }
        case R.GapExtentWithDoubleTicks: {
          const e15 = this._cp2(i11, 0, 2), r19 = this._cp3(i11, e15, 0, 1);
          let _4;
          if (s13 >= 4)
            _4 = i11[3];
          else {
            const s14 = this._sub(e15, h8);
            _4 = this._add(r19, s14);
          }
          this._addAngledTicks(t12, h8, e15, this._mid(r19, _4)), this._addAngledTicks(t12, r19, _4, this._mid(h8, e15));
          break;
        }
        case R.GapExtentMidline: {
          const e15 = this._cp2(i11, 2, 0), r19 = this._cp3(i11, e15, 0, 1);
          let _4;
          if (s13 >= 4)
            _4 = i11[3];
          else {
            const s14 = this._sub(e15, h8);
            _4 = this._add(r19, s14);
          }
          const c11 = [];
          c11.push(this._mid(h8, r19)), c11.push(this._mid(e15, _4)), t12.push(c11);
          break;
        }
        case R.Chevron: {
          const e15 = this._cp2(i11, -1, -1);
          let r19;
          if (s13 >= 3)
            r19 = i11[2];
          else {
            const s14 = this._sub(e15, h8);
            this._leftPerpendicular(s14), r19 = this._add(h8, s14);
          }
          t12.push([e15, this._makeCtrlPt(h8), r19]);
          break;
        }
        case R.PerpendicularWithArc: {
          const s14 = this._cp2(i11, 0, -2), e15 = this._cp3(i11, s14, 0.5, -1);
          let r19 = this._sub(s14, h8);
          const _4 = this._norm(r19);
          r19[0] /= _4, r19[1] /= _4;
          const c11 = this._crossProduct(r19, this._sub(e15, h8));
          let u14 = this._dotProduct(r19, this._sub(e15, h8));
          u14 < 0.05 * _4 ? u14 = 0.05 * _4 : u14 > 0.95 * _4 && (u14 = 0.95 * _4);
          const o12 = [h8[0] + r19[0] * u14, h8[1] + r19[1] * u14];
          this._leftPerpendicular(r19);
          let n17 = [];
          n17.push([o12[0] - r19[0] * c11, o12[1] - r19[1] * c11]), n17.push([o12[0] + r19[0] * c11, o12[1] + r19[1] * c11]), t12.push(n17);
          const a15 = [s14[0] + r19[0] * c11, s14[1] + r19[1] * c11];
          r19 = this._sub(s14, a15);
          const p6 = Math.cos(Math.PI / 18);
          let l12 = Math.sin(Math.PI / 18);
          c11 < 0 && (l12 = -l12), n17 = [h8, s14];
          for (let t13 = 1; t13 <= 9; t13++)
            this._rotateDirect(r19, p6, l12), n17.push(this._add(a15, r19));
          t12.push(n17);
          break;
        }
        case R.ClosedHalfCircle: {
          const s14 = this._cp2(i11, 2, 0), e15 = this._mid(h8, s14), r19 = this._sub(s14, e15), _4 = Math.cos(Math.PI / 18), c11 = Math.sin(Math.PI / 18), u14 = [h8, s14];
          for (let t13 = 1; t13 <= 18; t13++)
            this._rotateDirect(r19, _4, c11), u14.push(this._add(e15, r19));
          t12.push(u14);
          break;
        }
        case R.TripleParallelExtended: {
          const s14 = this._cp2(i11, 0, -2), r19 = this._cp3(i11, s14, 1, -2), _4 = this._mid(h8, s14), c11 = this._sub(r19, s14);
          this._normalize(c11);
          const u14 = Math.abs(this._crossProduct(c11, this._sub(_4, s14))) / 2, o12 = this._dist(s14, r19), n17 = [s14, h8];
          n17.push([h8[0] + c11[0] * o12 * 0.5, h8[1] + c11[1] * o12 * 0.5]), t12.push(n17);
          const a15 = [];
          a15.push([_4[0] - c11[0] * u14, _4[1] - c11[1] * u14]), a15.push([_4[0] + c11[0] * o12 * 0.375, _4[1] + c11[1] * o12 * 0.375]), j2(a15[a15.length - 1], 1), a15.push([_4[0] + c11[0] * o12 * 0.75, _4[1] + c11[1] * o12 * 0.75]), t12.push(a15);
          const p6 = [s14, r19];
          t12.push(p6);
          break;
        }
        case R.ParallelWithTicks: {
          const s14 = this._cp2(i11, 3, 0), e15 = this._cp3(i11, s14, 0.5, -1), r19 = this._sub(e15, s14);
          this._normalize(r19);
          const _4 = this._crossProduct(r19, this._sub(e15, h8));
          this._leftPerpendicular(r19), this._addAngledTicks(t12, h8, s14, e15), this._addAngledTicks(t12, this._mix(h8, 1, r19, _4), this._mix(s14, 1, r19, _4), this._mid(h8, s14));
          break;
        }
        case R.Parallel: {
          const s14 = this._cp2(i11, 3, 0), e15 = this._cp3(i11, s14, 0.5, -1), r19 = this._sub(s14, h8);
          this._normalize(r19);
          const _4 = this._leftPerp(r19), c11 = this._crossProduct(r19, this._sub(e15, h8));
          let u14 = [h8, s14];
          t12.push(u14), u14 = [], u14.push([h8[0] + _4[0] * c11, h8[1] + _4[1] * c11]), u14.push([s14[0] + _4[0] * c11, s14[1] + _4[1] * c11]), t12.push(u14);
          break;
        }
        case R.PerpendicularToFirstSegment: {
          const s14 = this._cp2(i11, 3, 0), e15 = this._cp3(i11, s14, 0.5, -1), r19 = this._mid(h8, s14), _4 = this._sub(s14, h8);
          this._normalize(_4);
          const c11 = this._crossProduct(_4, this._sub(e15, h8));
          this._leftPerpendicular(_4);
          const u14 = [];
          u14.push([r19[0] - _4[0] * c11 * 0.25, r19[1] - _4[1] * c11 * 0.25]), u14.push([r19[0] + _4[0] * c11 * 1.25, r19[1] + _4[1] * c11 * 1.25]), t12.push(u14);
          break;
        }
        case R.ParallelOffset: {
          const s14 = this._cp2(i11, 3, 0), e15 = this._cp3(i11, s14, 0.5, -1), r19 = this._sub(s14, h8);
          this._normalize(r19);
          const _4 = this._crossProduct(r19, this._sub(e15, h8));
          this._leftPerpendicular(r19);
          const c11 = [];
          c11.push([h8[0] - r19[0] * _4, h8[1] - r19[1] * _4]), c11.push([s14[0] - r19[0] * _4, s14[1] - r19[1] * _4]), t12.push(c11);
          const u14 = [];
          u14.push([h8[0] + r19[0] * _4, h8[1] + r19[1] * _4]), u14.push([s14[0] + r19[0] * _4, s14[1] + r19[1] * _4]), t12.push(u14);
          break;
        }
        case R.OffsetOpposite: {
          const s14 = this._cp2(i11, 3, 0), e15 = this._cp3(i11, s14, 0.5, -1), r19 = this._sub(s14, h8);
          this._normalize(r19);
          const _4 = this._crossProduct(r19, this._sub(e15, h8));
          this._leftPerpendicular(r19);
          const c11 = [];
          c11.push([h8[0] - r19[0] * _4, h8[1] - r19[1] * _4]), c11.push([s14[0] - r19[0] * _4, s14[1] - r19[1] * _4]), t12.push(c11);
          break;
        }
        case R.OffsetSame: {
          const s14 = this._cp2(i11, 3, 0), e15 = this._cp3(i11, s14, 0.5, -1), r19 = this._sub(s14, h8);
          this._normalize(r19);
          const _4 = this._crossProduct(r19, this._sub(e15, h8));
          this._leftPerpendicular(r19);
          const c11 = [];
          c11.push([h8[0] + r19[0] * _4, h8[1] + r19[1] * _4]), c11.push([s14[0] + r19[0] * _4, s14[1] + r19[1] * _4]), t12.push(c11);
          break;
        }
        case R.CircleWithArc: {
          let r19 = this._cp2(i11, 3, 0);
          const _4 = this._cp3(i11, r19, 0.5, -1);
          let c11, u14;
          if (s13 >= 4)
            c11 = i11[3], u14 = this._crossProduct(this._sub(c11, r19), this._sub(_4, r19)) > 0;
          else {
            c11 = r19, u14 = this._crossProduct(this._sub(c11, h8), this._sub(_4, h8)) > 0;
            const s14 = 24 * this._geomUnitsPerPoint, t13 = this._sub(c11, h8);
            this._normalize(t13, s14);
            const i12 = Math.sqrt(2) / 2;
            this._rotateDirect(t13, i12, u14 ? i12 : -i12), r19 = this._add(h8, t13);
          }
          const o12 = this._sub(r19, h8), n17 = Math.cos(Math.PI / 18), a15 = Math.sin(Math.PI / 18), p6 = [r19];
          for (let s14 = 1; s14 <= 36; s14++)
            this._rotateDirect(o12, n17, a15), p6.push(this._add(h8, o12));
          this._add90DegArc(p6, r19, c11, _4, u14), j2(p6[p6.length - 8], 1), t12.push(p6);
          break;
        }
        case R.DoubleJog: {
          let e15, r19, _4 = this._cp2(i11, -3, 1);
          if (e15 = s13 >= 3 ? i11[2] : this._add(h8, this._sub(h8, _4)), s13 >= 4)
            r19 = i11[3];
          else {
            const s14 = h8;
            h8 = _4, r19 = e15;
            const t13 = this._dist(h8, s14), i12 = this._dist(r19, s14);
            let c12 = 30 * this._geomUnitsPerPoint;
            0.5 * t13 < c12 && (c12 = 0.5 * t13), 0.5 * i12 < c12 && (c12 = 0.5 * i12), _4 = this._mix(h8, c12 / t13, s14, (t13 - c12) / t13), e15 = this._mix(r19, c12 / i12, s14, (i12 - c12) / i12);
          }
          const c11 = this._mid(h8, _4), u14 = this._mid(r19, e15), o12 = this._dist(h8, _4), n17 = this._dist(e15, r19);
          let a15 = Math.min(o12, n17) / 8;
          a15 = Math.min(a15, 24 * this._geomUnitsPerPoint);
          const p6 = Math.cos(Math.PI / 4);
          let l12 = this._sub(h8, _4);
          this._normalize(l12, a15), this._crossProduct(l12, this._sub(r19, _4)) > 0 ? this._rotateDirect(l12, p6, -p6) : this._rotateDirect(l12, p6, p6);
          let d4 = [];
          d4.push(_4), d4.push(this._add(c11, l12)), d4.push(this._sub(c11, l12)), d4.push(h8), t12.push(d4), l12 = this._sub(r19, e15), this._normalize(l12, a15), this._crossProduct(l12, this._sub(h8, e15)) < 0 ? this._rotateDirect(l12, p6, p6) : this._rotateDirect(l12, p6, -p6), d4 = [], d4.push(e15), d4.push(this._add(u14, l12)), d4.push(this._sub(u14, l12)), d4.push(r19), t12.push(d4);
          break;
        }
        case R.PerpendicularOffset: {
          const s14 = this._cp2(i11, -4, 1), e15 = this._cp3(i11, s14, 0.882353, -1.94), r19 = this._sub(e15, s14);
          this._crossProduct(r19, this._sub(h8, s14)) > 0 ? this._rightPerpendicular(r19) : this._leftPerpendicular(r19);
          const _4 = [r19[0] / 8, r19[1] / 8], c11 = this._sub(this._mid(s14, e15), _4);
          t12.push([c11, h8]);
          break;
        }
        case R.LineExcludingLastSegment: {
          const s14 = this._arrowPath(i11), h9 = [];
          let e15 = s14.length - 2;
          for (; e15--; )
            h9.push(s14[e15]);
          t12.push(h9);
          break;
        }
        case R.MultivertexArrow: {
          const s14 = this._arrowPath(i11), h9 = [];
          this._addArrow(h9, s14, false), t12.push(h9);
          break;
        }
        case R.CrossedArrow: {
          const s14 = this._arrowPath(i11), h9 = [];
          this._addArrow(h9, s14, true), t12.push(h9);
          break;
        }
        case R.ChevronArrow: {
          const [s14, e15] = this._arrowLastSeg(i11), r19 = 10 * this._geomUnitsPerPoint, _4 = this._sub(h8, s14);
          this._normalize(_4);
          const c11 = this._crossProduct(_4, this._sub(e15, s14)), u14 = this._leftPerp(_4), o12 = [e15[0] - u14[0] * c11 * 2, e15[1] - u14[1] * c11 * 2], n17 = [];
          n17.push([e15[0] + _4[0] * r19, e15[1] + _4[1] * r19]), n17.push(h8), n17.push([o12[0] + _4[0] * r19, o12[1] + _4[1] * r19]), t12.push(n17);
          break;
        }
        case R.ChevronArrowOffset: {
          const [s14, e15] = this._arrowLastSeg(i11), r19 = this._sub(h8, s14);
          this._normalize(r19);
          const _4 = this._crossProduct(r19, this._sub(e15, s14));
          this._leftPerpendicular(r19);
          const c11 = [e15[0] - r19[0] * _4, e15[1] - r19[1] * _4], u14 = [];
          u14.push([c11[0] + r19[0] * _4 * 0.5, c11[1] + r19[1] * _4 * 0.5]), u14.push(this._mid(c11, h8)), u14.push([c11[0] - r19[0] * _4 * 0.5, c11[1] - r19[1] * _4 * 0.5]), t12.push(u14);
          break;
        }
        case R.PartialFirstSegment: {
          const [s14, e15] = this._arrowLastSeg(i11), r19 = this._sub(h8, s14);
          this._normalize(r19);
          const _4 = this._crossProduct(r19, this._sub(e15, s14));
          this._leftPerpendicular(r19);
          const c11 = [e15[0] - r19[0] * _4, e15[1] - r19[1] * _4];
          t12.push([s14, c11]);
          break;
        }
        case R.Arch: {
          const s14 = this._cp2(i11, 0, -1), e15 = this._cp3(i11, s14, 0.5, 1), r19 = this._sub(h8, s14), _4 = this._mix(e15, 1, r19, 0.55), c11 = this._mix(e15, 1, r19, -0.55), u14 = [h8];
          this._addBezier2(u14, h8, _4, e15, 4), this._addBezier2(u14, e15, c11, s14, 4), t12.push(u14);
          break;
        }
        case R.CurvedParallelTicks: {
          const s14 = this._cp2(i11, -4, 1), e15 = this._cp3(i11, s14, 0.882353, -1.94), r19 = this._sub(e15, s14);
          this._crossProduct(r19, this._sub(h8, s14)) > 0 ? this._rightPerpendicular(r19) : this._leftPerpendicular(r19);
          const _4 = [r19[0] / 8, r19[1] / 8], c11 = this._sub(this._mid(s14, e15), _4), u14 = this._sub(this._mix(s14, 0.75, e15, 0.25), _4), o12 = this._sub(this._mix(s14, 0.25, e15, 0.75), _4), n17 = [s14];
          this._addBezier2(n17, s14, u14, c11, 3), this._addBezier2(n17, c11, o12, e15, 3), t12.push(n17);
          for (let i12 = 0; i12 < 8; i12++) {
            const s15 = n17[2 * i12 + 1], h9 = [this._clone(s15)];
            h9.push(this._add(s15, [r19[0] / 4, r19[1] / 4])), t12.push(h9);
          }
          break;
        }
        case R.Arc90Degrees: {
          const s14 = this._cp2(i11, 0, -1), e15 = this._cp3(i11, s14, 0.5, 1), r19 = [s14];
          this._add90DegArc(r19, s14, h8, e15), t12.push(r19);
          break;
        }
        case R.FullGeometry:
        default:
          t12.push(i11);
      }
    }
    return t12;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectCut.js
var u9 = class {
  static local() {
    return null === u9.instance && (u9.instance = new u9()), u9.instance;
  }
  execute(e15, t12, u14, i11) {
    return new s8(e15, t12, u14);
  }
};
u9.instance = null;
var s8 = class extends U2 {
  constructor(e15, u14, s12) {
    super(e15, true, true), this._curveHelper = new n7(), this._beginCut = (void 0 !== u14.beginCut ? u14.beginCut : 1) * s12, this._endCut = (void 0 !== u14.endCut ? u14.endCut : 1) * s12, this._middleCut = (void 0 !== u14.middleCut ? u14.middleCut : 0) * s12, this._invert = void 0 !== u14.invert && u14.invert, this._beginCut < 0 && (this._beginCut = 0), this._endCut < 0 && (this._endCut = 0), this._middleCut < 0 && (this._middleCut = 0);
  }
  processPath(e15) {
    const t12 = this._beginCut, u14 = this._endCut, s12 = this._middleCut, i11 = this._curveHelper.calculatePathLength(e15), r19 = [];
    if (this._invert)
      if (0 === t12 && 0 === u14 && 0 === s12)
        ;
      else if (t12 + u14 + s12 >= i11)
        r19.push(e15);
      else {
        let n17 = this._curveHelper.getSubCurve(e15, 0, t12);
        n17 && r19.push(n17), n17 = this._curveHelper.getSubCurve(e15, 0.5 * (i11 - s12), 0.5 * (i11 + s12)), n17 && r19.push(n17), n17 = this._curveHelper.getSubCurve(e15, i11 - u14, u14), n17 && r19.push(n17);
      }
    else if (0 === t12 && 0 === u14 && 0 === s12)
      r19.push(e15);
    else if (t12 + u14 + s12 >= i11)
      ;
    else if (0 === s12) {
      const s13 = this._curveHelper.getSubCurve(e15, t12, i11 - u14);
      s13 && r19.push(s13);
    } else {
      let n17 = this._curveHelper.getSubCurve(e15, t12, 0.5 * (i11 - s12));
      n17 && r19.push(n17), n17 = this._curveHelper.getSubCurve(e15, 0.5 * (i11 + s12), i11 - u14), n17 && r19.push(n17);
    }
    return 0 === r19.length ? null : { paths: r19 };
  }
};

// node_modules/@arcgis/core/symbols/cim/GeometryWalker.js
var i8 = 1e-7;
var n8 = class {
  constructor() {
    this._values = [], this.extPtGap = 0, this.ctrlPtGap = 0, this._length = 0, this._currentValue = 0;
  }
  isEmpty() {
    return 0 === this._values.length;
  }
  size() {
    return this._values.length;
  }
  init(t12, s12, e15 = true) {
    if (this._setEmpty(), !t12 || 0 === t12.length)
      return false;
    for (let n17 = 0; n17 < t12.length; n17++) {
      let s13 = Math.abs(t12[n17]);
      e15 && s13 < i8 && (s13 = i8), this._values.push(s13), this._length += s13;
    }
    return s12 && 1 & t12.length && (this._length *= 2), 0 !== this._length && (this.ctrlPtGap = this.extPtGap = 0, this._currentValue = -1, true);
  }
  scale(t12) {
    const s12 = this._values ? this._values.length : 0;
    for (let e15 = 0; e15 < s12; ++e15)
      this._values[e15] *= t12;
    this._length *= t12, this.extPtGap *= t12, this.ctrlPtGap *= t12;
  }
  addValue(t12) {
    this._length += t12, this._values.push(t12);
  }
  firstValue() {
    return this._values[0];
  }
  lastValue() {
    return this._values[this._values.length - 1];
  }
  nextValue() {
    return this._currentValue++, this._currentValue === this._values.length && (this._currentValue = 0), this._values[this._currentValue];
  }
  reset() {
    this._currentValue = -1;
  }
  length() {
    return this._length;
  }
  _setEmpty() {
    this.extPtGap = this.ctrlPtGap = this._length = 0, this._currentValue = -1, this._values.length = 0;
  }
};
var h5 = class {
  constructor() {
    this.pt = null, this.ca = 0, this.sa = 0;
  }
};
var r7;
!function(t12) {
  t12[t12.FAIL = 0] = "FAIL", t12[t12.END = 1] = "END", t12[t12.CONTINUE = 2] = "CONTINUE";
}(r7 || (r7 = {}));
var a7 = class {
  constructor() {
    this.reset();
  }
  reset() {
    this.segment = -1, this.segmentLength = 0, this.abscissa = 0, this.isPathEnd = false, this.isPartEnd = false;
  }
  isValid() {
    return -1 !== this.segment;
  }
  copyTo(t12) {
    t12.segment = this.segment, t12.segmentLength = this.segmentLength, t12.abscissa = this.abscissa, t12.isPathEnd = this.isPathEnd, t12.isPartEnd = this.isPartEnd;
  }
};
var g4 = class extends n7 {
  constructor(t12 = 0, s12 = false) {
    super(t12, s12), this._tolerance = e8, this._currentPosition = new a7();
  }
  updateTolerance(t12) {
    this._tolerance = e8 * t12;
  }
  init(t12, s12, e15 = true) {
    return e15 ? (this._patternLength = s12.length(), this._partExtPtGap = s12.extPtGap, this._partCtrlPtGap = s12.ctrlPtGap) : (this._patternLength = 0, this._partExtPtGap = 0, this._partCtrlPtGap = 0), this._currentPosition.reset(), this._partSegCount = 0, this._path = t12, this._seg = -1, this._setPosAtNextPart();
  }
  curPositionIsValid() {
    return this._currentPosition.isValid();
  }
  nextPosition(t12, s12 = r7.FAIL) {
    const e15 = new a7();
    return !!this._nextPosition(t12, e15, null, s12) && (e15.copyTo(this._currentPosition), true);
  }
  curPointAndAngle(t12) {
    t12.pt = this._getPoint(this._currentPosition);
    const [s12, e15] = this._getAngle(this._currentPosition);
    t12.ca = s12, t12.sa = e15;
  }
  nextPointAndAngle(t12, s12, e15 = r7.FAIL) {
    const i11 = new a7();
    if (!this._nextPosition(t12, i11, null, e15))
      return false;
    i11.copyTo(this._currentPosition), s12.pt = this._getPoint(i11);
    const [n17, h8] = this._getAngle(i11);
    return s12.ca = n17, s12.sa = h8, true;
  }
  nextCurve(t12) {
    if (0 === t12)
      return null;
    const s12 = [], e15 = new a7();
    return this._nextPosition(t12, e15, s12, r7.END) ? (e15.copyTo(this._currentPosition), s12) : null;
  }
  isPathEnd() {
    return this._currentPosition.isPathEnd;
  }
  getPathEnd() {
    if (-1 === this._currentPosition.segment)
      throw new Error("missing segment");
    return this._path[this._currentPosition.segment + 1];
  }
  _nextPosition(t12, s12, e15, i11) {
    if (this._currentPosition.isPathEnd)
      return false;
    let n17 = this._currentPosition.abscissa;
    for (this._currentPosition.segmentLength > 0 && (n17 /= this._currentPosition.segmentLength), this._currentPosition.copyTo(s12); s12.abscissa + t12 * this._partLengthRatio > s12.segmentLength + this._tolerance; ) {
      if (e15) {
        if (0 === e15.length)
          if (0 === n17) {
            const t14 = this._path[s12.segment];
            e15.push([t14[0], t14[1]]);
          } else
            e15.push(this.getSegCoord2D(this._path, s12.segment, n17));
        const t13 = this._path[s12.segment + 1];
        e15.push([t13[0], t13[1]]);
      }
      if (n17 = 0, t12 -= (s12.segmentLength - s12.abscissa) / this._partLengthRatio, this._partSegCount)
        s12.segment = this._nextSegment(), s12.segmentLength = this.calculateSegLength(this._path, s12.segment), s12.abscissa = 0, this._partSegCount--;
      else {
        if (!this._setPosAtNextPart())
          return i11 !== r7.FAIL && (s12.segmentLength = this.calculateSegLength(this._path, s12.segment), s12.isPartEnd = true, i11 === r7.END ? (s12.abscissa = s12.segmentLength, s12.isPathEnd = true) : s12.abscissa = s12.segmentLength + t12, true);
        this._currentPosition.copyTo(s12);
      }
    }
    if (s12.abscissa += t12 * this._partLengthRatio, e15) {
      if (0 === e15.length)
        if (0 === n17) {
          const t14 = this._path[s12.segment];
          e15.push([t14[0], t14[1]]);
        } else
          e15.push(this.getSegCoord2D(this._path, s12.segment, n17));
      const t13 = s12.abscissa / s12.segmentLength;
      if (1 === t13) {
        const t14 = this._path[s12.segment + 1];
        e15.push([t14[0], t14[1]]);
      } else
        e15.push(this.getSegCoord2D(this._path, s12.segment, t13));
    }
    return this._partSegCount || Math.abs(s12.abscissa - s12.segmentLength) < this._tolerance && (s12.isPathEnd = this._partIsLast, s12.isPartEnd = true), true;
  }
  _getPoint(t12) {
    if (-1 === t12.segment)
      throw new Error("missing segment");
    const s12 = t12.segmentLength <= 0 ? 0 : t12.abscissa / t12.segmentLength;
    return this.getSegCoord2D(this._path, t12.segment, s12);
  }
  _getAngle(t12) {
    if (-1 === t12.segment)
      throw new Error("missing segment");
    const s12 = t12.segmentLength <= 0 ? 0 : t12.abscissa / t12.segmentLength;
    return this.getSegAngleCS(this._path, t12.segment, s12);
  }
  _setPosAtNextPart() {
    for (; this._partSegCount; )
      this._hasNextSegment() && this._nextSegment(), this._partSegCount--;
    if (!this._hasNextSegment())
      return false;
    for (this._partLength = 0, this._partIsLast = true, this._partSegCount = 0; this._hasNextSegment(); )
      if (this._partLength += this.calculateSegLength(this._path, this._nextSegment()), this._partSegCount++, 1 === I2(this._path[this._getEndPointIndex()])) {
        this._partIsLast = !this._hasNextSegment();
        break;
      }
    let s12 = this._partSegCount;
    for (; s12; )
      this._previousSegment(), --s12;
    this._currentPosition.segment = this._nextSegment(), this._currentPosition.segmentLength = this.calculateSegLength(this._path, this._currentPosition.segment), this._currentPosition.abscissa = 0, this._currentPosition.isPathEnd = this._currentPosition.isPartEnd = false, --this._partSegCount;
    const e15 = this._getStartPointIndex();
    this._ctrlPtBegin = 1 === I2(this._path[e15]);
    let i11 = e15 + this._partSegCount + 1;
    if (i11 >= this._path.length && (i11 = 0), this._ctrlPtEnd = 1 === I2(this._path[i11]), this._patternLength > 0) {
      const t12 = this._ctrlPtBegin ? this._partCtrlPtGap : this._partExtPtGap, s13 = this._ctrlPtEnd ? this._partCtrlPtGap : this._partExtPtGap;
      let e16 = Math.round((this._partLength - (t12 + s13)) / this._patternLength);
      e16 <= 0 && (e16 = t12 + s13 > 0 ? 0 : 1), this._partLengthRatio = this._partLength / (t12 + s13 + e16 * this._patternLength), this._partLengthRatio < 0.01 && (this._partLengthRatio = 1);
    } else
      this._partLengthRatio = 1;
    return true;
  }
  _hasNextSegment() {
    return this._seg < this._path.length - 2;
  }
  _previousSegment() {
    return --this._seg;
  }
  _nextSegment() {
    return ++this._seg;
  }
  _getStartPointIndex() {
    return this._seg;
  }
  _getEndPointIndex() {
    return this._seg + 1;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectDashes.js
var r8 = class {
  static local() {
    return null === r8.instance && (r8.instance = new r8()), r8.instance;
  }
  execute(t12, e15, s12, a15) {
    return new n9(t12, e15, s12);
  }
};
r8.instance = null;
var n9 = class extends U2 {
  constructor(t12, e15, s12) {
    var _a, _b;
    super(t12, true, true), this._firstCurve = null, this._walker = new g4(), this._walker.updateTolerance(s12), this._endings = e15.lineDashEnding, this._customDashPos = -((_a = e15.offsetAlongLine) != null ? _a : 0) * s12, this._offsetAtEnd = ((_b = e15.customEndingOffset) != null ? _b : 0) * s12, this._pattern = new n8(), this._pattern.init(e15.dashTemplate, true), this._pattern.scale(s12);
  }
  processPath(t12) {
    if (0 === this._pattern.length())
      return this.iteratePath = false, { paths: [t12] };
    if (!this.iteratePath) {
      let e15 = true;
      switch (this._endings) {
        case k2.HalfPattern:
        case k2.HalfGap:
        default:
          this._pattern.extPtGap = 0;
          break;
        case k2.FullPattern:
          this.isClosed || (this._pattern.extPtGap = 0.5 * this._pattern.firstValue());
          break;
        case k2.FullGap:
          this.isClosed || (this._pattern.extPtGap = 0.5 * this._pattern.lastValue());
          break;
        case k2.NoConstraint:
          this.isClosed || (e15 = false);
          break;
        case k2.Custom:
          this.isClosed || (this._pattern.extPtGap = 0.5 * this._offsetAtEnd);
      }
      const a16 = this._walker.calculatePathLength(t12);
      if (this._pattern.isEmpty() || a16 < 0.1 * this._pattern.length())
        return { paths: [t12] };
      if (!this._walker.init(t12, this._pattern, e15))
        return { paths: [t12] };
    }
    let a15;
    if (this.iteratePath)
      a15 = this._pattern.nextValue();
    else {
      let t13;
      switch (this._endings) {
        case k2.HalfPattern:
        default:
          t13 = 0.5 * this._pattern.firstValue();
          break;
        case k2.HalfGap:
          t13 = 0.5 * -this._pattern.lastValue();
          break;
        case k2.FullGap:
          t13 = -this._pattern.lastValue();
          break;
        case k2.FullPattern:
          t13 = 0;
          break;
        case k2.NoConstraint:
        case k2.Custom:
          t13 = -this._customDashPos;
      }
      let e15 = t13 / this._pattern.length();
      e15 -= Math.floor(e15), t13 = e15 * this._pattern.length(), this._pattern.reset(), a15 = this._pattern.nextValue();
      let i12 = false;
      for (; t13 >= a15; )
        t13 -= a15, a15 = this._pattern.nextValue(), i12 = !i12;
      a15 -= t13, i12 ? (this._walker.nextPosition(a15), a15 = this._pattern.nextValue()) : this.isClosed && (this._firstCurve = this._walker.nextCurve(a15), a15 = this._pattern.nextValue(), this._walker.nextPosition(a15), a15 = this._pattern.nextValue());
    }
    let i11 = this._walker.nextCurve(a15);
    return i11 ? this._walker.isPathEnd() ? (this.iteratePath = false, this._firstCurve && (this._firstCurve.splice(0, 1), s7.mergePath(i11, this._firstCurve), this._firstCurve = null)) : (a15 = this._pattern.nextValue(), !this._walker.nextPosition(a15) || this._walker.isPathEnd() ? (this.iteratePath = false, this._firstCurve && (i11 = this._firstCurve, this._firstCurve = null)) : this.iteratePath = true) : (this.iteratePath = false, i11 = this._firstCurve, this._firstCurve = null), { paths: [i11] };
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectDonut.js
var r9 = class {
  static local() {
    return null === r9.instance && (r9.instance = new r9()), r9.instance;
  }
  execute(t12, i11, e15, s12) {
    return new m5(t12, i11, e15);
  }
};
r9.instance = null;
var m5 = class {
  constructor(t12, i11, r19) {
    switch (this._inputGeometries = t12, this._curveHelper = new n7(), this._width = (void 0 !== i11.width ? i11.width : 2) * r19, i11.method) {
      case B.Mitered:
      default:
        this._method = O.Mitered;
        break;
      case B.Bevelled:
        this._method = O.Bevelled;
        break;
      case B.Rounded:
      case B.TrueBuffer:
        this._method = O.Rounded;
        break;
      case B.Square:
        this._method = O.Square;
    }
    this._option = i11.option, this._offsetFlattenError = e8 * r19;
  }
  next() {
    let e15 = this._inputGeometries.next();
    for (; e15; ) {
      if (u2(e15) && this._width > 0) {
        if (Math.min(e15.xmax - e15.xmin, e15.ymax - e15.ymin) - 2 * this._width < 0)
          return e15;
        const t12 = [];
        return t12.push([[e15.xmin, e15.ymin], [e15.xmin, e15.ymax], [e15.xmax, e15.ymax], [e15.xmax, e15.ymin], [e15.xmin, e15.ymin]]), t12.push([[e15.xmin + this._width, e15.ymin + this._width], [e15.xmax - this._width, e15.ymin + this._width], [e15.xmax - this._width, e15.ymax - this._width], [e15.xmin + this._width, e15.ymax - this._width], [e15.xmin + this._width, e15.ymin + this._width]]), { rings: t12 };
      }
      if (y2(e15) && this._width > 0) {
        const t12 = [];
        for (const i11 of e15.rings) {
          const e16 = this._curveHelper.calculatePathLength(i11), s12 = this._curveHelper.offset(i11, this._width, this._method, 4, this._offsetFlattenError);
          s12 && (e16 < 0 && s12.reverse(), t12.push(s12));
        }
        if (t12.length)
          return { rings: t12 };
      }
      e15 = this._inputGeometries.next();
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectJog.js
var s9 = class {
  static local() {
    return null === s9.instance && (s9.instance = new s9()), s9.instance;
  }
  execute(t12, i11, s12, n17) {
    return new e9(t12, i11, s12);
  }
};
s9.instance = null;
var e9 = class extends U2 {
  constructor(t12, s12, e15) {
    super(t12, false, true), this._curveHelper = new n7(), this._length = (void 0 !== s12.length ? s12.length : 20) * e15, this._angle = void 0 !== s12.angle ? s12.angle : 225, this._position = void 0 !== s12.position ? s12.position : 50, this._length < 0 && (this._length = -this._length), this._position < 20 && (this._position = 20), this._position > 80 && (this._position = 80), this._mirror = false;
  }
  processPath(t12) {
    if (this._curveHelper.isEmpty(t12, false))
      return null;
    const i11 = t12[0], s12 = t12[t12.length - 1], e15 = [s12[0] - i11[0], s12[1] - i11[1]];
    this._curveHelper.normalize(e15);
    const n17 = [i11[0] + (s12[0] - i11[0]) * this._position / 100, i11[1] + (s12[1] - i11[1]) * this._position / 100], h8 = Math.cos((90 - this._angle) / 180 * Math.PI);
    let r19 = Math.sin((90 - this._angle) / 180 * Math.PI);
    this._mirror && (r19 = -r19), this._mirror = !this._mirror;
    return { paths: [[i11, [n17[0] - this._length / 2 * h8, n17[1] - this._length / 2 * r19], [n17[0] + this._length / 2 * h8, n17[1] + this._length / 2 * r19], s12]] };
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectMove.js
var n10 = class {
  static local() {
    return null === n10.instance && (n10.instance = new n10()), n10.instance;
  }
  execute(t12, s12, e15, i11) {
    return new r10(t12, s12, e15);
  }
};
n10.instance = null;
var r10 = class {
  constructor(t12, s12, e15) {
    this._inputGeometries = t12, this._offsetX = void 0 !== s12.offsetX ? s12.offsetX * e15 : 0, this._offsetY = void 0 !== s12.offsetY ? -s12.offsetY * e15 : 0;
  }
  next() {
    let n17 = this._inputGeometries.next();
    for (; n17; ) {
      if (u2(n17))
        return { xmin: n17.xmin + this._offsetX, xmax: n17.xmax + this._offsetX, ymin: n17.ymin + this._offsetY, ymax: n17.ymax + this._offsetY };
      if (y2(n17)) {
        const s12 = y(n17);
        return this._moveMultipath(s12.rings, this._offsetX, this._offsetY), s12;
      }
      if (f(n17)) {
        const s12 = y(n17);
        return this._moveMultipath(s12.paths, this._offsetX, this._offsetY), s12;
      }
      if (l2(n17)) {
        const s12 = y(n17);
        return this._movePath(s12.points, this._offsetX, this._offsetY), s12;
      }
      if (s4(n17))
        return { x: n17.x + this._offsetX, y: n17.y + this._offsetY };
      n17 = this._inputGeometries.next();
    }
    return null;
  }
  _moveMultipath(t12, s12, e15) {
    if (t12)
      for (const i11 of t12)
        this._movePath(i11, s12, e15);
  }
  _movePath(t12, s12, e15) {
    if (t12)
      for (const i11 of t12)
        i11[0] += s12, i11[1] += e15;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectOffset.js
var r11 = class {
  static local() {
    return null === r11.instance && (r11.instance = new r11()), r11.instance;
  }
  execute(t12, e15, s12, i11) {
    return new f5(t12, e15, s12);
  }
};
r11.instance = null;
var f5 = class {
  constructor(t12, e15, s12) {
    var _a;
    this._inputGeometries = t12, this._curveHelper = new n7(), this._offset = ((_a = e15.offset) != null ? _a : 1) * s12, this._method = e15.method, this._option = e15.option, this._offsetFlattenError = e8 * s12;
  }
  next() {
    let i11 = this._inputGeometries.next();
    for (; i11; ) {
      if (0 === this._offset)
        return i11;
      if (u2(i11)) {
        if (this._method === O.Rounded && this._offset > 0) {
          const t12 = [[i11.xmin, i11.ymin], [i11.xmin, i11.ymax], [i11.xmax, i11.ymax], [i11.xmax, i11.ymin], [i11.xmin, i11.ymin]], e15 = this._curveHelper.offset(t12, -this._offset, this._method, 4, this._offsetFlattenError);
          return e15 ? { rings: [e15] } : null;
        }
        if (Math.min(i11.xmax - i11.xmin, i11.ymax - i11.ymin) + 2 * this._offset > 0)
          return { xmin: i11.xmin - this._offset, xmax: i11.xmax + this._offset, ymin: i11.ymin - this._offset, ymax: i11.ymax + this._offset };
      }
      if (y2(i11)) {
        const t12 = [];
        for (const e15 of i11.rings) {
          const s12 = this._curveHelper.offset(e15, -this._offset, this._method, 4, this._offsetFlattenError);
          s12 && t12.push(s12);
        }
        if (t12.length)
          return { rings: t12 };
      }
      if (f(i11)) {
        const t12 = [];
        for (const e15 of i11.paths) {
          const s12 = this._curveHelper.offset(e15, -this._offset, this._method, 4, this._offsetFlattenError);
          s12 && t12.push(s12);
        }
        if (t12.length)
          return { paths: t12 };
      }
      i11 = this._inputGeometries.next();
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectReverse.js
var s10 = class {
  static local() {
    return null === s10.instance && (s10.instance = new s10()), s10.instance;
  }
  execute(e15, t12, r19, s12) {
    return new n11(e15, t12, r19);
  }
};
s10.instance = null;
var n11 = class {
  constructor(e15, t12, r19) {
    this._inputGeometries = e15, this._reverse = void 0 === t12.reverse || t12.reverse;
  }
  next() {
    let s12 = this._inputGeometries.next();
    for (; s12; ) {
      if (!this._reverse)
        return s12;
      if (f(s12)) {
        const t12 = y(s12);
        return g3(t12.paths), t12;
      }
      s12 = this._inputGeometries.next();
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectRotate.js
var u10 = class {
  static local() {
    return null === u10.instance && (u10.instance = new u10()), u10.instance;
  }
  execute(t12, n17, e15, r19) {
    return new c7(t12, n17, e15);
  }
};
u10.instance = null;
var c7 = class {
  constructor(t12, n17, e15) {
    this._inputGeometries = t12, this._rotateAngle = void 0 !== n17.angle ? n17.angle * Math.PI / 180 : 0;
  }
  next() {
    let u14 = this._inputGeometries.next();
    for (; u14; ) {
      if (0 === this._rotateAngle)
        return u14;
      const c11 = u4();
      c2(c11, u14);
      const l12 = (c11[2] + c11[0]) / 2, m8 = (c11[3] + c11[1]) / 2;
      if (u2(u14)) {
        const t12 = { rings: [[[u14.xmin, u14.ymin], [u14.xmin, u14.ymax], [u14.xmax, u14.ymax], [u14.xmax, u14.ymin], [u14.xmin, u14.ymin]]] };
        return this._rotateMultipath(t12.rings, l12, m8), t12;
      }
      if (y2(u14)) {
        const n17 = y(u14);
        return this._rotateMultipath(n17.rings, l12, m8), n17;
      }
      if (f(u14)) {
        const n17 = y(u14);
        return this._rotateMultipath(n17.paths, l12, m8), n17;
      }
      if (l2(u14)) {
        const n17 = y(u14);
        return this._rotatePath(n17.points, l12, m8), n17;
      }
      if (s4(u14))
        return u14;
      u14 = this._inputGeometries.next();
    }
    return null;
  }
  _rotateMultipath(t12, n17, e15) {
    if (t12)
      for (const r19 of t12)
        this._rotatePath(r19, n17, e15);
  }
  _rotatePath(t12, n17, e15) {
    if (t12) {
      const r19 = Math.cos(this._rotateAngle), i11 = Math.sin(this._rotateAngle);
      for (const o12 of t12) {
        const t13 = o12[0] - n17, s12 = o12[1] - e15;
        o12[0] = n17 + t13 * r19 - s12 * i11, o12[1] = e15 + t13 * i11 + s12 * r19;
      }
    }
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectScale.js
var c8 = class {
  static local() {
    return null === c8.instance && (c8.instance = new c8()), c8.instance;
  }
  execute(t12, s12, i11, r19) {
    return new l7(t12, s12, i11);
  }
};
c8.instance = null;
var l7 = class {
  constructor(t12, s12, i11) {
    this._inputGeometries = t12, this._xFactor = void 0 !== s12.xScaleFactor ? s12.xScaleFactor : 1.15, this._yFactor = void 0 !== s12.yScaleFactor ? s12.yScaleFactor : 1.15;
  }
  next() {
    let c11 = this._inputGeometries.next();
    for (; c11; ) {
      if (1 === this._xFactor && 1 === this._yFactor)
        return c11;
      const l12 = u4();
      c2(l12, c11);
      const u14 = (l12[2] + l12[0]) / 2, m8 = (l12[3] + l12[1]) / 2;
      if (u2(c11)) {
        const t12 = { rings: [[[c11.xmin, c11.ymin], [c11.xmin, c11.ymax], [c11.xmax, c11.ymax], [c11.xmax, c11.ymin], [c11.xmin, c11.ymin]]] };
        return this._scaleMultipath(t12.rings, u14, m8), t12;
      }
      if (y2(c11)) {
        const s12 = y(c11);
        return this._scaleMultipath(s12.rings, u14, m8), s12;
      }
      if (f(c11)) {
        const s12 = y(c11);
        return this._scaleMultipath(s12.paths, u14, m8), s12;
      }
      if (l2(c11)) {
        const s12 = y(c11);
        return this._scalePath(s12.points, u14, m8), s12;
      }
      if (s4(c11))
        return c11;
      c11 = this._inputGeometries.next();
    }
    return null;
  }
  _scaleMultipath(t12, s12, i11) {
    if (t12)
      for (const r19 of t12)
        this._scalePath(r19, s12, i11);
  }
  _scalePath(t12, s12, i11) {
    if (t12)
      for (const r19 of t12) {
        const t13 = (r19[0] - s12) * this._xFactor, n17 = (r19[1] - i11) * this._yFactor;
        r19[0] = s12 + t13, r19[1] = i11 + n17;
      }
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectWave.js
var a8 = class {
  static local() {
    return null === a8.instance && (a8.instance = new a8()), a8.instance;
  }
  execute(t12, e15, i11, s12) {
    return new o8(t12, e15, i11);
  }
};
a8.instance = null;
var o8 = class {
  constructor(t12, e15, i11) {
    this._inputGeometries = t12, this._height = (void 0 !== e15.amplitude ? e15.amplitude : 2) * i11, this._period = (void 0 !== e15.period ? e15.period : 3) * i11, this._style = e15.waveform, this._height <= 0 && (this._height = Math.abs(this._height)), this._period <= 0 && (this._period = Math.abs(this._period)), this._pattern = new n8(), this._pattern.addValue(this._period), this._pattern.addValue(this._period), this._walker = new g4(), this._walker.updateTolerance(i11);
  }
  next() {
    let i11 = this._inputGeometries.next();
    for (; i11; ) {
      if (0 === this._height || 0 === this._period)
        return i11;
      if (f(i11)) {
        const t12 = this._processGeom(i11.paths);
        if (t12.length)
          return { paths: t12 };
      }
      if (y2(i11)) {
        const t12 = this._processGeom(i11.rings);
        if (t12.length)
          return { rings: t12 };
      }
      i11 = this._inputGeometries.next();
    }
    return null;
  }
  _processGeom(t12) {
    const e15 = [];
    for (const i11 of t12)
      if (this._walker.init(i11, this._pattern))
        switch (this._style) {
          case A2.Sinus:
          default:
            e15.push(this._constructCurve(i11, false));
            break;
          case A2.Square:
            e15.push(this._constructSquare(i11));
            break;
          case A2.Triangle:
            e15.push(this._constructTriangle(i11));
            break;
          case A2.Random:
            e15.push(this._constructCurve(i11, true));
        }
      else
        e15.push(i11);
    return e15;
  }
  _constructCurve(t12, e15) {
    const s12 = new s7(), h8 = this._walker.calculatePathLength(t12);
    let n17 = Math.round(h8 / this._period);
    0 === n17 && (n17 = 1);
    const a15 = n17 * 16 + 1, o12 = h8 / n17, l12 = this._period / 16, _4 = 1 / a15, c11 = 2 * Math.PI * h8 / o12, p6 = 2 * Math.PI * Math.random(), u14 = 2 * Math.PI * Math.random(), d4 = 2 * Math.PI * Math.random(), g8 = 0.75 - Math.random() / 2, w6 = 0.75 - Math.random() / 2, f9 = new h5();
    this._walker.curPointAndAngle(f9), s12.startPath(f9.pt);
    let k4 = 0;
    for (; ; ) {
      if (!this._walker.nextPointAndAngle(l12, f9)) {
        s12.lineTo(t12[t12.length - 1]);
        break;
      }
      {
        const t13 = k4;
        let i11;
        if (k4 += _4, e15) {
          const e16 = this._height / 2 * (1 + 0.3 * Math.sin(g8 * c11 * t13 + p6));
          i11 = e16 * Math.sin(c11 * t13 + u14), i11 += e16 * Math.sin(w6 * c11 * t13 + d4), i11 /= 2;
        } else
          i11 = 0.5 * this._height * Math.sin(0.5 * c11 * t13);
        s12.lineTo([f9.pt[0] - i11 * f9.sa, f9.pt[1] + i11 * f9.ca]);
      }
    }
    return s12.path();
  }
  _constructSquare(t12) {
    const e15 = new s7(), s12 = this._walker.calculatePathLength(t12);
    Math.round(s12 / this._period);
    let h8 = true;
    for (; ; ) {
      let t13 = false;
      if (this._walker.curPositionIsValid()) {
        const i11 = new h5();
        this._walker.curPointAndAngle(i11);
        const s13 = new h5();
        if (this._walker.nextPointAndAngle(this._period, s13)) {
          const n17 = new h5();
          this._walker.nextPointAndAngle(this._period, n17) && (h8 ? (e15.startPath(i11.pt), h8 = false) : e15.lineTo(i11.pt), e15.lineTo([i11.pt[0] - this._height / 2 * i11.sa, i11.pt[1] + this._height / 2 * i11.ca]), e15.lineTo([s13.pt[0] - this._height / 2 * s13.sa, s13.pt[1] + this._height / 2 * s13.ca]), e15.lineTo([s13.pt[0] + this._height / 2 * s13.sa, s13.pt[1] - this._height / 2 * s13.ca]), e15.lineTo([n17.pt[0] + this._height / 2 * n17.sa, n17.pt[1] - this._height / 2 * n17.ca]), t13 = true);
        }
      }
      if (!t13) {
        e15.lineTo(this._walker.getPathEnd());
        break;
      }
    }
    return e15.path();
  }
  _constructTriangle(t12) {
    const e15 = new s7(), s12 = this._walker.calculatePathLength(t12);
    Math.round(s12 / this._period);
    let h8 = true;
    for (; ; ) {
      let t13 = false;
      if (this._walker.curPositionIsValid()) {
        const i11 = new h5();
        this._walker.curPointAndAngle(i11);
        const s13 = new h5();
        if (this._walker.nextPointAndAngle(this._period / 2, s13)) {
          const n17 = new h5();
          this._walker.nextPointAndAngle(this._period, n17) && (this._walker.nextPosition(this._period / 2) && (h8 ? (e15.startPath(i11.pt), h8 = false) : e15.lineTo(i11.pt), e15.lineTo([s13.pt[0] - this._height / 2 * s13.sa, s13.pt[1] + this._height / 2 * s13.ca]), e15.lineTo([n17.pt[0] + this._height / 2 * n17.sa, n17.pt[1] - this._height / 2 * n17.ca])), t13 = true);
        }
      }
      if (!t13) {
        e15.lineTo(this._walker.getPathEnd());
        break;
      }
    }
    return e15.path();
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementAlongLineSameSize.js
var a9 = class {
  static local() {
    return null === a9.instance && (a9.instance = new a9()), a9.instance;
  }
  execute(t12, e15, s12, i11) {
    return new r12(t12, e15, s12);
  }
};
a9.instance = null;
var r12 = class extends G2 {
  constructor(t12, e15, n17) {
    var _a;
    super(t12, true, true), this._geometryWalker = new g4(), this._geometryWalker.updateTolerance(n17), this._angleToLine = (_a = e15.angleToLine) != null ? _a : true, this._offset = (e15.offset ? e15.offset : 0) * n17, this._originalEndings = e15.endings, this._offsetAtEnd = (e15.customEndingOffset ? e15.customEndingOffset : 0) * n17, this._position = -(e15.offsetAlongLine ? e15.offsetAlongLine : 0) * n17, this._pattern = new n8(), this._pattern.init(e15.placementTemplate, false), this._pattern.scale(n17), this._endings = this._originalEndings;
  }
  processPath(t12) {
    if (this._pattern.isEmpty())
      return null;
    let s12;
    if (this.iteratePath)
      s12 = this._pattern.nextValue();
    else {
      this._originalEndings === X.WithFullGap && this.isClosed ? this._endings = X.WithMarkers : this._endings = this._originalEndings, this._pattern.extPtGap = 0;
      let i12, n17 = true;
      switch (this._endings) {
        case X.NoConstraint:
          i12 = -this._position, i12 = this._adjustPosition(i12), n17 = false;
          break;
        case X.WithHalfGap:
        default:
          i12 = -this._pattern.lastValue() / 2;
          break;
        case X.WithFullGap:
          i12 = -this._pattern.lastValue(), this._pattern.extPtGap = this._pattern.lastValue();
          break;
        case X.WithMarkers:
          i12 = 0;
          break;
        case X.Custom:
          i12 = -this._position, i12 = this._adjustPosition(i12), this._pattern.extPtGap = 0.5 * this._offsetAtEnd;
      }
      if (!this._geometryWalker.init(t12, this._pattern, n17))
        return null;
      this._pattern.reset();
      let a15 = 0;
      for (; i12 > a15; )
        i12 -= a15, a15 = this._pattern.nextValue();
      a15 -= i12, s12 = a15, this.iteratePath = true;
    }
    const i11 = new h5();
    return this._geometryWalker.nextPointAndAngle(s12, i11) ? this._endings === X.WithFullGap && this._geometryWalker.isPathEnd() ? (this.iteratePath = false, null) : this._endings === X.WithMarkers && this._geometryWalker.isPathEnd() && (this.iteratePath = false, this.isClosed) ? null : (this.internalPlacement.setTranslate(i11.pt[0] - this._offset * i11.sa, i11.pt[1] + this._offset * i11.ca), this._angleToLine && this.internalPlacement.setRotateCS(i11.ca, i11.sa), this.internalPlacement) : (this.iteratePath = false, null);
  }
  _adjustPosition(t12) {
    let e15 = t12 / this._pattern.length();
    return e15 -= Math.floor(e15), e15 * this._pattern.length();
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementAtExtremities.js
var n12 = class {
  static local() {
    return null === n12.instance && (n12.instance = new n12()), n12.instance;
  }
  execute(t12, e15, s12, i11) {
    return new r13(t12, e15, s12);
  }
};
n12.instance = null;
var r13 = class extends G2 {
  constructor(t12, e15, i11) {
    super(t12, false, true), this._curveHelper = new n7(), this._angleToLine = void 0 === e15.angleToLine || e15.angleToLine, this._offset = void 0 !== e15.offset ? e15.offset * i11 : 0, this._type = e15.extremityPlacement, this._position = void 0 !== e15.offsetAlongLine ? e15.offsetAlongLine * i11 : 0, this._beginProcessed = false;
  }
  processPath(t12) {
    let e15;
    switch (this._type) {
      case o3.Both:
      default:
        this._beginProcessed ? (e15 = this._atExtremities(t12, this._position, false), this._beginProcessed = false, this.iteratePath = false) : (e15 = this._atExtremities(t12, this._position, true), this._beginProcessed = true, this.iteratePath = true);
        break;
      case o3.JustBegin:
        e15 = this._atExtremities(t12, this._position, true);
        break;
      case o3.JustEnd:
        e15 = this._atExtremities(t12, this._position, false);
      case o3.None:
    }
    return e15;
  }
  _atExtremities(t12, s12, i11) {
    const n17 = t12.length;
    if (n17 < 2)
      return null;
    const r19 = i11 ? 1 : n17 - 2, o12 = i11 ? n17 : -1, a15 = i11 ? 1 : -1;
    let l12, h8 = 0, c11 = i11 ? t12[0] : t12[n17 - 1];
    for (let _4 = r19; _4 !== o12; _4 += a15) {
      l12 = c11, c11 = t12[_4];
      const i12 = this._curveHelper.calculateLength(l12, c11);
      if (h8 + i12 > s12) {
        const t13 = (s12 - h8) / i12, [n18, r20] = this._curveHelper.getAngleCS(l12, c11, t13), o13 = C3(l12, c11, t13);
        return this.internalPlacement.setTranslate(o13[0] - this._offset * r20, o13[1] + this._offset * n18), this._angleToLine && this.internalPlacement.setRotateCS(-n18, -r20), this.internalPlacement;
      }
      h8 += i12;
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementAtRatioPositions.js
var a10 = class {
  static local() {
    return null === a10.instance && (a10.instance = new a10()), a10.instance;
  }
  execute(t12, i11, s12, e15) {
    return new r14(t12, i11, s12);
  }
};
a10.instance = null;
var r14 = class extends G2 {
  constructor(t12, e15, n17) {
    super(t12, true, true), this._walker = new g4(), this._walker.updateTolerance(n17), this._angleToLine = void 0 === e15.angleToLine || e15.angleToLine, this._offset = void 0 !== e15.offset ? e15.offset * n17 : 0, this._beginGap = void 0 !== e15.beginPosition ? e15.beginPosition * n17 : 0, this._endGap = void 0 !== e15.endPosition ? e15.endPosition * n17 : 0, this._flipFirst = void 0 === e15.flipFirst || e15.flipFirst, this._pattern = new n8(), this._pattern.init(e15.positionArray, false, false), this._subPathLen = 0, this._posCount = this._pattern.size(), this._isFirst = true, this._prevPos = 0;
  }
  processPath(t12) {
    if (this._pattern.isEmpty())
      return null;
    let i11;
    if (this.iteratePath) {
      const t13 = this._pattern.nextValue() * this._subPathLen, s13 = this._beginGap + t13;
      i11 = s13 - this._prevPos, this._prevPos = s13;
    } else {
      if (this._posCount = this._pattern.size(), this._isFirst = true, this._prevPos = 0, this._subPathLen = this._walker.calculatePathLength(t12) - this._beginGap - this._endGap, this._subPathLen < 0)
        return this.iteratePath = false, null;
      if (!this._walker.init(t12, this._pattern, false))
        return null;
      this._pattern.reset();
      const s13 = this._pattern.nextValue() * this._subPathLen, e15 = this._beginGap + s13;
      i11 = e15 - this._prevPos, this._prevPos = e15, this.iteratePath = true;
    }
    const s12 = new h5();
    if (!this._walker.nextPointAndAngle(i11, s12, r7.END))
      return this.iteratePath = false, null;
    this.internalPlacement.setTranslate(s12.pt[0] - this._offset * s12.sa, s12.pt[1] + this._offset * s12.ca);
    const a15 = this._isFirst && this._flipFirst;
    let r19, h8;
    return this._angleToLine ? (r19 = s12.ca, h8 = s12.sa) : (r19 = 1, h8 = 0), a15 && (r19 = -r19, h8 = -h8), this.internalPlacement.setRotateCS(r19, h8), this._isFirst = false, this._posCount--, 0 === this._posCount && (this.iteratePath = false), this.internalPlacement;
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementInsidePolygon.js
function h6(t12) {
  return void 0 !== t12.rings;
}
var e10 = class {
  static local() {
    return null === e10.instance && (e10.instance = new e10()), e10.instance;
  }
  execute(t12, s12, i11, h8) {
    return new n13(t12, s12, i11, h8);
  }
};
e10.instance = null;
var n13 = class {
  constructor(e15, n17, _4, r19) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    if (this._xMin = 0, this._xMax = 0, this._yMin = 0, this._yMax = 0, this._currentX = 0, this._currentY = 0, this._stepX = Math.abs((_a = n17.stepX) != null ? _a : 16) * _4, this._stepY = Math.abs((_b = n17.stepY) != null ? _b : 16) * _4, 0 !== this._stepX && 0 !== this._stepY && e15 && h6(e15) && e15.rings) {
      if (this._gridType = (_c = n17.gridType) != null ? _c : Y.Fixed, this._gridType === Y.Random) {
        const s12 = (_d = n17.seed) != null ? _d : 13, i11 = 1;
        this._randomLCG = new t2(s12 * i11), this._randomness = ((_e = n17.randomness) != null ? _e : 100) / 100, this._gridAngle = 0, this._shiftOddRows = false, this._cosAngle = 1, this._sinAngle = 0, this._offsetX = 0, this._offsetY = 0;
      } else {
        if (this._randomness = 0, this._gridAngle = (_f = n17.gridAngle) != null ? _f : 0, this._shiftOddRows = (_g = n17.shiftOddRows) != null ? _g : false, this._offsetX = ((_h = n17.offsetX) != null ? _h : 0) * _4, this._offsetY = ((_i = n17.offsetY) != null ? _i : 0) * _4, this._cosAngle = Math.cos(this._gridAngle / 180 * Math.PI), this._sinAngle = -Math.sin(this._gridAngle / 180 * Math.PI), this._stepX)
          if (this._offsetX < 0)
            for (; this._offsetX < -0.5 * this._stepX; )
              this._offsetX += this._stepX;
          else
            for (; this._offsetX >= 0.5 * this._stepX; )
              this._offsetX -= this._stepX;
        if (this._stepY)
          if (this._offsetY < 0)
            for (; this._offsetY < -0.5 * this._stepY; )
              this._offsetY += this._stepY;
          else
            for (; this._offsetY >= 0.5 * this._stepY; )
              this._offsetY -= this._stepY;
      }
      this._graphicOriginX = 0, this._graphicOriginY = 0, this._internalPlacement = new t7(), this._calculateMinMax(e15), this._geometry = e15;
    }
  }
  next() {
    return this._geometry ? this._nextInside() : null;
  }
  _calculateMinMax(t12) {
    let s12, i11, h8, e15, n17, _4, r19, o12;
    this._xMin = 0, this._xMax = 0, this._yMin = 0, this._yMax = 0, n17 = _4 = Number.MAX_VALUE, r19 = o12 = -Number.MAX_VALUE;
    for (const a15 of t12.rings) {
      const t13 = a15 ? a15.length : 0;
      for (let f9 = 0; f9 < t13; ++f9)
        s12 = a15[f9][0] - this._graphicOriginX - this._offsetX, i11 = a15[f9][1] - this._graphicOriginY - this._offsetY, h8 = this._cosAngle * s12 - this._sinAngle * i11, e15 = this._sinAngle * s12 + this._cosAngle * i11, n17 = Math.min(n17, h8), r19 = Math.max(r19, h8), _4 = Math.min(_4, e15), o12 = Math.max(o12, e15);
    }
    n17 += this._graphicOriginX, r19 += this._graphicOriginX, _4 += this._graphicOriginY, o12 += this._graphicOriginY, this._xMin = Math.round(n17 / this._stepX), this._xMax = Math.round(r19 / this._stepX), this._yMin = Math.round(_4 / this._stepY), this._yMax = Math.round(o12 / this._stepY), this._currentX = this._xMax + 1, this._currentY = this._yMin - 1;
  }
  _nextInside() {
    for (; ; ) {
      if (this._currentX > this._xMax) {
        if (this._currentY++, this._currentY > this._yMax)
          return null;
        this._currentX = this._xMin, this._shiftOddRows && this._currentY % 2 && this._currentX--;
      }
      let t12 = this._currentX * this._stepX + this._offsetX;
      this._shiftOddRows && this._currentY % 2 && (t12 += 0.5 * this._stepX);
      const s12 = this._currentY * this._stepY + this._offsetY;
      let h8, e15;
      return this._currentX++, this._gridType === Y.Random ? (h8 = this._graphicOriginX + t12 + this._stepX * this._randomness * (0.5 - this._randomLCG.getFloat()) * 2 / 3, e15 = this._graphicOriginY + s12 + this._stepY * this._randomness * (0.5 - this._randomLCG.getFloat()) * 2 / 3) : (h8 = this._graphicOriginX + this._cosAngle * t12 + this._sinAngle * s12, e15 = this._graphicOriginY - this._sinAngle * t12 + this._cosAngle * s12), this._internalPlacement.setTranslate(h8, e15), this._internalPlacement;
    }
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementOnLine.js
var r15 = 1e-3;
var l8 = class {
  static local() {
    return null === l8.instance && (l8.instance = new l8()), l8.instance;
  }
  execute(e15, t12, n17, i11) {
    return new o9(e15, t12, n17);
  }
};
l8.instance = null;
var o9 = class extends G2 {
  constructor(e15, t12, n17) {
    super(e15, true, true), this._curveHelper = new n7(), this._angleToLine = void 0 === t12.angleToLine || t12.angleToLine, this._offset = void 0 !== t12.offset ? t12.offset * n17 : 0, this._relativeTo = t12.relativeTo, this._position = void 0 !== t12.startPointOffset ? t12.startPointOffset * n17 : 0, this._epsilon = r15 * n17;
  }
  processPath(e15) {
    const i11 = this._position;
    if (this._relativeTo === Z.SegmentMidpoint) {
      for (this.iteratePath || (this._segmentCount = e15.length, this._curSegment = 1, this.iteratePath = true); this._curSegment < this._segmentCount; ) {
        const n17 = this._curSegment;
        this._curSegment++;
        const i12 = e15[n17 - 1], s12 = e15[n17], r20 = this._curveHelper.calculateLength(i12, s12);
        if (r20 < this._epsilon)
          continue;
        const l12 = 0.5 + this._position / r20, [o12, a15] = this._curveHelper.getAngleCS(i12, s12, l12), h8 = C3(i12, s12, l12);
        return this.internalPlacement.setTranslate(h8[0] - this._offset * a15, h8[1] + this._offset * o12), this._angleToLine && this.internalPlacement.setRotateCS(o12, a15), this.internalPlacement;
      }
      return this.iteratePath = false, null;
    }
    this._relativeTo === Z.LineEnd && d2(e15);
    const r19 = this.onLine(e15, i11);
    return this._relativeTo === Z.LineEnd && d2(e15), r19;
  }
  onLine(e15, n17) {
    let i11, r19 = false;
    switch (this._relativeTo) {
      case Z.LineMiddle:
      default:
        i11 = this._curveHelper.calculatePathLength(e15) / 2 + n17;
        break;
      case Z.LineBeginning:
        i11 = n17;
        break;
      case Z.LineEnd:
        i11 = n17, r19 = true;
    }
    const l12 = e15.length;
    let o12, a15 = 0, h8 = e15[0];
    for (let s12 = 1; s12 < l12; ++s12) {
      o12 = h8, h8 = e15[s12];
      const n18 = this._curveHelper.calculateLength(o12, h8);
      if (a15 + n18 > i11) {
        const e16 = (i11 - a15) / n18, [s13, l13] = this._curveHelper.getAngleCS(o12, h8, e16), c11 = C3(o12, h8, e16), u14 = r19 ? -this._offset : this._offset;
        return this.internalPlacement.setTranslate(c11[0] - u14 * l13, c11[1] + u14 * s13), this._angleToLine && (r19 ? this.internalPlacement.setRotateCS(-s13, -l13) : this.internalPlacement.setRotateCS(s13, l13)), this.internalPlacement;
      }
      a15 += n18;
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementOnVertices.js
var n14 = class {
  static local() {
    return null === n14.instance && (n14.instance = new n14()), n14.instance;
  }
  execute(t12, s12, e15, i11) {
    return new a11(t12, s12, e15);
  }
};
n14.instance = null;
var r16 = 1e-15;
var a11 = class extends G2 {
  constructor(t12, s12, e15) {
    super(t12, true, true), this._curveHelper = new n7(), this._angleToLine = void 0 === s12.angleToLine || s12.angleToLine, this._offset = void 0 !== s12.offset ? s12.offset * e15 : 0, this._endPoints = void 0 === s12.placeOnEndPoints || s12.placeOnEndPoints, this._controlPoints = void 0 === s12.placeOnControlPoints || s12.placeOnControlPoints, this._regularVertices = void 0 === s12.placeOnRegularVertices || s12.placeOnRegularVertices, this._tags = [], this._tagIterator = 0;
  }
  processPath(t12) {
    if (this.iteratePath || (this._preparePath(t12), this.iteratePath = true), this._tagIterator >= this._tags.length)
      return this._tags.length = 0, this._tagIterator = 0, this.iteratePath = false, null;
    const s12 = this._tags[this._tagIterator];
    this._angleToLine && this.internalPlacement.setRotate(s12[2]);
    let e15 = s12[0], i11 = s12[1];
    if (0 !== this._offset) {
      const t13 = Math.cos(s12[2]), n17 = Math.sin(s12[2]);
      e15 -= this._offset * n17, i11 += this._offset * t13;
    }
    return this.internalPlacement.setTranslate(e15, i11), this._tagIterator++, this.internalPlacement;
  }
  _preparePath(t12) {
    this._tags.length = 0, this._tagIterator = 0;
    const i11 = y4(t12), n17 = t12.length - 1;
    let r19, a15, h8 = 0, l12 = 0, _4 = 0, c11 = 0, g8 = 0;
    for (; h8 < n17; ) {
      h8++, r19 = t12[h8 - 1], a15 = t12[h8];
      const s12 = I2(r19), u14 = I2(a15);
      (this._angleToLine || 0 !== this._offset) && (c11 = this._curveHelper.getAngle(r19, a15, 0)), 1 === h8 ? i11 ? (l12 = c11, _4 = s12) : (this._endPoints || this._controlPoints && 1 === s12) && this._tags.push([r19[0], r19[1], c11]) : 1 === s12 ? this._controlPoints && this._tags.push([r19[0], r19[1], o10(g8, c11)]) : this._regularVertices && this._tags.push([r19[0], r19[1], o10(g8, c11)]), (this._angleToLine || 0 !== this._offset) && (g8 = this._curveHelper.getAngle(r19, a15, 1)), h8 === n17 && (i11 ? 1 === u14 || 1 === _4 ? this._controlPoints && this._tags.push([a15[0], a15[1], o10(g8, l12)]) : this._regularVertices && this._tags.push([a15[0], a15[1], o10(g8, l12)]) : (this._endPoints || this._controlPoints && 1 === u14) && this._tags.push([a15[0], a15[1], g8]));
    }
    this._tagIterator = 0;
  }
};
function o10(t12, s12) {
  const e15 = Math.PI;
  for (; Math.abs(s12 - t12) > e15 + 2 * r16; )
    s12 - t12 > e15 ? s12 -= 2 * e15 : s12 += 2 * e15;
  return (t12 + s12) / 2;
}

// node_modules/@arcgis/core/core/PriorityQueue.js
var t8 = class {
  constructor(t12 = e11) {
    this._data = [], this._compare = t12;
  }
  get size() {
    return this._data.length;
  }
  enqueue(t12) {
    if (null == t12)
      return;
    const { _data: e15, _compare: n17 } = this;
    e15.push(t12);
    let l12 = e15.length - 1 >>> 0;
    const r19 = e15[l12];
    for (; l12 > 0; ) {
      const t13 = l12 - 1 >> 1, s12 = e15[t13];
      if (!(n17(s12, r19) <= 0))
        break;
      e15[t13] = r19, e15[l12] = s12, l12 = t13;
    }
  }
  dequeue() {
    const { _data: t12, _compare: e15 } = this, n17 = t12[0], l12 = t12.pop();
    if (0 === t12.length)
      return n17;
    t12[0] = l12;
    let r19 = 0;
    const s12 = t12.length, u14 = t12[0];
    let a15, o12, c11 = null;
    for (; ; ) {
      const n18 = 2 * r19 + 1, l13 = 2 * r19 + 2;
      if (c11 = null, n18 < s12 && (a15 = t12[n18], e15(a15, u14) > 0 && (c11 = n18)), l13 < s12 && (o12 = t12[l13], (null === c11 && e15(o12, u14) <= 0 || null !== c11 && e15(o12, a15) <= 0) && (c11 = l13)), null === c11)
        break;
      t12[r19] = t12[c11], t12[c11] = u14, r19 = c11;
    }
    return n17;
  }
};
var e11 = (t12, e15) => t12 < e15 ? -1 : t12 > e15 ? 1 : 0;

// node_modules/@arcgis/core/geometry/support/labelPoint.js
var N = 100 * 222045e-21;
function u11(t12) {
  const { rings: n17 } = t12;
  if (!n17 || 0 === n17.length)
    return null;
  const s12 = c2(u4(), t12);
  if (!s12)
    return null;
  const c11 = 4 * (Math.abs(s12[0]) + Math.abs(s12[2]) + Math.abs(s12[1]) + Math.abs(s12[3]) + 1) * N;
  let l12 = 0, f9 = 0;
  for (let e15 = 0; e15 < n17.length; e15++) {
    const t13 = M(n17[e15]);
    t13 > f9 && (f9 = t13, l12 = e15);
  }
  if (Math.abs(f9) <= 2 * c11 * c11) {
    const t13 = s3(u4(), n17[l12]);
    return [(t13[0] + t13[2]) / 2, (t13[1] + t13[3]) / 2];
  }
  const u14 = u(n17[l12], false, u4());
  if (null === u14)
    return null;
  if (1 === n17.length && n17[0].length < 4)
    return u14;
  const d4 = [[NaN, NaN], [NaN, NaN], [NaN, NaN], [NaN, NaN]], x5 = [NaN, NaN, NaN, NaN], M4 = [NaN, NaN, NaN, NaN];
  let b5 = false, w6 = m6(u14, t12, true);
  0 === w6.distance && (b5 = true, d4[0][0] = u14[0], d4[0][1] = u14[1], w6 = m6(u14, t12, false)), x5[0] = w6.distance, M4[0] = 0;
  const y7 = [NaN, NaN];
  let C5 = false, k4 = 0.25, P5 = -1;
  const T4 = s3(u4(), n17[l12]);
  let z3 = NaN;
  do {
    if (z3 = NaN, d4[1] = g5(t12, p4(T4[0], T4[2], k4), c11, s12), isNaN(d4[1][0]) || isNaN(d4[1][1]) || (w6 = m6(d4[1], t12, false), z3 = w6.distance), !isNaN(z3) && z3 > c11 && h7(d4[1], t12))
      C5 = true, x5[1] = z3, M4[1] = j3(d4[1], u14);
    else if (!isNaN(z3) && z3 > P5 && (P5 = z3, y7[0] = d4[1][0], y7[1] = d4[1][1]), k4 -= 0.01, k4 < 0.1) {
      if (!(P5 >= 0))
        break;
      C5 = true, x5[1] = P5, d4[1][0] = y7[0], d4[1][1] = y7[1], M4[1] = j3(d4[1], u14);
    }
  } while (!C5);
  C5 = false, k4 = 0.5, P5 = -1;
  let D2 = 0.01, S2 = 1;
  do {
    if (z3 = NaN, d4[2] = g5(t12, p4(T4[0], T4[2], k4), c11, s12), isNaN(d4[2][0]) || isNaN(d4[2][1]) || (w6 = m6(d4[2], t12, false), z3 = w6.distance), !isNaN(z3) && z3 > c11 && h7(d4[2], t12))
      C5 = true, x5[2] = z3, M4[2] = j3(d4[2], u14);
    else if (!isNaN(z3) && z3 > P5)
      P5 = z3, y7[0] = d4[2][0], y7[1] = d4[2][1];
    else if (z3 > P5 && (P5 = z3, y7[0] = d4[2][0], y7[1] = d4[2][1]), k4 = 0.5 + D2 * S2, D2 += 0.01, S2 *= -1, k4 < 0.3 || k4 > 0.7) {
      if (!(P5 >= 0))
        break;
      C5 = true, x5[2] = P5, d4[2][0] = y7[0], d4[2][1] = y7[1], M4[2] = j3(d4[2], u14);
    }
  } while (!C5);
  C5 = false, k4 = 0.75, P5 = -1;
  do {
    if (z3 = NaN, d4[3] = g5(t12, p4(T4[0], T4[2], k4), c11, s12), isNaN(d4[3][0]) || isNaN(d4[3][1]) || (w6 = m6(d4[3], t12, false), z3 = w6.distance), !isNaN(z3) && z3 > c11 && h7(d4[3], t12))
      C5 = true, x5[3] = z3, M4[3] = j3(d4[3], u14);
    else if (z3 > P5 && (P5 = z3, y7[0] = d4[3][0], y7[1] = d4[3][1]), k4 += 0.01, k4 > 0.9) {
      if (!(P5 >= 0))
        break;
      C5 = true, x5[3] = P5, d4[3][0] = y7[0], d4[3][1] = y7[1], M4[3] = j3(d4[3], u14);
    }
  } while (!C5);
  const B4 = [0, 1, 2, 3], Q4 = b5 ? 0 : 1;
  let R3;
  for (let e15 = Q4; e15 < 4; e15++)
    for (let t13 = Q4; t13 < 3; t13++) {
      const n18 = M4[t13], e16 = M4[t13 + 1];
      q(n18, e16) > 0 && (R3 = B4[t13], B4[t13] = B4[t13 + 1], B4[t13 + 1] = R3, M4[t13] = e16, M4[t13 + 1] = n18);
    }
  let U5 = Q4, v2 = 0, A4 = 0;
  for (let e15 = Q4; e15 < 4; e15++) {
    switch (e15) {
      case 0:
        A4 = 2 * x5[B4[e15]];
        break;
      case 1:
        A4 = 1.66666666 * x5[B4[e15]];
        break;
      case 2:
        A4 = 1.33333333 * x5[B4[e15]];
        break;
      case 3:
        A4 = x5[B4[e15]];
    }
    A4 > v2 && (v2 = A4, U5 = B4[e15]);
  }
  return d4[U5];
}
function h7(t12, n17) {
  const { rings: e15 } = n17;
  let i11 = 0;
  for (const r19 of e15) {
    const n18 = r19.length;
    for (let e16 = 1; e16 < n18; ++e16) {
      const n19 = r19[e16 - 1], o12 = r19[e16];
      if (n19[1] > t12[1] == o12[1] > t12[1])
        continue;
      (o12[0] - n19[0]) * (t12[1] - n19[1]) - (o12[1] - n19[1]) * (t12[0] - n19[0]) > 0 ? i11++ : i11--;
    }
  }
  return 0 !== i11;
}
function m6(t12, n17, e15) {
  if (e15 && h7(t12, n17))
    return { coord: t12, distance: 0 };
  let i11 = 1 / 0, r19 = 0, o12 = 0;
  const s12 = [0, 0], { rings: a15 } = n17;
  for (const l12 of a15)
    if (!(l12.length < 2))
      for (let n18 = 0; n18 < l12.length - 1; n18++) {
        i(s12, t12, l12, n18);
        const e16 = j3(t12, s12);
        e16 < i11 && (i11 = e16, r19 = s12[0], o12 = s12[1]);
      }
  return { coord: [r19, o12], distance: Math.sqrt(i11) };
}
function g5(t12, n17, i11, r19) {
  const o12 = [n17, 0];
  let s12 = 1 / 0, a15 = 1 / 0, c11 = false, l12 = false;
  const N3 = [[n17, r19[1] - 1], [n17, r19[3] + 1]], u14 = [0, 0], h8 = [0, 0], m8 = [0, 0], g8 = [[0, 0], [0, 0]], x5 = u4(), { rings: M4 } = t12;
  for (const e15 of M4)
    if (!(e15.length < 2))
      for (let t13 = 1; t13 < e15.length; t13++) {
        if (g8[0][0] = e15[t13 - 1][0], g8[0][1] = e15[t13 - 1][1], g8[1][0] = e15[t13][0], g8[1][1] = e15[t13][1], null === d3(x5, g8))
          continue;
        if (h8[0] = N3[0][0], h8[1] = N3[0][1], m8[0] = N3[1][0], m8[1] = N3[1][1], 0 === y5(x5, h8, m8))
          continue;
        if (!G(N3[0], N3[1], g8[0], g8[1], u14))
          continue;
        const n18 = u14[1];
        s12 > a15 ? n18 < s12 && (s12 = n18, c11 = true) : n18 < a15 && (a15 = n18, l12 = true);
      }
  return c11 && l12 ? o12[1] = (s12 + a15) / 2 : o12[0] = o12[1] = NaN, o12;
}
function d3(t12, n17) {
  if (n17.length < 2)
    return null;
  t12 || (t12 = u4());
  const [i11, r19] = n17[0], [o12, s12] = n17[1];
  return t12[0] = Math.min(i11, o12), t12[1] = Math.min(r19, s12), t12[2] = Math.max(i11, o12), t12[3] = Math.max(r19, s12), t12;
}
var x3 = 1;
var M2 = 4;
var b3 = 3;
var w4 = 12;
function y5(t12, n17, e15) {
  let i11 = C4(n17, t12), r19 = C4(e15, t12);
  const o12 = t12[0], s12 = t12[1], a15 = t12[2], c11 = t12[3];
  if (i11 & r19)
    return 0;
  if (!(i11 | r19))
    return 4;
  const l12 = (i11 ? 1 : 0) | (r19 ? 2 : 0);
  do {
    const l13 = e15[0] - n17[0], f9 = e15[1] - n17[1];
    if (l13 > f9)
      i11 & b3 ? (i11 & x3 ? (n17[1] += f9 * (o12 - n17[0]) / l13, n17[0] = o12) : (n17[1] += f9 * (a15 - n17[0]) / l13, n17[0] = a15), i11 = C4(n17, t12)) : r19 & b3 ? (r19 & x3 ? (e15[1] += f9 * (o12 - e15[0]) / l13, e15[0] = o12) : (e15[1] += f9 * (a15 - e15[0]) / l13, e15[0] = a15), r19 = C4(e15, t12)) : i11 ? (i11 & M2 ? (n17[0] += l13 * (s12 - n17[1]) / f9, n17[1] = s12) : (n17[0] += l13 * (c11 - n17[1]) / f9, n17[1] = c11), i11 = C4(n17, t12)) : (r19 & M2 ? (e15[0] += l13 * (s12 - e15[1]) / f9, e15[1] = s12) : (e15[0] += l13 * (c11 - e15[1]) / f9, e15[1] = c11), r19 = C4(e15, t12));
    else if (i11 & w4 ? (i11 & M2 ? (n17[0] += l13 * (s12 - n17[1]) / f9, n17[1] = s12) : (n17[0] += l13 * (c11 - n17[1]) / f9, n17[1] = c11), i11 = C4(n17, t12)) : r19 & w4 ? (r19 & M2 ? (e15[0] += l13 * (s12 - e15[1]) / f9, e15[1] = s12) : (e15[0] += l13 * (c11 - e15[1]) / f9, e15[1] = c11), r19 = C4(e15, t12)) : i11 ? (i11 & x3 ? (n17[1] += f9 * (o12 - n17[0]) / l13, n17[0] = o12) : (n17[1] += f9 * (a15 - n17[0]) / l13, n17[0] = a15), i11 = C4(n17, t12)) : (r19 & x3 ? (e15[1] += f9 * (o12 - e15[0]) / l13, e15[0] = o12) : (e15[1] += f9 * (a15 - e15[0]) / l13, e15[0] = a15), r19 = C4(e15, t12)), i11 & r19)
      return 0;
  } while (i11 | r19);
  return l12;
}
function C4(t12, n17) {
  return (t12[0] < n17[0] ? 1 : 0) | (t12[0] > n17[2] ? 1 : 0) << 1 | (t12[1] < n17[1] ? 1 : 0) << 2 | (t12[1] > n17[3] ? 1 : 0) << 3;
}
function p4(t12, n17, e15) {
  return t12 + (n17 - t12) * e15;
}
function j3(t12, n17) {
  return (t12[0] - n17[0]) * (t12[0] - n17[0]) + (t12[1] - n17[1]) * (t12[1] - n17[1]);
}
function q(t12, n17) {
  if (t12 < n17)
    return -1;
  if (t12 > n17)
    return 1;
  if (t12 === n17)
    return 0;
  const e15 = isNaN(t12), i11 = isNaN(n17);
  return e15 < i11 ? -1 : e15 > i11 ? 1 : 0;
}
var k3 = class {
  constructor(t12, n17, e15, i11) {
    this.x = t12, this.y = n17, this.cellSize = e15, this.distancefromCellCenter = s2(t12, n17, i11), this.maxDistanceToPolygon = this.distancefromCellCenter + this.cellSize * Math.SQRT2;
  }
};
var P4 = 1;
var T = 100;
function z2(i11) {
  if (!i11 || !i11.rings || 0 === i11.rings.length)
    return null;
  const o12 = s3(u4(), i11.rings[0]);
  if (!o12)
    return null;
  const a15 = o12[2] - o12[0], c11 = o12[3] - o12[1];
  if (0 === a15 || 0 === c11)
    return [o12[0] + a15 / 2, o12[1] + c11 / 2];
  const l12 = Math.max(Math.min(a15, c11) / T, P4), f9 = new t8((t12, n17) => n17.maxDistanceToPolygon - t12.maxDistanceToPolygon), N3 = Math.min(a15, c11);
  let u14 = N3 / 2, h8 = 0, m8 = 0;
  for (h8 = o12[0]; h8 < o12[2]; h8 += N3)
    for (m8 = o12[1]; m8 < o12[3]; m8 += N3)
      f9.enqueue(new k3(h8 + u14, m8 + u14, u14, i11));
  const g8 = o(i11.rings, false);
  if (null === g8)
    return null;
  let d4, x5 = new k3(g8[0], g8[1], 0, i11);
  for (; f9.size > 0; )
    d4 = e(f9.dequeue()), d4.distancefromCellCenter > x5.distancefromCellCenter && (x5 = d4), d4.maxDistanceToPolygon - x5.distancefromCellCenter <= l12 || (u14 = d4.cellSize / 2, f9.enqueue(new k3(d4.x - u14, d4.y - u14, u14, i11)), f9.enqueue(new k3(d4.x + u14, d4.y - u14, u14, i11)), f9.enqueue(new k3(d4.x - u14, d4.y + u14, u14, i11)), f9.enqueue(new k3(d4.x + u14, d4.y + u14, u14, i11)));
  return [x5.x, x5.y];
}

// node_modules/@arcgis/core/symbols/cim/placements/PlacementPolygonCenter.js
function l9(t12) {
  return void 0 !== t12.rings;
}
var a12 = class {
  static local() {
    return null === a12.instance && (a12.instance = new a12()), a12.instance;
  }
  execute(t12, e15, s12, n17) {
    return new f6(t12, e15, s12);
  }
};
a12.instance = null;
var f6 = class {
  constructor(t12, e15, s12) {
    this._geometry = t12, this._offsetX = void 0 !== e15.offsetX ? e15.offsetX * s12 : 0, this._offsetY = void 0 !== e15.offsetY ? e15.offsetY * s12 : 0, this._method = void 0 !== e15.method ? e15.method : K.OnPolygon, this._internalPlacement = new t7();
  }
  next() {
    const t12 = this._geometry;
    return this._geometry = null, t12 && l9(t12) ? this._polygonCenter(t12) : null;
  }
  _polygonCenter(r19) {
    let l12 = false;
    switch (this._method) {
      case K.CenterOfMass:
        {
          const t12 = g(r19);
          t12 && (this._internalPlacement.setTranslate(t12[0] + this._offsetX, t12[1] + this._offsetY), l12 = true);
        }
        break;
      case K.BoundingBoxCenter:
        {
          const s12 = u4();
          c2(s12, r19), s12 && (this._internalPlacement.setTranslate((s12[2] + s12[0]) / 2 + this._offsetX, (s12[3] + s12[1]) / 2 + this._offsetY), l12 = true);
        }
        break;
      case K.OnPolygon:
      default: {
        let t12;
        t12 = has("polylabel-placement-enabled") ? z2(r19) : u11(r19), null !== t12 && (this._internalPlacement.setTranslate(t12[0] + this._offsetX, t12[1] + this._offsetY), l12 = true);
      }
    }
    return l12 ? this._internalPlacement : null;
  }
};

// node_modules/@arcgis/core/symbols/cim/CIMOperators.js
function A3(p6) {
  if (!p6)
    return null;
  switch (p6.type) {
    case "CIMGeometricEffectAddControlPoints":
      return o7.local();
    case "CIMGeometricEffectArrow":
      return h3.local();
    case "CIMGeometricEffectBuffer":
      return f4.local();
    case "CIMGeometricEffectControlMeasureLine":
      return _.local();
    case "CIMGeometricEffectCut":
      return u9.local();
    case "CIMGeometricEffectDashes":
      return r8.local();
    case "CIMGeometricEffectDonut":
      return r9.local();
    case "CIMGeometricEffectJog":
      return s9.local();
    case "CIMGeometricEffectMove":
      return n10.local();
    case "CIMGeometricEffectOffset":
      return r11.local();
    case "CIMGeometricEffectReverse":
      return s10.local();
    case "CIMGeometricEffectRotate":
      return u10.local();
    case "CIMGeometricEffectScale":
      return c8.local();
    case "CIMGeometricEffectWave":
      return a8.local();
  }
  return null;
}
function g6(e15) {
  if (!e15)
    return null;
  switch (e15.type) {
    case "CIMMarkerPlacementAlongLineSameSize":
      return a9.local();
    case "CIMMarkerPlacementAtExtremities":
      return n12.local();
    case "CIMMarkerPlacementAtRatioPositions":
      return a10.local();
    case "CIMMarkerPlacementInsidePolygon":
      return e10.local();
    case "CIMMarkerPlacementOnLine":
      return l8.local();
    case "CIMMarkerPlacementOnVertices":
      return n14.local();
    case "CIMMarkerPlacementPolygonCenter":
      return a12.local();
  }
  return null;
}

// node_modules/@arcgis/core/symbols/cim/imageUtils.js
function t9(t12) {
  const e15 = t12.getFrame(0);
  if (e15 instanceof HTMLImageElement || e15 instanceof HTMLCanvasElement)
    return e15;
  const n17 = document.createElement("canvas");
  n17.width = t12.width, n17.height = t12.height;
  const a15 = n17.getContext("2d");
  return e15 instanceof ImageData ? a15.putImageData(e15, 0, 0) : a15.drawImage(e15, 0, 0), n17;
}

// node_modules/@arcgis/core/symbols/cim/Rect.js
var t10 = class {
  constructor(t12 = 0, h8 = 0, i11 = 0, s12 = 0) {
    this.x = t12, this.y = h8, this.width = i11, this.height = s12;
  }
  get isEmpty() {
    return this.width <= 0 || this.height <= 0;
  }
  union(t12) {
    this.x = Math.min(this.x, t12.x), this.y = Math.min(this.y, t12.y), this.width = Math.max(this.width, t12.width), this.height = Math.max(this.height, t12.height);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/collisions/BoundingBox.js
var i9 = class {
  constructor(i11, e15, s12, r19) {
    this.center = t4(i11, e15), this.centerT = n(), this.halfWidth = s12 / 2, this.halfHeight = r19 / 2, this.width = s12, this.height = r19;
  }
  get x() {
    return this.center[0];
  }
  get y() {
    return this.center[1];
  }
  get blX() {
    return this.center[0] + this.halfWidth;
  }
  get blY() {
    return this.center[1] + this.halfHeight;
  }
  get trX() {
    return this.center[0] - this.halfWidth;
  }
  get trY() {
    return this.center[1] - this.halfHeight;
  }
  get xmin() {
    return this.x - this.halfWidth;
  }
  get xmax() {
    return this.x + this.halfWidth;
  }
  get ymin() {
    return this.y - this.halfHeight;
  }
  get ymax() {
    return this.y + this.halfHeight;
  }
  set x(t12) {
    this.center[0] = t12;
  }
  set y(t12) {
    this.center[1] = t12;
  }
  clone() {
    return new i9(this.x, this.y, this.width, this.height);
  }
  serialize(t12) {
    return t12.writeF32(this.center[0]), t12.writeF32(this.center[1]), t12.push(this.width), t12.push(this.height), t12;
  }
  findCollisionDelta(t12, h8 = 4) {
    const i11 = Math.abs(t12.centerT[0] - this.centerT[0]), e15 = Math.abs(t12.centerT[1] - this.centerT[1]), s12 = (t12.halfWidth + this.halfWidth + h8) / i11, r19 = (t12.halfHeight + this.halfHeight + h8) / e15, n17 = Math.min(s12, r19);
    return Math.log2(n17);
  }
  extend(t12) {
    const h8 = Math.min(this.xmin, t12.xmin), i11 = Math.min(this.ymin, t12.ymin), e15 = Math.max(this.xmax, t12.xmax) - h8, s12 = Math.max(this.ymax, t12.ymax) - i11, r19 = h8 + e15 / 2, n17 = i11 + s12 / 2;
    this.width = e15, this.height = s12, this.halfWidth = e15 / 2, this.halfHeight = s12 / 2, this.x = r19, this.y = n17;
  }
  static deserialize(t12) {
    const h8 = t12.readF32(), e15 = t12.readF32(), s12 = t12.readInt32(), r19 = t12.readInt32();
    return new i9(h8, e15, s12, r19);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/shapingUtils.js
var l10 = 26;
var u12 = 4;
var g7 = l10 + u12;
var _2 = l10 - 6;
var p5 = 3;
var x4 = 8;
var w5 = Math.PI / 180;
var y6 = class {
  constructor(t12, s12, e15, i11) {
    this._rotationT = n4(), this._xBounds = 0, this._yBounds = 0, this.minZoom = 0, this.maxZoom = 255, this._bounds = null;
    const o12 = e15.rect, h8 = new Float32Array(8);
    t12 *= i11, s12 *= i11;
    const r19 = e15.code ? o12.width * i11 : e15.metrics.width, a15 = e15.code ? o12.height * i11 : e15.metrics.height;
    h8[0] = t12, h8[1] = s12, h8[2] = t12 + r19, h8[3] = s12, h8[4] = t12, h8[5] = s12 + a15, h8[6] = t12 + r19, h8[7] = s12 + a15, this._data = h8, this._setTextureCoords(o12), this._scale = i11, this._mosaic = e15, this.x = t12, this.y = s12, this.maxOffset = Math.max(t12 + r19, s12 + a15);
  }
  get width() {
    return this._mosaic.metrics.width * this._scale;
  }
  get mosaic() {
    return this._mosaic;
  }
  set angle(s12) {
    this._angle = s12, h2(this._rotationT, -s12), this._setOffsets(this._data);
  }
  get angle() {
    return this._angle;
  }
  get xTopLeft() {
    return this._data[0];
  }
  get yTopLeft() {
    return this._data[1];
  }
  get xBottomRight() {
    return this._data[6];
  }
  get yBottomRight() {
    return this._data[7];
  }
  get texcoords() {
    return this._texcoords;
  }
  get textureBinding() {
    return this._mosaic.textureBinding;
  }
  get offsets() {
    return this._offsets || this._setOffsets(this._data), this._offsets;
  }
  get char() {
    return String.fromCharCode(this._mosaic.code);
  }
  get code() {
    return this._mosaic.code;
  }
  get bounds() {
    if (!this._bounds) {
      const { height: t12, width: e15 } = this._mosaic.metrics, i11 = e15 * this._scale, h8 = Math.abs(t12) * this._scale, r19 = new Float32Array(8);
      r19[0] = this.x, r19[1] = this.y, r19[2] = this.x + i11, r19[3] = this.y, r19[4] = this.x, r19[5] = this.y + h8, r19[6] = this.x + i11, r19[7] = this.y + h8;
      const a15 = o5(n4(), this._rotationT, this._transform);
      a2(r19, r19, a15);
      let c11 = 1 / 0, f9 = 1 / 0, d4 = 0, l12 = 0;
      for (let s12 = 0; s12 < 4; s12++) {
        const t13 = r19[2 * s12], e16 = r19[2 * s12 + 1];
        c11 = Math.min(c11, t13), f9 = Math.min(f9, e16), d4 = Math.max(d4, t13), l12 = Math.max(l12, e16);
      }
      const u14 = d4 - c11, g8 = l12 - f9, _4 = c11 + u14 / 2, p6 = f9 + g8 / 2;
      this._bounds = new i9(_4, p6, u14, g8);
    }
    return this._bounds;
  }
  setTransform(t12) {
    this._transform = t12, this._offsets = null;
  }
  _setOffsets(t12) {
    this._offsets || (this._offsets = { upperLeft: 0, upperRight: 0, lowerLeft: 0, lowerRight: 0 });
    const e15 = this._offsets, i11 = new Float32Array(8), h8 = o5(n4(), this._rotationT, this._transform);
    a2(i11, t12, h8), e15.upperLeft = w3(i11[0] * x4, i11[1] * x4), e15.upperRight = w3(i11[2] * x4, i11[3] * x4), e15.lowerLeft = w3(i11[4] * x4, i11[5] * x4), e15.lowerRight = w3(i11[6] * x4, i11[7] * x4);
  }
  _setTextureCoords({ x: t12, y: s12, width: e15, height: i11 }) {
    this._texcoords = { upperLeft: w3(t12, s12), upperRight: w3(t12 + e15, s12), lowerLeft: w3(t12, s12 + i11), lowerRight: w3(t12 + e15, s12 + i11) };
  }
};
var M3 = (t12, s12) => ({ code: 0, page: 0, sdf: true, rect: new t6(0, 0, 11, 8), textureBinding: s12, metrics: { advance: 0, height: 4, width: t12, left: 0, top: 0 } });
var T2 = class {
  constructor(t12, s12, e15) {
    this._rotation = 0, this._decorate(t12, s12, e15), this.glyphs = t12, this.bounds = this._createBounds(t12), this.isMultiline = s12.length > 1, this._hasRotation = 0 !== e15.angle, this._transform = this._createGlyphTransform(this.bounds, e15);
    for (const i11 of t12)
      i11.setTransform(this._transform);
  }
  setRotation(e15) {
    if (0 === e15 && 0 === this._rotation)
      return;
    this._rotation = e15;
    const i11 = this._transform, o12 = h2(n4(), e15);
    o5(i11, o12, i11);
    for (const t12 of this.glyphs)
      t12.setTransform(this._transform);
  }
  _decorate(t12, s12, e15) {
    if (!e15.decoration || "none" === e15.decoration || !t12.length)
      return;
    const i11 = e15.scale, n17 = "underline" === e15.decoration ? g7 : _2, o12 = t12[0].textureBinding;
    for (const h8 of s12) {
      const s13 = h8.startX * i11, e16 = h8.startY * i11, r19 = (h8.width + h8.glyphWidthEnd) * i11;
      t12.push(new y6(s13, e16 + n17 * i11, M3(r19, o12), 1));
    }
  }
  get boundsT() {
    const t12 = this.bounds, s12 = r3(n(), t12.x, t12.y);
    if (z(s12, s12, this._transform), this._hasRotation) {
      const e15 = Math.max(t12.width, t12.height);
      return new i9(s12[0], s12[1], e15, e15);
    }
    return new i9(s12[0], s12[1], t12.width, t12.height);
  }
  _createBounds(t12) {
    let s12 = 1 / 0, e15 = 1 / 0, i11 = 0, n17 = 0;
    for (const r19 of t12)
      s12 = Math.min(s12, r19.xTopLeft), e15 = Math.min(e15, r19.yTopLeft), i11 = Math.max(i11, r19.xTopLeft + r19.width), n17 = Math.max(n17, r19.yBottomRight);
    const o12 = i11 - s12, h8 = n17 - e15;
    return new i9(s12 + o12 / 2, e15 + h8 / 2, o12, h8);
  }
  _createGlyphTransform(t12, s12) {
    const o12 = w5 * s12.angle, r19 = n4(), c11 = n();
    return i4(r19, r19, r3(c11, s12.xOffset, -s12.yOffset)), s12.isCIM ? e6(r19, r19, o12) : (i4(r19, r19, r3(c11, t12.x, t12.y)), e6(r19, r19, o12), i4(r19, r19, r3(c11, -t12.x, -t12.y))), r19;
  }
};
var B2 = class {
  constructor(t12, s12, e15, i11, n17, o12) {
    this.glyphWidthEnd = 0, this.startX = 0, this.startY = 0, this.start = Math.max(0, Math.min(s12, e15)), this.end = Math.max(0, Math.max(s12, e15)), this.end < t12.length && (this.glyphWidthEnd = t12[this.end].metrics.width), this.width = i11, this.yMin = n17, this.yMax = o12;
  }
};
var b4 = (t12) => 10 === t12;
var R2 = (t12) => 32 === t12;
function L2(t12, s12, e15) {
  const i11 = new Array(), n17 = 1 / e15.scale, o12 = e15.maxLineWidth * n17, h8 = s12 ? t12.length - 1 : 0, r19 = s12 ? -1 : t12.length, a15 = s12 ? -1 : 1;
  let c11 = h8, f9 = 0, d4 = 0, m8 = c11, l12 = m8, u14 = 0, g8 = 1 / 0, _4 = 0;
  for (; c11 !== r19; ) {
    const { code: s13, metrics: e16 } = t12[c11], n18 = Math.abs(e16.top);
    if (b4(s13) || R2(s13) || (g8 = Math.min(g8, n18), _4 = Math.max(_4, n18 + e16.height)), b4(s13))
      c11 !== h8 && (i11.push(new B2(t12, m8, c11 - a15, f9, g8, _4)), g8 = 1 / 0, _4 = 0), f9 = 0, m8 = c11 + a15, l12 = c11 + a15, d4 = 0;
    else if (R2(s13))
      l12 = c11 + a15, d4 = 0, u14 = e16.advance, f9 += e16.advance;
    else if (f9 > o12) {
      if (l12 !== m8) {
        const s14 = l12 - 2 * a15;
        f9 -= u14, i11.push(new B2(t12, m8, s14, f9 - d4, g8, _4)), g8 = 1 / 0, _4 = 0, m8 = l12, f9 = d4;
      } else
        i11.push(new B2(t12, m8, c11 - a15, f9, g8, _4)), g8 = 1 / 0, _4 = 0, m8 = c11, l12 = c11, f9 = 0;
      f9 += e16.advance, d4 += e16.advance;
    } else
      f9 += e16.advance, d4 += e16.advance;
    c11 += a15;
  }
  const p6 = new B2(t12, m8, c11 - a15, f9, g8, _4);
  return p6.start >= 0 && p6.end < t12.length && i11.push(p6), i11;
}
function v(t12, s12) {
  let e15 = 0;
  for (let o12 = 0; o12 < t12.length; o12++) {
    const { width: s13 } = t12[o12];
    e15 = Math.max(s13, e15);
  }
  const i11 = "underline" === s12.decoration ? u12 : 0, n17 = t12[0].yMin;
  return { x: 0, y: n17, height: t12[t12.length - 1].yMax + s12.lineHeight * (t12.length - 1) + i11 - n17, width: e15 };
}
function j4(t12, s12, e15) {
  const i11 = e15.scale, n17 = new Array(), o12 = L2(t12, s12, e15), h8 = v(o12, e15), { vAlign: r19, hAlign: a15 } = e15, f9 = r19 === t5.Baseline ? 1 : 0, d4 = f9 ? 0 : r19 - 1, m8 = (1 - f9) * -h8.y + d4 * (h8.height / 2) + (f9 ? 1 : 0) * -l10;
  for (let c11 = 0; c11 < o12.length; c11++) {
    const { start: s13, end: h9, width: r20 } = o12[c11];
    let f10 = -1 * (a15 + 1) * (r20 / 2) - p5;
    const d5 = c11 * e15.lineHeight + m8 - p5;
    o12[c11].startX = f10, o12[c11].startY = d5;
    for (let e16 = s13; e16 <= h9; e16++) {
      const s14 = t12[e16];
      if (b4(s14.code))
        continue;
      const o13 = new y6(f10 + s14.metrics.left, d5 - s14.metrics.top, s14, i11);
      f10 += s14.metrics.advance, n17.push(o13);
    }
  }
  return new T2(n17, o12, e15);
}

// node_modules/@arcgis/core/symbols/cim/CIMSymbolDrawHelper.js
var E = Math.PI / 180;
var J = 10;
var N2 = s.getLogger("esri.symbols.cim.CIMSymbolDrawHelper");
var O2 = class {
  constructor(t12) {
    this._t = t12;
  }
  static createIdentity() {
    return new O2([1, 0, 0, 0, 1, 0]);
  }
  clone() {
    const t12 = this._t;
    return new O2(t12.slice());
  }
  transform(t12) {
    const e15 = this._t;
    return [e15[0] * t12[0] + e15[1] * t12[1] + e15[2], e15[3] * t12[0] + e15[4] * t12[1] + e15[5]];
  }
  static createScale(t12, e15) {
    return new O2([t12, 0, 0, 0, e15, 0]);
  }
  scale(t12, e15) {
    const r19 = this._t;
    return r19[0] *= t12, r19[1] *= t12, r19[2] *= t12, r19[3] *= e15, r19[4] *= e15, r19[5] *= e15, this;
  }
  scaleRatio() {
    return Math.sqrt(this._t[0] * this._t[0] + this._t[1] * this._t[1]);
  }
  static createTranslate(t12, e15) {
    return new O2([0, 0, t12, 0, 0, e15]);
  }
  translate(t12, e15) {
    const r19 = this._t;
    return r19[2] += t12, r19[5] += e15, this;
  }
  static createRotate(t12) {
    const e15 = Math.cos(t12), r19 = Math.sin(t12);
    return new O2([e15, -r19, 0, r19, e15, 0]);
  }
  rotate(t12) {
    return O2.multiply(this, O2.createRotate(t12), this);
  }
  angle() {
    const t12 = this._t[0], e15 = this._t[3], r19 = Math.sqrt(t12 * t12 + e15 * e15);
    return [t12 / r19, e15 / r19];
  }
  static multiply(t12, e15, r19) {
    const i11 = t12._t, s12 = e15._t, o12 = i11[0] * s12[0] + i11[3] * s12[1], n17 = i11[1] * s12[0] + i11[4] * s12[1], a15 = i11[2] * s12[0] + i11[5] * s12[1] + s12[2], l12 = i11[0] * s12[3] + i11[3] * s12[4], h8 = i11[1] * s12[3] + i11[4] * s12[4], c11 = i11[2] * s12[3] + i11[5] * s12[4] + s12[5], m8 = r19._t;
    return m8[0] = o12, m8[1] = n17, m8[2] = a15, m8[3] = l12, m8[4] = h8, m8[5] = c11, r19;
  }
  invert() {
    const t12 = this._t;
    let e15 = t12[0] * t12[4] - t12[1] * t12[3];
    if (0 === e15)
      return new O2([0, 0, 0, 0, 0, 0]);
    e15 = 1 / e15;
    const r19 = (t12[1] * t12[5] - t12[2] * t12[4]) * e15, i11 = (t12[2] * t12[3] - t12[0] * t12[5]) * e15, s12 = t12[4] * e15, o12 = -t12[1] * e15, n17 = -t12[3] * e15, a15 = t12[0] * e15;
    return new O2([s12, o12, r19, n17, a15, i11]);
  }
};
var Y2 = class {
  constructor(t12, e15) {
    this._resourceManager = t12, this._transfos = [], this._sizeTransfos = [], this._geomUnitsPerPoint = 1, this._placementPool = new e2(t7, void 0, void 0, 100), this._earlyReturn = false, this._mapRotation = 0, this._transfos.push(e15 || O2.createIdentity()), this._sizeTransfos.push(e15 ? e15.scaleRatio() : 1);
  }
  setTransform(t12, e15) {
    this._transfos = [t12 || O2.createIdentity()], this._sizeTransfos = [e15 || (t12 ? t12.scaleRatio() : 1)];
  }
  setGeomUnitsPerPoint(t12) {
    this._geomUnitsPerPoint = t12;
  }
  transformPt(t12) {
    return this._transfos[this._transfos.length - 1].transform(t12);
  }
  transformSize(t12) {
    return t12 * this._sizeTransfos[this._sizeTransfos.length - 1];
  }
  reverseTransformPt(t12) {
    return this._transfos[this._transfos.length - 1].invert().transform(t12);
  }
  reverseTransformSize(t12) {
    return t12 / this._sizeTransfos[this._sizeTransfos.length - 1];
  }
  getTransformAngle() {
    return this._transfos[this._transfos.length - 1].angle();
  }
  geomUnitsPerPoint() {
    return this.isEmbedded() ? 1 : this._geomUnitsPerPoint;
  }
  isEmbedded() {
    return this._transfos.length > 1;
  }
  back() {
    return this._transfos[this._transfos.length - 1];
  }
  push(t12, e15) {
    const r19 = e15 ? t12.scaleRatio() : 1;
    O2.multiply(t12, this.back(), t12), this._transfos.push(t12), this._sizeTransfos.push(this._sizeTransfos[this._sizeTransfos.length - 1] * r19);
  }
  pop() {
    this._transfos.splice(-1, 1), this._sizeTransfos.splice(-1, 1);
  }
  drawSymbol(t12, e15, r19) {
    if (t12)
      switch (t12.type) {
        case "CIMPointSymbol":
        case "CIMLineSymbol":
        case "CIMPolygonSymbol":
          this.drawMultiLayerSymbol(t12, e15);
          break;
        case "CIMTextSymbol":
          this.drawTextSymbol(t12, e15, r19);
      }
  }
  drawMultiLayerSymbol(t12, e15) {
    if (!t12)
      return;
    const r19 = t12.symbolLayers;
    if (!r19)
      return;
    const i11 = t12.effects;
    if (i11 && i11.length > 0) {
      const t13 = this.executeEffects(i11, e15);
      if (t13) {
        let e16 = t13.next();
        for (; e16; )
          this.drawSymbolLayers(r19, e16), e16 = t13.next();
      }
    } else
      this.drawSymbolLayers(r19, e15);
  }
  executeEffects(t12, e15) {
    const r19 = this._resourceManager.geometryEngine;
    let i11 = new r4(e15);
    for (const s12 of t12) {
      const t13 = A3(s12);
      t13 && (i11 = t13.execute(i11, s12, this.geomUnitsPerPoint(), r19));
    }
    return i11;
  }
  drawSymbolLayers(t12, e15) {
    let r19 = t12.length;
    for (; r19--; ) {
      const i11 = t12[r19];
      if (!i11 || false === i11.enable)
        continue;
      const s12 = i11.effects;
      if (s12 && s12.length > 0) {
        const t13 = this.executeEffects(s12, e15);
        if (t13) {
          let e16 = null;
          for (; (e16 = t13.next()) && (this.drawSymbolLayer(i11, e16), !this._earlyReturn); )
            ;
        }
      } else
        this.drawSymbolLayer(i11, e15);
      if (this._earlyReturn)
        return;
    }
  }
  drawSymbolLayer(t12, e15) {
    switch (t12.type) {
      case "CIMSolidFill":
        this.drawSolidFill(e15, t12.color);
        break;
      case "CIMHatchFill":
        this.drawHatchFill(e15, t12);
        break;
      case "CIMPictureFill":
        this.drawPictureFill(e15, t12);
        break;
      case "CIMGradientFill":
        this.drawGradientFill(e15, t12);
        break;
      case "CIMSolidStroke":
        this.drawSolidStroke(e15, t12.color, t12.width, t12.capStyle, t12.joinStyle, t12.miterLimit);
        break;
      case "CIMPictureStroke":
        this.drawPictureStroke(e15, t12);
        break;
      case "CIMGradientStroke":
        this.drawGradientStroke(e15, t12);
        break;
      case "CIMCharacterMarker":
      case "CIMPictureMarker":
      case "CIMVectorMarker":
        this.drawMarkerLayer(t12, e15);
    }
  }
  drawHatchFill(t12, e15) {
    const r19 = this._buildHatchPolyline(e15, t12, this.geomUnitsPerPoint());
    r19 && (this.pushClipPath(t12), this.drawMultiLayerSymbol(e15.lineSymbol, r19), this.popClipPath());
  }
  drawPictureFill(t12, e15) {
  }
  drawGradientFill(t12, e15) {
  }
  drawPictureStroke(t12, e15) {
  }
  drawGradientStroke(t12, e15) {
  }
  drawMarkerLayer(t12, e15) {
    const r19 = t12.markerPlacement;
    if (r19) {
      const i11 = g6(r19);
      if (i11) {
        const s12 = "CIMMarkerPlacementInsidePolygon" === r19.type || "CIMMarkerPlacementPolygonCenter" === r19.type && r19.clipAtBoundary;
        s12 && this.pushClipPath(e15);
        const o12 = i11.execute(e15, r19, this.geomUnitsPerPoint(), this._resourceManager.geometryEngine);
        if (o12) {
          let e16 = null;
          for (; (e16 = o12.next()) && (this.drawMarker(t12, e16), !this._earlyReturn); )
            ;
        }
        s12 && this.popClipPath();
      }
    } else {
      const r20 = this._placementPool.acquire();
      if (s4(e15))
        r20.tx = e15.x, r20.ty = e15.y, this.drawMarker(t12, r20);
      else if (y2(e15))
        [r20.tx, r20.ty] = r2(e15), this.drawMarker(t12, r20);
      else
        for (const i11 of e15.points)
          if (r20.tx = i11[0], r20.ty = i11[1], this.drawMarker(t12, r20), this._earlyReturn)
            break;
      this._placementPool.release(r20);
    }
  }
  drawMarker(t12, e15) {
    switch (t12.type) {
      case "CIMCharacterMarker":
      case "CIMPictureMarker":
        this.drawPictureMarker(t12, e15);
        break;
      case "CIMVectorMarker":
        this.drawVectorMarker(t12, e15);
    }
  }
  drawPictureMarker(t12, e15) {
    var _a, _b, _c, _d, _e;
    if (!t12)
      return;
    const r19 = this._resourceManager.getResource(t12.url), i11 = (_a = t12.size) != null ? _a : 10;
    if (t(r19) || i11 <= 0)
      return;
    const o12 = r19.width, n17 = r19.height;
    if (!o12 || !n17)
      return;
    const a15 = o12 / n17, l12 = (_b = t12.scaleX) != null ? _b : 1, h8 = O2.createIdentity(), c11 = t12.anchorPoint;
    if (c11) {
      let e16 = c11.x, r20 = c11.y;
      "Absolute" !== t12.anchorPointUnits && (e16 *= i11 * a15 * l12, r20 *= i11), h8.translate(-e16, -r20);
    }
    let m8 = (_c = t12.rotation) != null ? _c : 0;
    t12.rotateClockwise && (m8 = -m8), this._mapRotation && (m8 += this._mapRotation), m8 && h8.rotate(m8 * E);
    let f9 = (_d = t12.offsetX) != null ? _d : 0, u14 = (_e = t12.offsetY) != null ? _e : 0;
    if (f9 || u14) {
      if (this._mapRotation) {
        const t13 = E * this._mapRotation, e16 = Math.cos(t13), r20 = Math.sin(t13), i12 = f9 * r20 + u14 * e16;
        f9 = f9 * e16 - u14 * r20, u14 = i12;
      }
      h8.translate(f9, u14);
    }
    const p6 = this.geomUnitsPerPoint();
    1 !== p6 && h8.scale(p6, p6);
    const d4 = e15.getAngle();
    d4 && h8.rotate(d4), h8.translate(e15.tx, e15.ty), this.push(h8, false), this.drawImage(t12, i11), this.pop();
  }
  drawVectorMarker(t12, e15) {
    var _a, _b, _c, _d;
    if (!t12)
      return;
    const r19 = t12.markerGraphics;
    if (!r19)
      return;
    const i11 = (_a = t12.size) != null ? _a : 10, s12 = t12.frame, o12 = s12 ? s12.ymax - s12.ymin : 0, n17 = i11 && o12 ? i11 / o12 : 1, a15 = O2.createIdentity();
    s12 && a15.translate(0.5 * -(s12.xmax + s12.xmin), 0.5 * -(s12.ymax + s12.ymin));
    const l12 = t12.anchorPoint;
    if (l12) {
      let e16 = l12.x, r20 = l12.y;
      "Absolute" !== t12.anchorPointUnits ? s12 && (e16 *= s12.xmax - s12.xmin, r20 *= s12.ymax - s12.ymin) : (e16 /= n17, r20 /= n17), a15.translate(-e16, -r20);
    }
    1 !== n17 && a15.scale(n17, n17);
    let h8 = (_b = t12.rotation) != null ? _b : 0;
    t12.rotateClockwise && (h8 = -h8), this._mapRotation && (h8 += this._mapRotation), h8 && a15.rotate(h8 * E);
    let c11 = (_c = t12.offsetX) != null ? _c : 0, m8 = (_d = t12.offsetY) != null ? _d : 0;
    if (c11 || m8) {
      if (this._mapRotation) {
        const t13 = E * this._mapRotation, e16 = Math.cos(t13), r20 = Math.sin(t13), i12 = c11 * r20 + m8 * e16;
        c11 = c11 * e16 - m8 * r20, m8 = i12;
      }
      a15.translate(c11, m8);
    }
    const f9 = this.geomUnitsPerPoint();
    1 !== f9 && a15.scale(f9, f9);
    const u14 = e15.getAngle();
    u14 && a15.rotate(u14), a15.translate(e15.tx, e15.ty), this.push(a15, t12.scaleSymbolsProportionally);
    for (const p6 of r19)
      if (p6 && p6.symbol && p6.geometry || N2.error("Invalid marker graphic", p6), this.drawSymbol(p6.symbol, p6.geometry, p6.textString), this._earlyReturn)
        break;
    this.pop();
  }
  drawTextSymbol(t12, e15, r19) {
    var _a, _b, _c, _d;
    if (!t12)
      return;
    if (!s4(e15))
      return;
    if (((_a = t12.height) != null ? _a : 10) <= 0)
      return;
    const i11 = O2.createIdentity();
    let s12 = (_b = t12.angle) != null ? _b : 0;
    s12 = -s12, s12 && i11.rotate(s12 * E);
    const o12 = (_c = t12.offsetX) != null ? _c : 0, n17 = (_d = t12.offsetY) != null ? _d : 0;
    (o12 || n17) && i11.translate(o12, n17);
    const a15 = this.geomUnitsPerPoint();
    1 !== a15 && i11.scale(a15, a15), i11.translate(e15.x, e15.y), this.push(i11, false), this.drawText(t12, r19), this.pop();
  }
  _buildHatchPolyline(t12, e15, r19) {
    let i11 = (void 0 !== t12.separation ? t12.separation : 4) * r19, s12 = void 0 !== t12.rotation ? t12.rotation : 0;
    if (0 === i11)
      return null;
    i11 < 0 && (i11 = -i11);
    let o12 = 0;
    const n17 = 0.5 * i11;
    for (; o12 > n17; )
      o12 -= i11;
    for (; o12 < -n17; )
      o12 += i11;
    const a15 = u4();
    c2(a15, e15), a15[0] -= n17, a15[1] -= n17, a15[2] += n17, a15[3] += n17;
    const l12 = [[a15[0], a15[1]], [a15[0], a15[3]], [a15[2], a15[3]], [a15[2], a15[1]]];
    for (; s12 > 180; )
      s12 -= 180;
    for (; s12 < 0; )
      s12 += 180;
    const c11 = Math.cos(s12 * E), f9 = Math.sin(s12 * E), u14 = -i11 * f9, p6 = i11 * c11;
    let d4, _4, g8, y7;
    o12 = (void 0 !== t12.offsetX ? t12.offsetX * r19 : 0) * f9 - (void 0 !== t12.offsetY ? t12.offsetY * r19 : 0) * c11, d4 = g8 = Number.MAX_VALUE, _4 = y7 = -Number.MAX_VALUE;
    for (const h8 of l12) {
      const t13 = h8[0], e16 = h8[1], r20 = c11 * t13 + f9 * e16, i12 = -f9 * t13 + c11 * e16;
      d4 = Math.min(d4, r20), g8 = Math.min(g8, i12), _4 = Math.max(_4, r20), y7 = Math.max(y7, i12);
    }
    g8 = Math.floor(g8 / i11) * i11;
    let P5 = c11 * d4 - f9 * g8 - u14 * o12 / i11, w6 = f9 * d4 + c11 * g8 - p6 * o12 / i11, x5 = c11 * _4 - f9 * g8 - u14 * o12 / i11, S2 = f9 * _4 + c11 * g8 - p6 * o12 / i11;
    const M4 = 1 + Math.round((y7 - g8) / i11), b5 = [];
    for (let h8 = 0; h8 < M4; h8++)
      P5 += u14, w6 += p6, x5 += u14, S2 += p6, b5.push([[P5, w6], [x5, S2]]);
    return { paths: b5 };
  }
};
var q2 = class extends Y2 {
  constructor(t12, e15) {
    super(t12, e15), this.reset();
  }
  reset() {
    this._xmin = this._ymin = 1 / 0, this._xmax = this._ymax = -1 / 0, this._clipCount = 0;
  }
  envelope() {
    return new t10(this._xmin, this._ymin, this._xmax - this._xmin, this._ymax - this._ymin);
  }
  bounds() {
    return o2(this._xmin, this._ymin, this._xmax, this._ymax);
  }
  drawSolidFill(t12) {
    if (t12 && !(this._clipCount > 0))
      if (y2(t12))
        this._processPath(t12.rings, 0);
      else if (f(t12))
        this._processPath(t12.paths, 0);
      else if (u2(t12)) {
        const e15 = Q(t12);
        e15 && this._processPath(e15.rings, 0);
      } else
        console.error("drawSolidFill Unexpected geometry type!");
  }
  drawSolidStroke(t12, e15, r19) {
    if (!t12 || this._clipCount > 0)
      return;
    const i11 = 0.5 * this.transformSize(r19);
    if (y2(t12))
      this._processPath(t12.rings, i11);
    else if (f(t12))
      this._processPath(t12.paths, i11);
    else if (u2(t12)) {
      const e16 = Q(t12);
      e16 && this._processPath(e16.rings, i11);
    } else
      console.error("drawSolidStroke unexpected geometry type!");
  }
  drawMarkerLayer(t12, e15) {
    y2(e15) && t12.markerPlacement && ("CIMMarkerPlacementInsidePolygon" === t12.markerPlacement.type || "CIMMarkerPlacementPolygonCenter" === t12.markerPlacement.type && t12.markerPlacement.clipAtBoundary) ? this._processPath(e15.rings, 0) : super.drawMarkerLayer(t12, e15);
  }
  drawHatchFill(t12, e15) {
    this.drawSolidFill(t12);
  }
  drawPictureFill(t12, e15) {
    this.drawSolidFill(t12);
  }
  drawGradientFill(t12, e15) {
    this.drawSolidFill(t12);
  }
  drawPictureStroke(t12, e15) {
    this.drawSolidStroke(t12, null, e15.width);
  }
  drawGradientStroke(t12, e15) {
    this.drawSolidStroke(t12, null, e15.width);
  }
  pushClipPath(t12) {
    this.drawSolidFill(t12), this._clipCount++;
  }
  popClipPath() {
    this._clipCount--;
  }
  drawImage(t12, e15) {
    var _a;
    const { url: r19 } = t12, i11 = (_a = t12.scaleX) != null ? _a : 1;
    let s12 = i11 * e15, n17 = e15;
    const a15 = this._resourceManager.getResource(r19);
    !e15 && r(a15) && (s12 = i11 * a15.width, n17 = a15.height), this._merge(this.transformPt([-s12 / 2, -n17 / 2]), 0), this._merge(this.transformPt([-s12 / 2, n17 / 2]), 0), this._merge(this.transformPt([s12 / 2, -n17 / 2]), 0), this._merge(this.transformPt([s12 / 2, n17 / 2]), 0);
  }
  drawText(t12, e15) {
    if (!e15 || 0 === e15.length)
      return;
    this._textRasterizer || (this._textRasterizer = new s6());
    const r19 = et(t12), [i11, s12] = this._textRasterizer.computeTextSize(e15, r19);
    let o12 = 0;
    switch (t12.horizontalAlignment) {
      case "Left":
        o12 = i11 / 2;
        break;
      case "Right":
        o12 = -i11 / 2;
    }
    let n17 = 0;
    switch (t12.verticalAlignment) {
      case "Bottom":
        n17 = s12 / 2;
        break;
      case "Top":
        n17 = -s12 / 2;
        break;
      case "Baseline":
        n17 = s12 / 6;
    }
    this._merge(this.transformPt([-i11 / 2 + o12, -s12 / 2 + n17]), 0), this._merge(this.transformPt([-i11 / 2 + o12, s12 / 2 + n17]), 0), this._merge(this.transformPt([i11 / 2 + o12, -s12 / 2 + n17]), 0), this._merge(this.transformPt([i11 / 2 + o12, s12 / 2 + n17]), 0);
  }
  _processPath(t12, e15) {
    if (t12)
      for (const r19 of t12) {
        const t13 = r19 ? r19.length : 0;
        if (t13 > 1) {
          this._merge(this.transformPt(r19[0]), e15);
          for (let i11 = 1; i11 < t13; i11++)
            this._merge(this.transformPt(r19[i11]), e15);
        }
      }
  }
  _merge(t12, e15) {
    t12[0] - e15 < this._xmin && (this._xmin = t12[0] - e15), t12[0] + e15 > this._xmax && (this._xmax = t12[0] + e15), t12[1] - e15 < this._ymin && (this._ymin = t12[1] - e15), t12[1] + e15 > this._ymax && (this._ymax = t12[1] + e15);
  }
};
var V = class extends Y2 {
  constructor() {
    super(...arguments), this._searchPoint = [0, 0], this._searchDistPoint = 0;
  }
  hitTest(t12, e15, r19, i11, s12, o12) {
    const n17 = o12 * u3(1);
    this.setTransform(), this.setGeomUnitsPerPoint(n17), this._searchPoint = [(t12[0] + t12[2]) / 2, (t12[1] + t12[3]) / 2], this._searchDistPoint = (t12[2] - t12[0]) / 2 / n17, this._textInfo = i11;
    const a15 = e15 && ("CIMPointSymbol" === e15.type && "Map" !== e15.angleAlignment || "CIMTextSymbol" === e15.type);
    return this._mapRotation = a15 ? s12 : 0, this._earlyReturn = false, this.drawSymbol(e15, r19), this._earlyReturn;
  }
  drawSolidFill(t12, e15) {
    this._hitTestFill(t12);
  }
  drawHatchFill(t12, e15) {
    this._hitTestFill(t12);
  }
  drawPictureFill(t12, e15) {
    this._hitTestFill(t12);
  }
  drawGradientFill(t12, e15) {
    this._hitTestFill(t12);
  }
  drawSolidStroke(t12, e15, r19, i11, s12, o12) {
    this._hitTestStroke(t12, r19);
  }
  drawPictureStroke(t12, e15) {
    this._hitTestStroke(t12, e15.width);
  }
  drawGradientStroke(t12, e15) {
    this._hitTestStroke(t12, e15.width);
  }
  drawMarkerLayer(t12, e15) {
    t12.markerPlacement && ("CIMMarkerPlacementInsidePolygon" === t12.markerPlacement.type || "CIMMarkerPlacementPolygonCenter" === t12.markerPlacement.type && t12.markerPlacement.clipAtBoundary) ? this._hitTestFill(e15) : super.drawMarkerLayer(t12, e15);
  }
  pushClipPath(t12) {
  }
  popClipPath() {
  }
  drawImage(t12, e15) {
    var _a;
    const { url: r19 } = t12, i11 = (_a = t12.scaleX) != null ? _a : 1, o12 = this._resourceManager.getResource(r19);
    if (t(o12) || 0 === o12.height || 0 === e15)
      return;
    const n17 = e15 * this.geomUnitsPerPoint(), a15 = n17 * i11 * (o12.width / o12.height), l12 = this.reverseTransformPt(this._searchPoint), h8 = this._searchDistPoint;
    Math.abs(l12[0]) < a15 / 2 + h8 && Math.abs(l12[1]) < n17 / 2 + h8 && (this._earlyReturn = true);
  }
  drawText(e15, r19) {
    var _a, _b;
    const i11 = this._textInfo;
    if (!i11)
      return;
    const s12 = i11.get(e15);
    if (!s12)
      return;
    const { text: o12, mosaicItem: n17 } = s12;
    if (!n17 || 0 === n17.glyphMosaicItems.length)
      return;
    const a15 = (_a = e15.height) != null ? _a : J, l12 = tt(e15.lineGapType, (_b = e15.lineGap) != null ? _b : 0, a15), h8 = n5(o12)[1], c11 = n17.glyphMosaicItems, m8 = j4(c11, h8, { scale: a15 / j, angle: 0, xOffset: 0, yOffset: 0, hAlign: Z2(e15.horizontalAlignment), vAlign: $(e15.verticalAlignment), maxLineWidth: 512, lineHeight: f2 * Math.max(0.25, Math.min(l12 || 1, 4)), decoration: e15.font.decoration || "none", isCIM: true }), f9 = this.reverseTransformPt(this._searchPoint), u14 = f9[0], p6 = f9[1];
    for (const t12 of m8.glyphs)
      if (u14 > t12.xTopLeft && u14 < t12.xBottomRight && p6 > -t12.yBottomRight && p6 < -t12.yTopLeft) {
        this._earlyReturn = true;
        break;
      }
  }
  _hitTestFill(t12) {
    let e15 = null;
    if (u2(t12)) {
      const r20 = t12;
      e15 = [[[r20.xmin, r20.ymin], [r20.xmin, r20.ymax], [r20.xmax, r20.ymax], [r20.xmax, r20.ymin], [r20.xmin, r20.ymin]]];
    } else if (y2(t12))
      e15 = t12.rings;
    else {
      if (!f(t12))
        return;
      e15 = t12.paths;
    }
    const r19 = this.reverseTransformPt(this._searchPoint);
    if (this._pointInPolygon(r19, e15) && (this._earlyReturn = true), !this._earlyReturn) {
      const t13 = this.reverseTransformSize(this._searchDistPoint) * this.geomUnitsPerPoint();
      this._nearLine(r19, e15, t13) && (this._earlyReturn = true);
    }
  }
  _hitTestStroke(t12, e15) {
    let r19 = null;
    if (u2(t12)) {
      const e16 = t12;
      r19 = [[[e16.xmin, e16.ymin], [e16.xmin, e16.ymax], [e16.xmax, e16.ymax], [e16.xmax, e16.ymin], [e16.xmin, e16.ymin]]];
    } else if (y2(t12))
      r19 = t12.rings;
    else {
      if (!f(t12))
        return;
      r19 = t12.paths;
    }
    const i11 = this.reverseTransformPt(this._searchPoint), s12 = e15 * this.geomUnitsPerPoint(), o12 = this.reverseTransformSize(this._searchDistPoint) * this.geomUnitsPerPoint();
    this._nearLine(i11, r19, s12 / 2 + o12) && (this._earlyReturn = true);
  }
  _pointInPolygon(t12, e15) {
    let r19 = 0;
    for (const i11 of e15) {
      const e16 = i11.length;
      for (let s12 = 1; s12 < e16; s12++) {
        const e17 = i11[s12 - 1], o12 = i11[s12];
        if (e17[1] > t12[1] == o12[1] > t12[1])
          continue;
        (o12[0] - e17[0]) * (t12[1] - e17[1]) - (o12[1] - e17[1]) * (t12[0] - e17[0]) > 0 ? r19++ : r19--;
      }
    }
    return 0 !== r19;
  }
  _nearLine(t12, e15, r19) {
    for (const i11 of e15) {
      const e16 = i11.length;
      for (let s12 = 1; s12 < e16; s12++) {
        const e17 = i11[s12 - 1], o12 = i11[s12];
        let n17 = (o12[0] - e17[0]) * (o12[0] - e17[0]) + (o12[1] - e17[1]) * (o12[1] - e17[1]);
        if (0 === n17)
          continue;
        n17 = Math.sqrt(n17);
        const a15 = ((o12[0] - e17[0]) * (t12[1] - e17[1]) - (o12[1] - e17[1]) * (t12[0] - e17[0])) / n17;
        if (Math.abs(a15) < r19) {
          const i12 = ((o12[0] - e17[0]) * (t12[0] - e17[0]) + (o12[1] - e17[1]) * (t12[1] - e17[1])) / n17;
          if (i12 > -r19 && i12 < n17 + r19)
            return true;
        }
      }
    }
    return false;
  }
};
var W = class extends Y2 {
  constructor(t12, e15, r19, i11) {
    super(e15, r19), this._applyAdditionalRenderProps = i11, this._colorSubstitutionHelper = new a4(), this._ctx = t12;
  }
  drawSolidFill(t12, e15) {
    if (!t12)
      return;
    if (y2(t12))
      this._buildPath(t12.rings, true);
    else if (f(t12))
      this._buildPath(t12.paths, true);
    else if (u2(t12))
      this._buildPath(Q(t12).rings, true);
    else {
      if (!l2(t12))
        return;
      console.log("CanvasDrawHelper.drawSolidFill - No implementation!");
    }
    const r19 = this._ctx;
    r19.fillStyle = "string" == typeof e15 ? e15 : "rgba(" + Math.round(e15[0]) + "," + Math.round(e15[1]) + "," + Math.round(e15[2]) + "," + e15[3] / 255 + ")", r19.fill("evenodd");
  }
  drawSolidStroke(t12, e15, r19, i11, s12, o12) {
    if (!t12 || !e15 || 0 === r19)
      return;
    if (y2(t12))
      this._buildPath(t12.rings, true);
    else if (f(t12))
      this._buildPath(t12.paths, false);
    else {
      if (!u2(t12))
        return void console.log("CanvasDrawHelper.drawSolidStroke isn't implemented!");
      this._buildPath(Q(t12).rings, true);
    }
    const n17 = this._ctx;
    n17.strokeStyle = "string" == typeof e15 ? e15 : "rgba(" + Math.round(e15[0]) + "," + Math.round(e15[1]) + "," + Math.round(e15[2]) + "," + e15[3] / 255 + ")", n17.lineWidth = Math.max(this.transformSize(r19), 0.5), this._setCapStyle(i11), this._setJoinStyle(s12), n17.miterLimit = o12, n17.stroke();
  }
  pushClipPath(t12) {
    if (this._ctx.save(), y2(t12))
      this._buildPath(t12.rings, true);
    else if (f(t12))
      this._buildPath(t12.paths, true);
    else {
      if (!u2(t12))
        return;
      this._buildPath(Q(t12).rings, true);
    }
    this._ctx.clip("evenodd");
  }
  popClipPath() {
    this._ctx.restore();
  }
  drawImage(t12, e15) {
    var _a;
    const { colorSubstitutions: r19, url: i11, tintColor: o12 } = t12, n17 = (_a = t12.scaleX) != null ? _a : 1, a15 = this._resourceManager.getResource(i11);
    if (t(a15))
      return;
    let l12 = e15 * (a15.width / a15.height), h8 = e15;
    e15 || (l12 = a15.width, h8 = a15.height);
    const c11 = A(i11) || "src" in a15 && A(a15.src);
    let m8 = "getFrame" in a15 ? t9(a15) : a15;
    r19 && (m8 = this._colorSubstitutionHelper.applyColorSubstituition(m8, r19)), this._applyAdditionalRenderProps && !c11 && o12 && (m8 = this._colorSubstitutionHelper.tintImageData(m8, o12));
    const f9 = this.transformPt([0, 0]), [u14, p6] = this.getTransformAngle(), d4 = this.transformSize(1), _4 = this._ctx;
    _4.save(), _4.setTransform({ m11: n17 * d4 * u14, m12: n17 * d4 * p6, m21: -d4 * p6, m22: d4 * u14, m41: f9[0], m42: f9[1] }), _4.drawImage(m8, -l12 / 2, -h8 / 2, l12, h8), _4.restore();
  }
  drawText(t12, e15) {
    if (!e15 || 0 === e15.length)
      return;
    this._textRasterizer || (this._textRasterizer = new s6());
    const r19 = et(t12);
    r19.size *= this.transformSize(e3(1));
    const i11 = this._textRasterizer.rasterizeText(e15, r19);
    if (!i11)
      return;
    const { size: s12, anchorX: o12, anchorY: n17, canvas: l12 } = i11, h8 = s12[0] * (o12 + 0.5), c11 = s12[1] * (n17 - 0.5), m8 = this._ctx, f9 = this.transformPt([0, 0]), [u14, p6] = this.getTransformAngle(), d4 = 1;
    m8.save(), m8.setTransform({ m11: d4 * u14, m12: d4 * p6, m21: -d4 * p6, m22: d4 * u14, m41: f9[0] - d4 * h8, m42: f9[1] + d4 * c11 }), m8.drawImage(l12, 0, 0), m8.restore();
  }
  drawPictureFill(t12, e15) {
    if (!t12)
      return;
    let { colorSubstitutions: r19, height: i11, offsetX: o12, offsetY: n17, rotation: a15, scaleX: l12, tintColor: h8, url: c11 } = e15;
    const m8 = this._resourceManager.getResource(c11);
    if (t(m8))
      return;
    if (y2(t12))
      this._buildPath(t12.rings, true);
    else if (f(t12))
      this._buildPath(t12.paths, true);
    else if (u2(t12))
      this._buildPath(Q(t12).rings, true);
    else {
      if (!l2(t12))
        return;
      console.log("CanvasDrawHelper.drawPictureFill - No implementation!");
    }
    const f9 = this._ctx, u14 = A(c11) || "src" in m8 && A(m8.src);
    let y7, P5 = "getFrame" in m8 ? t9(m8) : m8;
    if (r19 && (P5 = this._colorSubstitutionHelper.applyColorSubstituition(P5, r19)), this._applyAdditionalRenderProps) {
      u14 || h8 && (P5 = this._colorSubstitutionHelper.tintImageData(P5, h8)), y7 = f9.createPattern(P5, "repeat");
      const t13 = this.transformSize(1);
      a15 || (a15 = 0), o12 ? o12 *= t13 : o12 = 0, n17 ? n17 *= t13 : n17 = 0, i11 && (i11 *= t13);
      const e16 = i11 ? i11 / m8.height : 1, r20 = l12 && i11 ? l12 * i11 / m8.width : 1;
      if (0 !== a15 || 1 !== e16 || 1 !== r20 || 0 !== o12 || 0 !== n17) {
        const t14 = new DOMMatrix();
        t14.rotateSelf(0, 0, -a15).translateSelf(o12, n17).scaleSelf(r20, e16, 1), y7.setTransform(t14);
      }
    } else
      y7 = f9.createPattern(P5, "repeat");
    f9.save(), f9.fillStyle = y7, f9.fill("evenodd"), f9.restore();
  }
  drawPictureStroke(t12, e15) {
    if (!t12)
      return;
    let { colorSubstitutions: i11, capStyle: o12, joinStyle: n17, miterLimit: a15, tintColor: h8, url: c11, width: m8 } = e15;
    const f9 = this._resourceManager.getResource(c11);
    if (t(f9))
      return;
    let u14;
    if (y2(t12))
      u14 = t12.rings;
    else if (f(t12))
      u14 = t12.paths;
    else if (u2(t12))
      u14 = Q(t12).rings;
    else {
      if (!l2(t12))
        return;
      console.log("CanvasDrawHelper.drawPictureStroke - No implementation!");
    }
    m8 || (m8 = f9.width);
    const y7 = A(c11) || "src" in f9 && A(f9.src);
    let P5 = "getFrame" in f9 ? t9(f9) : f9;
    i11 && (P5 = this._colorSubstitutionHelper.applyColorSubstituition(P5, i11)), this._applyAdditionalRenderProps && (y7 || h8 && (P5 = this._colorSubstitutionHelper.tintImageData(P5, h8)));
    const w6 = Math.max(this.transformSize(u3(m8)), 0.5), x5 = w6 / P5.width, S2 = this._ctx, M4 = S2.createPattern(P5, "repeat-y");
    let b5, C5;
    S2.save(), this._setCapStyle(o12), this._setJoinStyle(n17), S2.miterLimit = a15, S2.lineWidth = w6;
    for (let s12 of u14)
      if (s12 = y(s12), it(s12), s12 && !(s12.length <= 1)) {
        b5 = this.transformPt(s12[0]);
        for (let t13 = 1; t13 < s12.length; t13++) {
          C5 = this.transformPt(s12[t13]);
          const e16 = K2(b5, C5), r19 = new DOMMatrix();
          r19.translateSelf(0, b5[1] - w6 / 2).scaleSelf(x5, x5, 1).rotateSelf(0, 0, 90 - e16), M4.setTransform(r19), S2.strokeStyle = M4, S2.beginPath(), S2.moveTo(b5[0], b5[1]), S2.lineTo(C5[0], C5[1]), S2.stroke(), b5 = C5;
        }
      }
    S2.restore();
  }
  _buildPath(t12, e15) {
    const r19 = this._ctx;
    if (r19.beginPath(), t12)
      for (const i11 of t12) {
        const t13 = i11 ? i11.length : 0;
        if (t13 > 1) {
          let s12 = this.transformPt(i11[0]);
          r19.moveTo(s12[0], s12[1]);
          for (let e16 = 1; e16 < t13; e16++)
            s12 = this.transformPt(i11[e16]), r19.lineTo(s12[0], s12[1]);
          e15 && r19.closePath();
        }
      }
  }
  _setCapStyle(t12) {
    switch (t12) {
      case U.Butt:
        this._ctx.lineCap = "butt";
        break;
      case U.Round:
        this._ctx.lineCap = "round";
        break;
      case U.Square:
        this._ctx.lineCap = "square";
    }
  }
  _setJoinStyle(t12) {
    switch (t12) {
      case w2.Bevel:
        this._ctx.lineJoin = "bevel";
        break;
      case w2.Round:
        this._ctx.lineJoin = "round";
        break;
      case w2.Miter:
        this._ctx.lineJoin = "miter";
    }
  }
};
function K2(t12, e15) {
  const r19 = e15[0] - t12[0], i11 = e15[1] - t12[1];
  return 180 / Math.PI * Math.atan2(i11, r19);
}
var Q = (t12) => t12 ? { spatialReference: t12.spatialReference, rings: [[[t12.xmin, t12.ymin], [t12.xmin, t12.ymax], [t12.xmax, t12.ymax], [t12.xmax, t12.ymin], [t12.xmin, t12.ymin]]] } : null;
var Z2 = (t12) => {
  switch (t12) {
    case "Left":
      return e5.Left;
    case "Right":
      return e5.Right;
    case "Center":
      return e5.Center;
    case "Justify":
      return N2.warnOnce("Horizontal alignment 'justify' is not implemented. Falling back to 'center'."), e5.Center;
  }
};
var $ = (t12) => {
  switch (t12) {
    case "Top":
      return t5.Top;
    case "Center":
      return t5.Center;
    case "Bottom":
      return t5.Bottom;
    case "Baseline":
      return t5.Baseline;
  }
};
var tt = (t12, e15, r19) => {
  switch (t12) {
    case "ExtraLeading":
      return 1 + e15 / r19;
    case "Multiple":
      return e15;
    case "Exact":
      return e15 / r19;
  }
};
function et(t12, r19 = 1) {
  const i11 = g2(t12), s12 = S(t12.fontStyleName), o12 = a3(t12.fontFamilyName), { weight: n17, style: a15 } = s12, l12 = r19 * (t12.height || 5), h8 = w(t12.horizontalAlignment), c11 = x(t12.verticalAlignment), m8 = k(t12), f9 = P(t12.haloSymbol), u14 = f9 ? r19 * (0 | t12.haloSize) : 0;
  return { color: m8, size: l12, horizontalAlignment: h8, verticalAlignment: c11, font: { family: o12, style: I(a15), weight: h(n17), decoration: i11 }, halo: { size: u14 || 0, color: f9, style: a15 }, pixelRatio: 1, premultiplyColors: true };
}
var rt = 1e-4;
function it(t12) {
  let e15, r19, i11, s12, o12, n17 = t12[0], a15 = 1;
  for (; a15 < t12.length; )
    e15 = t12[a15][0] - n17[0], r19 = t12[a15][1] - n17[1], s12 = 0 !== e15 ? r19 / e15 : Math.PI / 2, void 0 !== i11 && s12 - i11 <= rt ? (t12.splice(a15 - 1, 1), n17 = o12) : (o12 = n17, n17 = t12[a15], a15++), i11 = s12;
}

// node_modules/@arcgis/core/symbols/cim/CIMSymbolHelper.js
var Y3 = Math.PI;
var $2 = Y3 / 2;
var U3 = 4;
var q3 = 10;
var W2 = 96 / 72;
var J2 = Math.PI / 180;
var K3 = s.getLogger("esri.symbols.cim.CIMSymbolHelper");
function Q2(e15) {
  if (!e15 || !e15.type)
    return null;
  let t12;
  switch (e15.type) {
    case "cim":
      return e15.data;
    case "web-style":
      return e15;
    case "simple-marker":
      t12 = oe2.fromSimpleMarker(e15);
      break;
    case "picture-marker":
      t12 = oe2.fromPictureMarker(e15);
      break;
    case "simple-line":
      t12 = oe2.fromSimpleLineSymbol(e15);
      break;
    case "simple-fill":
      t12 = oe2.fromSimpleFillSymbol(e15);
      break;
    case "picture-fill":
      t12 = oe2.fromPictureFillSymbol(e15);
      break;
    case "text":
      t12 = oe2.fromTextSymbol(e15);
  }
  return { type: "CIMSymbolReference", symbol: t12 };
}
function Z3(e15, t12, r19) {
  switch (t12.type) {
    case "CIMSymbolReference":
      return Z3(e15, t12.symbol, r19);
    case "CIMPointSymbol":
      null == r19 && (r19 = { x: 0, y: 0 }), e15.drawSymbol(t12, r19);
      break;
    case "CIMLineSymbol":
      null == r19 && (r19 = { paths: [[[0, 0], [10, 0]]] }), e15.drawSymbol(t12, r19);
      break;
    case "CIMPolygonSymbol":
      null == r19 && (r19 = { rings: [[[0, 0], [0, 10], [10, 10], [10, 0], [0, 0]]] }), e15.drawSymbol(t12, r19);
      break;
    case "CIMTextSymbol": {
      const r20 = { x: 0, y: 0 };
      e15.drawSymbol(t12, r20);
      break;
    }
    case "CIMVectorMarker": {
      const r20 = new t7();
      e15.drawMarker(t12, r20);
      break;
    }
  }
  return e15.envelope();
}
function ee(e15) {
  if (!e15)
    return 0;
  switch (e15.type) {
    case "CIMMarkerPlacementAlongLineSameSize":
    case "CIMMarkerPlacementAlongLineRandomSize":
    case "CIMMarkerPlacementAtExtremities":
    case "CIMMarkerPlacementAtMeasuredUnits":
    case "CIMMarkerPlacementAtRatioPositions":
    case "CIMMarkerPlacementOnLine":
    case "CIMMarkerPlacementOnVertices":
      return Math.abs(e15.offset);
    default:
      return 0;
  }
}
function te(e15) {
  if (!e15)
    return 0;
  switch (e15.type) {
    case "CIMGeometricEffectArrow":
      return Math.abs(0.5 * e15.width);
    case "CIMGeometricEffectBuffer":
      return Math.abs(e15.size);
    case "CIMGeometricEffectExtension":
    case "CIMGeometricEffectRadial":
      return Math.abs(e15.length);
    case "CIMGeometricEffectJog":
      return Math.abs(0.5 * e15.length);
    case "CIMGeometricEffectMove":
      return Math.max(Math.abs(b(e15.offsetX)), Math.abs(b(e15.offsetY)));
    case "CIMGeometricEffectOffset":
    case "CIMGeometricEffectOffsetTangent":
      return Math.abs(e15.offset);
    case "CIMGeometricEffectRegularPolygon":
      return Math.abs(e15.radius);
    case "CIMGeometricEffectRotate":
    case "CIMGeometricEffectScale":
    default:
      return 0;
    case "CIMGeometricEffectTaperedPolygon":
      return 0.5 * Math.max(Math.abs(e15.fromWidth), Math.abs(e15.toWidth));
    case "CIMGeometricEffectWave":
      return Math.abs(e15.amplitude);
  }
}
function re(e15) {
  if (!e15)
    return 0;
  let t12 = 0;
  for (const r19 of e15)
    t12 += te(r19);
  return t12;
}
var ae = class {
  getSymbolInflateSize(e15, t12, r19, a15, o12) {
    return e15 || (e15 = [0, 0, 0, 0]), t12 ? this._getInflateSize(e15, t12, r19, a15, o12) : e15;
  }
  static safeSize(e15) {
    const t12 = Math.max(Math.abs(e15[0]), Math.abs(e15[2])), r19 = Math.max(Math.abs(e15[1]), Math.abs(e15[3]));
    return Math.sqrt(t12 * t12 + r19 * r19);
  }
  _vectorMarkerBounds(e15, t12, r19, a15) {
    let o12 = true;
    const i11 = u4();
    if (t12 && t12.markerGraphics)
      for (const s12 of t12.markerGraphics) {
        const t13 = [0, 0, 0, 0];
        s12.geometry && (c2(i11, s12.geometry), t13[0] = 0, t13[1] = 0, t13[2] = 0, t13[3] = 0, this.getSymbolInflateSize(t13, s12.symbol, r19, 0, a15), i11[0] += t13[0], i11[1] += t13[1], i11[2] += t13[2], i11[3] += t13[3], o12 ? (e15[0] = i11[0], e15[1] = i11[1], e15[2] = i11[2], e15[3] = i11[3], o12 = false) : (e15[0] = Math.min(e15[0], i11[0]), e15[1] = Math.min(e15[1], i11[1]), e15[2] = Math.max(e15[2], i11[2]), e15[3] = Math.max(e15[3], i11[3])));
      }
    return e15;
  }
  _getInflateSize(e15, t12, r19, a15, o12) {
    if (ue(t12)) {
      const i11 = this._getLayersInflateSize(e15, t12.symbolLayers, r19, a15, o12), s12 = re(t12.effects);
      return s12 > 0 && (i11[0] -= s12, i11[1] -= s12, i11[2] += s12, i11[3] += s12), i11;
    }
    return this._getTextInflatedSize(e15, t12, o12);
  }
  _getLayersInflateSize(e15, t12, r19, a15, i11) {
    let s12 = true;
    if (!t12)
      return e15;
    for (const n17 of t12) {
      if (!n17)
        continue;
      let t13 = [0, 0, 0, 0];
      switch (n17.type) {
        case "CIMSolidFill":
        case "CIMPictureFill":
        case "CIMHatchFill":
        case "CIMGradientFill":
          break;
        case "CIMSolidStroke":
        case "CIMPictureStroke":
        case "CIMGradientStroke": {
          const e16 = n17;
          let r20 = e16.width;
          e16.capStyle === U.Square || e16.joinStyle === w2.Miter ? r20 /= 1.4142135623730951 : r20 /= 2, t13[0] = -r20, t13[1] = -r20, t13[2] = r20, t13[3] = r20;
          break;
        }
        case "CIMCharacterMarker":
        case "CIMVectorMarker":
        case "CIMPictureMarker": {
          const e16 = n17;
          if ("CIMVectorMarker" === n17.type) {
            const e17 = n17;
            if (t13 = this._vectorMarkerBounds(t13, e17, r19, i11), e17.frame) {
              const r20 = (e17.frame.xmin + e17.frame.xmax) / 2, a16 = (e17.frame.ymin + e17.frame.ymax) / 2;
              t13[0] -= r20, t13[1] -= a16, t13[2] -= r20, t13[3] -= a16;
              const o12 = e17.size / (e17.frame.ymax - e17.frame.ymin);
              t13[0] *= o12, t13[1] *= o12, t13[2] *= o12, t13[3] *= o12;
            }
          } else if ("CIMPictureMarker" === n17.type) {
            const a16 = n17, i12 = r19.getResource(a16.url);
            let s14 = 1;
            r(i12) && i12.height && (s14 = i12.width / i12.height);
            const l14 = e16.size / 2, c11 = e16.size * s14 * a16.scaleX / 2;
            t13 = [-c11, -l14, c11, l14];
          } else {
            const r20 = e16.size / 2;
            t13 = [-r20, -r20, r20, r20];
          }
          if (e16.anchorPoint) {
            let r20, a16;
            "Absolute" === e16.anchorPointUnits ? (r20 = e16.anchorPoint.x, a16 = e16.anchorPoint.y) : (r20 = e16.anchorPoint.x * (t13[2] - t13[0]), a16 = e16.anchorPoint.y * (t13[3] - t13[1])), t13[0] -= r20, t13[1] -= a16, t13[2] -= r20, t13[3] -= a16;
          }
          let s13 = b(e16.rotation);
          if (e16.rotateClockwise && (s13 = -s13), a15 && (s13 -= a15), s13) {
            const e17 = J2 * s13, r20 = Math.cos(e17), a16 = Math.sin(e17), o12 = u4([n3, n3, -n3, -n3]);
            m(o12, [t13[0] * r20 - t13[1] * a16, t13[0] * a16 + t13[1] * r20]), m(o12, [t13[0] * r20 - t13[3] * a16, t13[0] * a16 + t13[3] * r20]), m(o12, [t13[2] * r20 - t13[1] * a16, t13[2] * a16 + t13[1] * r20]), m(o12, [t13[2] * r20 - t13[3] * a16, t13[2] * a16 + t13[3] * r20]), t13 = o12;
          }
          let l13 = b(e16.offsetX), m8 = b(e16.offsetY);
          if (a15) {
            const e17 = J2 * a15, t14 = Math.cos(e17), r20 = Math.sin(e17), o12 = l13 * r20 + m8 * t14;
            l13 = l13 * t14 - m8 * r20, m8 = o12;
          }
          t13[0] += l13, t13[1] += m8, t13[2] += l13, t13[3] += m8;
          const y7 = ee(e16.markerPlacement);
          y7 > 0 && (t13[0] -= y7, t13[1] -= y7, t13[2] += y7, t13[3] += y7);
          break;
        }
      }
      const l12 = re(n17.effects);
      l12 > 0 && (t13[0] -= l12, t13[1] -= l12, t13[2] += l12, t13[3] += l12), s12 ? (e15[0] = t13[0], e15[1] = t13[1], e15[2] = t13[2], e15[3] = t13[3], s12 = false) : (e15[0] = Math.min(e15[0], t13[0]), e15[1] = Math.min(e15[1], t13[1]), e15[2] = Math.max(e15[2], t13[2]), e15[3] = Math.max(e15[3], t13[3]));
    }
    return e15;
  }
  _getTextInflatedSize(e15, r19, a15) {
    var _a, _b;
    const o12 = (_a = r19.height) != null ? _a : q3;
    if (e15[0] = -o12 / 2, e15[1] = -o12 / 2, e15[2] = o12 / 2, e15[3] = o12 / 2, !a15)
      return e15;
    const i11 = a15.get(r19);
    if (!i11)
      return e15;
    const { text: s12, mosaicItem: n17 } = i11;
    if (!n17 || 0 === n17.glyphMosaicItems.length)
      return e15;
    const l12 = tt(r19.lineGapType, (_b = r19.lineGap) != null ? _b : 0, o12), c11 = n5(s12)[1], f9 = n17.glyphMosaicItems, m8 = j4(f9, c11, { scale: o12 / j, angle: b(r19.angle), xOffset: b(r19.offsetX), yOffset: b(r19.offsetY), hAlign: Z2(r19.horizontalAlignment), vAlign: $(r19.verticalAlignment), maxLineWidth: 512, lineHeight: f2 * Math.max(0.25, Math.min(l12 || 1, 4)), decoration: r19.font.decoration || "none", isCIM: true }).boundsT;
    return e15[0] = m8.x - m8.halfWidth, e15[1] = -m8.y - m8.halfHeight, e15[2] = m8.x + m8.halfWidth, e15[3] = -m8.y + m8.halfHeight, e15;
  }
};
var oe2 = class {
  static getEnvelope(e15, t12, r19) {
    const a15 = new q2(r19);
    if (Array.isArray(e15)) {
      let r20;
      for (const o12 of e15)
        r20 ? r20.union(Z3(a15, o12, t12)) : r20 = Z3(a15, o12, t12);
      return r20;
    }
    return Z3(a15, e15, t12);
  }
  static getTextureAnchor(e15, t12) {
    const r19 = this.getEnvelope(e15, null, t12);
    if (!r19)
      return [0, 0, 0];
    const a15 = (r19.x + 0.5 * r19.width) * W2, o12 = (r19.y + 0.5 * r19.height) * W2, i11 = r19.width * W2 + 2, s12 = r19.height * W2 + 2;
    return [-a15 / i11, -o12 / s12, s12];
  }
  static rasterize(e15, t12, r19, a15, o12 = true) {
    const i11 = r19 || this.getEnvelope(t12, null, a15);
    if (!i11)
      return [null, 0, 0, 0, 0];
    const s12 = (i11.x + 0.5 * i11.width) * W2, n17 = (i11.y + 0.5 * i11.height) * W2;
    e15.width = i11.width * W2, e15.height = i11.height * W2, r19 || (e15.width += 2, e15.height += 2);
    const l12 = e15.getContext("2d"), c11 = O2.createScale(W2, -W2);
    c11.translate(0.5 * e15.width - s12, 0.5 * e15.height + n17);
    const f9 = new W(l12, a15, c11);
    switch (t12.type) {
      case "CIMPointSymbol": {
        const e16 = { type: "point", x: 0, y: 0 };
        f9.drawSymbol(t12, e16);
        break;
      }
      case "CIMVectorMarker": {
        const e16 = new t7();
        f9.drawMarker(t12, e16);
        break;
      }
    }
    const m8 = l12.getImageData(0, 0, e15.width, e15.height), y7 = new Uint8Array(m8.data);
    if (o12) {
      let e16;
      for (let t13 = 0; t13 < y7.length; t13 += 4)
        e16 = y7[t13 + 3] / 255, y7[t13] = y7[t13] * e16, y7[t13 + 1] = y7[t13 + 1] * e16, y7[t13 + 2] = y7[t13 + 2] * e16;
    }
    return [y7, e15.width, e15.height, -s12 / e15.width, -n17 / e15.height];
  }
  static fromTextSymbol(e15) {
    const { angle: r19, color: a15, font: o12, haloColor: i11, haloSize: s12, horizontalAlignment: n17, kerning: l12, text: c11, verticalAlignment: f9, xoffset: m8, yoffset: y7 } = e15;
    let h8, p6, u14, M4, d4;
    o12 && (h8 = o12.family, p6 = o12.style, u14 = o12.weight, M4 = o12.size, d4 = o12.decoration);
    let S2 = false;
    if (c11) {
      S2 = n5(c11)[1];
    }
    return { type: "CIMPointSymbol", symbolLayers: [{ type: "CIMVectorMarker", enable: true, anchorPointUnits: "Relative", dominantSizeAxis3D: "Y", size: 10, billboardMode3D: "FaceNearPlane", frame: { xmin: -5, ymin: -5, xmax: 5, ymax: 5 }, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: { x: 0, y: 0 }, symbol: { type: "CIMTextSymbol", angle: r19, blockProgression: C.BTT, depth3D: 1, extrapolateBaselines: true, fontEffects: l4.Normal, fontEncoding: a.Unicode, fontFamilyName: h8 || "Arial", fontStyleName: me(p6, u14), fontType: u6.Unspecified, haloSize: s12, height: M4, hinting: y3.Default, horizontalAlignment: le(n17 != null ? n17 : "center"), kerning: l12, letterWidth: 100, ligatures: true, lineGapType: "Multiple", offsetX: b(m8), offsetY: b(y7), strikethrough: "line-through" === d4, underline: "underline" === d4, symbol: { type: "CIMPolygonSymbol", symbolLayers: [{ type: "CIMSolidFill", enable: true, color: fe(a15) }] }, haloSymbol: { type: "CIMPolygonSymbol", symbolLayers: [{ type: "CIMSolidFill", enable: true, color: fe(i11) }] }, shadowColor: [0, 0, 0, 255], shadowOffsetX: 1, shadowOffsetY: 1, textCase: "Normal", textDirection: S2 ? ne.RTL : ne.LTR, verticalAlignment: ce(f9 != null ? f9 : "baseline"), verticalGlyphOrientation: oe.Right, wordSpacing: 100, billboardMode3D: m3.FaceNearPlane }, textString: c11 }], scaleSymbolsProportionally: true, respectFrame: true }], scaleX: 1, angleAlignment: "Display" };
  }
  static fromPictureFillSymbol(e15) {
    const { height: t12, outline: r19, width: a15, xoffset: o12, xscale: i11, yoffset: s12, yscale: n17 } = e15, l12 = [], c11 = { type: "CIMPolygonSymbol", symbolLayers: l12 };
    if (r19) {
      const { cap: e16, join: t13, miterLimit: a16, width: o13 } = r19;
      l12.push({ type: "CIMSolidStroke", color: fe(r19.color), capStyle: se(e16), joinStyle: ne2(t13), miterLimit: a16, width: o13 });
    }
    let f9 = e15.url;
    "esriPFS" === e15.type && e15.imageData && (f9 = e15.imageData);
    const m8 = "angle" in e15 ? e15.angle : 0, y7 = a15 * (i11 || 1), h8 = t12 * (n17 || 1);
    return l12.push({ type: "CIMPictureFill", invertBackfaceTexture: false, scaleX: 1, textureFilter: ie.Picture, tintColor: null, url: f9, height: h8, width: y7, offsetX: b(o12), offsetY: b(s12), rotation: b(-m8), colorSubstitutions: null }), c11;
  }
  static fromSimpleFillSymbol(e15) {
    const { color: t12, style: a15, outline: o12 } = e15, i11 = [], s12 = { type: "CIMPolygonSymbol", symbolLayers: i11 };
    let n17 = null;
    if (o12) {
      const { cap: e16, join: t13, style: r19 } = o12;
      "solid" !== r19 && "none" !== r19 && "esriSLSSolid" !== r19 && "esriSLSNull" !== r19 && (n17 = [{ type: "CIMGeometricEffectDashes", dashTemplate: pe(r19, e16), lineDashEnding: "NoConstraint", scaleDash: true, offsetAlongLine: null }]), i11.push({ type: "CIMSolidStroke", color: fe(o12.color), capStyle: se(e16), joinStyle: ne2(t13), miterLimit: o12.miterLimit, width: o12.width, effects: n17 });
    }
    if (a15 && "solid" !== a15 && "none" !== a15 && "esriSFSSolid" !== a15 && "esriSFSNull" !== a15) {
      const e16 = { type: "CIMLineSymbol", symbolLayers: [{ type: "CIMSolidStroke", color: fe(t12), capStyle: U.Butt, joinStyle: w2.Miter, width: 0.75 }] };
      let o13 = 0;
      const s13 = e3(de(a15) ? 8 : 10);
      switch (a15) {
        case "vertical":
        case "esriSFSVertical":
          o13 = 90;
          break;
        case "forward-diagonal":
        case "esriSFSForwardDiagonal":
        case "diagonal-cross":
        case "esriSFSDiagonalCross":
          o13 = -45;
          break;
        case "backward-diagonal":
        case "esriSFSBackwardDiagonal":
          o13 = 45;
          break;
        case "cross":
        case "esriSFSCross":
          o13 = 0;
      }
      i11.push({ type: "CIMHatchFill", lineSymbol: e16, offsetX: 0, offsetY: 0, rotation: o13, separation: s13 }), "cross" === a15 || "esriSFSCross" === a15 ? i11.push({ type: "CIMHatchFill", lineSymbol: y(e16), offsetX: 0, offsetY: 0, rotation: 90, separation: s13 }) : "diagonal-cross" !== a15 && "esriSFSDiagonalCross" !== a15 || i11.push({ type: "CIMHatchFill", lineSymbol: y(e16), offsetX: 0, offsetY: 0, rotation: 45, separation: s13 });
    } else
      !a15 || "solid" !== a15 && "esriSFSSolid" !== a15 || i11.push({ type: "CIMSolidFill", enable: true, color: fe(t12) });
    return s12;
  }
  static fromSimpleLineSymbol(e15) {
    const { cap: t12, color: r19, join: a15, marker: o12, miterLimit: i11, style: s12, width: n17 } = e15;
    let l12 = null;
    "solid" !== s12 && "none" !== s12 && "esriSLSSolid" !== s12 && "esriSLSNull" !== s12 && (l12 = [{ type: "CIMGeometricEffectDashes", dashTemplate: pe(s12, t12), lineDashEnding: "NoConstraint", scaleDash: true, offsetAlongLine: null }]);
    const c11 = [];
    if (o12) {
      let e16;
      switch (o12.placement) {
        case "begin-end":
          e16 = o3.Both;
          break;
        case "begin":
          e16 = o3.JustBegin;
          break;
        case "end":
          e16 = o3.JustEnd;
          break;
        default:
          e16 = o3.None;
      }
      const t13 = oe2.fromSimpleMarker(o12, n17, r19).symbolLayers[0];
      t13.markerPlacement = { type: "CIMMarkerPlacementAtExtremities", angleToLine: true, offset: 0, extremityPlacement: e16, offsetAlongLine: 0 }, c11.push(t13);
    }
    return "none" !== s12 && "esriSLSNull" !== s12 && c11.push({ type: "CIMSolidStroke", color: fe(r19), capStyle: se(t12), joinStyle: ne2(a15), miterLimit: i11, width: n17, effects: l12 }), { type: "CIMLineSymbol", symbolLayers: c11 };
  }
  static fromPictureMarker(e15) {
    const { angle: t12, height: r19, width: a15, xoffset: o12, yoffset: i11 } = e15;
    let s12 = e15.url;
    return "esriPMS" === e15.type && e15.imageData && (s12 = e15.imageData), { type: "CIMPointSymbol", symbolLayers: [{ type: "CIMPictureMarker", invertBackfaceTexture: false, scaleX: 1, textureFilter: ie.Picture, tintColor: null, url: s12, size: r19, width: a15, offsetX: b(o12), offsetY: b(i11), rotation: b(-t12) }] };
  }
  static fromSimpleMarker(e15, t12, r19) {
    var _a;
    const { style: a15 } = e15, o12 = (_a = e15.color) != null ? _a : r19;
    if ("path" === a15) {
      const t13 = [];
      if ("outline" in e15 && e15.outline) {
        const r21 = e15.outline;
        t13.push({ type: "CIMSolidStroke", enable: true, width: u3(Math.round(e3(r21.width))), color: fe(r21.color) });
      }
      t13.push({ type: "CIMSolidFill", enable: true, color: fe(o12), path: e15.path });
      const [r20, a16] = Me("square");
      return { type: "CIMPointSymbol", symbolLayers: [{ type: "CIMVectorMarker", enable: true, rotation: b(-e15.angle), size: b(e15.size || 6), offsetX: b(e15.xoffset), offsetY: b(e15.yoffset), frame: r20, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: a16, symbol: { type: "CIMPolygonSymbol", symbolLayers: t13 } }] }] };
    }
    const [i11, s12] = Me(a15);
    let c11;
    if (s12 && i11) {
      const r20 = [];
      if ("outline" in e15 && e15.outline) {
        const t13 = e15.outline;
        r20.push({ type: "CIMSolidStroke", enable: true, width: t13.width > 0.667 ? u3(Math.round(e3(t13.width))) : t13.width, color: fe(t13.color) });
      } else
        !t12 || "line-marker" !== e15.type || "cross" !== e15.style && "x" !== e15.style || r20.push({ type: "CIMSolidStroke", enable: true, width: t12, color: fe(o12) });
      r20.push({ type: "CIMSolidFill", enable: true, color: fe(o12) });
      const a16 = { type: "CIMPolygonSymbol", symbolLayers: r20 };
      c11 = { type: "CIMPointSymbol", symbolLayers: [{ type: "CIMVectorMarker", enable: true, rotation: b(-e15.angle), size: b(e15.size || 6 * t12), offsetX: b(e15.xoffset), offsetY: b(e15.yoffset), frame: i11, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: s12, symbol: a16 }] }] };
    }
    return c11;
  }
  static fromCIMHatchFill(e15, t12) {
    var _a;
    const a15 = t12 * ((_a = e15.separation) != null ? _a : U3), o12 = a15 / 2, i11 = 4, s12 = y(e15.lineSymbol);
    let n17 = this._getLineSymbolPeriod(s12) || i11;
    for (; n17 < i11; )
      n17 *= 2;
    const l12 = n17 / 2, c11 = { xmin: -l12, xmax: l12, ymin: -o12, ymax: o12 }, f9 = s12.symbolLayers.find((e16) => "CIMSolidStroke" === e16.type);
    f9 && (f9.width *= t12);
    return { type: "CIMVectorMarker", frame: c11, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: { paths: [[[-l12, 0], [l12, 0]]] }, symbol: s12 }], size: a15 };
  }
  static fetchResources(e15, t12, r19) {
    if (e15 && t12)
      switch (e15.type) {
        case "CIMPointSymbol":
        case "CIMLineSymbol":
        case "CIMPolygonSymbol": {
          const a15 = e15.symbolLayers;
          if (!a15)
            return;
          for (const e16 of a15)
            switch (Ce(e16, t12, r19), e16.type) {
              case "CIMPictureFill":
              case "CIMHatchFill":
              case "CIMGradientFill":
              case "CIMPictureStroke":
              case "CIMGradientStroke":
              case "CIMCharacterMarker":
              case "CIMPictureMarker":
                "url" in e16 && e16.url && r19.push(t12.fetchResource(e16.url, null));
                break;
              case "CIMVectorMarker": {
                const a16 = e16.markerGraphics;
                if (!a16)
                  continue;
                for (const e17 of a16)
                  if (e17) {
                    const a17 = e17.symbol;
                    a17 && oe2.fetchResources(a17, t12, r19);
                  }
              }
            }
        }
      }
  }
  static _getLineSymbolPeriod(e15) {
    if (e15) {
      const t12 = this._getEffectsRepeat(e15.effects);
      if (t12)
        return t12;
      if (e15.symbolLayers) {
        for (const r19 of e15.symbolLayers)
          if (r19) {
            const e16 = this._getEffectsRepeat(r19.effects);
            if (e16)
              return e16;
            switch (r19.type) {
              case "CIMCharacterMarker":
              case "CIMPictureMarker":
              case "CIMVectorMarker":
              case "CIMObjectMarker3D":
              case "CIMglTFMarker3D": {
                const e17 = this._getPlacementRepeat(r19.markerPlacement);
                if (e17)
                  return e17;
              }
            }
          }
      }
    }
    return 0;
  }
  static _getEffectsRepeat(e15) {
    if (e15) {
      for (const t12 of e15)
        if (t12)
          switch (t12.type) {
            case "CIMGeometricEffectDashes": {
              const e16 = t12.dashTemplate;
              if (e16 && e16.length) {
                let t13 = 0;
                for (const r19 of e16)
                  t13 += r19;
                return 1 & e16.length && (t13 *= 2), t13;
              }
              break;
            }
            case "CIMGeometricEffectWave":
              return t12.period;
            default:
              K3.error(`unsupported geometric effect type ${t12.type}`);
          }
    }
    return 0;
  }
  static _getPlacementRepeat(e15) {
    if (e15)
      switch (e15.type) {
        case "CIMMarkerPlacementAlongLineSameSize":
        case "CIMMarkerPlacementAlongLineRandomSize":
        case "CIMMarkerPlacementAlongLineVariableSize": {
          const t12 = e15.placementTemplate;
          if (t12 && t12.length) {
            let e16 = 0;
            for (const r19 of t12)
              e16 += r19;
            return 1 & t12.length && (e16 *= 2), e16;
          }
          break;
        }
      }
    return 0;
  }
  static fromCIMInsidePolygon(e15) {
    var _a;
    const t12 = e15.markerPlacement, r19 = { type: e15.type, ...e15 };
    r19.markerPlacement = null, r19.anchorPoint = null;
    const a15 = Math.abs(t12.stepX), o12 = Math.abs(t12.stepY), i11 = ((_a = t12.randomness) != null ? _a : 100) / 100;
    let n17, c11, f9, m8;
    if ("Random" === t12.gridType) {
      const e16 = e3(dt), r20 = Math.max(Math.floor(e16 / a15), 1), y7 = Math.max(Math.floor(e16 / o12), 1);
      n17 = r20 * a15 / 2, c11 = y7 * o12 / 2, f9 = 2 * c11;
      const h8 = new t2(t12.seed), p6 = i11 * a15 / 1.5, u14 = i11 * o12 / 1.5;
      m8 = [];
      for (let t13 = 0; t13 < r20; t13++)
        for (let e17 = 0; e17 < y7; e17++) {
          const r21 = t13 * a15 - n17 + p6 * (0.5 - h8.getFloat()), i12 = e17 * o12 - c11 + u14 * (0.5 - h8.getFloat());
          m8.push({ x: r21, y: i12 }), 0 === t13 && m8.push({ x: r21 + 2 * n17, y: i12 }), 0 === e17 && m8.push({ x: r21, y: i12 + 2 * c11 });
        }
    } else
      true === t12.shiftOddRows ? (n17 = a15 / 2, c11 = o12, f9 = 2 * o12, m8 = [{ x: -n17, y: 0 }, { x: n17, y: 0 }, { x: 0, y: c11 }, { x: 0, y: -c11 }]) : (n17 = a15 / 2, c11 = o12 / 2, f9 = o12, m8 = [{ x: -a15, y: 0 }, { x: 0, y: -o12 }, { x: -a15, y: -o12 }, { x: 0, y: 0 }, { x: a15, y: 0 }, { x: 0, y: o12 }, { x: a15, y: o12 }, { x: -a15, y: o12 }, { x: a15, y: -o12 }]);
    return { type: "CIMVectorMarker", frame: { xmin: -n17, xmax: n17, ymin: -c11, ymax: c11 }, markerGraphics: m8.map((e16) => ({ type: "CIMMarkerGraphic", geometry: e16, symbol: { type: "CIMPointSymbol", symbolLayers: [r19] } })), size: f9 };
  }
  static getSize(e15) {
    if (e15)
      switch (e15.type) {
        case "CIMTextSymbol":
          return e15.height;
        case "CIMPointSymbol": {
          let t12 = 0;
          if (e15.symbolLayers) {
            for (const r19 of e15.symbolLayers)
              if (r19)
                switch (r19.type) {
                  case "CIMCharacterMarker":
                  case "CIMPictureMarker":
                  case "CIMVectorMarker":
                  case "CIMObjectMarker3D":
                  case "CIMglTFMarker3D": {
                    const e16 = r19.size;
                    e16 > t12 && (t12 = e16);
                    break;
                  }
                }
          }
          return t12;
        }
        case "CIMLineSymbol":
        case "CIMPolygonSymbol": {
          let t12 = 0;
          if (e15.symbolLayers) {
            for (const r19 of e15.symbolLayers)
              if (r19)
                switch (r19.type) {
                  case "CIMSolidStroke":
                  case "CIMPictureStroke":
                  case "CIMGradientStroke": {
                    const e16 = r19.width;
                    e16 > t12 && (t12 = e16);
                    break;
                  }
                  case "CIMCharacterMarker":
                  case "CIMPictureMarker":
                  case "CIMVectorMarker":
                  case "CIMObjectMarker3D":
                  case "CIMglTFMarker3D":
                    if (m2(r19.markerPlacement)) {
                      const e16 = r19.size;
                      e16 > t12 && (t12 = e16);
                    }
                }
          }
          return t12;
        }
      }
  }
  static getMarkerScaleRatio(e15) {
    if (e15 && "CIMVectorMarker" === e15.type) {
      if (false !== e15.scaleSymbolsProportionally && e15.frame) {
        const t12 = e15.frame.ymax - e15.frame.ymin;
        return e15.size / t12;
      }
    }
    return 1;
  }
};
var ie2 = class {
  static findApplicableOverrides(e15, t12, r19) {
    if (e15 && t12) {
      if (e15.primitiveName) {
        let a15 = false;
        for (const t13 of r19)
          if (t13.primitiveName === e15.primitiveName) {
            a15 = true;
            break;
          }
        if (!a15)
          for (const o12 of t12)
            o12.primitiveName === e15.primitiveName && r19.push(o12);
      }
      switch (e15.type) {
        case "CIMPointSymbol":
        case "CIMLineSymbol":
        case "CIMPolygonSymbol":
          if (e15.effects)
            for (const a15 of e15.effects)
              ie2.findApplicableOverrides(a15, t12, r19);
          if (e15.symbolLayers)
            for (const a15 of e15.symbolLayers)
              ie2.findApplicableOverrides(a15, t12, r19);
          break;
        case "CIMTextSymbol":
          break;
        case "CIMSolidStroke":
        case "CIMPictureStroke":
        case "CIMGradientStroke":
        case "CIMSolidFill":
        case "CIMPictureFill":
        case "CIMHatchFill":
        case "CIMGradientFill":
        case "CIMVectorMarker":
        case "CIMCharacterMarker":
        case "CIMPictureMarker":
          if (e15.effects)
            for (const a15 of e15.effects)
              ie2.findApplicableOverrides(a15, t12, r19);
          if (e15.markerPlacement && ie2.findApplicableOverrides(e15.markerPlacement, t12, r19), "CIMVectorMarker" === e15.type) {
            if (e15.markerGraphics)
              for (const a15 of e15.markerGraphics)
                ie2.findApplicableOverrides(a15, t12, r19), ie2.findApplicableOverrides(a15.symbol, t12, r19);
          } else
            "CIMCharacterMarker" === e15.type ? ie2.findApplicableOverrides(e15.symbol, t12, r19) : "CIMHatchFill" === e15.type ? ie2.findApplicableOverrides(e15.lineSymbol, t12, r19) : "CIMPictureMarker" === e15.type && ie2.findApplicableOverrides(e15.animatedSymbolProperties, t12, r19);
      }
    }
  }
  static findEffectOverrides(e15, t12, r19) {
    var _a;
    if (!t12 || !e15)
      return;
    const a15 = e15.length;
    for (let o12 = 0; o12 < a15; o12++) {
      const a16 = (_a = e15[o12]) == null ? void 0 : _a.primitiveName;
      if (a16) {
        let e16 = false;
        for (const t13 of r19)
          if (t13.primitiveName === a16) {
            e16 = true;
            break;
          }
        if (!e16)
          for (const o13 of t12)
            o13.primitiveName === a16 && r19.push(o13);
      }
    }
  }
  static async resolveSymbolOverrides(e15, t12, a15, o12, i11, s12, n17) {
    if (!e15 || !e15.symbol)
      return null;
    let { symbol: l12, primitiveOverrides: c11 } = e15;
    const f9 = !!c11;
    if (!f9 && !o12)
      return l12;
    l12 = y(l12);
    let m8 = true;
    if (t12 || (t12 = { attributes: {} }, m8 = false), f9) {
      if (m8 || (c11 = c11.filter((e16) => {
        var _a;
        return !((_a = e16.valueExpressionInfo) == null ? void 0 : _a.expression.includes("$feature"));
      })), n17 || (c11 = c11.filter((e16) => {
        var _a;
        return !((_a = e16.valueExpressionInfo) == null ? void 0 : _a.expression.includes("$view"));
      })), c11.length > 0) {
        const e16 = F(t12.attributes);
        await ie2.evaluateOverrides(c11, t12, { spatialReference: a15, fields: e16, geometryType: i11 }, s12, n17);
      }
      ie2.applyOverrides(l12, c11);
    }
    return o12 && ie2.applyDictionaryTextOverrides(l12, t12, o12), l12;
  }
  static async evaluateOverrides(e15, t12, r19, a15, o12) {
    if (!t12)
      return;
    let i11;
    for (const s12 of e15) {
      const e16 = s12.valueExpressionInfo;
      if (e16 && r19) {
        i11 || (i11 = []), s12.value = void 0;
        const n17 = o4(e16.expression, r19.spatialReference, r19.fields).then((e17) => {
          s12.value = i5(e17, t12, { $view: o12 }, r19.geometryType, a15);
        });
        i11.push(n17);
      }
    }
    void 0 !== i11 && i11.length > 0 && await Promise.all(i11);
  }
  static applyDictionaryTextOverrides(e15, t12, r19, a15 = "Normal") {
    if (e15 && e15.type)
      switch (e15.type) {
        case "CIMPointSymbol":
        case "CIMLineSymbol":
        case "CIMPolygonSymbol":
        case "CIMTextSymbol":
          {
            const o12 = e15.symbolLayers;
            if (!o12)
              return;
            for (const i11 of o12)
              i11 && "CIMVectorMarker" === i11.type && ie2.applyDictionaryTextOverrides(i11, t12, r19, "CIMTextSymbol" === e15.type ? e15.textCase : a15);
          }
          break;
        case "CIMVectorMarker":
          {
            const a16 = e15.markerGraphics;
            if (!a16)
              return;
            for (const e16 of a16)
              e16 && ie2.applyDictionaryTextOverrides(e16, t12, r19);
          }
          break;
        case "CIMMarkerGraphic": {
          const o12 = e15.textString;
          if (o12 && o12.includes("[")) {
            const i11 = i2(o12, r19);
            e15.textString = l3(t12, i11, a15);
          }
        }
      }
  }
  static applyOverrides(e15, t12, r19, a15) {
    if (e15.primitiveName) {
      for (const i11 of t12)
        if (i11.primitiveName === e15.primitiveName) {
          const t13 = Se(i11.propertyName);
          if (a15 && a15.push({ cim: e15, nocapPropertyName: t13, value: e15[t13] }), i11.expression && (i11.value = ie2.toValue(i11.propertyName, i11.expression)), r19) {
            let t14 = false;
            for (const a16 of r19)
              a16.primitiveName === e15.primitiveName && (t14 = true);
            t14 || r19.push(i11);
          }
          r(i11.value) && (e15[t13] = i11.value);
        }
    }
    switch (e15.type) {
      case "CIMPointSymbol":
      case "CIMLineSymbol":
      case "CIMPolygonSymbol":
        if (e15.effects)
          for (const o12 of e15.effects)
            ie2.applyOverrides(o12, t12, r19, a15);
        if (e15.symbolLayers)
          for (const o12 of e15.symbolLayers)
            ie2.applyOverrides(o12, t12, r19, a15);
        break;
      case "CIMTextSymbol":
        break;
      case "CIMSolidStroke":
      case "CIMSolidFill":
      case "CIMVectorMarker":
        if (e15.effects)
          for (const o12 of e15.effects)
            ie2.applyOverrides(o12, t12, r19, a15);
        if ("CIMVectorMarker" === e15.type && e15.markerGraphics)
          for (const o12 of e15.markerGraphics)
            ie2.applyOverrides(o12, t12, r19, a15), ie2.applyOverrides(o12.symbol, t12, r19, a15);
    }
  }
  static restoreOverrides(e15) {
    for (const t12 of e15)
      t12.cim[t12.nocapPropertyName] = t12.value;
  }
  static buildOverrideKey(e15) {
    let t12 = "";
    for (const r19 of e15)
      void 0 !== r19.value && (t12 += `${r19.primitiveName}${r19.propertyName}${JSON.stringify(r19.value)}`);
    return t12;
  }
  static toValue(t12, r19) {
    if ("DashTemplate" === t12)
      return r19.split(" ").map((e15) => Number(e15));
    if ("Color" === t12) {
      const t13 = new l(r19).toRgba();
      return t13[3] *= 255, t13;
    }
    return r19;
  }
};
var se = (e15) => {
  if (!e15)
    return U.Butt;
  switch (e15) {
    case "butt":
      return U.Butt;
    case "square":
      return U.Square;
    case "round":
      return U.Round;
  }
};
var ne2 = (e15) => {
  if (!e15)
    return w2.Miter;
  switch (e15) {
    case "miter":
      return w2.Miter;
    case "round":
      return w2.Round;
    case "bevel":
      return w2.Bevel;
  }
};
var le = (e15) => {
  if (t(e15))
    return "Center";
  switch (e15) {
    case "left":
      return "Left";
    case "right":
      return "Right";
    case "center":
      return "Center";
  }
};
var ce = (e15) => {
  if (t(e15))
    return "Center";
  switch (e15) {
    case "baseline":
      return "Baseline";
    case "top":
      return "Top";
    case "middle":
      return "Center";
    case "bottom":
      return "Bottom";
  }
};
var fe = (e15) => {
  if (!e15)
    return [0, 0, 0, 0];
  const { r: t12, g: r19, b: a15, a: o12 } = e15;
  return [t12, r19, a15, 255 * o12];
};
var me = (e15, t12) => {
  const r19 = ye(t12), a15 = he(e15);
  return r19 && a15 ? `${r19}-${a15}` : `${r19}${a15}`;
};
var ye = (e15) => {
  if (!e15)
    return "";
  switch (e15.toLowerCase()) {
    case "bold":
    case "bolder":
      return "bold";
  }
  return "";
};
var he = (e15) => {
  if (!e15)
    return "";
  switch (e15.toLowerCase()) {
    case "italic":
    case "oblique":
      return "italic";
  }
  return "";
};
var pe = (e15, t12) => {
  const r19 = "butt" === t12;
  switch (e15) {
    case "dash":
    case "esriSLSDash":
      return r19 ? [4, 3] : [3, 4];
    case "dash-dot":
    case "esriSLSDashDot":
      return r19 ? [4, 3, 1, 3] : [3, 4, 0, 4];
    case "dot":
    case "esriSLSDot":
      return r19 ? [1, 3] : [0, 4];
    case "long-dash":
    case "esriSLSLongDash":
      return r19 ? [8, 3] : [7, 4];
    case "long-dash-dot":
    case "esriSLSLongDashDot":
      return r19 ? [8, 3, 1, 3] : [7, 4, 0, 4];
    case "long-dash-dot-dot":
    case "esriSLSDashDotDot":
      return r19 ? [8, 3, 1, 3, 1, 3] : [7, 4, 0, 4, 0, 4];
    case "short-dash":
    case "esriSLSShortDash":
      return r19 ? [4, 1] : [3, 2];
    case "short-dash-dot":
    case "esriSLSShortDashDot":
      return r19 ? [4, 1, 1, 1] : [3, 2, 0, 2];
    case "short-dash-dot-dot":
    case "esriSLSShortDashDotDot":
      return r19 ? [4, 1, 1, 1, 1, 1] : [3, 2, 0, 2, 0, 2];
    case "short-dot":
    case "esriSLSShortDot":
      return r19 ? [1, 1] : [0, 2];
    case "solid":
    case "esriSLSSolid":
    case "none":
      return K3.error("Unexpected: style does not require rasterization"), [0, 0];
    default:
      return K3.error(`Tried to rasterize SLS, but found an unexpected style: ${e15}!`), [0, 0];
  }
};
function ue(e15) {
  return void 0 !== e15.symbolLayers;
}
var Me = (e15) => {
  const t12 = 100, r19 = 50;
  let a15, o12;
  const i11 = e15;
  if ("circle" === i11 || "esriSMSCircle" === i11) {
    const e16 = 0.25;
    let t13 = Math.acos(1 - e16 / r19), i12 = Math.ceil(Y3 / t13 / 4);
    0 === i12 && (i12 = 1), t13 = $2 / i12, i12 *= 4;
    const s12 = [];
    s12.push([r19, 0]);
    for (let a16 = 1; a16 < i12; a16++)
      s12.push([r19 * Math.cos(a16 * t13), -r19 * Math.sin(a16 * t13)]);
    s12.push([r19, 0]), a15 = { rings: [s12] }, o12 = { xmin: -r19, ymin: -r19, xmax: r19, ymax: r19 };
  } else if ("cross" === i11 || "esriSMSCross" === i11) {
    const e16 = 0;
    a15 = { rings: [[[e16, r19], [e16, e16], [r19, e16], [r19, -e16], [e16, -e16], [e16, -r19], [-e16, -r19], [-e16, -e16], [-r19, -e16], [-r19, e16], [-e16, e16], [-e16, r19], [e16, r19]]] }, o12 = { xmin: -r19, ymin: -r19, xmax: r19, ymax: r19 };
  } else if ("diamond" === i11 || "esriSMSDiamond" === i11)
    a15 = { rings: [[[-r19, 0], [0, r19], [r19, 0], [0, -r19], [-r19, 0]]] }, o12 = { xmin: -r19, ymin: -r19, xmax: r19, ymax: r19 };
  else if ("square" === i11 || "esriSMSSquare" === i11)
    a15 = { rings: [[[-r19, -r19], [-r19, r19], [r19, r19], [r19, -r19], [-r19, -r19]]] }, o12 = { xmin: -r19, ymin: -r19, xmax: r19, ymax: r19 };
  else if ("x" === i11 || "esriSMSX" === i11) {
    const e16 = 0;
    a15 = { rings: [[[0, e16], [r19 - e16, r19], [r19, r19 - e16], [e16, 0], [r19, e16 - r19], [r19 - e16, -r19], [0, -e16], [e16 - r19, -r19], [-r19, e16 - r19], [-e16, 0], [-r19, r19 - e16], [e16 - r19, r19], [0, e16]]] }, o12 = { xmin: -r19, ymin: -r19, xmax: r19, ymax: r19 };
  } else if ("triangle" === i11 || "esriSMSTriangle" === i11) {
    const e16 = t12 * 0.5773502691896257, r20 = -e16, i12 = 2 / 3 * t12, s12 = i12 - t12;
    a15 = { rings: [[[r20, s12], [0, i12], [e16, s12], [r20, s12]]] }, o12 = { xmin: r20, ymin: s12, xmax: e16, ymax: i12 };
  } else
    "arrow" === i11 && (a15 = { rings: [[[-50, 50], [50, 0], [-50, -50], [-33, -20], [-33, 20], [-50, 50]]] }, o12 = { xmin: -r19, ymin: -r19, xmax: r19, ymax: r19 });
  return [o12, a15];
};
var de = (e15) => "vertical" === e15 || "horizontal" === e15 || "cross" === e15 || "esriSFSCross" === e15 || "esriSFSVertical" === e15 || "esriSFSHorizontal" === e15;
var Se = (e15) => e15 ? e15.charAt(0).toLowerCase() + e15.substr(1) : e15;
var be;
function Ce(e15, t12, r19) {
  if (!e15.effects || r(t12.geometryEngine))
    return;
  if (be)
    return void r19.push(be);
  d(e15.effects) && (be = p(), r19.push(be), be.then((e16) => t12.geometryEngine = e16));
}

// node_modules/@arcgis/core/symbols/cim/quantizeTime.js
var t11 = 0.05;
function n15(n17) {
  return Math.max(Math.round(n17 / t11), 1) * t11;
}
var e12 = /* @__PURE__ */ new Set(["StartTimeOffset", "Duration", "RepeatDelay"]);
function a13(t12, a15) {
  return e12.has(a15) ? n15(t12) : t12;
}

// node_modules/@arcgis/core/symbols/cim/SDFHelper.js
function r17(t12) {
  var _a;
  if (!t12)
    return null;
  switch (t12.type) {
    case "CIMPointSymbol": {
      const o12 = t12.symbolLayers;
      return o12 && 1 === o12.length ? r17(o12[0]) : null;
    }
    case "CIMVectorMarker": {
      const o12 = t12.markerGraphics;
      if (!o12 || 1 !== o12.length)
        return null;
      const n17 = o12[0];
      if (!n17)
        return null;
      const r19 = n17.geometry;
      if (!r19)
        return null;
      const l12 = n17.symbol;
      return !l12 || "CIMPolygonSymbol" !== l12.type && "CIMLineSymbol" !== l12.type || ((_a = l12.symbolLayers) == null ? void 0 : _a.some((t13) => !!t13.effects)) ? null : { geom: r19, asFill: "CIMPolygonSymbol" === l12.type };
    }
    case "sdf":
      return { geom: t12.geom, asFill: t12.asFill };
  }
  return null;
}
function l11(t12) {
  return t12 ? t12.rings ? t12.rings : t12.paths ? t12.paths : void 0 !== t12.xmin && void 0 !== t12.ymin && void 0 !== t12.xmax && void 0 !== t12.ymax ? [[[t12.xmin, t12.ymin], [t12.xmin, t12.ymax], [t12.xmax, t12.ymax], [t12.xmax, t12.ymin], [t12.xmin, t12.ymin]]] : null : null;
}
function e13(t12) {
  let o12 = 1 / 0, r19 = -1 / 0, l12 = 1 / 0, e15 = -1 / 0;
  for (const n17 of t12)
    for (const t13 of n17)
      t13[0] < o12 && (o12 = t13[0]), t13[0] > r19 && (r19 = t13[0]), t13[1] < l12 && (l12 = t13[1]), t13[1] > e15 && (e15 = t13[1]);
  return new t10(o12, l12, r19 - o12, e15 - l12);
}
function s11(t12) {
  let o12 = 1 / 0, n17 = -1 / 0, r19 = 1 / 0, l12 = -1 / 0;
  for (const e15 of t12)
    for (const t13 of e15)
      t13[0] < o12 && (o12 = t13[0]), t13[0] > n17 && (n17 = t13[0]), t13[1] < r19 && (r19 = t13[1]), t13[1] > l12 && (l12 = t13[1]);
  return [o12, r19, n17, l12];
}
function i10(t12) {
  return t12 ? t12.rings ? s11(t12.rings) : t12.paths ? s11(t12.paths) : u2(t12) ? [t12.xmin, t12.ymin, t12.xmax, t12.ymax] : null : null;
}
function f7(t12, o12, n17, r19, l12) {
  const [e15, s12, i11, f9] = t12;
  if (i11 < e15 || f9 < s12)
    return [0, 0, 0];
  const a15 = i11 - e15, m8 = f9 - s12, u14 = 128, c11 = 1, h8 = Math.floor(0.5 * (0.5 * u14 - c11)), y7 = (u14 - 2 * (h8 + c11)) / Math.max(a15, m8), x5 = Math.round(a15 * y7) + 2 * h8, M4 = Math.round(m8 * y7) + 2 * h8;
  let g8 = 1;
  if (o12) {
    g8 = M4 / y7 / (o12.ymax - o12.ymin);
  }
  let p6 = 0, d4 = 0, b5 = 1;
  r19 && (l12 ? o12 && n17 && o12.ymax - o12.ymin > 0 && (b5 = (o12.xmax - o12.xmin) / (o12.ymax - o12.ymin), p6 = r19.x / (n17 * b5), d4 = r19.y / n17) : (p6 = r19.x, d4 = r19.y)), p6 = 0.5 * (o12.xmax + o12.xmin) + p6 * (o12.xmax - o12.xmin), d4 = 0.5 * (o12.ymax + o12.ymin) + d4 * (o12.ymax - o12.ymin), p6 -= e15, d4 -= s12, p6 *= y7, d4 *= y7, p6 += h8, d4 += h8;
  let w6 = p6 / x5 - 0.5, F3 = d4 / M4 - 0.5;
  return l12 && (w6 *= n17 * b5, F3 *= n17), [g8, w6, F3];
}
function a14(t12) {
  const o12 = l11(t12.geom), n17 = e13(o12), r19 = 128, s12 = 1, i11 = Math.floor(0.5 * (0.5 * r19 - s12)), f9 = (r19 - 2 * (i11 + s12)) / Math.max(n17.width, n17.height), a15 = Math.round(n17.width * f9) + 2 * i11, h8 = Math.round(n17.height * f9) + 2 * i11, y7 = [];
  for (const l12 of o12)
    if (l12 && l12.length > 1) {
      const o13 = [];
      for (const r20 of l12) {
        let [l13, e15] = r20;
        l13 -= n17.x, e15 -= n17.y, l13 *= f9, e15 *= f9, l13 += i11 - 0.5, e15 += i11 - 0.5, t12.asFill ? o13.push([l13, e15]) : o13.push([Math.round(l13), Math.round(e15)]);
      }
      if (t12.asFill) {
        const t13 = o13.length - 1;
        o13[0][0] === o13[t13][0] && o13[0][1] === o13[t13][1] || o13.push(o13[0]);
      }
      y7.push(o13);
    }
  const x5 = m7(y7, a15, h8, i11);
  return t12.asFill && u13(y7, a15, h8, i11, x5), [c9(x5, i11), a15, h8];
}
function m7(t12, o12, n17, r19) {
  const l12 = o12 * n17, e15 = new Array(l12), s12 = r19 * r19 + 1;
  for (let i11 = 0; i11 < l12; ++i11)
    e15[i11] = s12;
  for (const i11 of t12) {
    const t13 = i11.length;
    for (let l13 = 1; l13 < t13; ++l13) {
      const t14 = i11[l13 - 1], s13 = i11[l13];
      let f9, a15, m8, u14;
      t14[0] < s13[0] ? (f9 = t14[0], a15 = s13[0]) : (f9 = s13[0], a15 = t14[0]), t14[1] < s13[1] ? (m8 = t14[1], u14 = s13[1]) : (m8 = s13[1], u14 = t14[1]);
      let c11 = Math.floor(f9) - r19, h8 = Math.floor(a15) + r19, y7 = Math.floor(m8) - r19, x5 = Math.floor(u14) + r19;
      c11 < 0 && (c11 = 0), h8 > o12 && (h8 = o12), y7 < 0 && (y7 = 0), x5 > n17 && (x5 = n17);
      const M4 = s13[0] - t14[0], g8 = s13[1] - t14[1], p6 = M4 * M4 + g8 * g8;
      for (let r20 = c11; r20 < h8; r20++)
        for (let l14 = y7; l14 < x5; l14++) {
          let i12, f10, a16 = (r20 - t14[0]) * M4 + (l14 - t14[1]) * g8;
          a16 < 0 ? (i12 = t14[0], f10 = t14[1]) : a16 > p6 ? (i12 = s13[0], f10 = s13[1]) : (a16 /= p6, i12 = t14[0] + a16 * M4, f10 = t14[1] + a16 * g8);
          const m9 = (r20 - i12) * (r20 - i12) + (l14 - f10) * (l14 - f10), u15 = (n17 - l14 - 1) * o12 + r20;
          m9 < e15[u15] && (e15[u15] = m9);
        }
    }
  }
  for (let i11 = 0; i11 < l12; ++i11)
    e15[i11] = Math.sqrt(e15[i11]);
  return e15;
}
function u13(t12, o12, n17, r19, l12) {
  for (const e15 of t12) {
    const t13 = e15.length;
    for (let s12 = 1; s12 < t13; ++s12) {
      const t14 = e15[s12 - 1], i11 = e15[s12];
      let f9, a15, m8, u14;
      t14[0] < i11[0] ? (f9 = t14[0], a15 = i11[0]) : (f9 = i11[0], a15 = t14[0]), t14[1] < i11[1] ? (m8 = t14[1], u14 = i11[1]) : (m8 = i11[1], u14 = t14[1]);
      let c11 = Math.floor(f9), h8 = Math.floor(a15) + 1, y7 = Math.floor(m8), x5 = Math.floor(u14) + 1;
      c11 < r19 && (c11 = r19), h8 > o12 - r19 && (h8 = o12 - r19), y7 < r19 && (y7 = r19), x5 > n17 - r19 && (x5 = n17 - r19);
      for (let e16 = y7; e16 < x5; ++e16) {
        if (t14[1] > e16 == i11[1] > e16)
          continue;
        const s13 = (n17 - e16 - 1) * o12;
        for (let o13 = c11; o13 < h8; ++o13)
          o13 < (i11[0] - t14[0]) * (e16 - t14[1]) / (i11[1] - t14[1]) + t14[0] && (l12[s13 + o13] = -l12[s13 + o13]);
        for (let t15 = r19; t15 < c11; ++t15)
          l12[s13 + t15] = -l12[s13 + t15];
      }
    }
  }
}
function c9(o12, n17) {
  const r19 = 2 * n17, l12 = o12.length, e15 = new Uint8Array(4 * l12);
  for (let s12 = 0; s12 < l12; ++s12) {
    const n18 = 0.5 - o12[s12] / r19;
    o6(n18, e15, 4 * s12);
  }
  return e15;
}

// node_modules/@arcgis/core/symbols/cim/effects/CIMEffectHelper.js
var c10 = 96 / 72;
var f8 = class {
  static executeEffects(t12, s12, r19) {
    const f9 = a5(s12), p6 = c10;
    let u14 = new r4(f9);
    for (const e15 of t12) {
      const t13 = A3(e15);
      t13 && (u14 = t13.execute(u14, e15, p6, r19));
    }
    return u14;
  }
  static next(t12) {
    const s12 = t12.next();
    return x2(s12), s12;
  }
  static applyEffects(e15, r19, c11) {
    if (!e15)
      return r19;
    let f9 = new r4(r19);
    for (const t12 of e15) {
      const s12 = A3(t12);
      s12 && (f9 = s12.execute(f9, t12, 1, c11));
    }
    let p6, u14 = null;
    for (; p6 = f9.next(); )
      u14 ? f(u14) ? f(p6) && u14.paths.push(...p6.paths) : y2(u14) && y2(p6) && u14.rings.push(...p6.rings) : u14 = p6;
    return u14;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/grouping.js
function e14(e15, o12) {
  let r19;
  if ("string" == typeof e15)
    r19 = c(e15 + `-seed(${o12})`);
  else {
    let t12 = 12;
    r19 = e15 ^ o12;
    do {
      r19 = 107 * (r19 >> 8 ^ r19) + t12 | 0;
    } while (0 != --t12);
  }
  return (1 + r19 / (1 << 31)) / 2;
}
function o11(t12) {
  return Math.floor(e14(t12, r18) * n16);
}
var r18 = 53290320;
var n16 = 10;

// node_modules/@arcgis/core/symbols/cim/cimAnalyzer.js
var J3 = s.getLogger("esri.symbols.cim.cimAnalyzer");
function H(e15) {
  switch (e15) {
    case "Butt":
      return e4.BUTT;
    case "Square":
      return e4.SQUARE;
    default:
      return e4.ROUND;
  }
}
function Y4(e15) {
  switch (e15) {
    case "Bevel":
      return n2.BEVEL;
    case "Miter":
      return n2.MITER;
    default:
      return n2.ROUND;
  }
}
function $3(e15, t12, i11, o12) {
  let r19;
  e15[t12] ? r19 = e15[t12] : (r19 = {}, e15[t12] = r19), r19[i11] = o12;
}
function E2(e15) {
  const t12 = e15.markerPlacement;
  return t12 && t12.angleToLine ? i3.MAP : i3.SCREEN;
}
async function T3(e15, t12, i11, o12, n17) {
  const l12 = o12 != null ? o12 : [];
  if (!e15)
    return l12;
  let a15, s12;
  const c11 = {};
  if ("CIMSymbolReference" !== e15.type)
    return J3.error("Expect cim type to be 'CIMSymbolReference'"), l12;
  if (a15 = e15.symbol, s12 = e15.primitiveOverrides, s12) {
    const e16 = [];
    for (const i12 of s12) {
      const o13 = i12.valueExpressionInfo;
      if (o13 && t12) {
        const n18 = o13.expression, l13 = o4(n18, t12.spatialReference, t12.fields).then((e17) => {
          t(e17) || $3(c11, i12.primitiveName, i12.propertyName, e17);
        });
        e16.push(l13);
      } else
        null != i12.value && $3(c11, i12.primitiveName, i12.propertyName, i12.value);
    }
    e16.length > 0 && await Promise.all(e16);
  }
  const p6 = [];
  switch (oe2.fetchResources(a15, i11, p6), p6.length > 0 && await Promise.all(p6), a15.type) {
    case "CIMPointSymbol":
    case "CIMLineSymbol":
    case "CIMPolygonSymbol":
      j5(a15, s12, c11, t12, l12, i11, n17);
  }
  return l12;
}
function j5(e15, t12, i11, o12, r19, n17, l12) {
  if (!e15)
    return;
  const a15 = e15.symbolLayers;
  if (!a15)
    return;
  const s12 = e15.effects;
  let f9;
  const c11 = oe2.getSize(e15);
  "CIMPointSymbol" === e15.type && "Map" === e15.angleAlignment && (f9 = i3.MAP);
  let y7 = a15.length;
  for (; y7--; ) {
    const m8 = a15[y7];
    if (!m8 || false === m8.enable)
      continue;
    let u14;
    s12 && s12.length && (u14 = [...s12]);
    const h8 = m8.effects;
    h8 && h8.length && (s12 ? u14.push(...h8) : u14 = [...h8]);
    const g8 = [];
    let d4;
    ie2.findEffectOverrides(u14, t12, g8), d4 = g8.length > 0 ? ae2(u14, g8, i11, o12) : u14;
    const S2 = [];
    switch (ie2.findApplicableOverrides(m8, t12, S2), m8.type) {
      case "CIMSolidFill":
        D(m8, d4, i11, S2, o12, r19);
        break;
      case "CIMPictureFill":
        F2(m8, d4, i11, S2, o12, n17, r19);
        break;
      case "CIMHatchFill":
        U4(m8, d4, i11, S2, o12, r19);
        break;
      case "CIMGradientFill":
        W3(m8, d4, i11, S2, o12, r19);
        break;
      case "CIMSolidStroke":
        G3(m8, d4, i11, S2, o12, r19, "CIMPolygonSymbol" === e15.type, c11);
        break;
      case "CIMPictureStroke":
        B3(m8, d4, i11, S2, o12, r19, "CIMPolygonSymbol" === e15.type, c11);
        break;
      case "CIMGradientStroke":
        q4(m8, d4, i11, S2, o12, r19, "CIMPolygonSymbol" === e15.type, c11);
        break;
      case "CIMCharacterMarker":
        if (V2(m8, d4, i11, S2, o12, r19))
          break;
        break;
      case "CIMPictureMarker":
        if (V2(m8, d4, i11, S2, o12, r19))
          break;
        "CIMLineSymbol" === e15.type && (f9 = E2(m8)), K4(m8, d4, i11, S2, o12, n17, r19, f9, c11);
        break;
      case "CIMVectorMarker":
        if (V2(m8, d4, i11, S2, o12, r19))
          break;
        "CIMLineSymbol" === e15.type && (f9 = E2(m8)), Q3(m8, d4, i11, S2, o12, r19, n17, f9, c11, l12);
        break;
      default:
        J3.error("Cannot analyze CIM layer", m8.type);
    }
  }
}
function D(e15, t12, i11, o12, r19, n17) {
  const l12 = e15.primitiveName, a15 = u5(e15.color), [f9, c11] = pe2(o12, l12, t12, null, null), m8 = c(JSON.stringify(e15) + c11).toString();
  n17.push({ type: "fill", templateHash: m8, materialHash: f9 ? () => m8 : m8, cim: e15, materialOverrides: null, colorLocked: e15.colorLocked, color: ne3(l12, i11, "Color", r19, a15, re2), height: 0, angle: 0, offsetX: 0, offsetY: 0, scaleX: 1, effects: t12, applyRandomOffset: false, sampleAlphaOnly: true });
}
function F2(e15, t12, i11, o12, r19, l12, a15) {
  const f9 = e15.primitiveName, c11 = e15.tintColor ? u5(e15.tintColor) : { r: 255, g: 255, b: 255, a: 1 }, [m8, p6] = pe2(o12, f9, t12, null, null), u14 = c(JSON.stringify(e15) + p6).toString(), y7 = c(`${e15.url}${JSON.stringify(e15.colorSubstitutions)}`).toString();
  let h8 = b(e15.scaleX);
  if ("width" in e15) {
    const t13 = e15.width;
    let i12 = 1;
    const o13 = l12.getResource(e15.url);
    r(o13) && (i12 = o13.width / o13.height), h8 /= i12 * (e15.height / t13);
  }
  a15.push({ type: "fill", templateHash: u14, materialHash: m8 ? () => y7 : y7, cim: e15, materialOverrides: null, colorLocked: e15.colorLocked, effects: t12, color: ne3(f9, i11, "TintColor", r19, c11, re2), height: ne3(f9, i11, "Height", r19, e15.height), scaleX: ne3(f9, i11, "ScaleX", r19, h8), angle: ne3(f9, i11, "Rotation", r19, b(e15.rotation)), offsetX: ne3(f9, i11, "OffsetX", r19, b(e15.offsetX)), offsetY: ne3(f9, i11, "OffsetY", r19, b(e15.offsetY)), url: e15.url, applyRandomOffset: false, sampleAlphaOnly: false });
}
function U4(e15, t12, i11, o12, r19, n17) {
  var _a;
  const l12 = ["Rotation", "OffsetX", "OffsetY"], a15 = o12.filter((t13) => t13.primitiveName !== e15.primitiveName || !l12.includes(t13.propertyName)), f9 = e15.primitiveName, [c11, m8] = pe2(o12, f9, t12, null, null), p6 = c(JSON.stringify(e15) + m8).toString(), u14 = c(`${e15.separation}${JSON.stringify(e15.lineSymbol)}`).toString();
  let y7 = { r: 255, g: 255, b: 255, a: 1 };
  if (e15.lineSymbol) {
    const t13 = (_a = e15.lineSymbol) == null ? void 0 : _a.symbolLayers.find((e16) => "CIMSolidStroke" === e16.type);
    t13 && (y7 = u5(t13.color));
  }
  n17.push({ type: "fill", templateHash: p6, materialHash: c11 ? ce2(u14, i11, a15, r19) : u14, cim: e15, materialOverrides: a15, colorLocked: e15.colorLocked, effects: t12, color: y7, height: ne3(f9, i11, "Separation", r19, e15.separation), scaleX: 1, angle: ne3(f9, i11, "Rotation", r19, b(e15.rotation)), offsetX: ne3(f9, i11, "OffsetX", r19, b(e15.offsetX)), offsetY: ne3(f9, i11, "OffsetY", r19, b(e15.offsetY)), applyRandomOffset: false, sampleAlphaOnly: true });
}
function W3(e15, t12, i11, o12, r19, n17) {
  const l12 = e15.primitiveName, [a15, f9] = pe2(o12, l12, t12, null, null), c11 = c(JSON.stringify(e15) + f9).toString();
  n17.push({ type: "fill", templateHash: c11, materialHash: a15 ? ce2(c11, i11, o12, r19) : c11, cim: e15, materialOverrides: null, colorLocked: e15.colorLocked, effects: t12, color: { r: 128, g: 128, b: 128, a: 1 }, height: 0, angle: 0, offsetX: 0, offsetY: 0, scaleX: 1, applyRandomOffset: false, sampleAlphaOnly: false });
}
function G3(e15, t12, i11, o12, r19, n17, l12, a15) {
  const f9 = e15.primitiveName, c11 = u5(e15.color), m8 = void 0 !== e15.width ? e15.width : 4, p6 = H(e15.capStyle), u14 = Y4(e15.joinStyle), y7 = e15.miterLimit, [h8, g8] = pe2(o12, f9, t12, null, null), d4 = c(JSON.stringify(e15) + g8).toString();
  let S2, N3;
  if (t12 && t12 instanceof Array && t12.length > 0) {
    const e16 = t12[t12.length - 1];
    if ("CIMGeometricEffectDashes" === e16.type && "NoConstraint" === e16.lineDashEnding && null === e16.offsetAlongLine) {
      const e17 = (t12 = [...t12]).pop();
      S2 = e17.dashTemplate, N3 = e17.scaleDash;
    }
  }
  n17.push({ type: "line", templateHash: d4, materialHash: h8 ? () => d4 : d4, cim: e15, materialOverrides: null, isOutline: l12, colorLocked: e15.colorLocked, effects: t12, color: ne3(f9, i11, "Color", r19, c11, re2), width: ne3(f9, i11, "Width", r19, m8), cap: ne3(f9, i11, "CapStyle", r19, p6), join: ne3(f9, i11, "JoinStyle", r19, u14), miterLimit: ne3(f9, i11, "MiterLimit", r19, y7), referenceWidth: a15, zOrder: oe3(e15.name), dashTemplate: S2, scaleDash: N3, sampleAlphaOnly: true });
}
function B3(e15, t12, i11, o12, r19, n17, l12, a15) {
  const f9 = c(`${e15.url}${JSON.stringify(e15.colorSubstitutions)}`).toString(), c11 = e15.primitiveName, m8 = u5(e15.tintColor), p6 = void 0 !== e15.width ? e15.width : 4, u14 = H(e15.capStyle), y7 = Y4(e15.joinStyle), h8 = e15.miterLimit, [g8, d4] = pe2(o12, c11, t12, null, null), S2 = c(JSON.stringify(e15) + d4).toString();
  n17.push({ type: "line", templateHash: S2, materialHash: g8 ? () => f9 : f9, cim: e15, materialOverrides: null, isOutline: l12, colorLocked: e15.colorLocked, effects: t12, color: ne3(c11, i11, "TintColor", r19, m8, re2), width: ne3(c11, i11, "Width", r19, p6), cap: ne3(c11, i11, "CapStyle", r19, u14), join: ne3(c11, i11, "JoinStyle", r19, y7), miterLimit: ne3(c11, i11, "MiterLimit", r19, h8), referenceWidth: a15, zOrder: oe3(e15.name), dashTemplate: null, scaleDash: false, url: e15.url, sampleAlphaOnly: false });
}
function q4(e15, t12, i11, o12, r19, n17, l12, a15) {
  const f9 = e15.primitiveName, c11 = void 0 !== e15.width ? e15.width : 4, m8 = H(e15.capStyle), p6 = Y4(e15.joinStyle), u14 = e15.miterLimit, [y7, h8] = pe2(o12, f9, t12, null, null), g8 = c(JSON.stringify(e15) + h8).toString();
  n17.push({ type: "line", templateHash: g8, materialHash: y7 ? ce2(g8, i11, o12, r19) : g8, cim: e15, materialOverrides: null, isOutline: l12, colorLocked: e15.colorLocked, effects: t12, color: { r: 128, g: 128, b: 128, a: 1 }, width: ne3(f9, i11, "Width", r19, c11), cap: ne3(f9, i11, "CapStyle", r19, m8), join: ne3(f9, i11, "JoinStyle", r19, p6), miterLimit: ne3(f9, i11, "MiterLimit", r19, u14), referenceWidth: a15, zOrder: oe3(e15.name), dashTemplate: null, scaleDash: false, sampleAlphaOnly: false });
}
function V2(e15, t12, i11, o12, r19, n17) {
  const l12 = e15.markerPlacement;
  if (!l12 || "CIMMarkerPlacementInsidePolygon" !== l12.type)
    return false;
  const f9 = l12, c11 = Math.abs(f9.stepX), m8 = Math.abs(f9.stepY);
  if (0 === c11 || 0 === m8)
    return true;
  const p6 = ["Rotation", "OffsetX", "OffsetY"], u14 = o12.filter((t13) => t13.primitiveName !== e15.primitiveName || !p6.includes(t13.propertyName)), y7 = "url" in e15 ? e15.url : null, [h8, g8] = pe2(o12, f9.primitiveName, t12, null, null), d4 = c(JSON.stringify(e15) + g8).toString();
  let S2, b5, O3 = null;
  if ("Random" === l12.gridType) {
    const e16 = e3(dt), t13 = Math.max(Math.floor(e16 / c11), 1), i12 = Math.max(Math.floor(e16 / m8), 1);
    S2 = m8 * i12, O3 = (e17) => e17 ? e17 * i12 : 0;
    b5 = t13 * c11 / S2;
  } else
    l12.shiftOddRows ? (S2 = 2 * m8, O3 = (e16) => e16 ? 2 * e16 : 0, b5 = c11 / m8 * 0.5) : (S2 = m8, O3 = null, b5 = c11 / m8);
  let k4 = { r: 255, g: 255, b: 255, a: 1 };
  return "tintColor" in e15 && (k4 = u5(e15.tintColor)), n17.push({ type: "fill", templateHash: d4, materialHash: h8 ? ce2(d4, i11, u14, r19) : d4, cim: e15, materialOverrides: u14, colorLocked: e15.colorLocked, effects: t12, color: ne3(f9.primitiveName, i11, "TintColor", r19, k4, re2), height: ne3(f9.primitiveName, i11, "StepY", r19, S2, O3), scaleX: b5, angle: ne3(f9.primitiveName, i11, "GridAngle", r19, f9.gridAngle), offsetX: ne3(f9.primitiveName, i11, "OffsetX", r19, b(f9.offsetX)), offsetY: ne3(f9.primitiveName, i11, "OffsetY", r19, b(f9.offsetY)), url: y7, applyRandomOffset: "Random" === l12.gridType, sampleAlphaOnly: !y7 }), true;
}
function K4(e15, t12, i11, o12, r19, l12, a15, f9, c11) {
  var _a;
  const m8 = e15.primitiveName, p6 = b(e15.size);
  let u14 = b(e15.scaleX, 1);
  const y7 = b(e15.rotation), h8 = b(e15.offsetX), g8 = b(e15.offsetY), d4 = e15.tintColor ? u5(e15.tintColor) : { r: 255, g: 255, b: 255, a: 1 }, S2 = c(`${e15.url}${JSON.stringify(e15.colorSubstitutions)}${JSON.stringify(e15.animatedSymbolProperties)}`).toString(), b5 = se2(e15.markerPlacement, o12, i11, r19), O3 = fe2(e15.animatedSymbolProperties, o12, i11, r19), [k4, C5] = pe2(o12, m8, t12, b5, O3), P5 = c(JSON.stringify(e15) + C5).toString(), M4 = (_a = e15.anchorPoint) != null ? _a : { x: 0, y: 0 };
  if ("width" in e15) {
    const t13 = e15.width;
    let i12 = 1;
    const o13 = l12.getResource(e15.url);
    r(o13) && (i12 = o13.width / o13.height), u14 /= i12 * (p6 / t13);
  }
  function L3(e16, t13) {
    return t3(O3, e16, t13);
  }
  const I3 = e15.animatedSymbolProperties && true === e15.animatedSymbolProperties.randomizeStartTime ? (e16, t13, i12, o13) => {
    const r20 = o11(o13), n17 = L3(e16, t13);
    return S2 + `-MATERIALGROUP(${r20})-ASP(${JSON.stringify(n17)})`;
  } : k4 ? (e16, t13) => {
    const i12 = L3(e16, t13);
    return S2 + `-ASP(${JSON.stringify(i12)})`;
  } : S2;
  a15.push({ type: "marker", templateHash: P5, materialHash: I3, cim: e15, materialOverrides: null, colorLocked: e15.colorLocked, effects: t12, scaleSymbolsProportionally: false, alignment: f9, size: ne3(m8, i11, "Size", r19, p6), scaleX: ne3(m8, i11, "ScaleX", r19, u14), rotation: ne3(m8, i11, "Rotation", r19, y7), offsetX: ne3(m8, i11, "OffsetX", r19, h8), offsetY: ne3(m8, i11, "OffsetY", r19, g8), color: ne3(m8, i11, "TintColor", r19, d4, re2), anchorPoint: { x: M4.x, y: -M4.y }, isAbsoluteAnchorPoint: "Relative" !== e15.anchorPointUnits, outlineColor: { r: 0, g: 0, b: 0, a: 0 }, outlineWidth: 0, frameHeight: 0, rotateClockwise: e15.rotateClockwise, referenceSize: c11, sizeRatio: 1, markerPlacement: b5, url: e15.url, animatedSymbolProperties: O3 });
}
function Q3(e15, t12, i11, o12, r19, n17, l12, a15, s12, f9) {
  const c11 = e15.markerGraphics;
  if (!c11)
    return;
  let m8 = 0;
  if (e15.scaleSymbolsProportionally) {
    const t13 = e15.frame;
    t13 && (m8 = t13.ymax - t13.ymin);
  }
  const p6 = se2(e15.markerPlacement, o12, i11, r19);
  for (const u14 of c11)
    if (u14) {
      const c12 = u14.symbol;
      if (!c12)
        continue;
      switch (c12.type) {
        case "CIMPointSymbol":
        case "CIMLineSymbol":
        case "CIMPolygonSymbol":
          Z4(e15, t12, p6, null, u14, o12, i11, r19, n17, l12, a15, s12, m8, f9);
          break;
        case "CIMTextSymbol":
          _3(e15, t12, p6, u14, i11, o12, r19, n17, a15, s12, m8);
      }
    }
}
function _3(e15, i11, o12, r19, n17, l12, a15, f9, c11, m8, u14) {
  const y7 = [];
  ie2.findApplicableOverrides(r19, l12, y7);
  const h8 = r19.geometry;
  if (!("x" in h8) || !("y" in h8))
    return;
  const g8 = r19.symbol, d4 = g2(g8), S2 = S(g8.fontStyleName), z3 = a3(g8.fontFamilyName);
  g8.font = { family: z3, decoration: d4, ...S2 };
  const A4 = e15.frame, R3 = h8.x - 0.5 * (A4.xmin + A4.xmax), x5 = h8.y - 0.5 * (A4.ymin + A4.ymax), J4 = e15.size / u14, H2 = e15.primitiveName, Y5 = b(g8.height) * J4, $4 = b(g8.angle), E3 = b(e15.offsetX) + (b(g8.offsetX) + R3) * J4, T4 = b(e15.offsetY) + (b(g8.offsetY) + x5) * J4, j6 = u5(k(g8));
  let D2 = u5(P(g8)), F3 = L(g8);
  F3 || (D2 = u5(k(g8.haloSymbol)), F3 = g8.haloSize * J4);
  const [U5, W4] = pe2(l12, H2, i11, o12, null), G4 = JSON.stringify(e15.effects) + Number(e15.colorLocked).toString() + JSON.stringify(e15.anchorPoint) + e15.anchorPointUnits + JSON.stringify(e15.markerPlacement) + e15.size.toString(), B4 = c(JSON.stringify(r19) + G4 + W4).toString();
  let q5 = ne3(r19.primitiveName, n17, "TextString", a15, r19.textString, s5, g8.textCase);
  if (null == q5)
    return;
  const { fontStyleName: V3 } = g8, K5 = z3 + (V3 ? "-" + V3.toLowerCase() : "-regular"), Q4 = K5;
  "string" == typeof q5 && q5.includes("[") && g8.fieldMap && (q5 = c3(g8.fieldMap, q5, g8.textCase)), f9.push({ type: "text", templateHash: B4, materialHash: U5 || "function" == typeof q5 || q5.match(/\[(.*?)\]/) ? (e16, t12, i12) => Q4 + "-" + t3(q5, e16, t12, i12) : Q4 + "-" + c(q5), cim: g8, materialOverrides: null, colorLocked: e15.colorLocked, effects: i11, alignment: c11, anchorPoint: { x: e15.anchorPoint ? e15.anchorPoint.x : 0, y: e15.anchorPoint ? e15.anchorPoint.y : 0 }, isAbsoluteAnchorPoint: "Relative" !== e15.anchorPointUnits, fontName: K5, decoration: d4, weight: ne3(H2, n17, "Weight", a15, S2.weight), style: ne3(H2, n17, "Size", a15, S2.style), size: ne3(H2, n17, "Size", a15, Y5), angle: ne3(H2, n17, "Rotation", a15, $4), offsetX: ne3(H2, n17, "OffsetX", a15, E3), offsetY: ne3(H2, n17, "OffsetY", a15, T4), horizontalAlignment: w(g8.horizontalAlignment), verticalAlignment: x(g8.verticalAlignment), text: q5, color: j6, outlineColor: D2, outlineSize: F3, referenceSize: m8, sizeRatio: 1, markerPlacement: o12 });
}
function Z4(e15, t12, i11, o12, r19, l12, a15, f9, c11, m8, p6, u14, y7, h8) {
  var _a;
  const g8 = r19.symbol, b5 = g8.symbolLayers;
  if (!b5)
    return;
  if (h8)
    return void te2(e15, t12, i11, o12, r19, a15, l12, f9, c11, m8, p6, u14, y7);
  let O3 = b5.length;
  if (ue2(b5))
    return void ee2(e15, t12, i11, o12, r19, b5, l12, a15, f9, c11, p6, u14, y7);
  const M4 = f8.applyEffects(g8.effects, r19.geometry, m8.geometryEngine);
  if (M4)
    for (; O3--; ) {
      const h9 = b5[O3];
      if (h9 && false !== h9.enable)
        switch (h9.type) {
          case "CIMSolidFill":
          case "CIMSolidStroke": {
            const g9 = f8.applyEffects(h9.effects, M4, m8.geometryEngine), b6 = i10(g9);
            if (!b6)
              continue;
            const O4 = "Relative" !== e15.anchorPointUnits, [L3, w6, I3] = f7(b6, e15.frame, e15.size, e15.anchorPoint, O4), X2 = "CIMSolidFill" === h9.type, A4 = { type: "sdf", geom: g9, asFill: X2 }, R3 = e15.primitiveName, x5 = (_a = b(e15.size)) != null ? _a : 10, J4 = b(e15.rotation), H2 = b(e15.offsetX), Y5 = b(e15.offsetY), $4 = h9.path, E3 = h9.primitiveName, T4 = u5(X2 ? k(h9) : P(h9)), j6 = X2 ? { r: 0, g: 0, b: 0, a: 0 } : u5(P(h9)), D2 = L(h9);
            if (!X2 && !D2)
              break;
            let F3 = false, U5 = "";
            for (const e16 of l12)
              e16.primitiveName !== E3 && e16.primitiveName !== R3 || (void 0 !== e16.value ? U5 += `-${e16.primitiveName}-${e16.propertyName}-${JSON.stringify(e16.value)}` : e16.valueExpressionInfo && (F3 = true));
            r(t12) && "function" == typeof t12 && (F3 = true);
            const W4 = JSON.stringify({ ...e15, markerGraphics: null }), G4 = c(JSON.stringify(A4) + $4).toString(), B4 = { type: "marker", templateHash: c(JSON.stringify(r19) + JSON.stringify(h9) + W4 + U5).toString(), materialHash: F3 ? () => G4 : G4, cim: A4, materialOverrides: null, colorLocked: e15.colorLocked, effects: t12, scaleSymbolsProportionally: e15.scaleSymbolsProportionally, alignment: p6, anchorPoint: { x: w6, y: I3 }, isAbsoluteAnchorPoint: O4, size: ne3(e15.primitiveName, a15, "Size", f9, x5), rotation: ne3(e15.primitiveName, a15, "Rotation", f9, J4), offsetX: ne3(e15.primitiveName, a15, "OffsetX", f9, H2), offsetY: ne3(e15.primitiveName, a15, "OffsetY", f9, Y5), scaleX: 1, frameHeight: y7, rotateClockwise: e15.rotateClockwise, referenceSize: u14, sizeRatio: L3, color: ne3(E3, a15, "Color", f9, T4, re2), outlineColor: ne3(E3, a15, "Color", f9, j6, re2), outlineWidth: ne3(E3, a15, "Width", f9, D2), markerPlacement: i11, animatedSymbolProperties: o12, path: $4 };
            c11.push(B4);
            break;
          }
          default:
            te2(e15, t12, i11, o12, r19, a15, l12, f9, c11, m8, p6, u14, y7);
        }
    }
}
function ee2(e15, t12, i11, o12, r19, n17, l12, a15, f9, c11, m8, p6, u14) {
  const y7 = r19.geometry, h8 = n17[0], g8 = n17[1], b5 = i10(y7);
  if (!b5)
    return;
  const O3 = "Relative" !== e15.anchorPointUnits, [M4, L3, w6] = f7(b5, e15.frame, e15.size, e15.anchorPoint, O3), I3 = { type: "sdf", geom: y7, asFill: true }, X2 = e15.primitiveName, z3 = b(e15.size), A4 = b(e15.rotation), R3 = b(e15.offsetX), x5 = b(e15.offsetY), J4 = g8.path, H2 = g8.primitiveName, Y5 = h8.primitiveName, $4 = u5(k(g8)), E3 = u5(P(h8)), T4 = L(h8);
  let j6 = false, D2 = "";
  for (const s12 of l12)
    s12.primitiveName !== H2 && s12.primitiveName !== Y5 && s12.primitiveName !== X2 || (void 0 !== s12.value ? D2 += `-${s12.primitiveName}-${s12.propertyName}-${JSON.stringify(s12.value)}` : s12.valueExpressionInfo && (j6 = true));
  const F3 = JSON.stringify({ ...e15, markerGraphics: null }), U5 = c(JSON.stringify(I3) + J4).toString(), W4 = { type: "marker", templateHash: c(JSON.stringify(r19) + JSON.stringify(g8) + JSON.stringify(h8) + F3 + D2).toString(), materialHash: j6 ? () => U5 : U5, cim: I3, materialOverrides: null, colorLocked: e15.colorLocked, effects: t12, scaleSymbolsProportionally: e15.scaleSymbolsProportionally, alignment: m8, anchorPoint: { x: L3, y: w6 }, isAbsoluteAnchorPoint: O3, size: ne3(e15.primitiveName, a15, "Size", f9, z3), rotation: ne3(e15.primitiveName, a15, "Rotation", f9, A4), offsetX: ne3(e15.primitiveName, a15, "OffsetX", f9, R3), offsetY: ne3(e15.primitiveName, a15, "OffsetY", f9, x5), scaleX: 1, frameHeight: u14, rotateClockwise: e15.rotateClockwise, referenceSize: p6, sizeRatio: M4, color: ne3(H2, a15, "Color", f9, $4, re2), outlineColor: ne3(Y5, a15, "Color", f9, E3, re2), outlineWidth: ne3(Y5, a15, "Width", f9, T4), markerPlacement: i11, path: J4, animatedSymbolProperties: o12 };
  c11.push(W4);
}
function te2(e15, t12, i11, o12, r19, a15, f9, c11, p6, u14, y7, h8, g8) {
  const d4 = ie3(e15, r19), S2 = ["Rotation", "OffsetX", "OffsetY"], v2 = f9.filter((t13) => t13.primitiveName !== e15.primitiveName || !S2.includes(t13.propertyName));
  let b5 = "";
  for (const n17 of f9)
    void 0 !== n17.value && (b5 += `-${n17.primitiveName}-${n17.propertyName}-${JSON.stringify(n17.value)}`);
  const [O3, k4, C5] = oe2.getTextureAnchor(d4, u14), P5 = e15.primitiveName, M4 = b(e15.rotation), L3 = b(e15.offsetX), w6 = b(e15.offsetY), I3 = c(JSON.stringify(d4) + b5).toString(), X2 = { type: "marker", templateHash: I3, materialHash: v2.length > 0 || r(t12) && "function" == typeof t12 ? ce2(I3, a15, v2, c11) : I3, cim: d4, materialOverrides: v2, colorLocked: e15.colorLocked, effects: t12, scaleSymbolsProportionally: e15.scaleSymbolsProportionally, alignment: y7, anchorPoint: { x: O3, y: k4 }, isAbsoluteAnchorPoint: false, size: e15.size, rotation: ne3(P5, a15, "Rotation", c11, M4), offsetX: ne3(P5, a15, "OffsetX", c11, L3), offsetY: ne3(P5, a15, "OffsetY", c11, w6), color: { r: 255, g: 255, b: 255, a: 1 }, outlineColor: { r: 0, g: 0, b: 0, a: 0 }, outlineWidth: 0, scaleX: 1, frameHeight: g8, rotateClockwise: e15.rotateClockwise, referenceSize: h8, sizeRatio: C5 / u3(e15.size), markerPlacement: i11, animatedSymbolProperties: o12 };
  p6.push(X2);
}
function ie3(e15, t12) {
  return { type: e15.type, enable: true, name: e15.name, colorLocked: e15.colorLocked, primitiveName: e15.primitiveName, anchorPoint: e15.anchorPoint, anchorPointUnits: e15.anchorPointUnits, offsetX: 0, offsetY: 0, rotateClockwise: e15.rotateClockwise, rotation: 0, size: e15.size, billboardMode3D: e15.billboardMode3D, depth3D: e15.depth3D, frame: e15.frame, markerGraphics: [t12], scaleSymbolsProportionally: e15.scaleSymbolsProportionally, respectFrame: e15.respectFrame, clippingPath: e15.clippingPath };
}
function oe3(e15) {
  if (e15 && 0 === e15.indexOf("Level_")) {
    const t12 = parseInt(e15.substr(6), 10);
    if (!isNaN(t12))
      return t12;
  }
  return 0;
}
function re2(t12) {
  if (!t12 || 0 === t12.length)
    return null;
  const i11 = new l(t12).toRgba();
  return { r: i11[0], g: i11[1], b: i11[2], a: i11[3] };
}
function ne3(e15, t12, i11, o12, r19, n17, l12) {
  const a15 = t12[e15];
  if (a15) {
    const e16 = a15[i11];
    if ("string" == typeof e16 || "number" == typeof e16 || e16 instanceof Array)
      return n17 ? n17.call(null, e16, l12) : e16;
    if (null != e16 && e16 instanceof p2)
      return (t13, i12, a16) => {
        let s12 = i5(e16, t13, { $view: a16 }, o12.geometryType, i12);
        return null !== s12 && n17 && (s12 = n17.call(null, s12, l12)), null !== s12 ? s12 : r19;
      };
  }
  return r19;
}
function le2(e15) {
  return e15 ? e15.charAt(0).toLowerCase() + e15.substr(1) : e15;
}
function ae2(e15, t12, o12, r19) {
  for (const i11 of t12) {
    if (i11.valueExpressionInfo) {
      const e16 = o12[i11.primitiveName] && o12[i11.primitiveName][i11.propertyName];
      e16 instanceof p2 && (i11.fn = (t13, i12, o13) => i5(e16, t13, { $view: o13 }, r19.geometryType, i12));
    }
  }
  return (o13, r20, n17) => {
    for (const e16 of t12)
      e16.fn && (e16.value = e16.fn(o13, r20, n17));
    const l12 = [];
    for (let a15 of e15) {
      const e16 = a15 == null ? void 0 : a15.primitiveName;
      if (e16) {
        let o14 = false;
        for (const r21 of t12)
          if (r21.primitiveName === e16) {
            const e17 = le2(r21.propertyName);
            null != r21.value && r21.value !== a15[e17] && (o14 || (a15 = y(a15), o14 = true), a15[e17] = r21.value);
          }
      }
      l12.push(a15);
    }
    return l12;
  };
}
function se2(e15, t12, o12, r19) {
  const n17 = [];
  if (ie2.findApplicableOverrides(e15, t12, n17), 0 === n17.length)
    return e15;
  for (const i11 of n17) {
    if (i11.valueExpressionInfo) {
      const e16 = o12[i11.primitiveName] && o12[i11.primitiveName][i11.propertyName];
      e16 instanceof p2 && (i11.fn = (t13, i12, o13) => i5(e16, t13, { $view: o13 }, r19.geometryType, i12));
    }
  }
  return (t13, o13, r20) => {
    for (const e16 of n17)
      e16.fn && (e16.value = e16.fn(t13, o13, r20));
    const l12 = y(e15), a15 = e15.primitiveName;
    for (const e16 of n17)
      if (e16.primitiveName === a15) {
        const t14 = le2(e16.propertyName);
        null != e16.value && e16.value !== l12[t14] && (l12[t14] = e16.value);
      }
    return l12;
  };
}
function fe2(e15, t12, o12, r19) {
  const n17 = [];
  if (ie2.findApplicableOverrides(e15, t12, n17), 0 === n17.length)
    return e15;
  for (const i11 of n17) {
    if (i11.valueExpressionInfo) {
      const e16 = o12[i11.primitiveName] && o12[i11.primitiveName][i11.propertyName];
      e16 instanceof p2 && (i11.fn = (t13, i12, o13) => i5(e16, t13, { $view: o13 }, r19.geometryType, i12));
    }
  }
  return (t13, o13, r20) => {
    for (const e16 of n17)
      e16.fn && (e16.value = e16.fn(t13, o13, r20));
    const l12 = y(e15), a15 = e15.primitiveName;
    for (const e16 of n17)
      if (e16.primitiveName === a15) {
        const t14 = le2(e16.propertyName);
        if (null != e16.value) {
          const i11 = a13(e16.value, e16.propertyName);
          i11 !== l12[t14] && (l12[t14] = i11);
        }
      }
    return l12;
  };
}
function ce2(e15, t12, i11, o12) {
  for (const r19 of i11) {
    if (r19.valueExpressionInfo) {
      const e16 = t12[r19.primitiveName] && t12[r19.primitiveName][r19.propertyName];
      e16 instanceof p2 && (r19.fn = (t13, i12, r20) => i5(e16, t13, { $view: r20 }, o12.geometryType, i12));
    }
  }
  return (t13, o13, r19) => {
    for (const e16 of i11)
      e16.fn && (e16.value = e16.fn(t13, o13, r19));
    return c(e15 + ie2.buildOverrideKey(i11)).toString();
  };
}
function me2(e15, t12) {
  if (!t12 || 0 === t12.length)
    return e15;
  const o12 = y(e15);
  return ie2.applyOverrides(o12, t12), o12;
}
function pe2(e15, t12, i11, o12, r19) {
  let l12 = false, a15 = "";
  for (const n17 of e15)
    n17.primitiveName === t12 && (void 0 !== n17.value ? a15 += `-${n17.primitiveName}-${n17.propertyName}-${JSON.stringify(n17.value)}` : n17.valueExpressionInfo && (l12 = true));
  return r(i11) && "function" == typeof i11 && (l12 = true), r(o12) && "function" == typeof o12 && (l12 = true), r(r19) && "function" == typeof r19 && (l12 = true), [l12, a15];
}
var ue2 = (e15) => e15 && 2 === e15.length && e15[0].enable && e15[1].enable && "CIMSolidStroke" === e15[0].type && "CIMSolidFill" === e15[1].type && !e15[0].effects && !e15[1].effects;

export {
  n5 as n,
  a5 as a,
  g6 as g,
  j4 as j,
  f8 as f,
  t10 as t,
  s6 as s,
  O2 as O,
  V,
  W,
  Q2 as Q,
  ae,
  oe2 as oe,
  ie2 as ie,
  pe,
  r17 as r,
  a14 as a2,
  e14 as e,
  o11 as o,
  T3 as T,
  me2 as me
};
//# sourceMappingURL=chunk-57QYUXCA.js.map
