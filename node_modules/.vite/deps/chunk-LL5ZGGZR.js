import {
  e as e2
} from "./chunk-Q5IFLFM5.js";
import {
  g,
  i as i2
} from "./chunk-EWYYYS2T.js";
import {
  c as c2
} from "./chunk-7N2Z7KNR.js";
import {
  o
} from "./chunk-4Y3VLNR2.js";
import {
  t as t3
} from "./chunk-57QYUXCA.js";
import {
  l
} from "./chunk-SFYX532J.js";
import {
  re
} from "./chunk-6TBB7UXB.js";
import {
  A,
  S
} from "./chunk-EQNT4A7P.js";
import {
  q
} from "./chunk-XO5VJRK4.js";
import {
  d,
  m as m2
} from "./chunk-XGEPEYGB.js";
import {
  c
} from "./chunk-2T7LFOXQ.js";
import {
  t as t2
} from "./chunk-YF2CRSQX.js";
import {
  m
} from "./chunk-DVGM5RQS.js";
import {
  u
} from "./chunk-NRP45AHD.js";
import {
  u as u2
} from "./chunk-6M2AHKYV.js";
import {
  v2 as v
} from "./chunk-3MNMDUQZ.js";
import {
  R
} from "./chunk-LNZAOBFW.js";
import {
  s as s2
} from "./chunk-LIZHLHNA.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";
import {
  has
} from "./chunk-HVKDYDPP.js";
import {
  e,
  i,
  r,
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/util/vvFlagUtils.js
function e3(e4) {
  if (!e4)
    return A.NONE;
  let r3 = 0;
  for (const i3 of e4)
    if ("size" === i3.type) {
      const t4 = l(i3);
      r3 |= t4, "outline" === i3.target && (r3 |= t4 << 4);
    } else
      "color" === i3.type ? r3 |= A.COLOR : "opacity" === i3.type ? r3 |= A.OPACITY : "rotation" === i3.type && (r3 |= A.ROTATION);
  return r3;
}

// node_modules/@arcgis/core/views/2d/layers/graphics/graphicsUtils.js
var c3 = 512;
var g2 = 50;
function p(e4, t4) {
  const n4 = R(t4);
  if (!n4)
    return null;
  const [i3, s3] = n4.valid;
  return e4[2] > s3 ? [u2([e4[0], e4[1], s3, e4[3]]), u2([i3, e4[1], i3 + e4[2] - s3, e4[3]])] : e4[0] < i3 ? [u2([i3, e4[1], e4[2], e4[3]]), u2([s3 - (i3 - e4[0]), e4[1], s3, e4[3]])] : null;
}
function u3(e4) {
  return "text" === e4 || "esriTS" === e4;
}
function h(e4) {
  return "simple-marker" === e4 || "picture-marker" === e4 || "esriSMS" === e4 || "esriPMS" === e4;
}
function y(e4) {
  switch (e(e4.geometry).type) {
    case "point":
    case "multipoint":
      return 0;
    case "polyline":
      return 1;
    case "polygon":
    case "extent":
      return 2;
  }
  return 0;
}
function d2(e4) {
  if (!e4)
    return null;
  const { xmin: t4, ymin: n4, xmax: r3, ymax: o2, spatialReference: s3 } = e4;
  return new v({ rings: [[[t4, n4], [t4, o2], [r3, o2], [r3, n4], [t4, n4]]], spatialReference: s3 });
}

// node_modules/@arcgis/core/views/2d/layers/features/support/pixelBuffering.js
function m3(t4, e4) {
  if (!("visualVariables" in t4))
    return 0;
  if (!t4.hasVisualVariables("size"))
    return 0;
  const r3 = t4.getVisualVariablesForType("size");
  if (!r3[0])
    return 0;
  const i3 = r3[0];
  if (e4 && "cluster_count" === i3.field && "cluster" === e4.type)
    return e4.clusterMaxSize;
  if ("outline" === i3.target)
    return 0;
  if ("stops" === i3.transformationType)
    return i3.stops.map((t5) => t5.size).reduce(g3, 0);
  if ("clamped-linear" === i3.transformationType) {
    let t5 = -1 / 0, e5 = -1 / 0;
    return t5 = "number" == typeof i3.maxSize ? i3.maxSize : i3.maxSize.stops.map((t6) => t6.size).reduce(g3, 0), e5 = "number" == typeof i3.minSize ? i3.minSize : i3.minSize.stops.map((t6) => t6.size).reduce(g3, 0), Math.max(t5, e5);
  }
  return "real-world-size" === i3.transformationType ? 30 : void 0;
}
var y2 = { sdf: true, code: 99, metrics: q.metrics, rect: new t3(0, 0, 24, 24), page: 0, textureBinding: 2 };
function g3(t4, e4) {
  return Math.max(t4, e4);
}

// node_modules/@arcgis/core/views/2d/layers/features/schemaUtils.js
var T = s.getLogger("esri.views.2d.layers.features.schemaUtils");
var S2 = "ValidationError";
function E(e4) {
  return e4;
}
function w(e4, t4) {
  let i3 = 0, n4 = 0, s3 = S.DEFAULT;
  if (r(e4)) {
    if (n4 = m3(e4, t4), "visualVariables" in e4 && (i3 = e3(e4.visualVariables || []), "dot-density" === e4.type && (s3 = S.DOT_DENSITY)), "heatmap" === e4.type && (s3 = S.HEATMAP), "dictionary" === e4.type)
      return { maxVVSize: n4, vvFlags: i3, symbologyType: S.DEFAULT };
    if ("pie-chart" === e4.type)
      return { maxVVSize: n4, vvFlags: i3, symbologyType: S.PIE_CHART };
    if (s3 !== S.DOT_DENSITY && s3 !== S.HEATMAP) {
      const t5 = e4.getSymbols();
      "backgroundFillSymbol" in e4 && e4.backgroundFillSymbol && t5.push(e4.backgroundFillSymbol);
      let r3 = true, i4 = true;
      for (const e5 of t5)
        if ("cim" === e5.type && (i4 = false), "simple-fill" === e5.type || "picture-fill" === e5.type) {
          const t6 = e5.outline, n5 = t6 && "none" !== t6.style && "solid" !== t6.style, s4 = "simple-fill" === e5.type && "none" !== e5.style && "solid" !== e5.style, l2 = "picture-fill" === e5.type || s4 || n5;
          n5 && (r3 = false), l2 && (i4 = false);
        }
      r3 ? s3 = i4 ? S.OUTLINE_FILL_SIMPLE : S.OUTLINE_FILL : i4 && (s3 = S.SIMPLE);
    }
  }
  return { vvFlags: i3, maxVVSize: n4, symbologyType: s3 };
}
var I = null;
function F(e4) {
  if (has("esri-2d-update-debug")) {
    const t4 = V(e4, true);
    console.debug("Created new schema", t4), console.debug("Schema diff", m(I, t4)), I = t4;
  }
  return V(e4);
}
function V(e4, t4 = false) {
  var _a, _b;
  try {
    const i3 = D(e4, t4), n4 = C(e4), s3 = {};
    i3.map((t5) => O(s3, e4, t5));
    const l2 = r(e4.subtypeCode) ? `${e4.subtypeField} = ${e4.subtypeCode}` : null, a = t2(e4.definitionExpression, l2);
    return { source: { definitionExpression: a, fields: e4.fields.map((e5) => e5.toJSON()), gdbVersion: e4.gdbVersion, historicMoment: (_a = e4.historicMoment) == null ? void 0 : _a.getTime(), outFields: e4.availableFields, pixelBuffer: e4.pixelBuffer, spatialReference: e4.spatialReference.toJSON(), timeExtent: (_b = e4.timeExtent) == null ? void 0 : _b.toJSON(), customParameters: e4.customParameters }, attributes: { fields: {}, indexCount: 0 }, processors: i3, tileRenderer: n4, targets: s3 };
  } catch (i3) {
    if (i3.fieldName === S2)
      return T.error(i3), null;
    throw i3;
  }
}
function O(t4, r3, i3) {
  switch (i3.target) {
    case "feature":
      return void M(t4, N(r3), i3);
    case "aggregate": {
      if (!("featureReduction" in r3))
        return;
      const n4 = r3.featureReduction;
      switch (n4.type) {
        case "selection":
          throw new s2(S2, "Mapview does not support `selection` reduction type", n4);
        case "binning":
          return M(t4, N(r3), i3), void L(t4, n4, r3.fields.map((e4) => e4.toJSON()), i3);
        case "cluster":
          return M(t4, N(r3), i3), void R2(t4, n4, r3.fields.map((e4) => e4.toJSON()), i3);
      }
    }
  }
}
function z(e4, t4) {
  for (const r3 in t4) {
    const i3 = t4[r3];
    if (i3.target !== e4.name)
      continue;
    const n4 = e4.attributes[r3];
    n4 ? (n4.context.mesh = n4.context.mesh || i3.context.mesh, n4.context.storage = n4.context.storage || i3.context.storage) : e4.attributes[r3] = i3;
  }
  return e4;
}
function N(e4) {
  var _a, _b, _c, _d, _e;
  return [(_b = (_a = e(e4.filter)) == null ? void 0 : _a.toJSON()) != null ? _b : null, (_e = (_d = e((_c = e(e4.featureEffect)) == null ? void 0 : _c.filter)) == null ? void 0 : _d.toJSON()) != null ? _e : null];
}
function M(e4, t4, r3) {
  return e4.feature || (e4.feature = { name: "feature", input: "source", filters: t4, attributes: {} }), z(e4.feature, r3.attributes.fields), e4;
}
function j3(t4, r3) {
  const { onStatisticExpression: i3, onStatisticField: n4, statisticType: s3 } = t4;
  switch (s3) {
    case "min":
    case "max":
    case "avg":
    case "avg_angle":
    case "sum":
    case "count":
      return "esriFieldTypeDouble";
    case "mode": {
      if (i3) {
        const { returnType: r4 } = i3;
        return r4 ? "string" === r4 ? "esriFieldTypeString" : "esriFieldTypeDouble" : (T.error(new s2(S2, "Unable to infer type of aggregateField with onStatisticExpression. ReturnType is not defined", t4)), "esriFieldTypeString");
      }
      const s4 = r3.find((e4) => e4.name === n4);
      return s4 ? s4.type : (T.error(new s2(S2, "Unable to infer type of aggregateField with onStatisticExpression. ReturnType is not defined", t4)), "esriFieldTypeString");
    }
  }
}
function L(e4, t4, r3, i3) {
  var _a;
  return e4.aggregate || (e4.aggregate = { name: "aggregate", type: "bin", filters: null, input: "feature", params: { fixedBinLevel: t4.fixedBinLevel, fields: ((_a = t4.fields) != null ? _a : []).map((e5) => ({ ...e5.toJSON(), type: j3(e5, r3) })) }, attributes: {} }), z(e4.aggregate, i3.attributes.fields), e4;
}
function R2(e4, t4, r3, i3) {
  var _a, _b;
  return e4.aggregate || (e4.aggregate = { name: "aggregate", type: "cluster", input: "feature", filters: null, attributes: {}, params: { clusterRadius: u(t4.clusterRadius / 2), clusterPixelBuffer: 64 * Math.ceil(u(t4.clusterMaxSize) / 64), fields: (_b = (_a = t4.fields) != null ? _a : []) == null ? void 0 : _b.map((e5) => ({ ...e5.toJSON(), type: j3(e5, r3) })) } }), z(e4.aggregate, i3.attributes.fields), e4;
}
function U(e4, t4) {
  return t4.field ? B(e4, { ...t4, type: "field", field: t4.field }) : t4.valueExpression ? B(e4, { ...t4, type: "expression", valueExpression: t4.valueExpression }) : { field: null, fieldIndex: null };
}
function B(e4, t4) {
  switch (t4.type) {
    case "expression": {
      const r3 = E(t4.valueExpression);
      if (!e4.fields[r3]) {
        const i3 = e4.indexCount++;
        e4.fields[r3] = { ...t4, name: r3, fieldIndex: i3 };
      }
      return { fieldIndex: e4.fields[r3].fieldIndex };
    }
    case "label-expression": {
      const r3 = E(JSON.stringify(t4.label));
      if (!e4.fields[r3]) {
        const i3 = e4.indexCount++;
        e4.fields[r3] = { ...t4, name: r3, fieldIndex: i3 };
      }
      return { fieldIndex: e4.fields[r3].fieldIndex };
    }
    case "field": {
      const r3 = t4.field;
      return "aggregate" === t4.target && e4.fields[r3] || (e4.fields[r3] = { ...t4, name: r3 }), { field: r3 };
    }
    case "statistic":
      return e4.fields[t4.name] = { ...t4 }, { field: t4.name };
  }
}
function D(e4, t4 = false) {
  const r3 = new Array();
  let i3 = 0;
  return r3.push(A2(e4, i3++, t4)), r3;
}
function P(e4, t4, r3, i3, n4, s3 = false) {
  const l2 = B(e4, { type: "label-expression", target: r3, context: { mesh: true }, resultType: "string", label: { labelExpression: t4.labelExpression, labelExpressionInfo: t4.labelExpressionInfo ? { expression: t4.labelExpressionInfo.expression } : null, symbol: !!t4.symbol, where: t4.where } }), { fieldIndex: o2 } = l2;
  return { ...o(t4, n4, s3), fieldIndex: o2, target: r3, index: i3 };
}
function k(t4, r3, i3) {
  var _a, _b;
  const n4 = "featureReduction" in r3 && r3.featureReduction;
  if (!n4)
    return { fields: [], labels: [], matcher: null, rendererOverride: null };
  const s3 = "aggregate", l2 = [];
  let o2 = null, a = e2(r3.geometryType), d3 = [], f2 = null;
  if (n4)
    switch (n4.type) {
      case "selection":
        return T.error(new s2(S2, "Mapview does not support `selection` reduction type", n4)), { fields: [], labels: [], matcher: null, rendererOverride: null };
      case "cluster":
      case "binning":
        if (l2.push(...(_a = n4.fields) != null ? _a : []), "cluster" === n4.type ? a = "esriGeometryPoint" : "binning" === n4.type && (a = "esriGeometryPolygon"), n4.renderer && !((_b = n4.renderer.authoringInfo) == null ? void 0 : _b.isAutoGenerated)) {
          if ("cluster" === n4.type) {
            const { renderer: e5 } = m2(n4.renderer, n4, null);
            f2 = e5;
          } else
            f2 = n4.renderer;
          const e4 = w(n4.renderer, n4);
          o2 = $(null, s3, n4.renderer, e4, i3), d3 = n4 && n4.labelsVisible && n4.labelingInfo || [];
        } else if ("cluster" === n4.type) {
          if (f2 = d(l2, r3.renderer, n4, null, true), n4.symbol) {
            const e4 = w(f2, n4);
            o2 = { type: "simple", symbol: o(n4.symbol, e4, i3), symbologyType: e4.symbologyType };
          }
          d3 = n4 && n4.labelsVisible && n4.labelingInfo || [];
        }
    }
  _(t4, l2);
  return { labels: c(d3, "binning" === n4.type ? "esriGeometryPolygon" : a), matcher: o2, fields: l2, rendererOverride: f2 };
}
function A2(t4, i3, n4 = false) {
  var _a;
  const s3 = { indexCount: 0, fields: {} }, l2 = "featureReduction" in t4 && t4.featureReduction, o2 = l2 ? "aggregate" : "feature";
  if ("sublayers" in t4) {
    const i4 = { type: "subtype", subtypeField: t4.subtypeField, renderers: {}, symbologyType: S.DEFAULT }, l3 = { type: "subtype", mapping: {}, target: "feature" }, a2 = { type: "subtype", classes: {} }, u4 = { type: "symbol", target: "feature", aggregateFields: [], attributes: s3, storage: l3, mesh: { matcher: i4, aggregateMatcher: null, labels: a2, sortKey: null } }, f3 = /* @__PURE__ */ new Set();
    let p3 = 0;
    for (const { renderer: c5, subtypeCode: y4, labelingInfo: m5, labelsVisible: g4 } of t4.sublayers) {
      const t5 = { symbologyType: S.DEFAULT, vvFlags: 0, maxVVSize: 0 }, u5 = $(s3, o2, c5, t5, n4), b2 = q2(s3, o2, c5), x3 = g4 && m5;
      if ("visualVariables" in c5 && c5.visualVariables && c5.visualVariables.length)
        throw new s2(S2, "Visual variables are currently not supported for subtype layers");
      if ("dictionary" === u5.type)
        throw new s2(S2, "Dictionary renderer is not supported in subtype layers");
      if ("subtype" === u5.type)
        throw new s2(S2, "Nested subtype renderers is not supported");
      if (r(b2) && "subtype" === b2.type)
        throw new s2(S2, "Nested subtype storage is not supported");
      if (r(b2) && r(b2.attributeMapping))
        throw new s2(S2, "Non-visual-variable attributes are not supported in subtype layers");
      if ("heatmap" === u5.type)
        throw new s2(S2, "Heatmaps are not supported in subtype layers");
      if ("pie-chart" === u5.type)
        throw new s2(S2, "Pie-charts are not supported in subtype layers");
      if (f3.has(y4))
        throw new s2(S2, "Subtype codes for sublayers must be unique");
      f3.add(y4), i4.renderers[y4] = u5, l3.mapping[y4] = b2, x3 && (a2.classes[y4] = x3.map((e4) => P(s3, e4, "feature", p3++, t5, n4)));
    }
    return u4;
  }
  if ("heatmap" === t4.renderer.type && "raster" === g()) {
    const { radius: e4, fieldOffset: r3, field: i4 } = t4.renderer;
    return { type: "heatmap", aggregateFields: [], attributes: s3, target: o2, storage: null, mesh: { radius: e4, fieldOffset: r3, field: U(s3, { target: o2, field: i4, resultType: "numeric" }).field } };
  }
  const a = k(s3, t4, n4), f2 = e2(t4.geometryType), p2 = (_a = a.rendererOverride) != null ? _a : t4.renderer, c4 = w(p2, l2), y3 = $(s3, o2, p2, c4, n4), m4 = q2(s3, o2, p2), b = J(s3, t4.orderBy, l2), x2 = t4.labelsVisible && t4.labelingInfo || [], h2 = c(x2, f2);
  let T2 = 0;
  const E2 = [...h2.map((e4) => P(s3, e4, "feature", T2++, c4, n4)), ...a.labels.map((e4) => P(s3, e4, "aggregate", T2++, c4, n4))];
  return { type: "symbol", target: o2, attributes: s3, aggregateFields: a.fields, storage: m4, mesh: { matcher: y3, labels: { type: "simple", classes: E2 }, aggregateMatcher: a.matcher, sortKey: b } };
}
function C(e4) {
  var _a;
  return "heatmap" === ((_a = e4.renderer) == null ? void 0 : _a.type) && "raster" === g() ? { type: "heatmap" } : { type: "symbol" };
}
function J(t4, i3, s3) {
  if (r(s3) || t(i3) || !i3.length)
    return null;
  i3.length > 1 && T.warn(`Layer rendering currently only supports ordering by 1 orderByInfo, but found ${i3.length}. All but the first will be discarded`);
  const l2 = i3[0], o2 = "ascending" === l2.order ? "asc" : "desc";
  if (l2.field)
    return { field: l2.field, order: o2 };
  if (l2.valueExpression) {
    return { fieldIndex: B(t4, { type: "expression", target: "feature", valueExpression: l2.valueExpression, resultType: "numeric" }).fieldIndex, order: o2 };
  }
  return T.error(new s2(S2, "Expected to find a field or valueExpression for OrderByInfo", l2)), null;
}
function _(e4, t4) {
  const r3 = { mesh: true, storage: true };
  for (const i3 of t4) {
    const { name: t5, onStatisticField: n4, onStatisticExpression: s3, statisticType: l2 } = i3;
    let o2 = null, a = null;
    const u4 = "numeric", d3 = "feature";
    if (s3) {
      a = B(e4, { type: "expression", target: d3, valueExpression: s3.expression, resultType: u4 }).fieldIndex;
    } else {
      o2 = B(e4, { type: "field", target: d3, field: n4, resultType: u4 }).field;
    }
    B(e4, { type: "statistic", target: "aggregate", name: t5, context: r3, inField: o2, inFieldIndex: a, statisticType: l2 });
  }
}
function q2(e4, t4, r3) {
  let i3;
  switch (r3.type) {
    case "simple":
    case "class-breaks":
    case "unique-value":
    case "dictionary":
      i3 = { visualVariables: true, attributes: null };
      break;
    default:
      i3 = c2(r3).getStorageSpec(r3);
  }
  return G(e4, t4, i3, r3);
}
function G(e4, t4, i3, s3) {
  if (t(i3))
    return null;
  const { visualVariables: l2, attributes: o2 } = i3;
  let a = null;
  l2 && "visualVariables" in s3 && (a = H(e4, t4, s3.visualVariables));
  const u4 = r(a) ? 4 : 0;
  let d3 = null;
  return r(o2) && (d3 = o2.map((r3, i4) => {
    const { field: n4, fieldIndex: s4 } = U(e4, { valueExpression: r3.valueExpression, field: r3.field, resultType: "numeric", target: t4 });
    return { binding: i4 + u4, field: n4, fieldIndex: s4 };
  })), { type: "simple", target: t4, attributeMapping: d3, vvMapping: a };
}
function H(e4, t4, r3) {
  if (!r3 || !r3.length)
    return [];
  const i3 = { storage: true }, n4 = "numeric";
  return i2(r3).map((r4) => {
    var _a;
    const s3 = re(r4.type), { field: l2, fieldIndex: o2 } = U(e4, { target: t4, valueExpression: r4.valueExpression, field: r4.field, context: i3, resultType: n4 });
    switch (r4.type) {
      case "size":
        return "$view.scale" === r4.valueExpression ? null : { type: "size", binding: s3, field: l2, fieldIndex: o2, normalizationField: U(e4, { target: t4, field: r4.normalizationField, context: i3, resultType: n4 }).field, valueRepresentation: (_a = r4.valueRepresentation) != null ? _a : null };
      case "color":
        return { type: "color", binding: s3, field: l2, fieldIndex: o2, normalizationField: U(e4, { target: t4, field: r4.normalizationField, context: i3, resultType: n4 }).field };
      case "opacity":
        return { type: "opacity", binding: s3, field: l2, fieldIndex: o2, normalizationField: U(e4, { target: t4, field: r4.normalizationField, context: i3, resultType: n4 }).field };
      case "rotation":
        return { type: "rotation", binding: s3, field: l2, fieldIndex: o2 };
    }
  }).filter((e5) => e5);
}
function $(e4, t4, r3, i3, n4 = false) {
  const l2 = i(e4, { indexCount: 0, fields: {} });
  switch (r3.type) {
    case "simple":
    case "dot-density":
      return K(l2, r3, i3, n4);
    case "class-breaks":
      return Q(l2, t4, r3, i3, n4);
    case "unique-value":
      return W(l2, t4, r3, i3, n4);
    case "dictionary":
      return X(l2, r3, i3, n4);
    case "heatmap":
      return Z(l2, r3, i3, n4);
    case "pie-chart":
      return Y(l2, r3, i3, n4);
  }
}
function K(e4, t4, r3, i3 = false) {
  const n4 = t4.getSymbols(), s3 = n4.length ? n4[0] : null;
  return { type: "simple", symbol: o(s3, r3, i3), symbologyType: r3.symbologyType };
}
function Y(e4, t4, r3, i3 = false) {
  const n4 = t4.getSymbols(), s3 = n4[0], l2 = n4.length > 1 ? n4[1] : null;
  return { type: "pie-chart", markerSymbol: o(s3, r3, i3), fillSymbol: o(l2, r3, i3), symbologyType: r3.symbologyType };
}
function Q(e4, t4, r3, i3, n4 = false) {
  const s3 = { mesh: true, use: "renderer.field" }, l2 = r3.backgroundFillSymbol, { field: o2, fieldIndex: a } = U(e4, { target: t4, field: r3.field, valueExpression: r3.valueExpression, resultType: "numeric", context: s3 }), u4 = r3.normalizationType, d3 = "log" === u4 ? "esriNormalizeByLog" : "percent-of-total" === u4 ? "esriNormalizeByPercentOfTotal" : "field" === u4 ? "esriNormalizeByField" : null, f2 = r3.classBreakInfos.map((e5) => ({ symbol: o(e5.symbol, i3, n4), min: e5.minValue, max: e5.maxValue })).sort((e5, t5) => e5.min - t5.min);
  return { type: "interval", attributes: e4.fields, field: o2, fieldIndex: a, backgroundFillSymbol: o(l2, i3, n4), defaultSymbol: o(r3.defaultSymbol, i3, n4), intervals: f2, normalizationField: r3.normalizationField, normalizationTotal: r3.normalizationTotal, normalizationType: d3, isMaxInclusive: r3.isMaxInclusive, symbologyType: i3.symbologyType };
}
function W(t4, r3, i3, n4, s3 = false) {
  const l2 = [], o2 = i3.backgroundFillSymbol, a = { target: r3, context: { mesh: true }, resultType: "string" };
  if (i3.field && "string" != typeof i3.field)
    throw new s2(S2, "Expected renderer.field to be a string", i3);
  const { field: u4, fieldIndex: d3 } = U(t4, { ...a, field: i3.field, valueExpression: i3.valueExpression });
  for (const e4 of i3.uniqueValueInfos)
    l2.push({ value: "" + e4.value, symbol: o(e4.symbol, n4, s3) });
  return { type: "map", attributes: t4.fields, field: u4, fieldIndex: d3, field2: U(t4, { ...a, field: i3.field2 }).field, field3: U(t4, { ...a, field: i3.field3 }).field, fieldDelimiter: i3.fieldDelimiter, backgroundFillSymbol: o(o2, n4), defaultSymbol: o(i3.defaultSymbol, n4), map: l2, symbologyType: n4.symbologyType };
}
function X(e4, t4, r3, i3 = false) {
  return { type: "dictionary", config: t4.config, fieldMap: t4.fieldMap, scaleExpression: t4.scaleExpression, url: t4.url, symbolOptions: r3, symbologyType: r3.symbologyType };
}
function Z(e4, t4, r3, i3 = false) {
  const n4 = t4.getSymbols(), s3 = n4.length ? n4[0] : null;
  return { type: "heatmap", symbol: o(s3, r3, i3), symbologyType: r3.symbologyType };
}

export {
  c3 as c,
  g2 as g,
  p,
  u3 as u,
  h,
  y,
  d2 as d,
  w,
  F,
  $
};
//# sourceMappingURL=chunk-LL5ZGGZR.js.map
