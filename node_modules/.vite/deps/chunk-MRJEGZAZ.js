import {
  DateTime,
  S,
  c2 as c,
  d,
  f as f2,
  i,
  i3 as i2,
  l2 as l,
  m,
  o,
  t3 as t,
  v,
  y
} from "./chunk-GDBM63TX.js";
import {
  f as f3
} from "./chunk-36RXM3AP.js";
import {
  F,
  K,
  M,
  O,
  R,
  S as S2,
  W,
  b,
  h,
  m as m2,
  p,
  x
} from "./chunk-2ZKX6TXA.js";
import {
  r
} from "./chunk-7Q5M7ANT.js";
import {
  k2 as k
} from "./chunk-LNZAOBFW.js";
import {
  C
} from "./chunk-MJXQTGI2.js";
import {
  f
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/arcade/featureset/support/errorsupport.js
var t2;
!function(e2) {
  e2.InvalidFunctionParameters = "InvalidFunctionParameters", e2.UnsupportedSqlFunction = "UnsupportedSqlFunction", e2.UnsupportedOperator = "UnsupportedOperator", e2.UnsupportedSyntax = "UnsupportedSyntax", e2.UnsupportedIsRhs = "UnsupportedIsRhs", e2.UnsupportedIsLhs = "UnsupportedIsLhs", e2.MissingStatisticParameters = "MissingStatisticParameters";
}(t2 || (t2 = {}));
var r2 = { [t2.MissingStatisticParameters]: "Statistic does not have 1 or 0 Parameters", [t2.InvalidFunctionParameters]: "Invalid parameters for call to {function}", [t2.UnsupportedIsLhs]: "Unsupported left hand expression in is statement", [t2.UnsupportedIsRhs]: "Unsupported right hand expression in is statement", [t2.UnsupportedOperator]: "Unsupported operator - {operator}", [t2.UnsupportedSyntax]: "Unsupported syntax - {node}", [t2.UnsupportedSqlFunction]: "Sql function not found = {function}" };
var s = class extends Error {
  constructor(t4, n2) {
    super(i(r2[t4], n2)), this.declaredRootClass = "esri.arcade.featureset.support.sqlerror", Error.captureStackTrace && Error.captureStackTrace(this, s);
  }
};
var n;
!function(e2) {
  e2.NeverReach = "NeverReach", e2.NotImplemented = "NotImplemented", e2.Cancelled = "Cancelled", e2.InvalidStatResponse = "InvalidStatResponse", e2.InvalidRequest = "InvalidRequest", e2.RequestFailed = "RequestFailed", e2.MissingFeatures = "MissingFeatures", e2.AggregationFieldNotFound = "AggregationFieldNotFound", e2.DataElementsNotFound = "DataElementsNotFound";
}(n || (n = {}));
var a = { [n.Cancelled]: "Cancelled", [n.InvalidStatResponse]: "Invalid statistics response from service", [n.InvalidRequest]: "Invalid request", [n.RequestFailed]: "Request failed - {reason}", [n.MissingFeatures]: "Missing features", [n.AggregationFieldNotFound]: "Aggregation field not found", [n.DataElementsNotFound]: "Data elements not found on service", [n.NeverReach]: "Encountered unreachable logic", [n.NotImplemented]: "Not implemented" };
var o2 = class extends Error {
  constructor(t4, r3) {
    super(i(a[t4], r3)), this.declaredRootClass = "esri.arcade.featureset.support.featureseterror", Error.captureStackTrace && Error.captureStackTrace(this, o2);
  }
};

// node_modules/@arcgis/core/arcade/featureset/support/cache.js
var a2 = class {
  constructor() {
    this._databaseTypeMetaData = {}, this._layerInfo = {};
  }
  clearDatabaseType(a3) {
    void 0 === this._databaseTypeMetaData[a3] && delete this._databaseTypeMetaData[a3];
  }
  getDatabaseType(a3) {
    return "MUSTBESET" === a3 || void 0 === this._databaseTypeMetaData[a3] ? null : this._databaseTypeMetaData[a3];
  }
  setDatabaseType(a3, e2) {
    this._databaseTypeMetaData[a3] = e2;
  }
  getLayerInfo(a3) {
    return void 0 === this._layerInfo[a3] ? null : this._layerInfo[a3];
  }
  setLayerInfo(a3, e2) {
    this._layerInfo[a3] = e2;
  }
  clearLayerInfo(a3) {
    void 0 !== this._layerInfo[a3] && delete this._layerInfo[a3];
  }
};
a2.applicationCache = null;

// node_modules/@arcgis/core/arcade/featureset/support/sqlUtils.js
function s2(e2, r3) {
  return u(e2 == null ? void 0 : e2.parseTree, r3, e2 == null ? void 0 : e2.parameters);
}
function o3(e2, r3, t4) {
  return u(e2, r3, t4);
}
function c2(t4, n2, a3, s4) {
  return f3.create(u(t4.parseTree, t.Standardised, t4.parameters, n2, a3), s4);
}
function i3(t4, n2, a3 = "AND") {
  return f3.create("((" + s2(t4, t.Standardised) + ")" + a3 + "(" + s2(n2, t.Standardised) + "))", t4.fieldsIndex);
}
function u(e2, r3, a3, s4 = null, o5 = null) {
  let c3, i5, p4, g3;
  switch (e2.type) {
    case "interval":
      return N(u(e2.value, r3, a3, s4, o5), e2.qualifier, e2.op);
    case "case-expression": {
      let t4 = " CASE ";
      "simple" === e2.format && (t4 += u(e2.operand, r3, a3, s4, o5));
      for (let n2 = 0; n2 < e2.clauses.length; n2++)
        t4 += " WHEN " + u(e2.clauses[n2].operand, r3, a3, s4, o5) + " THEN " + u(e2.clauses[n2].value, r3, a3, s4, o5);
      return null !== e2.else && (t4 += " ELSE " + u(e2.else, r3, a3, s4, o5)), t4 += " END ", t4;
    }
    case "parameter": {
      const t4 = a3[e2.value.toLowerCase()];
      if ("string" == typeof t4) {
        return "'" + a3[e2.value.toLowerCase()].toString().replace(/'/g, "''") + "'";
      }
      if (t4 instanceof Date)
        return f4(t4, r3);
      if (t4 instanceof Array) {
        const e3 = [];
        for (let n2 = 0; n2 < t4.length; n2++)
          "string" == typeof t4[n2] ? e3.push("'" + t4[n2].toString().replace(/'/g, "''") + "'") : t4[n2] instanceof Date ? e3.push(f4(t4[n2], r3)) : e3.push(t4[n2].toString());
        return e3;
      }
      return t4.toString();
    }
    case "expression-list":
      i5 = [];
      for (const t4 of e2.value)
        i5.push(u(t4, r3, a3, s4, o5));
      return i5;
    case "unary-expression":
      return " ( NOT " + u(e2.expr, r3, a3, s4, o5) + " ) ";
    case "binary-expression":
      switch (e2.operator) {
        case "AND":
          return " (" + u(e2.left, r3, a3, s4, o5) + " AND " + u(e2.right, r3, a3, s4, o5) + ") ";
        case "OR":
          return " (" + u(e2.left, r3, a3, s4, o5) + " OR " + u(e2.right, r3, a3, s4, o5) + ") ";
        case "IS":
          if ("null" !== e2.right.type)
            throw new s(t2.UnsupportedIsRhs);
          return " (" + u(e2.left, r3, a3, s4, o5) + " IS NULL )";
        case "ISNOT":
          if ("null" !== e2.right.type)
            throw new s(t2.UnsupportedIsRhs);
          return " (" + u(e2.left, r3, a3, s4, o5) + " IS NOT NULL )";
        case "IN":
          return c3 = [], "expression-list" === e2.right.type ? (c3 = u(e2.right, r3, a3, s4, o5), " (" + u(e2.left, r3, a3, s4, o5) + " IN (" + c3.join(",") + ")) ") : (g3 = u(e2.right, r3, a3, s4, o5), g3 instanceof Array ? " (" + u(e2.left, r3, a3, s4, o5) + " IN (" + g3.join(",") + ")) " : " (" + u(e2.left, r3, a3, s4, o5) + " IN (" + g3 + ")) ");
        case "NOT IN":
          return c3 = [], "expression-list" === e2.right.type ? (c3 = u(e2.right, r3, a3, s4, o5), " (" + u(e2.left, r3, a3, s4, o5) + " NOT IN (" + c3.join(",") + ")) ") : (g3 = u(e2.right, r3, a3, s4, o5), g3 instanceof Array ? " (" + u(e2.left, r3, a3, s4, o5) + " NOT IN (" + g3.join(",") + ")) " : " (" + u(e2.left, r3, a3, s4, o5) + " NOT IN (" + g3 + ")) ");
        case "BETWEEN":
          return p4 = u(e2.right, r3, a3, s4, o5), " (" + u(e2.left, r3, a3, s4, o5) + " BETWEEN " + p4[0] + " AND " + p4[1] + " ) ";
        case "NOTBETWEEN":
          return p4 = u(e2.right, r3, a3, s4, o5), " (" + u(e2.left, r3, a3, s4, o5) + " NOT BETWEEN " + p4[0] + " AND " + p4[1] + " ) ";
        case "LIKE":
          return "" !== e2.escape ? " (" + u(e2.left, r3, a3, s4, o5) + " LIKE " + u(e2.right, r3, a3, s4, o5) + " ESCAPE '" + e2.escape + "') " : " (" + u(e2.left, r3, a3, s4, o5) + " LIKE " + u(e2.right, r3, a3, s4, o5) + ") ";
        case "NOT LIKE":
          return "" !== e2.escape ? " (" + u(e2.left, r3, a3, s4, o5) + " NOT LIKE " + u(e2.right, r3, a3, s4, o5) + " ESCAPE '" + e2.escape + "') " : " (" + u(e2.left, r3, a3, s4, o5) + " NOT LIKE " + u(e2.right, r3, a3, s4, o5) + ") ";
        case "<>":
        case "<":
        case ">":
        case ">=":
        case "<=":
        case "=":
        case "*":
        case "-":
        case "+":
        case "/":
          return " (" + u(e2.left, r3, a3, s4, o5) + " " + e2.operator + " " + u(e2.right, r3, a3, s4, o5) + ") ";
      }
      throw new s(t2.UnsupportedOperator, { operator: e2.operator });
    case "null":
      return "null";
    case "boolean":
      return true === e2.value ? "1" : "0";
    case "string":
      return "'" + e2.value.toString().replace(/'/g, "''") + "'";
    case "timestamp":
    case "date":
      return f4(e2.value, r3);
    case "number":
      return e2.value.toString();
    case "current-time":
      return d2("date" === e2.mode, r3);
    case "column-reference":
      return s4 && s4.toLowerCase() === e2.column.toLowerCase() ? "(" + o5 + ")" : e2.column;
    case "function": {
      const t4 = u(e2.args, r3, a3, s4, o5);
      return l2(e2.name, t4, r3);
    }
  }
  throw new s(t2.UnsupportedSyntax, { node: e2.type });
}
function l2(r3, a3, s4) {
  switch (r3.toLowerCase().trim()) {
    case "abs":
      if (1 !== a3.length)
        throw new s(t2.InvalidFunctionParameters, { function: "abs" });
      return "abs(" + a3[0] + ")";
    case "ceiling":
    case "ceil":
      if (1 !== a3.length)
        throw new s(t2.InvalidFunctionParameters, { function: "ceiling" });
      switch (s4) {
        case t.Standardised:
        case t.StandardisedNoInterval:
      }
      return "CEILING(" + a3[0] + ")";
    case "floor":
      if (1 !== a3.length)
        throw new s(t2.InvalidFunctionParameters, { function: "floor" });
      return "FLOOR(" + a3[0] + ")";
    case "log":
      if (1 !== a3.length)
        throw new s(t2.InvalidFunctionParameters, { function: "log" });
      return "LOG(" + a3[0] + ")";
    case "log10":
      if (1 !== a3.length)
        throw new s(t2.InvalidFunctionParameters, { function: "log10" });
      return "LOG10(" + a3[0] + ")";
    case "power":
      if (2 !== a3.length)
        throw new s(t2.InvalidFunctionParameters, { function: "power" });
      return "POWER(" + a3[0] + "," + a3[1] + ")";
    case "round":
      if (2 === a3.length)
        return "ROUND(" + a3[0] + "," + a3[1] + ")";
      if (1 === a3.length)
        return "ROUND(" + a3[0] + ")";
      throw new s(t2.InvalidFunctionParameters, { function: "round" });
    case "truncate":
      if (a3.length < 1 || a3.length > 2)
        throw new s(t2.InvalidFunctionParameters, { function: "truncate" });
      return s4 === t.SqlServer ? "ROUND(" + a3[0] + (1 === a3.length ? "0" : "," + a3[1]) + ",1)" : "TRUNCATE(" + a3[0] + (1 === a3.length ? ")" : "," + a3[1] + ")");
    case "char_length":
    case "len":
      if (1 !== a3.length)
        throw new s(t2.InvalidFunctionParameters, { function: "char_length" });
      switch (s4) {
        case t.SqlServer:
          return "LEN(" + a3[0] + ")";
        case t.Oracle:
          return "LENGTH(" + a3[0] + ")";
        default:
          return "CHAR_LENGTH(" + a3[0] + ")";
      }
    case "concat":
      if (a3.length < 1)
        throw new s(t2.InvalidFunctionParameters, { function: "concat" });
      {
        let e2 = "CONCAT(";
        for (let r4 = 0; r4 < a3.length; r4++)
          0 !== r4 && (e2 += ","), e2 += a3[r4];
        return e2 += ")", e2;
      }
    case "lower":
    case "lcase":
      if (1 !== a3.length)
        throw new s(t2.InvalidFunctionParameters, { function: "lower" });
      return "LOWER(" + a3[0] + ")";
    case "upper":
    case "ucase":
      if (1 !== a3.length)
        throw new s(t2.InvalidFunctionParameters, { function: "upper" });
      return "UPPER(" + a3[0] + ")";
    case "substring": {
      let r4 = "";
      switch (s4) {
        case t.Oracle:
          return r4 = "SUBSTR(" + a3[0] + "," + a3[1], 3 === a3.length && (r4 += "," + a3[2]), r4 += ")", r4;
        case t.SqlServer:
          return r4 = 3 === a3.length ? "SUBSTRING(" + a3[0] + "," + a3[1] + "," + a3[2] + ")" : "SUBSTRING(" + a3[0] + ",  " + a3[1] + ", LEN(" + a3[0] + ") - " + a3[1] + ")", r4;
        default:
          return r4 = "SUBSTRING(" + a3[0] + " FROM " + a3[1], 3 === a3.length && (r4 += " FOR " + a3[2]), r4 += ")", r4;
      }
    }
    case "extract":
      return "EXTRACT(" + a3[0].replace(/\'/g, "") + " FROM " + a3[1] + ")";
  }
  throw new s(t2.InvalidFunctionParameters, { function: r3 });
}
function f4(r3, t4) {
  const n2 = r3 instanceof Date ? DateTime.fromJSDate(r3) : DateTime.fromSQL(r3), s4 = 0 === n2.hour && 0 === n2.minute && 0 === n2.second && 0 === n2.millisecond;
  switch (t4) {
    case t.FILEGDB:
    case t.Standardised:
    case t.StandardisedNoInterval:
      return s4 ? `date '${n2.toFormat("yyyy-LL-dd")}'` : `date '${n2.toFormat("yyyy-LL-dd HH:mm:ss")}'`;
    case t.Oracle:
      return s4 ? `TO_DATE('${n2.toFormat("yyyy-LL-dd")}','YYYY-MM-DD')` : `TO_DATE('${n2.toFormat("yyyy-LL-dd HH:mm:ss")}','YYYY-MM-DD HH24:MI:SS')`;
    case t.SqlServer:
      return `'${n2.toFormat(s4 ? "yyyy-LL-dd" : "yyyy-LL-dd HH:mm:ss")}'`;
    case t.PGDB:
      return `#${n2.toFormat(s4 ? "LL-dd-yyyy" : "LL-dd-yyyy HH:mm:ss")}#`;
    case t.Postgres:
      return `TIMESTAMP '${n2.toFormat(s4 ? "yyyy-LL-dd" : "yyyy-LL-dd HH:mm:ss")}'`;
    default:
      return `date '${n2.toFormat("yyyy-LL-dd HH:mm:ss")}'`;
  }
}
function d2(r3, t4) {
  switch (t4) {
    case t.FILEGDB:
    case t.Standardised:
    case t.StandardisedNoInterval:
    case t.Oracle:
      return r3 ? "CURRENT_DATE" : "CURRENT_TIMESTAMP";
    case t.SqlServer:
      return r3 ? "CAST(GETDATE() AS DATE)" : "GETDATE()";
    case t.PGDB:
    case t.Postgres:
    default:
      return r3 ? "CURRENT_DATE" : "CURRENT_TIMESTAMP";
  }
}
function p2(e2, r3, t4 = {}) {
  const n2 = {}, a3 = {}, s4 = { esriFieldTypeSmallInteger: "integer", esriFieldTypeInteger: "integer", esriFieldTypeSingle: "double", esriFieldTypeDouble: "double", esriFieldTypeString: "string", esriFieldTypeDate: "date", esriFieldTypeOID: "integer", oid: "integer", long: "integer", "small-integer": "integer", integer: "integer", single: "double", double: "double", date: "date", string: "string" };
  for (const o5 of r3) {
    const e3 = o5.type ? s4[o5.type] : void 0;
    n2[o5.name.toLowerCase()] = void 0 === e3 ? "" : e3;
  }
  for (const o5 in t4) {
    const e3 = s4[t4[o5]];
    a3[o5.toLowerCase()] = void 0 === e3 ? "" : e3;
  }
  switch (g(n2, e2.parseTree, e2.parameters, a3)) {
    case "double":
      return "double";
    case "integer":
      return "integer";
    case "date":
      return "date";
    case "string":
      return "string";
  }
  return "";
}
function g(e2, r3, a3, s4) {
  let o5;
  switch (r3.type) {
    case "interval":
      return "integer";
    case "case-expression": {
      const t4 = [];
      if ("simple" === r3.format) {
        for (let n2 = 0; n2 < r3.clauses.length; n2++)
          t4.push(g(e2, r3.clauses[n2].value, a3, s4));
        null !== r3.else && t4.push(g(e2, r3.else, a3, s4));
      } else {
        for (let n2 = 0; n2 < r3.clauses.length; n2++)
          t4.push(g(e2, r3.else, a3, s4));
        null !== r3.else && t4.push(g(e2, r3.else, a3, s4));
      }
      return m3(t4);
    }
    case "parameter": {
      const e3 = s4[r3.value.toLowerCase()];
      if (void 0 === e3 && a3) {
        const e4 = a3[r3.value.toLowerCase()];
        if (void 0 === e4)
          return "";
        if (null === e4)
          return "";
        if ("string" == typeof e4 || e4 instanceof String)
          return "string";
        if ("boolean" == typeof e4)
          return "boolean";
        if (e4 instanceof Date)
          return "date";
        if ("number" == typeof e4)
          return e4 % 1 == 0 ? "integer" : "double";
      }
      return void 0 === e3 ? "" : e3;
    }
    case "expression-list": {
      const t4 = [];
      for (const n2 of r3.value)
        t4.push(g(e2, n2, a3, s4));
      return t4;
    }
    case "unary-expression":
      return "boolean";
    case "binary-expression":
      switch (r3.operator) {
        case "AND":
        case "OR":
        case "IN":
        case "NOT IN":
        case "BETWEEN":
        case "NOTBETWEEN":
        case "LIKE":
        case "NOT LIKE":
        case "<>":
        case "<":
        case ">":
        case ">=":
        case "<=":
        case "=":
          return "boolean";
        case "IS":
        case "ISNOT":
          if ("null" !== r3.right.type)
            throw new s(t2.UnsupportedIsRhs);
          return "boolean";
        case "*":
        case "-":
        case "+":
        case "/":
          return m3([g(e2, r3.left, a3, s4), g(e2, r3.right, a3, s4)]);
        default:
          throw new s(t2.UnsupportedOperator, { operator: r3.operator });
      }
    case "null":
      return "";
    case "boolean":
      return "boolean";
    case "string":
      return "string";
    case "number":
      return null === r3.value ? "" : r3.value % 1 == 0 ? "integer" : "double";
    case "date":
    case "timestamp":
    case "current-time":
      return "date";
    case "column-reference": {
      const t4 = e2[r3.column.toLowerCase()];
      return void 0 === t4 ? "" : t4;
    }
    case "function":
      switch (r3.name.toLowerCase()) {
        case "position":
        case "extract":
        case "char_length":
          return "integer";
        case "round":
          return o5 = g(e2, r3.args, a3, s4), o5 instanceof Array ? o5.length > 0 ? o5[0] : "" : o5;
        case "sign":
          return o5 = g(e2, r3.args, a3, s4), o5 instanceof Array && (o5 = m3(o5)), "integer" === o5 || "double" === o5 ? o5 : "double";
        case "ceiling":
        case "floor":
        case "abs": {
          const t4 = g(e2, r3.args, a3, s4);
          return t4 instanceof Array ? m3(t4) : t4;
        }
        case "area":
        case "length":
        case "log":
        case "log10":
        case "sin":
        case "cos":
        case "tan":
        case "asin":
        case "acos":
        case "atan":
        case "power":
        case "truncate":
          return "double";
        case "substring":
        case "trim":
        case "concat":
        case "lower":
        case "upper":
          return "string";
      }
      return "";
  }
  throw new s(t2.UnsupportedSyntax, { node: r3.type });
}
var h2 = { boolean: 1, string: 2, integer: 3, double: 4, date: 5 };
function m3(e2) {
  if (e2) {
    let r3 = "";
    for (const t4 of e2)
      "" !== t4 && (r3 = "" === r3 || h2[r3] < h2[t4] ? t4 : r3);
    return r3;
  }
  return "";
}
function y2(e2, r3) {
  return T(e2.parseTree, r3);
}
function w(e2) {
  return "column-reference" === (e2 == null ? void 0 : e2.parseTree.type);
}
function T(e2, r3) {
  if (null == e2)
    return false;
  switch (e2.type) {
    case "when-clause":
      return T(e2.operand, r3) || T(e2.value, r3);
    case "case-expression":
      for (const t4 of e2.clauses)
        if (T(t4, r3))
          return true;
      return !("simple" !== e2.format || !T(e2.operand, r3)) || !(null === e2.else || !T(e2.else, r3));
    case "parameter":
    case "null":
    case "boolean":
    case "date":
    case "timestamp":
    case "string":
    case "number":
      return false;
    case "expression-list":
      for (const t4 of e2.value)
        if (T(t4, r3))
          return true;
      return false;
    case "unary-expression":
      return T(e2.expr, r3);
    case "binary-expression":
      return T(e2.left, r3) || T(e2.right, r3);
    case "column-reference":
      return r3.toLowerCase() === e2.column.toLowerCase();
    case "function":
      return T(e2.args, r3);
  }
  return false;
}
function E(e2) {
  let r3 = "";
  return r3 += e2.period.toUpperCase(), r3;
}
function N(e2, r3, t4) {
  let n2 = "";
  return n2 = "interval-period" === r3.type ? E(r3) : E(r3.start) + " TO " + E(r3.end), "INTERVAL " + t4 + " " + e2 + " " + n2;
}

// node_modules/@arcgis/core/arcade/featureset/support/FeatureSetIterator.js
var e = class {
  constructor(t4, e2) {
    this._lastId = -1, this._progress = e2, this._parent = t4;
  }
  reset() {
    this._lastId = -1;
  }
  nextBatch(e2) {
    if (null !== this._parent._mainSetInUse)
      return this._parent._mainSetInUse.then((t4) => this.nextBatch(e2), (t4) => this.nextBatch(e2));
    const n2 = { returnpromise: null, hasset: false }, s4 = [];
    return n2.returnpromise = new Promise((a3, i5) => {
      this._parent._getSet(this._progress).then((r3) => {
        const h4 = f(r3._known, "known");
        let _ = h4.length - 1;
        if ("GETPAGES" === h4[h4.length - 1] && (_ -= 1), this._lastId + e2 > _ && h4.length > 0 && "GETPAGES" === h4[h4.length - 1])
          return void this._parent._expandPagedSet(r3, this._parent._maxQueryRate(), 0, 0, this._progress).then((t4) => {
            n2.hasset = true, this._parent._mainSetInUse = null, this.nextBatch(e2).then(a3, i5);
          }, (t4) => {
            n2.hasset = true, this._parent._mainSetInUse = null, i5(t4);
          });
        const l4 = f(r3._candidates, "candidates");
        if (_ >= this._lastId + e2 || 0 === l4.length) {
          for (let t4 = 0; t4 < e2; t4++) {
            const e3 = t4 + this._lastId + 1;
            if (e3 >= h4.length)
              break;
            s4[t4] = h4[e3];
          }
          return this._lastId += s4.length, 0 === s4.length && (n2.hasset = true, this._parent._mainSetInUse = null, a3([])), void this._parent._getFeatureBatch(s4, this._progress).then((t4) => {
            n2.hasset = true, this._parent._mainSetInUse = null, a3(t4);
          }, (t4) => {
            n2.hasset = true, this._parent._mainSetInUse = null, i5(t4);
          });
        }
        this._parent._refineSetBlock(r3, this._parent._maxProcessingRate(), this._progress).then(() => {
          n2.hasset = true, this._parent._mainSetInUse = null, this.nextBatch(e2).then(a3, i5);
        }, (t4) => {
          n2.hasset = true, this._parent._mainSetInUse = null, i5(t4);
        });
      }, (t4) => {
        n2.hasset = true, this._parent._mainSetInUse = null, i5(t4);
      });
    }), false === n2.hasset && (this._parent._mainSetInUse = n2.returnpromise, n2.hasset = true), n2.returnpromise;
  }
  next() {
    if (null !== this._parent._mainSetInUse)
      return this._parent._mainSetInUse.then((t4) => this.next(), (t4) => this.next());
    const e2 = { returnpromise: null, hasset: false };
    return e2.returnpromise = new Promise((n2, s4) => {
      this._parent._getSet(this._progress).then((a3) => {
        const i5 = f(a3._known, "known");
        if (this._lastId < i5.length - 1)
          "GETPAGES" === i5[this._lastId + 1] ? this._parent._expandPagedSet(a3, this._parent._maxQueryRate(), 0, 0, this._progress).then((t4) => (e2.hasset = true, this._parent._mainSetInUse = null, this.next())).then(n2, s4) : (this._lastId += 1, this._parent._getFeature(a3, i5[this._lastId], this._progress).then((t4) => {
            e2.hasset = true, this._parent._mainSetInUse = null, n2(t4);
          }, (t4) => {
            e2.hasset = true, this._parent._mainSetInUse = null, s4(t4);
          }));
        else {
          f(a3._candidates, "candidates").length > 0 ? this._parent._refineSetBlock(a3, this._parent._maxProcessingRate(), this._progress).then(() => {
            e2.hasset = true, this._parent._mainSetInUse = null, this.next().then(n2, s4);
          }, (t4) => {
            e2.hasset = true, this._parent._mainSetInUse = null, s4(t4);
          }) : (e2.hasset = true, this._parent._mainSetInUse = null, n2(null));
        }
      }, (t4) => {
        e2.hasset = true, this._parent._mainSetInUse = null, s4(t4);
      });
    }), false === e2.hasset && (this._parent._mainSetInUse = e2.returnpromise, e2.hasset = true), e2.returnpromise;
  }
  async count() {
    if (-1 !== this._parent._totalCount)
      return this._parent._totalCount;
    const t4 = await this._parent._getSet(this._progress), e2 = await this._refineAllSets(t4);
    return this._parent._totalCount = e2._known.length, this._parent._totalCount;
  }
  async _refineAllSets(t4) {
    if (t4._known.length > 0 && "GETPAGES" === t4._known[t4._known.length - 1])
      return await this._parent._expandPagedSet(t4, this._parent._maxQueryRate(), 0, 1, this._progress), this._refineAllSets(t4);
    if (t4._candidates.length > 0) {
      if ("GETPAGES" === t4._known[t4._candidates.length - 1])
        return await this._parent._expandPagedSet(t4, this._parent._maxQueryRate(), 0, 2, this._progress), this._refineAllSets(t4);
      const e2 = await this._parent._refineSetBlock(t4, this._parent._maxProcessingRate(), this._progress);
      return e2._candidates.length > 0 ? this._refineAllSets(e2) : e2;
    }
    return t4;
  }
};

// node_modules/@arcgis/core/arcade/featureset/support/IdSet.js
var t3 = class {
  constructor(t4, s4, e2, i5) {
    this._lastFetchedIndex = 0, this._ordered = false, this.pagesDefinition = null, this._candidates = t4, this._known = s4, this._ordered = e2, this.pagesDefinition = i5;
  }
};

// node_modules/@arcgis/core/arcade/featureset/support/stats.js
function s3(t4) {
  return t4 = +t4, isFinite(t4) ? t4 - t4 % 1 || (t4 < 0 ? -0 : 0 === t4 ? t4 : 0) : t4;
}
function i4(t4) {
  let n2 = 0;
  for (let e2 = 0; e2 < t4.length; e2++)
    n2 += t4[e2];
  return n2 / t4.length;
}
function l3(t4) {
  const n2 = i4(t4);
  let e2 = 0;
  for (let r3 = 0; r3 < t4.length; r3++)
    e2 += (n2 - t4[r3]) ** 2;
  return e2 / t4.length;
}
function o4(t4) {
  const n2 = i4(t4);
  let e2 = 0;
  for (let r3 = 0; r3 < t4.length; r3++)
    e2 += (n2 - t4[r3]) ** 2;
  return e2 / (t4.length - 1);
}
function h3(t4) {
  let n2 = 0;
  for (let e2 = 0; e2 < t4.length; e2++)
    n2 += t4[e2];
  return n2;
}
function f5(t4, n2) {
  const c3 = [], u3 = {}, s4 = [];
  for (let i5 = 0; i5 < t4.length; i5++) {
    if (void 0 !== t4[i5] && null !== t4[i5]) {
      const n3 = t4[i5];
      if (y(n3) || l(n3))
        void 0 === u3[n3] && (c3.push(n3), u3[n3] = 1);
      else {
        let t5 = false;
        for (let e2 = 0; e2 < s4.length; e2++)
          true === c(s4[e2], n3) && (t5 = true);
        false === t5 && (s4.push(n3), c3.push(n3));
      }
    }
    if (c3.length >= n2 && -1 !== n2)
      return c3;
  }
  return c3;
}
function m4(t4) {
  switch (t4.toLowerCase()) {
    case "distinct":
      return "distinct";
    case "avg":
    case "mean":
      return "avg";
    case "min":
      return "min";
    case "sum":
      return "sum";
    case "max":
      return "max";
    case "stdev":
    case "stddev":
      return "stddev";
    case "var":
    case "variance":
      return "var";
    case "count":
      return "count";
  }
  return "";
}
function g2(t4, n2, e2 = 1e3) {
  switch (t4.toLowerCase()) {
    case "distinct":
      return f5(n2, e2);
    case "avg":
    case "mean":
      return i4(n2);
    case "min":
      return Math.min.apply(Math, n2);
    case "sum":
      return h3(n2);
    case "max":
      return Math.max.apply(Math, n2);
    case "stdev":
    case "stddev":
      return Math.sqrt(l3(n2));
    case "var":
    case "variance":
      return l3(n2);
    case "count":
      return n2.length;
  }
  return 0;
}
async function w2(t4, n2, e2) {
  const r3 = await k2(t4, n2, e2, true);
  return 0 === r3.length ? null : Math.min.apply(Math, r3);
}
async function d3(t4, n2, e2) {
  const r3 = await k2(t4, n2, e2, true);
  return 0 === r3.length ? null : Math.max.apply(Math, r3);
}
async function p3(t4, n2, e2) {
  let r3 = "";
  n2 && !w(n2) && (r3 = p2(n2, t4.fields));
  const a3 = await k2(t4, n2, e2, true);
  if (0 === a3.length)
    return null;
  const l4 = i4(a3);
  return null === l4 ? l4 : "integer" === r3 ? s3(l4) : l4;
}
async function v2(t4, n2, e2) {
  const r3 = await k2(t4, n2, e2, true);
  return 0 === r3.length ? null : o4(r3);
}
async function y3(t4, n2, e2) {
  const r3 = await k2(t4, n2, e2, true);
  return 0 === r3.length ? null : Math.sqrt(o4(r3));
}
async function x2(t4, n2, e2) {
  const r3 = await k2(t4, n2, e2, true);
  return 0 === r3.length ? null : h3(r3);
}
async function M2(t4, n2) {
  return t4.iterator(n2).count();
}
async function k2(e2, r3, a3, c3 = false) {
  const u3 = e2.iterator(a3), s4 = [], i5 = { ticker: 0 };
  let l4 = await u3.next();
  for (; null !== l4; ) {
    if (i5.ticker++, a3.aborted)
      throw new o2(n.Cancelled);
    i5.ticker % 100 == 0 && (i5.ticker = 0, await new Promise((t4) => {
      setTimeout(t4, 0);
    }));
    const e3 = r3 == null ? void 0 : r3.calculateValue(l4);
    null === e3 ? false === c3 && (s4[s4.length] = e3) : s4[s4.length] = e3, l4 = await u3.next();
  }
  return s4;
}
async function C2(e2, r3, a3 = 1e3, c3 = null) {
  const u3 = e2.iterator(c3), s4 = [], i5 = {}, l4 = { ticker: 0 };
  let o5 = await u3.next();
  for (; null !== o5; ) {
    if (l4.ticker++, c3 && c3.aborted)
      throw new o2(n.Cancelled);
    l4.ticker % 100 == 0 && (l4.ticker = 0, await new Promise((t4) => {
      setTimeout(t4, 0);
    }));
    const e3 = r3 == null ? void 0 : r3.calculateValue(o5);
    if (null != e3 && void 0 === i5[e3] && (s4.push(e3), i5[e3] = 1), s4.length >= a3 && -1 !== a3)
      return s4;
    o5 = await u3.next();
  }
  return s4;
}

// node_modules/@arcgis/core/arcade/featureset/support/FeatureSet.js
var C3 = class {
  constructor(e2) {
    this.recentlyUsedQueries = null, this.featureSetQueryInterceptor = null, this._idstates = [], this._parent = null, this._wset = null, this._mainSetInUse = null, this._maxProcessing = 200, this._maxQuery = 500, this._totalCount = -1, this._databaseType = t.NotEvaluated, this._databaseTypeProbed = null, this.declaredRootClass = "esri.arcade.featureset.support.FeatureSet", this._featureCache = [], this.typeIdField = null, this.types = null, this.fields = null, this.geometryType = "", this.objectIdField = "", this.globalIdField = "", this.spatialReference = null, this.hasM = false, this.hasZ = false, this._transparent = false, this.loaded = false, this._loadPromise = null, this._fieldsIndex = null, e2 && e2.lrucache && (this.recentlyUsedQueries = e2.lrucache), e2 && e2.interceptor && (this.featureSetQueryInterceptor = e2.interceptor);
  }
  optimisePagingFeatureQueries(e2) {
    this._parent && this._parent.optimisePagingFeatureQueries(e2);
  }
  _hasMemorySource() {
    return true;
  }
  prop(e2, t4) {
    return void 0 === t4 ? this[e2] : (void 0 !== this[e2] && (this[e2] = t4), this);
  }
  end() {
    return null !== this._parent && true === this._parent._transparent ? this._parent.end() : this._parent;
  }
  _ensureLoaded() {
    return this.load();
  }
  load() {
    return null === this._loadPromise && (this._loadPromise = this.loadImpl()), this._loadPromise;
  }
  async loadImpl() {
    var _a, _b;
    return true === ((_a = this._parent) == null ? void 0 : _a.loaded) ? (this._initialiseFeatureSet(), this) : (await ((_b = this._parent) == null ? void 0 : _b.load()), this._initialiseFeatureSet(), this);
  }
  _initialiseFeatureSet() {
    null !== this._parent ? (this.fields = this._parent.fields.slice(0), this.geometryType = this._parent.geometryType, this.objectIdField = this._parent.objectIdField, this.globalIdField = this._parent.globalIdField, this.spatialReference = this._parent.spatialReference, this.hasM = this._parent.hasM, this.hasZ = this._parent.hasZ, this.typeIdField = this._parent.typeIdField, this.types = this._parent.types) : (this.fields = [], this.typeIdField = "", this.objectIdField = "", this.globalIdField = "", this.spatialReference = new k({ wkid: 4326 }), this.geometryType = S.point);
  }
  getField(e2, t4) {
    let s4;
    return (t4 = t4 || this.fields) && (e2 = e2.toLowerCase(), t4.some((t5) => (t5 && t5.name.toLowerCase() === e2 && (s4 = t5), !!s4))), s4;
  }
  getFieldsIndex() {
    return null === this._fieldsIndex && (this._fieldsIndex = new r(this.fields)), this._fieldsIndex;
  }
  _maxProcessingRate() {
    return null !== this._parent ? Math.min(this._maxProcessing, this._parent._maxProcessingRate()) : Math.min(this._maxProcessing, this._maxQueryRate());
  }
  _maxQueryRate() {
    return null !== this._parent ? Math.max(this._maxQuery, this._parent._maxQueryRate()) : this._maxQuery;
  }
  _checkCancelled(e2) {
    if (null != e2 && e2.aborted)
      throw new o2(n.Cancelled);
  }
  nativeCapabilities() {
    return this._parent.nativeCapabilities();
  }
  async _canDoAggregates(e2, t4, s4, a3, r3) {
    return null !== this._parent && this._parent._canDoAggregates(e2, t4, s4, a3, r3);
  }
  async _getAggregatePagesDataSourceDefinition(e2, a3, r3, n2, i5, l4, u3) {
    if (null === this._parent)
      throw new o2(n.NeverReach);
    return this._parent._getAggregatePagesDataSourceDefinition(e2, a3, r3, n2, i5, l4, u3);
  }
  async _getAgregagtePhysicalPage(e2, a3, r3) {
    if (null === this._parent)
      throw new o2(n.NeverReach);
    return this._parent._getAgregagtePhysicalPage(e2, a3, r3);
  }
  async databaseType() {
    if (this._databaseType === t.NotEvaluated) {
      if (null !== a2.applicationCache) {
        const t4 = a2.applicationCache.getDatabaseType(this._cacheableFeatureSetSourceKey());
        if (null !== t4)
          return t4;
      }
      if (null !== this._databaseTypeProbed)
        return this._databaseTypeProbed;
      try {
        this._databaseTypeProbed = this._getDatabaseTypeImpl(), null !== a2.applicationCache && a2.applicationCache.setDatabaseType(this._cacheableFeatureSetSourceKey(), this._databaseTypeProbed);
      } catch (t4) {
        throw null !== a2.applicationCache && a2.applicationCache.clearDatabaseType(this._cacheableFeatureSetSourceKey()), t4;
      }
      return this._databaseTypeProbed;
    }
    return this._databaseType;
  }
  async _getDatabaseTypeImpl() {
    const e2 = [{ thetype: t.SqlServer, testwhere: "(CAST( '2015-01-01' as DATETIME) = CAST( '2015-01-01' as DATETIME)) AND OBJECTID<0" }, { thetype: t.Oracle, testwhere: "(TO_DATE('2003-11-18','YYYY-MM-DD') = TO_DATE('2003-11-18','YYYY-MM-DD')) AND OBJECTID<0" }, { thetype: t.StandardisedNoInterval, testwhere: "(date '2015-01-01 10:10:10' = date '2015-01-01 10:10:10') AND OBJECTID<0" }];
    for (const t4 of e2) {
      if (true === await this._runDatabaseProbe(t4.testwhere))
        return t4.thetype;
    }
    return t.StandardisedNoInterval;
  }
  _cacheableFeatureSetSourceKey() {
    return "MUSTBESET";
  }
  async _runDatabaseProbe(e2) {
    if (null !== this._parent)
      return this._parent._runDatabaseProbe(e2);
    throw new o2(n.NotImplemented);
  }
  isTable() {
    var _a, _b;
    return (_b = (_a = this._parent) == null ? void 0 : _a.isTable()) != null ? _b : false;
  }
  _featureFromCache(e2) {
    if (void 0 !== this._featureCache[e2])
      return this._featureCache[e2];
  }
  _isInFeatureSet(e2) {
    return i2.Unknown;
  }
  _getSet(e2) {
    throw new o2(n.NotImplemented);
  }
  async _getFeature(e2, a3, r3) {
    if (this._checkCancelled(r3), void 0 !== this._featureFromCache(a3))
      return this._featureFromCache(a3);
    if (await this._getFeatures(e2, a3, this._maxProcessingRate(), r3), this._checkCancelled(r3), void 0 !== this._featureFromCache(a3))
      return this._featureFromCache(a3);
    throw new o2(n.MissingFeatures);
  }
  async _getFeatureBatch(e2, t4) {
    this._checkCancelled(t4);
    const s4 = new t3([], e2, false, null), a3 = [];
    await this._getFeatures(s4, -1, e2.length, t4), this._checkCancelled(t4);
    for (const r3 of e2)
      void 0 !== this._featureFromCache(r3) && a3.push(this._featureFromCache(r3));
    return a3;
  }
  async _getFeatures(e2, t4, s4, a3) {
    return "success";
  }
  _getFilteredSet(e2, a3, r3, n2, i5) {
    throw new o2(n.NotImplemented);
  }
  async _refineSetBlock(e2, t4, s4) {
    if (true === this._checkIfNeedToExpandCandidatePage(e2, this._maxQueryRate()))
      return await this._expandPagedSet(e2, this._maxQueryRate(), 0, 0, s4), this._refineSetBlock(e2, t4, s4);
    this._checkCancelled(s4);
    const a3 = e2._candidates.length;
    this._refineKnowns(e2, t4);
    let r3 = a3 - e2._candidates.length;
    if (0 === e2._candidates.length)
      return e2;
    if (r3 >= t4)
      return e2;
    if (await this._refineIfParentKnown(e2, t4 - r3, s4), this._checkCancelled(s4), this._refineKnowns(e2, t4 - r3), r3 = a3 - e2._candidates.length, r3 < t4 && e2._candidates.length > 0) {
      const a4 = t4 - r3, n2 = this._prepareFetchAndRefineSet(e2._candidates);
      return await this._fetchAndRefineFeatures(n2, n2.length > a4 ? a4 : e2._candidates.length, s4), this._checkCancelled(s4), this._refineKnowns(e2, t4 - r3), e2;
    }
    return e2;
  }
  _fetchAndRefineFeatures(e2, t4, s4) {
    return null;
  }
  _prepareFetchAndRefineSet(e2) {
    const t4 = [];
    for (let s4 = 0; s4 < e2.length; s4++)
      this._isPhysicalFeature(e2[s4]) && t4.push(e2[s4]);
    return t4;
  }
  _isPhysicalFeature(e2) {
    return null === this._parent || this._parent._isPhysicalFeature(e2);
  }
  _refineKnowns(e2, t4) {
    let s4 = 0, a3 = null;
    const r3 = [];
    t4 = this._maxQueryRate();
    for (let n2 = 0; n2 < e2._candidates.length && "GETPAGES" !== e2._candidates[n2]; n2++) {
      let i5 = false;
      const u3 = this._candidateIdTransform(e2._candidates[n2]);
      u3 !== e2._candidates[n2] && (i5 = true);
      const h4 = this._isInFeatureSet(u3);
      if (h4 === i2.InFeatureSet)
        true === i5 ? e2._known.includes(u3) || (e2._known.push(u3), s4 += 1) : (e2._known.push(e2._candidates[n2]), s4 += 1), null === a3 ? a3 = { start: n2, end: n2 } : a3.end === n2 - 1 ? a3.end = n2 : (r3.push(a3), a3 = { start: n2, end: n2 });
      else if (h4 === i2.NotInFeatureSet)
        null === a3 ? a3 = { start: n2, end: n2 } : a3.end === n2 - 1 ? a3.end = n2 : (r3.push(a3), a3 = { start: n2, end: n2 }), s4 += 1;
      else if (h4 === i2.Unknown && (s4 += 1, true === e2._ordered))
        break;
      if (s4 >= t4)
        break;
    }
    null !== a3 && r3.push(a3);
    for (let n2 = r3.length - 1; n2 >= 0; n2--)
      e2._candidates.splice(r3[n2].start, r3[n2].end - r3[n2].start + 1);
  }
  _refineIfParentKnown(e2, t4, s4) {
    const a3 = new t3([], [], e2._ordered, null);
    return a3._candidates = e2._candidates.slice(0), this._parent._refineSetBlock(a3, t4, s4);
  }
  _candidateIdTransform(e2) {
    return this._parent._candidateIdTransform(e2);
  }
  _checkIfNeedToExpandKnownPage(e2, t4) {
    if (null === e2.pagesDefinition)
      return false;
    let s4 = 0;
    for (let a3 = e2._lastFetchedIndex; a3 < e2._known.length; a3++) {
      if ("GETPAGES" === e2._known[a3])
        return true;
      if (void 0 === this._featureCache[e2._known[a3]] && (s4 += 1, s4 >= t4))
        break;
    }
    return false;
  }
  _checkIfNeedToExpandCandidatePage(e2, t4) {
    if (null === e2.pagesDefinition)
      return false;
    let s4 = 0;
    for (let a3 = 0; a3 < e2._candidates.length; a3++) {
      if ("GETPAGES" === e2._candidates[a3])
        return true;
      if (s4 += 1, s4 >= t4)
        break;
    }
    return false;
  }
  async _expandPagedSet(e2, a3, r3, n2, i5) {
    if (null === this._parent)
      throw new o2(n.NotImplemented);
    return this._parent._expandPagedSet(e2, a3, r3, n2, i5);
  }
  async _expandPagedSetFeatureSet(e2, t4, s4, a3, r3) {
    if (e2._known.length > 0 && "GETPAGES" === e2._known[e2._known.length - 1] && (a3 = 1), 0 === a3 && e2._candidates.length > 0 && "GETPAGES" === e2._candidates[e2._candidates.length - 1] && (a3 = 2), 0 === a3)
      return "finished";
    const n2 = await this._getPage(e2, a3, r3);
    return s4 + n2 < t4 ? this._expandPagedSet(e2, t4, s4 + n2, 0, r3) : "success";
  }
  async _getPage(e2, t4, s4) {
    const a3 = 1 === t4 ? e2._known : e2._candidates;
    if (e2.pagesDefinition.internal.set.length > e2.pagesDefinition.resultOffset || true === e2.pagesDefinition.internal.fullyResolved) {
      a3.length = a3.length - 1;
      let t5 = 0;
      for (let r3 = 0; r3 < e2.pagesDefinition.resultRecordCount && !(e2.pagesDefinition.resultOffset + r3 >= e2.pagesDefinition.internal.set.length); r3++)
        a3[a3.length] = e2.pagesDefinition.internal.set[e2.pagesDefinition.resultOffset + r3], t5++;
      e2.pagesDefinition.resultOffset += t5;
      let s5 = false;
      return true === e2.pagesDefinition.internal.fullyResolved && e2.pagesDefinition.internal.set.length <= e2.pagesDefinition.resultOffset && (s5 = true), false === s5 && a3.push("GETPAGES"), t5;
    }
    return await this._getPhysicalPage(e2, t4, s4), this._getPage(e2, t4, s4);
  }
  _getPhysicalPage(e2, t4, s4) {
    return null;
  }
  _clonePageDefinition(e2) {
    return null === this._parent ? null : this._parent._clonePageDefinition(e2);
  }
  _first(e2) {
    return this.iterator(e2).next();
  }
  first(e2) {
    return this._first(e2);
  }
  async calculateStatistic(e2, t4, s4, a3) {
    await this._ensureLoaded();
    let r3 = await this._stat(e2, t4, "", null, null, s4, a3);
    return false === r3.calculated && (r3 = await this._manualStat(e2, t4, s4, a3)), r3.result;
  }
  async _manualStat(e2, t4, s4, a3) {
    let r3 = null;
    switch (e2.toLowerCase()) {
      case "count":
        return r3 = await M2(this, a3), { calculated: true, result: r3 };
      case "distinct":
        return r3 = await C2(this, t4, s4, a3), { calculated: true, result: r3 };
      case "avg":
      case "mean":
        return r3 = await p3(this, t4, a3), { calculated: true, result: r3 };
      case "stdev":
        return r3 = await y3(this, t4, a3), { calculated: true, result: r3 };
      case "variance":
        return r3 = await v2(this, t4, a3), { calculated: true, result: r3 };
      case "sum":
        return r3 = await x2(this, t4, a3), { calculated: true, result: r3 };
      case "min":
        return r3 = await w2(this, t4, a3), { calculated: true, result: r3 };
      case "max":
        return r3 = await d3(this, t4, a3), { calculated: true, result: r3 };
      default:
        return { calculated: true, result: 0 };
    }
  }
  async _stat(e2, t4, s4, a3, r3, n2, i5) {
    const l4 = await this._parent._stat(e2, t4, s4, a3, r3, n2, i5);
    return false === l4.calculated ? null === r3 && "" === s4 && null === a3 ? this._manualStat(e2, t4, n2, i5) : { calculated: false } : l4;
  }
  _unionAllGeomSelf(e2) {
    const t4 = this.iterator(this._defaultTracker(e2)), s4 = [];
    return new Promise((e3, a3) => {
      this._unionShapeInBatches(s4, t4, e3, a3);
    });
  }
  _unionAllGeom(e2) {
    return new Promise((t4, s4) => {
      const a3 = this.iterator(this._defaultTracker(e2)), r3 = [];
      this._unionShapeInBatches(r3, a3, t4, s4);
    });
  }
  _unionShapeInBatches(e2, t4, s4, a3) {
    t4.next().then((r3) => {
      try {
        null !== r3 && null !== r3.geometry && e2.push(r3.geometry), e2.length > 30 || null === r3 && e2.length > 1 ? b(e2).then((n2) => {
          try {
            null === r3 ? s4(n2) : (e2 = [n2], this._unionShapeInBatches(e2, t4, s4, a3));
          } catch (i5) {
            a3(i5);
          }
        }, a3) : null === r3 ? 1 === e2.length ? s4(e2[0]) : s4(null) : this._unionShapeInBatches(e2, t4, s4, a3);
      } catch (n2) {
        a3(n2);
      }
    }, a3);
  }
  iterator(e2) {
    return new e(this, e2);
  }
  intersection(e2, t4 = false) {
    return C3._featuresetFunctions.intersection.bind(this)(e2, t4);
  }
  difference(e2, t4 = false, s4 = true) {
    return C3._featuresetFunctions.difference.bind(this)(e2, t4, s4);
  }
  symmetricDifference(e2, t4 = false, s4 = true) {
    return C3._featuresetFunctions.symmetricDifference.bind(this)(e2, t4, s4);
  }
  morphShape(e2, t4, s4 = "unknown", a3 = null) {
    return C3._featuresetFunctions.morphShape.bind(this)(e2, t4, s4, a3);
  }
  morphShapeAndAttributes(e2, t4, s4 = "unknown") {
    return C3._featuresetFunctions.morphShapeAndAttributes.bind(this)(e2, t4, s4);
  }
  union(e2, t4 = false) {
    return C3._featuresetFunctions.union.bind(this)(e2, t4);
  }
  intersects(e2) {
    return C3._featuresetFunctions.intersects.bind(this)(e2);
  }
  envelopeIntersects(e2) {
    return C3._featuresetFunctions.envelopeIntersects.bind(this)(e2);
  }
  contains(e2) {
    return C3._featuresetFunctions.contains.bind(this)(e2);
  }
  overlaps(e2) {
    return C3._featuresetFunctions.overlaps.bind(this)(e2);
  }
  relate(e2, t4) {
    return C3._featuresetFunctions.relate.bind(this)(e2, t4);
  }
  within(e2) {
    return C3._featuresetFunctions.within.bind(this)(e2);
  }
  touches(e2) {
    return C3._featuresetFunctions.touches.bind(this)(e2);
  }
  top(e2) {
    return C3._featuresetFunctions.top.bind(this)(e2);
  }
  crosses(e2) {
    return C3._featuresetFunctions.crosses.bind(this)(e2);
  }
  buffer(e2, t4, s4, a3 = true) {
    return C3._featuresetFunctions.buffer.bind(this)(e2, t4, s4, a3);
  }
  filter(e2, t4 = null) {
    return C3._featuresetFunctions.filter.bind(this)(e2, t4);
  }
  orderBy(e2) {
    return C3._featuresetFunctions.orderBy.bind(this)(e2);
  }
  dissolve(e2, t4) {
    return C3._featuresetFunctions.dissolve.bind(this)(e2, t4);
  }
  groupby(e2, t4) {
    return C3._featuresetFunctions.groupby.bind(this)(e2, t4);
  }
  reduce(e2, t4 = null, s4) {
    return new Promise((a3, r3) => {
      this._reduceImpl(this.iterator(this._defaultTracker(s4)), e2, t4, 0, a3, r3, 0);
    });
  }
  _reduceImpl(e2, t4, s4, a3, r3, n2, i5) {
    try {
      if (++i5 > 1e3)
        return void setTimeout(() => {
          i5 = 0, this._reduceImpl(e2, t4, s4, a3, r3, n2, i5);
        });
      e2.next().then((l4) => {
        try {
          if (null === l4)
            r3(s4);
          else {
            const u3 = t4(s4, l4, a3, this);
            C(u3) ? u3.then((s5) => {
              this._reduceImpl(e2, t4, s5, a3 + 1, r3, n2, i5);
            }, n2) : this._reduceImpl(e2, t4, u3, a3 + 1, r3, n2, i5);
          }
        } catch (u3) {
          n2(u3);
        }
      }, n2);
    } catch (l4) {
      n2(l4);
    }
  }
  removeField(e2) {
    return C3._featuresetFunctions.removeField.bind(this)(e2);
  }
  addField(e2, t4, s4 = null) {
    return C3._featuresetFunctions.addField.bind(this)(e2, t4, s4);
  }
  sumArea(e2, t4 = false, s4) {
    const a3 = m(e2);
    return this.reduce((e3, s5) => null === s5.geometry ? 0 : t4 ? K(s5.geometry, a3).then((t5) => e3 + t5) : W(s5.geometry, a3).then((t5) => e3 + t5), 0, s4);
  }
  sumLength(e2, t4 = false, s4) {
    const a3 = d(e2);
    return this.reduce((e3, s5) => null === s5.geometry ? 0 : t4 ? M(s5.geometry, a3).then((t5) => e3 + t5) : F(s5.geometry, a3).then((t5) => e3 + t5), 0, s4);
  }
  _substituteVars(e2, t4) {
    if (null !== t4) {
      const s4 = {};
      for (const e3 in t4)
        s4[e3.toLowerCase()] = t4[e3];
      e2.parameters = s4;
    }
  }
  async distinct(e2, t4 = 1e3, s4 = null, a3) {
    await this.load();
    const r3 = f3.create(e2, this.getFieldsIndex());
    return this._substituteVars(r3, s4), this.calculateStatistic("distinct", r3, t4, this._defaultTracker(a3));
  }
  async min(e2, t4 = null, s4) {
    await this.load();
    const a3 = f3.create(e2, this.getFieldsIndex());
    return this._substituteVars(a3, t4), this.calculateStatistic("min", a3, -1, this._defaultTracker(s4));
  }
  async max(e2, t4 = null, s4) {
    await this.load();
    const a3 = f3.create(e2, this.getFieldsIndex());
    return this._substituteVars(a3, t4), this.calculateStatistic("max", a3, -1, this._defaultTracker(s4));
  }
  async avg(e2, t4 = null, s4) {
    await this.load();
    const a3 = f3.create(e2, this.getFieldsIndex());
    return this._substituteVars(a3, t4), this.calculateStatistic("avg", a3, -1, this._defaultTracker(s4));
  }
  async sum(e2, t4 = null, s4) {
    await this.load();
    const a3 = f3.create(e2, this.getFieldsIndex());
    return this._substituteVars(a3, t4), this.calculateStatistic("sum", a3, -1, this._defaultTracker(s4));
  }
  async stdev(e2, t4 = null, s4) {
    await this.load();
    const a3 = f3.create(e2, this.getFieldsIndex());
    return this._substituteVars(a3, t4), this.calculateStatistic("stdev", a3, -1, this._defaultTracker(s4));
  }
  async variance(e2, t4 = null, s4) {
    await this.load();
    const a3 = f3.create(e2, this.getFieldsIndex());
    return this._substituteVars(a3, t4), this.calculateStatistic("variance", a3, -1, this._defaultTracker(s4));
  }
  async count(e2) {
    return await this.load(), this.calculateStatistic("count", f3.create("1", this.getFieldsIndex()), -1, this._defaultTracker(e2));
  }
  _defaultTracker(e2) {
    return e2 || { aborted: false };
  }
  forEach(e2, t4) {
    return new Promise((s4, a3) => {
      this._forEachImpl(this.iterator(this._defaultTracker(t4)), e2, this, s4, a3, 0);
    });
  }
  _forEachImpl(e2, t4, s4, a3, r3, n2) {
    try {
      if (++n2 > 1e3)
        return void setTimeout(() => {
          n2 = 0, this._forEachImpl(e2, t4, s4, a3, r3, n2);
        }, 0);
      e2.next().then((i5) => {
        try {
          if (null === i5)
            a3(s4);
          else {
            const l4 = t4(i5);
            null == l4 ? this._forEachImpl(e2, t4, s4, a3, r3, n2) : C(l4) ? l4.then(() => {
              try {
                this._forEachImpl(e2, t4, s4, a3, r3, n2);
              } catch (i6) {
                r3(i6);
              }
            }, r3) : this._forEachImpl(e2, t4, s4, a3, r3, n2);
          }
        } catch (l4) {
          r3(l4);
        }
      }, r3);
    } catch (i5) {
      r3(i5);
    }
  }
  convertToJSON(e2) {
    const t4 = { layerDefinition: { geometryType: this.geometryType, fields: [] }, featureSet: { features: [], geometryType: this.geometryType } };
    for (let s4 = 0; s4 < this.fields.length; s4++)
      t4.layerDefinition.fields.push(o(this.fields[s4]));
    return this.reduce((e3, s4) => {
      const a3 = { geometry: s4.geometry && s4.geometry.toJSON(), attributes: {} };
      for (const t5 in s4.attributes)
        a3.attributes[t5] = s4.attributes[t5];
      return t4.featureSet.features.push(a3), 1;
    }, 0, e2).then(() => t4);
  }
  castToText(e2 = false) {
    return "object, FeatureSet";
  }
  queryAttachments(e2, t4, s4, a3, r3) {
    return this._parent.queryAttachments(e2, t4, s4, a3, r3);
  }
  serviceUrl() {
    return this._parent.serviceUrl();
  }
  subtypes() {
    return this.typeIdField ? { subtypeField: this.typeIdField, subtypes: this.types ? this.types.map((e2) => ({ name: e2.name, code: e2.id })) : [] } : null;
  }
  relationshipMetaData() {
    return this._parent.relationshipMetaData();
  }
  get gdbVersion() {
    return this._parent ? this._parent.gdbVersion : "";
  }
  schema() {
    const e2 = [];
    for (const t4 of this.fields)
      e2.push(o(t4));
    return { objectIdField: this.objectIdField, globalIdField: this.globalIdField, geometryType: void 0 === v[this.geometryType] ? "" : v[this.geometryType], fields: e2 };
  }
  async convertToText(e2, t4) {
    if ("schema" === e2)
      return await this._ensureLoaded(), JSON.stringify(this.schema());
    if ("featureset" === e2) {
      await this._ensureLoaded();
      const e3 = [];
      await this.reduce((t5, s5) => {
        const a3 = { geometry: s5.geometry ? s5.geometry.toJSON() : null, attributes: s5.attributes };
        return null !== a3.geometry && a3.geometry.spatialReference && delete a3.geometry.spatialReference, e3.push(a3), 1;
      }, 0, t4);
      const s4 = this.schema();
      return s4.features = e3, s4.spatialReference = this.spatialReference.toJSON(), JSON.stringify(s4);
    }
    return this.castToText();
  }
  getFeatureByObjectId(e2, t4) {
    return this._parent.getFeatureByObjectId(e2, t4);
  }
  getOwningSystemUrl() {
    return this._parent.getOwningSystemUrl();
  }
  getIdentityUser() {
    return this._parent.getIdentityUser();
  }
  getRootFeatureSet() {
    return null !== this._parent ? this._parent.getRootFeatureSet() : this;
  }
  getDataSourceFeatureSet() {
    return null !== this._parent ? this._parent.getDataSourceFeatureSet() : this;
  }
  castAsJson(e2 = null) {
    return "keeptype" === (e2 == null ? void 0 : e2.featureset) ? this : "none" === (e2 == null ? void 0 : e2.featureset) ? null : { type: "FeatureSet" };
  }
  async castAsJsonAsync(e2 = null, t4 = null) {
    var _a;
    if ("keeptype" === (t4 == null ? void 0 : t4.featureset))
      return this;
    if ("schema" === (t4 == null ? void 0 : t4.featureset))
      return await this._ensureLoaded(), JSON.parse(JSON.stringify(this.schema()));
    if ("none" === (t4 == null ? void 0 : t4.featureset))
      return null;
    await this._ensureLoaded();
    const s4 = [];
    await this.reduce((e3, a4) => {
      const r3 = { geometry: a4.geometry ? true === (t4 == null ? void 0 : t4.keepGeometryType) ? a4.geometry : a4.geometry.toJSON() : null, attributes: a4.attributes };
      return null !== r3.geometry && r3.geometry.spatialReference && true !== (t4 == null ? void 0 : t4.keepGeometryType) && delete r3.geometry.spatialReference, s4.push(r3), 1;
    }, 0, e2);
    const a3 = this.schema();
    return a3.features = s4, a3.spatialReference = true === (t4 == null ? void 0 : t4.keepGeometryType) ? this.spatialReference : (_a = this.spatialReference) == null ? void 0 : _a.toJSON(), a3;
  }
};
C3._featuresetFunctions = {};

// node_modules/@arcgis/core/arcade/featureset/sources/Empty.js
var u2 = class extends C3 {
  constructor(e2) {
    super(e2), this.declaredClass = "esri.layers.featureset.sources.Empty", this._maxProcessing = 1e3, this._wset = new t3([], [], false, null), this._parent = e2.parentfeatureset, this._databaseType = t.Standardised;
  }
  async _getSet() {
    return this._wset;
  }
  optimisePagingFeatureQueries() {
  }
  _isInFeatureSet() {
    return i2.NotInFeatureSet;
  }
  async _getFeature() {
    throw new o2(n.NeverReach);
  }
  async queryAttachments() {
    return [];
  }
  async _getFeatures() {
    return "success";
  }
  _featureFromCache() {
    return null;
  }
  async _fetchAndRefineFeatures() {
    throw new o2(n.NeverReach);
  }
  async _getFilteredSet() {
    return new t3([], [], false, null);
  }
  _stat(e2, t4, r3, s4, a3, n2, u3) {
    return this._manualStat(e2, t4, n2, u3);
  }
  async _canDoAggregates() {
    return false;
  }
};

// node_modules/@arcgis/core/arcade/featureset/actions/SpatialFilter.js
var f6 = class extends C3 {
  constructor(e2) {
    super(e2), this._relation = "", this._relationGeom = null, this._relationString = "", this.declaredClass = "esri.arcade.featureset.actions.SpatialFilter", this._relationString = e2.relationString, this._parent = e2.parentfeatureset, this._maxProcessing = 40, this._relation = e2.relation, this._relationGeom = e2.relationGeom;
  }
  async _getSet(e2) {
    if (null === this._wset) {
      await this._ensureLoaded();
      const t4 = await this._parent._getFilteredSet("esriSpatialRelRelation" !== this._relation ? this._relation : this._relation + ":" + this._relationString, this._relationGeom, null, null, e2);
      return this._checkCancelled(e2), this._wset = new t3(t4._candidates.slice(0), t4._known.slice(0), t4._ordered, this._clonePageDefinition(t4.pagesDefinition)), this._wset;
    }
    return this._wset;
  }
  _isInFeatureSet(e2) {
    let t4 = this._parent._isInFeatureSet(e2);
    return t4 === i2.NotInFeatureSet ? t4 : (t4 = this._idstates[e2], void 0 === t4 ? i2.Unknown : t4);
  }
  _getFeature(e2, t4, i5) {
    return this._parent._getFeature(e2, t4, i5);
  }
  _getFeatures(e2, t4, i5, r3) {
    return this._parent._getFeatures(e2, t4, i5, r3);
  }
  _featureFromCache(e2) {
    return this._parent._featureFromCache(e2);
  }
  async executeSpatialRelationTest(e2) {
    var _a;
    if (null === e2.geometry)
      return false;
    switch (this._relation) {
      case "esriSpatialRelEnvelopeIntersects": {
        const t4 = f2(this._relationGeom), i5 = f2(e2.geometry);
        return h(t4, i5);
      }
      case "esriSpatialRelIntersects":
        return h(this._relationGeom, e2.geometry);
      case "esriSpatialRelContains":
        return p(this._relationGeom, e2.geometry);
      case "esriSpatialRelOverlaps":
        return O(this._relationGeom, e2.geometry);
      case "esriSpatialRelWithin":
        return x(this._relationGeom, e2.geometry);
      case "esriSpatialRelTouches":
        return S2(this._relationGeom, e2.geometry);
      case "esriSpatialRelCrosses":
        return m2(this._relationGeom, e2.geometry);
      case "esriSpatialRelRelation":
        return R(this._relationGeom, e2.geometry, (_a = this._relationString) != null ? _a : "");
    }
  }
  async _fetchAndRefineFeatures(e2, t4, i5) {
    var _a;
    const r3 = new t3([], e2, false, null), s4 = Math.min(t4, e2.length);
    await ((_a = this._parent) == null ? void 0 : _a._getFeatures(r3, -1, s4, i5)), this._checkCancelled(i5);
    const o5 = [];
    for (let n2 = 0; n2 < s4; n2++) {
      const t5 = this._parent._featureFromCache(e2[n2]);
      o5.push(await this.executeSpatialRelationTest(t5));
    }
    for (let n2 = 0; n2 < t4; n2++)
      true === o5[n2] ? this._idstates[e2[n2]] = i2.InFeatureSet : this._idstates[e2[n2]] = i2.NotInFeatureSet;
    return "success";
  }
  async _getFilteredSet(e2, t4, i5, r3, a3) {
    await this._ensureLoaded();
    const s4 = await this._parent._getFilteredSet("esriSpatialRelRelation" !== this._relation ? this._relation : this._relation + ":" + this._relationString, this._relationGeom, i5, r3, a3);
    let o5;
    return this._checkCancelled(a3), o5 = null !== t4 ? new t3(s4._candidates.slice(0).concat(s4._known.slice(0)), [], s4._ordered, this._clonePageDefinition(s4.pagesDefinition)) : new t3(s4._candidates.slice(0), s4._known.slice(0), s4._ordered, this._clonePageDefinition(s4.pagesDefinition)), o5;
  }
  async _stat(e2, t4, i5, r3, n2, a3, s4) {
    if ("" !== i5)
      return { calculated: false };
    const o5 = await this._parent._stat(e2, t4, "esriSpatialRelRelation" !== this._relation ? this._relation : this._relation + ":" + this._relationString, this._relationGeom, n2, a3, s4);
    return false === o5.calculated ? null === n2 && "" === i5 && null === r3 ? this._manualStat(e2, t4, a3, s4) : { calculated: false } : o5;
  }
  async _canDoAggregates(e2, t4, i5, r3, n2) {
    return "" === i5 && null === r3 && (null !== this._parent && this._parent._canDoAggregates(e2, t4, "esriSpatialRelRelation" !== this._relation ? this._relation : this._relation + ":" + this._relationString, this._relationGeom, n2));
  }
  async _getAggregatePagesDataSourceDefinition(e2, r3, n2, a3, s4, o5, l4) {
    if (null === this._parent)
      throw new o2(n.NeverReach);
    return this._parent._getAggregatePagesDataSourceDefinition(e2, r3, "esriSpatialRelRelation" !== this._relation ? this._relation : this._relation + ":" + this._relationString, this._relationGeom, s4, o5, l4);
  }
  static registerAction() {
    C3._featuresetFunctions.intersects = function(t4) {
      return null == t4 ? new u2({ parentfeatureset: this }) : new f6({ parentfeatureset: this, relation: "esriSpatialRelIntersects", relationGeom: t4 });
    }, C3._featuresetFunctions.envelopeIntersects = function(t4) {
      return null == t4 ? new u2({ parentfeatureset: this }) : new f6({ parentfeatureset: this, relation: "esriSpatialRelEnvelopeIntersects", relationGeom: t4 });
    }, C3._featuresetFunctions.contains = function(t4) {
      return null == t4 ? new u2({ parentfeatureset: this }) : new f6({ parentfeatureset: this, relation: "esriSpatialRelContains", relationGeom: t4 });
    }, C3._featuresetFunctions.overlaps = function(t4) {
      return null == t4 ? new u2({ parentfeatureset: this }) : new f6({ parentfeatureset: this, relation: "esriSpatialRelOverlaps", relationGeom: t4 });
    }, C3._featuresetFunctions.within = function(t4) {
      return null == t4 ? new u2({ parentfeatureset: this }) : new f6({ parentfeatureset: this, relation: "esriSpatialRelWithin", relationGeom: t4 });
    }, C3._featuresetFunctions.touches = function(t4) {
      return null == t4 ? new u2({ parentfeatureset: this }) : new f6({ parentfeatureset: this, relation: "esriSpatialRelTouches", relationGeom: t4 });
    }, C3._featuresetFunctions.crosses = function(t4) {
      return null == t4 ? new u2({ parentfeatureset: this }) : new f6({ parentfeatureset: this, relation: "esriSpatialRelCrosses", relationGeom: t4 });
    }, C3._featuresetFunctions.relate = function(t4, i5) {
      return null == t4 ? new u2({ parentfeatureset: this }) : new f6({ parentfeatureset: this, relation: "esriSpatialRelRelation", relationGeom: t4, relationString: i5 });
    };
  }
};

export {
  t2 as t,
  s,
  n,
  o2 as o,
  a2 as a,
  t3 as t2,
  s2,
  o3 as o2,
  c2 as c,
  i3 as i,
  l2 as l,
  f4 as f,
  d2 as d,
  p2 as p,
  y2 as y,
  w,
  N,
  m4 as m,
  g2 as g,
  C3 as C,
  u2 as u,
  f6 as f2
};
//# sourceMappingURL=chunk-MRJEGZAZ.js.map
