import {
  e as e5,
  h
} from "./chunk-SBPLVEUA.js";
import {
  o
} from "./chunk-7QNA4ADD.js";
import {
  e as e6
} from "./chunk-FGA4AGTH.js";
import {
  e as e4
} from "./chunk-6ZCPLPAF.js";
import {
  e as e3
} from "./chunk-BQL7VXQR.js";
import {
  a,
  i,
  n as n3,
  t
} from "./chunk-ZLTZ3KAT.js";
import {
  n as n2
} from "./chunk-A22ACVMF.js";
import {
  O
} from "./chunk-RUM3DXFX.js";
import {
  e as e2
} from "./chunk-IVLBGTXL.js";
import {
  e
} from "./chunk-GHN7C53L.js";
import {
  n
} from "./chunk-D4V6J5BT.js";
import {
  has
} from "./chunk-HVKDYDPP.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/PositionAttribute.glsl.js
function o2(o4) {
  o4.attributes.add(O.POSITION, "vec3"), o4.vertex.code.add(n3`vec3 positionModel() { return position; }`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/DoublePrecision.glsl.js
function c({ code: c3 }, i4) {
  i4.doublePrecisionRequiresObfuscation ? c3.add(n3`vec3 dpPlusFrc(vec3 a, vec3 b) {
return mix(a, a + b, vec3(notEqual(b, vec3(0))));
}
vec3 dpMinusFrc(vec3 a, vec3 b) {
return mix(vec3(0), a - b, vec3(notEqual(a, b)));
}
vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {
vec3 t1 = dpPlusFrc(hiA, hiB);
vec3 e = dpMinusFrc(t1, hiA);
vec3 t2 = dpMinusFrc(hiB, e) + dpMinusFrc(hiA, dpMinusFrc(t1, e)) + loA + loB;
return t1 + t2;
}`) : c3.add(n3`vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {
vec3 t1 = hiA + hiB;
vec3 e = t1 - hiA;
vec3 t2 = ((hiB - e) + (hiA - (t1 - e))) + loA + loB;
return t1 + t2;
}`);
}
function i2(e7) {
  return !!has("force-double-precision-obfuscation") || e7.driverTest.doublePrecisionRequiresObfuscation;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Matrix3DrawUniform.js
var o3 = class extends i {
  constructor(r, o4) {
    super(r, "mat3", a.Draw, (e7, s, t3) => e7.setUniformMatrix3fv(r, o4(s, t3)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexPosition.glsl.js
function F(r, o4) {
  r.include(o2);
  const e7 = r.vertex;
  e7.include(c, o4), r.varyings.add("vPositionWorldCameraRelative", "vec3"), r.varyings.add("vPosition_view", "vec3"), e7.uniforms.add([new e4("transformWorldFromViewTH", (r2) => r2.transformWorldFromViewTH), new e4("transformWorldFromViewTL", (r2) => r2.transformWorldFromViewTL), new e5("transformViewFromCameraRelativeRS", (r2) => r2.transformViewFromCameraRelativeRS), new e6("transformProjFromView", (r2) => r2.transformProjFromView), new o3("transformWorldFromModelRS", (r2) => r2.transformWorldFromModelRS), new o("transformWorldFromModelTH", (r2) => r2.transformWorldFromModelTH), new o("transformWorldFromModelTL", (r2) => r2.transformWorldFromModelTL)]), e7.code.add(n3`vec3 positionWorldCameraRelative() {
vec3 rotatedModelPosition = transformWorldFromModelRS * positionModel();
vec3 transform_CameraRelativeFromModel = dpAdd(
transformWorldFromModelTL,
transformWorldFromModelTH,
-transformWorldFromViewTL,
-transformWorldFromViewTH
);
return transform_CameraRelativeFromModel + rotatedModelPosition;
}`), e7.code.add(n3`
    void forwardPosition(float fOffset) {
      vPositionWorldCameraRelative = positionWorldCameraRelative();
      if (fOffset != 0.0) {
        vPositionWorldCameraRelative += fOffset * ${o4.spherical ? n3`normalize(transformWorldFromViewTL + vPositionWorldCameraRelative)` : n3`vec3(0.0, 0.0, 1.0)`};
      }

      vPosition_view = transformViewFromCameraRelativeRS * vPositionWorldCameraRelative;
      gl_Position = transformProjFromView * vec4(vPosition_view, 1.0);
    }
  `), r.fragment.uniforms.add(new e4("transformWorldFromViewTL", (r2) => r2.transformWorldFromViewTL)), e7.code.add(n3`vec3 positionWorld() {
return transformWorldFromViewTL + vPositionWorldCameraRelative;
}`), r.fragment.code.add(n3`vec3 positionWorld() {
return transformWorldFromViewTL + vPositionWorldCameraRelative;
}`);
}
var c2 = class extends t {
  constructor() {
    super(...arguments), this.transformWorldFromViewTH = n(), this.transformWorldFromViewTL = n(), this.transformViewFromCameraRelativeRS = e(), this.transformProjFromView = e2();
  }
};
var W = class extends t {
  constructor() {
    super(...arguments), this.transformWorldFromModelRS = e(), this.transformWorldFromModelTH = n2(), this.transformWorldFromModelTL = n2();
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js
function t2(e7) {
  e7.varyings.add("linearDepth", "float");
}
function i3(e7) {
  e7.vertex.uniforms.add(new e3("nearFar", (e8, r) => r.camera.nearFar));
}
function n4(e7) {
  e7.vertex.code.add(n3`float calculateLinearDepth(vec2 nearFar,float z) {
return (-z - nearFar[0]) / (nearFar[1] - nearFar[0]);
}`);
}
function d(a2, d2) {
  const { vertex: s } = a2;
  switch (d2.output) {
    case h.Color:
      if (d2.receiveShadows)
        return t2(a2), void s.code.add(n3`void forwardLinearDepth() { linearDepth = gl_Position.w; }`);
      break;
    case h.Depth:
    case h.Shadow:
    case h.ShadowHighlight:
    case h.ShadowExludeHighlight:
      return a2.include(F, d2), t2(a2), i3(a2), n4(a2), void s.code.add(n3`void forwardLinearDepth() {
linearDepth = calculateLinearDepth(nearFar, vPosition_view.z);
}`);
  }
  s.code.add(n3`void forwardLinearDepth() {}`);
}

export {
  o2 as o,
  c,
  i2 as i,
  o3 as o2,
  F,
  c2,
  W,
  t2 as t,
  i3 as i2,
  n4 as n,
  d
};
//# sourceMappingURL=chunk-AMNM3DGI.js.map
