import {
  c as c5,
  r as r4,
  v as v2
} from "./chunk-XNT3PUPA.js";
import "./chunk-JMGHYNUW.js";
import "./chunk-SFYX532J.js";
import {
  n as n4,
  s as s6
} from "./chunk-XBFCIW4K.js";
import "./chunk-6TBB7UXB.js";
import "./chunk-UO3LS2M5.js";
import "./chunk-EQNT4A7P.js";
import {
  c as c4,
  l as l3,
  r as r3,
  u
} from "./chunk-B53IHUIT.js";
import {
  b as b3
} from "./chunk-ESF7LLEL.js";
import {
  s as s7
} from "./chunk-AAL2O6PB.js";
import {
  Y
} from "./chunk-EQTVTD33.js";
import "./chunk-3XRZHFYO.js";
import "./chunk-IOZMLQTF.js";
import {
  t as t4
} from "./chunk-U7WNSJZS.js";
import "./chunk-QISOH77W.js";
import {
  o as o3
} from "./chunk-XO5VJRK4.js";
import {
  q as q2
} from "./chunk-MKD3FBJ5.js";
import "./chunk-L6PG65Z3.js";
import "./chunk-MATM5L52.js";
import "./chunk-4OM3EX6P.js";
import "./chunk-3OFVLRSL.js";
import "./chunk-WKJPACEU.js";
import "./chunk-OP2HNSVZ.js";
import "./chunk-O5HVKKEP.js";
import "./chunk-IPJF6OUC.js";
import "./chunk-NWERINOI.js";
import {
  f as f4,
  g as g3
} from "./chunk-OEFH2SLX.js";
import "./chunk-K3WMIXIE.js";
import {
  s as s4
} from "./chunk-I4YZGF7W.js";
import "./chunk-65ZBTSJX.js";
import "./chunk-FZSI6IGI.js";
import "./chunk-36RXM3AP.js";
import {
  d as d3
} from "./chunk-WSICXEIO.js";
import {
  h
} from "./chunk-VWCRJ6R6.js";
import {
  l as l2
} from "./chunk-MKNNZ33G.js";
import "./chunk-JQUWFKNU.js";
import "./chunk-UVQQJ3R6.js";
import {
  i as i2
} from "./chunk-QU433TMZ.js";
import "./chunk-IIAN3QNN.js";
import "./chunk-TFHLTN6F.js";
import "./chunk-4JNOVZUK.js";
import {
  c as c3,
  d as d2
} from "./chunk-UKETAWZI.js";
import {
  c as c2,
  q
} from "./chunk-HKYKZCGY.js";
import {
  n as n3
} from "./chunk-5MBCFCGH.js";
import {
  J,
  M,
  X,
  _,
  at,
  ft,
  gt,
  lt,
  pt,
  rt,
  w as w2
} from "./chunk-TJ2I6XQT.js";
import "./chunk-EDHROVWI.js";
import {
  o as o2,
  s as s5,
  t as t3
} from "./chunk-34YPGGJT.js";
import "./chunk-TWJNUVV2.js";
import "./chunk-NCXAKZRR.js";
import "./chunk-DUCSW4OU.js";
import "./chunk-WVDA5Z37.js";
import "./chunk-LT5KLTS5.js";
import "./chunk-SERWCSJG.js";
import {
  j as j3
} from "./chunk-OOOPZLJE.js";
import "./chunk-U2WD23Z5.js";
import "./chunk-RW4M3CI3.js";
import "./chunk-FFVIDMFN.js";
import {
  r as r2
} from "./chunk-7Q5M7ANT.js";
import "./chunk-A4HIS5ZJ.js";
import {
  x
} from "./chunk-AMLHWG76.js";
import "./chunk-OFQYIOO7.js";
import "./chunk-ZJZBAYFU.js";
import {
  g as g2
} from "./chunk-J5VTDQTQ.js";
import {
  a as a2,
  m as m2,
  y as y2
} from "./chunk-DVGM5RQS.js";
import "./chunk-GLGOVVCK.js";
import "./chunk-BUVDI6S7.js";
import "./chunk-GY2AJLN6.js";
import "./chunk-W62B63EU.js";
import "./chunk-N43PI2UO.js";
import "./chunk-ZWUEORSX.js";
import {
  T
} from "./chunk-US2IWMHE.js";
import {
  h as h2
} from "./chunk-NAKEKTIK.js";
import "./chunk-QWNKYSI4.js";
import "./chunk-ZPYDYUP5.js";
import "./chunk-CZBRZ6SU.js";
import "./chunk-RT3T2K4S.js";
import "./chunk-WJCI2CGX.js";
import {
  d
} from "./chunk-REIQNAQW.js";
import {
  G
} from "./chunk-XMZAPOBR.js";
import "./chunk-X2S4RQJ4.js";
import "./chunk-376OPXM4.js";
import "./chunk-DER356EU.js";
import "./chunk-NRP45AHD.js";
import "./chunk-IWQ7452U.js";
import "./chunk-NAN5J6QS.js";
import "./chunk-6M2AHKYV.js";
import "./chunk-KXVMEIWT.js";
import "./chunk-UDND2Z3V.js";
import "./chunk-JUVQV3R3.js";
import "./chunk-RAX2HD42.js";
import "./chunk-ZYRIJWLX.js";
import {
  a
} from "./chunk-C5H57NTD.js";
import "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import "./chunk-YWAQYJRC.js";
import "./chunk-B356PXLT.js";
import "./chunk-EHPBHJYZ.js";
import {
  v2 as v
} from "./chunk-3MNMDUQZ.js";
import {
  w2 as w
} from "./chunk-UWG37XSU.js";
import {
  E as E2,
  R,
  k2 as k
} from "./chunk-LNZAOBFW.js";
import {
  s as s3
} from "./chunk-PF5I4XZQ.js";
import "./chunk-HLM6QCL2.js";
import "./chunk-RXYULINL.js";
import {
  f as f3,
  j as j2,
  l
} from "./chunk-5NXILPDI.js";
import {
  n as n2
} from "./chunk-THVR7IAM.js";
import {
  U as U2
} from "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import "./chunk-KAN4HXCG.js";
import "./chunk-VWYWOOPX.js";
import "./chunk-M5VHU5LK.js";
import "./chunk-7QMMKGW4.js";
import {
  e as e2,
  n2 as n,
  y
} from "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import {
  D,
  E,
  L,
  U,
  b as b2,
  f as f2,
  g,
  j
} from "./chunk-MJXQTGI2.js";
import {
  s as s2
} from "./chunk-LIZHLHNA.js";
import "./chunk-BTUHYGXO.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";
import {
  has
} from "./chunk-HVKDYDPP.js";
import {
  t as t2
} from "./chunk-6QC7MLLS.js";
import {
  b,
  c,
  e,
  f,
  i,
  m,
  o,
  r,
  t
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/views/2d/layers/features/processors.js
function o4(o7) {
  return "heatmap" === o7 ? import("./HeatmapProcessor-5RCA5MA3.js") : import("./SymbolProcessor-NIN3VA66.js");
}

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderPBFHeader.js
var r5 = 268435455;
var n5 = class {
  constructor() {
    this.fieldMap = /* @__PURE__ */ new Map(), this.fields = [], this.hasFeatures = false, this.exceededTransferLimit = false, this.fieldCount = 0, this.featureCount = 0, this.objectIdFieldIndex = 0, this.vertexCount = 0, this.offsets = { attributes: new Array(), geometry: new Array() }, this.centroid = new Array();
  }
  hasField(e3) {
    return this.fieldMap.has(e3);
  }
  isDateField(e3) {
    var _a, _b;
    return (_b = (_a = this.fieldMap.get(e3)) == null ? void 0 : _a.isDate) != null ? _b : false;
  }
  getFieldIndex(e3) {
    var _a;
    return (_a = this.fieldMap.get(e3)) == null ? void 0 : _a.index;
  }
};
function a3(e3) {
  const t6 = 1, r6 = 2, n7 = e3.asUnsafe(), a8 = n7.getLength(), i5 = n7.pos() + a8, o7 = { name: "", isDate: false };
  for (; n7.pos() < i5 && n7.next(); )
    switch (n7.tag()) {
      case t6:
        o7.name = n7.getString();
        break;
      case r6:
        "esriFieldTypeDate" === c2(n7.getEnum()) && (o7.isDate = true);
        break;
      default:
        n7.skip();
    }
  return o7;
}
function i3(e3) {
  return e3.toLowerCase().trim();
}
function o5(s9, o7, f9 = false) {
  const c9 = 1, d9 = 3, u4 = 9, l9 = 12, g6 = 13, p4 = 15, h6 = s9.asUnsafe(), m6 = h6.pos(), b6 = new n5();
  let w4 = 0, k3 = 0;
  const x4 = 1, y6 = 2, I2 = 4, F5 = 3;
  let L3 = null, A3 = null, C = null, S3 = false;
  for (; h6.next(); )
    switch (h6.tag()) {
      case c9:
        L3 = h6.getString();
        break;
      case d9:
        A3 = h6.getString();
        break;
      case l9:
        C = h6.processMessage(q);
        break;
      case u4:
        if (b6.exceededTransferLimit = h6.getBool(), b6.exceededTransferLimit) {
          b6.offsets.geometry = f9 ? new Float64Array(8e3) : new Int32Array(8e3), b6.centroid = f9 ? new Float64Array(16e3) : new Int32Array(16e3);
          for (let e3 = 0; e3 < b6.centroid.length; e3++)
            b6.centroid[e3] = r5;
        }
        break;
      case g6: {
        const e3 = a3(s9), t6 = e3.name, r6 = i3(e3.name), n7 = { fieldName: t6, index: w4++, isDate: e3.isDate };
        b6.fields.push(n7), b6.fieldMap.set(e3.name, n7), b6.fieldMap.set(r6, n7);
        break;
      }
      case p4: {
        const e3 = h6.getLength(), t6 = h6.pos() + e3;
        if (!b6.exceededTransferLimit) {
          const e4 = b6.offsets.geometry, t7 = b6.centroid;
          e4.push(0), t7.push(r5), t7.push(r5);
        }
        !S3 && b6.exceededTransferLimit && (S3 = true, b6.offsets.attributes = f9 ? new Float64Array(8e3 * w4) : new Uint32Array(8e3 * w4));
        let s10 = k3 * w4;
        for (; h6.pos() < t6 && h6.next(); )
          switch (h6.tag()) {
            case x4: {
              if (S3)
                b6.offsets.attributes[s10++] = h6.pos();
              else {
                b6.offsets.attributes.push(h6.pos());
              }
              const e4 = h6.getLength();
              h6.skipLen(e4);
              break;
            }
            case y6:
              if (o7) {
                const e4 = h6.getLength(), t7 = h6.pos() + e4;
                for (; h6.pos() < t7 && h6.next(); )
                  switch (h6.tag()) {
                    case F5: {
                      h6.getUInt32();
                      const e5 = h6.getSInt64(), t8 = h6.getSInt64();
                      b6.centroid[2 * k3] = e5, b6.centroid[2 * k3 + 1] = t8;
                      break;
                    }
                    default:
                      h6.skip();
                  }
              } else {
                b6.offsets.geometry[k3] = h6.pos();
                const e4 = h6.getLength();
                b6.vertexCount += e4, h6.skipLen(e4);
              }
              break;
            case I2: {
              const e4 = h6.getLength(), t7 = h6.pos() + e4;
              for (; h6.pos() < t7 && h6.next(); )
                switch (h6.tag()) {
                  case F5: {
                    h6.getUInt32();
                    const e5 = h6.getSInt64(), t8 = h6.getSInt64();
                    b6.centroid[2 * k3] = e5, b6.centroid[2 * k3 + 1] = t8;
                    break;
                  }
                  default:
                    h6.skip();
                }
              break;
            }
            default:
              h6.skip();
          }
        k3++, b6.hasFeatures = true;
        break;
      }
      default:
        h6.skip();
    }
  const M2 = L3 || A3;
  if (!M2)
    throw new s2("FeatureSet has no objectId or globalId field name");
  return b6.featureCount = k3, b6.fieldCount = w4, b6.objectIdFieldIndex = b6.getFieldIndex(M2), b6.transform = C, b6.displayIds = new Uint32Array(b6.featureCount), b6.groupIds = new Uint16Array(b6.featureCount), h6.move(m6), b6;
}

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderPBF.js
var g4 = true;
var l4 = 268435455;
var _2 = 128;
var f5 = 128e3;
var y3 = { small: { delta: new Int32Array(_2), decoded: new Int32Array(_2) }, large: { delta: new Int32Array(f5), decoded: new Int32Array(f5) } };
function I(e3) {
  return e3 <= y3.small.delta.length ? y3.small : (e3 <= y3.large.delta.length || (y3.large.delta = new Int32Array(Math.round(1.25 * e3)), y3.large.decoded = new Int32Array(Math.round(1.25 * e3))), y3.large);
}
function p(e3) {
  return e3.toLowerCase().trim();
}
function m3(r6) {
  try {
    const e3 = 2, t6 = new n3(new Uint8Array(r6), new DataView(r6));
    for (; t6.next(); ) {
      if (t6.tag() === e3)
        return x2(t6.getMessage());
      t6.skip();
    }
  } catch (s9) {
    const r7 = new s2("query:parsing-pbf", "Error while parsing FeatureSet PBF payload", { error: s9 });
    s.getLogger("esri.view.2d.layers.features.support.FeatureSetReaderPBF").error(r7);
  }
  return null;
}
function x2(e3) {
  const t6 = 1;
  for (; e3.next(); ) {
    if (e3.tag() === t6)
      return e3.getMessage();
    e3.skip();
  }
  return null;
}
function S(e3) {
  const t6 = 1, r6 = 2, s9 = 3, i5 = 4, n7 = 5, a8 = 6, h6 = 7, o7 = 8, d9 = 9, u4 = e3.getLength(), c9 = e3.pos() + u4;
  for (; e3.pos() < c9 && e3.next(); )
    switch (e3.tag()) {
      case t6:
        return e3.getString();
      case r6:
        return e3.getFloat();
      case s9:
        return e3.getDouble();
      case i5:
        return e3.getSInt32();
      case n7:
        return e3.getUInt32();
      case a8:
        return e3.getInt64();
      case h6:
        return e3.getUInt64();
      case o7:
        return e3.getSInt64();
      case d9:
        return e3.getBool();
      default:
        return e3.skip(), null;
    }
  return null;
}
function F(e3, t6, r6, s9, i5, n7) {
  return 0.5 * Math.abs(e3 * s9 + r6 * n7 + i5 * t6 - e3 * n7 - r6 * t6 - i5 * s9);
}
function v3(e3, t6, r6, s9) {
  return 0 === e3 * s9 - r6 * t6 && e3 * r6 + t6 * s9 > 0;
}
var G2 = class extends b3 {
  constructor(e3, t6, r6, s9) {
    super(e3, s9), this._hasNext = false, this._isPoints = false, this._featureIndex = -1, this._featureOffset = 0, this._cache = { area: 0, unquantGeometry: void 0, geometry: void 0, centroid: void 0, legacyFeature: void 0, optFeature: void 0 }, this._geometryType = s9.geometryType, this._reader = t6, this._header = r6, this._hasNext = r6.hasFeatures, this._isPoints = "esriGeometryPoint" === s9.geometryType;
  }
  static fromBuffer(e3, t6, r6 = false) {
    const s9 = t6.geometryType, i5 = m3(e3), n7 = o5(i5, "esriGeometryPoint" === s9, r6), a8 = b3.createInstance();
    return new G2(a8, i5, n7, t6);
  }
  get geometryType() {
    return this._geometryType;
  }
  get _size() {
    return this._header.featureCount;
  }
  get hasZ() {
    return false;
  }
  get hasM() {
    return false;
  }
  get stride() {
    return 2 + (this.hasZ ? 1 : 0) + (this.hasM ? 1 : 0);
  }
  get hasFeatures() {
    return this._header.hasFeatures;
  }
  get hasNext() {
    return this._hasNext;
  }
  get exceededTransferLimit() {
    return this._header.exceededTransferLimit;
  }
  hasField(e3) {
    return this._header.hasField(e3) || this._header.hasField(p(e3));
  }
  getFieldNames() {
    return this._header.fields.map((e3) => e3.fieldName);
  }
  getSize() {
    return this._size;
  }
  getQuantizationTransform() {
    return this._header.transform;
  }
  getCursor() {
    return this.copy();
  }
  getIndex() {
    return this._featureIndex;
  }
  setIndex(e3) {
    this._cache.area = 0, this._cache.unquantGeometry = void 0, this._cache.geometry = void 0, this._cache.centroid = void 0, this._cache.legacyFeature = void 0, this._cache.optFeature = void 0, this._featureIndex = e3;
  }
  getAttributeHash() {
    let e3 = "";
    return this._header.fields.forEach(({ index: t6 }) => {
      e3 += this._readAttributeAtIndex(t6) + ".";
    }), e3;
  }
  getObjectId() {
    return this._readAttributeAtIndex(this._header.objectIdFieldIndex);
  }
  getDisplayId() {
    return this._header.displayIds[this._featureIndex];
  }
  setDisplayId(e3) {
    this._header.displayIds[this._featureIndex] = e3;
  }
  getGroupId() {
    return this._header.groupIds[this._featureIndex];
  }
  setGroupId(e3) {
    this._header.groupIds[this._featureIndex] = e3;
  }
  readLegacyFeature() {
    var _a;
    if (void 0 === this._cache.legacyFeature) {
      const e3 = this.readCentroid(), t6 = { attributes: this.readAttributes(), geometry: this._isPoints ? this.readLegacyPointGeometry() : this.readLegacyGeometry(), centroid: (_a = e3 && { x: e3.coords[0], y: e3.coords[1] }) != null ? _a : null };
      return this._cache.legacyFeature = t6, t6;
    }
    return this._cache.legacyFeature;
  }
  readOptimizedFeature() {
    if (void 0 === this._cache.optFeature) {
      const e3 = new s5(this.readGeometry(), this.readAttributes(), this.readCentroid());
      return e3.objectId = this.getObjectId(), e3.displayId = this.getDisplayId(), this._cache.optFeature = e3, e3;
    }
    return this._cache.optFeature;
  }
  getXHydrated() {
    const e3 = this._header.centroid[2 * this._featureIndex], t6 = this.getQuantizationTransform();
    return t(t6) ? e3 : e3 * t6.scale[0] + t6.translate[0];
  }
  getYHydrated() {
    const e3 = this._header.centroid[2 * this._featureIndex + 1], t6 = this.getQuantizationTransform();
    return t(t6) ? e3 : t6.translate[1] - e3 * t6.scale[1];
  }
  getX() {
    return this._header.centroid[2 * this._featureIndex] * this._sx + this._tx;
  }
  getY() {
    return this._header.centroid[2 * this._featureIndex + 1] * this._sy + this._ty;
  }
  readLegacyPointGeometry() {
    return { x: this.getX(), y: this.getY() };
  }
  readLegacyGeometry(e3) {
    const t6 = this.readGeometry(e3);
    return rt(t6, this.geometryType, false, false);
  }
  readLegacyCentroid() {
    const e3 = this.readCentroid();
    if (!e3)
      return null;
    const [t6, r6] = e3.coords;
    return { x: t6, y: r6 };
  }
  readGeometryArea() {
    return this._cache.area || this.readGeometry(true), this._cache.area;
  }
  readUnquantizedGeometry(e3 = false) {
    if (void 0 === this._cache.unquantGeometry) {
      const t6 = this.readGeometry(e3);
      if (!t6)
        return this._cache.unquantGeometry = void 0, null;
      const r6 = I(t6.coords.length).decoded, s9 = t6.clone(r6), i5 = s9.coords;
      let n7 = 0;
      for (const e4 of s9.lengths) {
        for (let t7 = 1; t7 < e4; t7++) {
          const e5 = 2 * (n7 + t7), r7 = 2 * (n7 + t7 - 1);
          i5[e5] += i5[r7], i5[e5 + 1] += i5[r7 + 1];
        }
        n7 += e4;
      }
      return this._cache.unquantGeometry = s9, s9;
    }
    return this._cache.unquantGeometry;
  }
  readHydratedGeometry() {
    if (this._isPoints) {
      if (this._header.centroid[2 * this._featureIndex] === l4)
        return null;
      const e4 = this.getXHydrated(), t7 = this.getYHydrated();
      return new t3([], [e4, t7]);
    }
    const e3 = this.readGeometry();
    if (!e3)
      return null;
    const t6 = e3.clone(), r6 = this.getQuantizationTransform();
    return r(r6) && pt(t6, t6, this.hasZ, this.hasM, r6), t6;
  }
  readGeometry(e3 = false) {
    if (void 0 === this._cache.geometry) {
      let r6 = null;
      if (this._isPoints) {
        if (this._header.centroid[2 * this._featureIndex] === l4)
          return null;
        const e4 = this.getX(), t6 = this.getY();
        r6 = new t3([], [e4, t6]);
      } else {
        const s9 = this._header.offsets.geometry[this._featureIndex], i5 = this._reader;
        if (0 === s9) {
          const e4 = this._readServerCentroid();
          if (!e4)
            return null;
          const [t6, r7] = e4.coords;
          return this.createQuantizedExtrudedQuad(t6, r7);
        }
        i5.move(s9);
        try {
          if (r6 = e3 ? this._parseGeometryForDisplay(i5) : this._parseGeometry(i5), null === r6) {
            const e4 = this._readServerCentroid();
            if (!e4)
              return null;
            const [t6, r7] = e4.coords;
            return this.createQuantizedExtrudedQuad(t6, r7);
          }
        } catch (t6) {
          return console.error("Failed to parse geometry!", t6), null;
        }
      }
      return this._cache.geometry = r6, r6;
    }
    return this._cache.geometry;
  }
  readCentroid() {
    if (void 0 === this._cache.centroid) {
      let e3;
      return e3 = this._computeCentroid(), e3 || (e3 = this._readServerCentroid()), this._cache.centroid = e3 != null ? e3 : void 0, e3 != null ? e3 : null;
    }
    return this._cache.centroid;
  }
  copy() {
    const e3 = this._reader.clone(), t6 = new G2(this.instance, e3, this._header, this.fullSchema());
    return this.copyInto(t6), t6;
  }
  next() {
    for (this._cache.area = 0, this._cache.unquantGeometry = void 0, this._cache.geometry = void 0, this._cache.centroid = void 0, this._cache.legacyFeature = void 0, this._cache.optFeature = void 0; ++this._featureIndex < this._size && !this._getExists(); )
      ;
    return this._featureIndex < this._size;
  }
  _readAttribute(e3, t6) {
    const r6 = this._header.hasField(e3) ? e3 : p(e3), s9 = this._header.getFieldIndex(r6);
    if (null == s9)
      return;
    const i5 = this._readAttributeAtIndex(s9);
    if (!t6)
      return i5;
    if (null == i5)
      return i5;
    return this._header.isDateField(r6) ? new Date(i5) : i5;
  }
  _readAttributes() {
    const e3 = {};
    return this._header.fields.forEach(({ fieldName: t6, index: r6 }) => {
      e3[t6] = this._readAttributeAtIndex(r6);
    }), e3;
  }
  copyInto(e3) {
    super.copyInto(e3), e3._featureIndex = this._featureIndex, e3._featureOffset = this._featureOffset, e3._hasNext = this._hasNext;
  }
  _readAttributeAtIndex(e3) {
    const t6 = this._header.offsets.attributes[this._featureIndex * this._header.fieldCount + e3], r6 = this._reader;
    return r6.move(t6), S(r6);
  }
  _readServerCentroid() {
    const e3 = this._header.centroid[2 * this._featureIndex] + this._tx, t6 = this._header.centroid[2 * this._featureIndex + 1] + this._ty;
    return e3 === l4 ? null : new t3([], [e3, t6]);
  }
  _parseGeometry(e3) {
    const t6 = 2, r6 = 3, s9 = e3.asUnsafe(), i5 = s9.getLength(), n7 = s9.pos() + i5, a8 = [], h6 = [];
    for (; s9.pos() < n7 && s9.next(); )
      switch (s9.tag()) {
        case t6: {
          const e4 = s9.getUInt32(), t7 = s9.pos() + e4;
          for (; s9.pos() < t7; )
            h6.push(s9.getUInt32());
          break;
        }
        case r6: {
          const e4 = s9.getUInt32(), t7 = s9.pos() + e4;
          for (a8.push(s9.getSInt32() + this._tx), a8.push(s9.getSInt32() + this._ty), this.hasZ && s9.getSInt32(), this.hasM && s9.getSInt32(); s9.pos() < t7; )
            a8.push(s9.getSInt32()), a8.push(s9.getSInt32()), this.hasZ && s9.getSInt32(), this.hasM && s9.getSInt32();
          break;
        }
        default:
          s9.skip();
      }
    return new t3(h6, a8);
  }
  _parseGeometryForDisplay(e3) {
    const t6 = 2, r6 = 3, s9 = e3.asUnsafe(), n7 = s9.getLength(), a8 = s9.pos() + n7, h6 = [], o7 = [];
    let u4 = 0, c9 = 0, l9 = null, _4 = 0;
    const f9 = "esriGeometryPolygon" === this.geometryType;
    for (; s9.pos() < a8 && s9.next(); )
      switch (s9.tag()) {
        case t6: {
          const e4 = s9.getUInt32(), t7 = s9.pos() + e4;
          for (; s9.pos() < t7; ) {
            const e5 = s9.getUInt32();
            h6.push(e5), u4 += e5;
          }
          l9 = I(2 * u4).delta;
          break;
        }
        case r6: {
          s9.getUInt32();
          const e4 = 2 + (this.hasZ ? 1 : 0) + (this.hasM ? 1 : 0);
          c(l9);
          for (const t7 of h6)
            if (c9 + e4 * t7 > l9.length)
              for (let e5 = 0; e5 < t7; e5++)
                s9.getSInt32(), s9.getSInt32(), this.hasZ && s9.getSInt32(), this.hasM && s9.getSInt32();
            else if (f9 && g4) {
              const e5 = this.getAreaSimplificationThreshold(t7, this._header.vertexCount);
              let r7 = 2, i5 = 1;
              const n8 = false;
              let a9 = s9.getSInt32(), h7 = s9.getSInt32();
              l9[c9++] = a9, l9[c9++] = h7, this.hasZ && s9.getSInt32(), this.hasM && s9.getSInt32();
              let d9 = s9.getSInt32(), u5 = s9.getSInt32();
              for (this.hasZ && s9.getSInt32(), this.hasM && s9.getSInt32(); r7 < t7; ) {
                let t8 = s9.getSInt32(), n9 = s9.getSInt32();
                this.hasZ && s9.getSInt32(), this.hasM && s9.getSInt32();
                const o8 = a9 + d9, g6 = h7 + u5;
                F(a9, h7, o8, g6, o8 + t8, g6 + n9) >= e5 ? (_4 += -0.5 * (o8 - a9) * (g6 + h7), i5 > 1 && v3(l9[c9 - 2], l9[c9 - 1], d9, u5) ? (l9[c9 - 2] += d9, l9[c9 - 1] += u5) : (l9[c9++] = d9, l9[c9++] = u5, i5++), a9 = o8, h7 = g6) : (t8 += d9, n9 += u5), d9 = t8, u5 = n9, r7++;
              }
              i5 < 3 || n8 ? c9 -= 2 * i5 : (_4 += -0.5 * (a9 + d9 - a9) * (h7 + u5 + h7), v3(l9[c9 - 2], l9[c9 - 1], d9, u5) ? (l9[c9 - 2] += d9, l9[c9 - 1] += u5, o7.push(i5)) : (l9[c9++] = d9, l9[c9++] = u5, o7.push(++i5)));
            } else {
              let e5 = 0, r7 = s9.getSInt32(), i5 = s9.getSInt32();
              this.hasZ && s9.getSInt32(), this.hasM && s9.getSInt32(), l9[c9++] = r7, l9[c9++] = i5, e5 += 1;
              for (let n8 = 1; n8 < t7; n8++) {
                const t8 = s9.getSInt32(), a9 = s9.getSInt32(), h7 = r7 + t8, o8 = i5 + a9;
                _4 += -0.5 * (h7 - r7) * (o8 + i5), this.hasZ && s9.getSInt32(), this.hasM && s9.getSInt32(), n8 > 2 && v3(l9[c9 - 2], l9[c9 - 1], t8, a9) ? (l9[c9 - 2] += t8, l9[c9 - 1] += a9) : (l9[c9++] = t8, l9[c9++] = a9, e5 += 1), r7 = h7, i5 = o8;
              }
              o7.push(e5);
            }
          break;
        }
        default:
          s9.skip();
      }
    if (this._cache.area = _4, !o7.length)
      return null;
    if (this._tx || this._ty) {
      let e4 = 0;
      c(l9);
      for (const t7 of o7)
        l9[2 * e4] += this._tx, l9[2 * e4 + 1] += this._ty, e4 += t7;
    }
    return new t3(o7, l9);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/controllers/support/sourceAdapters.js
var p2 = class {
  constructor(e3) {
    this.service = e3;
  }
  destroy() {
  }
};
function f6(e3) {
  return Array.isArray(e3.source);
}
function l5(e3) {
  return "ogc-source" === (e3 == null ? void 0 : e3.type);
}
function y4(e3) {
  const { capabilities: t6 } = e3;
  return l5(e3.source) ? new q3(e3) : f6(e3) ? new d4(e3) : t6.query.supportsFormatPBF && has("featurelayer-pbf") ? new v4(e3) : new F2(e3);
}
async function h3(e3) {
  const t6 = new h2();
  return await t6.open(e3, {}), t6;
}
var d4 = class extends p2 {
  constructor(e3) {
    super(e3), this._portsOpen = h3(e3.source).then((e4) => this.client = e4);
  }
  destroy() {
    this.client.close(), this.client = null;
  }
  async executeQuery(e3, t6) {
    await this._portsOpen;
    const r6 = await this.client.invoke("queryFeatures", e3.toJSON(), t6);
    return c5.fromFeatureSet(r6, this.service);
  }
};
var v4 = class extends p2 {
  async executeQuery(e3, t6) {
    const { data: r6 } = await d2(this.service.source, e3, t6), s9 = !e3.quantizationParameters;
    return G2.fromBuffer(r6, this.service, s9);
  }
};
var F2 = class extends p2 {
  async executeQuery(r6, o7) {
    var _a;
    const { source: n7, capabilities: m6, spatialReference: p4, objectIdField: f9, geometryType: l9 } = this.service;
    if (r(r6.quantizationParameters) && !m6.query.supportsQuantization) {
      const e3 = r6.clone(), m7 = s4(e(e3.quantizationParameters));
      e3.quantizationParameters = null;
      const { data: l10 } = await c3(n7, e3, p4, o7), y7 = lt(l10, f9);
      return ft(m7, y7), c5.fromOptimizedFeatureSet(y7, this.service);
    }
    const { data: y6 } = await c3(n7, r6, this.service.spatialReference, o7);
    return "esriGeometryPoint" === l9 && (y6.features = (_a = y6.features) == null ? void 0 : _a.filter((t6) => {
      if (r(t6.geometry)) {
        const e3 = t6.geometry;
        return Number.isFinite(e3.x) && Number.isFinite(e3.y);
      }
      return true;
    })), c5.fromFeatureSet(y6, this.service);
  }
};
var q3 = class extends p2 {
  async executeQuery(e3, r6) {
    const { capabilities: i5 } = this.service;
    if (e3.quantizationParameters && !i5.query.supportsQuantization) {
      const i6 = e3.clone(), n8 = s4(e(i6.quantizationParameters));
      i6.quantizationParameters = null;
      const c9 = await q2(this.service.source, e3, r6);
      return ft(n8, c9), c5.fromOptimizedFeatureSet(c9, this.service);
    }
    const n7 = await q2(this.service.source, e3, r6);
    return c5.fromOptimizedFeatureSet(n7, this.service);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/UpdateToken.js
var t5 = class {
  constructor() {
    this.version = 0, this.source = false, this.targets = { feature: false, aggregate: false }, this.storage = { filters: false, data: false }, this.mesh = false, this.queryFilter = false, this.why = { mesh: [], source: [] };
  }
  static create(e3) {
    const s9 = new t5();
    for (const t6 in e3) {
      const r6 = e3[t6];
      if ("object" == typeof r6)
        for (const e4 in r6) {
          const a8 = r6[e4];
          s9[t6][e4] = a8;
        }
      s9[t6] = r6;
    }
    return s9;
  }
  static empty() {
    return t5.create({});
  }
  static all() {
    return t5.create({ source: true, targets: { feature: true, aggregate: true }, storage: { filters: true, data: true }, mesh: true });
  }
  unset(t6) {
    this.version = t6.version, t6.source && (this.source = false), t6.targets.feature && (this.targets.feature = false), t6.targets.aggregate && (this.targets.aggregate = false), t6.storage.filters && (this.storage.filters = false), t6.storage.data && (this.storage.data = false), t6.mesh && (this.mesh = false), t6.queryFilter && (this.queryFilter = false);
  }
  any() {
    return this.source || this.mesh || this.storage.filters || this.storage.data || this.targets.feature || this.targets.aggregate || this.queryFilter;
  }
  describe() {
    let t6 = 0, e3 = "";
    if (this.mesh) {
      t6 += 20, e3 += "-> (20) Mesh needs update\n";
      for (const t7 of this.why.mesh)
        e3 += `    + ${t7}
`;
    }
    if (this.source) {
      t6 += 10, e3 += "-> (10) The source needs update\n";
      for (const t7 of this.why.source)
        e3 += `    + ${t7}
`;
    }
    this.targets.feature && (t6 += 5, e3 += "-> (5) Feature target parameters changed\n"), this.storage.filters && (t6 += 5, e3 += "-> (5) Feature filter parameters changed\n"), this.targets.aggregate && (t6 += 4, e3 += "-> (4) Aggregate target parameters changed\n"), this.storage.data && (t6 += 1, e3 += "-> (1) Texture storage parameters changed");
    const s9 = t6 < 5 ? "Fastest" : t6 < 10 ? "Fast" : t6 < 15 ? "Moderate" : t6 < 20 ? "Slow" : "Very Slow";
    console.debug(`Applying ${s9} update of cost ${t6}/45 `), console.debug(e3);
  }
  toJSON() {
    return { queryFilter: this.queryFilter, source: this.source, targets: this.targets, storage: this.storage, mesh: this.mesh };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/DataTileSubscription.js
var a4 = class {
  constructor(s9, t6) {
    this.requests = { done: new Array(), stream: new s7(10) }, this._edits = null, this._abortController = new AbortController(), this._version = 0, this._done = false, this.didSend = false, this.tile = s9, this._version = t6;
  }
  get signal() {
    return this._abortController.signal;
  }
  get options() {
    return { signal: this._abortController.signal };
  }
  get empty() {
    return !this.requests.done.length;
  }
  get edits() {
    return this._edits;
  }
  get done() {
    return this._done;
  }
  end() {
    this._done = true;
  }
  clear() {
    this.requests.done = [];
  }
  applyUpdate(e3) {
    this.requests.done.forEach((s9) => s9.message.status.unset(e3)), this._version = e3.version, r(this._edits) && this._edits.status.unset(e3);
  }
  add(e3) {
    var _a2;
    e3.message.status = (_a2 = e3.message.status) != null ? _a2 : t5.empty(), e3.message.status.version = this._version, has("esri-2d-update-debug") && console.debug(this.tile.id, "DataTileSubscription:add", this._version), e3.message.end && this.requests.done.forEach((e4) => {
      r(e4.message) && e4.message.end && (e4.message.end = false);
    }), this.requests.done.push(e3);
  }
  edit(e3, s9) {
    const a8 = e3.getQuantizationTransform(), o7 = e3.fullSchema(), n7 = Array.from(e3.features()), h6 = [...s9, ...n7.map((e4) => e4.objectId)];
    if (this.removeIds(h6), this._invalidate(), t(this._edits))
      return void (this._edits = { type: "append", addOrUpdate: c5.fromOptimizedFeatures(n7, o7, e(a8)), id: this.tile.id, status: t5.empty(), end: true });
    this.requests.done.forEach((e4) => e4.message.end = false);
    e(this._edits.addOrUpdate).append(e3.features());
  }
  *readers() {
    for (const { message: e3 } of this.requests.done)
      r(e3.addOrUpdate) && (yield e3.addOrUpdate);
    r(this._edits) && r(this._edits.addOrUpdate) && (yield this._edits.addOrUpdate);
  }
  _invalidate() {
    for (const e3 of this.requests.done)
      e3.message.status = t5.empty();
    r(this._edits) && (this._edits.status = t5.empty());
  }
  removeIds(e3) {
    this._invalidate();
    for (const { message: t6 } of this.requests.done) {
      const r6 = t6.addOrUpdate;
      r(r6) && (r6.removeIds(e3), r6.isEmpty && (t6.addOrUpdate = null));
    }
    r(this._edits) && r(this._edits.addOrUpdate) && this._edits.addOrUpdate.removeIds(e3), this.requests.done = this.requests.done.filter((e4) => e4.message.addOrUpdate || e4.message.end);
  }
  abort() {
    this._abortController.abort();
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/DataTileSource.js
function l6(e3, s9) {
  const t6 = /* @__PURE__ */ new Set();
  return e3 && e3.forEach((e4) => t6.add(e4)), s9 && s9.forEach((e4) => t6.add(e4)), t6.has("*") ? ["*"] : Array.from(t6);
}
var m4 = class {
  constructor(e3) {
    this.events = new n2(), this._resolver = D(), this._didEdit = false, this._subscriptions = /* @__PURE__ */ new Map(), this._outSR = e3.outSR, this._serviceInfo = e3.serviceInfo, this._onTileUpdateMessage = e3.onMessage;
  }
  destroy() {
  }
  async _onMessage(e3) {
    var _a, _b;
    const s9 = this._subscriptions.get(e3.id);
    if (!s9)
      return;
    const t6 = { ...e3, remove: (_a = e3.remove) != null ? _a : [], status: (_b = e3.status) != null ? _b : t5.empty() };
    return g(this._onTileUpdateMessage(t6, s9.options));
  }
  update(s9, t6) {
    var _a;
    const r6 = t6.fields.length;
    t6.outFields = l6((_a = this._schema) == null ? void 0 : _a.outFields, t6.outFields), t6.outFields = t6.outFields.length >= 0.75 * r6 ? ["*"] : t6.outFields, t6.outFields.sort();
    const i5 = m2(this._schema, t6);
    if (!i5)
      return;
    has("esri-2d-update-debug") && console.debug("Applying Update - Source:", i5);
    const o7 = "orderByFields" in this._serviceInfo && this._serviceInfo.orderByFields ? this._serviceInfo.orderByFields : this._serviceInfo.objectIdField + " ASC", n7 = { returnCentroid: "esriGeometryPolygon" === this._serviceInfo.geometryType, returnGeometry: true, timeReferenceUnknownClient: "stream" !== this._serviceInfo.type && this._serviceInfo.timeReferenceUnknownClient, outFields: t6.outFields, outSpatialReference: this._outSR, orderByFields: [o7], where: t6.definitionExpression || "1=1", gdbVersion: t6.gdbVersion, historicMoment: t6.historicMoment, timeExtent: T.fromJSON(t6.timeExtent) }, a8 = this._schema && a2(i5, "outFields");
    this._schema && y2(i5, ["timeExtent", "definitionExpression", "gdbVersion", "historicMoment", "customParameters"]) && (s9.why.mesh.push("Layer filter and/or custom parameters changed"), s9.why.source.push("Layer filter and/or custom parameters changed"), s9.mesh = true, s9.source = true, s9.queryFilter = true), a8 && (s9.why.source.push("Layer required fields changed"), s9.source = true), m2(n7, this._queryInfo) && (this._queryInfo = n7), this._schema = t6, this._resolver.resolve();
  }
  whenInitialized() {
    return this._resolver.promise;
  }
  async applyUpdate(e3) {
    if (e3.queryFilter || e3.source && this._didEdit)
      return this.refresh(e3.version), void (this._didEdit = false);
    this._subscriptions.forEach((s9) => s9.applyUpdate(e3)), await this.resend();
  }
  refresh(e3, s9) {
    for (const t6 of this._tiles())
      this.unsubscribe(t6), this.subscribe(t6, e3);
  }
  subscribe(e3, s9) {
    const t6 = new a4(e3, s9);
    this._subscriptions.set(e3.id, t6);
  }
  unsubscribe(e3) {
    const s9 = this.get(e3.id);
    r(s9) && s9.abort(), this._subscriptions.delete(e3.id);
  }
  createQuery(e3 = {}) {
    const s9 = this._queryInfo.historicMoment ? new Date(this._queryInfo.historicMoment) : null;
    return new x({ ...this._queryInfo, historicMoment: s9, ...e3 });
  }
  get(e3) {
    return this._subscriptions.has(e3) ? this._subscriptions.get(e3) : null;
  }
  async queryLastEditDate() {
    throw new Error("Service does not support query type");
  }
  async query(e3) {
    throw new Error("Service does not support query");
  }
  *_tiles() {
    const e3 = Array.from(this._subscriptions.values());
    for (const s9 of e3)
      yield s9.tile;
  }
  async edit(e3, s9) {
    const t6 = Array.from(this._subscriptions.values()), r6 = t6.map(({ tile: e4 }) => e4);
    for (const i5 of t6)
      i5.removeIds(s9);
    if (e3.length) {
      const t7 = r6.map((s10) => {
        const t8 = this.createTileQuery(s10);
        return t8.objectIds = e3, { tile: s10, query: t8 };
      }).map(async ({ tile: e4, query: s10 }) => ({ tile: e4, result: await this.query(s10), query: s10 })), i5 = (await L(t7)).map(async ({ tile: t8, result: r7 }) => {
        if (!r7.hasFeatures && !s9.length && !e3.length)
          return;
        const i6 = this._subscriptions.get(t8.key.id);
        i6 && i6.edit(r7, e3);
      });
      await E(i5);
    }
    this._didEdit = true;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/BaseFeatureSource.js
var p3 = 4;
var d5 = class extends m4 {
  constructor(e3) {
    super(e3), this.type = "feature", this.mode = "on-demand", this._adapter = y4(e3.serviceInfo), this._queue = new l2({ concurrency: 8, process: async (e4) => {
      if (f2(e4), r(e4.tile)) {
        const t6 = e4.tile.key.id, { signal: r6 } = e4, s9 = has("esri-tiles-debug") ? { tile: t6.replace(/\//g, "."), depth: e4.depth } : void 0, i5 = await this._adapter.executeQuery(e4.query, { signal: r6, query: { ...s9, ...this._schema.customParameters } });
        return i5.level = e4.tile.key.level, i5;
      }
      return this._adapter.executeQuery(e4.query, { ...e4, query: this._schema.customParameters });
    } }), this._patchQueue = new l2({ concurrency: 8, process: async (e4) => {
      if (f2(e4), r(e4.tile)) {
        const t6 = e4.tile.key.id, { signal: r6 } = e4, s9 = has("esri-tiles-debug") ? { tile: t6.replace(/\//g, "."), depth: e4.depth } : void 0, i5 = await this._adapter.executeQuery(e4.query, { signal: r6, query: { ...s9, ...this._schema.customParameters } });
        return i5.level = e4.tile.key.level, i5;
      }
      return this._adapter.executeQuery(e4.query, { ...e4, query: this._schema.customParameters });
    } });
  }
  destroy() {
    super.destroy(), this._adapter.destroy(), this._queue.destroy(), this._patchQueue.destroy();
  }
  get updating() {
    return !!this._queue.length || Array.from(this._subscriptions.values()).some((e3) => !e3.done);
  }
  get maxRecordCountFactor() {
    const { query: e3 } = this._serviceInfo.capabilities;
    return e3.supportsMaxRecordCountFactor ? p3 : null;
  }
  get maxPageSize() {
    var _a;
    const { query: e3 } = this._serviceInfo.capabilities;
    return ((_a = e3.maxRecordCount) != null ? _a : 8e3) * i(this.maxRecordCountFactor, 1);
  }
  get pageSize() {
    return Math.min(8e3, this.maxPageSize);
  }
  enableEvent(e3, t6) {
  }
  subscribe(e3, s9) {
    super.subscribe(e3, s9);
    const i5 = this._subscriptions.get(e3.id);
    this._fetchDataTile(e3).catch((s10) => {
      j(s10) || s.getLogger("esri.views.2d.layers.features.sources.BaseFeatureSource").error(new s2("mapview-query-error", "Encountered error when fetching tile", { tile: e3, error: s10 }));
    }).then(() => i5.end());
  }
  unsubscribe(e3) {
    super.unsubscribe(e3);
  }
  readers(e3) {
    return this._subscriptions.get(e3).readers();
  }
  async query(e3) {
    return this._adapter.executeQuery(e3, { query: this._schema.customParameters });
  }
  async queryLastEditDate() {
    const t6 = this._serviceInfo.source, r6 = { ...t6.query, f: "json" };
    return (await U2(t6.path, { query: r6, responseType: "json" })).data.editingInfo.lastEditDate;
  }
  createTileQuery(e3, t6 = {}) {
    var _a;
    const r6 = this._serviceInfo.geometryType, s9 = this.createQuery(t6);
    s9.quantizationParameters = (_a = t6.quantizationParameters) != null ? _a : e3.getQuantizationParameters(), s9.resultType = "tile", s9.geometry = e3.extent, this._serviceInfo.capabilities.query.supportsQuantization ? "esriGeometryPolyline" === r6 && (s9.maxAllowableOffset = e3.resolution * has("feature-polyline-generalization-factor")) : "esriGeometryPolyline" !== r6 && "esriGeometryPolygon" !== r6 || (s9.maxAllowableOffset = e3.resolution, "esriGeometryPolyline" === r6 && (s9.maxAllowableOffset *= has("feature-polyline-generalization-factor")));
    const i5 = this._serviceInfo.capabilities.query;
    return s9.defaultSpatialReferenceEnabled = i5.supportsDefaultSpatialReference, s9.compactGeometryEnabled = i5.supportsCompactGeometry, s9;
  }
  async _executePatchQuery(e3, t6, r6, i5) {
    const a8 = t6.clone();
    a8.outFields = [this._serviceInfo.objectIdField, ...r6], a8.returnCentroid = false, a8.returnGeometry = false;
    const o7 = r(a8.start) ? a8.start / 8e3 : 0, n7 = i5.signal;
    return this._patchQueue.push({ tile: e3, query: a8, signal: n7, depth: o7 });
  }
  async _resend(e3, t6) {
    const { query: r6, message: i5 } = e3, n7 = r(r6.outFields) ? r6.outFields : [], u4 = this._queryInfo.outFields, c9 = u4.filter((e4) => !n7.includes(e4));
    if (t(i5.addOrUpdate))
      this._onMessage({ ...i5, type: "append" });
    else if (c9.length)
      try {
        const e4 = this._subscriptions.get(i5.id).tile, s9 = await this._executePatchQuery(e4, r6, c9, t6);
        f2(t6), r6.outFields = u4, i5.addOrUpdate.joinAttributes(s9), this._onMessage({ ...i5, end: i5.end, type: "append" });
      } catch (l9) {
      }
    else
      this._onMessage({ ...i5, type: "append" });
  }
  async _resendSubscription(e3) {
    if (has("esri-2d-update-debug") && console.debug(e3.tile.id, "Resend Subscription"), e3.empty)
      return this._onMessage({ id: e3.tile.id, addOrUpdate: null, end: false, type: "append" });
    const t6 = e3.signal;
    for (const r6 of e3.requests.done)
      await this._resend(r6, { signal: t6 });
    return r(e3.edits) ? this._onMessage(e3.edits) : void 0;
  }
  async resend() {
    const e3 = Array.from(this._subscriptions.values());
    await Promise.all(e3.map((e4) => this._resendSubscription(e4)));
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/DrillDownFeatureSource.js
var s8 = has("esri-mobile");
var i4 = { maxDrillLevel: s8 ? 1 : 4, maxRecordCountFactor: s8 ? 1 : 3 };
var a5 = class extends d5 {
  constructor(e3) {
    super(e3);
  }
  async _fetchDataTile(r6) {
    const s9 = this._serviceInfo.capabilities.query.supportsMaxRecordCountFactor, a8 = this._subscriptions.get(r6.key.id), o7 = a8.signal, n7 = r6.getQuantizationParameters();
    let c9 = 0;
    const d9 = async (u4, l9) => {
      const p4 = this._queryInfo, m6 = this.createTileQuery(u4, { maxRecordCountFactor: s9 ? i4.maxRecordCountFactor : void 0, returnExceededLimitFeatures: false, quantizationParameters: n7 });
      c9++;
      try {
        const t6 = await this._queue.push({ tile: r6, query: m6, signal: o7, depth: l9 });
        if (c9--, f2(o7), !t6)
          return;
        if (p4 !== this._queryInfo)
          return void d9(u4, l9);
        if (t6.exceededTransferLimit && l9 < i4.maxDrillLevel) {
          for (const e3 of u4.createChildTiles())
            d9(e3, l9 + 1);
          return;
        }
        const s10 = { id: r6.id, addOrUpdate: t6, end: 0 === c9, type: "append" };
        a8.add({ query: m6, message: s10 }), this._onMessage(s10);
      } catch (h6) {
        j(h6) || this._onMessage({ id: r6.id, addOrUpdate: null, end: true, type: "append" });
      }
    };
    d9(r6, 0);
  }
};

// node_modules/@arcgis/core/layers/graphics/data/StreamFeatureManager.js
var o6 = "__esri_stream_id__";
var d6 = "__esri_timestamp__";
var a6 = 1e3;
var h4 = class {
  constructor(t6, e3, s9, i5, r6 = 128) {
    this._trackIdToObservations = /* @__PURE__ */ new Map(), this._idCounter = 0, this._lastPurge = performance.now(), this._addOrUpdated = /* @__PURE__ */ new Map(), this._removed = [], this._maxAge = 0, this._timeInfo = s9, this._purgeOptions = i5, this.store = t6, this.objectIdField = e3, this.purgeInterval = r6, this._useGeneratedIds = this.objectIdField === o6;
  }
  add(r6) {
    if (this._useGeneratedIds) {
      const t6 = this._nextId();
      r6.attributes[this.objectIdField] = t6, r6.objectId = t6;
    } else
      r6.objectId = r6.attributes[this.objectIdField];
    if (this._addOrUpdated.set(r6.objectId, r6), this._maxAge = Math.max(this._maxAge, r6.attributes[this._timeInfo.startTimeField]), !this._timeInfo.trackIdField)
      return t(this._trackIdLessObservations) && (this._trackIdLessObservations = new s7(1e5)), void this._trackIdLessObservations.enqueue(r6.objectId);
    const o7 = r6.attributes[this._timeInfo.trackIdField];
    if (!this._trackIdToObservations.has(o7)) {
      const s9 = r(this._purgeOptions) && null != this._purgeOptions.maxObservations ? this._purgeOptions.maxObservations : a6, r7 = a(s9, 0, a6);
      this._trackIdToObservations.set(o7, new s7(r7));
    }
    const d9 = this._trackIdToObservations.get(o7).enqueue(r6.objectId);
    r(d9) && (this._addOrUpdated.has(d9) ? this._addOrUpdated.delete(d9) : this._removed.push(d9));
  }
  checkForUpdates() {
    const t6 = this._getToAdd(), e3 = this._getToRemove(), s9 = performance.now();
    s9 - this._lastPurge >= this.purgeInterval && (this._purge(s9), this._lastPurge = s9);
    const r6 = [];
    if (r(e3))
      for (const o7 of e3) {
        const t7 = this.store.removeById(o7);
        r(t7) && r6.push(t7);
      }
    if (r(t6))
      for (const i5 of t6)
        i5.attributes[d6] = s9, this.store.add(i5);
    (t6 || (r6 == null ? void 0 : r6.length)) && this.store.update(t6, r6);
  }
  _getToAdd() {
    if (!this._addOrUpdated.size)
      return null;
    const t6 = new Array(this._addOrUpdated.size);
    let e3 = 0;
    return this._addOrUpdated.forEach((s9) => t6[e3++] = s9), this._addOrUpdated.clear(), t6;
  }
  _getToRemove() {
    const t6 = this._removed;
    return this._removed.length ? (this._removed = [], t6) : null;
  }
  _nextId() {
    const t6 = this._idCounter;
    return this._idCounter = (this._idCounter + 1) % 4294967294 + 1, t6;
  }
  _purge(t6) {
    const e3 = this._purgeOptions;
    r(e3) && (this._purgeSomeByDisplayCount(e3), this._purgeByAge(e3), this._purgeByAgeReceived(t6, e3), this._purgeTracks());
  }
  _purgeSomeByDisplayCount(t6) {
    if (!t6.displayCount)
      return;
    let e3 = this.store.size;
    if (e3 > t6.displayCount) {
      if (this._timeInfo.trackIdField) {
        for (const s9 of this._trackIdToObservations.values())
          if (e3 > t6.displayCount && s9.size) {
            const t7 = e(s9.dequeue());
            this._removed.push(t7), e3--;
          }
      }
      if (r(this._trackIdLessObservations)) {
        let s9 = e3 - t6.displayCount;
        for (; s9-- > 0; ) {
          const t7 = this._trackIdLessObservations.dequeue();
          r(t7) && this._removed.push(t7);
        }
      }
    }
  }
  _purgeByAge(t6) {
    var _a;
    if (!t6.age || !((_a = this._timeInfo) == null ? void 0 : _a.startTimeField))
      return;
    const e3 = 60 * t6.age * 1e3, s9 = this._maxAge - e3;
    this.store.forEach((t7) => {
      t7.attributes[this._timeInfo.startTimeField] < s9 && this._removed.push(t7.objectId);
    });
  }
  _purgeByAgeReceived(t6, e3) {
    if (!e3.ageReceived)
      return;
    const s9 = t6 - 60 * e3.ageReceived * 1e3;
    this.store.forEach((t7) => {
      t7.attributes[d6] < s9 && this._removed.push(t7.objectId);
    });
  }
  _purgeTracks() {
    this._trackIdToObservations.forEach((t6, e3) => {
      0 === t6.size && this._trackIdToObservations.delete(e3);
    });
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/GeoEventSource.js
var l7 = 2500;
function m5(t6, s9) {
  const r6 = t6.weakClone();
  if (r(t6.geometry)) {
    const e3 = w2(s9, t6.geometry.coords[0]), i5 = M(s9, t6.geometry.coords[1]);
    r6.geometry = new t3([], [e3, i5]);
  }
  return r6;
}
function _3(e3) {
  return "esriGeometryPoint" === e3 ? m5 : (t6, s9) => {
    const r6 = t6.weakClone(), n7 = new t3(), o7 = false, d9 = false, c9 = at(n7, t6.geometry, o7, d9, e3, s9, false, false);
    return r6.geometry = c9, r6;
  };
}
function f7(t6) {
  return "esriGeometryPoint" === t6 ? (t7) => r(t7.geometry) ? { minX: t7.geometry.coords[0], minY: t7.geometry.coords[1], maxX: t7.geometry.coords[0], maxY: t7.geometry.coords[1] } : { minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 } : (t7) => {
    let s9 = 1 / 0, r6 = 1 / 0, i5 = -1 / 0, n7 = -1 / 0;
    return r(t7.geometry) && t7.geometry.forEachVertex((e3, t8) => {
      s9 = Math.min(s9, e3), r6 = Math.min(r6, t8), i5 = Math.max(i5, e3), n7 = Math.max(n7, t8);
    }), { minX: s9, minY: r6, maxX: i5, maxY: n7 };
  };
}
function v5(e3, t6) {
  const r6 = i2(9, f7(t6));
  return r6.load(e3), r6;
}
function g5(e3, t6) {
  return e3.search({ minX: t6.bounds[0], minY: t6.bounds[1], maxX: t6.bounds[2], maxY: t6.bounds[3] });
}
var y5 = class {
  constructor(e3, t6) {
    this.onUpdate = e3, this._geometryType = t6, this._objectIdToFeature = /* @__PURE__ */ new Map();
  }
  get _features() {
    const e3 = [];
    return this._objectIdToFeature.forEach((t6) => e3.push(t6)), e3;
  }
  add(e3) {
    this._objectIdToFeature.set(e3.objectId, e3), this._index = null;
  }
  get(e3) {
    return this._objectIdToFeature.has(e3) ? this._objectIdToFeature.get(e3) : null;
  }
  forEach(e3) {
    this._objectIdToFeature.forEach(e3);
  }
  search(e3) {
    return this._index || (this._index = v5(this._features, this._geometryType)), g5(this._index, e3);
  }
  removeById(e3) {
    const t6 = this._objectIdToFeature.get(e3);
    return t6 ? (this._objectIdToFeature.delete(e3), this._index = null, t6) : null;
  }
  update(e3, t6) {
    this.onUpdate(e3, t6);
  }
  get size() {
    return this._objectIdToFeature.size;
  }
};
var b4 = class extends m4 {
  constructor(e3) {
    super(e3), this.type = "geoevent", this._dataReceiveEventEnabled = false, this._level = 0, this._updateInfo = { websocket: 0, client: 0 }, this._inUpdate = false;
    const { outSR: s9 } = e3, { geometryType: r6, objectIdField: i5, timeInfo: n7, purgeOptions: o7, source: a8, spatialReference: h6, serviceFilter: u4, maxReconnectionAttempts: p4, maxReconnectionInterval: m6, updateInterval: f9, enableDataReceived: v6, customParameters: g6 } = e3.serviceInfo, b6 = new y5(this._onUpdate.bind(this), r6), I2 = new h4(b6, i5, n7, o7), U4 = t4(a8, h6, s9, r6, u4, p4, m6, g6);
    this._store = b6, this._manager = I2, this._connection = U4, this._quantize = _3(r6), this._dataReceiveEventEnabled = v6, this._handles = [this._connection.on("data-received", (e4) => this._onFeature(e4)), l(() => U4.connectionStatus, (e4) => this.events.emit("connectionStatus", e4)), l(() => U4.errorString, (e4) => this.events.emit("errorString", e4))], this._initUpdateInterval = () => {
      let t6 = performance.now();
      this._updateIntervalId = setInterval(() => {
        const s10 = performance.now(), r7 = s10 - t6;
        if (r7 > l7) {
          t6 = s10;
          const e4 = Math.round(this._updateInfo.client / (r7 / 1e3)), i6 = Math.round(this._updateInfo.websocket / (r7 / 1e3));
          this._updateInfo.client = 0, this._updateInfo.websocket = 0, this.events.emit("updateRate", { client: e4, websocket: i6 });
        }
        e3.canAcceptRequest() && !this._inUpdate && this._manager.checkForUpdates();
      }, f9);
    }, this._initUpdateInterval();
  }
  destroy() {
    super.destroy(), this._clearUpdateInterval(), this._handles.forEach((e3) => e3.remove()), this._connection.destroy();
  }
  _fetchDataTile() {
  }
  pauseStream() {
    this._clearUpdateInterval();
  }
  resumeStream() {
    this._initUpdateInterval();
  }
  enableEvent(e3, t6) {
    "data-received" === e3 && (this._dataReceiveEventEnabled = t6);
  }
  get updating() {
    return false;
  }
  subscribe(e3, t6) {
    super.subscribe(e3, t6);
    const s9 = this._subscriptions.get(e3.id);
    this._level = e3.level;
    const r6 = this._getTileFeatures(e3);
    this._onMessage({ type: "append", id: e3.key.id, addOrUpdate: r6, end: true }), s9.didSend = true;
  }
  unsubscribe(e3) {
    super.unsubscribe(e3);
  }
  *readers(t6) {
    const s9 = this._subscriptions.get(t6), { tile: r6 } = s9;
    yield this._getTileFeatures(r6);
    for (const i5 of s9.requests.stream.entries)
      r(i5) && r(i5.addOrUpdate) && (yield i5.addOrUpdate);
  }
  createTileQuery(e3) {
    throw new Error("Service does not support tile  queries");
  }
  async resend() {
    this._subscriptions.forEach((e3) => {
      const { tile: t6 } = e3, s9 = { type: "append", id: t6.id, addOrUpdate: this._getTileFeatures(t6), end: true };
      this._onMessage(s9);
    });
  }
  _getTileFeatures(e3) {
    const t6 = this._store.search(e3).map((t7) => this._quantize(t7, e3.transform));
    return c5.fromOptimizedFeatures(t6, this._serviceInfo, e3.transform);
  }
  _onFeature(e3) {
    this._updateInfo.websocket++;
    try {
      this._dataReceiveEventEnabled && this.events.emit("data-received", e3);
      const t6 = X(e3, this._serviceInfo.geometryType, false, false, this._serviceInfo.objectIdField);
      this._manager.add(t6);
    } catch (t6) {
    }
  }
  _clearUpdateInterval() {
    clearInterval(this._updateIntervalId), this._updateIntervalId = 0;
  }
  async _onUpdate(t6, s9) {
    this._inUpdate = true;
    try {
      r(t6) && (this._updateInfo.client += t6.length), this._subscriptions.forEach((e3, t7) => {
        e3.didSend && e3.tile.level === this._level && this._onMessage({ type: "append", id: t7, addOrUpdate: null, clear: true, end: false });
      });
      const s10 = [];
      this._subscriptions.forEach((e3, t7) => {
        if (!e3.didSend || e3.tile.level !== this._level)
          return;
        const r6 = e3.tile, i5 = { type: "append", id: t7, addOrUpdate: this._getTileFeatures(r6), remove: [], end: false, status: t5.empty() };
        e3.requests.stream.enqueue(i5), s10.push(this._onMessage(i5));
      }), await Promise.all(s10), this._subscriptions.forEach((e3, t7) => {
        e3.didSend && e3.tile.level === this._level && this._onMessage({ type: "append", id: t7, addOrUpdate: null, end: true });
      });
    } catch {
    }
    this._inUpdate = false;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/PagedFeatureSource.js
var n6 = class extends d5 {
  constructor(e3) {
    super(e3);
  }
  async _fetchDataTile(r6) {
    const i5 = 6, o7 = 20, n7 = this._subscriptions.get(r6.key.id);
    let d9 = false, c9 = 0, u4 = 0;
    const p4 = (e3, t6) => {
      u4--, f2(n7);
      const a8 = r6.id, i6 = e3.reader, o8 = e3.query;
      if (!i6.exceededTransferLimit) {
        if (d9 = true, 0 !== t6 && !i6.hasFeatures) {
          const e5 = { id: a8, addOrUpdate: i6, end: 0 === u4, type: "append" };
          return n7.add({ message: e5, query: o8 }), void this._onMessage(e5);
        }
        const e4 = { id: a8, addOrUpdate: i6, end: 0 === u4, type: "append" };
        return n7.add({ message: e4, query: o8 }), void this._onMessage(e4);
      }
      const c10 = { id: a8, addOrUpdate: i6, end: d9 && 0 === u4, type: "append" };
      n7.add({ message: c10, query: o8 }), this._onMessage(c10);
    };
    let h6 = 0, m6 = 0;
    for (; !d9 && m6++ < o7; ) {
      let o8;
      for (let s9 = 0; s9 < h6 + 1; s9++) {
        const s10 = c9++;
        u4++, o8 = this._fetchDataTilePage(r6, s10, n7).then((e3) => e3 && p4(e3, s10)).catch((s11) => {
          d9 = true, j(s11) || (s.getLogger("esri.views.2d.layers.features.sources.PagedFeatureSource").error(new s2("mapview-query-error", "Encountered error when fetching tile", { tile: r6, error: s11 })), this._onMessage({ id: r6.id, addOrUpdate: null, end: d9, type: "append" }));
        });
      }
      await o8, f2(n7), h6 = Math.min(h6 + 2, i5);
    }
  }
  async _fetchDataTilePage(e3, t6, a8) {
    f2(a8);
    const o7 = this._queryInfo, n7 = { start: this.pageSize * t6, num: this.pageSize, returnExceededLimitFeatures: true, quantizationParameters: e3.getQuantizationParameters() };
    r(this.maxRecordCountFactor) && (n7.maxRecordCountFactor = this.maxRecordCountFactor);
    const d9 = this.createTileQuery(e3, n7);
    try {
      const r6 = a8.signal, i5 = await this._queue.push({ tile: e3, query: d9, signal: r6, depth: t6 });
      return f2(a8), i5 ? o7 !== this._queryInfo ? this._fetchDataTilePage(e3, t6, a8) : { reader: i5, query: d9 } : null;
    } catch (c9) {
      return b2(c9), null;
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/SnapshotFeatureSource.js
function h5(t6, e3, s9) {
  const r6 = t6.getXHydrated(), o7 = t6.getYHydrated(), a8 = e3.getColumnForX(r6), n7 = Math.floor(e3.normalizeCol(a8));
  return `${s9}/${Math.floor(e3.getRowForY(o7))}/${n7}`;
}
function l8(t6, e3) {
  if (t(t6))
    return null;
  const s9 = e3.transform, o7 = t6.getQuantizationTransform();
  if (t(o7)) {
    const [e4, r6] = s9.scale, [o8, a9] = s9.translate, n8 = -o8 / e4, i6 = 1 / e4, d10 = a9 / r6, u5 = 1 / -r6;
    return t6.transform(n8, d10, i6, u5);
  }
  const [a8, n7] = o7.scale, [i5, d9] = o7.translate, [u4, h6] = s9.scale, [l9, c9] = s9.translate, g6 = a8 / u4, _4 = (i5 - l9) / u4, p4 = n7 / h6, f9 = (-d9 + c9) / h6;
  return t6.transform(_4, f9, g6, p4);
}
var c6 = class extends d5 {
  constructor(t6) {
    super(t6), this.mode = "snapshot", this._loading = true, this._controller = new AbortController(), this._downloadPromise = null, this._didSendEnd = false, this._queries = new Array(), this._invalidated = false, this._hasAggregates = false, this._random = new t2(1e3), this._store = t6.store, this._markedIdsBufId = this._store.storage.createBitset();
  }
  destroy() {
    super.destroy(), this._controller.abort();
  }
  get loading() {
    return this._loading;
  }
  get _signal() {
    return this._controller.signal;
  }
  update(t6, s9) {
    super.update(t6, s9), null == this._featureCount && (this._featureCount = s9.initialFeatureCount), r(s9.changedFeatureCount) && (this._featureCount = s9.changedFeatureCount), this._hasAggregates = t6.targets.aggregate;
  }
  async resend(t6 = false) {
    if (await this._downloadPromise, this._invalidated || t6) {
      const t7 = f(this._featureCount, "Expected featureCount to be defined");
      return this._invalidated = false, this._subscriptions.forEach((t8) => t8.clear()), this._downloadPromise = this._download(t7), void await this._downloadPromise;
    }
    const e3 = this._queries.map(({ query: t7, reader: e4 }) => this._sendPatchQuery(t7, e4));
    await Promise.all(e3), this._subscriptions.forEach((t7) => {
      t7.requests.done.forEach((t8) => this._onMessage(t8.message));
    });
  }
  async refresh(t6, e3) {
    e3 && (this._featureCount = e3.featureCount), await this.resend(true);
  }
  async _sendPatchQuery(t6, s9) {
    const r6 = r(t6.outFields) ? t6.outFields : [], a8 = this._queryInfo.outFields, n7 = a8.filter((t7) => !r6.includes(t7));
    if (!n7.length)
      return;
    const i5 = t6.clone(), d9 = this._signal;
    i5.returnGeometry = false, i5.returnCentroid = false, i5.outFields = n7, t6.outFields = a8;
    const u4 = await this._queue.push({ query: i5, depth: 0, signal: d9 });
    f2({ signal: d9 }), s9.joinAttributes(u4);
  }
  async _fetchDataTile(t6) {
    if (!this._downloadPromise) {
      const t7 = f(this._featureCount, "Expected featureCount to be defined");
      this._downloadPromise = this._download(t7);
    }
    const e3 = this._store.search(t6), r6 = this._subscriptions.get(t6.key.id), o7 = e3.length - 1;
    for (let s9 = 0; s9 < o7; s9++) {
      const o8 = l8(e3[s9], t6), n8 = { type: "append", id: t6.id, addOrUpdate: o8, end: false, status: t5.empty() };
      r6.add({ query: null, message: n8 }), this._hasAggregates || await U(1), this._onMessage(n8);
    }
    const n7 = l8(o7 >= 0 ? e3[o7] : null, t6), i5 = this._didSendEnd, d9 = { type: "append", id: t6.id, addOrUpdate: n7, end: i5, status: t5.empty() };
    r6.add({ query: null, message: d9 }), this._onMessage(d9);
  }
  async _download(e3) {
    try {
      await this.whenInitialized();
      const t6 = this._store.storage.getBitset(this._markedIdsBufId), s9 = /* @__PURE__ */ new Set();
      t6.clear();
      const r6 = Math.ceil(e3 / this.pageSize), o7 = Array.from({ length: r6 }, (t7, e4) => e4).sort((t7, e4) => this._random.getInt() - this._random.getInt()).map((e4) => this._downloadPage(e4, t6, s9));
      await Promise.all(o7), this._store.sweepFeatures(t6, this._store.storage), this._store.sweepFeatureSets(s9);
    } catch (s9) {
      s.getLogger("esri.views.2d.layers.features.sources.SnapshotFeatureSource").error("mapview-snapshot-source", "Encountered and error when downloading feature snapshot", s9);
    }
    this._sendEnd(), this._loading = false;
  }
  async _downloadPage(t6, s9, r6) {
    const a8 = this.pageSize, n7 = { start: t6 * a8, num: a8, cacheHint: true };
    r(this.maxRecordCountFactor) && (n7.maxRecordCountFactor = this.maxRecordCountFactor);
    const i5 = this.createQuery(n7), d9 = this._signal, u4 = await this._queue.push({ query: i5, depth: t6, signal: d9 });
    f2({ signal: d9 }), this._queries.push({ query: i5, reader: u4 }), this._store.insert(u4), r6.add(u4.instance);
    const h6 = u4.getCursor();
    for (; h6.next(); )
      s9.set(h6.getDisplayId());
    this._send(u4);
  }
  _send(t6) {
    if (!this._subscriptions.size)
      return;
    let s9 = null;
    const o7 = /* @__PURE__ */ new Map(), a8 = /* @__PURE__ */ new Set(), n7 = /* @__PURE__ */ new Map();
    this._subscriptions.forEach((t7) => {
      var _a;
      const e3 = t7.tile;
      o7.set(e3.key.id, null), s9 = e3.tileInfoView, a8.add(e3.level);
      const { row: r6, col: i5 } = e3.key, d9 = `${e3.level}/${r6}/${i5}`, u4 = (_a = n7.get(d9)) != null ? _a : [];
      u4.push(t7), n7.set(d9, u4);
    });
    for (const e3 of a8) {
      const a9 = s9.getLODInfoAt(e3), i5 = t6.getCursor();
      for (; i5.next(); ) {
        const t7 = h5(i5, a9, e3), s10 = i5.getIndex();
        if (n7.has(t7))
          for (const e4 of n7.get(t7)) {
            const t8 = e4.tile.id;
            let a10 = o7.get(t8);
            t(a10) && (a10 = [], o7.set(t8, a10)), a10.push(s10);
          }
      }
    }
    o7.forEach((s10, r6) => {
      if (r(s10)) {
        const e3 = this._subscriptions.get(r6), o8 = { type: "append", id: r6, addOrUpdate: l8(r3.from(t6, s10), e3.tile), end: false, status: t5.empty() };
        e3.add({ query: null, message: o8 }), this._onMessage(o8);
      }
    });
  }
  _sendEnd() {
    this._subscriptions.forEach((t6) => {
      const e3 = { type: "append", id: t6.tile.id, addOrUpdate: null, end: true, status: t5.empty() };
      t6.add({ query: null, message: e3 }), this._onMessage(e3);
    }), this._didSendEnd = true;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/createSource.js
function a7(e3, r6, a8, u4, i5, p4) {
  const f9 = c7(e3, r6, a8, u4, i5, p4);
  switch (f9.type) {
    case "feature":
      switch (f9.origin) {
        case "hosted":
        case "local":
          return new n6(f9);
        case "snapshot":
          return new c6(f9);
        case "unknown":
          return new a5(f9);
      }
    case "geoevent":
      return new b4(f9);
  }
}
function c7(t6, o7, n7, s9, a8, c9) {
  switch (t6.type) {
    case "snapshot":
      return { type: "feature", origin: "snapshot", featureCount: i(t6.featureCount, 0), serviceInfo: t6, onMessage: s9, outSR: o7, tileInfoView: n7, canAcceptRequest: a8, store: c9 };
    case "stream":
      return { type: "geoevent", serviceInfo: t6, onMessage: s9, outSR: o7, canAcceptRequest: a8 };
    case "memory":
    case "on-demand":
      return { type: "feature", serviceInfo: t6, onMessage: s9, outSR: o7, origin: u4(t6.source), tileInfoView: n7, canAcceptRequest: a8 };
  }
  function u4(e3) {
    return Array.isArray(e3) ? "local" : "path" in e3 && g2(e3.path) ? "hosted" : "unknown";
  }
}

// node_modules/@arcgis/core/geohash/geohashUtils.js
var c8 = new Float64Array(2);
var f8 = new Float64Array(2);
function X2(t6, n7) {
  let o7 = -90, r6 = 90, e3 = -180, c9 = 180;
  for (let f9 = 0; f9 < n7; f9++) {
    const n8 = Math.ceil((f9 + 1) / 2), u4 = Math.floor((f9 + 1) / 2), l9 = 1 - f9 % 2, h6 = 30 - (3 * n8 + 2 * u4), s9 = 30 - (2 * n8 + 3 * u4), i5 = 3 * l9 + 2 * (1 - l9), a8 = 2 * l9 + 3 * (1 - l9), g6 = 3 * l9 + 7 * (1 - l9) << s9, M2 = (7 * l9 + 3 * (1 - l9) << h6 & t6.geohashX) >> h6, A3 = (g6 & t6.geohashY) >> s9;
    for (let t7 = i5 - 1; t7 >= 0; t7--) {
      const n9 = (e3 + c9) / 2, o8 = M2 & 1 << t7 ? 1 : 0;
      e3 = (1 - o8) * e3 + o8 * n9, c9 = (1 - o8) * n9 + o8 * c9;
    }
    for (let t7 = a8 - 1; t7 >= 0; t7--) {
      const n9 = (o7 + r6) / 2, e4 = A3 & 1 << t7 ? 1 : 0;
      o7 = (1 - e4) * o7 + e4 * n9, r6 = (1 - e4) * n9 + e4 * r6;
    }
  }
  return [e3, o7, c9, r6];
}
function Y2(t6, n7, o7, r6) {
  r6 % 2 && (r6 += 1);
  let e3 = 0, c9 = 0, f9 = -90, u4 = 90, l9 = -180, h6 = 180;
  for (let s9 = 0; s9 < r6 / 2; s9++) {
    for (let t7 = 0; t7 < 5; t7++) {
      const n8 = (l9 + h6) / 2, r7 = o7 > n8 ? 1 : 0;
      e3 |= r7 << 29 - (t7 + 5 * s9), l9 = (1 - r7) * l9 + r7 * n8, h6 = (1 - r7) * n8 + r7 * h6;
    }
    for (let t7 = 0; t7 < 5; t7++) {
      const o8 = (f9 + u4) / 2, r7 = n7 > o8 ? 1 : 0;
      c9 |= r7 << 29 - (t7 + 5 * s9), f9 = (1 - r7) * f9 + r7 * o8, u4 = (1 - r7) * o8 + r7 * u4;
    }
  }
  t6.geohashX = e3, t6.geohashY = c9;
}
function b5(t6, n7, o7, r6, e3) {
  e3 % 2 && (e3 += 1);
  let c9 = 0, f9 = 0, u4 = -90, l9 = 90, h6 = -180, s9 = 180;
  for (let i5 = 0; i5 < e3 / 2; i5++) {
    for (let t7 = 0; t7 < 5; t7++) {
      const n8 = (h6 + s9) / 2, o8 = r6 > n8 ? 1 : 0;
      c9 |= o8 << 29 - (t7 + 5 * i5), h6 = (1 - o8) * h6 + o8 * n8, s9 = (1 - o8) * n8 + o8 * s9;
    }
    for (let t7 = 0; t7 < 5; t7++) {
      const n8 = (u4 + l9) / 2, r7 = o7 > n8 ? 1 : 0;
      f9 |= r7 << 29 - (t7 + 5 * i5), u4 = (1 - r7) * u4 + r7 * n8, l9 = (1 - r7) * n8 + r7 * l9;
    }
  }
  t6[2 * n7] = c9, t6[2 * n7 + 1] = f9;
}

// node_modules/@arcgis/core/geohash/GeohashTree.js
var u2 = class {
  constructor(e3 = [], s9, i5 = 8096) {
    this.onRelease = (t6) => {
    }, this._nodes = 0, this._root = new d7(this, 0, 0, 0), this._statisticFields = e3, this._pool = i5 ? new s7(8096) : null, this._serviceInfo = s9;
  }
  destroy() {
    this.clear();
  }
  _acquire(t6, s9, i5) {
    this._nodes++;
    let n7 = null;
    return r(this._pool) && (n7 = this._pool.dequeue()), r(n7) ? n7.realloc(t6, s9, i5) : n7 = new d7(this, t6, s9, i5), n7;
  }
  _release(t6) {
    this.onRelease(t6), this._nodes--, r(this._pool) && this._pool.enqueue(t6);
  }
  get count() {
    return this._root.count;
  }
  get size() {
    return this._nodes;
  }
  get poolSize() {
    return b(this._pool, 0, (t6) => t6.size);
  }
  get depth() {
    let t6 = 0;
    return this.forEach((e3) => t6 = Math.max(t6, e3.depth)), t6;
  }
  dropLevels(t6) {
    this.forEach((e3) => {
      if (e3.depth >= t6)
        for (let t7 = 0; t7 < e3.children.length; t7++) {
          const s9 = e3.children[t7];
          s9 && this._release(s9);
        }
    }), this.forEach((e3) => {
      if (e3.depth >= t6)
        for (let t7 = 0; t7 < e3.children.length; t7++)
          e3.children[t7] = null;
    });
  }
  clear() {
    this.forEach((t6) => this._release(t6)), this._root = new d7(this, 0, 0, 0);
  }
  insert(t6, e3, s9 = 0) {
    const i5 = c5.fromOptimizedFeatures([t6], this._serviceInfo).getCursor();
    i5.next();
    const n7 = i5.readGeometry();
    if (!n7)
      return;
    const [o7, a8] = n7.coords, r6 = t6.geohashX, l9 = t6.geohashY;
    this.insertCursor(i5, t6.displayId, o7, a8, r6, l9, e3, s9);
  }
  insertCursor(t6, e3, s9, i5, n7, o7, a8, r6 = 0) {
    let l9 = this._root, h6 = 0, c9 = 0, u4 = 0;
    for (; null !== l9; ) {
      if (l9.depth >= r6 && (l9.count += 1, l9.xTotal += s9, l9.yTotal += i5, l9.xGeohashTotal += n7, l9.yGeohashTotal += o7, l9.referenceId = e3, this._updateStatisticsCursor(t6, l9, 1)), h6 >= a8)
        return void l9.add(e3);
      const d9 = Math.ceil((h6 + 1) / 2), f9 = Math.floor((h6 + 1) / 2), x4 = 1 - h6 % 2, m6 = 30 - (3 * d9 + 2 * f9), g6 = 30 - (2 * d9 + 3 * f9), y6 = (n7 & 7 * x4 + 3 * (1 - x4) << m6) >> m6, p4 = (o7 & 3 * x4 + 7 * (1 - x4) << g6) >> g6, _4 = y6 + p4 * (8 * x4 + 4 * (1 - x4));
      c9 = c9 << 3 * x4 + 2 * (1 - x4) | y6, u4 = u4 << 2 * x4 + 3 * (1 - x4) | p4, null == l9.children[_4] && (l9.children[_4] = this._acquire(c9, u4, h6 + 1)), h6 += 1, l9 = l9.children[_4];
    }
  }
  remove(t6, e3) {
    const s9 = c5.fromOptimizedFeatures([t6], this._serviceInfo).getCursor();
    s9.next();
    const i5 = s9.readGeometry();
    if (!i5)
      return;
    const [n7, o7] = i5.coords, a8 = t6.geohashX, r6 = t6.geohashY;
    this.removeCursor(s9, n7, o7, a8, r6, e3);
  }
  removeCursor(t6, e3, s9, i5, n7, o7) {
    let a8 = this._root, r6 = 0;
    for (; null !== a8; ) {
      if (a8.count -= 1, a8.xTotal -= e3, a8.yTotal -= s9, a8.xGeohashTotal -= i5, a8.yGeohashTotal -= n7, this._updateStatisticsCursor(t6, a8, -1), r6 >= o7)
        return void a8.remove(t6.getDisplayId());
      const l9 = Math.ceil((r6 + 1) / 2), h6 = Math.floor((r6 + 1) / 2), c9 = 1 - r6 % 2, u4 = 30 - (3 * l9 + 2 * h6), d9 = 30 - (2 * l9 + 3 * h6), f9 = ((i5 & 7 * c9 + 3 * (1 - c9) << u4) >> u4) + ((n7 & 3 * c9 + 7 * (1 - c9) << d9) >> d9) * (8 * c9 + 4 * (1 - c9)), x4 = a8.children[f9];
      1 === (x4 == null ? void 0 : x4.count) && (this._release(x4), a8.children[f9] = null), r6 += 1, a8 = x4;
    }
  }
  forEach(t6) {
    let e3 = this._root;
    for (; null !== e3; ) {
      const s9 = this._linkChildren(e3) || e3.next;
      t6(e3), e3 = s9;
    }
  }
  find(t6, e3, s9) {
    return this._root.find(t6, e3, s9, 0, 0, 0);
  }
  findIf(t6) {
    let e3 = null;
    return this.forEach((s9) => {
      t6(s9) && (e3 = s9);
    }), e3;
  }
  findAllIf(t6) {
    const e3 = [];
    return this.forEach((s9) => {
      t6(s9) && e3.push(s9);
    }), e3;
  }
  findSingleOccupancyNode(t6, e3, s9, i5, n7) {
    let o7 = this._root;
    for (; null !== o7; ) {
      const a8 = o7.depth, r6 = o7.xNode, l9 = o7.yNode, h6 = 1 - a8 % 2, c9 = o7.xGeohashTotal / o7.count, u4 = o7.yGeohashTotal / o7.count;
      if (1 === o7.count && t6 < c9 && c9 <= s9 && e3 < u4 && u4 <= i5)
        return o7;
      if (a8 >= n7) {
        o7 = o7.next;
        continue;
      }
      const d9 = Math.ceil((a8 + 1) / 2), f9 = Math.floor((a8 + 1) / 2), x4 = 30 - (3 * d9 + 2 * f9), m6 = 30 - (2 * d9 + 3 * f9), g6 = ~((1 << x4) - 1), y6 = ~((1 << m6) - 1), p4 = (t6 & g6) >> x4, _4 = (e3 & y6) >> m6, v6 = (s9 & g6) >> x4, M2 = (i5 & y6) >> m6, T5 = r6 << 3 * h6 + 2 * (1 - h6), b6 = l9 << 2 * h6 + 3 * (1 - h6), k3 = T5 + 8 * h6 + 4 * (1 - h6), N = b6 + 4 * h6 + 8 * (1 - h6), I2 = Math.max(T5, p4), C = Math.max(b6, _4), G4 = Math.min(k3, v6), L3 = Math.min(N, M2);
      let S3 = null, w4 = null;
      for (let t7 = C; t7 <= L3; t7++)
        for (let e4 = I2; e4 <= G4; e4++) {
          const s10 = e4 - T5 + (t7 - b6) * (8 * h6 + 4 * (1 - h6)), i6 = o7.children[s10];
          i6 && (S3 || (S3 = i6, S3.next = o7.next), w4 && (w4.next = i6), w4 = i6, i6.next = o7.next);
        }
      o7 = S3 || o7.next;
    }
    return null;
  }
  getRegionDisplayIds(t6) {
    let e3 = this._root;
    const { bounds: s9, geohashBounds: i5, level: n7 } = t6, [o7, a8, r6, l9] = s9, h6 = [];
    for (; null !== e3; ) {
      const t7 = e3.depth, s10 = e3.xNode, c9 = e3.yNode;
      if (t7 >= n7) {
        const t8 = e3.xTotal / e3.count, s11 = e3.yTotal / e3.count;
        t8 >= o7 && t8 <= r6 && s11 >= a8 && s11 <= l9 && e3.displayIds.forEach((t9) => h6.push(t9)), e3 = e3.next;
        continue;
      }
      const u4 = Math.ceil((t7 + 1) / 2), d9 = Math.floor((t7 + 1) / 2), f9 = 1 - t7 % 2, x4 = 30 - (3 * u4 + 2 * d9), m6 = 30 - (2 * u4 + 3 * d9), g6 = ~((1 << x4) - 1), y6 = ~((1 << m6) - 1), p4 = (i5.xLL & g6) >> x4, _4 = (i5.yLL & y6) >> m6, v6 = (i5.xTR & g6) >> x4, M2 = (i5.yTR & y6) >> m6, T5 = s10 << 3 * f9 + 2 * (1 - f9), b6 = c9 << 2 * f9 + 3 * (1 - f9), k3 = T5 + 8 * f9 + 4 * (1 - f9), N = b6 + 4 * f9 + 8 * (1 - f9), I2 = Math.max(T5, p4), C = Math.max(b6, _4), G4 = Math.min(k3, v6), L3 = Math.min(N, M2);
      let S3 = null, w4 = null;
      for (let i6 = C; i6 <= L3; i6++)
        for (let t8 = I2; t8 <= G4; t8++) {
          const s11 = t8 - T5 + (i6 - b6) * (8 * f9 + 4 * (1 - f9)), n8 = e3.children[s11];
          n8 && (S3 || (S3 = n8, S3.next = e3.next), w4 && (w4.next = n8), w4 = n8, n8.next = e3.next);
        }
      e3 = S3 || e3.next;
    }
    return h6;
  }
  getRegionStatistics(t6) {
    let e3 = this._root, s9 = 0, i5 = 0, n7 = 0;
    const o7 = {}, { bounds: a8, geohashBounds: r6, level: l9 } = t6, [h6, c9, u4, d9] = a8;
    let f9 = 0;
    for (; null !== e3; ) {
      const t7 = e3.depth, a9 = e3.xNode, x4 = e3.yNode;
      if (t7 >= l9) {
        const t8 = e3.xTotal / e3.count, a10 = e3.yTotal / e3.count;
        t8 > h6 && t8 <= u4 && a10 > c9 && a10 <= d9 && (s9 += e3.count, i5 += e3.xTotal, n7 += e3.yTotal, 1 === e3.count && (f9 = e3.referenceId), this._aggregateStatistics(o7, e3.statistics)), e3 = e3.next;
        continue;
      }
      const m6 = Math.ceil((t7 + 1) / 2), g6 = Math.floor((t7 + 1) / 2), y6 = 1 - t7 % 2, p4 = 30 - (3 * m6 + 2 * g6), _4 = 30 - (2 * m6 + 3 * g6), v6 = ~((1 << p4) - 1), M2 = ~((1 << _4) - 1), T5 = (r6.xLL & v6) >> p4, b6 = (r6.yLL & M2) >> _4, k3 = (r6.xTR & v6) >> p4, N = (r6.yTR & M2) >> _4, I2 = a9 << 3 * y6 + 2 * (1 - y6), C = x4 << 2 * y6 + 3 * (1 - y6), G4 = I2 + 8 * y6 + 4 * (1 - y6), L3 = C + 4 * y6 + 8 * (1 - y6), S3 = Math.max(I2, T5), w4 = Math.max(C, b6), R4 = Math.min(G4, k3), F5 = Math.min(L3, N);
      let j5 = null, z = null;
      for (let r7 = w4; r7 <= F5; r7++)
        for (let t8 = S3; t8 <= R4; t8++) {
          const a10 = t8 - I2 + (r7 - C) * (8 * y6 + 4 * (1 - y6)), l10 = e3.children[a10];
          if (l10) {
            if (r7 !== w4 && r7 !== F5 && t8 !== S3 && t8 !== R4) {
              const t9 = l10.xTotal / l10.count, e4 = l10.yTotal / l10.count;
              t9 > h6 && t9 <= u4 && e4 > c9 && e4 <= d9 && (s9 += l10.count, i5 += l10.xTotal, n7 += l10.yTotal, 1 === l10.count && (f9 = l10.referenceId), this._aggregateStatistics(o7, l10.statistics));
              continue;
            }
            j5 || (j5 = l10, j5.next = e3.next), z && (z.next = l10), z = l10, l10.next = e3.next;
          }
        }
      e3 = j5 || e3.next;
    }
    return { count: s9, attributes: this.normalizeStatistics(o7, s9), xTotal: i5, yTotal: n7, referenceId: f9 };
  }
  getBins(t6) {
    const e3 = [], { geohashBounds: s9, level: i5 } = t6;
    let n7 = this._root;
    for (; null !== n7; ) {
      const t7 = n7.depth, o7 = n7.xNode, a8 = n7.yNode;
      if (t7 >= i5) {
        e3.push(n7), n7 = n7.next;
        continue;
      }
      const r6 = Math.ceil((t7 + 1) / 2), l9 = Math.floor((t7 + 1) / 2), h6 = 1 - t7 % 2, c9 = 30 - (3 * r6 + 2 * l9), u4 = 30 - (2 * r6 + 3 * l9), d9 = ~((1 << c9) - 1), f9 = ~((1 << u4) - 1), x4 = (s9.xLL & d9) >> c9, m6 = (s9.yLL & f9) >> u4, g6 = (s9.xTR & d9) >> c9, y6 = (s9.yTR & f9) >> u4, p4 = o7 << 3 * h6 + 2 * (1 - h6), _4 = a8 << 2 * h6 + 3 * (1 - h6), v6 = p4 + 8 * h6 + 4 * (1 - h6), M2 = _4 + 4 * h6 + 8 * (1 - h6), T5 = Math.max(p4, x4), b6 = Math.max(_4, m6), k3 = Math.min(v6, g6), N = Math.min(M2, y6);
      let I2 = null, C = null;
      for (let e4 = b6; e4 <= N; e4++)
        for (let t8 = T5; t8 <= k3; t8++) {
          const s10 = t8 - p4 + (e4 - _4) * (8 * h6 + 4 * (1 - h6)), i6 = n7.children[s10];
          i6 && (I2 || (I2 = i6, I2.next = n7.next), C && (C.next = i6), C = i6, i6.next = n7.next);
        }
      n7 = I2 || n7.next;
    }
    return e3;
  }
  _linkChildren(t6) {
    let e3 = null, s9 = null;
    for (let i5 = 0; i5 <= t6.children.length; i5++) {
      const n7 = t6.children[i5];
      n7 && (e3 || (e3 = n7, e3.next = t6.next), s9 && (s9.next = n7), s9 = n7, n7.next = t6.next);
    }
    return e3;
  }
  _updateStatisticsCursor(t6, e3, s9) {
    var _a, _b;
    for (const i5 of this._statisticFields) {
      const n7 = i5.name, o7 = i5.inField ? t6.readAttribute(i5.inField) : t6.getComputedNumericAtIndex(i5.inFieldIndex);
      switch (i5.statisticType) {
        case "min": {
          if (isNaN(o7))
            break;
          if (!e3.statistics[n7]) {
            e3.statistics[n7] = { value: o7 };
            break;
          }
          const t7 = e3.statistics[n7].value;
          e3.statistics[n7].value = Math.min(t7, o7);
          break;
        }
        case "max": {
          if (isNaN(o7))
            break;
          if (!e3.statistics[n7]) {
            e3.statistics[n7] = { value: o7 };
            break;
          }
          const t7 = e3.statistics[n7].value;
          e3.statistics[n7].value = Math.max(t7, o7);
          break;
        }
        case "count":
          break;
        case "sum":
        case "avg": {
          e3.statistics[n7] || (e3.statistics[n7] = { value: 0, nanCount: 0 });
          const t7 = e3.statistics[n7].value, i6 = (_a = e3.statistics[n7].nanCount) != null ? _a : 0;
          null == o7 || isNaN(o7) ? e3.statistics[n7].nanCount = i6 + s9 : e3.statistics[n7].value = t7 + s9 * o7;
          break;
        }
        case "avg_angle": {
          e3.statistics[n7] || (e3.statistics[n7] = { x: 0, y: 0, nanCount: 0 });
          const t7 = e3.statistics[n7].x, i6 = e3.statistics[n7].y, a8 = (_b = e3.statistics[n7].nanCount) != null ? _b : 0, r6 = Math.PI / 180;
          null == o7 || isNaN(o7) ? e3.statistics[n7].nanCount = a8 + s9 : (e3.statistics[n7].x = t7 + s9 * Math.cos(o7 * r6), e3.statistics[n7].y = i6 + s9 * Math.sin(o7 * r6));
          break;
        }
        case "mode": {
          e3.statistics[n7] || (e3.statistics[n7] = {});
          const t7 = e3.statistics[n7][o7] || 0;
          e3.statistics[n7][o7] = t7 + s9;
          break;
        }
      }
    }
  }
  _aggregateStatistics(t6, e3) {
    for (const s9 of this._statisticFields) {
      const i5 = s9.name;
      switch (s9.statisticType) {
        case "min": {
          if (!t6[i5]) {
            t6[i5] = { value: e3[i5].value };
            break;
          }
          const s10 = t6[i5].value;
          t6[i5].value = Math.min(s10, e3[i5].value);
          break;
        }
        case "max": {
          if (!t6[i5]) {
            t6[i5] = { value: e3[i5].value };
            break;
          }
          const s10 = t6[i5].value;
          t6[i5].value = Math.max(s10, e3[i5].value);
          break;
        }
        case "count":
          break;
        case "sum":
        case "avg":
        case "avg_angle":
        case "mode":
          t6[i5] || (t6[i5] = {});
          for (const s10 in e3[i5]) {
            const n7 = t6[i5][s10] || 0;
            t6[i5][s10] = n7 + e3[i5][s10];
          }
      }
    }
  }
  normalizeStatistics(t6, e3) {
    const s9 = {};
    for (const i5 of this._statisticFields) {
      const n7 = i5.name;
      switch (i5.statisticType) {
        case "min":
        case "max": {
          const i6 = t6[n7];
          if (!e3 || !i6)
            break;
          s9[n7] = i6.value;
          break;
        }
        case "count":
          if (!e3)
            break;
          s9[n7] = e3;
          break;
        case "sum": {
          if (!e3)
            break;
          const { value: i6, nanCount: o7 } = t6[n7];
          if (!(e3 - o7))
            break;
          s9[n7] = i6;
          break;
        }
        case "avg": {
          if (!e3)
            break;
          const { value: i6, nanCount: o7 } = t6[n7];
          if (!(e3 - o7))
            break;
          s9[n7] = i6 / (e3 - o7);
          break;
        }
        case "avg_angle": {
          if (!e3)
            break;
          const { x: i6, y: o7, nanCount: a8 } = t6[n7];
          if (!(e3 - a8))
            break;
          const r6 = i6 / (e3 - a8), l9 = o7 / (e3 - a8), h6 = 180 / Math.PI, c9 = Math.atan2(l9, r6) * h6;
          s9[n7] = c9;
          break;
        }
        case "mode": {
          const e4 = t6[n7];
          let i6 = 0, o7 = 0, a8 = null;
          for (const t7 in e4) {
            const s10 = e4[t7];
            s10 === i6 ? o7 += 1 : s10 > i6 && (i6 = s10, o7 = 1, a8 = t7);
          }
          s9[n7] = "null" === a8 || o7 > 1 ? null : a8;
          break;
        }
      }
    }
    return s9;
  }
};
var d7 = class {
  constructor(t6, e3, s9, i5) {
    this.count = 0, this.xTotal = 0, this.yTotal = 0, this.statistics = {}, this.displayId = 0, this.referenceId = 0, this.displayIds = /* @__PURE__ */ new Set(), this.next = null, this.depth = 0, this.xNode = 0, this.yNode = 0, this.xGeohashTotal = 0, this.yGeohashTotal = 0, this._tree = t6, this.children = new Array(32);
    for (let n7 = 0; n7 < this.children.length; n7++)
      this.children[n7] = null;
    this.xNode = e3, this.yNode = s9, this.depth = i5;
  }
  realloc(t6, e3, s9) {
    for (let i5 = 0; i5 < this.children.length; i5++)
      this.children[i5] = null;
    return this.xNode = t6, this.yNode = e3, this.depth = s9, this.next = null, this.xGeohashTotal = 0, this.yGeohashTotal = 0, this.displayId = 0, this.referenceId = 0, this.xTotal = 0, this.yTotal = 0, this.count = 0, this.statistics = {}, this.displayIds.clear(), this;
  }
  get id() {
    return `${this.xNode}.${this.yNode}`;
  }
  add(t6) {
    this.displayIds.add(t6);
  }
  remove(t6) {
    this.displayIds.delete(t6);
  }
  getAttributes() {
    const t6 = this._tree.normalizeStatistics(this.statistics, this.count);
    return t6.referenceId = null, t6.aggregateId = this.id, t6.aggregateCount = this.count, t6;
  }
  getGeometry(t6, s9) {
    const i5 = this.getLngLatBounds(), [r6, c9, u4, d9] = i5, f9 = g3({ rings: [[[r6, c9], [r6, d9], [u4, d9], [u4, c9], [r6, c9]]] }, k.WGS84, t6), x4 = J(new t3(), f9, false, false);
    if (r(s9)) {
      return at(new t3(), x4, false, false, "esriGeometryPolygon", s9, false, false);
    }
    return x4;
  }
  getGeometryCentroid(t6, s9) {
    const i5 = this.getLngLatBounds(), [o7, c9, u4, d9] = i5, f9 = g3({ x: (o7 + u4) / 2, y: (c9 + d9) / 2 }, k.WGS84, t6), x4 = _(new t3(), f9);
    if (r(s9)) {
      return at(new t3(), x4, false, false, "esriGeometryPoint", s9, false, false);
    }
    return x4;
  }
  getLngLatBounds() {
    const t6 = this.depth, e3 = Math.ceil(t6 / 2), s9 = Math.floor(t6 / 2), n7 = 30 - (3 * e3 + 2 * s9), o7 = 30 - (2 * e3 + 3 * s9), a8 = this.xNode << n7, r6 = this.yNode << o7;
    return X2({ geohashX: a8, geohashY: r6 }, this.depth);
  }
  find(t6, e3, s9, i5, n7, o7) {
    if (i5 >= s9)
      return this;
    const a8 = 1 - i5 % 2, r6 = 3 * a8 + 2 * (1 - a8), l9 = 2 * a8 + 3 * (1 - a8), h6 = 30 - n7 - r6, c9 = 30 - o7 - l9, u4 = ((t6 & 7 * a8 + 3 * (1 - a8) << h6) >> h6) + ((e3 & 3 * a8 + 7 * (1 - a8) << c9) >> c9) * (8 * a8 + 4 * (1 - a8)), d9 = this.children[u4];
    return null == d9 ? null : d9.find(t6, e3, s9, i5 + 1, n7 + r6, o7 + l9);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/BinStore.js
var G3 = s.getLogger("esri.view.2d.layers.features.support.BinStore");
var R2 = 12;
var L2 = 64;
var T2 = 5;
function A(e3) {
  return 57.29577951308232 * e3;
}
var D2 = class extends c4 {
  constructor(t6, s9, r6, i5) {
    super(t6, r6), this.type = "bin", this.events = new n2(), this.objectIdField = "aggregateId", this.featureAdapter = u, this._geohashLevel = T2, this._geohashBuf = [], this._serviceInfo = i5, this.geometryInfo = t6.geometryInfo, this._spatialReference = s9, this._projectionSupportCheck = f4(s9, k.WGS84), this._bitsets.geohash = r6.getBitset(r6.createBitset()), this._bitsets.inserted = r6.getBitset(r6.createBitset());
  }
  destroy() {
    this._tree && this._tree.destroy();
  }
  get featureSpatialReference() {
    return this._spatialReference;
  }
  get fields() {
    return this._fields;
  }
  async updateSchema(e3, t6) {
    const r6 = this._schema;
    try {
      await super.updateSchema(e3, t6), await this._projectionSupportCheck;
    } catch (n7) {
    }
    this._fields = this._schema.params.fields;
    const i5 = m2(r6, t6);
    t6 && (!t(i5) || e3.source || e3.storage.filters) ? ((a2(i5, "params.fields") || a2(i5, "params") || !this._tree || e3.source) && (this._tree && this._tree.destroy(), this._tree = new u2(this._statisticFields, this._serviceInfo), this._tree.onRelease = (e4) => e4.displayId && this._storage.releaseDisplayId(e4.displayId), this._geohashLevel = this._schema.params.fixedBinLevel, this._rebuildTree(), has("esri-2d-update-debug") && G3.info("Aggregate mesh needs update due to tree changing")), has("esri-2d-update-debug") && G3.info("Aggregate mesh needs update due to tree changing"), e3.targets[t6.name] = true, e3.mesh = false) : r6 && (e3.mesh = true);
  }
  clear() {
    this._rebuildTree();
  }
  sweepFeatures(e3, t6) {
    this._bitsets.inserted.forEachSet((s9) => {
      if (!e3.has(s9)) {
        const e4 = t6.lookupByDisplayIdUnsafe(s9);
        this._remove(e4);
      }
    });
  }
  sweepAggregates(e3, t6, s9) {
  }
  onTileData(e3, t6, r6, i5, o7 = true) {
    if (!this._schema || t(t6.addOrUpdate))
      return t6;
    this.events.emit("changed");
    const a8 = this._getTransforms(e3, this._spatialReference);
    {
      const e4 = t6.addOrUpdate.getCursor();
      for (; e4.next(); )
        this._update(e4, i5);
    }
    if (t6.status.mesh || !o7)
      return t6;
    const h6 = new Array();
    this._getBinsForTile(h6, e3, a8, r6), t6.addOrUpdate = c5.fromOptimizedFeatures(h6, { ...this._serviceInfo, geometryType: "esriGeometryPolygon" }), t6.addOrUpdate.attachStorage(r6), t6.end = true, t6.isRepush || (t6.clear = true);
    {
      const s9 = t6.addOrUpdate.getCursor();
      for (; s9.next(); ) {
        const t7 = s9.getDisplayId();
        this._bitsets.computed.unset(t7), this.setComputedAttributes(r6, s9, t7, e3.scale);
      }
    }
    return t6;
  }
  forEachBin(e3) {
    this._tree.forEach(e3);
  }
  forEach(e3) {
    this._tree.forEach((t6) => {
      if (t6.depth !== this._geohashLevel)
        return;
      const s9 = this._toFeatureJSON(t6), r6 = c5.fromFeatures([s9], { objectIdField: this.objectIdField, globalIdField: null, geometryType: this.geometryInfo.geometryType, fields: this.fields }).getCursor();
      r6.next(), e3(r6);
    });
  }
  forEachInBounds(e3, t6) {
  }
  forEachBounds(e3, t6, r6) {
    const { hasM: i5, hasZ: o7 } = this.geometryInfo;
    for (const a8 of e3) {
      const e4 = gt([0, 0, 0, 0], a8.readGeometry(), o7, i5);
      t(e4) || t6(G(r6, e4));
    }
  }
  toArray() {
    const e3 = [];
    return this.forEach((t6) => e3.push(t6)), e3;
  }
  onTileUpdate(e3) {
  }
  getAggregate(e3) {
    const t6 = s6(e3, true), s9 = this._tree.findIf((e4) => e4.displayId === t6);
    return o(s9, (e4) => this._toFeatureJSON(e4));
  }
  getAggregates() {
    return this._tree.findAllIf((e3) => e3.depth === this._geohashLevel).map(this._toFeatureJSON.bind(this));
  }
  getDisplayId(e3) {
    const t6 = this._tree.findIf((t7) => t7.id === e3);
    return o(t6, (e4) => e4.displayId);
  }
  getFeatureDisplayIdsForAggregate(e3) {
    const t6 = this._tree.findIf((t7) => t7.id === e3);
    return b(t6, [], (e4) => Array.from(e4.displayIds));
  }
  getDisplayIdForReferenceId(e3) {
    const t6 = this._tree.findIf((t7) => 1 === t7.displayIds.size && t7.displayIds.has(e3));
    return o(t6, (e4) => e4.displayId);
  }
  _toFeatureJSON(e3) {
    const t6 = this._spatialReference;
    return { displayId: e3.displayId, attributes: e3.getAttributes(), geometry: rt(e3.getGeometry(t6), "esriGeometryPolygon", false, false), centroid: null };
  }
  _rebuildTree() {
    this._bitsets.computed.clear(), this._bitsets.inserted.clear(), this._tree && this._tree.clear();
  }
  _remove(e3) {
    const t6 = e3.getDisplayId(), s9 = e3.getXHydrated(), r6 = e3.getYHydrated(), i5 = this._geohashBuf[2 * t6], o7 = this._geohashBuf[2 * t6 + 1];
    this._bitsets.inserted.has(t6) && (this._bitsets.inserted.unset(t6), this._tree.removeCursor(e3, s9, r6, i5, o7, this._geohashLevel));
  }
  _update(e3, t6) {
    const s9 = e3.getDisplayId(), r6 = this._bitsets.inserted, i5 = t6.isVisible(s9);
    if (i5 === r6.has(s9))
      return;
    if (!i5)
      return void this._remove(e3);
    const o7 = e3.getXHydrated(), a8 = e3.getYHydrated();
    if (!this._setGeohash(s9, o7, a8))
      return;
    const h6 = this._geohashBuf[2 * s9], n7 = this._geohashBuf[2 * s9 + 1];
    this._tree.insertCursor(e3, s9, o7, a8, h6, n7, this._geohashLevel), r6.set(s9);
  }
  _setGeohash(e3, t6, s9) {
    if (this._bitsets.geohash.has(e3))
      return true;
    const r6 = this._geohashBuf;
    if (this._spatialReference.isWebMercator) {
      const i5 = A(t6 / s3.radius), o7 = i5 - 360 * Math.floor((i5 + 180) / 360), a8 = A(Math.PI / 2 - 2 * Math.atan(Math.exp(-s9 / s3.radius)));
      b5(r6, e3, a8, o7, R2);
    } else {
      const i5 = g3({ x: t6, y: s9 }, this._spatialReference, k.WGS84);
      if (!i5)
        return false;
      b5(r6, e3, i5.y, i5.x, R2);
    }
    return this._bitsets.geohash.set(e3), true;
  }
  _getBinsForTile(e3, t6, s9, r6) {
    try {
      const i5 = this._getGeohashBounds(t6), o7 = this._tree.getBins(i5);
      for (const t7 of o7) {
        t7.displayId || (t7.displayId = r6.createDisplayId(true));
        let i6 = null;
        const o8 = t7.getGeometry(this._spatialReference, s9.tile);
        o8 || (i6 = t7.getGeometryCentroid(this._spatialReference, s9.tile));
        const a8 = new s5(o8, t7.getAttributes(), i6);
        a8.objectId = t7.id, a8.displayId = t7.displayId, e3.push(a8);
      }
    } catch (i5) {
      return void G3.error("Unable to get bins for tile", t6.key.id);
    }
  }
  _getGeohash(e3, t6, s9) {
    const r6 = { geohashX: 0, geohashY: 0 };
    return Y2(r6, t6, e3, s9), r6;
  }
  _getGeohashBounds(e3) {
    const t6 = this._getGeohashLevel(e3.key.level), s9 = [e3.extent.xmin, e3.extent.ymin, e3.extent.xmax, e3.extent.ymax], r6 = v.fromExtent(w.fromBounds(s9, this._spatialReference)), i5 = g3(r6, this._spatialReference, k.WGS84, { densificationStep: e3.resolution * L2 }), o7 = J(new t3(), i5, false, false), a8 = o7.coords.filter((e4, t7) => !(t7 % 2)), h6 = o7.coords.filter((e4, t7) => t7 % 2), n7 = Math.min(...a8), d9 = Math.min(...h6), l9 = Math.max(...a8), p4 = Math.max(...h6), g6 = this._getGeohash(n7, d9, t6), c9 = this._getGeohash(l9, p4, t6);
    return { bounds: s9, geohashBounds: { xLL: g6.geohashX, yLL: g6.geohashY, xTR: c9.geohashX, yTR: c9.geohashY }, level: t6 };
  }
  _getGeohashLevel(e3) {
    return this._schema.params.fixedBinLevel;
  }
  _getTransforms(e3, t6) {
    const s9 = { originPosition: "upperLeft", scale: [e3.resolution, e3.resolution], translate: [e3.bounds[0], e3.bounds[3]] }, r6 = R(t6);
    if (!r6)
      return { tile: s9, left: null, right: null };
    const [i5, o7] = r6.valid;
    return { tile: s9, left: { ...s9, translate: [o7, e3.bounds[3]] }, right: { ...s9, translate: [i5 - o7 + e3.bounds[0], e3.bounds[3]] } };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/ClusterStore.js
var F3 = 12;
var w3 = 64;
var S2 = 1;
var V = class extends o2 {
  constructor(e3, t6, s9, r6, o7) {
    super(new t3([], [t6, s9]), r6, null, e3), this.geohashBoundsInfo = o7;
  }
  get count() {
    return this.attributes.cluster_count;
  }
  static create(e3, t6, s9, r6, o7, a8, i5, h6) {
    const n7 = new V(t6, s9, r6, a8, i5);
    return n7.displayId = e3.createDisplayId(true), n7.referenceId = h6, n7.tileLevel = o7, n7;
  }
  update(e3, t6, s9, r6, o7, a8) {
    return this.geometry.coords[0] = e3, this.geometry.coords[1] = t6, this.tileLevel = s9, this.attributes = r6, this.geohashBoundsInfo = o7, this.referenceId = null, this.referenceId = a8, this;
  }
  toJSON() {
    return { attributes: { ...this.attributes, aggregateId: this.objectId, referenceId: 1 === this.attributes.cluster_count ? this.referenceId : null }, geometry: { x: this.geometry.coords[0], y: this.geometry.coords[1] } };
  }
};
function T3(e3) {
  return 57.29577951308232 * e3;
}
var D3 = class extends c4 {
  constructor(t6, s9, r6, o7) {
    super(t6, r6), this.type = "cluster", this.events = new n2(), this.objectIdField = "aggregateId", this.featureAdapter = u, this._geohashLevel = 0, this._tileLevel = 0, this._aggregateValueRanges = {}, this._aggregateValueRangesChanged = false, this._geohashBuf = [], this._clusters = /* @__PURE__ */ new Map(), this._tiles = /* @__PURE__ */ new Map(), this._serviceInfo = o7, this.geometryInfo = t6.geometryInfo, this._spatialReference = s9, this._projectionSupportCheck = f4(s9, k.WGS84), this._bitsets.geohash = r6.getBitset(r6.createBitset()), this._bitsets.inserted = r6.getBitset(r6.createBitset());
  }
  destroy() {
    this._tree.destroy();
  }
  get featureSpatialReference() {
    return this._spatialReference;
  }
  get fields() {
    return this._fields;
  }
  async updateSchema(e3, s9) {
    const r6 = this._schema;
    try {
      await super.updateSchema(e3, s9), await this._projectionSupportCheck;
    } catch (n7) {
    }
    this._fields = this._schema.params.fields;
    const h6 = m2(r6, s9);
    s9 && (!t(h6) || e3.source || e3.storage.filters) ? ((a2(h6, "params.fields") || !this._tree || e3.source) && (this._tree && this._tree.destroy(), this._tree = new u2(this._statisticFields, this._serviceInfo), this._rebuildTree(), has("esri-2d-update-debug") && console.debug("Aggregate mesh needs update due to tree changing")), has("esri-2d-update-debug") && console.debug("Applying Update - ClusterStore:", h6), e3.targets[s9.name] = true, e3.mesh = false, this._aggregateValueRanges = {}) : r6 && (e3.mesh = true);
  }
  clear() {
    this._rebuildTree();
  }
  sweepFeatures(e3, t6) {
    this._bitsets.inserted.forEachSet((s9) => {
      if (!e3.has(s9)) {
        const e4 = t6.lookupByDisplayIdUnsafe(s9);
        this._remove(e4);
      }
    });
  }
  sweepAggregates(e3, t6, s9) {
    this._clusters.forEach((r6, o7) => {
      r6 && r6.tileLevel !== s9 && (e3.releaseDisplayId(r6.displayId), t6.unsetAttributeData(r6.displayId), this._clusters.delete(o7));
    });
  }
  onTileData(e3, s9, r6, o7, a8 = true) {
    if (!this._schema || t(s9.addOrUpdate))
      return s9;
    this.events.emit("changed");
    const i5 = this._getTransforms(e3, this._spatialReference);
    {
      const e4 = s9.addOrUpdate.getCursor();
      for (; e4.next(); )
        this._update(e4, o7);
    }
    if (s9.status.mesh || !a8)
      return s9;
    const h6 = new Array(), n7 = this._schema.params.clusterRadius;
    this._getClustersForTile(h6, e3, n7, r6, i5), s9.addOrUpdate = c5.fromOptimizedFeatures(h6, this._serviceInfo), s9.addOrUpdate.attachStorage(r6), s9.clear = true, s9.end = true;
    {
      const t6 = s9.addOrUpdate.getCursor();
      for (; t6.next(); ) {
        const s10 = t6.getDisplayId();
        this._bitsets.computed.unset(s10), this.setComputedAttributes(r6, t6, s10, e3.scale);
      }
    }
    return this._aggregateValueRangesChanged && s9.end && (this.events.emit("valueRangesChanged", { valueRanges: this._aggregateValueRanges }), this._aggregateValueRangesChanged = false), s9;
  }
  onTileUpdate({ added: e3, removed: t6 }) {
    if (e3.length) {
      const t7 = e3[0].level;
      this._tileLevel = t7, this._setGeohashLevel(t7);
    }
    if (!this._schema)
      return;
    const s9 = this._schema.params.clusterRadius;
    t6.forEach((e4) => {
      this._tiles.delete(e4.key.id), this._markTileClustersForDeletion(e4, s9);
    });
  }
  getAggregate(e3) {
    for (const t6 of this._clusters.values())
      if (((t6 == null ? void 0 : t6.displayId) & n4) == (e3 & n4))
        return t6.toJSON();
    return null;
  }
  getAggregates() {
    const e3 = [];
    for (const t6 of this._clusters.values())
      (t6 == null ? void 0 : t6.tileLevel) === this._tileLevel && e3.push(t6.toJSON());
    return e3;
  }
  getDisplayId(e3) {
    const t6 = this._clusters.get(e3);
    return t6 ? t6.displayId : null;
  }
  getFeatureDisplayIdsForAggregate(e3) {
    const t6 = this._clusters.get(e3);
    return t6 ? this._tree.getRegionDisplayIds(t6.geohashBoundsInfo) : [];
  }
  getDisplayIdForReferenceId(e3) {
    for (const t6 of this._clusters.values())
      if ((t6 == null ? void 0 : t6.referenceId) === e3)
        return t6.displayId;
    return null;
  }
  getAggregateValueRanges() {
    return this._aggregateValueRanges;
  }
  forEach(e3) {
    this._clusters.forEach((t6) => {
      if (!t6)
        return;
      const s9 = t6.toJSON(), r6 = c5.fromFeatures([s9], { objectIdField: this.objectIdField, globalIdField: null, geometryType: this.geometryInfo.geometryType, fields: this.fields }).getCursor();
      r6.next(), e3(r6);
    });
  }
  forEachInBounds(e3, t6) {
  }
  forEachBounds(e3, s9, r6) {
    const { hasM: o7, hasZ: a8 } = this.geometryInfo;
    for (const i5 of e3) {
      const e4 = gt([0, 0, 0, 0], i5.readGeometry(), a8, o7);
      t(e4) || s9(G(r6, e4));
    }
  }
  toArray() {
    const e3 = [];
    return this.forEach((t6) => e3.push(t6)), e3;
  }
  size() {
    let e3 = 0;
    return this.forEach((t6) => e3++), e3;
  }
  _rebuildTree() {
    this._bitsets.computed.clear(), this._bitsets.inserted.clear(), this._tree && this._tree.clear();
  }
  _remove(e3) {
    const t6 = e3.getDisplayId(), s9 = e3.getXHydrated(), r6 = e3.getYHydrated(), o7 = this._geohashBuf[2 * t6], a8 = this._geohashBuf[2 * t6 + 1];
    this._bitsets.inserted.has(t6) && (this._bitsets.inserted.unset(t6), this._tree.removeCursor(e3, s9, r6, o7, a8, this._geohashLevel));
  }
  _update(e3, t6) {
    const s9 = e3.getDisplayId(), r6 = this._bitsets.inserted, o7 = t6.isVisible(s9);
    if (o7 === r6.has(s9))
      return;
    if (!o7)
      return void this._remove(e3);
    const a8 = e3.getXHydrated(), i5 = e3.getYHydrated();
    if (!this._setGeohash(s9, a8, i5))
      return;
    const h6 = this._geohashBuf[2 * s9], n7 = this._geohashBuf[2 * s9 + 1];
    this._tree.insertCursor(e3, s9, a8, i5, h6, n7, this._geohashLevel), r6.set(s9);
  }
  _setGeohash(e3, t6, s9) {
    if (this._bitsets.geohash.has(e3))
      return true;
    const r6 = this._geohashBuf;
    if (this._spatialReference.isWebMercator) {
      const o7 = T3(t6 / s3.radius), a8 = o7 - 360 * Math.floor((o7 + 180) / 360), i5 = T3(Math.PI / 2 - 2 * Math.atan(Math.exp(-s9 / s3.radius)));
      b5(r6, e3, i5, a8, F3);
    } else {
      const o7 = g3({ x: t6, y: s9 }, this._spatialReference, k.WGS84);
      if (!o7)
        return false;
      b5(r6, e3, o7.y, o7.x, F3);
    }
    return this._bitsets.geohash.set(e3), true;
  }
  _getClustersForTile(e3, o7, a8, i5, h6, n7 = true) {
    const l9 = this._schema.params.clusterPixelBuffer, u4 = 2 * a8, g6 = Math.ceil(2 ** o7.key.level * o3 / u4) + 1, c9 = Math.ceil(l9 / u4) + 0, p4 = Math.ceil(o3 / u4), { row: m6, col: y6 } = o7.key, I2 = y6 * o3, b6 = m6 * o3, R4 = Math.floor(I2 / u4) - c9, M2 = Math.floor(b6 / u4) - c9, x4 = R4 + p4 + 2 * c9, C = M2 + p4 + 2 * c9, j5 = o7.tileInfoView.getLODInfoAt(o7.key.level);
    for (let v6 = R4; v6 <= x4; v6++)
      for (let a9 = M2; a9 <= C; a9++) {
        let l10 = v6;
        j5.wrap && (l10 = v6 < 0 ? v6 + g6 : v6 % g6);
        const u5 = j5.wrap && v6 < 0, c10 = j5.wrap && v6 % g6 !== v6, p5 = this._lookupCluster(i5, j5, o7.key.level, l10, a9, o7);
        if (r(p5)) {
          const o8 = o(h6, (e4) => u5 ? e4.left : c10 ? e4.right : e4.tile);
          if (n7 && t(o8))
            continue;
          if (!p5.count)
            continue;
          if (r(o8) && n7) {
            const t6 = p5.geometry.clone();
            let r6 = p5.attributes;
            t6.coords[0] = w2(o8, t6.coords[0]), t6.coords[1] = M(o8, t6.coords[1]), 1 === p5.count && r(p5.referenceId) && (r6 = { ...p5.attributes, referenceId: p5.referenceId });
            const a10 = new s5(t6, r6);
            a10.displayId = p5.displayId, e3.push(a10);
          }
        }
      }
  }
  _getGeohashLevel(e3) {
    return Math.min(Math.ceil(e3 / 2 + 2), F3);
  }
  _setGeohashLevel(e3) {
    const t6 = this._getGeohashLevel(e3), s9 = (Math.floor(t6 / S2) + 1) * S2 - 1;
    if (this._geohashLevel !== s9)
      return this._geohashLevel = s9, this._rebuildTree(), void this._bitsets.geohash.clear();
  }
  _getTransforms(e3, t6) {
    const s9 = { originPosition: "upperLeft", scale: [e3.resolution, e3.resolution], translate: [e3.bounds[0], e3.bounds[3]] }, r6 = R(t6);
    if (!r6)
      return { tile: s9, left: null, right: null };
    const [o7, a8] = r6.valid;
    return { tile: s9, left: { ...s9, translate: [a8, e3.bounds[3]] }, right: { ...s9, translate: [o7 - a8 + e3.bounds[0], e3.bounds[3]] } };
  }
  _getClusterId(e3, t6, s9) {
    return (15 & e3) << 28 | (16383 & t6) << 14 | 16383 & s9;
  }
  _markForDeletion(e3, t6, s9) {
    const r6 = this._getClusterId(e3, t6, s9);
    this._clusters.delete(r6);
  }
  _getClusterBounds(e3, t6, s9) {
    const r6 = this._schema.params.clusterRadius, o7 = 2 * r6;
    let a8 = s9 % 2 ? t6 * o7 : t6 * o7 - r6;
    const i5 = s9 * o7;
    let h6 = a8 + o7;
    const n7 = i5 - o7, l9 = 2 ** e3.level * o3;
    e3.wrap && a8 < 0 && (a8 = 0), e3.wrap && h6 > l9 && (h6 = l9);
    const u4 = a8 / o3, g6 = i5 / o3, c9 = h6 / o3, d9 = n7 / o3;
    return [e3.getXForColumn(u4), e3.getYForRow(g6), e3.getXForColumn(c9), e3.getYForRow(d9)];
  }
  _getGeohash(e3, t6, s9) {
    const r6 = { geohashX: 0, geohashY: 0 };
    return Y2(r6, t6, e3, s9), r6;
  }
  _getGeohashBounds(e3, t6) {
    const s9 = this._getGeohashLevel(e3.key.level);
    if (this._spatialReference.isWebMercator) {
      const [e4, r7, o8, a9] = t6, i6 = { x: e4, y: r7 }, h7 = { x: o8, y: a9 };
      let l10 = 0, g7 = 0, c10 = 0, d10 = 0;
      {
        const e5 = T3(i6.x / s3.radius);
        l10 = e5 - 360 * Math.floor((e5 + 180) / 360), g7 = T3(Math.PI / 2 - 2 * Math.atan(Math.exp(-i6.y / s3.radius)));
      }
      {
        const e5 = T3(h7.x / s3.radius);
        c10 = e5 - 360 * Math.floor((e5 + 180) / 360), d10 = T3(Math.PI / 2 - 2 * Math.atan(Math.exp(-h7.y / s3.radius)));
      }
      const f10 = { geohashX: 0, geohashY: 0 }, p4 = { geohashX: 0, geohashY: 0 };
      Y2(f10, g7, l10, s9), Y2(p4, d10, c10, s9);
      return { bounds: [e4, r7, o8, a9], geohashBounds: { xLL: f10.geohashX, yLL: f10.geohashY, xTR: p4.geohashX, yTR: p4.geohashY }, level: s9 };
    }
    const r6 = v.fromExtent(w.fromBounds(t6, this._spatialReference)), o7 = g3(r6, this._spatialReference, k.WGS84, { densificationStep: e3.resolution * w3 });
    if (!o7)
      return null;
    const a8 = J(new t3(), o7, false, false), i5 = a8.coords.filter((e4, t7) => !(t7 % 2)), h6 = a8.coords.filter((e4, t7) => t7 % 2), l9 = Math.min(...i5), g6 = Math.min(...h6), c9 = Math.max(...i5), d9 = Math.max(...h6), f9 = this._getGeohash(l9, g6, s9), m6 = this._getGeohash(c9, d9, s9);
    return { bounds: t6, geohashBounds: { xLL: f9.geohashX, yLL: f9.geohashY, xTR: m6.geohashX, yTR: m6.geohashY }, level: s9 };
  }
  _lookupCluster(e3, r6, o7, a8, i5, h6) {
    const n7 = this._getClusterId(o7, a8, i5), l9 = this._clusters.get(n7), u4 = this._getClusterBounds(r6, a8, i5), g6 = this._getGeohashBounds(h6, u4);
    if (t(g6))
      return null;
    const c9 = this._tree.getRegionStatistics(g6), { count: d9, xTotal: f9, yTotal: p4, referenceId: m6 } = c9, _4 = d9 ? f9 / d9 : 0, y6 = d9 ? p4 / d9 : 0;
    if (0 === d9)
      return this._clusters.set(n7, null), null;
    const I2 = { cluster_count: d9, ...c9.attributes }, b6 = r(l9) ? l9.update(_4, y6, o7, I2, g6, m6) : V.create(e3, n7, _4, y6, o7, I2, g6, m6);
    if (0 === d9) {
      const [e4, t6, s9, r7] = u4;
      b6.geometry.coords[0] = (e4 + s9) / 2, b6.geometry.coords[1] = (t6 + r7) / 2;
    }
    return this._clusters.set(n7, b6), this._updateAggregateValueRangeForCluster(b6, b6.tileLevel), b6;
  }
  _updateAggregateValueRangeForCluster(e3, t6) {
    const s9 = this._aggregateValueRanges[t6] || { minValue: 1 / 0, maxValue: 0 }, r6 = s9.minValue, o7 = s9.maxValue;
    s9.minValue = Math.min(r6, e3.count), s9.maxValue = Math.max(o7, e3.count), this._aggregateValueRanges[t6] = s9, r6 === s9.minValue && o7 === s9.maxValue || (this._aggregateValueRangesChanged = true);
  }
  _markTileClustersForDeletion(e3, t6) {
    const s9 = 2 * t6, r6 = Math.ceil(o3 / s9), { row: o7, col: a8 } = e3.key, i5 = a8 * o3, h6 = o7 * o3, n7 = Math.floor(i5 / s9), l9 = Math.floor(h6 / s9);
    for (let u4 = n7; u4 < n7 + r6; u4++)
      for (let t7 = l9; t7 < l9 + r6; t7++)
        this._markForDeletion(e3.key.level, u4, t7);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/controllers/FeatureController2D.js
var F4 = 5e3;
var j4 = "tileRenderer.featuresView.attributeView.initialize";
var T4 = "tileRenderer.featuresView.attributeView.requestUpdate";
var k2 = "tileRenderer.featuresView.requestRender";
function x3(e3) {
  return "worker:port-closed" === e3.name;
}
function R3(e3) {
  if (!j(e3) && !x3(e3))
    throw e3;
}
function A2(e3) {
  return "feature" === e3.type && "snapshot" === e3.mode;
}
var U3 = class extends d {
  constructor() {
    super(...arguments), this._storage = new r4(), this._markedIdsBufId = this._storage.createBitset(), this._lastCleanup = performance.now(), this._cleanupNeeded = false, this._invalidated = false, this._tileToResolver = /* @__PURE__ */ new Map(), this._didEdit = false, this._updateVersion = 1, this.tileStore = null, this.config = null, this.processor = null, this.remoteClient = null, this.service = null;
  }
  initialize() {
    this._initStores(), this._initSource(), this._updateQueue = new l2({ concurrency: "geoevent" === this._source.type ? 1 : 4, process: (e3, t6) => this._onTileMessage(e3, { signal: t6 }) }), this.handles.add([this.tileStore.on("update", this.onTileUpdate.bind(this)), f3(() => !this.updating, () => this.onIdle())]), this._checkUpdating = setInterval(() => this.notifyChange("updating"), 300);
  }
  _initSource() {
    const e3 = this.tileStore.tileScheme, t6 = () => this._updateQueue.length < 50, r6 = (e4, t7) => (this._invalidated = true, this._patchTile(e4, t7));
    this._source = a7(this.service, this.spatialReference, e3, r6, t6, this.featureStore), this._proxyEvents();
  }
  _proxyEvents() {
    if ("geoevent" === this._source.type) {
      const e3 = this._source.events;
      this.handles.add([e3.on("connectionStatus", (e4) => this.remoteClient.invoke("setProperty", { propertyName: "connectionStatus", value: e4 }).catch(R3)), e3.on("errorString", (e4) => this.remoteClient.invoke("setProperty", { propertyName: "errorString", value: e4 }).catch(R3)), e3.on("data-received", (e4) => this.remoteClient.invoke("emitEvent", { name: "data-received", event: { attributes: e4.attributes, centroid: e4.centroid, geometry: e4.geometry } }).catch(R3)), e3.on("updateRate", (e4) => this.remoteClient.invoke("emitEvent", { name: "update-rate", event: { ...e4 } }).catch(R3))]);
    }
  }
  _initAttributeStore(e3) {
    this.attributeStore || (this.attributeStore = new v2({ type: "remote", initialize: (e4, t6) => g(this.remoteClient.invoke(j4, e4, { signal: t6 }).catch(R3)), update: (e4, t6) => g(this.remoteClient.invoke(T4, e4, { signal: t6 }).catch(R3)), render: (e4) => g(this.remoteClient.invoke(k2, void 0, { signal: e4 }).catch(R3)) }, e3, () => this.notifyChange("updating")));
  }
  _initStores() {
    const e3 = "snapshot" === this.service.type ? "snapshot" : "on-demand", t6 = { geometryInfo: { geometryType: this.service.geometryType, hasM: false, hasZ: false }, spatialReference: this.spatialReference, fieldsIndex: this.fieldsIndex, fields: this.service.fields };
    this.featureStore = new l3(t6, this._storage, e3);
  }
  _initQueryEngine(e3) {
    var _a;
    const t6 = this;
    (_a = this.featureQueryEngine) == null ? void 0 : _a.destroy(), this.featureQueryEngine = new Y({ definitionExpression: e3.schema.source.definitionExpression, fields: this.service.fields, geometryType: this.service.geometryType, objectIdField: this.service.objectIdField, hasM: false, hasZ: false, spatialReference: this.spatialReference.toJSON(), cacheSpatialQueries: true, featureStore: this.featureStore, aggregateAdapter: { getFeatureObjectIds(e4) {
      if (t(t6.aggregateStore))
        return [];
      return t6.aggregateStore.getFeatureDisplayIdsForAggregate(e4).map((e5) => t6.getObjectId(e5));
    } }, timeInfo: this.service.timeInfo });
  }
  _initAggregateQueryEngine(e3, t6) {
    var _a;
    if ((_a = this.aggregateQueryEngine) == null ? void 0 : _a.destroy(), t(e3))
      return;
    const s9 = t6.targets.aggregate.params.fields.slice();
    this.aggregateQueryEngine = new Y({ definitionExpression: null, fields: s9, geometryType: e3.geometryInfo.geometryType, objectIdField: e3.objectIdField, hasM: e3.geometryInfo.hasM, hasZ: e3.geometryInfo.hasZ, spatialReference: this.spatialReference.toJSON(), cacheSpatialQueries: false, featureStore: e3, aggregateAdapter: { getFeatureObjectIds: (e4) => [] } });
  }
  destroy() {
    var _a, _b, _c;
    this._updateQueue.destroy(), this._source.destroy(), (_a = this.featureQueryEngine) == null ? void 0 : _a.destroy(), (_b = this.aggregateQueryEngine) == null ? void 0 : _b.destroy(), (_c = this.attributeStore) == null ? void 0 : _c.destroy();
    for (const e3 of this.tileStore.tiles)
      this._source.unsubscribe(e3);
    clearInterval(this._checkUpdating);
  }
  get fieldsIndex() {
    return new r2(this.service.fields);
  }
  get spatialReference() {
    return this.tileStore.tileScheme.spatialReference;
  }
  get updating() {
    return this.isUpdating();
  }
  isUpdating() {
    const e3 = this._source.updating, t6 = !!this._updateQueue.length, r6 = !this.attributeStore || this.attributeStore.isUpdating(), s9 = e3 || t6 || r6;
    return has("esri-2d-log-updating") && console.log(`Updating FeatureController2D: ${s9}
  -> updatingSource ${e3}
  -> updateQueue ${t6}
  -> updatingAttributeStore ${r6}
`), s9;
  }
  enableEvent(e3) {
    this._source.enableEvent(e3.name, e3.value);
  }
  pause() {
    this._updateQueue.pause(), this._updateQueue.clear();
  }
  resume() {
    this._updateQueue.resume();
  }
  pauseStream() {
    "geoevent" === this._source.type && this._source.pauseStream();
  }
  resumeStream() {
    "geoevent" === this._source.type && this._source.resumeStream();
  }
  _initAggregateStore(e3) {
    var _a, _b;
    const t6 = (_b = (_a = e3.schema.targets) == null ? void 0 : _a.aggregate) == null ? void 0 : _b.type, r6 = o(this.config, (e4) => {
      var _a2, _b2;
      return (_b2 = (_a2 = e4.schema.targets) == null ? void 0 : _a2.aggregate) == null ? void 0 : _b2.type;
    });
    if (r6 !== t6 && (r(this.aggregateStore) && (this.handles.remove("valueRangesChanged"), this.aggregateStore.destroy(), this.aggregateStore = null), t6)) {
      switch (t6) {
        case "cluster": {
          const e4 = { geometryInfo: { geometryType: "esriGeometryPoint", hasM: false, hasZ: false }, spatialReference: this.spatialReference, fieldsIndex: this.fieldsIndex, fields: this.service.fields };
          this.aggregateStore = new D3(e4, this.spatialReference, this._storage, this.service), this.handles.add(this.aggregateStore.events.on("valueRangesChanged", (e5) => {
            this.remoteClient.invoke("emitEvent", { name: "valueRangesChanged", event: { valueRanges: e5.valueRanges } }).catch(R3);
          }), "valueRangesChanged");
          break;
        }
        case "bin": {
          const e4 = { geometryInfo: { geometryType: "esriGeometryPolygon", hasM: false, hasZ: false }, spatialReference: this.spatialReference, fieldsIndex: this.fieldsIndex, fields: this.service.fields };
          this.aggregateStore = new D2(e4, this.spatialReference, this._storage, this.service);
          break;
        }
      }
      this.aggregateStore.onTileUpdate({ added: this.tileStore.tiles, removed: [] });
    }
  }
  async update(e3, t6) {
    this._updateVersion++, this._initQueryEngine(t6), this._initAttributeStore(t6), this.pause(), await Promise.all([this._source.update(e3, t6.schema.source), this.featureStore.updateSchema(e3, t6.schema.targets.feature), this.attributeStore.update(e3, t6), this.attributeStore.updateFilters(e3, t6, this)]), this._initAggregateStore(t6), r(this.aggregateStore) && await this.aggregateStore.updateSchema(e3, t6.schema.targets.aggregate), this._initAggregateQueryEngine(this.aggregateStore, t6.schema), has("esri-2d-update-debug") && e3.describe(), this._set("config", t6);
  }
  async applyUpdate(e3) {
    e3.version = this._updateVersion, has("esri-2d-update-debug") && console.debug(`Applying update ${e3.version}`), e3.mesh && this.clearTiles(), this._updateQueue.resume(), await this._source.applyUpdate(e3), this.notifyChange("updating"), await j2(() => !this.updating), r(this.aggregateStore) && (await U(10), await j2(() => !this.updating));
  }
  async onEdits({ edits: e3 }) {
    has("esri-2d-update-debug") && console.debug("Applying Edit:", e3), this._didEdit = true;
    try {
      const t6 = e3.removed.map((e4) => e4.objectId && -1 !== e4.objectId ? e4.objectId : this._lookupObjectIdByGlobalId(e4.globalId)), r6 = e3.addOrModified.map(({ objectId: e4 }) => e4);
      this.featureStore.invalidate(), await this._source.edit(r6, t6), this.clearTiles(), this.notifyChange("updating"), r(this.aggregateStore) && this.aggregateStore.clear(), await this._source.resend(), await j2(() => !this.updating);
    } catch (t6) {
    }
  }
  async refresh(e3) {
    if (!e3.dataChanged) {
      const e4 = t5.empty();
      return e4.storage.filters = true, this.applyUpdate(e4);
    }
    this.featureStore.invalidate(), this.clearTiles(), this._source.refresh(this._updateVersion, e3), this._cleanupNeeded = true, this.notifyChange("updating"), await j2(() => !this.updating);
  }
  clearTiles() {
    for (const e3 of this.tileStore.tiles)
      this.processor.onTileClear(e3);
  }
  onTileUpdate(e3) {
    r(this.aggregateStore) && this.aggregateStore.onTileUpdate(e3);
    for (const t6 of e3.added)
      this._source.subscribe(t6, this._updateVersion), this._level = t6.level;
    for (const t6 of e3.removed)
      this._source.unsubscribe(t6), this._cleanupNeeded = true, this._tileToResolver.has(t6.id) && (this._tileToResolver.get(t6.id).resolve(), this._tileToResolver.delete(t6.id));
    this.notifyChange("updating");
  }
  async onIdle() {
    this._invalidated && (this._invalidated = false, (r(this.aggregateStore) || "heatmap" === this.processor.type) && await this._repushCurrentLevelTiles()), this._markAndSweep();
  }
  async querySummaryStatistics({ query: e3, params: t6 }) {
    return this.featureQueryEngine.executeQueryForSummaryStatistics(e3, t6);
  }
  async queryAggregateSummaryStatistics({ query: e3, params: t6 }) {
    return this.aggregateQueryEngine.executeQueryForSummaryStatistics(e3, t6);
  }
  async queryUniqueValues({ query: e3, params: t6 }) {
    return this.featureQueryEngine.executeQueryForUniqueValues(e3, t6);
  }
  async queryAggregateUniqueValues({ query: e3, params: t6 }) {
    return this.aggregateQueryEngine.executeQueryForUniqueValues(e3, t6);
  }
  async queryClassBreaks({ query: e3, params: t6 }) {
    return this.featureQueryEngine.executeQueryForClassBreaks(e3, t6);
  }
  async queryAggregateClassBreaks({ query: e3, params: t6 }) {
    return this.aggregateQueryEngine.executeQueryForClassBreaks(e3, t6);
  }
  async queryHistogram({ query: e3, params: t6 }) {
    return this.featureQueryEngine.executeQueryForHistogram(e3, t6);
  }
  async queryAggregateHistogram({ query: e3, params: t6 }) {
    return this.aggregateQueryEngine.executeQueryForHistogram(e3, t6);
  }
  queryExtent(e3) {
    return this.featureQueryEngine.executeQueryForExtent(e3);
  }
  queryAggregates(e3) {
    return this.aggregateQueryEngine.executeQuery(e3);
  }
  queryAggregateCount(e3) {
    return this.aggregateQueryEngine.executeQueryForCount(e3);
  }
  queryAggregateIds(e3) {
    return this.aggregateQueryEngine.executeQueryForIds(e3);
  }
  queryFeatures(e3) {
    return this.featureQueryEngine.executeQuery(e3);
  }
  async queryVisibleFeatures(e3) {
    const t6 = await this.featureQueryEngine.executeQuery(e3), r6 = t6.objectIdFieldName;
    return t6.features = t6.features.filter((e4) => {
      const t7 = e4.attributes[r6], i5 = this.getDisplayId(t7);
      return o(i5, (e5) => this.attributeStore.isVisible(e5));
    }), t6;
  }
  queryFeatureCount(e3) {
    return this.featureQueryEngine.executeQueryForCount(e3);
  }
  queryLatestObservations(e3) {
    return this.featureQueryEngine.executeQueryForLatestObservations(e3);
  }
  queryObjectIds(e3) {
    return this.featureQueryEngine.executeQueryForIds(e3);
  }
  async queryStatistics() {
    return this.featureStore.storeStatistics;
  }
  getObjectId(e3) {
    return this.featureStore.lookupObjectId(e3, this._storage);
  }
  getDisplayId(e3) {
    if (r(this.aggregateStore)) {
      const t6 = this.aggregateStore.getDisplayId(e3);
      if (t(t6)) {
        const t7 = this.featureStore.lookupDisplayId(e3);
        return this.aggregateStore.getDisplayIdForReferenceId(t7);
      }
      return t6;
    }
    return this.featureStore.lookupDisplayId(e3);
  }
  getFeatures(e3) {
    const t6 = [], r6 = [];
    for (const s9 of e3) {
      const e4 = r(this.aggregateStore) ? this.getAggregate(s9) : null;
      if (r(e4))
        if (r(e4.attributes.referenceId)) {
          const r7 = this.getFeature(e4.attributes.referenceId);
          r(r7) && t6.push(r7);
        } else
          r6.push(e4);
      else {
        const e5 = this.getFeature(s9);
        r(e5) && t6.push(e5);
      }
    }
    return { features: t6, aggregates: r6 };
  }
  getFeature(e3) {
    const t6 = this.featureStore.lookupFeatureByDisplayId(e3, this._storage);
    if (t(t6))
      return null;
    const s9 = t6.readHydratedGeometry(), i5 = rt(s9, t6.geometryType, t6.hasZ, t6.hasM);
    return { attributes: t6.readAttributes(), geometry: i5 };
  }
  getAggregate(e3) {
    return t(this.aggregateStore) ? null : this.aggregateStore.getAggregate(e3);
  }
  getAggregates() {
    return t(this.aggregateStore) ? [] : this.aggregateStore.getAggregates();
  }
  async setHighlight(e3) {
    const t6 = m(e3.map((e4) => this.getDisplayId(e4)));
    return this.attributeStore.setHighlight(e3, t6);
  }
  _lookupObjectIdByGlobalId(e3) {
    const t6 = this.service.globalIdField;
    if (t(t6))
      throw new Error("Expected globalIdField to be defined");
    let s9 = null;
    if (this.featureStore.forEach((r6) => {
      e3 === r6.readAttribute(t6) && (s9 = r6.getObjectId());
    }), t(s9))
      throw new Error(`Expected to find a feature with globalId ${e3}`);
    return s9;
  }
  async _repushCurrentLevelTiles() {
    const e3 = this.tileStore.tiles.filter((e4) => e4.level === this._level);
    e3.map(async (e4) => this._patchTile({ type: "append", id: e4.key.id, clear: true, addOrUpdate: null, end: false }));
    const t6 = e3.map(async (e4) => this._patchTile({ type: "append", id: e4.key.id, addOrUpdate: c5.fromOptimizedFeatures([], this.service), remove: [], end: true, isRepush: true, status: t5.empty() }));
    await Promise.all(t6);
  }
  _maybeForceCleanup() {
    performance.now() - this._lastCleanup > F4 && this._markAndSweep();
  }
  _patchTile(e3, t6) {
    const r6 = this._updateQueue.push(e3, t6).then(() => {
      this.notifyChange("updating");
    }).catch((e4) => {
      this.notifyChange("updating");
    });
    return this.notifyChange("updating"), r6;
  }
  async _onTileMessage(e3, t6) {
    if (f2(t6), has("esri-2d-update-debug")) {
      const t7 = o(e3.addOrUpdate, (e4) => e4.hasFeatures);
      console.debug(e3.id, `FeatureController:onTileMessage: [clear:${e3.clear}, end:${e3.end}, features: ${t7}]`);
    }
    const a8 = this.tileStore.get(e3.id);
    if (!a8)
      return;
    if (e3.clear)
      return this.processor.onTileClear(a8);
    const o7 = e3.status;
    this._cleanupNeeded = true;
    const n7 = [];
    for (const r6 of e3.remove) {
      const e4 = this.featureStore.lookupDisplayId(r6);
      e4 && n7.push(e4);
    }
    e3.remove = n7;
    try {
      if (t(e3.addOrUpdate))
        return void this.processor.onTileMessage(a8, { ...e3, addOrUpdate: null }, r(this.aggregateStore), t6).catch(b2);
      if (e3.addOrUpdate.setArcadeSpatialReference(this.spatialReference), this.featureStore.hasInstance(e3.addOrUpdate.instance) && o7.targets.feature || (o7.targets.feature = true, this.featureStore.onTileData(a8, e3)), !o7.storage.data || !o7.storage.filters) {
        o7.storage.data = true, o7.storage.filters = true, this.attributeStore.onTileData(a8, e3);
        "geoevent" === this._source.type || this._didEdit ? (await this.attributeStore.sendUpdates(), f2(t6)) : this.attributeStore.sendUpdates();
      }
      if (r(this.aggregateStore) && !o7.targets.aggregate) {
        o7.targets.aggregate = true;
        const t7 = A2(this._source) && this._source.loading, r6 = !A2(this._source) || t7 || e3.end;
        if (this.aggregateStore.onTileData(a8, e3, this._storage, this.attributeStore, r6), !r6)
          return;
        o7.mesh || (this.attributeStore.onTileData(a8, e3), await this.attributeStore.sendUpdates());
      }
      if (!o7.mesh) {
        o7.mesh = true;
        const r6 = r(this.aggregateStore) && "cluster" === this.aggregateStore.type;
        await this.processor.onTileMessage(a8, e3, r6, t6), f2(t6);
      }
      this._maybeForceCleanup();
    } catch (h6) {
      b2(h6);
    }
  }
  _mark(e3, t6, r6) {
    const s9 = (4294901760 & this._storage.getInstanceId(e3)) >>> 16;
    e3 && (t6.add(s9), r6.set(e3));
  }
  _markAndSweep() {
    this._lastCleanup = performance.now();
    if (!(!("feature" === this._source.type && "snapshot" === this._source.mode) && ("geoevent" === this._source.type || this._cleanupNeeded)))
      return;
    this._cleanupNeeded = false;
    const e3 = this._storage.getBitset(this._markedIdsBufId), t6 = /* @__PURE__ */ new Set();
    e3.clear();
    for (const r6 of this.tileStore.tiles)
      for (const s9 of this._source.readers(r6.id)) {
        const r7 = s9.getCursor();
        for (; r7.next(); ) {
          let s10 = r7.getDisplayId();
          if (!s10) {
            const e4 = r7.getObjectId();
            s10 = this.featureStore.lookupDisplayId(e4);
          }
          this._mark(s10, t6, e3);
        }
      }
    "symbol" === this.processor.type && this.processor.forEachBufferId((r6) => {
      this._mark(r6, t6, e3);
    }), this._updateQueue.forEach((r6) => {
      for (const s9 of r6.remove) {
        const r7 = this.featureStore.lookupDisplayId(s9);
        this._mark(r7, t6, e3);
      }
    }), r(this.aggregateStore) && (this.aggregateStore.sweepFeatures(e3, this.featureStore), "sweepAggregates" in this.aggregateStore && this.aggregateStore.sweepAggregates(this._storage, this.attributeStore, this._level)), this.featureStore.sweepFeatures(e3, this._storage, this.attributeStore), this.featureStore.sweepFeatureSets(t6);
  }
};
e2([y({ constructOnly: true })], U3.prototype, "tileStore", void 0), e2([y()], U3.prototype, "config", void 0), e2([y({ readOnly: true })], U3.prototype, "fieldsIndex", null), e2([y()], U3.prototype, "processor", void 0), e2([y({ constructOnly: true })], U3.prototype, "remoteClient", void 0), e2([y({ constructOnly: true })], U3.prototype, "service", void 0), e2([y()], U3.prototype, "spatialReference", null), e2([y()], U3.prototype, "updating", null), U3 = e2([n("esri.views.2d.layers.features.controllers.FeatureController2D")], U3);
var q4 = U3;

// node_modules/@arcgis/core/views/2d/layers/features/Pipeline.js
var d8 = class extends d {
  constructor() {
    super(...arguments), this.controller = null, this.processor = null, this.remoteClient = null, this.tileStore = null, this.service = null, this.viewState = null, this._paused = false, this._pendingTileUpdates = [];
  }
  initialize() {
    this.handles.add(l(() => this.updating, (e3) => {
      this.remoteClient.invoke("setUpdating", e3).catch((e4) => {
      });
    }));
  }
  destroy() {
    var _a, _b;
    this.stop(), (_a = this.controller) == null ? void 0 : _a.destroy(), (_b = this.processor) == null ? void 0 : _b.destroy(), this.controller = this.processor = this.tileStore = this.remoteClient = null;
  }
  get updating() {
    return !this.controller || this.controller.updating;
  }
  stop() {
    var _a, _b, _c;
    this._paused = true, Array.isArray((_a = this.service) == null ? void 0 : _a.source) && (this.service.source.forEach((e3) => e3.close()), this.service.source.length = 0), (_b = this.tileStore) == null ? void 0 : _b.updateTiles({ added: [], removed: this.tileStore.tiles.map((e3) => e3.id) }), (_c = this.tileStore) == null ? void 0 : _c.destroy(), this.tileStore = null, this._pendingTileUpdates.length = 0;
  }
  async startup({ service: e3, config: t6, tileInfo: r6, tiles: s9 }) {
    var _a, _b, _c;
    if (this._paused = true, Array.isArray((_a = this.service) == null ? void 0 : _a.source) && (this.service.source.forEach((e4) => e4.close()), this.service.source.length = 0), this.service = e3, !this.tileStore || !E2(this.tileStore.tileScheme.spatialReference, r6.spatialReference)) {
      const e4 = new h(j3.fromJSON(r6));
      s9.added.length = s9.removed.length = 0, (_b = this.tileStore) == null ? void 0 : _b.updateTiles({ added: [], removed: this.tileStore.tiles.map((e5) => e5.id) }), (_c = this.tileStore) == null ? void 0 : _c.destroy(), this.tileStore = new d3(e4), this._pendingTileUpdates.length = 0;
    }
    for (await this._createProcessorAndController(t6), await this.update({ config: t6 }), this.controller.resume(), this.tileStore.clear(), this.tileStore.updateTiles(s9), this._paused = false; this._pendingTileUpdates.length; )
      this.tileStore.updateTiles(this._pendingTileUpdates.pop());
  }
  async updateTiles(e3) {
    this._paused ? this._pendingTileUpdates.push(e3) : this.tileStore.updateTiles(e3);
  }
  async update({ config: e3 }) {
    const t6 = t5.empty();
    return await Promise.all([this.processor.update(t6, e3), this.controller.update(t6, e3)]), t6.toJSON();
  }
  async applyUpdate(e3) {
    return this.controller.applyUpdate(t5.create(e3));
  }
  async _createProcessorAndController(e3) {
    await Promise.all([this._handleControllerConfig(e3), this._handleProcessorConfig(e3)]), this.controller.processor = this.processor;
  }
  async _handleControllerConfig(e3) {
    return this._createController(this.service, e3);
  }
  async _handleProcessorConfig(e3) {
    return this._createProcessor(this.service, e3);
  }
  async _createController(e3, t6) {
    this.controller && this.controller.destroy();
    const { tileStore: r6, remoteClient: s9 } = this, o7 = new q4({ service: e3, tileStore: r6, remoteClient: s9 });
    return this.controller = o7, o7;
  }
  async _createProcessor(e3, t6) {
    const r6 = t6.schema.processors[0].type, s9 = (await o4(r6)).default, { remoteClient: o7, tileStore: i5 } = this, l9 = new s9({ service: e3, config: t6, tileStore: i5, remoteClient: o7 });
    return this.processor && this.processor.destroy(), this.processor = l9, l9;
  }
};
e2([y()], d8.prototype, "controller", void 0), e2([y()], d8.prototype, "processor", void 0), e2([y()], d8.prototype, "updating", null), e2([y()], d8.prototype, "viewState", void 0), d8 = e2([n("esri.views.2d.layers.features.Pipeline")], d8);
var u3 = d8;
export {
  u3 as default
};
//# sourceMappingURL=Pipeline-XKLRG2GG.js.map
