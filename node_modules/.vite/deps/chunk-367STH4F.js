import {
  l
} from "./chunk-7QMMKGW4.js";
import {
  e,
  n2 as n,
  y as y2
} from "./chunk-OOLCFNXJ.js";
import {
  N
} from "./chunk-BTUHYGXO.js";
import {
  y
} from "./chunk-HVKDYDPP.js";
import {
  r,
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/layers/support/DimensionalDefinition.js
var a;
var n2 = a = class extends l {
  constructor(e2) {
    super(e2), this.variableName = null, this.dimensionName = null, this.values = [], this.isSlice = false;
  }
  clone() {
    return new a({ variableName: this.variableName, dimensionName: this.dimensionName, values: y(this.values), isSlice: this.isSlice });
  }
};
e([y2({ type: String, json: { write: true } })], n2.prototype, "variableName", void 0), e([y2({ type: String, json: { write: true } })], n2.prototype, "dimensionName", void 0), e([y2({ type: N.array(N.oneOf([N.native(Number), N.array(N.native(Number))])), json: { write: true } })], n2.prototype, "values", void 0), e([y2({ type: Boolean, json: { write: true } })], n2.prototype, "isSlice", void 0), n2 = a = e([n("esri.layers.support.DimensionalDefinition")], n2);
var p = n2;

// node_modules/@arcgis/core/layers/support/rasterDatasets/multidimensionalUtils.js
function a2(e2, n3, t2) {
  var _a;
  const i2 = n3.shift();
  if (0 === t2.length) {
    const e3 = [];
    t2.push({ sliceId: -1, multidimensionalDefinition: e3 });
  }
  const s2 = t2.length;
  for (let a3 = 0; a3 < s2; a3++) {
    const n4 = t2.shift().multidimensionalDefinition;
    (_a = i2.values) == null ? void 0 : _a.forEach((a4) => {
      t2.push({ sliceId: -1, multidimensionalDefinition: [...n4, { variableName: e2, dimensionName: i2.name, values: [a4] }] });
    });
  }
  n3.length && a2(e2, n3, t2);
}
function i(e2, n3) {
  const t2 = [];
  let i2 = 0;
  return (n3 ? e2.variables.filter((e3) => e3.name.toLowerCase() === n3.toLowerCase()) : [...e2.variables].sort((e3, n4) => e3.name > n4.name ? 1 : -1)).forEach((e3) => {
    const n4 = [], s2 = [...e3.dimensions].sort((e4, n5) => e4.name > n5.name ? -1 : 1);
    a2(e3.name, s2, n4), n4.forEach((e4) => {
      t2.push({ ...e4, sliceId: i2++ });
    });
  }), t2;
}
function s(n3, t2, a3) {
  let i2 = n3;
  if (t2 && (t2 = [...t2].sort((e2, n4) => e2.dimensionName < n4.dimensionName ? -1 : 1)).forEach(({ dimensionName: e2, values: n4, isSlice: t3 }) => {
    n4.length && (i2 = i2.filter((a4) => {
      const i3 = a4.multidimensionalDefinition.find((n5) => n5.dimensionName === e2);
      if (null == i3)
        return false;
      const s2 = i3.values[0];
      return "number" == typeof s2 ? "number" == typeof n4[0] ? n4.includes(s2) : n4.some((e3) => e3[0] <= s2 && e3[1] >= s2) : "number" == typeof n4[0] ? n4.some((e3) => s2[0] <= e3 && s2[1] >= e3) : t3 ? n4.some((e3) => e3[0] === s2[0] && e3[0] === s2[1]) : n4.some((e3) => e3[0] >= s2[0] && e3[0] <= s2[1] || e3[1] >= s2[0] && e3[1] <= s2[1] || e3[0] < s2[0] && e3[1] > s2[1]);
    }));
  }), i2.length && a3 && r(a3.start) && r(a3.end)) {
    const e2 = a3.start.getTime(), n4 = a3.end.getTime(), t3 = i2[0].multidimensionalDefinition.findIndex((e3) => "StdTime" === e3.dimensionName);
    t3 > -1 && (i2 = i2.filter((a4) => {
      const i3 = a4.multidimensionalDefinition[t3].values[0];
      return e2 <= i3 && n4 >= i3;
    }));
  }
  return i2.map((e2) => e2.sliceId);
}
function r2(e2, n3) {
  return Array.isArray(e2) ? n3[0] === n3[1] ? e2[0] === n3[0] || e2[1] === n3[0] : e2[0] >= n3[0] && e2[0] <= n3[1] && e2[1] >= n3[0] && e2[1] <= n3[1] : e2 >= n3[0] && e2 <= n3[1];
}
function l2(e2, n3) {
  return e2[0] <= n3[0] && e2[1] >= n3[0] || e2[0] <= n3[1] && e2[1] >= n3[1] || e2[0] >= n3[0] && e2[1] <= n3[1];
}
function o(e2) {
  return 1 === e2.length ? [e2[0], e2[0]] : [e2[0], e2[e2.length - 1]];
}
function u(e2, n3, t2) {
  var _a, _b, _c;
  if (!((_a = n3 == null ? void 0 : n3.subsetDefinitions) == null ? void 0 : _a.length))
    return e2;
  let a3;
  if (t2) {
    const { variables: i3 } = n3;
    if (i3.length && !i3.includes(t2))
      return null;
    const s3 = n3.subsetDefinitions.find((n4) => n4.dimensionName === e2.name && n4.variableName === t2);
    if (!((_b = s3 == null ? void 0 : s3.values) == null ? void 0 : _b.length))
      return e2;
    a3 = o(s3.values);
  } else {
    a3 = (_c = n3.dimensions.find(({ name: n4 }) => n4 === e2.name)) == null ? void 0 : _c.extent;
  }
  const i2 = a3;
  if (!i2 || !(i2 == null ? void 0 : i2.length))
    return e2;
  const s2 = e2.values.filter((e3) => r2(e3, i2));
  return { ...e2, extent: [...i2], values: s2 };
}
function m(e2, n3, t2) {
  var _a;
  if (!((_a = n3 == null ? void 0 : n3.subsetDefinitions) == null ? void 0 : _a.length))
    return false;
  const { variables: a3 } = n3;
  if (a3.length && e2.some(({ variableName: e3 }) => e3 && !a3.includes(e3)))
    return true;
  for (let i2 = 0; i2 < e2.length; i2++) {
    const a4 = e2[i2], s2 = n3.subsetDefinitions.find((e3) => ("" === a4.variableName || e3.variableName === a4.variableName) && e3.dimensionName === a4.dimensionName);
    if (s2 == null ? void 0 : s2.values.length) {
      const e3 = o(s2.values);
      if (!a4.isSlice && 2 === a4.values.length && !Array.isArray(a4.values[0]) && a4.values[0] !== a4.values[1] && t2) {
        if (!l2(a4.values, e3))
          return true;
      } else if (a4.values.some((n4) => !r2(n4, e3)))
        return true;
    }
  }
  return false;
}
function c(e2, a3 = {}) {
  var _a, _b, _c;
  const { multidimensionalInfo: i2, keyProperties: s2 } = e2;
  if (t(i2))
    return null;
  const r3 = a3.variableName || (s2 == null ? void 0 : s2.DefaultVariable);
  let { variables: l3 } = i2;
  const { multidimensionalSubset: o2 } = a3;
  ((_a = o2 == null ? void 0 : o2.variables) == null ? void 0 : _a.length) && (l3 = l3.filter(({ name: e3 }) => o2.variables.includes(e3)));
  const m2 = r3 ? (_b = l3.find(({ name: e3 }) => e3 === r3)) != null ? _b : l3[0] : l3[0];
  if (!m2)
    return null;
  const c2 = [], { dimensions: f2, name: d2 } = m2;
  if (0 === f2.length)
    return [new p({ variableName: d2, dimensionName: "", values: [], isSlice: true })];
  for (let n3 = 0; n3 < f2.length; n3++) {
    const e3 = u(f2[n3], o2, d2);
    if (!e3)
      return null;
    const { values: i3, extent: s3 } = e3;
    let r4 = (_c = i3 == null ? void 0 : i3[0]) != null ? _c : s3[0];
    "stdz" === e3.name.toLowerCase() && !e3.hasRanges && Math.abs(s3[1]) <= Math.abs(s3[0]) && (r4 = (i3 == null ? void 0 : i3.length) ? i3[i3.length - 1] : s3[1]), c2.push(new p({ variableName: d2, dimensionName: e3.name, values: [r4], isSlice: !a3.useRangeForRangedDimensionInfo || !!e3.hasRanges }));
  }
  return c2;
}
function f(e2) {
  return !(t(e2) || !e2.length) && e2.some((e3) => {
    if (null == e3.values)
      return true;
    const n3 = e3.values.length;
    return 0 === n3 || n3 > 1 || !e3.isSlice && Array.isArray(e3.values[0]);
  });
}
function d(e2, t2) {
  var _a;
  if (t(t2) || t(e2))
    return null;
  let a3 = t2.variables.map((e3) => ({ ...e3 }));
  return ((_a = e2 == null ? void 0 : e2.variables) == null ? void 0 : _a.length) && (a3 = a3.filter(({ name: n3 }) => e2.variables.includes(n3)), a3.forEach((n3) => {
    n3.dimensions = n3.dimensions.map((t3) => u(t3, e2, n3.name));
  })), a3;
}
function h(e2, n3) {
  var _a;
  const { values: t2 } = n3;
  if (t2 == null ? void 0 : t2.length)
    return Array.isArray(t2[0]) !== Array.isArray(e2) ? -1 : Array.isArray(t2[0]) ? t2.findIndex((n4) => n4[0] === e2[0] && n4[1] === e2[1]) : t2.indexOf(e2);
  const { extent: a3 } = n3;
  if (Array.isArray(e2) || e2 < a3[0] || e2 > a3[1])
    return -1;
  const i2 = n3.interval || 1;
  if ("ISO8601" !== n3.unit)
    return Math.round((e2 - a3[0]) / i2);
  const s2 = a3[0];
  let r3 = -1;
  switch (((_a = n3.intervalUnit) == null ? void 0 : _a.toLowerCase()) || "seconds") {
    case "seconds":
      r3 = Math.round((e2 - s2) / 1e3 / i2);
      break;
    case "minutes":
      r3 = Math.round((e2 - s2) / 6e4 / i2);
      break;
    case "hours":
      r3 = Math.round((e2 - s2) / 36e5 / i2);
      break;
    case "days":
      r3 = Math.round((e2 - s2) / 864e5 / i2);
      break;
    case "months":
      {
        const n4 = new Date(e2).getUTCFullYear() - new Date(s2).getUTCFullYear(), t3 = new Date(s2).getUTCMonth(), a4 = new Date(e2).getUTCMonth();
        r3 = 0 === n4 ? a4 - t3 : a4 + 11 - t3 + 12 * (n4 - 1);
      }
      break;
    case "years":
      r3 = Math.round((new Date(e2).getUTCFullYear() - new Date(s2).getUTCFullYear()) / i2);
      break;
    case "decades":
      r3 = Math.round((new Date(e2).getUTCFullYear() - new Date(s2).getUTCFullYear()) / 10 / i2);
  }
  return r3;
}
function v(e2) {
  var _a, _b, _c;
  let n3 = (_a = e2.values) == null ? void 0 : _a.length;
  if (n3)
    return n3;
  const { extent: t2, unit: a3 } = e2, i2 = e2.interval || 1, s2 = t2 ? t2[1] - t2[0] : 0;
  if ("ISO8601" !== a3)
    return Math.round(s2 / i2);
  switch ((_c = (_b = e2.intervalUnit) == null ? void 0 : _b.toLowerCase()) != null ? _c : "seconds") {
    case "seconds":
      n3 = Math.round(s2 / 1e3 / i2);
      break;
    case "minutes":
      n3 = Math.round(s2 / 6e4 / i2);
      break;
    case "hours":
      n3 = Math.round(s2 / 36e5 / i2);
      break;
    case "days":
      n3 = Math.round(s2 / 864e5 / i2);
      break;
    case "months":
      {
        const e3 = new Date(t2[1]).getUTCFullYear() - new Date(t2[0]).getUTCFullYear(), a4 = new Date(t2[1][0]).getUTCMonth(), i3 = new Date(t2[1][1]).getUTCMonth();
        n3 = 0 === e3 ? i3 - a4 + 1 : i3 + 11 - a4 + 12 * (e3 - 1) + 1;
      }
      break;
    case "years":
      n3 = Math.round((new Date(t2[1]).getUTCFullYear() - new Date(t2[0]).getUTCFullYear()) / i2);
      break;
    case "decades":
      n3 = Math.round((new Date(t2[1]).getUTCFullYear() - new Date(t2[0]).getUTCFullYear()) / 10 / i2);
      break;
    default:
      n3 = 0;
  }
  return n3;
}
function g(e2, n3) {
  let t2 = 0;
  const a3 = e2[0].variableName, i2 = [...n3.variables].sort((e3, n4) => e3.name > n4.name ? 1 : -1);
  for (let s2 = 0; s2 < i2.length; s2++) {
    const n4 = i2[s2], r3 = [...n4.dimensions].sort((e3, n5) => e3.name > n5.name ? -1 : 1);
    if (n4.name !== a3) {
      t2 += r3.map((e3) => v(e3)).reduce((e3, n5) => e3 * n5);
      continue;
    }
    const l3 = r3.map((e3) => v(e3)), o2 = r3.length;
    for (let a4 = 0; a4 < o2; a4++) {
      const n5 = e2.find((e3) => e3.dimensionName === r3[a4].name);
      if (null == n5)
        return null;
      const i3 = h(n5.values[0], r3[a4]);
      if (-1 === i3)
        return null;
      l3.shift(), t2 += a4 === o2 - 1 ? i3 : i3 * l3.reduce((e3, n6) => e3 * n6);
    }
    break;
  }
  return t2;
}

export {
  p,
  i,
  s,
  m,
  c,
  f,
  d,
  g
};
//# sourceMappingURL=chunk-367STH4F.js.map
