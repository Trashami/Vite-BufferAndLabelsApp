import {
  M,
  c2 as c,
  p,
  p2,
  w,
  w2
} from "./chunk-UWG37XSU.js";
import {
  R,
  k2 as k
} from "./chunk-LNZAOBFW.js";
import {
  r as r2
} from "./chunk-HLM6QCL2.js";
import {
  e,
  n2 as n,
  y as y2
} from "./chunk-OOLCFNXJ.js";
import {
  y
} from "./chunk-HVKDYDPP.js";
import {
  i
} from "./chunk-6QC7MLLS.js";
import {
  r,
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/geometry/support/zmUtils.js
function h(h7, a3, s5 = false) {
  let { hasM: t4, hasZ: e6 } = h7;
  Array.isArray(a3) ? 4 !== a3.length || t4 || e6 ? 3 === a3.length && s5 && !t4 ? (e6 = true, t4 = false) : 3 === a3.length && t4 && e6 && (t4 = false, e6 = false) : (t4 = true, e6 = true) : (e6 = !e6 && a3.hasZ && (!t4 || a3.hasM), t4 = !t4 && a3.hasM && (!e6 || a3.hasZ)), h7.hasZ = e6, h7.hasM = t4;
}

// node_modules/@arcgis/core/geometry/Multipoint.js
var h2;
function l(t4) {
  return (s5, e6) => null == s5 ? e6 : null == e6 ? s5 : t4(s5, e6);
}
function c2(t4) {
  return t4 && ("esri.geometry.SpatialReference" === t4.declaredClass || null != t4.wkid);
}
var m = h2 = class extends p {
  constructor(...t4) {
    super(...t4), this.points = [], this.type = "multipoint";
  }
  normalizeCtorArgs(t4, s5) {
    if (!t4 && !s5)
      return {};
    const e6 = {};
    Array.isArray(t4) ? (e6.points = t4, e6.spatialReference = s5) : c2(t4) ? e6.spatialReference = t4 : (t4.points && (e6.points = t4.points), t4.spatialReference && (e6.spatialReference = t4.spatialReference), t4.hasZ && (e6.hasZ = t4.hasZ), t4.hasM && (e6.hasM = t4.hasM));
    const i5 = e6.points && e6.points[0];
    return i5 && (void 0 === e6.hasZ && void 0 === e6.hasM ? (e6.hasZ = i5.length > 2, e6.hasM = false) : void 0 === e6.hasZ ? e6.hasZ = i5.length > 3 : void 0 === e6.hasM && (e6.hasM = i5.length > 3)), e6;
  }
  get cache() {
    return this.commitProperty("points"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get extent() {
    const t4 = this.points;
    if (!t4.length)
      return null;
    const s5 = new w2(), e6 = this.hasZ, i5 = this.hasM, r7 = e6 ? 3 : 2, n3 = t4[0], a3 = l(Math.min), p4 = l(Math.max);
    let h7, c8, m5, u7, [f5, y5] = n3, [d2, g4] = n3;
    for (let o5 = 0, l5 = t4.length; o5 < l5; o5++) {
      const s6 = t4[o5], [n4, l6] = s6;
      if (f5 = a3(f5, n4), y5 = a3(y5, l6), d2 = p4(d2, n4), g4 = p4(g4, l6), e6 && s6.length > 2) {
        const t5 = s6[2];
        h7 = a3(h7, t5), m5 = p4(m5, t5);
      }
      if (i5 && s6.length > r7) {
        const t5 = s6[r7];
        c8 = a3(c8, t5), u7 = p4(u7, t5);
      }
    }
    return s5.xmin = f5, s5.ymin = y5, s5.xmax = d2, s5.ymax = g4, s5.spatialReference = this.spatialReference, e6 ? (s5.zmin = h7, s5.zmax = m5) : (s5.zmin = void 0, s5.zmax = void 0), i5 ? (s5.mmin = c8, s5.mmax = u7) : (s5.mmin = void 0, s5.mmax = void 0), s5;
  }
  writePoints(t4, e6) {
    e6.points = y(this.points);
  }
  addPoint(t4) {
    return h(this, t4), Array.isArray(t4) ? this.points.push(t4) : this.points.push(t4.toArray()), this.notifyChange("points"), this;
  }
  clone() {
    const t4 = { points: y(this.points), spatialReference: this.spatialReference };
    return this.hasZ && (t4.hasZ = true), this.hasM && (t4.hasM = true), new h2(t4);
  }
  getPoint(t4) {
    if (!this._validateInputs(t4))
      return null;
    const s5 = this.points[t4], e6 = { x: s5[0], y: s5[1], spatialReference: this.spatialReference };
    let i5 = 2;
    return this.hasZ && (e6.z = s5[2], i5 = 3), this.hasM && (e6.m = s5[i5]), new w(e6);
  }
  removePoint(t4) {
    if (!this._validateInputs(t4))
      return null;
    const s5 = new w(this.points.splice(t4, 1)[0], this.spatialReference);
    return this.notifyChange("points"), s5;
  }
  setPoint(t4, s5) {
    return this._validateInputs(t4) ? (h(this, s5), Array.isArray(s5) || (s5 = s5.toArray()), this.points[t4] = s5, this.notifyChange("points"), this) : this;
  }
  toJSON(t4) {
    return this.write({}, t4);
  }
  _validateInputs(t4) {
    return null != t4 && t4 >= 0 && t4 < this.points.length;
  }
};
e([y2({ readOnly: true })], m.prototype, "cache", null), e([y2()], m.prototype, "extent", null), e([y2({ type: [[Number]], json: { write: { isRequired: true } } })], m.prototype, "points", void 0), e([r2("points")], m.prototype, "writePoints", null), m = h2 = e([n("esri.geometry.Multipoint")], m), m.prototype.toJSON.isDefaultToJSON = true;
var u = m;

// node_modules/@arcgis/core/geometry/support/coordsUtils.js
function r3(n3) {
  if (!n3)
    return null;
  if (Array.isArray(n3))
    return n3;
  const t4 = n3.hasZ, r7 = n3.hasM;
  if ("point" === n3.type)
    return r7 && t4 ? [n3.x, n3.y, n3.z, n3.m] : t4 ? [n3.x, n3.y, n3.z] : r7 ? [n3.x, n3.y, n3.m] : [n3.x, n3.y];
  if ("polygon" === n3.type)
    return n3.rings.slice(0);
  if ("polyline" === n3.type)
    return n3.paths.slice(0);
  if ("multipoint" === n3.type)
    return n3.points.slice(0);
  if ("extent" === n3.type) {
    const t5 = n3.clone().normalize();
    if (!t5)
      return null;
    let r8 = false, e6 = false;
    return t5.forEach((n4) => {
      n4.hasZ && (r8 = true), n4.hasM && (e6 = true);
    }), t5.map((n4) => {
      const t6 = [[n4.xmin, n4.ymin], [n4.xmin, n4.ymax], [n4.xmax, n4.ymax], [n4.xmax, n4.ymin], [n4.xmin, n4.ymin]];
      if (r8 && n4.hasZ) {
        const r9 = 0.5 * (n4.zmax - n4.zmin);
        for (let n5 = 0; n5 < t6.length; n5++)
          t6[n5].push(r9);
      }
      if (e6 && n4.hasM) {
        const r9 = 0.5 * (n4.mmax - n4.mmin);
        for (let n5 = 0; n5 < t6.length; n5++)
          t6[n5].push(r9);
      }
      return t6;
    });
  }
  return null;
}
function e2(n3, t4) {
  const r7 = t4[0] - n3[0], e6 = t4[1] - n3[1];
  if (n3.length > 2 && t4.length > 2) {
    const o5 = n3[2] - t4[2];
    return Math.sqrt(r7 * r7 + e6 * e6 + o5 * o5);
  }
  return Math.sqrt(r7 * r7 + e6 * e6);
}
function o(n3, t4, r7) {
  const e6 = n3[0] + r7 * (t4[0] - n3[0]), o5 = n3[1] + r7 * (t4[1] - n3[1]);
  return n3.length > 2 && t4.length > 2 ? [e6, o5, n3[2] + r7 * (t4[2] - n3[2])] : [e6, o5];
}
function i2(n3, t4, r7, e6) {
  const [o5, i5] = t4, [s5, l5] = r7[e6], [f5, c8] = r7[e6 + 1], u7 = f5 - s5, h7 = c8 - l5, a3 = u7 * u7 + h7 * h7, g4 = (o5 - s5) * u7 + (i5 - l5) * h7, m5 = Math.min(1, Math.max(0, g4 / a3));
  return n3[0] = s5 + u7 * m5, n3[1] = l5 + h7 * m5, n3;
}
function s(n3, t4, r7) {
  const e6 = r7.rings;
  let o5, i5, s5 = false, f5 = 1 / 0;
  for (let c8 = 0; c8 < e6.length; c8++) {
    const r8 = e6[c8];
    for (let e7 = 0, c9 = r8.length - 1; e7 < r8.length; c9 = e7++)
      o5 = r8[e7], i5 = r8[c9], o5[1] > t4 != i5[1] > t4 && n3 < (i5[0] - o5[0]) * (t4 - o5[1]) / (i5[1] - o5[1]) + o5[0] && (s5 = !s5), f5 = Math.min(f5, l2(n3, t4, o5, i5));
  }
  return 0 === f5 ? 0 : (s5 ? 1 : -1) * Math.sqrt(f5);
}
function l2(n3, t4, r7, e6) {
  let o5 = r7[0], i5 = r7[1], s5 = e6[0] - o5, l5 = e6[1] - i5;
  if (0 !== s5 || 0 !== l5) {
    const r8 = ((n3 - o5) * s5 + (t4 - i5) * l5) / (s5 * s5 + l5 * l5);
    r8 > 1 ? (o5 = e6[0], i5 = e6[1]) : r8 > 0 && (o5 += s5 * r8, i5 += l5 * r8);
  }
  return s5 = n3 - o5, l5 = t4 - i5, s5 * s5 + l5 * l5;
}
function f(n3, t4) {
  return o(n3, t4, 0.5);
}
function c3(n3) {
  const t4 = n3.length;
  let r7 = 0;
  for (let o5 = 0; o5 < t4 - 1; ++o5)
    r7 += e2(n3[o5], n3[o5 + 1]);
  return r7;
}
function u2(n3, t4) {
  if (t4 <= 0)
    return n3[0];
  const r7 = n3.length;
  let i5 = 0;
  for (let s5 = 0; s5 < r7 - 1; ++s5) {
    const r8 = e2(n3[s5], n3[s5 + 1]);
    if (t4 - i5 < r8) {
      const e6 = (t4 - i5) / r8;
      return o(n3[s5], n3[s5 + 1], e6);
    }
    i5 += r8;
  }
  return n3[r7 - 1];
}
function h3(n3, t4, r7) {
  const e6 = n3.length;
  let o5 = 0, i5 = 0, s5 = 0;
  for (let l5 = 0; l5 < e6; l5++) {
    const f5 = n3[l5], c8 = n3[(l5 + 1) % e6];
    let u7 = 2;
    o5 += f5[0] * c8[1] - c8[0] * f5[1], f5.length > 2 && c8.length > 2 && r7 && (i5 += f5[0] * c8[2] - c8[0] * f5[2], u7 = 3), f5.length > u7 && c8.length > u7 && t4 && (s5 += f5[0] * c8[u7] - c8[0] * f5[u7]);
  }
  return o5 <= 0 && i5 <= 0 && s5 <= 0;
}
function a(t4) {
  const r7 = t4.length;
  return r7 > 2 && i(t4[0], t4[r7 - 1]);
}
function g(n3) {
  var _a, _b;
  if ("rings" in n3 && (m2(n3), n3.rings.length > 0 && !h3(n3.rings[0], (_a = n3.hasM) != null ? _a : false, (_b = n3.hasZ) != null ? _b : false)))
    for (const t4 of n3.rings)
      t4.reverse();
}
function m2(n3) {
  if ("rings" in n3)
    for (const t4 of n3.rings)
      a(t4) || t4.push(t4[0].slice());
}
function p3(n3) {
  if ("polygon" !== n3.type && "polyline" !== n3.type)
    return n3;
  return y3("polygon" === n3.type ? n3.rings : n3.paths, n3.spatialReference), n3;
}
function y3(n3, r7) {
  const e6 = R(r7);
  if (!e6)
    return;
  const o5 = e6.valid[0], i5 = e6.valid[1], s5 = i5 - o5;
  for (const t4 of n3) {
    let n4 = 1 / 0, r8 = -1 / 0;
    for (const s6 of t4) {
      const t5 = x(s6[0], o5, i5);
      n4 = Math.min(n4, t5), r8 = Math.max(r8, t5), s6[0] = t5;
    }
    const e7 = r8 - n4;
    s5 - e7 < e7 && t4.forEach((n5) => {
      n5[0] < 0 && (n5[0] += s5);
    });
  }
}
function x(n3, t4, r7) {
  const e6 = r7 - t4;
  return n3 < t4 ? r7 - (t4 - n3) % e6 : n3 > r7 ? t4 + (n3 - t4) % e6 : n3;
}
function M2(n3) {
  if (!n3 || n3.length < 3)
    return 0;
  let t4 = 0;
  const r7 = n3.length - 1;
  for (let e6 = 0; e6 < r7; e6++)
    t4 += (n3[e6][0] - n3[e6 + 1][0]) * (n3[e6][1] + n3[e6 + 1][1]);
  return t4 += (n3[r7][0] - n3[0][0]) * (n3[r7][1] + n3[0][1]), -0.5 * t4;
}

// node_modules/@arcgis/core/geometry/support/boundsUtils.js
function n2(n3) {
  return void 0 !== n3.xmin && void 0 !== n3.ymin && void 0 !== n3.xmax && void 0 !== n3.ymax;
}
function t2(n3) {
  return void 0 !== n3.points;
}
function e3(n3) {
  return void 0 !== n3.x && void 0 !== n3.y;
}
function o2(n3) {
  return void 0 !== n3.paths;
}
function r4(n3) {
  return void 0 !== n3.rings;
}
function i3(n3) {
  function t4(t5, e6) {
    return null == t5 ? e6 : null == e6 ? t5 : n3(t5, e6);
  }
  return t4;
}
var l3 = i3(Math.min);
var u3 = i3(Math.max);
function c4(i5, l5) {
  return o2(l5) ? h4(i5, l5.paths, false, false) : r4(l5) ? h4(i5, l5.rings, false, false) : t2(l5) ? s2(i5, l5.points, false, false, false, false) : n2(l5) ? g2(i5, l5) : (e3(l5) && (i5[0] = l5.x, i5[1] = l5.y, i5[2] = l5.x, i5[3] = l5.y), i5);
}
function f2(i5, l5) {
  return o2(l5) ? h4(i5, l5.paths, true, false) : r4(l5) ? h4(i5, l5.rings, true, false) : t2(l5) ? s2(i5, l5.points, true, false, true, false) : n2(l5) ? g2(i5, l5, true, false, true, false) : (e3(l5) && (i5[0] = l5.x, i5[1] = l5.y, i5[2] = l5.z, i5[3] = l5.x, i5[4] = l5.y, i5[5] = l5.z), i5);
}
function h4(n3, t4, e6, o5) {
  const r7 = e6 ? 3 : 2;
  if (!t4.length || !t4[0].length)
    return null;
  let i5, c8, f5, h7, [g4, s5] = t4[0][0], [x4, m5] = t4[0][0];
  for (let a3 = 0; a3 < t4.length; a3++) {
    const n4 = t4[a3];
    for (let t5 = 0; t5 < n4.length; t5++) {
      const a4 = n4[t5], [d2, v3] = a4;
      if (g4 = l3(g4, d2), s5 = l3(s5, v3), x4 = u3(x4, d2), m5 = u3(m5, v3), e6 && a4.length > 2) {
        const n5 = a4[2];
        i5 = l3(i5, n5), c8 = u3(c8, n5);
      }
      if (o5 && a4.length > r7) {
        const n5 = a4[r7];
        f5 = l3(i5, n5), h7 = u3(c8, n5);
      }
    }
  }
  return e6 ? o5 ? (n3[0] = g4, n3[1] = s5, n3[2] = i5, n3[3] = f5, n3[4] = x4, n3[5] = m5, n3[6] = c8, n3[7] = h7, n3.length = 8, n3) : (n3[0] = g4, n3[1] = s5, n3[2] = i5, n3[3] = x4, n3[4] = m5, n3[5] = c8, n3.length = 6, n3) : o5 ? (n3[0] = g4, n3[1] = s5, n3[2] = f5, n3[3] = x4, n3[4] = m5, n3[5] = h7, n3.length = 6, n3) : (n3[0] = g4, n3[1] = s5, n3[2] = x4, n3[3] = m5, n3.length = 4, n3);
}
function g2(n3, t4, e6, o5, r7, i5) {
  const l5 = t4.xmin, u7 = t4.xmax, c8 = t4.ymin, f5 = t4.ymax;
  let h7 = t4.zmin, g4 = t4.zmax, s5 = t4.mmin, x4 = t4.mmax;
  return r7 ? (h7 = h7 || 0, g4 = g4 || 0, i5 ? (s5 = s5 || 0, x4 = x4 || 0, n3[0] = l5, n3[1] = c8, n3[2] = h7, n3[3] = s5, n3[4] = u7, n3[5] = f5, n3[6] = g4, n3[7] = x4, n3) : (n3[0] = l5, n3[1] = c8, n3[2] = h7, n3[3] = u7, n3[4] = f5, n3[5] = g4, n3)) : i5 ? (s5 = s5 || 0, x4 = x4 || 0, n3[0] = l5, n3[1] = c8, n3[2] = s5, n3[3] = u7, n3[4] = f5, n3[5] = x4, n3) : (n3[0] = l5, n3[1] = c8, n3[2] = u7, n3[3] = f5, n3);
}
function s2(n3, t4, e6, o5, r7, i5) {
  const c8 = e6 ? 3 : 2, f5 = o5 && i5, h7 = e6 && r7;
  if (!t4.length || !t4[0].length)
    return null;
  let g4, s5, x4, m5, [a3, d2] = t4[0], [v3, y5] = t4[0];
  for (let p4 = 0; p4 < t4.length; p4++) {
    const n4 = t4[p4], [e7, o6] = n4;
    if (a3 = l3(a3, e7), d2 = l3(d2, o6), v3 = u3(v3, e7), y5 = u3(y5, o6), h7 && n4.length > 2) {
      const t5 = n4[2];
      g4 = l3(g4, t5), s5 = u3(s5, t5);
    }
    if (f5 && n4.length > c8) {
      const t5 = n4[c8];
      x4 = l3(g4, t5), m5 = u3(s5, t5);
    }
  }
  return r7 ? (g4 = g4 || 0, s5 = s5 || 0, i5 ? (x4 = x4 || 0, m5 = m5 || 0, n3[0] = a3, n3[1] = d2, n3[2] = g4, n3[3] = x4, n3[4] = v3, n3[5] = y5, n3[6] = s5, n3[7] = m5, n3) : (n3[0] = a3, n3[1] = d2, n3[2] = g4, n3[3] = v3, n3[4] = y5, n3[5] = s5, n3)) : i5 ? (x4 = x4 || 0, m5 = m5 || 0, n3[0] = a3, n3[1] = d2, n3[2] = x4, n3[3] = v3, n3[4] = y5, n3[5] = m5, n3) : (n3[0] = a3, n3[1] = d2, n3[2] = v3, n3[3] = y5, n3);
}

// node_modules/@arcgis/core/geometry/support/centroid.js
function e4(n3) {
  return n3 ? n3.hasZ ? [n3.xmax - n3.xmin / 2, n3.ymax - n3.ymin / 2, n3.zmax - n3.zmin / 2] : [n3.xmax - n3.xmin / 2, n3.ymax - n3.ymin / 2] : null;
}
function r5(n3) {
  var _a;
  return n3 ? o3(n3.rings, (_a = n3.hasZ) != null ? _a : false) : null;
}
function o3(n3, t4) {
  if (!n3 || !n3.length)
    return null;
  const l5 = [], e6 = [], r7 = t4 ? [1 / 0, -1 / 0, 1 / 0, -1 / 0, 1 / 0, -1 / 0] : [1 / 0, -1 / 0, 1 / 0, -1 / 0];
  for (let o5 = 0, i5 = n3.length; o5 < i5; o5++) {
    const l6 = u4(n3[o5], t4, r7);
    l6 && e6.push(l6);
  }
  if (e6.sort((n4, l6) => {
    let e7 = n4[2] - l6[2];
    return 0 === e7 && t4 && (e7 = n4[4] - l6[4]), e7;
  }), e6.length && (l5[0] = e6[0][0], l5[1] = e6[0][1], t4 && (l5[2] = e6[0][3]), (l5[0] < r7[0] || l5[0] > r7[1] || l5[1] < r7[2] || l5[1] > r7[3] || t4 && (l5[2] < r7[4] || l5[2] > r7[5])) && (l5.length = 0)), !l5.length) {
    const e7 = n3[0] && n3[0].length ? i4(n3[0], t4) : null;
    if (!e7)
      return null;
    l5[0] = e7[0], l5[1] = e7[1], t4 && e7.length > 2 && (l5[2] = e7[2]);
  }
  return l5;
}
function u4(n3, t4, l5) {
  let e6 = 0, r7 = 0, o5 = 0, u7 = 0, i5 = 0;
  const s5 = n3.length ? n3[0][0] : 0, g4 = n3.length ? n3[0][1] : 0, h7 = n3.length && t4 ? n3[0][2] : 0;
  for (let f5 = 0; f5 < n3.length; f5++) {
    const c9 = n3[f5], m5 = n3[(f5 + 1) % n3.length], [x4, a3, y5] = c9, p4 = x4 - s5, z = a3 - g4, [Z, d2, j2] = m5, U = Z - s5, b = d2 - g4, k2 = p4 * b - U * z;
    if (u7 += k2, e6 += (p4 + U) * k2, r7 += (z + b) * k2, t4 && c9.length > 2 && m5.length > 2) {
      const n4 = y5 - h7, t5 = j2 - h7, l6 = p4 * t5 - U * n4;
      o5 += (n4 + t5) * l6, i5 += l6;
    }
    x4 < l5[0] && (l5[0] = x4), x4 > l5[1] && (l5[1] = x4), a3 < l5[2] && (l5[2] = a3), a3 > l5[3] && (l5[3] = a3), t4 && (y5 < l5[4] && (l5[4] = y5), y5 > l5[5] && (l5[5] = y5));
  }
  if (u7 > 0 && (u7 *= -1), i5 > 0 && (i5 *= -1), !u7)
    return null;
  u7 *= 0.5, i5 *= 0.5;
  const c8 = [e6 / (6 * u7) + s5, r7 / (6 * u7) + g4, u7];
  return t4 && (l5[4] === l5[5] || 0 === i5 ? (c8[3] = (l5[4] + l5[5]) / 2, c8[4] = 0) : (c8[3] = o5 / (6 * i5) + h7, c8[4] = i5)), c8;
}
function i4(l5, e6) {
  const r7 = e6 ? [0, 0, 0] : [0, 0], o5 = e6 ? [0, 0, 0] : [0, 0];
  let u7 = 0, i5 = 0, s5 = 0, g4 = 0;
  for (let h7 = 0, c8 = l5.length; h7 < c8 - 1; h7++) {
    const c9 = l5[h7], f5 = l5[h7 + 1];
    if (c9 && f5) {
      r7[0] = c9[0], r7[1] = c9[1], o5[0] = f5[0], o5[1] = f5[1], e6 && c9.length > 2 && f5.length > 2 && (r7[2] = c9[2], o5[2] = f5[2]);
      const l6 = e2(r7, o5);
      if (l6) {
        u7 += l6;
        const n3 = f(c9, f5);
        i5 += l6 * n3[0], s5 += l6 * n3[1], e6 && n3.length > 2 && (g4 += l6 * n3[2]);
      }
    }
  }
  return u7 > 0 ? e6 ? [i5 / u7, s5 / u7, g4 / u7] : [i5 / u7, s5 / u7] : l5.length ? l5[0] : null;
}
var s3 = 1e-6;
function g3(n3) {
  if (!n3 || !n3.rings)
    return null;
  const { rings: t4 } = n3;
  let e6 = 0;
  for (let o5 = 0; o5 < t4.length; o5++)
    e6 += M2(t4[o5]);
  if (e6 < s3)
    return o3(t4, false);
  const r7 = [0, 0], u7 = t4[0][0];
  for (let l5 = 0; l5 < t4.length; l5++)
    c5(r7, u7, t4[l5]);
  return r7[0] *= 1 / e6, r7[1] *= 1 / e6, r7[0] += u7[0], r7[1] += u7[1], r7;
}
var h5 = 1 / 3;
function c5(n3, t4, e6) {
  if (!n3 || !e6 || e6.length < 3)
    return null;
  const r7 = e6[0], o5 = [0, 0], u7 = [e6[1][0] - r7[0], e6[1][1] - r7[1]];
  let i5;
  for (let l5 = 2; l5 < e6.length; l5++)
    o5[0] = e6[l5][0] - r7[0], o5[1] = e6[l5][1] - r7[1], i5 = 0.5 * h5 * (o5[0] * u7[1] - o5[1] * u7[0]), n3[0] += i5 * (u7[0] + o5[0]), n3[1] += i5 * (u7[1] + o5[1]), u7[0] = o5[0], u7[1] = o5[1];
  const s5 = M2(e6), g4 = [r7[0], r7[1]];
  return g4[0] -= t4[0], g4[1] -= t4[1], g4[0] *= s5, g4[1] *= s5, n3[0] += g4[0], n3[1] += g4[1], n3;
}

// node_modules/@arcgis/core/geometry/support/extentUtils.js
function t3(n3) {
  return void 0 !== n3.xmin && void 0 !== n3.ymin && void 0 !== n3.xmax && void 0 !== n3.ymax;
}
function u5(n3) {
  return void 0 !== n3.points;
}
function m3(n3) {
  return void 0 !== n3.x && void 0 !== n3.y;
}
function o4(n3) {
  return void 0 !== n3.paths;
}
function r6(n3) {
  return void 0 !== n3.rings;
}
var x2 = [];
function a2(n3, i5, t4, u7) {
  return { xmin: n3, ymin: i5, xmax: t4, ymax: u7 };
}
function c6(n3, i5, t4, u7, m5, o5) {
  return { xmin: n3, ymin: i5, zmin: t4, xmax: u7, ymax: m5, zmax: o5 };
}
function s4(n3, i5, t4, u7, m5, o5) {
  return { xmin: n3, ymin: i5, mmin: t4, xmax: u7, ymax: m5, mmax: o5 };
}
function e5(n3, i5, t4, u7, m5, o5, r7, x4) {
  return { xmin: n3, ymin: i5, zmin: t4, mmin: u7, xmax: m5, ymax: o5, zmax: r7, mmax: x4 };
}
function f3(n3, i5 = false, t4 = false) {
  return i5 ? t4 ? e5(n3[0], n3[1], n3[2], n3[3], n3[4], n3[5], n3[6], n3[7]) : c6(n3[0], n3[1], n3[2], n3[3], n3[4], n3[5]) : t4 ? s4(n3[0], n3[1], n3[2], n3[3], n3[4], n3[5]) : a2(n3[0], n3[1], n3[2], n3[3]);
}
function l4(n3) {
  return n3 ? t3(n3) ? n3 : m3(n3) ? d(n3) : r6(n3) ? v(n3) : o4(n3) ? h6(n3) : u5(n3) ? y4(n3) : null : null;
}
function y4(i5) {
  const { hasZ: t4, hasM: u7, points: m5 } = i5;
  return f3(s2(x2, m5, t4 != null ? t4 : false, u7 != null ? u7 : false), t4, u7);
}
function d(n3) {
  const { x: i5, y: t4, z: u7, m: m5 } = n3, o5 = null != m5;
  return null != u7 ? o5 ? e5(i5, t4, u7, m5, i5, t4, u7, m5) : c6(i5, t4, u7, i5, t4, u7) : o5 ? s4(i5, t4, m5, i5, t4, m5) : a2(i5, t4, i5, t4);
}
function v(n3) {
  const { hasZ: t4, hasM: u7, rings: m5 } = n3, o5 = h4(x2, m5, t4 != null ? t4 : false, u7 != null ? u7 : false);
  return o5 ? f3(o5, t4, u7) : null;
}
function h6(n3) {
  const { hasZ: t4, hasM: u7, paths: m5 } = n3, o5 = h4(x2, m5, t4 != null ? t4 : false, u7 != null ? u7 : false);
  return o5 ? f3(o5, t4, u7) : null;
}

// node_modules/@arcgis/core/geometry/Polygon.js
var x3;
function j(t4) {
  return !Array.isArray(t4[0]);
}
var w3 = x3 = class extends p {
  constructor(...t4) {
    super(...t4), this.rings = [], this.type = "polygon";
  }
  static fromExtent(t4) {
    const r7 = t4.clone().normalize(), e6 = t4.spatialReference;
    let s5 = false, i5 = false;
    for (const o5 of r7)
      o5.hasZ && (s5 = true), o5.hasM && (i5 = true);
    const n3 = { rings: r7.map((t5) => {
      const r8 = [[t5.xmin, t5.ymin], [t5.xmin, t5.ymax], [t5.xmax, t5.ymax], [t5.xmax, t5.ymin], [t5.xmin, t5.ymin]];
      if (s5 && t5.hasZ) {
        const e7 = t5.zmin + 0.5 * (t5.zmax - t5.zmin);
        for (let t6 = 0; t6 < r8.length; t6++)
          r8[t6].push(e7);
      }
      if (i5 && t5.hasM) {
        const e7 = t5.mmin + 0.5 * (t5.mmax - t5.mmin);
        for (let t6 = 0; t6 < r8.length; t6++)
          r8[t6].push(e7);
      }
      return r8;
    }), spatialReference: e6 };
    return s5 && (n3.hasZ = true), i5 && (n3.hasM = true), new x3(n3);
  }
  normalizeCtorArgs(t4, r7) {
    let e6, s5, i5 = null, n3 = null;
    return t4 && !Array.isArray(t4) ? (i5 = t4.rings ? t4.rings : null, r7 || (t4.spatialReference ? r7 = t4.spatialReference : t4.rings || (r7 = t4)), e6 = t4.hasZ, s5 = t4.hasM) : i5 = t4, i5 = i5 || [], r7 = r7 || k.WGS84, i5.length && i5[0] && null != i5[0][0] && "number" == typeof i5[0][0] && (i5 = [i5]), n3 = i5[0] && i5[0][0], n3 && (void 0 === e6 && void 0 === s5 ? (e6 = n3.length > 2, s5 = n3.length > 3) : void 0 === e6 ? e6 = s5 ? n3.length > 3 : n3.length > 2 : void 0 === s5 && (s5 = e6 ? n3.length > 3 : n3.length > 2)), { rings: i5, spatialReference: r7, hasZ: e6, hasM: s5 };
  }
  get cache() {
    return this.commitProperty("rings"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get centroid() {
    const t4 = r5(this);
    if (!t4 || isNaN(t4[0]) || isNaN(t4[1]) || this.hasZ && isNaN(t4[2]))
      return null;
    const r7 = new w();
    return r7.x = t4[0], r7.y = t4[1], r7.spatialReference = this.spatialReference, this.hasZ && (r7.z = t4[2]), r7;
  }
  get extent() {
    const { spatialReference: t4 } = this, r7 = v(this);
    if (!r7)
      return null;
    const e6 = new w2(r7);
    return e6.spatialReference = t4, e6;
  }
  get isSelfIntersecting() {
    return p2(this.rings);
  }
  writeRings(t4, r7) {
    r7.rings = y(this.rings);
  }
  addRing(t4) {
    if (!t4)
      return;
    const r7 = this.rings, e6 = r7.length;
    if (j(t4)) {
      const s5 = [];
      for (let r8 = 0, e7 = t4.length; r8 < e7; r8++)
        s5[r8] = t4[r8].toArray();
      r7[e6] = s5;
    } else
      r7[e6] = t4.concat();
    return this.notifyChange("rings"), this;
  }
  clone() {
    const t4 = new x3();
    return t4.spatialReference = this.spatialReference, t4.rings = y(this.rings), t4.hasZ = this.hasZ, t4.hasM = this.hasM, t4;
  }
  equals(t4) {
    if (this === t4)
      return true;
    if (t(t4))
      return false;
    const e6 = this.spatialReference, n3 = t4.spatialReference;
    if (r(e6) !== r(n3))
      return false;
    if (r(e6) && r(n3) && !e6.equals(n3))
      return false;
    if (this.rings.length !== t4.rings.length)
      return false;
    const o5 = ([t5, r7, e7, s5], [i5, n4, o6, a3]) => t5 === i5 && r7 === n4 && (null == e7 && null == o6 || e7 === o6) && (null == s5 && null == a3 || s5 === a3);
    for (let s5 = 0; s5 < this.rings.length; s5++) {
      const e7 = this.rings[s5], i5 = t4.rings[s5];
      if (!i(e7, i5, o5))
        return false;
    }
    return true;
  }
  contains(t4) {
    if (!t4)
      return false;
    const r7 = M(t4, this.spatialReference);
    return c(this, r(r7) ? r7 : t4);
  }
  isClockwise(t4) {
    let r7;
    return r7 = j(t4) ? t4.map((t5) => this.hasZ ? this.hasM ? [t5.x, t5.y, t5.z, t5.m] : [t5.x, t5.y, t5.z] : [t5.x, t5.y]) : t4, h3(r7, this.hasM, this.hasZ);
  }
  getPoint(t4, r7) {
    if (!this._validateInputs(t4, r7))
      return null;
    const e6 = this.rings[t4][r7], s5 = this.hasZ, i5 = this.hasM;
    return s5 && !i5 ? new w(e6[0], e6[1], e6[2], void 0, this.spatialReference) : i5 && !s5 ? new w(e6[0], e6[1], void 0, e6[2], this.spatialReference) : s5 && i5 ? new w(e6[0], e6[1], e6[2], e6[3], this.spatialReference) : new w(e6[0], e6[1], this.spatialReference);
  }
  insertPoint(t4, r7, e6) {
    return this._validateInputs(t4, r7, true) ? (h(this, e6), Array.isArray(e6) || (e6 = e6.toArray()), this.rings[t4].splice(r7, 0, e6), this.notifyChange("rings"), this) : this;
  }
  removePoint(t4, r7) {
    if (!this._validateInputs(t4, r7))
      return null;
    const e6 = new w(this.rings[t4].splice(r7, 1)[0], this.spatialReference);
    return this.notifyChange("rings"), e6;
  }
  removeRing(t4) {
    if (!this._validateInputs(t4, null))
      return null;
    const r7 = this.rings.splice(t4, 1)[0], e6 = this.spatialReference, s5 = r7.map((t5) => new w(t5, e6));
    return this.notifyChange("rings"), s5;
  }
  setPoint(t4, r7, e6) {
    return this._validateInputs(t4, r7) ? (h(this, e6), Array.isArray(e6) || (e6 = e6.toArray()), this.rings[t4][r7] = e6, this.notifyChange("rings"), this) : this;
  }
  _validateInputs(t4, r7, e6 = false) {
    if (null == t4 || t4 < 0 || t4 >= this.rings.length)
      return false;
    if (null != r7) {
      const s5 = this.rings[t4];
      if (e6 && (r7 < 0 || r7 > s5.length))
        return false;
      if (!e6 && (r7 < 0 || r7 >= s5.length))
        return false;
    }
    return true;
  }
  toJSON(t4) {
    return this.write({}, t4);
  }
};
e([y2({ readOnly: true })], w3.prototype, "cache", null), e([y2({ readOnly: true })], w3.prototype, "centroid", null), e([y2({ readOnly: true })], w3.prototype, "extent", null), e([y2({ readOnly: true })], w3.prototype, "isSelfIntersecting", null), e([y2({ type: [[[Number]]], json: { write: { isRequired: true } } })], w3.prototype, "rings", void 0), e([r2("rings")], w3.prototype, "writeRings", null), w3 = x3 = e([n("esri.geometry.Polygon")], w3), w3.prototype.toJSON.isDefaultToJSON = true;
var v2 = w3;

// node_modules/@arcgis/core/geometry/Polyline.js
var c7;
function u6(t4) {
  return !Array.isArray(t4[0]);
}
var f4 = c7 = class extends p {
  constructor(...t4) {
    super(...t4), this.paths = [], this.type = "polyline";
  }
  normalizeCtorArgs(t4, e6) {
    let s5, r7, i5 = null, a3 = null;
    return t4 && !Array.isArray(t4) ? (i5 = t4.paths ? t4.paths : null, e6 || (t4.spatialReference ? e6 = t4.spatialReference : t4.paths || (e6 = t4)), s5 = t4.hasZ, r7 = t4.hasM) : i5 = t4, i5 = i5 || [], e6 = e6 || k.WGS84, i5.length && i5[0] && null != i5[0][0] && "number" == typeof i5[0][0] && (i5 = [i5]), a3 = i5[0] && i5[0][0], a3 && (void 0 === s5 && void 0 === r7 ? (s5 = a3.length > 2, r7 = false) : void 0 === s5 ? s5 = !r7 && a3.length > 3 : void 0 === r7 && (r7 = !s5 && a3.length > 3)), { paths: i5, spatialReference: e6, hasZ: s5, hasM: r7 };
  }
  get cache() {
    return this.commitProperty("paths"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get extent() {
    const { spatialReference: t4 } = this, e6 = h6(this);
    if (!e6)
      return null;
    const s5 = new w2(e6);
    return s5.spatialReference = t4, s5;
  }
  writePaths(t4, s5) {
    s5.paths = y(this.paths);
  }
  addPath(t4) {
    if (!t4)
      return;
    const e6 = this.paths, s5 = e6.length;
    if (u6(t4)) {
      const r7 = [];
      for (let e7 = 0, s6 = t4.length; e7 < s6; e7++)
        r7[e7] = t4[e7].toArray();
      e6[s5] = r7;
    } else
      e6[s5] = t4.concat();
    return this.notifyChange("paths"), this;
  }
  clone() {
    const t4 = new c7();
    return t4.spatialReference = this.spatialReference, t4.paths = y(this.paths), t4.hasZ = this.hasZ, t4.hasM = this.hasM, t4;
  }
  getPoint(t4, e6) {
    if (!this._validateInputs(t4, e6))
      return null;
    const s5 = this.paths[t4][e6], r7 = this.hasZ, i5 = this.hasM;
    return r7 && !i5 ? new w(s5[0], s5[1], s5[2], void 0, this.spatialReference) : i5 && !r7 ? new w(s5[0], s5[1], void 0, s5[2], this.spatialReference) : r7 && i5 ? new w(s5[0], s5[1], s5[2], s5[3], this.spatialReference) : new w(s5[0], s5[1], this.spatialReference);
  }
  insertPoint(t4, e6, s5) {
    return this._validateInputs(t4, e6, true) ? (h(this, s5), Array.isArray(s5) || (s5 = s5.toArray()), this.paths[t4].splice(e6, 0, s5), this.notifyChange("paths"), this) : this;
  }
  removePath(t4) {
    if (!this._validateInputs(t4, null))
      return null;
    const e6 = this.paths.splice(t4, 1)[0], s5 = this.spatialReference, r7 = e6.map((t5) => new w(t5, s5));
    return this.notifyChange("paths"), r7;
  }
  removePoint(t4, e6) {
    if (!this._validateInputs(t4, e6))
      return null;
    const s5 = new w(this.paths[t4].splice(e6, 1)[0], this.spatialReference);
    return this.notifyChange("paths"), s5;
  }
  setPoint(t4, e6, s5) {
    return this._validateInputs(t4, e6) ? (h(this, s5), Array.isArray(s5) || (s5 = s5.toArray()), this.paths[t4][e6] = s5, this.notifyChange("paths"), this) : this;
  }
  _validateInputs(t4, e6, s5 = false) {
    if (null == t4 || t4 < 0 || t4 >= this.paths.length)
      return false;
    if (null != e6) {
      const r7 = this.paths[t4];
      if (s5 && (e6 < 0 || e6 > r7.length))
        return false;
      if (!s5 && (e6 < 0 || e6 >= r7.length))
        return false;
    }
    return true;
  }
  toJSON(t4) {
    return this.write({}, t4);
  }
};
e([y2({ readOnly: true })], f4.prototype, "cache", null), e([y2({ readOnly: true })], f4.prototype, "extent", null), e([y2({ type: [[[Number]]], json: { write: { isRequired: true } } })], f4.prototype, "paths", void 0), e([r2("paths")], f4.prototype, "writePaths", null), f4 = c7 = e([n("esri.geometry.Polyline")], f4), f4.prototype.toJSON.isDefaultToJSON = true;
var m4 = f4;

export {
  u,
  r3 as r,
  i2 as i,
  s,
  f,
  c3 as c,
  u2,
  h3 as h,
  g,
  m2 as m,
  p3 as p,
  y3 as y,
  M2 as M,
  e4 as e,
  r5 as r2,
  o3 as o,
  u4 as u3,
  g3 as g2,
  c4 as c2,
  f2,
  h4 as h2,
  s2,
  l4 as l,
  v,
  v2,
  m4 as m2
};
//# sourceMappingURL=chunk-3MNMDUQZ.js.map
