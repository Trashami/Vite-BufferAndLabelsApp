import {
  d,
  i,
  t
} from "./chunk-FFVIDMFN.js";
import {
  E2 as E
} from "./chunk-WJCI2CGX.js";
import {
  m2,
  v2 as v
} from "./chunk-3MNMDUQZ.js";
import {
  k2 as k,
  o
} from "./chunk-LNZAOBFW.js";
import {
  e,
  m,
  n2 as n,
  y
} from "./chunk-OOLCFNXJ.js";
import {
  s
} from "./chunk-LIZHLHNA.js";

// node_modules/@arcgis/core/views/interactive/sketch/SketchTooltipElevationOptions.js
var t2 = class extends m {
  constructor(o2) {
    super(o2), this.mode = "absolute-height";
  }
  toJSON() {
    return { mode: this.mode };
  }
};
e([y({ type: String, nonNullable: true })], t2.prototype, "mode", void 0), t2 = e([n("esri.widgets.Sketch.SketchTooltipOptions.ElevationOptions")], t2);

// node_modules/@arcgis/core/views/interactive/sketch/SketchTooltipVisibleElements.js
var i2 = class extends m {
  constructor() {
    super(...arguments), this.distance = true, this.elevation = true, this.size = true, this.scale = true, this.rotation = true, this.orientation = true, this.totalLength = true, this.area = true, this.radius = true;
  }
  toJSON() {
    return { distance: this.distance, size: this.size, scale: this.scale, rotation: this.rotation, orientation: this.orientation, totalLength: this.totalLength, area: this.area, radius: this.radius };
  }
};
e([y({ type: Boolean, nonNullable: true })], i2.prototype, "distance", void 0), e([y({ type: Boolean, nonNullable: true })], i2.prototype, "elevation", void 0), e([y({ type: Boolean, nonNullable: true })], i2.prototype, "size", void 0), e([y({ type: Boolean, nonNullable: true })], i2.prototype, "scale", void 0), e([y({ type: Boolean, nonNullable: true })], i2.prototype, "rotation", void 0), e([y({ type: Boolean, nonNullable: true })], i2.prototype, "orientation", void 0), e([y({ type: Boolean, nonNullable: true })], i2.prototype, "totalLength", void 0), e([y({ type: Boolean, nonNullable: true })], i2.prototype, "area", void 0), e([y({ type: Boolean, nonNullable: true })], i2.prototype, "radius", void 0), i2 = e([n("esri.widgets.Sketch.SketchTooltipOptions.VisibleElements")], i2);

// node_modules/@arcgis/core/views/interactive/sketch/SketchTooltipOptions.js
var l = class extends m {
  constructor(e2) {
    super(e2), this.enabled = false, this.elevation = new t2(), this.visibleElements = new i2(), this.visualVariables = null;
  }
  toJSON() {
    return { enabled: this.enabled, elevation: this.elevation, visibleElements: this.visibleElements };
  }
};
e([y({ type: Boolean, nonNullable: true })], l.prototype, "enabled", void 0), e([y({ type: t2, nonNullable: true })], l.prototype, "elevation", void 0), e([y({ type: i2, nonNullable: true })], l.prototype, "visibleElements", void 0), e([y()], l.prototype, "visualVariables", void 0), l = e([n("esri.widgets.Sketch.SketchTooltipOptions")], l);
var p = l;

// node_modules/@arcgis/core/geometry/support/geodesicUtils.js
function f(e2) {
  if (!e2)
    return null;
  if (o(e2) && e2.wkid) {
    const t3 = d[e2.wkid];
    if (t3)
      return t3;
  }
  if (e2.wkt) {
    const t3 = p2(e2.wkt);
    if (t3)
      return t3;
  }
  return null;
}
function p2(e2) {
  const t3 = t.exec(e2);
  if (!t3 || 2 !== t3.length)
    return null;
  const n2 = t3[1].split(",");
  if (!n2 || n2.length < 3)
    return null;
  const i3 = parseFloat(n2[1]), r = parseFloat(n2[2]);
  if (isNaN(i3) || isNaN(r))
    return null;
  return { a: i3, f: 0 === r ? 0 : 1 / r };
}
function u(e2) {
  const t3 = f(e2 != null ? e2 : k.WGS84);
  if (m3(t3))
    return t3;
  const n2 = t3.a * (1 - t3.f);
  return Object.assign(t3, { b: n2, eSq: 1 - (n2 / t3.a) ** 2, radius: (2 * t3.a + n2) / 3, densificationRatio: 1e4 / ((2 * t3.a + n2) / 3) });
}
function m3(e2) {
  return null != e2 && "b" in e2 && "eSq" in e2 && "radius" in e2;
}
function g(e2, t3, i3) {
  const { a: s2, eSq: r } = u(i3), a = Math.sqrt(r), o2 = Math.sin(t3[1] * i), c = s2 * t3[0] * i;
  let h;
  if (r > 0) {
    h = s2 * ((1 - r) * (o2 / (1 - r * (o2 * o2)) - 1 / (2 * a) * Math.log((1 - a * o2) / (1 + a * o2)))) * 0.5;
  } else
    h = s2 * o2;
  return e2[0] = c, e2[1] = h, e2;
}
function M(e2) {
  return null !== f(e2);
}
function w2(n2, i3 = "square-meters") {
  if (n2.some((e2) => !M(e2.spatialReference)))
    throw new s("geodesic-areas:invalid-spatial-reference", "the input geometries spatial reference is not supported");
  const s2 = [];
  for (let e2 = 0; e2 < n2.length; e2++) {
    const t3 = n2[e2], i4 = t3.spatialReference, { radius: r2, densificationRatio: a2 } = u(i4), o3 = r2 * a2;
    s2.push(R(t3, o3));
  }
  const r = [], a = [0, 0], o2 = [0, 0];
  for (let e2 = 0; e2 < s2.length; e2++) {
    const { rings: n3, spatialReference: c } = s2[e2];
    let h = 0;
    for (let e3 = 0; e3 < n3.length; e3++) {
      const t3 = n3[e3];
      g(a, t3[0], c), g(o2, t3[t3.length - 1], c);
      let i4 = o2[0] * a[1] - a[0] * o2[1];
      for (let e4 = 0; e4 < t3.length - 1; e4++)
        g(a, t3[e4 + 1], c), g(o2, t3[e4], c), i4 += o2[0] * a[1] - a[0] * o2[1];
      h += i4;
    }
    h = E(h, "square-meters", i3), r.push(h / -2);
  }
  return r;
}
function y2(n2, i3 = "meters") {
  if (!n2)
    throw new s("geodesic-lengths:invalid-geometries", "the input geometries type is not supported");
  if (n2.some((e2) => !M(e2.spatialReference)))
    throw new s("geodesic-lengths:invalid-spatial-reference", "the input geometries spatial reference is not supported");
  const s2 = [];
  for (let e2 = 0; e2 < n2.length; e2++) {
    const r = n2[e2], { spatialReference: a } = r, o2 = "polyline" === r.type ? r.paths : r.rings;
    let c = 0;
    for (let e3 = 0; e3 < o2.length; e3++) {
      const t3 = o2[e3];
      let n3 = 0;
      for (let e4 = 1; e4 < t3.length; e4++) {
        const i4 = t3[e4 - 1][0], s3 = t3[e4][0], r2 = t3[e4 - 1][1], o3 = t3[e4][1];
        if (r2 !== o3 || i4 !== s3) {
          const e5 = new v2();
          b(e5, [i4, r2], [s3, o3], a), n3 += e5.distance;
        }
      }
      c += n3;
    }
    c = E(c, "meters", i3), s2.push(c);
  }
  return s2;
}
function R(t3, n2) {
  if ("polyline" !== t3.type && "polygon" !== t3.type)
    throw new s("geodesic-densify:invalid-geometry", "the input geometry is neither polyline nor polygon");
  const { spatialReference: i3 } = t3;
  if (!M(i3))
    throw new s("geodesic-densify:invalid-spatial-reference", "the input geometry spatial reference is not supported");
  const s2 = "polyline" === t3.type ? t3.paths : t3.rings, r = [], a = [0, 0], h = new v2();
  for (const e2 of s2) {
    const t4 = [];
    r.push(t4), t4.push([e2[0][0], e2[0][1]]);
    let s3, o2, c = e2[0][0], l2 = e2[0][1];
    for (let r2 = 0; r2 < e2.length - 1; r2++) {
      if (s3 = e2[r2 + 1][0], o2 = e2[r2 + 1][1], c === s3 && l2 === o2)
        continue;
      const f2 = [c, l2];
      b(h, [c, l2], [s3, o2], i3);
      const { azimuth: p3, distance: u2 } = h, m4 = u2 / n2;
      if (m4 > 1) {
        for (let e3 = 1; e3 <= m4 - 1; e3++) {
          z(a, f2, p3, e3 * n2, i3), t4.push(a.slice(0));
        }
        z(a, f2, p3, (u2 + Math.floor(m4 - 1) * n2) / 2, i3), t4.push(a.slice(0));
      }
      z(a, f2, p3, u2, i3), t4.push(a.slice(0)), c = a[0], l2 = a[1];
    }
  }
  return "polyline" === t3.type ? new m2({ paths: r, spatialReference: i3 }) : new v({ rings: r, spatialReference: i3 });
}
var v2 = class {
  constructor(e2 = 0, t3, n2) {
    this.distance = e2, this.azimuth = t3, this.reverseAzimuth = n2;
  }
};
function z(e2, t3, i3, s2, r) {
  const a = t3[0], o2 = t3[1], c = a * i, h = o2 * i, l2 = (i3 != null ? i3 : 0) * i, { a: f2, b: p3, f: m4 } = u(r), d2 = Math.sin(l2), g2 = Math.cos(l2), M2 = (1 - m4) * Math.tan(h), w3 = 1 / Math.sqrt(1 + M2 * M2), y3 = M2 * w3, R2 = Math.atan2(M2, g2), v3 = w3 * d2, z2 = v3 * v3, b2 = 1 - z2, j = b2 * (f2 * f2 - p3 * p3) / (p3 * p3), q = 1 + j / 16384 * (4096 + j * (j * (320 - 175 * j) - 768)), x = j / 1024 * (256 + j * (j * (74 - 47 * j) - 128));
  let A, N, S, k2, P = s2 / (p3 * q), F = 2 * Math.PI;
  for (; Math.abs(P - F) > 1e-12; )
    S = Math.cos(2 * R2 + P), A = Math.sin(P), N = Math.cos(P), k2 = x * A * (S + x / 4 * (N * (2 * S * S - 1) - x / 6 * S * (4 * A * A - 3) * (4 * S * S - 3))), F = P, P = s2 / (p3 * q) + k2;
  const U = y3 * A - w3 * N * g2, C = Math.atan2(y3 * N + w3 * A * g2, (1 - m4) * Math.sqrt(z2 + U * U)), E3 = Math.atan2(A * d2, w3 * N - y3 * A * g2), G = m4 / 16 * b2 * (4 + m4 * (4 - 3 * b2)), I = C / i, O = (c + (E3 - (1 - G) * m4 * v3 * (P + G * A * (S + G * N * (2 * S * S - 1))))) / i;
  return e2[0] = O, e2[1] = I, e2;
}
function b(e2, t3, i3, s2) {
  const r = t3[0] * i, a = t3[1] * i, o2 = i3[0] * i, c = i3[1] * i, { a: h, b: l2, f: f2, radius: p3 } = u(s2), m4 = o2 - r, d2 = Math.atan((1 - f2) * Math.tan(a)), g2 = Math.atan((1 - f2) * Math.tan(c)), M2 = Math.sin(d2), w3 = Math.cos(d2), y3 = Math.sin(g2), R2 = Math.cos(g2);
  let v3, z2, b2, j, q, x, A, N, S, k2, P = 1e3, F = m4;
  do {
    if (A = Math.sin(F), N = Math.cos(F), b2 = Math.sqrt(R2 * A * (R2 * A) + (w3 * y3 - M2 * R2 * N) * (w3 * y3 - M2 * R2 * N)), 0 === b2)
      return e2.distance = 0, e2.azimuth = void 0, e2.reverseAzimuth = void 0, e2;
    q = M2 * y3 + w3 * R2 * N, x = Math.atan2(b2, q), S = w3 * R2 * A / b2, z2 = 1 - S * S, j = q - 2 * M2 * y3 / z2, isNaN(j) && (j = 0), k2 = f2 / 16 * z2 * (4 + f2 * (4 - 3 * z2)), v3 = F, F = m4 + (1 - k2) * f2 * S * (x + k2 * b2 * (j + k2 * q * (2 * j * j - 1)));
  } while (Math.abs(F - v3) > 1e-12 && --P > 0);
  if (0 === P) {
    const t4 = p3, i4 = Math.acos(Math.sin(a) * Math.sin(c) + Math.cos(a) * Math.cos(c) * Math.cos(o2 - r)) * t4, s3 = o2 - r, h2 = Math.sin(s3) * Math.cos(c), l3 = Math.cos(a) * Math.sin(c) - Math.sin(a) * Math.cos(c) * Math.cos(s3), f3 = Math.atan2(h2, l3);
    return e2.azimuth = f3 / i, e2.distance = i4, e2.reverseAzimuth = void 0, e2;
  }
  const U = z2 * (h * h - l2 * l2) / (l2 * l2), C = U / 1024 * (256 + U * (U * (74 - 47 * U) - 128)), E3 = l2 * (1 + U / 16384 * (4096 + U * (U * (320 - 175 * U) - 768))) * (x - C * b2 * (j + C / 4 * (q * (2 * j * j - 1) - C / 6 * j * (4 * b2 * b2 - 3) * (4 * j * j - 3)))), G = Math.atan2(R2 * Math.sin(F), w3 * y3 - M2 * R2 * Math.cos(F)), I = Math.atan2(w3 * Math.sin(F), w3 * y3 * Math.cos(F) - M2 * R2);
  return e2.azimuth = G / i, e2.distance = E3, e2.reverseAzimuth = I / i, e2;
}

export {
  M,
  w2 as w,
  y2 as y,
  v2 as v,
  z,
  b,
  p
};
//# sourceMappingURL=chunk-2NKIENHY.js.map
