{
  "version": 3,
  "sources": ["../../@arcgis/core/chunks/LineCallout.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.25/esri/copyright.txt for details.\n*/\nimport{isSome as e}from\"../core/maybe.js\";import{s as i}from\"./vec2.js\";import{a as o}from\"./vec2f64.js\";import{Z as r}from\"./vec4f64.js\";import{SliceDraw as t}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{AlignPixel as a}from\"../views/3d/webgl-engine/core/shaderLibrary/hud/AlignPixel.glsl.js\";import{HUD as l}from\"../views/3d/webgl-engine/core/shaderLibrary/hud/HUD.glsl.js\";import{multipassGeometryTest as n}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassGeometryTest.glsl.js\";import{addScreenSizePerspectiveAlignment as s}from\"../views/3d/webgl-engine/core/shaderLibrary/util/ScreenSizePerspective.glsl.js\";import{Float2PassUniform as d}from\"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";import{Float4PassUniform as c}from\"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";import{FloatPassUniform as f}from\"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";import{glsl as p}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{ShaderBuilder as g}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{VertexAttribute as h}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";function S(o){const r=new g;r.include(a),r.include(l,o),r.include(t,o),r.attributes.add(h.UV0,\"vec2\");const{vertex:S,fragment:u}=r;return S.uniforms.add([new c(\"viewport\",((e,i)=>i.camera.fullViewport)),new f(\"lineSize\",((e,i)=>Math.ceil(e.size)*i.camera.pixelRatio)),new d(\"pixelToNDC\",((e,o)=>i(m,2/o.camera.fullViewport[2],2/o.camera.fullViewport[3]))),new f(\"borderSize\",((i,o)=>e(i.borderColor)?o.camera.pixelRatio:0)),new d(\"screenOffset\",((e,o)=>i(m,e.screenOffset[0]*o.camera.pixelRatio,e.screenOffset[1]*o.camera.pixelRatio)))]),r.varyings.add(\"coverageSampling\",\"vec4\"),r.varyings.add(\"lineSizes\",\"vec2\"),o.hasMultipassGeometry&&r.varyings.add(\"depth\",\"float\"),o.hasScreenSizePerspective&&s(S),S.code.add(p`\n    void main(void) {\n      ProjectHUDAux projectAux;\n      vec4 endPoint = projectPositionHUD(projectAux);\n\n      vec3 vpos = projectAux.posModel;\n      if (rejectBySlice(vpos)) {\n        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }\n    ${o.occlusionTestEnabled?p`\n      if (!testVisibilityHUD(endPoint)) {\n        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }`:\"\"}\n\n    ${o.hasScreenSizePerspective?p`\n      vec4 perspectiveFactor = screenSizePerspectiveScaleFactor(projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\n      vec2 screenOffsetScaled = applyScreenSizePerspectiveScaleFactorVec2(screenOffset, perspectiveFactor);\n        `:p`\n      vec2 screenOffsetScaled = screenOffset;\n        `}\n      // Add view dependent polygon offset to get exact same original starting point. This is mostly\n      // used to get the correct depth value\n      vec3 posView = (view * vec4(position, 1.0)).xyz;\n      ${o.hasMultipassGeometry?\"depth = posView.z;\":\"\"}\n\n      applyHUDViewDependentPolygonOffset(auxpos1.w, projectAux.absCosAngle, posView);\n      vec4 startPoint = proj * vec4(posView, 1.0);\n      // Apply screen offset to both start and end point\n      vec2 screenOffsetNorm = screenOffsetScaled * 2.0 / viewport.zw;\n      startPoint.xy += screenOffsetNorm * startPoint.w;\n      endPoint.xy += screenOffsetNorm * endPoint.w;\n      // Align start and end to pixel origin\n      vec4 startAligned = alignToPixelOrigin(startPoint, viewport.zw);\n      vec4 endAligned = alignToPixelOrigin(endPoint, viewport.zw);\n    ${o.depthHudEnabled?o.depthHudAlignStartEnabled?p`endAligned = vec4(endAligned.xy / endAligned.w * startAligned.w, startAligned.zw);`:p`startAligned = vec4(startAligned.xy / startAligned.w * endAligned.w, endAligned.zw);`:\"\"}\n      vec4 projectedPosition = mix(startAligned, endAligned, uv0.y);\n      // The direction of the line in screen space\n      vec2 screenSpaceDirection = normalize(endAligned.xy / endAligned.w - startAligned.xy / startAligned.w);\n      vec2 perpendicularScreenSpaceDirection = vec2(screenSpaceDirection.y, -screenSpaceDirection.x);\n    ${o.hasScreenSizePerspective?p`\n      float lineSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(lineSize, perspectiveFactor);\n      float borderSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(borderSize, perspectiveFactor);\n        `:p`\n      float lineSizeScaled = lineSize;\n      float borderSizeScaled = borderSize;\n        `}\n      float halfPixelSize = lineSizeScaled * 0.5;\n      // Calculate a pixel offset from the edge of the pixel, s.t. we keep the line aligned\n      // to pixels if it has a full pixel size. Since pixel aligned biases to the bottom-left,\n      // we bias the size to the right (for odd sizes) to balance out the bias. Grow sub-pixel\n      // sizes towards the left or right s.t. there is a smooth transition (e.g. from 2 to 3 px).\n      float halfWholePixelSize = floor(lineSizeScaled) * 0.5;\n      float halfPixelSizeInt = floor(halfWholePixelSize);\n\n      // Sub-pixel offset if we need to grow sub-pixels to the left\n      float subpixelOffset = -fract(lineSizeScaled) * float(halfWholePixelSize > 0.0);\n\n      // Pixel offset aligning to whole pixels and adding subpixel offset if needed\n      float pixelOffset = -halfPixelSizeInt + subpixelOffset;\n\n      // Compute full ndc offset, adding 1px padding for doing anti-aliasing and the border size\n      float padding = 1.0 + borderSizeScaled;\n      vec2 ndcOffset = (pixelOffset - padding + uv0.x * (lineSizeScaled + padding + padding)) * pixelToNDC;\n\n      // Offset x/y from the center of the line in screen space\n      projectedPosition.xy += perpendicularScreenSpaceDirection * ndcOffset * projectedPosition.w;\n\n      // Compute a coverage varying which we can use in the fragment shader to determine\n      // how much a pixel is actually covered by the line (i.e. to anti alias the line).\n      // This works by computing two coordinates that can be linearly interpolated and then\n      // subtracted to find out how far away from the line edge we are.\n      float edgeDirection = (uv0.x * 2.0 - 1.0);\n\n      float halfBorderSize = 0.5 * borderSizeScaled;\n      float halfPixelSizeAndBorder = halfPixelSize + halfBorderSize;\n      float outerEdgeCoverageSampler = edgeDirection * (halfPixelSizeAndBorder + halfBorderSize + 1.0);\n\n      float isOneSided = float(lineSizeScaled < 2.0 && borderSize < 2.0);\n\n      coverageSampling = vec4(\n        // Edge coordinate\n        outerEdgeCoverageSampler,\n\n        // Border edge coordinate\n        outerEdgeCoverageSampler - halfPixelSizeAndBorder * isOneSided,\n\n        // Line offset\n        halfPixelSize - 0.5,\n\n        // Border offset\n        halfBorderSize - 0.5 + halfPixelSizeAndBorder * (1.0 - isOneSided)\n      );\n\n      lineSizes = vec2(lineSizeScaled, borderSizeScaled);\n\n      gl_Position = projectedPosition;\n    }\n  `),u.uniforms.add([new c(\"uColor\",(e=>v(e.color))),new c(\"borderColor\",(e=>v(e.borderColor)))]),o.hasMultipassGeometry&&(u.include(n,o),u.uniforms.add(new d(\"inverseViewport\",((e,i)=>i.inverseViewport)))),u.code.add(p`\n    void main() {\n      ${o.hasMultipassGeometry?\"if( geometryDepthTest(gl_FragCoord.xy * inverseViewport, depth) ){ discard; }\":\"\"}\n\n      // Mix between line and border coverage offsets depending on whether we need\n      // a border (based on the sidedness).\n      vec2 coverage = min(1.0 - clamp(abs(coverageSampling.xy) - coverageSampling.zw, 0.0, 1.0), lineSizes);\n\n      // Mix between border and line color based on the line coverage (conceptually the line\n      // blends on top of the border background).\n      //\n      // Anti-alias by blending final result using the full (including optional border) coverage\n      // and the color alpha\n      float borderAlpha = uColor.a * borderColor.a * coverage.y;\n      float colorAlpha = uColor.a * coverage.x;\n\n      float finalAlpha = mix(borderAlpha, 1.0, colorAlpha);\n\n    ${o.depthHudEnabled?p`\n      if (finalAlpha < 0.01) {\n        discard;\n      }\n      `:p`\n      vec3 finalRgb = mix(borderColor.rgb * borderAlpha, uColor.rgb, colorAlpha);\n      gl_FragColor = vec4(finalRgb, finalAlpha);\n      `}\n  }\n  `),r}function v(i){return e(i)?i:r}const m=o(),u=Object.freeze(Object.defineProperty({__proto__:null,build:S},Symbol.toStringTag,{value:\"Module\"}));export{u as L,S as b};\n"],
  "mappings": "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",
  "names": ["o", "r", "u", "S", "e", "i", "n"]
}
