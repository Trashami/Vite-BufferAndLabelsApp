import {
  i as i2,
  o
} from "./chunk-GRWIJKD6.js";
import {
  r as r3
} from "./chunk-7N2Z7KNR.js";
import {
  ge
} from "./chunk-6TBB7UXB.js";
import {
  I
} from "./chunk-EQNT4A7P.js";
import {
  D as D2,
  F as F2,
  x2 as x
} from "./chunk-OYDVEVDU.js";
import {
  E2 as E3,
  a
} from "./chunk-O4DPVR3F.js";
import {
  E as E2
} from "./chunk-MATM5L52.js";
import {
  t as t3
} from "./chunk-4OM3EX6P.js";
import {
  C,
  D,
  E,
  F,
  G,
  L,
  P,
  R
} from "./chunk-3OFVLRSL.js";
import {
  t as t2
} from "./chunk-UDYHZLTE.js";
import {
  e as e2
} from "./chunk-IQBIGNPU.js";
import {
  M,
  b,
  f as f2,
  h,
  i,
  l as l2,
  r as r2
} from "./chunk-ZNRXLY4R.js";
import {
  d
} from "./chunk-REIQNAQW.js";
import {
  g
} from "./chunk-J6LQZWZI.js";
import {
  u
} from "./chunk-NRP45AHD.js";
import {
  m
} from "./chunk-C5H57NTD.js";
import {
  w,
  w2
} from "./chunk-UWG37XSU.js";
import {
  l
} from "./chunk-5NXILPDI.js";
import {
  e,
  m as m2,
  n2 as n,
  y
} from "./chunk-OOLCFNXJ.js";
import {
  f,
  j
} from "./chunk-MJXQTGI2.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";
import {
  r,
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/views/2d/engine/flow/utils.js
function n2(e4) {
  const n3 = i3(a2(e4)), o3 = n3, s4 = true, r5 = Math.max(n3 / 2, 5), l6 = Math.round(u(e4.maxPathLength) / r5) + 1, u6 = 10, { density: c3 } = e4;
  return { smoothing: u(e4.smoothing), interpolate: true, velocityScale: "flow-from" === e4.flowRepresentation ? 1 : -1, verticesPerLine: l6, minSpeedThreshold: 1e-3, segmentLength: r5, maxTurnAngle: 1, collisions: s4, lineCollisionWidth: o3, lineSpacing: u6, density: c3 };
}
function i3(e4) {
  return "constant" === e4.kind ? e4.value[0] : e4.values[e4.values.length - 1];
}
function o2(e4) {
  const t6 = e4.toRgba();
  return [t6[0] / 255, t6[1] / 255, t6[2] / 255, t6[3]];
}
function s2(e4) {
  return { kind: "constant", value: [0.1, 0.1, 0.1, 1] };
}
function a2(e4) {
  if (!e4.hasVisualVariables("size"))
    return { kind: "constant", value: [u(e4.trailWidth)] };
  const n3 = e4.getVisualVariablesForType("size")[0], i4 = [], o3 = [];
  let s4;
  if (n3.stops) {
    for (const e5 of n3.stops)
      i4.push(e5.value), o3.push(u(e5.size));
    s4 = n3.stops.length;
  } else
    i4.push(n3.minDataValue, n3.maxDataValue), o3.push(u(n3.minSize), u(n3.maxSize)), s4 = 2;
  return { kind: "ramp", stops: i4, values: o3, count: s4 };
}
function r4(e4) {
  if (!e4.hasVisualVariables("color"))
    return { kind: "constant", value: o2(e4.color) };
  const t6 = e4.getVisualVariablesForType("color")[0], n3 = [], i4 = [];
  for (const s4 of t6.stops)
    n3.push(s4.value), Array.prototype.push.apply(i4, o2(s4.color));
  return { kind: "ramp", stops: n3, values: i4, count: t6.stops.length };
}
function l3(e4) {
  if (!e4.hasVisualVariables("opacity"))
    return { kind: "constant", value: [1] };
  const t6 = e4.getVisualVariablesForType("opacity")[0], n3 = [], i4 = [];
  for (const o3 of t6.stops)
    n3.push(o3.value), i4.push(o3.opacity);
  return { kind: "ramp", stops: n3, values: i4, count: t6.stops.length };
}
function u2(e4, t6, n3, i4) {
  switch (t6) {
    case "int":
      e4.setUniform1iv(n3, i4);
      break;
    case "float":
      e4.setUniform1fv(n3, i4);
      break;
    case "vec2":
      e4.setUniform2fv(n3, i4);
      break;
    case "vec3":
      e4.setUniform3fv(n3, i4);
      break;
    case "vec4":
      e4.setUniform4fv(n3, i4);
  }
}
function c(e4, t6, n3, i4) {
  "constant" === i4.kind ? u2(e4, n3, `u_${t6}`, i4.value) : (u2(e4, "float", `u_${t6}_stops`, i4.stops), u2(e4, n3, `u_${t6}_values`, i4.values), e4.setUniform1i(`u_${t6}_count`, i4.count));
}
function p(e4, t6) {
  let n3 = true;
  return n3 = n3 && e4.collisions === t6.collisions, n3 = n3 && e4.density === t6.density, n3 = n3 && e4.interpolate === t6.interpolate, n3 = n3 && e4.lineCollisionWidth === t6.lineCollisionWidth, n3 = n3 && e4.lineSpacing === t6.lineSpacing, n3 = n3 && e4.maxTurnAngle === t6.maxTurnAngle, n3 = n3 && e4.minSpeedThreshold === t6.minSpeedThreshold, n3 = n3 && e4.segmentLength === t6.segmentLength, n3 = n3 && e4.smoothing === t6.smoothing, n3 = n3 && e4.velocityScale === t6.velocityScale, n3 = n3 && e4.verticesPerLine === t6.verticesPerLine, n3;
}
function f3(t6, n3) {
  return t6 === n3 || !(!r(t6) || !r(n3)) && t6.equals(n3);
}
function m3(e4, t6) {
  if (!p(e4.simulationSettings, t6.simulationSettings))
    return false;
  if (!f3(e4.timeExtent, t6.timeExtent))
    return false;
  let n3 = true;
  return n3 = n3 && e4.loadImagery === t6.loadImagery, n3 = n3 && e4.createFlowMesh === t6.createFlowMesh, n3 = n3 && e4.color.kind === t6.color.kind, n3 = n3 && e4.opacity.kind === t6.opacity.kind, n3 = n3 && e4.size.kind === t6.size.kind, n3;
}

// node_modules/@arcgis/core/views/2d/engine/flow/styles/Imagery.js
var d2 = class {
  constructor(t6) {
    this._params = t6, this.animated = false;
  }
  isCompatible(t6) {
    if (!(t6 instanceof d2))
      return false;
    if (!f3(this._params.timeExtent, t6._params.timeExtent))
      return false;
    let r5 = true;
    return r5 = r5 && this._params.loadImagery === t6._params.loadImagery, r5 = r5 && this._params.color.kind === t6._params.color.kind, r5 = r5 && this._params.opacity.kind === t6._params.opacity.kind, r5;
  }
  async load(a3, r5) {
    const { extent: e4, size: s4 } = a3;
    f(r5);
    const i4 = await this._params.loadImagery(e4, s4[0], s4[1], this._params.timeExtent, r5);
    return new g2(i4, { color: this._params.color, opacity: this._params.opacity });
  }
  render(t6, a3, e4) {
    const { context: s4 } = t6, { program: n3 } = e4;
    s4.setFaceCullingEnabled(false), s4.setBlendingEnabled(true), s4.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), s4.useProgram(n3), n3.setUniformMatrix3fv("u_dvsMat3", a3.dvsMat3), s4.bindTexture(e4.texture, 0), n3.setUniform1i("u_texture", 0), n3.setUniform1f("u_Min", e4.min), n3.setUniform1f("u_Max", e4.max), c(n3, "color", "vec4", this._params.color), c(n3, "opacity", "float", this._params.opacity), s4.bindVAO(e4.vertexArray), s4.drawArrays(E.TRIANGLE_STRIP, 0, 4);
  }
};
var u3 = /* @__PURE__ */ new Map();
u3.set("a_position", 0), u3.set("a_texcoord", 1);
var w3 = { geometry: [new t3("a_position", 2, C.UNSIGNED_SHORT, 0, 8), new t3("a_texcoord", 2, C.UNSIGNED_SHORT, 4, 8)] };
var x2 = { vsPath: "raster/flow/imagery", fsPath: "raster/flow/imagery", attributes: u3 };
var g2 = class {
  constructor(t6, a3) {
    this._flowData = t6, this._values = a3;
  }
  attach(t6) {
    const { context: a3 } = t6, { width: r5, height: s4 } = this._flowData, i4 = E3.createVertex(a3, F.STATIC_DRAW, new Uint16Array([0, 0, 0, 1, r5, 0, 1, 1, 0, s4, 0, 0, r5, s4, 1, 0])), o3 = new a(a3, u3, w3, { geometry: i4 }), f8 = [];
    "ramp" === this._values.color.kind && f8.push("vvColor"), "ramp" === this._values.opacity.kind && f8.push("vvOpacity");
    const d6 = t6.painter.materialManager.getProgram(x2, f8);
    let g4 = 1e6, y5 = -1e6;
    for (let e4 = 0; e4 < s4; e4++)
      for (let t7 = 0; t7 < r5; t7++)
        if (0 !== this._flowData.mask[e4 * r5 + t7]) {
          const a4 = this._flowData.data[2 * (e4 * r5 + t7) + 0], s5 = this._flowData.data[2 * (e4 * r5 + t7) + 1], i5 = Math.sqrt(a4 * a4 + s5 * s5);
          g4 = Math.min(g4, i5), y5 = Math.max(y5, i5);
        }
    const A = new Uint8Array(4 * r5 * s4);
    for (let e4 = 0; e4 < s4; e4++)
      for (let t7 = 0; t7 < r5; t7++)
        if (0 !== this._flowData.mask[e4 * r5 + t7]) {
          const a4 = this._flowData.data[2 * (e4 * r5 + t7) + 0], s5 = this._flowData.data[2 * (e4 * r5 + t7) + 1], i5 = (Math.sqrt(a4 * a4 + s5 * s5) - g4) / (y5 - g4);
          A[4 * (e4 * r5 + t7) + 0] = 255 * i5, A[4 * (e4 * r5 + t7) + 1] = 0, A[4 * (e4 * r5 + t7) + 2] = 0, A[4 * (e4 * r5 + t7) + 3] = 255;
        } else
          A[4 * (e4 * r5 + t7) + 0] = 0, A[4 * (e4 * r5 + t7) + 1] = 0, A[4 * (e4 * r5 + t7) + 2] = 0, A[4 * (e4 * r5 + t7) + 3] = 0;
    const E4 = new E2(a3, { pixelFormat: P.RGBA, internalFormat: P.RGBA, samplingMode: L.LINEAR, dataType: G.UNSIGNED_BYTE, wrapMode: D.CLAMP_TO_EDGE, flipped: true, width: r5, height: s4 }, A);
    this.vertexArray = o3, this.program = d6, this.texture = E4, this.min = g4, this.max = y5, this._flowData = null;
  }
  detach() {
    this.vertexArray.dispose(), this.texture.dispose();
  }
  get ready() {
    return this.program.isCompiled;
  }
};

// node_modules/@arcgis/core/views/2d/engine/flow/styles/Particles.js
var _ = class {
  constructor(t6) {
    this._params = t6;
  }
  get animated() {
    return this._params.flowSpeed > 0;
  }
  isCompatible(t6) {
    return t6 instanceof _ && m3(this._params, t6._params);
  }
  async load(e4, a3) {
    const { extent: s4, size: r5 } = e4;
    f(a3);
    const i4 = await this._params.loadImagery(s4, r5[0], r5[1], this._params.timeExtent, a3), { vertexData: o3, indexData: n3 } = await this._params.createFlowMesh("Particles", this._params.simulationSettings, i4, a3);
    return new c2(o3, n3, { color: this._params.color, opacity: this._params.opacity, size: this._params.size });
  }
  render(t6, e4, s4) {
    const { context: n3 } = t6, { program: m5 } = s4;
    n3.setFaceCullingEnabled(false), n3.setBlendingEnabled(true), n3.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), n3.useProgram(m5), m5.setUniform1f("u_time", e4.time), m5.setUniform1f("u_trailLength", this._params.trailLength), m5.setUniform1f("u_flowSpeed", this._params.flowSpeed), m5.setUniform1f("u_featheringSize", this._params.featheringSize), m5.setUniform1f("u_featheringOffset", this._params.featheringOffset), m5.setUniform1f("u_introFade", this._params.introFade ? 1 : 0), m5.setUniform1f("u_fadeToZero", this._params.fadeToZero ? 1 : 0), m5.setUniform1f("u_decayRate", this._params.decayRate), m5.setUniformMatrix3fv("u_dvsMat3", e4.dvsMat3), m5.setUniformMatrix3fv("u_displayViewMat3", e4.displayViewMat3), c(m5, "color", "vec4", this._params.color), c(m5, "opacity", "float", this._params.opacity), c(m5, "size", "float", this._params.size), n3.bindVAO(s4.vertexArray), n3.drawElements(E.TRIANGLES, s4.indexCount, C.UNSIGNED_INT, 0);
  }
};
var l4 = /* @__PURE__ */ new Map();
l4.set("a_xyts0", 0), l4.set("a_xyts1", 1), l4.set("a_typeIdDurationSeed", 2), l4.set("a_extrudeInfo", 3);
var h2 = { geometry: [new t3("a_xyts0", 4, C.FLOAT, 0, 64), new t3("a_xyts1", 4, C.FLOAT, 16, 64), new t3("a_typeIdDurationSeed", 4, C.FLOAT, 32, 64), new t3("a_extrudeInfo", 4, C.FLOAT, 48, 64)] };
var f4 = { vsPath: "raster/flow/particles", fsPath: "raster/flow/particles", attributes: l4 };
var c2 = class {
  constructor(t6, e4, a3) {
    this._vertexData = t6, this._indexData = e4, this._values = a3;
  }
  attach(t6) {
    const { context: e4 } = t6, a3 = E3.createVertex(e4, F.STATIC_DRAW, this._vertexData), r5 = E3.createIndex(e4, F.STATIC_DRAW, this._indexData), i4 = new a(e4, l4, h2, { geometry: a3 }, r5), o3 = [];
    "ramp" === this._values.color.kind && o3.push("vvColor"), "ramp" === this._values.opacity.kind && o3.push("vvOpacity"), "ramp" === this._values.size.kind && o3.push("vvSize");
    const p3 = t6.painter.materialManager.getProgram(f4, o3);
    this.vertexArray = i4, this.program = p3, this.indexCount = this._indexData.length, this._vertexData = null, this._indexData = null;
  }
  detach() {
    this.vertexArray.dispose();
  }
  get ready() {
    return this.program.isCompiled;
  }
};

// node_modules/@arcgis/core/views/2d/engine/flow/styles/Stack.js
var t4 = class {
  constructor(t6) {
    this._styles = t6;
  }
  get animated() {
    return this._styles.reduce((t6, s4) => t6 || s4.animated, false);
  }
  isCompatible(s4) {
    if (!(s4 instanceof t4))
      return false;
    if (this._styles.length !== s4._styles.length)
      return false;
    const e4 = this._styles.length;
    for (let t6 = 0; t6 < e4; t6++)
      if (!this._styles[t6].isCompatible(s4._styles[t6]))
        return false;
    return true;
  }
  async load(t6, e4) {
    const r5 = await Promise.all(this._styles.map((s4) => s4.load(t6, e4)));
    return new s3(r5);
  }
  render(t6, s4, e4) {
    for (let r5 = 0; r5 < this._styles.length; r5++)
      this._styles[r5].render(t6, s4, e4.resources[r5]);
  }
};
var s3 = class {
  constructor(t6) {
    this.resources = t6;
  }
  attach(t6) {
    for (const s4 of this.resources)
      s4.attach(t6);
  }
  detach() {
    for (const t6 of this.resources)
      t6.detach();
  }
  get ready() {
    return this.resources.reduce((t6, s4) => t6 && s4.ready, true);
  }
};

// node_modules/@arcgis/core/views/2d/engine/flow/styles/Streamlines.js
var _2 = class {
  constructor(t6) {
    this._params = t6;
  }
  get animated() {
    return this._params.flowSpeed > 0;
  }
  isCompatible(t6) {
    return t6 instanceof _2 && m3(this._params, t6._params);
  }
  async load(e4, a3) {
    const { extent: s4, size: r5 } = e4;
    f(a3);
    const i4 = await this._params.loadImagery(s4, r5[0], r5[1], this._params.timeExtent, a3), { vertexData: o3, indexData: n3 } = await this._params.createFlowMesh("Streamlines", this._params.simulationSettings, i4, a3);
    return new d3(o3, n3, { color: this._params.color, opacity: this._params.opacity, size: this._params.size });
  }
  render(t6, e4, s4) {
    const { context: n3 } = t6, { program: m5 } = s4;
    n3.setFaceCullingEnabled(false), n3.setBlendingEnabled(true), n3.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), n3.useProgram(m5), m5.setUniform1f("u_time", e4.time), m5.setUniform1f("u_trailLength", this._params.trailLength), m5.setUniform1f("u_flowSpeed", this._params.flowSpeed), m5.setUniform1f("u_featheringSize", this._params.featheringSize), m5.setUniform1f("u_featheringOffset", this._params.featheringOffset), m5.setUniform1f("u_introFade", this._params.introFade ? 1 : 0), m5.setUniform1f("u_fadeToZero", this._params.fadeToZero ? 1 : 0), m5.setUniform1f("u_decayRate", this._params.decayRate), m5.setUniformMatrix3fv("u_dvsMat3", e4.dvsMat3), m5.setUniformMatrix3fv("u_displayViewMat3", e4.displayViewMat3), c(m5, "color", "vec4", this._params.color), c(m5, "opacity", "float", this._params.opacity), c(m5, "size", "float", this._params.size), n3.bindVAO(s4.vertexArray), n3.drawElements(E.TRIANGLES, s4.indexCount, C.UNSIGNED_INT, 0);
  }
};
var l5 = /* @__PURE__ */ new Map();
l5.set("a_positionAndSide", 0), l5.set("a_timeInfo", 1), l5.set("a_extrude", 2), l5.set("a_speed", 3);
var h3 = { geometry: [new t3("a_positionAndSide", 3, C.FLOAT, 0, 36), new t3("a_timeInfo", 3, C.FLOAT, 12, 36), new t3("a_extrude", 2, C.FLOAT, 24, 36), new t3("a_speed", 1, C.FLOAT, 32, 36)] };
var f5 = { vsPath: "raster/flow/streamlines", fsPath: "raster/flow/streamlines", attributes: l5 };
var d3 = class {
  constructor(t6, e4, a3) {
    this._vertexData = t6, this._indexData = e4, this._values = a3;
  }
  attach(t6) {
    const { context: e4 } = t6, a3 = E3.createVertex(e4, F.STATIC_DRAW, this._vertexData), r5 = E3.createIndex(e4, F.STATIC_DRAW, this._indexData), i4 = new a(e4, l5, h3, { geometry: a3 }, r5), o3 = [];
    "ramp" === this._values.color.kind && o3.push("vvColor"), "ramp" === this._values.opacity.kind && o3.push("vvOpacity"), "ramp" === this._values.size.kind && o3.push("vvSize");
    const p3 = t6.painter.materialManager.getProgram(f5, o3);
    this.vertexArray = i4, this.program = p3, this.indexCount = this._indexData.length, this._vertexData = null, this._indexData = null;
  }
  detach() {
    this.vertexArray.dispose();
  }
  get ready() {
    return this.program.isCompiled;
  }
};

// node_modules/@arcgis/core/views/2d/engine/flow/createFlowStyle.js
var f6 = 4;
var p2 = 1;
var u4 = 0.5;
var y2 = true;
var d4 = true;
var g3 = 2.3;
function w4(w5, h6) {
  const { flowSpeed: j2, trailLength: v } = w5, S = n2(w5);
  let k = null;
  const x3 = { opacity: l3(w5), size: a2(w5) };
  let I2 = r4(w5);
  if ("none" === w5.background)
    x3.color = I2;
  else {
    "constant" === I2.kind && (I2 = { kind: "ramp", stops: [0, 1], values: [0, 0, 0, 1, I2.value[0], I2.value[1], I2.value[2], I2.value[3]], count: 2 });
    const e4 = { loadImagery: h6.loadImagery, timeExtent: h6.timeExtent, color: I2, opacity: { kind: "constant", value: [1] } };
    k = new d2(e4), x3.color = s2();
  }
  const z = { loadImagery: h6.loadImagery, createFlowMesh: h6.createFlowMesh, simulationSettings: S, timeExtent: h6.timeExtent, trailLength: v, flowSpeed: j2, featheringSize: p2, featheringOffset: u4, introFade: y2, fadeToZero: d4, decayRate: g3, color: x3.color, opacity: x3.opacity, size: x3.size }, E4 = "butt" === w5.trailCap || i3(a2(w5)) <= f6 ? new _2(z) : new _(z);
  return r(k) ? new t4([k, E4]) : E4;
}

// node_modules/@arcgis/core/views/2d/engine/flow/FlowContainer.js
var t5 = class extends o {
  constructor() {
    super(...arguments), this.flowStyle = null;
  }
  get requiresDedicatedFBO() {
    return false;
  }
  doRender(e4) {
    super.doRender(e4);
  }
  prepareRenderPasses(s4) {
    const t6 = s4.registerRenderPass({ name: "flow", brushes: [i2], target: () => this.children, drawPhase: I.MAP });
    return [...super.prepareRenderPasses(s4), t6];
  }
};

// node_modules/@arcgis/core/views/2d/engine/flow/FlowDisplayData.js
var e3 = class {
  constructor(t6, e4, s4, a3) {
    this.state = { name: "created" }, this.flowStyle = t6, this.extent = e4, this.size = s4, this.pixelRatio = a3;
  }
  async load() {
    const t6 = new AbortController();
    this.state = { name: "loading", abortController: t6 };
    const e4 = { extent: this.extent, size: this.size, pixelRatio: this.pixelRatio }, s4 = await this.flowStyle.load(e4, t6.signal);
    this.state = { name: "loaded", resources: s4 };
  }
  attach(e4) {
    if ("loaded" !== this.state.name)
      return void s.getLogger("esri.views.2d.engine.flow.FlowDisplayData").error("Only loaded resources can be attached.");
    const s4 = this.state.resources;
    s4.attach(e4), this.state = { name: "attached", resources: s4 };
  }
  detach() {
    if ("loading" === this.state.name)
      return this.state.abortController.abort(), void (this.state = { name: "detached" });
    "attached" === this.state.name && (this.state.resources.detach(), this.state = { name: "detached" });
  }
  update(t6) {
    if (!this.flowStyle.isCompatible(t6.flowStyle))
      return false;
    return !(!this.extent.equals(t6.extent) || this.size[0] !== t6.size[0] || this.size[1] !== t6.size[1] || this.pixelRatio !== t6.pixelRatio) && (this.flowStyle = t6.flowStyle, true);
  }
};

// node_modules/@arcgis/core/views/2d/engine/flow/FlowDisplayObject.js
var m4 = class extends r3 {
  constructor() {
    super(...arguments), this._displayData = null;
  }
  get displayData() {
    return this._displayData;
  }
  set displayData(t6) {
    this._displayData = t6, this.requestRender();
  }
  clear() {
    r(this._displayData) && (this._displayData.detach(), this._displayData = null, this.requestRender());
  }
  setTransform(s4) {
    const { displayData: n3 } = this;
    if (t(n3))
      return;
    const l6 = n3.extent.xmin, m5 = n3.extent.ymax, p3 = [0, 0];
    s4.toScreen(p3, [l6, m5]);
    const c3 = (n3.extent.xmax - n3.extent.xmin) / n3.size[0] / s4.resolution, d6 = m(s4.rotation), { dvs: h6 } = this.transforms;
    l2(h6, [-1, 1, 0]), f2(h6, h6, [2 / (s4.size[0] * s4.pixelRatio), -2 / (s4.size[1] * s4.pixelRatio), 1]), M(h6, h6, [p3[0], p3[1], 0]), h(h6, h6, d6), f2(h6, h6, [c3 * s4.pixelRatio, c3 * s4.pixelRatio, 1]);
  }
  _createTransforms() {
    return { dvs: e2() };
  }
};

// node_modules/@arcgis/core/views/2d/engine/flow/FlowStrategy.js
var h4 = 1.15;
var y3 = class extends m2 {
  constructor(t6) {
    super(t6), this._flowDisplayObject = new m4(), this._loading = null;
  }
  initialize() {
    this.flowContainer.addChild(this._flowDisplayObject);
  }
  destroy() {
    this._clear(), this.flowContainer.removeAllChildren();
  }
  get updating() {
    return null != this._loading;
  }
  update(t6) {
    const { flowStyle: o3 } = this.flowContainer;
    if (t(o3))
      return void this._clear();
    const { extent: i4, rotation: l6, resolution: n3, pixelRatio: p3 } = t6.state, m5 = u5(i4, l6);
    m5.expand(h4);
    const d6 = [Math.round((m5.xmax - m5.xmin) / n3), Math.round((m5.ymax - m5.ymin) / n3)], y5 = new e3(o3, m5, d6, p3);
    if (r(this._loading)) {
      if (this._loading.update(y5))
        return;
      this._loading.detach(), this._loading = null;
    }
    !t(this._flowDisplayObject.displayData) && this._flowDisplayObject.displayData.update(y5) || (y5.load().then(() => {
      this._flowDisplayObject.clear(), this._flowDisplayObject.displayData = this._loading, this._loading = null;
    }, (t7) => {
      j(t7) || (s.getLogger(this.declaredClass).error("A resource failed to load.", t7), this._loading = null);
    }), this._loading = y5);
  }
  _clear() {
    this._flowDisplayObject.clear(), r(this._loading) && (this._loading.detach(), this._loading = null);
  }
};
e([y()], y3.prototype, "_loading", void 0), e([y()], y3.prototype, "flowContainer", void 0), e([y()], y3.prototype, "updating", null), y3 = e([n("esri.views.2d.engine.flow.FlowStrategy")], y3);
var f7 = y3;
function u5(t6, o3) {
  const e4 = new w({ x: (t6.xmax + t6.xmin) / 2, y: (t6.ymax + t6.ymin) / 2, spatialReference: t6.spatialReference }), s4 = t6.xmax - t6.xmin, r5 = t6.ymax - t6.ymin, a3 = Math.abs(Math.cos(m(o3))), l6 = Math.abs(Math.sin(m(o3))), n3 = a3 * s4 + l6 * r5, c3 = l6 * s4 + a3 * r5, m5 = new w2({ xmin: e4.x - n3 / 2, ymin: e4.y - c3 / 2, xmax: e4.x + n3 / 2, ymax: e4.y + c3 / 2, spatialReference: t6.spatialReference });
  return m5.centerAt(e4), m5;
}

// node_modules/@arcgis/core/views/2d/engine/flow/FlowView2D.js
var h5 = class extends d {
  constructor() {
    super(...arguments), this._loadImagery = (t6, e4, i4, r5, o3) => x(this.layer, t6, e4, i4, r5, o3), this._createFlowMesh = (t6, e4, i4, r5) => this.layer.createFlowMesh({ meshType: t6, flowData: i4, simulationSettings: e4 }, { signal: r5 }), this.attached = false, this.container = null, this.layer = null, this.type = "flow", this.timeExtent = null, this.redrawOrRefetch = async () => {
      this._updateVisualization();
    };
  }
  get updating() {
    return !this._strategy || this._strategy.updating;
  }
  attach() {
    const { layer: t6 } = this, e4 = () => {
      this._loadImagery = (e5, i4, r5, o3, s4) => x(t6, e5, i4, r5, o3, s4), this._updateVisualization();
    };
    "multidimensionalDefinition" in t6 ? this.handles.add(l(() => t6.multidimensionalDefinition, e4)) : this.handles.add([l(() => t6.mosaicRule, e4), l(() => t6.renderingRule, e4), l(() => t6.definitionExpression, e4)]), this.container = new t5(), this._strategy = new f7({ flowContainer: this.container }), this._updateVisualization();
  }
  detach() {
    this._strategy.destroy(), this.container.removeAllChildren(), this.container = null, this.handles.removeAll();
  }
  update(t6) {
    t6.stationary ? this._strategy.update(t6) : this.layerView.requestUpdate();
  }
  hitTest(t6) {
    return new g({ attributes: {}, geometry: t6.clone(), layer: this.layer });
  }
  moveEnd() {
  }
  async doRefresh() {
  }
  _updateVisualization() {
    const { renderer: t6 } = this.layer;
    if ("flow" !== t6.type)
      return;
    const e4 = w4(t6, { loadImagery: this._loadImagery, createFlowMesh: this._createFlowMesh, timeExtent: this.timeExtent });
    this.container.flowStyle = e4, this.layerView.requestUpdate();
  }
};
e([y()], h5.prototype, "_strategy", void 0), e([y()], h5.prototype, "attached", void 0), e([y()], h5.prototype, "container", void 0), e([y()], h5.prototype, "layer", void 0), e([y()], h5.prototype, "layerView", void 0), e([y()], h5.prototype, "type", void 0), e([y()], h5.prototype, "updating", null), e([y()], h5.prototype, "timeExtent", void 0), h5 = e([n("esri.views.2d.engine.flow.FlowView2D")], h5);
var d5 = h5;

// node_modules/@arcgis/core/views/2d/engine/imagery/RasterVFDisplayObject.js
var y4 = class extends r3 {
  constructor(t6 = null) {
    super(), this._source = null, this._symbolizerParameters = null, this._vaoInvalidated = true, this.coordScale = [1, 1], this.height = null, this.stencilRef = 0, this.resolution = null, this.pixelRatio = 1, this.x = 0, this.y = 0, this.rotation = 0, this.rawPixelData = null, this.width = null, this.source = t6;
  }
  destroy() {
    var _a, _b;
    r(this.vaoData) && ((_a = this.vaoData.magdir) == null ? void 0 : _a.vao.dispose(), (_b = this.vaoData.scalar) == null ? void 0 : _b.vao.dispose(), this.vaoData = null);
  }
  get symbolizerParameters() {
    return this._symbolizerParameters;
  }
  set symbolizerParameters(t6) {
    JSON.stringify(this._symbolizerParameters) !== JSON.stringify(t6) && (this._symbolizerParameters = t6, this.invalidateVAO());
  }
  get source() {
    return this._source;
  }
  set source(t6) {
    this._source = t6, this.invalidateVAO();
  }
  invalidateVAO() {
    var _a, _b;
    !this._vaoInvalidated && r(this.vaoData) && ((_a = this.vaoData.magdir) == null ? void 0 : _a.vao.dispose(), (_b = this.vaoData.scalar) == null ? void 0 : _b.vao.dispose(), this.vaoData = null, this._vaoInvalidated = true, this.requestRender());
  }
  updateVectorFieldVAO(s4) {
    if (this._vaoInvalidated) {
      if (this._vaoInvalidated = false, r(this.source) && t(this.vaoData)) {
        const { style: t6 } = this.symbolizerParameters;
        switch (t6) {
          case "beaufort_ft":
          case "beaufort_km":
          case "beaufort_kn":
          case "beaufort_m":
          case "beaufort_mi":
          case "classified_arrow":
          case "ocean_current_kn":
          case "ocean_current_m":
          case "single_arrow":
            {
              const t7 = F2(this.source, this.symbolizerParameters), e4 = this._createVectorFieldVAO(s4.context, t7);
              this.vaoData = { magdir: e4 };
            }
            break;
          case "simple_scalar":
            {
              const t7 = D2(this.source, this.symbolizerParameters), e4 = this._createVectorFieldVAO(s4.context, t7);
              this.vaoData = { scalar: e4 };
            }
            break;
          case "wind_speed": {
            const t7 = F2(this.source, this.symbolizerParameters), e4 = this._createVectorFieldVAO(s4.context, t7), a3 = D2(this.source, this.symbolizerParameters), r5 = this._createVectorFieldVAO(s4.context, a3);
            this.vaoData = { magdir: e4, scalar: r5 };
          }
        }
      }
      this.ready(), this.requestRender();
    }
  }
  _createTransforms() {
    return { dvs: e2() };
  }
  setTransform(t6) {
    const e4 = r2(this.transforms.dvs), [n3, l6] = t6.toScreenNoRotation([0, 0], [this.x, this.y]), h6 = this.resolution / this.pixelRatio / t6.resolution, m5 = h6 * this.width, u6 = h6 * this.height, d6 = Math.PI * this.rotation / 180;
    M(e4, e4, t2(n3, l6)), M(e4, e4, t2(m5 / 2, u6 / 2)), h(e4, e4, -d6), M(e4, e4, t2(-m5 / 2, -u6 / 2)), b(e4, e4, t2(m5, u6)), i(this.transforms.dvs, t6.displayViewMat3, e4);
  }
  onAttach() {
    this.invalidateVAO();
  }
  onDetach() {
    this.invalidateVAO();
  }
  _createVectorFieldVAO(t6, e4) {
    const { vertexData: s4, indexData: a3 } = e4, r5 = E3.createVertex(t6, F.STATIC_DRAW, new Float32Array(s4)), i4 = E3.createIndex(t6, F.STATIC_DRAW, new Uint32Array(a3)), o3 = ge("vector-field", { geometry: [{ location: 0, name: "a_pos", count: 2, type: C.FLOAT, normalized: false }, { location: 1, name: "a_offset", count: 2, type: C.FLOAT, normalized: false }, { location: 2, name: "a_vv", count: 2, type: C.FLOAT, normalized: false }] });
    return { vao: new a(t6, o3.attributes, o3.bufferLayouts, { geometry: r5 }, i4), elementCount: a3.length };
  }
};

export {
  d5 as d,
  y4 as y
};
//# sourceMappingURL=chunk-A2S4JS7P.js.map
