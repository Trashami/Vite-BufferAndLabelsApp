import {
  D,
  F,
  N,
  S,
  T,
  V,
  c,
  d,
  f,
  m as m2,
  x
} from "./chunk-K3WMIXIE.js";
import {
  O
} from "./chunk-I4YZGF7W.js";
import "./chunk-65ZBTSJX.js";
import {
  m,
  y
} from "./chunk-INL7BDTP.js";
import "./chunk-W62B63EU.js";
import "./chunk-NDQ5FHGV.js";
import "./chunk-376OPXM4.js";
import {
  i
} from "./chunk-DER356EU.js";
import {
  u
} from "./chunk-NRP45AHD.js";
import "./chunk-IWQ7452U.js";
import "./chunk-NAN5J6QS.js";
import "./chunk-RAX2HD42.js";
import "./chunk-ZYRIJWLX.js";
import "./chunk-C5H57NTD.js";
import "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import "./chunk-YWAQYJRC.js";
import "./chunk-B356PXLT.js";
import "./chunk-EHPBHJYZ.js";
import "./chunk-3MNMDUQZ.js";
import {
  w
} from "./chunk-UWG37XSU.js";
import {
  R,
  k2 as k,
  p
} from "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import "./chunk-HLM6QCL2.js";
import "./chunk-RXYULINL.js";
import "./chunk-VWYWOOPX.js";
import "./chunk-M5VHU5LK.js";
import "./chunk-7QMMKGW4.js";
import "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import "./chunk-MJXQTGI2.js";
import "./chunk-LIZHLHNA.js";
import "./chunk-BTUHYGXO.js";
import "./chunk-UA3YPL2R.js";
import "./chunk-HVKDYDPP.js";
import "./chunk-6QC7MLLS.js";
import {
  e
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/smartMapping/statistics/support/utils.js
var y2 = null;
function $(e2, t, n) {
  return e2.x < 0 ? e2.x += t : e2.x > n && (e2.x -= t), e2;
}
function I(e2, n, r2, i2) {
  const a = p(r2) ? R(r2) : null, u2 = a ? Math.round((a.valid[1] - a.valid[0]) / n.scale[0]) : null;
  return e2.map((e3) => {
    const r3 = new w(e(e3.geometry));
    return O(n, r3, r3, r3.hasZ, r3.hasM), e3.geometry = a ? $(r3, u2, i2[0]) : r3, e3;
  });
}
function g(e2, t = 18, n, i2, o, s2) {
  const l = new Float64Array(o * s2);
  t = Math.round(u(t));
  let a = Number.POSITIVE_INFINITY, u2 = Number.NEGATIVE_INFINITY, m3 = 0, d3 = 0, p3 = 0, h = 0;
  const y3 = y(i2, n);
  for (const { geometry: r2, attributes: c3 } of e2) {
    const { x: e3, y: n2 } = r2, i3 = Math.max(0, e3 - t), $3 = Math.max(0, n2 - t), I2 = Math.min(s2, n2 + t), g2 = Math.min(o, e3 + t), j2 = +y3(c3);
    for (let r3 = $3; r3 < I2; r3++)
      for (let s3 = i3; s3 < g2; s3++) {
        const i4 = r3 * o + s3, c4 = m(s3 - e3, r3 - n2, t), y4 = l[i4];
        m3 = l[i4] += c4 * j2;
        const $4 = m3 - y4;
        d3 += $4, p3 += $4 * $4, m3 < a && (a = m3), m3 > u2 && (u2 = m3), h++;
      }
  }
  if (!h)
    return { mean: 0, stddev: 0, min: 0, max: 0, mid: 0, count: 0 };
  const $2 = (u2 - a) / 2;
  return { mean: d3 / h, stdDev: Math.sqrt((p3 - d3 * d3 / h) / h), min: a, max: u2, mid: $2, count: h };
}
async function j(e2, t) {
  if (!t)
    return [];
  const { field: n, field2: r2, field3: o, fieldDelimiter: s2 } = e2, l = e2.valueExpression, a = e2.normalizationType, u2 = e2.normalizationField, f2 = e2.normalizationTotal, c3 = [], h = e2.viewInfoParams;
  let $2 = null, I2 = null;
  if (l) {
    if (!y2) {
      const { arcadeUtils: e3 } = await i();
      y2 = e3;
    }
    $2 = y2.createFunction(l), I2 = h && y2.getViewInfo({ viewingMode: h.viewingMode, scale: h.scale, spatialReference: new k(h.spatialReference) });
  }
  const g2 = e2.fieldInfos, j2 = !(t[0] && "declaredClass" in t[0] && "esri.Graphic" === t[0].declaredClass) && g2 ? { fields: g2 } : null;
  return t.forEach((e3) => {
    const t2 = e3.attributes;
    let i2;
    if (l) {
      const t3 = j2 ? { ...e3, layer: j2 } : e3, n2 = y2.createExecContext(t3, I2);
      i2 = y2.executeFunction($2, n2);
    } else
      t2 && (i2 = t2[n], r2 && (i2 = `${c(i2)}${s2}${c(t2[r2])}`, o && (i2 = `${i2}${s2}${c(t2[o])}`)));
    if (a && "number" == typeof i2 && isFinite(i2)) {
      const e4 = t2 && parseFloat(t2[u2]);
      i2 = x(i2, a, e4, f2);
    }
    c3.push(i2);
  }), c3;
}

// node_modules/@arcgis/core/smartMapping/statistics/support/statsWorker.js
async function d2(i2) {
  const { attribute: e2, features: s2 } = i2, { normalizationType: r2, normalizationField: m3, minValue: f2, maxValue: u2, fieldType: d3 } = e2, p3 = await j({ field: e2.field, valueExpression: e2.valueExpression, normalizationType: r2, normalizationField: m3, normalizationTotal: e2.normalizationTotal, viewInfoParams: e2.viewInfoParams, fieldInfos: e2.fieldInfos }, s2), v2 = m2({ normalizationType: r2, normalizationField: m3, minValue: f2, maxValue: u2 }), c3 = { value: 0.5, fieldType: d3 }, z2 = "esriFieldTypeString" === d3 ? f({ values: p3, supportsNullCount: v2, percentileParams: c3 }) : d({ values: p3, minValue: f2, maxValue: u2, useSampleStdDev: !r2, supportsNullCount: v2, percentileParams: c3 });
  return V(z2, "esriFieldTypeDate" === d3);
}
async function p2(i2) {
  const { attribute: e2, features: n } = i2, l = await j({ field: e2.field, field2: e2.field2, field3: e2.field3, fieldDelimiter: e2.fieldDelimiter, valueExpression: e2.valueExpression, viewInfoParams: e2.viewInfoParams, fieldInfos: e2.fieldInfos }, n), t = T(l);
  return F(t, e2.domains, e2.returnAllCodedValues, e2.fieldDelimiter);
}
async function v(i2) {
  const { attribute: e2, features: n } = i2, { field: l, normalizationType: t, normalizationField: o, normalizationTotal: s2, classificationMethod: r2 } = e2, u2 = await j({ field: l, valueExpression: e2.valueExpression, normalizationType: t, normalizationField: o, normalizationTotal: s2, viewInfoParams: e2.viewInfoParams, fieldInfos: e2.fieldInfos }, n), d3 = D(u2, { field: l, normalizationType: t, normalizationField: o, normalizationTotal: s2, classificationMethod: r2, standardDeviationInterval: e2.standardDeviationInterval, numClasses: e2.numClasses, minValue: e2.minValue, maxValue: e2.maxValue });
  return N(d3, r2);
}
async function c2(i2) {
  const { attribute: e2, features: n } = i2, { field: l, normalizationType: t, normalizationField: o, normalizationTotal: s2, classificationMethod: r2 } = e2, m3 = await j({ field: l, valueExpression: e2.valueExpression, normalizationType: t, normalizationField: o, normalizationTotal: s2, viewInfoParams: e2.viewInfoParams, fieldInfos: e2.fieldInfos }, n);
  return S(m3, { field: l, normalizationType: t, normalizationField: o, normalizationTotal: s2, classificationMethod: r2, standardDeviationInterval: e2.standardDeviationInterval, numBins: e2.numBins, minValue: e2.minValue, maxValue: e2.maxValue });
}
async function z(a) {
  const { attribute: n, features: l } = a, { field: t, radius: o, fieldOffset: s2, transform: r2, spatialReference: m3, size: f2 } = n, u2 = I(l, r2, m3, f2), { count: d3, min: p3, max: v2, mean: c3, stdDev: z2 } = g(u2, o, s2, t, f2[0], f2[1]);
  return { count: d3, min: p3, max: v2, avg: c3, stddev: z2 };
}
export {
  v as classBreaks,
  z as heatmapStatistics,
  c2 as histogram,
  d2 as summaryStatistics,
  p2 as uniqueValues
};
//# sourceMappingURL=statsWorker-W42LOGAT.js.map
