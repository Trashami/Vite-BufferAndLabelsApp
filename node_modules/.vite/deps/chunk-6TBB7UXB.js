import {
  x
} from "./chunk-UO3LS2M5.js";
import {
  E,
  L,
  S
} from "./chunk-EQNT4A7P.js";
import {
  e as e2,
  n
} from "./chunk-QISOH77W.js";
import {
  t as t2
} from "./chunk-4OM3EX6P.js";
import {
  C,
  F,
  G
} from "./chunk-3OFVLRSL.js";
import {
  e
} from "./chunk-U2XHEJM7.js";
import {
  s as s2
} from "./chunk-LIZHLHNA.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";
import {
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/color.js
function i(r, n2 = 0, t3 = false) {
  const o = r[n2 + 3];
  return r[n2 + 0] *= o, r[n2 + 1] *= o, r[n2 + 2] *= o, t3 || (r[n2 + 3] *= 255), r;
}
function f(r) {
  if (!r)
    return 0;
  const { r: t3, g: o, b: u2, a: i2 } = r;
  return x(t3 * i2, o * i2, u2 * i2, 255 * i2);
}
function s3(r) {
  if (!r)
    return 0;
  const [t3, o, u2, i2] = r;
  return x(t3 * (i2 / 255), o * (i2 / 255), u2 * (i2 / 255), i2);
}
function a(n2, t3, o = 0) {
  if (t(t3))
    return n2[o + 0] = 0, n2[o + 1] = 0, n2[o + 2] = 0, void (n2[o + 3] = 0);
  const { r: u2, g: i2, b: c3, a: e3 } = t3;
  n2[o + 0] = u2 * e3 / 255, n2[o + 1] = i2 * e3 / 255, n2[o + 2] = c3 * e3 / 255, n2[o + 3] = e3;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/SymbolProperties.js
var h = class {
  constructor() {
    this.color = [0, 0, 0, 0], this.haloColor = [0, 0, 0, 0], this.haloSize = 0, this.size = 12, this.angle = 0, this.offsetX = 0, this.offsetY = 0, this.hAnchor = 0, this.vAnchor = 0;
  }
  acquire(o, h2, s4, t3, i2, l, r, e3, c3) {
    this.color = o, this.haloColor = h2, this.haloSize = s4, this.size = t3, this.angle = i2, this.offsetX = l, this.offsetY = r, this.hAnchor = e3, this.vAnchor = c3;
  }
  release() {
    this.color[0] = this.color[1] = this.color[2] = this.color[3] = 0, this.haloColor[0] = this.haloColor[1] = this.haloColor[2] = this.haloColor[3] = 0, this.haloSize = 0, this.size = 0, this.angle = 0, this.offsetX = 0, this.offsetY = 0, this.hAnchor = 0, this.vAnchor = 0;
  }
};
h.pool = new e(h);

// node_modules/@arcgis/core/views/2d/engine/webgl/Utils.js
var E3 = s.getLogger("esri.views.2d.engine.webgl.Utils");
var S2 = "geometry";
var A = [{ name: S2, strideInBytes: 36 }];
var N = [{ name: S2, strideInBytes: 12 }];
var M2 = [{ name: S2, strideInBytes: 36 }];
var D2 = [{ name: S2, strideInBytes: 24 }];
var _ = [{ name: S2, strideInBytes: 12 }];
var U = [{ name: S2, strideInBytes: 40 }];
var v = [{ name: S2, strideInBytes: 36 }];
var R = [{ name: S2, strideInBytes: 36 }];
function B(e3) {
  const t3 = {};
  for (const r of e3)
    t3[r.name] = r.strideInBytes;
  return t3;
}
var C2 = B(A);
var b = B(N);
var O = B(M2);
var F2 = B(D2);
var x2 = B(_);
var z = B(U);
var P2 = B(v);
var j = B(R);
function G2(e3, t3) {
  switch (e3) {
    case E.MARKER:
      return t3 === S.HEATMAP ? b : C2;
    case E.FILL:
      switch (t3) {
        case S.DOT_DENSITY:
          return x2;
        case S.SIMPLE:
        case S.OUTLINE_FILL_SIMPLE:
          return F2;
        default:
          return O;
      }
    case E.LINE:
      return z;
    case E.TEXT:
      return P2;
    case E.LABEL:
      return j;
  }
}
var $ = [S2];
var k = [S2];
var V = [S2];
var Y = [S2];
var H = [S2];
function q(e3) {
  switch (e3) {
    case E.MARKER:
      return $;
    case E.FILL:
      return k;
    case E.LINE:
      return V;
    case E.TEXT:
      return Y;
    case E.LABEL:
      return H;
  }
}
function X(e3) {
  switch (e3 % 4) {
    case 0:
    case 2:
      return 4;
    case 1:
    case 3:
      return 1;
  }
}
function K(e3, t3) {
  switch (t3 % 4) {
    case 0:
    case 2:
      return new Uint32Array(Math.floor(e3 * t3 / 4));
    case 1:
    case 3:
      return new Uint8Array(e3 * t3);
  }
}
function W(e3, t3) {
  switch (t3 % 4) {
    case 0:
    case 2:
      return new Uint32Array(e3);
    case 1:
    case 3:
      return new Uint8Array(e3);
  }
}
function J(e3) {
  return null != e3;
}
function Q(e3) {
  return "number" == typeof e3;
}
function ee(t3) {
  switch (t3) {
    case "butt":
      return e2.BUTT;
    case "round":
      return e2.ROUND;
    case "square":
      return e2.SQUARE;
    default:
      return E3.error(new s2("mapview-invalid-type", `Cap type ${t3} is not a valid option. Defaulting to round`)), e2.ROUND;
  }
}
function te(t3) {
  switch (t3) {
    case "miter":
      return n.MITER;
    case "bevel":
      return n.BEVEL;
    case "round":
      return n.ROUND;
    default:
      return E3.error(new s2("mapview-invalid-type", `Join type ${t3} is not a valid option. Defaulting to round`)), n.ROUND;
  }
}
function re(e3) {
  switch (e3) {
    case "opacity":
      return L.OPACITY;
    case "color":
      return L.COLOR;
    case "rotation":
      return L.ROTATION;
    case "size":
      return L.SIZE;
    default:
      return E3.error(`Cannot interpret unknown vv: ${e3}`), null;
  }
}
function ae(e3, t3, r, n2, a2, s4, i2) {
  for (const c3 in s4) {
    const t4 = s4[c3].stride, n3 = X(t4), i3 = s4[c3].data, o2 = r[c3].data, u2 = t4 * a2.vertexCount / n3, l = t4 * e3 / n3, m = t4 * a2.vertexFrom / n3;
    for (let e4 = 0; e4 < u2; ++e4)
      o2[e4 + l] = i3[e4 + m];
  }
  const o = a2.indexCount;
  for (let c3 = 0; c3 < o; ++c3)
    n2[c3 + t3] = i2[c3 + a2.indexFrom] - a2.vertexFrom + e3;
}
var se = { [S2]: F.STATIC_DRAW };
function ie(e3, t3) {
  const r = [];
  for (let n2 = 0; n2 < 5; ++n2) {
    const a2 = q(n2), s4 = {};
    for (const e4 of a2)
      s4[e4] = { data: t3(n2, e4) };
    r.push({ data: e3(n2), buffers: s4 });
  }
  return r;
}
function ue(e3) {
  switch (e3) {
    case C.BYTE:
    case C.UNSIGNED_BYTE:
      return 1;
    case C.SHORT:
    case C.UNSIGNED_SHORT:
      return 2;
    case C.FLOAT:
    case C.INT:
    case C.UNSIGNED_INT:
      return 4;
  }
}
function le(t3) {
  switch (t3) {
    case G.UNSIGNED_BYTE:
      return 1;
    case G.UNSIGNED_SHORT_4_4_4_4:
      return 2;
    case G.FLOAT:
      return 4;
    default:
      return void E3.error(new s2("webgl-utils", `Unable to handle type ${t3}`));
  }
}
function me(t3) {
  switch (t3) {
    case G.UNSIGNED_BYTE:
      return Uint8Array;
    case G.UNSIGNED_SHORT_4_4_4_4:
      return Uint16Array;
    case G.FLOAT:
      return Float32Array;
    default:
      return void E3.error(new s2("webgl-utils", `Unable to handle type ${t3}`));
  }
}
function fe(e3) {
  const t3 = {};
  for (const r in e3) {
    const n2 = e3[r];
    let a2 = 0;
    t3[r] = n2.map((e4) => {
      const t4 = new t2(e4.name, e4.count, e4.type, a2, 0, e4.normalized || false);
      return a2 += e4.count * ue(e4.type), t4;
    }), t3[r].forEach((e4) => e4.stride = a2);
  }
  return t3;
}
var pe = (e3) => {
  const t3 = /* @__PURE__ */ new Map();
  for (const r in e3)
    for (const n2 of e3[r])
      t3.set(n2.name, n2.location);
  return t3;
};
var de = (e3) => {
  const t3 = {};
  for (const r in e3) {
    const n2 = e3[r];
    t3[r] = n2.length ? n2[0].stride : 0;
  }
  return t3;
};
var ye = /* @__PURE__ */ new Map();
var ge = (e3, t3) => {
  if (!ye.has(e3)) {
    const r = fe(t3), n2 = { strides: de(r), bufferLayouts: r, attributes: pe(t3) };
    ye.set(e3, n2);
  }
  return ye.get(e3);
};
function he(e3) {
  e3(E.FILL), e3(E.LINE), e3(E.MARKER), e3(E.TEXT), e3(E.LABEL);
}
var Ie = (e3) => "path" in e3 && Re(e3.path);
var Te = (e3) => "url" in e3 && e3.url || "imageData" in e3 && e3.imageData;
var Ee = (e3) => "imageData" in e3 && e3.imageData && "contentType" in e3 && e3.contentType ? `data:${e3.contentType};base64,${e3.imageData}` : "url" in e3 ? e3.url : null;
var Se = (e3) => e3.startsWith("data:image/gif");
var we = (e3) => "url" in e3 && e3.url && (e3.url.includes(".gif") || Se(e3.url)) || "contentType" in e3 && "image/gif" === e3.contentType || "imageData" in e3 && Se(e3.imageData);
var Le = (e3) => e3.startsWith("data:image/png");
var Ae = (e3) => "url" in e3 && e3.url && (e3.url.includes(".png") || Le(e3.url)) || "contentType" in e3 && "image/png" === e3.contentType || "imageData" in e3 && Le(e3.imageData);
var Ne = (e3) => e3.type && e3.type.toLowerCase().includes("3d");
function Me(e3) {
  switch (e3.type) {
    case "line": {
      const t3 = e3;
      return "CIMSolidStroke" === t3.cim.type && !t3.dashTemplate;
    }
    case "fill":
      return "CIMSolidFill" === e3.cim.type;
    case "esriSFS":
      return "esriSFSSolid" === e3.style || "esriSFSNull" === e3.style;
    case "esriSLS":
      return "esriSLSSolid" === e3.style || "esriSLSNull" === e3.style;
    default:
      return false;
  }
}
var De = (e3) => e3.includes("data:image/svg+xml");
function _e(e3) {
  switch ("cim" in e3 ? e3.cim.type : e3.type) {
    case "esriSMS":
    case "esriPMS":
    case "CIMPointSymbol":
      return false;
    case "CIMVectorMarker":
    case "CIMCharacterMarker":
    case "CIMPictureMarker":
      return Be(e3);
    default:
      return true;
  }
}
function Ue(e3) {
  const t3 = "maxVVSize" in e3 && e3.maxVVSize, r = "width" in e3 && e3.width || "size" in e3 && e3.size || 0;
  return t3 || r;
}
function ve(e3) {
  const t3 = [];
  for (let r = 0; r < e3.length; r++)
    t3.push(e3.charCodeAt(r));
  return t3;
}
var Re = (e3) => !!e3 && (e3 = e3.trim(), !!(/^[mzlhvcsqta]\s*[-+.0-9][^mlhvzcsqta]+/i.test(e3) && /[\dz]$/i.test(e3) && e3.length > 4));
var Be = (e3) => {
  var _a, _b;
  return "fill" === e3.type && "CIMMarkerPlacementInsidePolygon" === ((_b = (_a = e3 == null ? void 0 : e3.cim) == null ? void 0 : _a.markerPlacement) == null ? void 0 : _b.type);
};

export {
  i,
  f,
  s3 as s,
  a,
  G2 as G,
  X,
  K,
  W,
  J,
  Q,
  ee,
  te,
  re,
  ae,
  se,
  ie,
  le,
  me,
  ge,
  he,
  Ie,
  Te,
  Ee,
  we,
  Ae,
  Ne,
  Me,
  De,
  _e,
  Ue,
  ve,
  Be
};
//# sourceMappingURL=chunk-6TBB7UXB.js.map
