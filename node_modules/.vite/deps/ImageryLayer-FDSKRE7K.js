import {
  $,
  L,
  c as c4,
  f as f5,
  i as i3,
  i2 as i4,
  j as j4,
  k as k4,
  l as l3,
  m as m2,
  n as n6,
  o as o4,
  u as u2,
  w as w5
} from "./chunk-OPGFTFHW.js";
import {
  c as c5,
  d,
  m,
  p as p5
} from "./chunk-367STH4F.js";
import {
  P,
  S,
  T as T3,
  _,
  f as f3,
  h,
  k as k3,
  n as n4,
  n2 as n5,
  u as u3
} from "./chunk-6VAE3YKY.js";
import {
  f as f4,
  f2 as f6
} from "./chunk-OYDVEVDU.js";
import {
  g as g2
} from "./chunk-OAXPH6DL.js";
import {
  n as n3,
  s as s6
} from "./chunk-P53ZRUMX.js";
import "./chunk-65ZBTSJX.js";
import {
  s as s5
} from "./chunk-GNLPM47O.js";
import "./chunk-UKETAWZI.js";
import "./chunk-HKYKZCGY.js";
import "./chunk-5MBCFCGH.js";
import "./chunk-O7LTV6XN.js";
import "./chunk-4TWWY75O.js";
import "./chunk-SQSR6K2M.js";
import "./chunk-UAJ2SDPQ.js";
import "./chunk-TJ2I6XQT.js";
import "./chunk-EDHROVWI.js";
import "./chunk-34YPGGJT.js";
import "./chunk-TWJNUVV2.js";
import {
  v as v5
} from "./chunk-NCXAKZRR.js";
import "./chunk-DUCSW4OU.js";
import {
  f as f2,
  i as i2,
  s as s4
} from "./chunk-WVDA5Z37.js";
import {
  e as e3
} from "./chunk-65SMURZR.js";
import {
  r as r3
} from "./chunk-7Q5M7ANT.js";
import {
  a as a2
} from "./chunk-LPRQBCQL.js";
import "./chunk-QR4K7IDQ.js";
import {
  o as o3
} from "./chunk-7N45W3EA.js";
import {
  p as p4
} from "./chunk-MQVQXXLV.js";
import {
  p as p3
} from "./chunk-HAVCYBU2.js";
import "./chunk-SBKKCBDN.js";
import "./chunk-MLVV3H5S.js";
import {
  x as x2
} from "./chunk-AMLHWG76.js";
import "./chunk-OFQYIOO7.js";
import "./chunk-ZJZBAYFU.js";
import {
  v as v4
} from "./chunk-G3HEFWHV.js";
import {
  p as p2
} from "./chunk-3GENFQBG.js";
import {
  c as c3
} from "./chunk-FX6IXM55.js";
import {
  O
} from "./chunk-QFFP6A5Q.js";
import "./chunk-J5VTDQTQ.js";
import "./chunk-PDEVQZ7U.js";
import {
  j2 as j3
} from "./chunk-7XXQ7762.js";
import "./chunk-DVGM5RQS.js";
import "./chunk-R6OA44DQ.js";
import "./chunk-QTYVDCOW.js";
import {
  c as c2,
  f,
  p,
  w as w4
} from "./chunk-YGVY4EIZ.js";
import "./chunk-HSDU7DIL.js";
import "./chunk-FWRLW4G5.js";
import {
  x
} from "./chunk-UK3I5WXR.js";
import {
  y as y3
} from "./chunk-GLGOVVCK.js";
import "./chunk-BUVDI6S7.js";
import "./chunk-6Z6ZAVRA.js";
import "./chunk-PK4W65H4.js";
import "./chunk-GY2AJLN6.js";
import "./chunk-W62B63EU.js";
import "./chunk-N43PI2UO.js";
import "./chunk-O6VYMEIX.js";
import "./chunk-HUQX7WZO.js";
import "./chunk-BYSA56OH.js";
import "./chunk-ZWUEORSX.js";
import {
  T as T2
} from "./chunk-US2IWMHE.js";
import "./chunk-ZL4T4NIV.js";
import "./chunk-NAKEKTIK.js";
import "./chunk-QWNKYSI4.js";
import "./chunk-FMJZBZWF.js";
import "./chunk-GOYVJTGW.js";
import "./chunk-ZPYDYUP5.js";
import {
  n as n2
} from "./chunk-TDV3ZXCQ.js";
import {
  t as t2
} from "./chunk-XJCUKRCO.js";
import {
  b
} from "./chunk-SOEQPPQP.js";
import "./chunk-22F6X66Z.js";
import "./chunk-AIDV7EKX.js";
import "./chunk-FZQZIM7U.js";
import "./chunk-YM6PUX7G.js";
import "./chunk-QEYOWTXD.js";
import "./chunk-CZBRZ6SU.js";
import "./chunk-KDO6J2FO.js";
import "./chunk-RT3T2K4S.js";
import "./chunk-WJCI2CGX.js";
import {
  g
} from "./chunk-J6LQZWZI.js";
import "./chunk-OD3FDQCI.js";
import "./chunk-J2PJNRU7.js";
import "./chunk-56SPM3WK.js";
import "./chunk-XMZAPOBR.js";
import "./chunk-BLJKKR5D.js";
import "./chunk-ZGNCYHMZ.js";
import "./chunk-X2S4RQJ4.js";
import {
  k as k2
} from "./chunk-FUPLN7UM.js";
import "./chunk-376OPXM4.js";
import "./chunk-DER356EU.js";
import "./chunk-MZIWIEIR.js";
import "./chunk-TQEOEDAZ.js";
import "./chunk-SHFHZMHO.js";
import "./chunk-NRP45AHD.js";
import "./chunk-IWQ7452U.js";
import "./chunk-NAN5J6QS.js";
import "./chunk-B4DKBAM3.js";
import "./chunk-6M2AHKYV.js";
import "./chunk-SZIJNKCV.js";
import "./chunk-6O43OEU5.js";
import "./chunk-J2K7ZDSV.js";
import "./chunk-2UML3WQZ.js";
import "./chunk-KXVMEIWT.js";
import "./chunk-UDND2Z3V.js";
import "./chunk-23Y3DIC6.js";
import "./chunk-JUVQV3R3.js";
import "./chunk-RAX2HD42.js";
import "./chunk-ZYRIJWLX.js";
import "./chunk-C5H57NTD.js";
import "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import {
  i
} from "./chunk-YWAQYJRC.js";
import "./chunk-B356PXLT.js";
import {
  c,
  v as v3
} from "./chunk-EHPBHJYZ.js";
import {
  u,
  v2
} from "./chunk-3MNMDUQZ.js";
import {
  w as w2,
  w2 as w3
} from "./chunk-UWG37XSU.js";
import {
  k2 as k
} from "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import {
  r as r2
} from "./chunk-HLM6QCL2.js";
import {
  o
} from "./chunk-RXYULINL.js";
import {
  l as l2
} from "./chunk-5NXILPDI.js";
import "./chunk-THVR7IAM.js";
import "./chunk-ZWJJTUFL.js";
import "./chunk-XQN7F674.js";
import {
  U
} from "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import {
  j as j2
} from "./chunk-KAN4HXCG.js";
import "./chunk-4FEGON7M.js";
import {
  s as s3
} from "./chunk-VWYWOOPX.js";
import {
  o as o2
} from "./chunk-M5VHU5LK.js";
import "./chunk-CXFRNDG4.js";
import {
  l
} from "./chunk-7QMMKGW4.js";
import {
  e as e2,
  j,
  n2 as n,
  y as y2
} from "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import {
  w
} from "./chunk-MJXQTGI2.js";
import {
  s as s2
} from "./chunk-LIZHLHNA.js";
import {
  T,
  a,
  v
} from "./chunk-BTUHYGXO.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";
import {
  y
} from "./chunk-HVKDYDPP.js";
import "./chunk-6QC7MLLS.js";
import {
  e,
  r,
  t
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/layers/support/rasterFunctionUtils.js
var e4 = { StretchFunction: { arguments: { ComputeGamma: { isDataset: false, isPublic: false, name: "ComputeGamma", type: "RasterFunctionVariable", value: false }, DRA: { isDataset: false, isPublic: false, name: "DRA", type: "RasterFunctionVariable", value: false }, EstimateStatsHistogram: { isDataset: false, isPublic: false, name: "EstimateStatsHistogram", type: "RasterFunctionVariable", value: false }, Gamma: { displayName: "Gamma", isDataset: false, isPublic: false, name: "Gamma", type: "RasterFunctionVariable" }, Histograms: { isDataset: false, isPublic: false, name: "Histograms", type: "RasterFunctionVariable" }, Max: { isDataset: false, isPublic: false, name: "Max", type: "RasterFunctionVariable", value: 255 }, MaxPercent: { isDataset: false, isPublic: false, name: "MaxPercent", type: "RasterFunctionVariable", value: 0.5 }, Min: { isDataset: false, isPublic: false, name: "Min", type: "RasterFunctionVariable", value: 0 }, MinPercent: { isDataset: false, isPublic: false, name: "MinPercent", type: "RasterFunctionVariable", value: 0.25 }, NumberOfStandardDeviations: { isDataset: false, isPublic: false, name: "NumberOfStandardDeviation", type: "RasterFunctionVariable", value: 2 }, Raster: { isDataset: true, isPublic: false, name: "Raster", type: "RasterFunctionVariable" }, SigmoidStrengthLevel: { isDataset: false, isPublic: false, name: "SigmoidStrengthLevel", type: "RasterFunctionVariable", value: 2 }, Statistics: { isDataset: false, isPublic: false, name: "Statistics", type: "RasterFunctionVariable" }, StretchType: { isDataset: false, isPublic: false, name: "StretchType", type: "RasterFunctionVariable", value: 0 }, type: "StretchFunctionArguments", UseGamma: { isDataset: false, isPublic: false, name: "UseGamma", type: "RasterFunctionVariable", value: false } }, description: "Enhances an image by adjusting the range of values displayed. This does not alter the underlying pixel values. If a pixel has a value outside of the specified range, it will appear as either the minimum or maximum value.", function: { description: "Enhances an image by adjusting the range of values displayed. This does not alter the underlying pixel values. If a pixel has a value outside of the specified range, it will appear as either the minimum or maximum value.", name: "Stretch", pixelType: "UNKNOWN", type: "StretchFunction" }, functionType: 0, name: "Stretch", thumbnail: "" }, RemapFunction: { name: "Remap", description: "Changes pixel values by assigning new values to ranges of pixel values or using an external table.", function: { type: "RemapFunction", pixelType: "UNKNOWN", name: "Remap", description: "Changes pixel values by assigning new values to ranges of pixel values or using an external table." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, UseTable: { name: "UseTable", isPublic: false, isDataset: false, value: false, type: "RasterFunctionVariable" }, InputRanges: { name: "InputRanges", isPublic: false, isDataset: false, type: "RasterFunctionVariable", displayName: "Input Ranges" }, OutputValues: { name: "OutputValues", isPublic: false, isDataset: false, type: "RasterFunctionVariable", displayName: "Output Values" }, NoDataRanges: { name: "NoDataRanges", isPublic: false, isDataset: false, type: "RasterFunctionVariable", displayName: "NoData Ranges" }, Table: { name: "Table", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, InputField: { name: "InputField", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, OutputField: { name: "OutputField", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, InputMaxField: { name: "InputMaxField", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, RemapTableType: { name: "RemapTableType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, AllowUnmatched: { name: "AllowUnmatched", isPublic: false, isDataset: false, value: true, type: "RasterFunctionVariable" }, type: "RemapFunctionArguments" }, functionType: 0, thumbnail: "" }, ColormapFunction: { name: "Colormap", description: "Changes pixel values to display the raster data as either a grayscale or a red, green, blue (RGB) image, based on a colormap or a color ramp.", function: { type: "ColormapFunction", pixelType: "UNKNOWN", name: "Colormap", description: "Changes pixel values to display the raster data as either a grayscale or a red, green, blue (RGB) image, based on a colormap or a color ramp." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, ColorSchemeType: { name: "ColorSchemeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, Colormap: { name: "Colormap", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, ColormapName: { name: "ColormapName", isPublic: false, isDataset: false, value: "Gray", type: "RasterFunctionVariable" }, ColorRamp: { name: "ColorRamp", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, type: "ColormapFunctionArguments" }, functionType: 0, thumbnail: "" }, ShadedReliefFunction: { name: "Shaded Relief", description: "Creates a multiband, color coded, 3D representation of the surface, with the sun's relative position taken into account for shading the image.", function: { type: "ShadedReliefFunction", pixelType: "UNKNOWN", name: "Shaded Relief", description: "Creates a multiband, color coded, 3D representation of the surface, with the sun's relative position taken into account for shading the image." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, ColorSchemeType: { name: "ColorSchemeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, ColorRamp: { name: "ColorRamp", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, HillshadeType: { name: "HillshadeType", isPublic: false, isDataset: false, value: 0, type: "RasterFunctionVariable" }, Colormap: { name: "Colormap", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, Azimuth: { name: "Azimuth", isPublic: false, isDataset: false, value: 315, type: "RasterFunctionVariable" }, Altitude: { name: "Altitude", isPublic: false, isDataset: false, value: 45, type: "RasterFunctionVariable" }, SlopeType: { name: "SlopeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, ZFactor: { name: "ZFactor", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, PSPower: { name: "PSPower", isPublic: false, isDataset: false, value: 0.664, type: "RasterFunctionVariable" }, PSZFactor: { name: "PSZFactor", isPublic: false, isDataset: false, value: 0.024, type: "RasterFunctionVariable" }, RemoveEdgeEffect: { name: "RemoveEdgeEffect", isPublic: false, isDataset: false, value: false, type: "RasterFunctionVariable" }, type: "ShadedReliefFunctionArguments" }, functionType: 0, thumbnail: "" }, HillshadeFunction: { name: "Hillshade", description: "Creates a 3D representation of the surface, with the sun's relative position taken into account for shading the image", function: { type: "HillshadeFunction", pixelType: "UNKNOWN", name: "Hillshade", description: "Creates a 3D representation of the surface, with the sun's relative position taken into account for shading the image" }, arguments: { DEM: { name: "DEM", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, HillshadeType: { name: "HillshadeType", isPublic: false, isDataset: false, value: 0, type: "RasterFunctionVariable" }, Azimuth: { name: "Azimuth", isPublic: false, isDataset: false, value: 315, type: "RasterFunctionVariable" }, Altitude: { name: "Altitude", isPublic: false, isDataset: false, value: 45, type: "RasterFunctionVariable" }, SlopeType: { name: "SlopeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, ZFactor: { name: "ZFactor", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, PSPower: { name: "PSPower", isPublic: false, isDataset: false, value: 0.664, type: "RasterFunctionVariable" }, PSZFactor: { name: "PSZFactor", isPublic: false, isDataset: false, value: 0.024, type: "RasterFunctionVariable" }, RemoveEdgeEffect: { name: "RemoveEdgeEffect", isPublic: false, isDataset: false, value: false, type: "RasterFunctionVariable" }, type: "HillshadeFunctionArguments" }, functionType: 0, thumbnail: "" }, ResampleFunction: { name: "Resample", description: "Changes the cell size of a raster.", function: { type: "ResampleFunction", pixelType: "UNKNOWN", name: "Resample", description: "Changes the cell size of a raster." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, ResamplingType: { name: "ResamplingType", isPublic: false, isDataset: false, value: 0, type: "RasterFunctionVariable" }, InputCellSize: { name: "InputCellsize", isPublic: false, isDataset: false, value: { x: 0, y: 0 }, type: "RasterFunctionVariable" }, OutputCellSize: { name: "OutputCellsize", isPublic: false, isDataset: false, value: { x: 0, y: 0 }, type: "RasterFunctionVariable" }, type: "ResampleFunctionArguments" }, functionType: 0, thumbnail: "" } };

// node_modules/@arcgis/core/layers/support/imageryRendererUtils.js
var c6 = { u1: [0, 1], u2: [0, 3], u4: [0, 15], u8: [0, 255], s8: [-128, 127], u16: [0, 65535], s16: [-32768, 32767] };
var m3 = { simple_scalar: "Simple Scalar", wind_barb: "Wind Barb", single_arrow: "Single Arrow", beaufort_kn: "Beaufort Wind (Knots)", beaufort_m: "Beaufort Wind (MetersPerSecond)", ocean_current_m: "Ocean Current (MetersPerSecond)", ocean_current_kn: "Ocean Current (Knots)" };
var p6 = /* @__PURE__ */ new Set(["raster-stretch", "unique-value", "class-breaks", "raster-shaded-relief", "vector-field", "raster-colormap"]);
function f7(e5) {
  return p6.has(e5.type);
}
function g3(t4, n9) {
  if (!t4 || !n9)
    return y(t4 || n9);
  const r4 = y(t4);
  if (n9.rasterFunctionDefinition) {
    const e5 = n9.rasterFunctionDefinition;
    (e5.thumbnail || e5.thumbnailEx) && (e5.thumbnail = e5.thumbnailEx = null), d2(r4.rasterFunctionDefinition.arguments, n9);
  } else if ("none" !== n9.functionName.toLowerCase()) {
    b2(r4.functionArguments).Raster = n9;
  }
  return r4;
}
function d2(e5, t4) {
  for (const n9 in e5)
    "raster" === n9.toLowerCase() && ("RasterFunctionVariable" === e5[n9].type ? (e5[n9] = t4.rasterFunctionDefinition, e5[n9].type = "RasterFunctionTemplate") : "RasterFunctionTemplate" === e5[n9].type && d2(e5[n9].arguments, t4));
}
function h2(t4) {
  const n9 = y(e4[t4.functionName + "Function"]), o5 = t4.functionArguments;
  for (const e5 in o5)
    "raster" === e5.toLowerCase() ? (n9.arguments[e5] = h2(o5[e5]), n9.arguments[e5].type = "RasterFunctionTemplate") : "colormap" === e5.toLowerCase() ? (n9.arguments[e5].value = D(o5[e5]), n9.arguments.ColorSchemeType.value = 0) : n9.arguments[e5].value = o5[e5];
  return n9;
}
function y4(e5, t4) {
  switch (t4 = t4 || {}, e5.type) {
    case "raster-stretch":
      return v6(e5, t4);
    case "class-breaks":
      return C(e5, t4);
    case "unique-value":
      return A(e5, t4);
    case "raster-colormap":
      return F(e5, t4);
    case "vector-field":
      return T4(e5, t4);
    case "raster-shaded-relief":
      return w6(e5, t4);
    case "flow":
      throw new Error("Unsupported rendering rule.");
  }
}
function b2(e5) {
  const t4 = e5 == null ? void 0 : e5.Raster;
  return t4 && "esri.layers.support.RasterFunction" === t4.declaredClass ? b2(t4.functionArguments) : e5;
}
var R = { none: 0, standardDeviation: 3, histogramEqualization: 4, minMax: 5, percentClip: 6, sigmoid: 9 };
function T4(e5, t4) {
  const r4 = new w5();
  r4.functionName = "VectorFieldRenderer";
  const { dataType: o5, bandProperties: a4 } = t4, i7 = "vector-uv" === o5;
  let s7, u6;
  a4 && 2 === a4.length && (s7 = a4.map((e6) => e6.BandName.toLowerCase()).indexOf("magnitude"), u6 = a4.map((e6) => e6.BandName.toLowerCase()).indexOf("direction")), -1 !== s7 && null !== s7 || (s7 = 0, u6 = 1);
  const c10 = "arithmetic" === e5.rotationType ? 1 : 2, p13 = "flow-from" === e5.flowRepresentation ? 0 : 1, f9 = e5.visualVariables ? e5.visualVariables.find((e6) => "Magnitude" === e6.field) : new j3(), g5 = { magnitudeBandID: s7, directionBandID: u6, isUVComponents: i7, referenceSystem: c10, massFlowAngleRepresentation: p13, symbolTileSize: 50, symbolTileSizeUnits: 100, calculationMethod: "Vector Average", symbologyName: m3[e5.style.toLowerCase().replace("-", "_")], minimumMagnitude: f9.minDataValue, maximumMagnitude: f9.maxDataValue, minimumSymbolSize: f9.minSize, maximumSymbolSize: f9.maxSize };
  return r4.functionArguments = g5, t4.convertToRFT ? new w5({ rasterFunctionDefinition: h2(r4) }) : r4;
}
function w6(e5, t4) {
  const r4 = t4.convertToRFT;
  if ("elevation" !== t4.dataType && ("generic" !== t4.dataType || 1 !== t4.bandCount || "s16" !== t4.pixelType && "s32" !== t4.pixelType && "f32" !== t4.pixelType && "f64" !== t4.pixelType))
    return new w5();
  const i7 = new w5();
  i7.functionName = "Hillshade";
  const s7 = "traditional" === e5.hillshadeType ? 0 : 1, u6 = "none" === e5.scalingType ? 1 : 3, l6 = { HillshadeType: s7, SlopeType: u6, ZFactor: e5.zFactor };
  return 0 === s7 && (l6.Azimuth = e5.azimuth, l6.Altitude = e5.altitude), 3 === u6 && (l6.PSPower = e5.pixelSizePower, l6.PSZFactor = e5.pixelSizeFactor), i7.functionArguments = l6, i7.variableName = "Raster", e5.colorRamp && (i7.functionName = "ShadedRelief", r4 ? l6.ColorRamp = _(e5.colorRamp) : l6.Colormap = h(e5.colorRamp, 256)), r4 ? new w5({ rasterFunctionDefinition: h2(i7) }) : i7;
}
function v6(e5, t4) {
  var _a;
  const r4 = t4.convertToRFT, s7 = new w5();
  s7.functionName = "Stretch";
  const l6 = R[n4.toJSON(e5.stretchType)], c10 = "u8", m7 = { StretchType: l6, Statistics: N(e5.statistics), DRA: e5.dynamicRangeAdjustment, UseGamma: e5.useGamma, Gamma: e5.gamma, ComputeGamma: e5.computeGamma };
  if (null != e5.outputMin && (m7.Min = e5.outputMin), null != e5.outputMax && (m7.Max = e5.outputMax), l6 === R.standardDeviation ? (m7.NumberOfStandardDeviations = e5.numberOfStandardDeviations, s7.outputPixelType = c10) : l6 === R.percentClip ? (m7.MinPercent = e5.minPercent, m7.MaxPercent = e5.maxPercent, s7.outputPixelType = c10) : l6 === R.minMax ? s7.outputPixelType = c10 : l6 === R.sigmoid && (m7.SigmoidStrengthLevel = e5.sigmoidStrengthLevel), s7.functionArguments = m7, s7.variableName = "Raster", e5.colorRamp) {
    const u6 = e5.colorRamp, l7 = new w5();
    if (r4)
      l7.functionArguments = { ColorRamp: _(u6) };
    else {
      const n9 = f3(u6);
      if (n9)
        l7.functionArguments = { colorRamp: n9 };
      else if (!t4.convertColorRampToColormap || "algorithmic" !== u6.type && "multipart" !== u6.type) {
        const t5 = e5.colorRamp.toJSON();
        "algorithmic" === t5.type ? t5.algorithm = t5.algorithm || "esriCIELabAlgorithm" : "multipart" === t5.type && ((_a = t5.colorRamps) == null ? void 0 : _a.length) && t5.colorRamps.forEach((e6) => e6.algorithm = e6.algorithm || "esriCIELabAlgorithm"), l7.functionArguments = { colorRamp: t5 };
      } else
        l7.functionArguments = { Colormap: h(u6, 256) };
    }
    return l7.variableName = "Raster", l7.functionName = "Colormap", l7.functionArguments.Raster = s7, r4 ? new w5({ rasterFunctionDefinition: h2(l7) }) : l7;
  }
  return r4 ? new w5({ rasterFunctionDefinition: h2(s7) }) : s7;
}
function C(e5, r4) {
  const o5 = [], a4 = [], i7 = [], s7 = [], u6 = 1e-6, { pixelType: l6, rasterAttributeTable: c10 } = r4, m7 = t(c10) ? null : c10.features, p13 = x3(c10);
  if (m7 && Array.isArray(m7) && e5.classBreakInfos) {
    e5.classBreakInfos.forEach((t5, n9) => {
      const r5 = t5.symbol.color;
      let o7;
      r5.a && m7.forEach((a5) => {
        o7 = a5.attributes[e5.field], (o7 >= t5.minValue && o7 < t5.maxValue || n9 === e5.classBreakInfos.length - 1 && o7 >= t5.minValue) && s7.push([a5.attributes[p13], r5.r, r5.g, r5.b]);
      });
    });
    const t4 = l6 ? S2(s7, l6) : s7, o6 = new w5();
    return o6.functionName = "Colormap", o6.functionArguments = {}, o6.functionArguments.Colormap = t4, o6.variableName = "Raster", r4.convertToRFT ? new w5({ rasterFunctionDefinition: h2(o6) }) : o6;
  }
  e5.classBreakInfos.forEach((e6, t4) => {
    const n9 = e6.symbol && e6.symbol.color;
    n9.a ? (0 === t4 ? o5.push(e6.minValue, e6.maxValue + u6) : o5.push(e6.minValue + u6, e6.maxValue + u6), a4.push(t4), s7.push([t4, n9.r, n9.g, n9.b])) : i7.push(e6.minValue, e6.maxValue);
  });
  const f9 = l6 ? S2(s7, l6) : s7, g5 = new w5();
  g5.functionName = "Remap", g5.functionArguments = { InputRanges: o5, OutputValues: a4, NoDataRanges: i7 }, g5.variableName = "Raster";
  const d7 = new w5();
  return d7.functionName = "Colormap", d7.functionArguments = { Colormap: f9, Raster: g5 }, r4.convertToRFT ? new w5({ rasterFunctionDefinition: h2(d7) }) : d7;
}
function S2(e5, t4) {
  const n9 = c6[String(t4).toLowerCase()];
  return n9 && e5.push([Math.floor(n9[0] - 1), 0, 0, 0], [Math.ceil(n9[1] + 1), 0, 0, 0]), e5;
}
function x3(e5) {
  if (t(e5))
    return;
  const { fields: n9 } = e5, r4 = n9 && n9.find((e6) => e6 && e6.name && "value" === e6.name.toLowerCase());
  return r4 && r4.name;
}
function A(e5, r4) {
  var _a, _b;
  const o5 = [], { pixelType: a4, rasterAttributeTable: i7 } = r4, s7 = t(i7) ? null : i7.features, u6 = x3(i7), l6 = (_b = (_a = e5.defaultSymbol) == null ? void 0 : _a.color) == null ? void 0 : _b.toRgb(), c10 = e5.uniqueValueInfos;
  if (c10)
    if (s7) {
      const t4 = /* @__PURE__ */ new Map();
      c10.forEach((e6) => {
        const n10 = e6.value, r5 = e6.symbol.color;
        null != n10 && r5 && r5.a && t4.set(String(n10), r5.toRgb());
      });
      const n9 = e5.field;
      s7.forEach(({ attributes: e6 }) => {
        const r5 = String(e6[n9]), a5 = e6[u6];
        if (t4.has(r5)) {
          const e7 = t4.get(r5);
          o5.push([a5, ...e7]);
        } else
          l6 && o5.push([a5, ...l6]);
      });
    } else
      for (let t4 = 0; t4 < c10.length; t4++) {
        const e6 = c10[t4], n9 = e6.symbol.color, r5 = +e6.value;
        if (n9 == null ? void 0 : n9.a) {
          if (isNaN(r5))
            return null;
          o5.push([r5, n9.r, n9.g, n9.b]);
        }
      }
  const m7 = a4 && o5.length > 0 ? S2(o5, a4) : o5, p13 = new w5();
  return p13.functionName = "Colormap", p13.functionArguments = {}, p13.functionArguments.Colormap = m7, p13.variableName = "Raster", r4.convertToRFT ? new w5({ rasterFunctionDefinition: h2(p13) }) : p13;
}
function F(e5, t4) {
  const r4 = e5.extractColormap();
  if (!r4 || 0 === r4.length)
    return;
  const { pixelType: o5 } = t4, a4 = o5 ? S2(r4, o5) : r4, i7 = new w5();
  return i7.functionName = "Colormap", i7.functionArguments = {}, i7.functionArguments.Colormap = a4, t4.convertToRFT ? new w5({ rasterFunctionDefinition: h2(i7) }) : i7;
}
function N(e5) {
  const t4 = [];
  return e5.forEach((e6) => {
    const n9 = e6;
    if (Array.isArray(n9))
      t4.push(n9);
    else {
      if (null == n9.min || null == n9.max)
        return;
      const e7 = [n9.min, n9.max, n9.avg || 0, n9.stddev || 0];
      t4.push(e7);
    }
  }), t4;
}
function D(e5) {
  const t4 = [], n9 = [];
  return e5.forEach((e6) => {
    t4.push(e6[0]), n9.push(k3([...e6.slice(1), 255]));
  }), { type: "RasterColormap", values: t4, colors: n9 };
}

// node_modules/@arcgis/core/layers/support/MosaicRule.js
var u4;
var m4 = o2()({ MT_FIRST: "first", MT_LAST: "last", MT_MIN: "min", MT_MAX: "max", MT_MEAN: "mean", MT_BLEND: "blend", MT_SUM: "sum" });
var h3 = o2()({ esriMosaicNone: "none", esriMosaicCenter: "center", esriMosaicNadir: "nadir", esriMosaicViewpoint: "viewpoint", esriMosaicAttribute: "attribute", esriMosaicLockRaster: "lock-raster", esriMosaicNorthwest: "northwest", esriMosaicSeamline: "seamline" });
function M(e5) {
  let t4;
  switch (e5 ? e5.toLowerCase().replace("esrimosaic", "") : "") {
    case "byattribute":
    case "attribute":
      t4 = "esriMosaicAttribute";
      break;
    case "lockraster":
      t4 = "esriMosaicLockRaster";
      break;
    case "center":
      t4 = "esriMosaicCenter";
      break;
    case "northwest":
      t4 = "esriMosaicNorthwest";
      break;
    case "nadir":
      t4 = "esriMosaicNadir";
      break;
    case "viewpoint":
      t4 = "esriMosaicViewpoint";
      break;
    case "seamline":
      t4 = "esriMosaicSeamline";
      break;
    default:
      t4 = "esriMosaicNone";
  }
  return h3.fromJSON(t4);
}
var w7 = u4 = class extends l {
  constructor(e5) {
    super(e5), this.ascending = true, this.itemRenderingRule = null, this.lockRasterIds = null, this.method = null, this.multidimensionalDefinition = null, this.objectIds = null, this.operation = null, this.sortField = null, this.sortValue = null, this.viewpoint = null, this.where = null;
  }
  readAscending(e5, t4) {
    return null != t4.ascending ? t4.ascending : null == t4.sortAscending || t4.sortAscending;
  }
  readMethod(e5, t4) {
    return M(t4.mosaicMethod || t4.defaultMosaicMethod);
  }
  readOperation(e5, t4) {
    const o5 = t4.mosaicOperation, r4 = t4.mosaicOperator && t4.mosaicOperator.toLowerCase(), i7 = o5 || (r4 ? m4.toJSON(r4) : null);
    return m4.fromJSON(i7) || "first";
  }
  castSortValue(e5) {
    return null == e5 || "string" == typeof e5 || "number" == typeof e5 ? e5 : `${e5}`;
  }
  clone() {
    return new u4({ ascending: this.ascending, itemRenderingRule: y(this.itemRenderingRule), lockRasterIds: y(this.lockRasterIds), method: this.method, multidimensionalDefinition: y(this.multidimensionalDefinition), objectIds: y(this.objectIds), operation: this.operation, sortField: this.sortField, sortValue: this.sortValue, viewpoint: y(this.viewpoint), where: this.where });
  }
};
e2([y2({ type: Boolean, json: { write: true } })], w7.prototype, "ascending", void 0), e2([o("ascending", ["ascending", "sortAscending"])], w7.prototype, "readAscending", null), e2([y2({ type: w5, json: { write: true } })], w7.prototype, "itemRenderingRule", void 0), e2([y2({ type: [T], json: { write: { overridePolicy() {
  return { enabled: "lock-raster" === this.method };
} } } })], w7.prototype, "lockRasterIds", void 0), e2([y2({ type: String, json: { type: h3.jsonValues, write: { target: "mosaicMethod", writer: h3.write } } })], w7.prototype, "method", void 0), e2([o("method", ["mosaicMethod", "defaultMosaicMethod"])], w7.prototype, "readMethod", null), e2([y2({ type: [p5], json: { write: true } })], w7.prototype, "multidimensionalDefinition", void 0), e2([y2({ type: [T], json: { name: "fids", write: true } })], w7.prototype, "objectIds", void 0), e2([y2({ json: { type: m4.jsonValues, read: { reader: m4.read }, write: { target: "mosaicOperation", writer: m4.write } } })], w7.prototype, "operation", void 0), e2([o("operation", ["mosaicOperation", "mosaicOperator"])], w7.prototype, "readOperation", null), e2([y2({ type: String, json: { write: { overridePolicy() {
  return { enabled: "attribute" === this.method };
} } } })], w7.prototype, "sortField", void 0), e2([y2({ type: [String, Number], json: { write: { allowNull: true, overridePolicy() {
  return { enabled: "attribute" === this.method, allowNull: true };
} } } })], w7.prototype, "sortValue", void 0), e2([s3("sortValue")], w7.prototype, "castSortValue", null), e2([y2({ type: w2, json: { write: true } })], w7.prototype, "viewpoint", void 0), e2([y2({ type: String, json: { write: true } })], w7.prototype, "where", void 0), w7 = u4 = e2([n("esri.layers.support.MosaicRule")], w7);
var y5 = w7;

// node_modules/@arcgis/core/layers/support/ExportImageServiceParameters.js
var y6 = class extends l {
  constructor() {
    super(...arguments), this.layer = null, this.adjustAspectRatio = void 0, this.compression = void 0, this.pixelType = void 0, this.lercVersion = 2;
  }
  writeAdjustAspectRatio(e5, t4, r4) {
    this.layer.version < 10.3 || (t4[r4] = e5);
  }
  get bandIds() {
    return this.layer.bandIds;
  }
  set bandIds(e5) {
    this.layer && (this.layer.bandIds = e5);
  }
  get compressionQuality() {
    var _a;
    return (_a = this.layer) == null ? void 0 : _a.compressionQuality;
  }
  set compressionQuality(e5) {
    this.layer && (this.layer.compressionQuality = e5);
  }
  writeCompressionQuality(e5, t4, r4) {
    this.format && this.format.toLowerCase().includes("jpg") && null != e5 && (t4[r4] = e5);
  }
  get compressionTolerance() {
    var _a;
    return (_a = this.layer) == null ? void 0 : _a.compressionTolerance;
  }
  set compressionTolerance(e5) {
    this.layer && (this.layer.compressionTolerance = e5);
  }
  writeCompressionTolerance(e5, t4, r4) {
    "lerc" === this.format && null != e5 && (t4[r4] = e5);
  }
  get format() {
    var _a;
    return "vector-field" === ((_a = this.layer.renderer) == null ? void 0 : _a.type) ? "lerc" : this.layer.format;
  }
  get interpolation() {
    var _a;
    return (_a = this.layer) == null ? void 0 : _a.interpolation;
  }
  set interpolation(e5) {
    this.layer && (this.layer.interpolation = e5);
  }
  get noData() {
    var _a;
    return (_a = this.layer) == null ? void 0 : _a.noData;
  }
  set noData(e5) {
    this.layer && (this.layer.noData = e5);
  }
  get noDataInterpretation() {
    var _a;
    return (_a = this.layer) == null ? void 0 : _a.noDataInterpretation;
  }
  set noDataInterpretation(e5) {
    this.layer && (this.layer.noDataInterpretation = e5);
  }
  writeLercVersion(e5, t4, r4) {
    "lerc" === this.format && this.layer.version >= 10.5 && (t4[r4] = e5);
  }
  get version() {
    const e5 = this.layer;
    return e5.commitProperty("bandIds"), e5.commitProperty("format"), e5.commitProperty("compressionQuality"), e5.commitProperty("compressionTolerance"), e5.commitProperty("interpolation"), e5.commitProperty("noData"), e5.commitProperty("noDataInterpretation"), e5.commitProperty("mosaicRule"), e5.commitProperty("renderingRule"), e5.commitProperty("adjustAspectRatio"), e5.commitProperty("pixelFilter"), e5.commitProperty("definitionExpression"), e5.commitProperty("multidimensionalSubset"), (this._get("version") || 0) + 1;
  }
  set version(e5) {
    this._set("version", e5);
  }
  get mosaicRule() {
    const e5 = this.layer;
    let t4 = e5.mosaicRule;
    const r4 = e5.definitionExpression;
    return t4 ? r4 && r4 !== t4.where && (t4 = t4.clone(), t4.where = r4) : r4 && (t4 = new y5({ where: r4 })), t4;
  }
  get renderingRule() {
    var _a, _b;
    const e5 = this.layer;
    let t4 = e5.renderingRule;
    const r4 = e5.pixelFilter, o5 = !e5.format || e5.format.includes("jpg") || e5.format.includes("png");
    t4 = this._addResampleRasterFunction(t4);
    const i7 = (_a = e5.multidimensionalSubset) == null ? void 0 : _a.areaOfInterest;
    return i7 && (t4 = this._addClipFunction(t4, i7)), o5 && !r4 && "vector-field" !== ((_b = e5.renderer) == null ? void 0 : _b.type) && (t4 = this.combineRendererWithRenderingRule(t4)), t4;
  }
  combineRendererWithRenderingRule(e5) {
    var _a;
    const t4 = this.layer, { rasterInfo: r4, renderer: o5 } = t4;
    if (e5 = e5 || t4.renderingRule, !o5 || !f7(o5))
      return e5;
    return g3(y4(o5, { rasterAttributeTable: r4.attributeTable, pixelType: r4.pixelType, dataType: r4.dataType, bandProperties: (_a = r4.keyProperties) == null ? void 0 : _a.BandProperties, convertColorRampToColormap: t4.version < 10.6, convertToRFT: !!(e5 == null ? void 0 : e5.rasterFunctionDefinition), bandCount: r4.bandCount }), e5);
  }
  _addResampleRasterFunction(e5) {
    var _a;
    if (!("vector-field" === ((_a = this.layer.renderer) == null ? void 0 : _a.type)) || "Resample" === (e5 == null ? void 0 : e5.functionName))
      return e5;
    const t4 = "esriImageServiceDataTypeVector-UV" === this.layer.serviceDataType ? 7 : 10, r4 = this.layer.serviceRasterInfo.pixelSize;
    let o5 = new w5({ functionName: "Resample", functionArguments: { ResamplingType: t4, InputCellSize: r4 } });
    return o5 = (e5 == null ? void 0 : e5.rasterFunctionDefinition) ? new w5({ rasterFunctionDefinition: h2(o5) }) : o5, g3(o5, e5);
  }
  _addClipFunction(e5, t4) {
    const r4 = new w5({ functionName: "Clip", functionArguments: { ClippingGeometry: t4.toJSON(), ClippingType: 1 } });
    return g3(r4, e5);
  }
};
e2([y2()], y6.prototype, "layer", void 0), e2([y2({ json: { write: true } })], y6.prototype, "adjustAspectRatio", void 0), e2([r2("adjustAspectRatio")], y6.prototype, "writeAdjustAspectRatio", null), e2([y2({ json: { write: true } })], y6.prototype, "bandIds", null), e2([y2({ json: { write: true } })], y6.prototype, "compression", void 0), e2([y2({ json: { write: true } })], y6.prototype, "compressionQuality", null), e2([r2("compressionQuality")], y6.prototype, "writeCompressionQuality", null), e2([y2({ json: { write: true } })], y6.prototype, "compressionTolerance", null), e2([r2("compressionTolerance")], y6.prototype, "writeCompressionTolerance", null), e2([y2({ json: { write: true } })], y6.prototype, "format", null), e2([y2({ type: String, json: { read: { reader: o4.read }, write: { writer: o4.write } } })], y6.prototype, "interpolation", null), e2([y2({ json: { write: true } })], y6.prototype, "noData", null), e2([y2({ type: String, json: { read: { reader: i4.read }, write: { writer: i4.write } } })], y6.prototype, "noDataInterpretation", null), e2([y2({ json: { write: true } })], y6.prototype, "pixelType", void 0), e2([y2({ json: { write: true } })], y6.prototype, "lercVersion", void 0), e2([r2("lercVersion")], y6.prototype, "writeLercVersion", null), e2([y2({ type: Number })], y6.prototype, "version", null), e2([y2({ json: { write: true } })], y6.prototype, "mosaicRule", null), e2([y2({ json: { write: true } })], y6.prototype, "renderingRule", null), y6 = e2([n("esri.layers.mixins.ExportImageServiceParameters")], y6);

// node_modules/@arcgis/core/rest/support/ImageAngleResult.js
var p7 = class extends l {
  constructor() {
    super(...arguments), this.north = null, this.up = null, this.spatialReference = null;
  }
};
e2([y2({ type: Number, json: { write: true } })], p7.prototype, "north", void 0), e2([y2({ type: Number, json: { write: true } })], p7.prototype, "up", void 0), e2([y2({ type: k, json: { write: true } })], p7.prototype, "spatialReference", void 0), p7 = e2([n("esri.rest.support.ImageAngleResult")], p7);
var i5 = p7;

// node_modules/@arcgis/core/rest/support/ImageIdentifyResult.js
var p8 = class extends l {
  constructor() {
    super(...arguments), this.catalogItemVisibilities = null, this.catalogItems = null, this.location = null, this.name = null, this.objectId = null, this.processedValues = null, this.properties = null, this.value = null;
  }
};
e2([y2({ json: { write: true } })], p8.prototype, "catalogItemVisibilities", void 0), e2([y2({ type: x, json: { write: true } })], p8.prototype, "catalogItems", void 0), e2([y2({ type: w2, json: { write: true } })], p8.prototype, "location", void 0), e2([y2({ json: { write: true } })], p8.prototype, "name", void 0), e2([y2({ json: { write: true } })], p8.prototype, "objectId", void 0), e2([y2({ json: { write: true } })], p8.prototype, "processedValues", void 0), e2([y2({ json: { write: true } })], p8.prototype, "properties", void 0), e2([y2({ json: { write: true } })], p8.prototype, "value", void 0), p8 = e2([n("esri.rest.support.ImageIdentifyResult")], p8);
var l4 = p8;

// node_modules/@arcgis/core/rest/support/ImagePixelLocationResult.js
var t3 = class extends l {
  constructor() {
    super(...arguments), this.geometries = null;
  }
};
e2([y2({ json: { write: true } })], t3.prototype, "geometries", void 0), t3 = e2([n("esri.rest.support.ImagePixelLocationResult")], t3);
var p9 = t3;

// node_modules/@arcgis/core/rest/support/ImageSample.js
var i6 = class extends l {
  constructor() {
    super(...arguments), this.attributes = null, this.location = null, this.locationId = null, this.rasterId = null, this.resolution = null, this.pixelValue = null;
  }
};
e2([y2({ json: { write: true } })], i6.prototype, "attributes", void 0), e2([y2({ type: w2, json: { write: true } })], i6.prototype, "location", void 0), e2([y2({ json: { write: true } })], i6.prototype, "locationId", void 0), e2([y2({ json: { write: true } })], i6.prototype, "rasterId", void 0), e2([y2({ json: { write: true } })], i6.prototype, "resolution", void 0), e2([y2({ json: { write: true } })], i6.prototype, "pixelValue", void 0), i6 = e2([n("esri.rest.support.ImageSample")], i6);
var p10 = i6;

// node_modules/@arcgis/core/rest/support/ImageSampleResult.js
var p11 = class extends l {
  constructor() {
    super(...arguments), this.samples = null;
  }
};
e2([y2({ type: [p10], json: { write: true } })], p11.prototype, "samples", void 0), p11 = e2([n("esri.rest.support.ImageSampleResult")], p11);
var c7 = p11;

// node_modules/@arcgis/core/rest/imageService.js
function u5(e5) {
  const t4 = e5 == null ? void 0 : e5.time;
  if (t4 && (null != t4.start || null != t4.end)) {
    const n9 = [];
    null != t4.start && n9.push(t4.start), null == t4.end || n9.includes(t4.end) || n9.push(t4.end), e5.time = n9.join(",");
  }
}
async function p12(e5, i7, r4) {
  const m7 = f2(e5), c10 = i7.geometry ? [i7.geometry] : [], l6 = await v5(c10), p13 = i7.toJSON();
  u5(p13);
  const f9 = l6 && l6[0];
  r(f9) && (p13.geometry = f9.toJSON());
  const g5 = s4({ ...m7.query, f: "json", ...p13 });
  return i2(g5, r4);
}
async function f8(n9, r4, m7) {
  var _a;
  const c10 = r4.toJSON();
  r(c10.angleName) && (c10.angleName = c10.angleName.join(",")), r(r4.point) && ((_a = r4.point.spatialReference) == null ? void 0 : _a.imageCoordinateSystem) && (c10.point.spatialReference = h4(r4.point.spatialReference)), r(r4.spatialReference) && r4.spatialReference.imageCoordinateSystem && (c10.spatialReference = R2(r4.spatialReference));
  const u6 = f2(n9), p13 = s4({ ...u6.query, f: "json", ...c10 }), f9 = i2(p13, m7), { data: g5 } = await U(`${u6.path}/computeAngles`, f9);
  return g5.spatialReference = g5.spatialReference ? null != g5.spatialReference.geodataXform ? new k({ wkid: 0, imageCoordinateSystem: g5.spatialReference }) : k.fromJSON(g5.spatialReference) : null, "NaN" === g5.north && (g5.north = null), "NaN" === g5.up && (g5.up = null), new i5(g5);
}
async function g4(t4, n9, i7) {
  var _a;
  const r4 = n9.toJSON(), { geometries: c10 } = n9;
  if (c10)
    for (let e5 = 0; e5 < c10.length; e5++)
      ((_a = c10[e5].spatialReference) == null ? void 0 : _a.imageCoordinateSystem) && (r4.geometries.geometries[e5].spatialReference = h4(c10[e5].spatialReference));
  const l6 = f2(t4), u6 = s4({ ...l6.query, f: "json", ...r4 }), p13 = i2(u6, i7), { data: f9 } = await U(`${l6.path}/computePixelLocation`, p13);
  return p9.fromJSON(f9);
}
async function y7(t4, n9, a4) {
  const s7 = await p12(t4, n9, a4), i7 = f2(t4), { data: r4 } = await U(`${i7.path}/computeStatisticsHistograms`, s7), { statistics: m7 } = r4;
  return (m7 == null ? void 0 : m7.length) && m7.forEach((e5) => {
    e5.avg = e5.mean, e5.stddev = e5.standardDeviation;
  }), { statistics: m7, histograms: r4.histograms };
}
async function d3(t4, n9, a4) {
  const s7 = await p12(t4, n9, a4), i7 = f2(t4), { data: r4 } = await U(`${i7.path}/computeHistograms`, s7);
  return { histograms: r4.histograms };
}
async function N2(i7, r4, m7) {
  var _a, _b, _c;
  const l6 = r4.toJSON();
  u5(l6), ((_a = l6.outFields) == null ? void 0 : _a.length) && (l6.outFields = l6.outFields.join(","));
  const p13 = (_b = await v5(r4.geometry)) == null ? void 0 : _b[0];
  r(p13) && (l6.geometry = p13.toJSON());
  const f9 = f2(i7), g5 = s4({ ...f9.query, f: "json", ...l6 }), y10 = i2(g5, m7), { data: d7 } = await U(`${f9.path}/getSamples`, y10), N3 = (_c = d7 == null ? void 0 : d7.samples) == null ? void 0 : _c.map((e5) => {
    const t4 = "NaN" === e5.value || "" === e5.value ? null : e5.value.split(" ").map((e6) => Number(e6));
    return { ...e5, pixelValue: t4 };
  });
  return c7.fromJSON({ samples: N3 });
}
async function S3(i7, m7, c10) {
  const l6 = f2(i7), u6 = m7.geometry ? [m7.geometry] : [];
  return v5(u6).then((n9) => {
    const o5 = m7.toJSON(), i8 = n9 && n9[0];
    r(i8) && (o5.geometry = JSON.stringify(i8.toJSON()));
    const r4 = s4({ ...l6.query, f: "json", ...o5 }), u7 = i2(r4, c10);
    return U(l6.path + "/identify", u7);
  }).then((e5) => l4.fromJSON(e5.data));
}
function h4(e5) {
  const { imageCoordinateSystem: t4 } = e5;
  if (t4) {
    const { id: e6, referenceServiceName: n9 } = t4;
    return null != e6 ? n9 ? { icsid: e6, icsns: n9 } : { icsid: e6 } : { ics: t4 };
  }
  return e5.toJSON();
}
function R2(e5, t4) {
  const n9 = h4(e5), { icsid: o5, icsns: a4, wkid: s7 } = n9;
  return null != o5 ? null == a4 || (t4 == null ? void 0 : t4.toLowerCase().includes("/" + a4.toLowerCase() + "/")) ? `0:${o5}` : JSON.stringify(n9) : s7 ? s7.toString() : JSON.stringify(n9);
}

// node_modules/@arcgis/core/rest/imageService/getCatalogItemRasterInfo.js
async function n7(n9, m7, p13) {
  var _a, _b;
  const f9 = f2(n9), u6 = s4({ ...f9 == null ? void 0 : f9.query, f: "json" }), h6 = i2(u6, p13), d7 = `${f9 == null ? void 0 : f9.path}/${m7}/info`, c10 = U(`${d7}`, h6), g5 = U(`${d7}/keyProperties`, h6), x4 = await Promise.allSettled([c10, g5]), y10 = "fulfilled" === x4[0].status ? x4[0].value.data : null, v7 = "fulfilled" === x4[1].status ? x4[1].value.data : null;
  let P2 = null;
  ((_a = y10.statistics) == null ? void 0 : _a.length) && (P2 = y10.statistics.map((e5) => ({ min: e5[0], max: e5[1], avg: e5[2], stddev: e5[3] })));
  const S4 = w3.fromJSON(y10.extent), j7 = Math.ceil(S4.width / y10.pixelSizeX - 0.1), w8 = Math.ceil(S4.height / y10.pixelSizeY - 0.1), b3 = S4.spatialReference, k5 = new w2({ x: y10.pixelSizeX, y: y10.pixelSizeY, spatialReference: b3 }), z = ((_b = y10.histograms) == null ? void 0 : _b.length) ? y10.histograms : null, L3 = new n5({ origin: y10.origin, blockWidth: y10.blockWidth, blockHeight: y10.blockHeight, firstPyramidLevel: y10.firstPyramidLevel, maximumPyramidLevel: y10.maxPyramidLevel });
  return new u3({ width: j7, height: w8, bandCount: y10.bandCount, extent: S4, spatialReference: b3, pixelSize: k5, pixelType: y10.pixelType.toLowerCase(), statistics: P2, histograms: z, keyProperties: v7, storageInfo: L3 });
}

// node_modules/@arcgis/core/rest/support/ImageAngleParameters.js
var n8;
var m5 = n8 = class extends l {
  constructor() {
    super(...arguments), this.angleNames = null, this.point = null, this.spatialReference = null, this.rasterId = null;
  }
  clone() {
    return new n8(y({ angleNames: this.angleNames, point: this.point, spatialReference: this.spatialReference, rasterId: this.rasterId }));
  }
};
e2([y2({ type: [String], json: { name: "angleName", write: true } })], m5.prototype, "angleNames", void 0), e2([y2({ type: w2, json: { write: true } })], m5.prototype, "point", void 0), e2([y2({ type: k, json: { write: true } })], m5.prototype, "spatialReference", void 0), e2([y2({ type: T, json: { write: true } })], m5.prototype, "rasterId", void 0), m5 = n8 = e2([n("esri.rest.support.ImageAngleParameters")], m5);
var l5 = m5;

// node_modules/@arcgis/core/rest/support/ImageHistogramParameters.js
var y8;
var j5 = y8 = class extends l {
  constructor() {
    super(...arguments), this.geometry = null, this.mosaicRule = null, this.renderingRule = null, this.pixelSize = null, this.raster = void 0, this.timeExtent = null;
  }
  writeGeometry(e5, r4, t4) {
    null != e5 && (r4.geometryType = c(e5), r4[t4] = e5.toJSON());
  }
  clone() {
    return new y8(y({ geometry: this.geometry, mosaicRule: this.mosaicRule, renderingRule: this.renderingRule, pixelSize: this.pixelSize, raster: this.raster, timeExtent: this.timeExtent }));
  }
};
e2([y2({ types: i, json: { read: v3 } })], j5.prototype, "geometry", void 0), e2([r2("geometry")], j5.prototype, "writeGeometry", null), e2([y2({ type: y5, json: { write: true } })], j5.prototype, "mosaicRule", void 0), e2([y2({ type: w5, json: { write: true } })], j5.prototype, "renderingRule", void 0), e2([y2({ type: w2, json: { write: true } })], j5.prototype, "pixelSize", void 0), e2([y2({ json: { write: true } })], j5.prototype, "raster", void 0), e2([y2({ type: T2, json: { read: { source: "time" }, write: { target: "time" } } })], j5.prototype, "timeExtent", void 0), j5 = y8 = e2([n("esri.rest.support.ImageHistogramParameters")], j5);
var d4 = j5;

// node_modules/@arcgis/core/rest/support/ImageIdentifyParameters.js
var y9;
var c8 = y9 = class extends l {
  constructor() {
    super(...arguments), this.geometry = null, this.renderingRules = null, this.pixelSize = null, this.returnGeometry = true, this.returnCatalogItems = true, this.returnPixelValues = true, this.maxItemCount = null, this.timeExtent = null, this.raster = void 0, this.viewId = void 0, this.processAsMultidimensional = false;
  }
  writeGeometry(e5, t4, r4) {
    null != e5 && (t4.geometryType = c(e5), t4[r4] = JSON.stringify(e5.toJSON()));
  }
  set mosaicRule(e5) {
    let t4 = e5;
    t4 && t4.mosaicMethod && (t4 = y5.fromJSON({ ...t4.toJSON(), mosaicMethod: t4.mosaicMethod, mosaicOperation: t4.mosaicOperation })), this._set("mosaicRule", t4);
  }
  writeMosaicRule(e5, t4, r4) {
    null != e5 && (t4[r4] = JSON.stringify(e5.toJSON()));
  }
  set renderingRule(e5) {
    let t4 = e5;
    t4 && t4.rasterFunction && (t4 = w5.fromJSON({ ...t4.toJSON(), rasterFunction: t4.rasterFunction, rasterFunctionArguments: t4.rasterFunctionArguments })), this._set("renderingRule", t4);
  }
  writeRenderingRule(e5, t4, r4) {
    null != e5 && (t4[r4] = JSON.stringify(e5.toJSON())), e5.rasterFunctionDefinition && (t4[r4] = JSON.stringify(e5.rasterFunctionDefinition));
  }
  writeRenderingRules(e5, t4, r4) {
    null != e5 && (t4[r4] = JSON.stringify(e5.map((e6) => e6.rasterFunctionDefinition || e6.toJSON())));
  }
  writePixelSize(e5, t4, r4) {
    null != e5 && (t4[r4] = JSON.stringify(e5));
  }
  writeTimeExtent(e5, t4, r4) {
    if (null != e5) {
      const o5 = r(e5.start) ? e5.start.getTime() : null, s7 = r(e5.end) ? e5.end.getTime() : null;
      t4[r4] = null != o5 ? null != s7 ? `${o5},${s7}` : `${o5}` : null;
    }
  }
  clone() {
    return new y9(y({ geometry: this.geometry, mosaicRule: this.mosaicRule, renderingRule: this.renderingRule, pixelSize: this.pixelSize, returnGeometry: this.returnGeometry, returnCatalogItems: this.returnCatalogItems, returnPixelValues: this.returnPixelValues, maxItemCount: this.maxItemCount, processAsMultidimensional: this.processAsMultidimensional, raster: this.raster, viewId: this.viewId, timeExtent: this.timeExtent }));
  }
};
e2([y2({ json: { write: true } })], c8.prototype, "geometry", void 0), e2([r2("geometry")], c8.prototype, "writeGeometry", null), e2([y2({ type: y5, json: { write: true } })], c8.prototype, "mosaicRule", null), e2([r2("mosaicRule")], c8.prototype, "writeMosaicRule", null), e2([y2({ type: w5, json: { write: true } })], c8.prototype, "renderingRule", null), e2([r2("renderingRule")], c8.prototype, "writeRenderingRule", null), e2([y2({ type: [w5], json: { write: true } })], c8.prototype, "renderingRules", void 0), e2([r2("renderingRules")], c8.prototype, "writeRenderingRules", null), e2([y2({ type: w2, json: { write: true } })], c8.prototype, "pixelSize", void 0), e2([r2("pixelSize")], c8.prototype, "writePixelSize", null), e2([y2({ type: Boolean, json: { write: true } })], c8.prototype, "returnGeometry", void 0), e2([y2({ type: Boolean, json: { write: true } })], c8.prototype, "returnCatalogItems", void 0), e2([y2({ type: Boolean, json: { write: true } })], c8.prototype, "returnPixelValues", void 0), e2([y2({ type: Number, json: { write: true } })], c8.prototype, "maxItemCount", void 0), e2([y2({ type: T2, json: { write: { target: "time" } } })], c8.prototype, "timeExtent", void 0), e2([r2("timeExtent")], c8.prototype, "writeTimeExtent", null), e2([y2({ json: { write: true } })], c8.prototype, "raster", void 0), e2([y2({ json: { write: true } })], c8.prototype, "viewId", void 0), e2([y2({ type: Boolean, json: { write: true } })], c8.prototype, "processAsMultidimensional", void 0), c8 = y9 = e2([n("esri.rest.support.ImageIdentifyParameters")], c8);
var d5 = c8;

// node_modules/@arcgis/core/rest/support/ImagePixelLocationParameters.js
var m6;
var c9 = m6 = class extends l {
  constructor() {
    super(...arguments), this.geometries = null, this.rasterId = null;
  }
  writeGeometry(r4, e5, o5) {
    e5.geometries = { geometryType: "esriGeometryPoint", geometries: r4.map((r5) => r5.toJSON()) };
  }
  clone() {
    var _a, _b;
    return new m6({ geometries: (_b = (_a = this.geometries) == null ? void 0 : _a.map((r4) => r4.clone())) != null ? _b : [], rasterId: this.rasterId });
  }
};
e2([y2({ type: [w2], json: { write: true } })], c9.prototype, "geometries", void 0), e2([r2("geometries")], c9.prototype, "writeGeometry", null), e2([y2({ type: T, json: { write: true } })], c9.prototype, "rasterId", void 0), c9 = m6 = e2([n("esri.rest.support.ImagePixelLocationParameters")], c9);
var a3 = c9;

// node_modules/@arcgis/core/rest/support/ImageSampleParameters.js
var d6;
var j6 = d6 = class extends l {
  constructor() {
    super(...arguments), this.geometry = null, this.interpolation = "nearest", this.mosaicRule = null, this.outFields = null, this.pixelSize = null, this.returnFirstValueOnly = true, this.sampleDistance = null, this.sampleCount = null, this.sliceId = null, this.timeExtent = null;
  }
  writeGeometry(t4, e5, o5) {
    null != t4 && (e5.geometryType = c(t4), e5[o5] = t4.toJSON());
  }
  set locations(t4) {
    if (t4 == null ? void 0 : t4.length) {
      const e5 = new u({ spatialReference: t4[0].spatialReference });
      e5.points = t4.map((t5) => [t5.x, t5.y]), this._set("locations", t4), this.geometry = e5;
    }
  }
  clone() {
    return new d6(y({ geometry: this.geometry, locations: this.locations, interpolation: this.interpolation, mosaicRule: this.mosaicRule, outFields: this.outFields, raster: this.raster, returnFirstValueOnly: this.returnFirstValueOnly, sampleDistance: this.sampleDistance, sampleCount: this.sampleCount, sliceId: this.sliceId, pixelSize: this.pixelSize, timeExtent: this.timeExtent }));
  }
};
e2([y2({ types: i, json: { read: v3 } })], j6.prototype, "geometry", void 0), e2([r2("geometry")], j6.prototype, "writeGeometry", null), e2([y2()], j6.prototype, "locations", null), e2([y2({ type: String, json: { type: o4.jsonValues, read: o4.read, write: o4.write } })], j6.prototype, "interpolation", void 0), e2([y2({ type: y5, json: { write: true } })], j6.prototype, "mosaicRule", void 0), e2([y2({ type: [String], json: { write: true } })], j6.prototype, "outFields", void 0), e2([y2({ type: w2, json: { write: true } })], j6.prototype, "pixelSize", void 0), e2([y2({ type: String, json: { write: true } })], j6.prototype, "raster", void 0), e2([y2({ type: Boolean, json: { write: true } })], j6.prototype, "returnFirstValueOnly", void 0), e2([y2({ type: Number, json: { write: true } })], j6.prototype, "sampleDistance", void 0), e2([y2({ type: Number, json: { write: true } })], j6.prototype, "sampleCount", void 0), e2([y2({ type: Number, json: { write: true } })], j6.prototype, "sliceId", void 0), e2([y2({ type: T2, json: { read: { source: "time" }, write: { target: "time" } } })], j6.prototype, "timeExtent", void 0), j6 = d6 = e2([n("esri.rest.support.ImageSampleParameters")], j6);
var h5 = j6;

// node_modules/@arcgis/core/layers/mixins/ArcGISImageService.js
var Se = o2()({ U1: "u1", U2: "u2", U4: "u4", U8: "u8", S8: "s8", U16: "u16", S16: "s16", U32: "u32", S32: "s32", F32: "f32", F64: "f64", C64: "c64", C128: "c128", UNKNOWN: "unknown" });
var ve = /* @__PURE__ */ new Set(["png", "png8", "png24", "png32", "jpg", "bmp", "gif", "jpgpng", "lerc", "tiff"]);
var be = j(a, { min: 0, max: 255 });
function Ie(e5) {
  var _a;
  if (!e5)
    return null;
  const t4 = (_a = JSON.stringify(e5).match(/"rasterFunction":"(.*?")/gi)) == null ? void 0 : _a.map((e6) => e6.replace('"rasterFunction":"', "").replace('"', ""));
  return t4 ? t4.join("/") : null;
}
var xe = (a4) => {
  let y10 = class extends a4 {
    constructor() {
      super(...arguments), this._functionRasterInfos = {}, this._rasterJobHandler = { instance: null, refCount: 0, connectionPromise: null }, this._cachedRendererJson = null, this._serviceSupportsMosaicRule = null, this._rasterAttributeTableFieldPrefix = "Raster.", this.adjustAspectRatio = null, this.bandIds = void 0, this.capabilities = null, this.compressionQuality = void 0, this.compressionTolerance = 0.01, this.copyright = null, this.defaultMosaicRule = null, this.definitionExpression = null, this.exportImageServiceParameters = null, this.rasterInfo = null, this.fields = null, this.fullExtent = null, this.hasMultidimensions = false, this.imageMaxHeight = 4100, this.imageMaxWidth = 4100, this.interpolation = void 0, this.minScale = 0, this.maxScale = 0, this.multidimensionalSubset = null, this.noData = null, this.noDataInterpretation = void 0, this.objectIdField = null, this.geometryType = "polygon", this.typeIdField = null, this.types = [], this.pixelFilter = null, this.raster = void 0, this.sourceType = null, this.viewId = void 0, this.symbolizer = null, this.rasterFunctionInfos = null, this.serviceDataType = null, this.spatialReference = null, this.pixelType = null, this.serviceRasterInfo = null, this.sourceJSON = null, this.url = null, this.version = void 0;
    }
    initialize() {
      this._set("exportImageServiceParameters", new y6({ layer: this }));
    }
    readServiceSupportsMosaicRule(e5, t4) {
      return this._isMosaicRuleSupported(t4);
    }
    get _rasterFunctionNamesIndex() {
      const e5 = /* @__PURE__ */ new Map();
      return !this.rasterFunctionInfos || r(this.rasterFunctionInfos) && this.rasterFunctionInfos.length < 1 || r(this.rasterFunctionInfos) && this.rasterFunctionInfos.forEach((t4) => {
        e5.set(t4.name.toLowerCase().replace(/ /gi, "_"), t4.name);
      }), e5;
    }
    readBandIds(e5, t4) {
      if (Array.isArray(e5) && e5.length > 0 && e5.every((e6) => "number" == typeof e6))
        return e5;
    }
    readCapabilities(e5, t4) {
      return this._readCapabilities(t4);
    }
    writeCompressionQuality(e5, t4, r4) {
      null != e5 && "lerc" !== this.format && (t4[r4] = e5);
    }
    writeCompressionTolerance(e5, t4, r4) {
      "lerc" === this.format && null != e5 && (t4[r4] = e5);
    }
    readDefaultMosaicRule(e5, t4) {
      return this._serviceSupportsMosaicRule ? y5.fromJSON(t4) : null;
    }
    get fieldsIndex() {
      return this.fields ? new r3(this.fields) : null;
    }
    set format(e5) {
      e5 && ve.has(e5.toLowerCase()) && this._set("format", e5.toLowerCase());
    }
    readFormat(e5, t4) {
      return "esriImageServiceDataTypeVector-UV" === t4.serviceDataType || "esriImageServiceDataTypeVector-MagDir" === t4.serviceDataType || null != this.pixelFilter ? "lerc" : "jpgpng";
    }
    readMinScale(e5, t4) {
      return null != t4.minLOD && null != t4.maxLOD ? e5 : 0;
    }
    readMaxScale(e5, t4) {
      return null != t4.minLOD && null != t4.maxLOD ? e5 : 0;
    }
    set mosaicRule(e5) {
      let t4 = e5;
      t4 && t4.mosaicMethod && (t4 = y5.fromJSON({ ...t4.toJSON(), mosaicMethod: t4.mosaicMethod, mosaicOperation: t4.mosaicOperation })), this._set("mosaicRule", t4);
    }
    readMosaicRule(e5, t4) {
      const r4 = e5 || t4.mosaicRule;
      return r4 ? y5.fromJSON(r4) : this._isMosaicRuleSupported(t4) ? y5.fromJSON(t4) : null;
    }
    writeMosaicRule(e5, t4, r4) {
      let i7 = this.mosaicRule;
      const s7 = this.definitionExpression;
      i7 ? s7 && s7 !== i7.where && (i7 = i7.clone(), i7.where = s7) : s7 && (i7 = new y5({ where: s7 })), this._isValidCustomizedMosaicRule(i7) && (t4[r4] = i7.toJSON());
    }
    get multidimensionalInfo() {
      return r(this.serviceRasterInfo) ? this.serviceRasterInfo.multidimensionalInfo : null;
    }
    writeNoData(e5, t4, r4) {
      null != e5 && "number" == typeof e5 && (t4[r4] = be(e5));
    }
    readObjectIdField(e5, t4) {
      if (!e5) {
        const r4 = t4.fields.filter((e6) => "esriFieldTypeOID" === e6.type || "oid" === e6.type);
        e5 = r4 && r4[0] && r4[0].name;
      }
      return e5;
    }
    get parsedUrl() {
      return j2(this.url);
    }
    readSourceType(e5, t4) {
      return this._isMosaicDataset(t4) ? "mosaic-dataset" : "raster-dataset";
    }
    set renderer(e5) {
      this.loaded && (e5 = this._configRenderer(e5)), this._set("renderer", e5);
    }
    readRenderer(e5, t4, r4) {
      var _a, _b;
      const i7 = (_b = (_a = t4 == null ? void 0 : t4.layerDefinition) == null ? void 0 : _a.drawingInfo) == null ? void 0 : _b.renderer, n9 = u2(i7, r4);
      return null == n9 ? null : ("vector-field" === n9.type && t4.symbolTileSize && !i7.symbolTileSize && (n9.symbolTileSize = t4.symbolTileSize), f7(n9) || s.getLogger(this.declaredClass).warn("ArcGISImageService", "Imagery layer doesn't support given renderer type."), n9);
    }
    writeRenderer(e5, t4, r4) {
      t4.layerDefinition = t4.layerDefinition || {}, t4.layerDefinition.drawingInfo = t4.layerDefinition.drawingInfo || {}, t4.layerDefinition.drawingInfo.renderer = e5.toJSON(), "vector-field" === e5.type && (t4.symbolTileSize = e5.symbolTileSize);
    }
    get rasterFields() {
      var _a, _b;
      const e5 = this._rasterAttributeTableFieldPrefix || "Raster.", t4 = new y3({ name: "Raster.ItemPixelValue", alias: "Item Pixel Value", domain: null, editable: false, length: 50, type: "string" }), r4 = new y3({ name: "Raster.ServicePixelValue", alias: "Service Pixel Value", domain: null, editable: false, length: 50, type: "string" }), i7 = new y3({ name: "Raster.ServicePixelValue.Raw", alias: "Raw Service Pixel Value", domain: null, editable: false, length: 50, type: "string" });
      let s7 = this.fields ? y(this.fields) : [];
      s7.push(r4), ((_a = this.capabilities) == null ? void 0 : _a.operations.supportsQuery) && this.fields && this.fields.length > 0 && s7.push(t4), this.version >= 10.4 && r(this.rasterFunctionInfos) && this.rasterFunctionInfos.some((e6) => "none" === e6.name.toLowerCase()) && s7.push(i7), r(this.rasterFunctionInfos) && this.rasterFunctionInfos.filter((e6) => "none" !== e6.name.toLowerCase()).forEach((e6) => {
        s7.push(new y3({ name: "Raster.ServicePixelValue." + e6.name, alias: e6.name, domain: null, editable: false, length: 50, type: "string" }));
      }), this._isVectorDataSet() && (s7.push(new y3({ name: "Raster.Magnitude", alias: "Magnitude", domain: null, editable: false, type: "double" })), s7.push(new y3({ name: "Raster.Direction", alias: "Direction", domain: null, editable: false, type: "double" })));
      const { attributeTable: n9 } = (_b = this.rasterInfo) != null ? _b : {};
      if (r(n9)) {
        const t5 = n9.fields.filter((e6) => "esriFieldTypeOID" !== e6.type && "value" !== e6.name.toLowerCase()).map((t6) => {
          const r5 = y(t6);
          return r5.name = e5 + t6.name, r5;
        });
        s7 = s7.concat(t5);
      }
      return s7;
    }
    set renderingRule(e5) {
      let t4 = e5;
      t4 && t4.rasterFunction && (t4 = w5.fromJSON({ ...t4.toJSON(), rasterFunction: t4.rasterFunction, rasterFunctionArguments: t4.rasterFunctionArguments })), this._set("renderingRule", t4);
    }
    readRenderingRule(e5, t4) {
      const r4 = t4.rasterFunctionInfos;
      return t4.renderingRule || r4 && r4.length && "None" !== r4[0].name ? this._isRFTJson(t4.renderingRule) ? w5.fromJSON({ rasterFunctionDefinition: t4.renderingRule }) : w5.fromJSON(t4.renderingRule || { rasterFunctionInfos: t4.rasterFunctionInfos }) : null;
    }
    writeRenderingRule(e5, t4, r4) {
      const i7 = e5.toJSON();
      i7.rasterFunctionDefinition ? t4[r4] = i7.rasterFunctionDefinition : t4[r4] = i7;
    }
    readSpatialReference(e5, t4) {
      const r4 = e5 || t4.extent.spatialReference;
      return r4 ? k.fromJSON(r4) : null;
    }
    readPixelType(e5) {
      return Se.fromJSON(e5) || e5;
    }
    writePixelType(e5, t4, r4) {
      (t(this.serviceRasterInfo) || this.pixelType !== this.serviceRasterInfo.pixelType) && (t4[r4] = Se.toJSON(e5));
    }
    readVersion(e5, t4) {
      let r4 = t4.currentVersion;
      return r4 || (r4 = t4.hasOwnProperty("fields") || t4.hasOwnProperty("timeInfo") ? 10 : 9.3), r4;
    }
    applyFilter(e5) {
      let t4 = e5;
      return this.pixelFilter && (t4 = this._clonePixelData(e5), this.pixelFilter(t4)), t4;
    }
    async applyRenderer(e5, t4) {
      let r4 = e5;
      const { renderer: i7, symbolizer: s7, pixelFilter: n9, bandIds: o5 } = this;
      if (!this._isPicture() && i7 && s7 && !n9) {
        const n10 = JSON.stringify(this._cachedRendererJson) !== JSON.stringify(i7.toJSON()), a5 = this._rasterJobHandler.instance;
        if (a5) {
          n10 && (s7.bind(), await a5.updateSymbolizer(s7, t4), this._cachedRendererJson = i7.toJSON());
          const l6 = await a5.symbolize({ bandIds: o5, ...e5 }, t4);
          r4 = { extent: e5.extent, pixelBlock: l6 };
        } else
          r4 = { extent: e5.extent, pixelBlock: s7.symbolize({ bandIds: o5, ...e5 }) };
      }
      return r4;
    }
    destroy() {
      this._shutdownJobHandler();
    }
    increaseRasterJobHandlerUsage() {
      this._rasterJobHandler.refCount++;
    }
    decreaseRasterJobHandlerUsage() {
      this._rasterJobHandler.refCount--, this._rasterJobHandler.refCount <= 0 && this._shutdownJobHandler();
    }
    async computeAngles(e5, t4) {
      if (!(await this._fetchCapabilities(t4 == null ? void 0 : t4.signal)).operations.supportsComputeAngles)
        throw new s2("imagery-layer:compute-angles", "this operation is not supported on the input image service");
      return e5 = v(l5, e5).clone(), f8(this.url, e5, this._getRequestOptions(t4));
    }
    async computePixelSpaceLocations(e5, t4) {
      if (!(await this._fetchCapabilities(t4 == null ? void 0 : t4.signal)).operations.supportsComputePixelLocation)
        throw new s2("imagery-layer:compute-pixel-space-locations", "this operation is not supported on the input image service");
      return e5 = v(a3, e5).clone(), g4(this.url, e5, this._getRequestOptions(t4));
    }
    async computeHistograms(e5, t4) {
      if (!(await this._fetchCapabilities(t4 == null ? void 0 : t4.signal)).operations.supportsComputeHistograms)
        throw new s2("imagery-layer:compute-histograms", "this operation is not supported on the input image service");
      e5 = v(d4, e5).clone();
      const { raster: r4, mosaicRule: i7, renderingRule: s7 } = this;
      return s7 && null == e5.renderingRule && (e5.renderingRule = s7), i7 && null == e5.mosaicRule && (e5.mosaicRule = i7), r4 && null == e5.raster && (e5.raster = r4), d3(this.url, e5, this._getRequestOptions(t4));
    }
    async computeStatisticsHistograms(e5, t4) {
      if (!(await this._fetchCapabilities(t4 == null ? void 0 : t4.signal)).operations.supportsComputeStatisticsHistograms)
        throw new s2("imagery-layer:compute-statistics-histograms", "this operation is not supported on the input image service");
      e5 = v(d4, e5).clone();
      const { raster: r4, mosaicRule: i7, renderingRule: s7 } = this;
      return s7 && null == e5.renderingRule && (e5.renderingRule = s7), i7 && null == e5.mosaicRule && (e5.mosaicRule = i7), r4 && null == e5.raster && (e5.raster = r4), y7(this.url, e5, this._getRequestOptions(t4));
    }
    getField(e5) {
      const { fieldsIndex: t4 } = this;
      return r(t4) ? t4.get(e5) : void 0;
    }
    getFieldDomain(e5, t4) {
      const r4 = this.getField(e5);
      return r4 ? r4.domain : null;
    }
    async fetchImage(e5, t4, r4, i7 = {}) {
      var _a, _b, _c, _d, _e;
      if (null == e5 || null == t4 || null == r4)
        throw new s2("imagery-layer:fetch-image", "Insufficient parameters for requesting an image. A valid extent, width and height values are required.");
      if (this.renderer || this.symbolizer) {
        const e6 = await this.generateRasterInfo(this.renderingRule, { signal: i7.signal });
        e6 && (this.rasterInfo = e6);
      }
      const s7 = this.getExportImageServiceParameters(e5, t4, r4, i7.timeExtent);
      if (null == s7) {
        if (i7.requestAsImageElement && this._canRequestImageElement(this.format)) {
          const e6 = document.createElement("canvas");
          return e6.width = t4, e6.height = r4, { imageOrCanvasElement: e6 };
        }
        const s8 = (_c = ((_a = this.bandIds) == null ? void 0 : _a.length) || ((_b = this.rasterInfo) == null ? void 0 : _b.bandCount)) != null ? _c : 0, n10 = t4 * r4, o5 = (_e = (_d = this.rasterInfo) == null ? void 0 : _d.pixelType) != null ? _e : "unknown", a5 = [];
        for (let e6 = 0; e6 < s8; e6++)
          a5.push(g2.createEmptyBand(o5, n10));
        return { pixelData: { pixelBlock: new g2({ width: t4, height: r4, pixels: a5, mask: new Uint8Array(n10), pixelType: o5 }), extent: e5 } };
      }
      const n9 = { imageServiceParameters: s7, imageProps: { extent: e5, width: t4, height: r4, format: this.format }, requestAsImageElement: i7.requestAsImageElement && !this.pixelFilter || false, signal: i7.signal };
      return this._requestArrayBuffer(n9);
    }
    fetchKeyProperties(e5) {
      return U(S4(this.parsedUrl) + "/keyProperties", { query: this._getQueryParams({ renderingRule: this.version >= 10.3 ? e5 == null ? void 0 : e5.renderingRule : null }) }).then((e6) => e6.data);
    }
    fetchRasterAttributeTable(e5) {
      return this.version < 10.1 ? Promise.reject(new s2("#fetchRasterAttributeTable()", "Failed to get rasterAttributeTable")) : U(S4(this.parsedUrl) + "/rasterAttributeTable", { query: this._getQueryParams({ renderingRule: this.version >= 10.3 ? e5 == null ? void 0 : e5.renderingRule : null }) }).then((e6) => x.fromJSON(e6.data));
    }
    getCatalogItemRasterInfo(e5, t4) {
      const r4 = { ...t4, query: this._getQueryParams() };
      return n7(S4(this.parsedUrl), e5, r4);
    }
    async getCatalogItemICSInfo(e5, t4) {
      var _a, _b, _c;
      const { data: r4 } = await U(S4(this.parsedUrl) + "/" + e5 + "/info/ics", { query: this._getQueryParams(), ...t4 }), i7 = r4 && r4.ics;
      if (!i7)
        return;
      let s7 = null;
      try {
        s7 = (await U(S4(this.parsedUrl) + "/" + e5 + "/info", { query: this._getQueryParams(), ...t4 })).data.extent;
      } catch {
      }
      if (!s7 || !s7.spatialReference)
        return { ics: i7, icsToPixelTransform: null, icsExtent: null, northDirection: null };
      const o5 = this.version >= 10.7 ? U(S4(this.parsedUrl) + "/" + e5 + "/info/icstopixel", { query: this._getQueryParams(), ...t4 }).then((e6) => e6.data).catch(() => ({})) : {}, a5 = s7.spatialReference, l6 = { geometries: JSON.stringify({ geometryType: "esriGeometryEnvelope", geometries: [s7] }), inSR: a5.wkid || JSON.stringify(a5), outSR: "0:" + e5 }, u6 = U(S4(this.parsedUrl) + "/project", { query: this._getQueryParams(l6), ...t4 }).then((e6) => e6.data).catch(() => ({})), p13 = 5, c10 = (s7.xmin + s7.xmax) / 2, m7 = (s7.ymax - s7.ymin) / (p13 + 1), d7 = s7.ymin + m7, h6 = [];
      for (let n9 = 0; n9 < p13; n9++)
        h6.push({ x: c10, y: d7 + m7 * n9 });
      const f9 = { geometries: JSON.stringify({ geometryType: "esriGeometryPoint", geometries: h6 }), inSR: a5.wkid || JSON.stringify(a5), outSR: "0:" + e5 }, y11 = U(S4(this.parsedUrl) + "/project", { query: this._getQueryParams(f9), ...t4 }).then((e6) => e6.data).catch(() => ({})), g5 = await Promise.all([o5, u6, y11]);
      let R3 = g5[0].ipxf;
      if (null == R3) {
        const e6 = (_a = i7.geodataXform) == null ? void 0 : _a.xf_0;
        "topup" === ((_b = e6 == null ? void 0 : e6.name) == null ? void 0 : _b.toLowerCase()) && 6 === ((_c = e6 == null ? void 0 : e6.coefficients) == null ? void 0 : _c.length) && (R3 = { affine: { name: "ics [sensor: Frame] to pixel (column, row) transformation", coefficients: e6.coefficients, cellsizeRatio: 0, type: "GeometricXform" } });
      }
      const v7 = w3.fromJSON(g5[1] && g5[1].geometries && g5[1].geometries[0]);
      v7 && (v7.spatialReference = new k({ wkid: 0, imageCoordinateSystem: i7 }));
      const b3 = g5[2].geometries ? g5[2].geometries.filter((e6) => null != e6 && null != e6.x && null != e6.y && "NaN" !== e6.x && "NaN" !== e6.y) : [], I = b3.length;
      if (I < 3)
        return { ics: i7, icsToPixelTransform: R3, icsExtent: v7, northDirection: null };
      let x4 = 0, w8 = 0, _2 = 0, F2 = 0;
      for (let n9 = 0; n9 < I; n9++)
        x4 += b3[n9].x, w8 += b3[n9].y, _2 += b3[n9].x * b3[n9].x, F2 += b3[n9].x * b3[n9].y;
      const D2 = (I * F2 - x4 * w8) / (I * _2 - x4 * x4);
      let j7 = 0;
      const T6 = b3[p13 - 1].x > b3[0].x, P2 = b3[p13 - 1].y > b3[0].y;
      return D2 === 1 / 0 ? j7 = P2 ? 90 : 270 : 0 === D2 ? j7 = T6 ? 0 : 180 : D2 > 0 ? j7 = T6 ? 180 * Math.atan(D2) / Math.PI : 180 * Math.atan(D2) / Math.PI + 180 : D2 < 0 && (j7 = P2 ? 180 + 180 * Math.atan(D2) / Math.PI : 360 + 180 * Math.atan(D2) / Math.PI), { ics: i7, icsToPixelTransform: R3, icsExtent: v7, northDirection: j7 };
    }
    async generateRasterInfo(e5, t4) {
      var _a;
      if (this.serviceRasterInfo && (!e5 || "none" === ((_a = e5.functionName) == null ? void 0 : _a.toLowerCase()) || this._isVectorFieldResampleFunction(e5)))
        return this.serviceRasterInfo;
      const r4 = Ie(e5);
      if (!r4)
        return null;
      if (this._functionRasterInfos[r4])
        return this._functionRasterInfos[r4];
      const i7 = this._generateRasterInfo(e5, t4);
      this._functionRasterInfos[r4] = i7;
      try {
        return await i7;
      } catch {
        return this._functionRasterInfos[r4] = null, null;
      }
    }
    getExportImageServiceParameters(e5, t4, r4, i7) {
      var _a, _b, _c;
      e5 = e5.clone().shiftCentralMeridian();
      const s7 = R2(e5.spatialReference, S4(this.parsedUrl));
      this.pixelType !== ((_a = this.serviceRasterInfo) == null ? void 0 : _a.pixelType) && (this.exportImageServiceParameters.pixelType = this.pixelType);
      const n9 = this.exportImageServiceParameters.toJSON(), { bandIds: o5, noData: a5 } = n9;
      let { renderingRule: l6 } = n9;
      const u6 = (_b = this.renderingRule) == null ? void 0 : _b.rasterFunctionDefinition, c10 = !this.renderer || "raster-stretch" === this.renderer.type;
      if ((o5 == null ? void 0 : o5.length) && this._hasRenderingRule(this.renderingRule) && !u6 && c10) {
        const e6 = { rasterFunction: "ExtractBand", rasterFunctionArguments: { BandIds: o5 } };
        if ("Stretch" === l6.rasterFunction)
          e6.rasterFunctionArguments.Raster = l6.rasterFunctionArguments.Raster, l6.rasterFunctionArguments.Raster = e6;
        else if ("Colormap" === l6.rasterFunction) {
          const t5 = l6.rasterFunctionArguments.Raster;
          "Stretch" === (t5 == null ? void 0 : t5.rasterFunction) ? (e6.rasterFunctionArguments.Raster = t5.rasterFunctionArguments.Raster, t5.rasterFunctionArguments.Raster = e6) : (e6.rasterFunctionArguments.Raster = t5, l6.rasterFunctionArguments.Raster = e6);
        } else
          e6.rasterFunctionArguments.Raster = l6, l6 = e6;
        n9.bandIds = void 0;
      } else
        n9.bandIds = o5 == null ? void 0 : o5.join(",");
      a5 instanceof Array && a5.length > 0 && (n9.noData = a5.join(","));
      const m7 = this._serviceSupportsMosaicRule ? this._combineMosaicRuleWithTimeExtent(this.exportImageServiceParameters.mosaicRule, i7) : null;
      n9.mosaicRule = r(m7) ? JSON.stringify(m7) : null;
      const { multidimensionalSubset: d7 } = this;
      if (d7 && r(m7) && m7.multidimensionalDefinition && m(m7.multidimensionalDefinition, d7, true))
        return null;
      n9.renderingRule = this._getRenderingRuleString(w5.fromJSON(l6));
      const h6 = {};
      if (i7) {
        const { start: e6, end: t5 } = i7.toJSON();
        let r5;
        if (e6 && t5 && e6 === t5 ? (h6.time = "" + e6, r5 = [e6]) : null == e6 && null == t5 || (h6.time = `${e6 != null ? e6 : "null"},${t5 != null ? t5 : "null"}`, r5 = null != e6 && null != t5 ? [e6, t5] : [e6 != null ? e6 : t5]), r5 && d7) {
          const e7 = d7.dimensions.find(({ name: e8 }) => "StdTime" === e8);
          if (2 === r5.length && e7.extent.length) {
            if (r5[0] = Math.max(r5[0], e7.extent[0]), r5[1] = Math.min(r5[1], (_c = e7.extent[1]) != null ? _c : e7.extent[0]), r5[1] < r5[0])
              return null;
            h6.time = r5.join();
          }
          const t6 = new p5({ variableName: "", dimensionName: "StdTime", isSlice: 1 === r5.length, values: r5 });
          if (m([t6], d7, true))
            return null;
        }
      }
      return { bbox: e5.xmin + "," + e5.ymin + "," + e5.xmax + "," + e5.ymax, bboxSR: s7, imageSR: s7, size: t4 + "," + r4, ...n9, ...h6 };
    }
    async getSamples(e5, t4) {
      var _a;
      if (!((_a = await this._fetchCapabilities(t4 == null ? void 0 : t4.signal)) == null ? void 0 : _a.operations.supportsGetSamples))
        throw new s2("imagery-layer:get-samples", "getSamples operation is not supported on the input image service");
      e5 = v(h5, e5).clone();
      const { raster: r4 } = this;
      return r4 && null == e5.raster && (e5.raster = r4), N2(this.url, e5, this._getRequestOptions(t4));
    }
    async identify(e5, t4) {
      if (!(await this._fetchCapabilities(t4 == null ? void 0 : t4.signal)).operations.supportsIdentify)
        throw new s2("imagery-layer:query-rasters", "query operation is not supported on the input image service");
      e5 = v(d5, e5).clone();
      const { raster: r4, mosaicRule: i7, renderingRule: s7 } = this;
      if (s7 && null == e5.renderingRule && (e5.renderingRule = s7), i7 && null == e5.mosaicRule) {
        const t5 = this._combineMosaicRuleWithTimeExtent(i7, e5.timeExtent);
        e5.mosaicRule = e(t5);
      }
      return r4 && null == e5.raster && (e5.raster = r4), S3(this.url, e5, this._getRequestOptions(t4));
    }
    createQuery() {
      const e5 = new x2();
      return e5.outFields = ["*"], e5.returnGeometry = true, e5.where = this.definitionExpression || "1=1", e5;
    }
    async queryRasters(e5, t4) {
      return { query: e5, requestOptions: t4 } = await this._prepareForQuery(e5, t4), s5(this.url, e5, t4);
    }
    async queryObjectIds(e5, t4) {
      return { query: e5, requestOptions: t4 } = await this._prepareForQuery(e5, t4), s6(this.url, e5, t4);
    }
    async queryRasterCount(e5, t4) {
      return { query: e5, requestOptions: t4 } = await this._prepareForQuery(e5, t4), n3(this.url, e5, t4);
    }
    async queryVisibleRasters(e5, t4) {
      var _a, _b, _c, _d;
      if (!e5)
        throw new s2("imagery-layer: query-visible-rasters", "missing query parameter");
      await this.load();
      const { pixelSize: r4, returnDomainValues: i7, returnTopmostRaster: s7, showNoDataRecords: n9 } = t4 || { pixelSize: null, returnDomainValues: false, returnTopmostRaster: false, showNoDataRecords: false };
      let a5 = false, l6 = null, u6 = null;
      const m7 = "raster.servicepixelvalue", d7 = this._rasterFunctionNamesIndex;
      if (r(e5.outFields) && (a5 = e5.outFields.some((e6) => !e6.toLowerCase().includes(m7)), this.version >= 10.4)) {
        const t5 = e5.outFields.filter((e6) => e6.toLowerCase().includes(m7) && e6.length > m7.length).map((e6) => {
          const t6 = e6.slice(m7.length + 1);
          return [this._updateRenderingRulesFunctionName(t6, d7), t6];
        });
        l6 = t5.map((e6) => new w5({ functionName: e6[0] })), u6 = t5.map((e6) => e6[1]);
        const { renderingRule: r5 } = this;
        0 === l6.length ? (r5 == null ? void 0 : r5.functionName) ? (l6.push(r5), u6.push(r5.functionName)) : l6 = null : (r5 == null ? void 0 : r5.functionName) && !l6.some((e6) => e6.functionName === r5.functionName) && (l6.push(r5), u6.push(r5.functionName));
      }
      const h6 = t(e5.outSpatialReference) || e5.outSpatialReference.equals(this.spatialReference), f9 = e5.timeExtent || this.timeExtent, y11 = this._combineMosaicRuleWithTimeExtent(this.exportImageServiceParameters.mosaicRule, f9), g5 = this._getQueryParams({ geometry: e5.geometry, timeExtent: f9, mosaicRule: y11, renderingRule: this.version < 10.4 ? this.renderingRule : null, renderingRules: l6, pixelSize: r4, returnCatalogItems: a5, returnGeometry: h6, raster: this.raster, maxItemCount: s7 ? 1 : null });
      delete g5.f;
      const R3 = new d5(g5);
      try {
        await this.generateRasterInfo(this.renderingRule);
        const r5 = await S3(this.url, R3, { signal: t4 == null ? void 0 : t4.signal, query: { ...this.customParameters } }), s8 = e5.outFields, o5 = null != r5.value && r5.value.toLowerCase().includes("nodata");
        if (!(a5 && !h6 && ((_a = r5 == null ? void 0 : r5.catalogItems) == null ? void 0 : _a.features.length) && (n9 || !o5)))
          return this._processVisibleRastersResponse(r5, { returnDomainValues: i7, templateRRFunctionNames: u6, showNoDataRecords: n9, templateFields: s8 });
        const l7 = this.objectIdField || "ObjectId", c10 = (_c = (_b = r5.catalogItems) == null ? void 0 : _b.features) != null ? _c : [], m8 = c10.map((e6) => {
          var _a2;
          return (_a2 = e6.attributes) == null ? void 0 : _a2[l7];
        }), d8 = new x2({ objectIds: m8, returnGeometry: true, outSpatialReference: e5.outSpatialReference, outFields: [l7] }), f10 = await this.queryRasters(d8);
        return ((_d = f10 == null ? void 0 : f10.features) == null ? void 0 : _d.length) && f10.features.forEach((t5) => {
          c10.forEach((r6) => {
            r6.attributes[l7] === t5.attributes[l7] && (r6.geometry = new v2(t5.geometry), r(e5.outSpatialReference) && (r6.geometry.spatialReference = e5.outSpatialReference));
          });
        }), this._processVisibleRastersResponse(r5, { returnDomainValues: i7, templateRRFunctionNames: u6, showNoDataRecords: n9, templateFields: s8 });
      } catch {
        throw new s2("imagery-layer:query-visible-rasters", "encountered error when querying visible rasters");
      }
    }
    async fetchVariableStatisticsHistograms(e5, t4) {
      const r4 = U(S4(this.parsedUrl) + "/statistics", { query: this._getQueryParams({ variable: e5 }), signal: t4 }).then((e6) => {
        var _a;
        return (_a = e6.data) == null ? void 0 : _a.statistics;
      }), i7 = U(S4(this.parsedUrl) + "/histograms", { query: this._getQueryParams({ variable: e5 }), signal: t4 }).then((e6) => {
        var _a;
        return (_a = e6.data) == null ? void 0 : _a.histograms;
      }), s7 = await Promise.all([r4, i7]);
      return s7[0] && s7[0].forEach((e6) => {
        e6.avg = e6.mean, e6.stddev = e6.standardDeviation;
      }), { statistics: s7[0] || null, histograms: s7[1] || null };
    }
    async createFlowMesh(e5, t4) {
      const r4 = this._rasterJobHandler.instance;
      return r4 ? r4.createFlowMesh(e5, t4) : f6(e5.meshType, e5.simulationSettings, e5.flowData, r(t4.signal) ? t4.signal : new AbortController().signal);
    }
    getMultidimensionalSubsetVariables(e5) {
      const t4 = e5 != null ? e5 : this.multidimensionalInfo;
      return d(this.multidimensionalSubset, t4);
    }
    async _fetchService(e5) {
      await this._fetchServiceInfo(e5), this.rasterInfo || (this.rasterInfo = this.serviceRasterInfo);
      const t4 = this.sourceJSON, r4 = r(this.serviceRasterInfo) ? Promise.resolve(this.serviceRasterInfo) : m2(S4(this.parsedUrl), t4, { signal: e5, query: this._getQueryParams() }).then((e6) => (this._set("serviceRasterInfo", e6), e6)), i7 = this._hasRenderingRule(this.renderingRule) ? this.generateRasterInfo(this.renderingRule, { signal: e5 }) : null, s7 = this._getRasterFunctionInfos();
      return Promise.all([r4, i7, s7]).then((e6) => {
        e6[1] ? this._set("rasterInfo", e6[1]) : this._set("rasterInfo", e6[0]), e6[2] && this._set("rasterFunctionInfos", e6[2]), this.renderer && !this._isSupportedRenderer(this.renderer) && (this._set("renderer", null), s.getLogger(this.declaredClass).warn("ArcGISImageService", "Switching to the default renderer. Renderer applied is not valid for this Imagery Layer")), this._set("renderer", this._configRenderer(this.renderer)), this.addHandles([l2(() => this.renderingRule, (e7) => {
          (this.renderer || this.symbolizer || this.popupEnabled && this.popupTemplate) && this.generateRasterInfo(e7).then((e8) => {
            e8 && (this.rasterInfo = e8);
          });
        })]);
        const { serviceRasterInfo: t5 } = this;
        t5 && r(t5.multidimensionalInfo) && this._updateMultidimensionalDefinition(t5);
      });
    }
    _combineMosaicRuleWithTimeExtent(e5, t4) {
      var _a;
      const r4 = this.timeInfo;
      if (t(e5) || t(this.multidimensionalInfo) || t(t4) || t(r4 == null ? void 0 : r4.startField))
        return e5;
      const { startField: i7 } = r4, s7 = this.multidimensionalInfo.variables.some((e6) => e6.dimensions.some((e7) => e7.name === i7)) ? i7 : "StdTime";
      if (e5 = e5.clone(), "mosaic-dataset" === this.sourceType)
        return e5.multidimensionalDefinition = (_a = e5.multidimensionalDefinition) == null ? void 0 : _a.filter((e6) => e6.dimensionName !== s7), this._cleanupMultidimensionalDefinition(e5);
      e5.multidimensionalDefinition = e5.multidimensionalDefinition || [];
      const n9 = e5.multidimensionalDefinition.filter((e6) => e6.dimensionName === s7), o5 = r(t4.start) ? t4.start.getTime() : null, a5 = r(t4.end) ? t4.end.getTime() : null, l6 = null == o5 || null == a5 || o5 === a5, u6 = l6 ? [o5 || a5] : [[o5, a5]], m7 = this.version >= 10.8;
      if (n9.length)
        n9.forEach((e6) => {
          e6.dimensionName === s7 && (m7 ? (e6.dimensionName = null, e6.isSlice = false, e6.values = []) : (e6.isSlice = l6, e6.values = u6));
        });
      else if (!m7) {
        const t5 = e5.multidimensionalDefinition.filter((e6) => null != e6.variableName && null == e6.dimensionName);
        t5.length ? t5.forEach((e6) => {
          e6.dimensionName = s7, e6.isSlice = l6, e6.values = u6;
        }) : e5.multidimensionalDefinition.push(new p5({ variableName: "", dimensionName: s7, isSlice: l6, values: u6 }));
      }
      return this._cleanupMultidimensionalDefinition(e5);
    }
    _cleanupMultidimensionalDefinition(e5) {
      return t(e5) ? null : (e5.multidimensionalDefinition && (e5.multidimensionalDefinition = e5.multidimensionalDefinition.filter((e6) => !(!e6.variableName && !e6.dimensionName)), 0 === e5.multidimensionalDefinition.length && (e5.multidimensionalDefinition = null)), "mosaic-dataset" !== this.sourceType && null == e5.multidimensionalDefinition ? null : e5);
    }
    async _prepareForQuery(e5, t4) {
      if (!(await this._fetchCapabilities(t4 == null ? void 0 : t4.signal)).operations.supportsQuery)
        throw new s2("imagery-layer:query-rasters", "query operation is not supported on the input image service");
      return e5 = r(e5) ? v(x2, e5) : this.createQuery(), t4 = this._getRequestOptions(t4), this.raster && (t4.query = { ...t4.query, raster: this.raster }), { query: e5, requestOptions: t4 };
    }
    async _initJobHandler() {
      if (null != this._rasterJobHandler.connectionPromise)
        return this._rasterJobHandler.connectionPromise;
      const e5 = new n6();
      this._rasterJobHandler.connectionPromise = e5.initialize().then(() => {
        this._rasterJobHandler.instance = e5;
      }, () => {
      }), await this._rasterJobHandler.connectionPromise;
    }
    _shutdownJobHandler() {
      this._rasterJobHandler.instance && this._rasterJobHandler.instance.destroy(), this._rasterJobHandler.instance = null, this._rasterJobHandler.connectionPromise = null, this._rasterJobHandler.refCount = 0, this._cachedRendererJson = null;
    }
    _isSupportedRenderer(e5) {
      const { rasterInfo: t4, renderingRule: r4 } = this;
      return "unique-value" === e5.type && this._hasRenderingRule(r4) && 1 === (t4 == null ? void 0 : t4.bandCount) && ["u8", "s8"].includes(t4.pixelType) || null != t4 && null != e5 && k4(t4).includes(e5.type);
    }
    async _fetchCapabilities(e5) {
      return this.capabilities || await this._fetchServiceInfo(e5), this.capabilities;
    }
    async _fetchServiceInfo(e5) {
      var _a;
      let t4 = this.sourceJSON;
      if (!t4) {
        const { data: r4, ssl: i7 } = await U(S4(this.parsedUrl), { query: this._getQueryParams(), signal: e5 });
        t4 = r4, this.sourceJSON = t4, i7 && (this.url = this.url.replace(/^http:/i, "https:"));
      }
      if (((_a = t4.capabilities) == null ? void 0 : _a.toLowerCase().split(",").map((e6) => e6.trim()).indexOf("tilesonly")) > -1)
        throw new s2("imagery-layer:fetch-service-info", "use ImageryTileLayer to open tiles-only image services");
      this.read(t4, { origin: "service", url: this.parsedUrl });
    }
    _isMosaicDataset(e5) {
      var _a;
      return e5.serviceSourceType ? "esriImageServiceSourceTypeMosaicDataset" === e5.serviceSourceType : ((_a = e5.fields) == null ? void 0 : _a.length) > 0;
    }
    _isMosaicRuleSupported(e5) {
      var _a;
      if (!e5)
        return false;
      const t4 = this._isMosaicDataset(e5), r4 = e5.currentVersion >= 10.71 && e5.hasMultidimensions && !(((_a = e5.fields) == null ? void 0 : _a.length) > 1);
      return t4 || r4;
    }
    _isVectorFieldResampleFunction(e5) {
      if (t(e5))
        return false;
      const { functionName: t4, functionArguments: r4 } = e5, i7 = "resample" === (t4 == null ? void 0 : t4.toLowerCase()), s7 = (r4 == null ? void 0 : r4.ResampleType) || (r4 == null ? void 0 : r4.resampleType);
      return i7 && (7 === s7 || 10 === s7);
    }
    _isPicture() {
      return !this.format || this.format.includes("jpg") || this.format.includes("png");
    }
    _configRenderer(e5) {
      var _a, _b;
      if (!this._isPicture() && !this.pixelFilter || this._isVectorDataSet()) {
        if (!this.bandIds && this.rasterInfo && this.rasterInfo.bandCount >= 3) {
          const e6 = L(this.rasterInfo);
          !e6 || 3 === this.rasterInfo.bandCount && 0 === e6[0] && 1 === e6[1] && 2 === e6[2] || (this.bandIds = e6);
        }
        e5 || (e5 = j4(this.rasterInfo, { bandIds: this.bandIds, variableName: this.renderingRule ? null : (_b = (_a = this.mosaicRule) == null ? void 0 : _a.multidimensionalDefinition) == null ? void 0 : _b[0].variableName }));
        const t4 = $(e5.toJSON());
        this.symbolizer ? (this.symbolizer.rendererJSON = t4, this.symbolizer.rasterInfo = this.rasterInfo) : this.symbolizer = new T3({ rendererJSON: t4, rasterInfo: this.rasterInfo }), this.symbolizer.bind().success || (this.symbolizer = null);
      }
      return e5;
    }
    _clonePixelData(e5) {
      return null == e5 ? e5 : { extent: e5.extent && e5.extent.clone(), pixelBlock: r(e5.pixelBlock) ? e5.pixelBlock.clone() : null };
    }
    _getQueryParams(e5) {
      e5 && r(e5.renderingRule) && "string" != typeof e5.renderingRule && (e5.renderingRule = this._getRenderingRuleString(e5.renderingRule));
      const { raster: t4, viewId: r4 } = this;
      return { raster: t4, viewId: r4, f: "json", ...e5, ...this.customParameters };
    }
    _getRequestOptions(e5) {
      return { ...e5, query: { ...e5 == null ? void 0 : e5.query, ...this.customParameters } };
    }
    _decodePixelBlock(e5, t4, r4) {
      return this._rasterJobHandler.instance ? this._rasterJobHandler.instance.decode({ data: e5, options: t4 }) : S(e5, t4, r4);
    }
    async _getRasterFunctionInfos(e5) {
      var _a;
      const t4 = this.sourceJSON.rasterFunctionInfos;
      if (this.loaded)
        return t4;
      if (t4 && this.version >= 10.3) {
        if (1 === t4.length && "none" === t4[0].name.toLowerCase())
          return t4;
        return (_a = (await U(S4(this.parsedUrl) + "/rasterFunctionInfos", { query: this._getQueryParams(), signal: e5 })).data) == null ? void 0 : _a.rasterFunctionInfos;
      }
      return null;
    }
    _canRequestImageElement(e5) {
      return !this.pixelFilter && (!e5 || e5.includes("png"));
    }
    async _requestArrayBuffer(e5) {
      const { imageProps: t4, requestAsImageElement: r4, signal: i7 } = e5;
      if (r4 && this._canRequestImageElement(t4.format)) {
        return { imageOrCanvasElement: (await U(S4(this.parsedUrl) + "/exportImage", { responseType: "image", query: this._getQueryParams({ f: "image", ...this.refreshParameters, ...e5.imageServiceParameters }), signal: i7 })).data, params: t4 };
      }
      const s7 = this._initJobHandler(), a5 = U(S4(this.parsedUrl) + "/exportImage", { responseType: "array-buffer", query: this._getQueryParams({ f: "image", ...e5.imageServiceParameters }), signal: i7 }), l6 = (await Promise.all([a5, s7]))[0].data, u6 = t4.format || "jpgpng";
      let p13 = u6;
      if ("bsq" !== p13 && "bip" !== p13 && (p13 = P(l6)), !p13)
        throw new s2("imagery-layer:fetch-image", "unsupported format signature " + String.fromCharCode.apply(null, new Uint8Array(l6)));
      const c10 = { signal: i7 }, m7 = "gif" === u6 || "bmp" === u6 || u6.includes("png") && ("png" === p13 || "jpg" === p13) ? S(l6, { useCanvas: true, ...t4 }, c10) : this._decodePixelBlock(l6, { width: t4.width, height: t4.height, planes: null, pixelType: null, noDataValue: null, format: u6 }, c10);
      return { pixelData: { pixelBlock: await m7, extent: t4.extent }, params: t4 };
    }
    _generateRasterInfo(e5, t4) {
      const r4 = { ...t4, query: this._getQueryParams() };
      return f5(S4(this.parsedUrl), e5, r4);
    }
    _isValidCustomizedMosaicRule(e5) {
      var _a;
      return e5 && JSON.stringify(e5.toJSON()) !== JSON.stringify((_a = this.defaultMosaicRule) == null ? void 0 : _a.toJSON());
    }
    _updateMultidimensionalDefinition(e5) {
      var _a;
      if (this._isValidCustomizedMosaicRule(this.mosaicRule))
        return;
      const t4 = c5(e5, { multidimensionalSubset: this.multidimensionalSubset });
      if (r(t4) && t4.length > 0) {
        this.mosaicRule = this.mosaicRule || new y5();
        const e6 = this.mosaicRule.multidimensionalDefinition;
        !this.sourceJSON.defaultVariableName && this.renderingRule && "none" !== ((_a = this.renderingRule.functionName) == null ? void 0 : _a.toLowerCase()) && t4.forEach((e7) => e7.variableName = ""), (!e6 || e6 && e6.length <= 0) && (this.mosaicRule.multidimensionalDefinition = t4);
      }
    }
    _processVisibleRastersResponse(e5, r4) {
      var _a;
      r4 = r4 || {};
      const i7 = e5.value, { templateRRFunctionNames: s7, showNoDataRecords: n9, returnDomainValues: o5, templateFields: a5 } = r4, l6 = e5.processedValues;
      let u6 = e5.catalogItems && e5.catalogItems.features, c10 = e5.properties && e5.properties.Values && e5.properties.Values.map((e6) => e6.replace(/ /gi, ", ")) || [];
      const m7 = this.objectIdField || "ObjectId", d7 = "string" == typeof i7 && i7.toLowerCase().includes("nodata"), h6 = [];
      if (i7 && !u6 && !d7) {
        const e6 = {};
        e6[m7] = 0;
        c10 = [i7], u6 = [new g(this.fullExtent, null, e6)];
      }
      if (!u6)
        return [];
      let f9, y11, g5;
      this._updateResponseFieldNames(u6, a5), d7 && !n9 && (u6 = []);
      for (let t4 = 0; t4 < u6.length; t4++) {
        if (f9 = u6[t4], null != i7) {
          if (y11 = c10[t4], g5 = this.renderingRule && l6 && l6.length > 0 && s7 && s7.length > 0 && s7.includes(this.renderingRule.functionName) ? l6[s7.indexOf(this.renderingRule.functionName)] : i7, "nodata" === y11.toLowerCase() && !n9)
            continue;
          const e6 = "Raster.ItemPixelValue", r5 = "Raster.ServicePixelValue";
          f9.attributes[e6] = y11, f9.attributes[r5] = g5, this._updateFeatureWithMagDirValues(f9, y11);
          const o6 = this.fields && this.fields.length > 0;
          let a6 = this.renderingRule && r((_a = this.serviceRasterInfo) == null ? void 0 : _a.attributeTable) ? o6 ? y11 : i7 : g5;
          this.renderingRule || (a6 = o6 ? y11 : i7), this._updateFeatureWithRasterAttributeTableValues(f9, a6);
        }
        if (f9.sourceLayer = f9.layer = this, o5 && this._updateFeatureWithDomainValues(f9), s7 && l6 && s7.length === l6.length)
          for (let e6 = 0; e6 < s7.length; e6++) {
            const t5 = "Raster.ServicePixelValue." + s7[e6];
            f9.attributes[t5] = l6[e6];
          }
        h6.push(u6[t4]);
      }
      return h6;
    }
    _updateFeatureWithRasterAttributeTableValues(e5, t4) {
      var _a;
      const r4 = this.rasterInfo && this.rasterInfo.attributeTable || ((_a = this.serviceRasterInfo) == null ? void 0 : _a.attributeTable);
      if (t(r4))
        return;
      const { features: i7, fields: s7 } = r4, n9 = s7.map((e6) => e6.name).filter((e6) => "value" === e6.toLowerCase()), o5 = n9 && n9[0];
      if (!o5)
        return;
      const a5 = i7.filter((e6) => e6.attributes[o5] === (null != t4 ? parseInt(t4, 10) : null));
      a5 && a5[0] && s7.forEach((t5) => {
        const r5 = this._rasterAttributeTableFieldPrefix + t5.name;
        e5.attributes[r5] = a5[0].attributes[t5.name];
      });
    }
    _updateFeatureWithMagDirValues(e5, t4) {
      if (!this._isVectorDataSet())
        return;
      const r4 = t4.split(/,\s*/).map((e6) => parseFloat(e6)), i7 = r4.map((e6) => [e6]), s7 = r4.map((e6) => ({ minValue: e6, maxValue: e6, noDataValue: null })), n9 = new g2({ height: 1, width: 1, pixelType: "f32", pixels: i7, statistics: s7 });
      null != this.pixelFilter && this.pixelFilter({ pixelBlock: n9, extent: new w3(0, 0, 0, 0, this.spatialReference) });
      const o5 = "esriImageServiceDataTypeVector-MagDir" === this.serviceDataType ? [n9.pixels[0][0], n9.pixels[1][0]] : f4([n9.pixels[0][0], n9.pixels[1][0]]);
      e5.attributes["Raster.Magnitude"] = o5[0], e5.attributes["Raster.Direction"] = o5[1];
    }
    _updateFeatureWithDomainValues(e5) {
      const t4 = this.fields && this.fields.filter((e6) => e6.domain && "coded-value" === e6.domain.type);
      null != t4 && t4.forEach((t5) => {
        const r4 = e5.attributes[t5.name];
        if (null != r4) {
          const i7 = t5.domain.codedValues.find((e6) => e6.code === r4);
          i7 && (e5.attributes[t5.name] = i7.name);
        }
      });
    }
    _updateResponseFieldNames(e5, t4) {
      if (!t4 || t4.length < 1)
        return;
      const r4 = this.fieldsIndex;
      t(r4) || e5.forEach((e6) => {
        var _a;
        if (e6 && e6.attributes)
          for (const i7 of t4) {
            const t5 = (_a = r4.get(i7)) == null ? void 0 : _a.name;
            t5 && t5 !== i7 && (e6.attributes[i7] = e6.attributes[t5], delete e6.attributes[t5]);
          }
      });
    }
    _getRenderingRuleString(e5) {
      var _a;
      if (this._hasRenderingRule(e5)) {
        let t4 = e5.toJSON();
        return t4 = (_a = t4.rasterFunctionDefinition) != null ? _a : t4, (t4.thumbnail || t4.thumbnailEx) && (t4.thumbnail = t4.thumbnailEx = null), JSON.stringify(t4);
      }
      return null;
    }
    _hasRenderingRule(e5) {
      return null != e5 && null != e5.functionName && "none" !== e5.functionName.toLowerCase();
    }
    _updateRenderingRulesFunctionName(e5, t4) {
      if (!e5 || e5.length < 1)
        return;
      if ("Raw" === e5)
        return e5.replace("Raw", "None");
      const r4 = e5.toLowerCase().replace(/ /gi, "_");
      return t4.has(r4) ? t4.get(r4) : e5;
    }
    _isRFTJson(e5) {
      return e5 && e5.name && e5.arguments && e5.function && e5.hasOwnProperty("functionType");
    }
    _isVectorDataSet() {
      return "esriImageServiceDataTypeVector-UV" === this.serviceDataType || "esriImageServiceDataTypeVector-MagDir" === this.serviceDataType;
    }
    _readCapabilities(e5) {
      const t4 = e5.capabilities ? e5.capabilities.toLowerCase().split(",").map((e6) => e6.trim()) : ["image", "catalog"], { currentVersion: r4, advancedQueryCapabilities: i7, maxRecordCount: s7 } = e5, n9 = t4.includes("image"), o5 = "esriImageServiceDataTypeElevation" === e5.serviceDataType, a5 = !!(e5.spatialReference || e5.extent && e5.extent.spatialReference), l6 = t4.includes("edit");
      return { data: { supportsAttachment: false }, operations: { supportsComputeHistograms: n9, supportsExportImage: n9, supportsIdentify: n9, supportsMeasure: t4.includes("mensuration") && a5, supportsDownload: t4.includes("download"), supportsQuery: t4.includes("catalog") && e5.fields && e5.fields.length > 0, supportsGetSamples: r4 >= 10.2 && n9, supportsProject: r4 >= 10.3 && n9, supportsComputeStatisticsHistograms: r4 >= 10.4 && n9, supportsQueryBoundary: r4 >= 10.6 && n9, supportsCalculateVolume: r4 >= 10.7 && o5, supportsComputePixelLocation: r4 >= 10.7 && t4.includes("catalog"), supportsComputeAngles: r4 >= 10.91, supportsAdd: l6, supportsDelete: l6, supportsEditing: l6, supportsUpdate: l6, supportsCalculate: false, supportsTruncate: false, supportsValidateSql: false, supportsChangeTracking: false, supportsQueryAttachments: false, supportsResizeAttachments: false, supportsSync: false, supportsExceedsLimitStatistics: false, supportsQueryAnalytics: false, supportsQueryTopFeatures: false }, query: { maxRecordCount: s7, maxRecordCountFactor: void 0, supportsStatistics: !!(i7 == null ? void 0 : i7.supportsStatistics), supportsOrderBy: !!(i7 == null ? void 0 : i7.supportsOrderBy), supportsDistinct: !!(i7 == null ? void 0 : i7.supportsDistinct), supportsPagination: !!(i7 == null ? void 0 : i7.supportsPagination), supportsStandardizedQueriesOnly: !!(i7 == null ? void 0 : i7.useStandardizedQueries), supportsPercentileStatistics: !!(i7 == null ? void 0 : i7.supportsPercentileStatistics), supportsCentroid: !!(i7 == null ? void 0 : i7.supportsReturningGeometryCentroid), supportsDistance: !!(i7 == null ? void 0 : i7.supportsQueryWithDistance), supportsExtent: !!(i7 == null ? void 0 : i7.supportsReturningQueryExtent), supportsGeometryProperties: !!(i7 == null ? void 0 : i7.supportsReturningGeometryProperties), supportsHavingClause: !!(i7 == null ? void 0 : i7.supportsHavingClause), supportsQuantization: false, supportsQuantizationEditMode: false, supportsQueryGeometry: false, supportsResultType: false, supportsMaxRecordCountFactor: false, supportsSqlExpression: false, supportsTopFeaturesQuery: false, supportsQueryByOthers: false, supportsHistoricMoment: false, supportsFormatPBF: false, supportsDisjointSpatialRelationship: false, supportsCacheHint: false, supportsSpatialAggregationStatistics: false, supportedSpatialAggregationStatistics: { envelope: false, centroid: false, convexHull: false }, supportsDefaultSpatialReference: !!(i7 == null ? void 0 : i7.supportsDefaultSR), supportsFullTextSearch: false, supportsCompactGeometry: false, standardMaxRecordCount: void 0, tileMaxRecordCount: void 0 } };
    }
  };
  function S4(e5) {
    var _a;
    return (_a = e5 == null ? void 0 : e5.path) != null ? _a : "";
  }
  return e2([y2()], y10.prototype, "_functionRasterInfos", void 0), e2([y2()], y10.prototype, "_rasterJobHandler", void 0), e2([y2()], y10.prototype, "_cachedRendererJson", void 0), e2([y2({ readOnly: true })], y10.prototype, "_serviceSupportsMosaicRule", void 0), e2([o("_serviceSupportsMosaicRule", ["currentVersion", "fields"])], y10.prototype, "readServiceSupportsMosaicRule", null), e2([y2()], y10.prototype, "_rasterAttributeTableFieldPrefix", void 0), e2([y2({ readOnly: true })], y10.prototype, "_rasterFunctionNamesIndex", null), e2([y2()], y10.prototype, "adjustAspectRatio", void 0), e2([y2({ type: [T], json: { write: true } })], y10.prototype, "bandIds", void 0), e2([o("bandIds")], y10.prototype, "readBandIds", null), e2([y2({ readOnly: true, json: { read: false } })], y10.prototype, "capabilities", void 0), e2([o("service", "capabilities", ["capabilities", "currentVersion", "serviceDataType"])], y10.prototype, "readCapabilities", null), e2([y2({ type: Number })], y10.prototype, "compressionQuality", void 0), e2([r2("compressionQuality")], y10.prototype, "writeCompressionQuality", null), e2([y2({ type: Number })], y10.prototype, "compressionTolerance", void 0), e2([r2("compressionTolerance")], y10.prototype, "writeCompressionTolerance", null), e2([y2({ json: { read: { source: "copyrightText" } } })], y10.prototype, "copyright", void 0), e2([y2({ readOnly: true, dependsOn: ["_serviceSupportsMosaicRule"] })], y10.prototype, "defaultMosaicRule", void 0), e2([o("defaultMosaicRule", ["defaultMosaicMethod"])], y10.prototype, "readDefaultMosaicRule", null), e2([y2({ type: String, json: { name: "layerDefinition.definitionExpression", write: { enabled: true, allowNull: true } } })], y10.prototype, "definitionExpression", void 0), e2([y2({ readOnly: true, constructOnly: true })], y10.prototype, "exportImageServiceParameters", void 0), e2([y2()], y10.prototype, "rasterInfo", void 0), e2([y2({ readOnly: true, type: [y3] })], y10.prototype, "fields", void 0), e2([y2({ readOnly: true })], y10.prototype, "fieldsIndex", null), e2([y2({ type: ["png", "png8", "png24", "png32", "jpg", "bmp", "gif", "jpgpng", "lerc", "tiff"], json: { write: true } })], y10.prototype, "format", null), e2([o("service", "format", ["serviceDataType"])], y10.prototype, "readFormat", null), e2([y2({ type: w3 })], y10.prototype, "fullExtent", void 0), e2([y2({ readOnly: true })], y10.prototype, "hasMultidimensions", void 0), e2([y2({ json: { read: { source: "maxImageHeight" } } })], y10.prototype, "imageMaxHeight", void 0), e2([y2({ json: { read: { source: "maxImageWidth" } } })], y10.prototype, "imageMaxWidth", void 0), e2([y2({ type: String, json: { type: o4.jsonValues, read: o4.read, write: o4.write } })], y10.prototype, "interpolation", void 0), e2([y2()], y10.prototype, "minScale", void 0), e2([o("service", "minScale")], y10.prototype, "readMinScale", null), e2([y2()], y10.prototype, "maxScale", void 0), e2([o("service", "maxScale")], y10.prototype, "readMaxScale", null), e2([y2({ type: y5 })], y10.prototype, "mosaicRule", null), e2([o("mosaicRule", ["mosaicRule", "defaultMosaicMethod"])], y10.prototype, "readMosaicRule", null), e2([r2("mosaicRule")], y10.prototype, "writeMosaicRule", null), e2([y2()], y10.prototype, "multidimensionalInfo", null), e2([y2({ type: c4, json: { write: true } })], y10.prototype, "multidimensionalSubset", void 0), e2([y2({ json: { type: T } })], y10.prototype, "noData", void 0), e2([r2("noData")], y10.prototype, "writeNoData", null), e2([y2({ type: String, json: { type: i4.jsonValues, read: i4.read, write: i4.write } })], y10.prototype, "noDataInterpretation", void 0), e2([y2({ type: String, readOnly: true, json: { read: { source: ["fields"] } } })], y10.prototype, "objectIdField", void 0), e2([o("objectIdField")], y10.prototype, "readObjectIdField", null), e2([y2({})], y10.prototype, "geometryType", void 0), e2([y2({})], y10.prototype, "typeIdField", void 0), e2([y2({})], y10.prototype, "types", void 0), e2([y2({ readOnly: true })], y10.prototype, "parsedUrl", null), e2([y2({ type: Function })], y10.prototype, "pixelFilter", void 0), e2([y2()], y10.prototype, "raster", void 0), e2([y2({ readOnly: true })], y10.prototype, "sourceType", void 0), e2([o("sourceType", ["serviceSourceType", "fields"])], y10.prototype, "readSourceType", null), e2([y2()], y10.prototype, "viewId", void 0), e2([y2({ types: l3, json: { name: "layerDefinition.drawingInfo.renderer", origins: { "web-scene": { types: i3, name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy: (e5) => ({ enabled: e5 && "vector-field" !== e5.type && "flow" !== e5.type }) } } } } })], y10.prototype, "renderer", null), e2([o("renderer")], y10.prototype, "readRenderer", null), e2([r2("renderer")], y10.prototype, "writeRenderer", null), e2([y2()], y10.prototype, "symbolizer", void 0), e2([y2(w4)], y10.prototype, "opacity", void 0), e2([y2({ readOnly: true })], y10.prototype, "rasterFields", null), e2([y2({ constructOnly: true })], y10.prototype, "rasterFunctionInfos", void 0), e2([y2({ type: w5 })], y10.prototype, "renderingRule", null), e2([o("renderingRule", ["renderingRule", "rasterFunctionInfos"])], y10.prototype, "readRenderingRule", null), e2([r2("renderingRule")], y10.prototype, "writeRenderingRule", null), e2([y2()], y10.prototype, "serviceDataType", void 0), e2([y2({ readOnly: true, type: k })], y10.prototype, "spatialReference", void 0), e2([o("spatialReference", ["spatialReference", "extent"])], y10.prototype, "readSpatialReference", null), e2([y2({ json: { type: Se.jsonValues } })], y10.prototype, "pixelType", void 0), e2([o("pixelType")], y10.prototype, "readPixelType", null), e2([r2("pixelType")], y10.prototype, "writePixelType", null), e2([y2({ constructOnly: true, type: u3 })], y10.prototype, "serviceRasterInfo", void 0), e2([y2()], y10.prototype, "sourceJSON", void 0), e2([y2(f)], y10.prototype, "url", void 0), e2([y2({ readOnly: true })], y10.prototype, "version", void 0), e2([o("version", ["currentVersion", "fields", "timeInfo"])], y10.prototype, "readVersion", null), y10 = e2([n("esri.layers.mixins.ArcGISImageService")], y10), y10;
};

// node_modules/@arcgis/core/layers/ImageryLayer.js
var L2 = class extends n2(a2(t2(c3(v4(xe(p2(o3(p3(O(b)))))))))) {
  constructor(...e5) {
    super(...e5), this.legendEnabled = true, this.isReference = null, this.operationalLayerType = "ArcGISImageServiceLayer", this.popupEnabled = true, this.popupTemplate = null, this.type = "imagery";
  }
  normalizeCtorArgs(e5, r4) {
    return "string" == typeof e5 ? { url: e5, ...r4 } : e5;
  }
  load(e5) {
    const r4 = r(e5) ? e5.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Image Service"] }, e5).catch(w).then(() => this._fetchService(r4))), Promise.resolve(this);
  }
  writeOperationalLayerType(e5, r4, t4) {
    var _a;
    const o5 = "vector-field" === ((_a = this.renderer) == null ? void 0 : _a.type);
    r4[t4] = o5 ? "ArcGISImageServiceVectorLayer" : "ArcGISImageServiceLayer";
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  createPopupTemplate(e5) {
    const r4 = this.rasterFields, t4 = this.title, o5 = /* @__PURE__ */ new Set();
    let i7 = false, s7 = false;
    this.capabilities && (i7 = this.capabilities.operations.supportsQuery && this.fields && this.fields.length > 0, s7 = "esriImageServiceDataTypeVector-UV" === this.serviceDataType || "esriImageServiceDataTypeVector-MagDir" === this.serviceDataType);
    const a4 = /* @__PURE__ */ new Set();
    i7 && a4.add("raster.itempixelvalue");
    for (const p13 of r4) {
      const e6 = p13.name.toLowerCase();
      a4.has(e6) || e6.includes("raster.servicepixelvalue.") || o5.add(p13.name);
    }
    return s7 && o5.add("raster.magnitude").add("raster.direction"), p4({ fields: r4, title: t4 }, { ...e5, visibleFieldNames: o5 });
  }
  queryFeatures(e5, r4) {
    return this.queryRasters(e5, r4).then((e6) => {
      if (e6 == null ? void 0 : e6.features)
        for (const r5 of e6.features)
          r5.layer = r5.sourceLayer = this;
      return e6;
    });
  }
  queryFeatureCount(e5, r4) {
    return this.queryRasterCount(e5, r4);
  }
  redraw() {
    this.emit("redraw");
  }
  serviceSupportsSpatialReference(e5) {
    return e3(this, e5);
  }
};
e2([y2(c2)], L2.prototype, "legendEnabled", void 0), e2([y2({ type: ["show", "hide"] })], L2.prototype, "listMode", void 0), e2([y2({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], L2.prototype, "isReference", void 0), e2([y2({ type: ["ArcGISImageServiceLayer"], json: { origins: { "web-map": { type: ["ArcGISImageServiceLayer", "ArcGISImageServiceVectorLayer"], read: false, write: { target: "layerType", ignoreOrigin: true } } } } })], L2.prototype, "operationalLayerType", void 0), e2([r2("web-map", "operationalLayerType")], L2.prototype, "writeOperationalLayerType", null), e2([y2(p)], L2.prototype, "popupEnabled", void 0), e2([y2({ type: k2, json: { read: { source: "popupInfo" }, write: { target: "popupInfo" } } })], L2.prototype, "popupTemplate", void 0), e2([y2({ readOnly: true })], L2.prototype, "defaultPopupTemplate", null), e2([y2({ readOnly: true, json: { read: false } })], L2.prototype, "type", void 0), L2 = e2([n("esri.layers.ImageryLayer")], L2);
var T5 = L2;
export {
  T5 as default
};
//# sourceMappingURL=ImageryLayer-FDSKRE7K.js.map
