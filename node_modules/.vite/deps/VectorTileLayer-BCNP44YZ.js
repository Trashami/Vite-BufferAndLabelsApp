import {
  l
} from "./chunk-2XVZ2CO6.js";
import "./chunk-L553EHL3.js";
import "./chunk-2GP5D74I.js";
import "./chunk-R24MO4IV.js";
import "./chunk-YQBYWPBD.js";
import "./chunk-QISOH77W.js";
import "./chunk-XO5VJRK4.js";
import "./chunk-4OM3EX6P.js";
import {
  s as s4
} from "./chunk-PY3FVAQV.js";
import {
  n as n3,
  z
} from "./chunk-7F2ZL2BI.js";
import "./chunk-3OFVLRSL.js";
import {
  e as e3
} from "./chunk-PQLPA2XZ.js";
import {
  l as l2
} from "./chunk-GX2FDWTU.js";
import "./chunk-5FHRTN6L.js";
import {
  e as e4
} from "./chunk-TFHLTN6F.js";
import "./chunk-4JNOVZUK.js";
import "./chunk-OJ2HHY2O.js";
import "./chunk-UAJ2SDPQ.js";
import {
  j as j4
} from "./chunk-OOOPZLJE.js";
import "./chunk-U2WD23Z5.js";
import {
  i
} from "./chunk-VGNX3TFX.js";
import {
  o as o3
} from "./chunk-7N45W3EA.js";
import {
  p
} from "./chunk-HAVCYBU2.js";
import {
  v
} from "./chunk-G3HEFWHV.js";
import {
  c
} from "./chunk-FX6IXM55.js";
import {
  O
} from "./chunk-QFFP6A5Q.js";
import "./chunk-J5VTDQTQ.js";
import "./chunk-YGVY4EIZ.js";
import "./chunk-E52E6T7N.js";
import "./chunk-N43PI2UO.js";
import {
  j as j3
} from "./chunk-HUQX7WZO.js";
import "./chunk-BYSA56OH.js";
import "./chunk-US2IWMHE.js";
import "./chunk-ZPYDYUP5.js";
import {
  n as n2
} from "./chunk-TDV3ZXCQ.js";
import {
  t
} from "./chunk-XJCUKRCO.js";
import {
  b
} from "./chunk-SOEQPPQP.js";
import "./chunk-22F6X66Z.js";
import "./chunk-AIDV7EKX.js";
import "./chunk-FZQZIM7U.js";
import "./chunk-YM6PUX7G.js";
import "./chunk-QEYOWTXD.js";
import "./chunk-CZBRZ6SU.js";
import "./chunk-KDO6J2FO.js";
import "./chunk-RT3T2K4S.js";
import "./chunk-WJCI2CGX.js";
import "./chunk-REIQNAQW.js";
import "./chunk-BLJKKR5D.js";
import {
  y as y3
} from "./chunk-X2S4RQJ4.js";
import "./chunk-376OPXM4.js";
import "./chunk-DER356EU.js";
import "./chunk-NRP45AHD.js";
import "./chunk-6M2AHKYV.js";
import "./chunk-SZIJNKCV.js";
import "./chunk-6O43OEU5.js";
import "./chunk-J2K7ZDSV.js";
import "./chunk-2UML3WQZ.js";
import "./chunk-23Y3DIC6.js";
import "./chunk-RAX2HD42.js";
import "./chunk-ZYRIJWLX.js";
import "./chunk-C5H57NTD.js";
import "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import "./chunk-YWAQYJRC.js";
import "./chunk-B356PXLT.js";
import "./chunk-EHPBHJYZ.js";
import "./chunk-3MNMDUQZ.js";
import {
  w2
} from "./chunk-UWG37XSU.js";
import {
  k2 as k
} from "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import {
  r
} from "./chunk-HLM6QCL2.js";
import {
  o as o2
} from "./chunk-RXYULINL.js";
import "./chunk-5NXILPDI.js";
import "./chunk-THVR7IAM.js";
import "./chunk-ZWJJTUFL.js";
import {
  U,
  a as a2
} from "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import {
  Bt,
  C,
  Ct,
  F,
  G,
  H,
  I,
  K,
  Ot,
  ft,
  j as j2
} from "./chunk-KAN4HXCG.js";
import "./chunk-4FEGON7M.js";
import "./chunk-VWYWOOPX.js";
import "./chunk-M5VHU5LK.js";
import "./chunk-7QMMKGW4.js";
import {
  e as e2,
  n2 as n,
  y as y2
} from "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import {
  f,
  j,
  w
} from "./chunk-MJXQTGI2.js";
import {
  s as s3
} from "./chunk-LIZHLHNA.js";
import "./chunk-BTUHYGXO.js";
import {
  s,
  s2
} from "./chunk-UA3YPL2R.js";
import {
  y
} from "./chunk-HVKDYDPP.js";
import {
  a2 as a,
  o
} from "./chunk-6QC7MLLS.js";
import {
  e
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/layers/support/imageUtils.js
var A = null;
function o4(o6) {
  if (A)
    return A;
  const l4 = { lossy: "UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", lossless: "UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==", alpha: "UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==", animation: "UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA" };
  return A = new Promise((A2) => {
    const n7 = new Image();
    n7.onload = () => {
      n7.onload = n7.onerror = null, A2(n7.width > 0 && n7.height > 0);
    }, n7.onerror = () => {
      n7.onload = n7.onerror = null, A2(false);
    }, n7.src = "data:image/webp;base64," + l4[o6];
  }), A;
}

// node_modules/@arcgis/core/layers/support/SpriteSource.js
var h = 1.15;
var n4 = class {
  constructor(t2, e6) {
    this._spriteSource = t2, this._maxTextureSize = e6, this.devicePixelRatio = 1, this._spriteImageFormat = "png", this._isRetina = false, this._spritesData = {}, this.image = null, this.width = null, this.height = null, this.loadStatus = "not-loaded", "url" === t2.type && t2.spriteFormat && (this._spriteImageFormat = t2.spriteFormat), t2.pixelRatio && (this.devicePixelRatio = t2.pixelRatio), this.baseURL = t2.spriteUrl;
  }
  get spriteNames() {
    const t2 = [];
    for (const e6 in this._spritesData)
      t2.push(e6);
    return t2.sort(), t2;
  }
  getSpriteInfo(t2) {
    return this._spritesData ? this._spritesData[t2] : null;
  }
  async load(t2) {
    if (this.baseURL) {
      this.loadStatus = "loading";
      try {
        await this._loadSprites(t2), this.loadStatus = "loaded";
      } catch {
        this.loadStatus = "failed";
      }
    } else
      this.loadStatus = "failed";
  }
  async _loadSprites(t2) {
    this._isRetina = this.devicePixelRatio > h;
    const { width: s6, height: r4, data: a3, json: o6 } = await this._getSpriteData(this._spriteSource, t2), n7 = Object.keys(o6);
    if (!n7 || 0 === n7.length || !a3)
      return this._spritesData = this.image = null, void (this.width = this.height = 0);
    this._spritesData = o6, this.width = s6, this.height = r4;
    const d3 = Math.max(this._maxTextureSize, 4096);
    if (s6 > d3 || r4 > d3) {
      const t3 = `Sprite resource for style ${this.baseURL} is bigger than the maximum allowed of ${d3} pixels}`;
      throw s2.getLogger("esri.layers.support.SpriteSource").error(t3), new s3("SpriteSource", t3);
    }
    let p2;
    for (let e6 = 0; e6 < a3.length; e6 += 4)
      p2 = a3[e6 + 3] / 255, a3[e6] = a3[e6] * p2, a3[e6 + 1] = a3[e6 + 1] * p2, a3[e6 + 2] = a3[e6 + 2] * p2;
    this.image = a3;
  }
  async _getSpriteData(i2, n7) {
    if ("image" === i2.type) {
      let t2, a3;
      if (this.devicePixelRatio < h) {
        if (!i2.spriteSource1x)
          throw new s3("SpriteSource", "no image data provided for low resolution sprites!");
        t2 = i2.spriteSource1x.image, a3 = i2.spriteSource1x.json;
      } else {
        if (!i2.spriteSource2x)
          throw new s3("SpriteSource", "no image data provided for high resolution sprites!");
        t2 = i2.spriteSource2x.image, a3 = i2.spriteSource2x.json;
      }
      return "width" in t2 && "height" in t2 && "data" in t2 && (o(t2.data) || a(t2.data)) ? { width: t2.width, height: t2.height, data: new Uint8Array(t2.data), json: a3 } : { ...d(t2), json: a3 };
    }
    const p2 = j2(this.baseURL), l4 = p2.query ? "?" + I(p2.query) : "", g2 = this._isRetina ? "@2x" : "", u = `${p2.path}${g2}.${this._spriteImageFormat}${l4}`, c2 = `${p2.path}${g2}.json${l4}`, [m2, S2] = await Promise.all([U(c2, n7), U(u, { responseType: "image", ...n7 })]);
    return { ...d(S2.data), json: m2.data };
  }
};
function d(t2) {
  const e6 = document.createElement("canvas"), i2 = e6.getContext("2d");
  e6.width = t2.width, e6.height = t2.height, i2.drawImage(t2, 0, 0, t2.width, t2.height);
  const s6 = i2.getImageData(0, 0, t2.width, t2.height);
  return { width: t2.width, height: t2.height, data: new Uint8Array(s6.data) };
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TilemapIndex.js
var l3 = class {
  constructor(e6) {
    this.url = e6;
  }
  async fetchTileIndex() {
    return this._tileIndexPromise || (this._tileIndexPromise = U(this.url).then((e6) => e6.data.index)), this._tileIndexPromise;
  }
  async dataKey(e6, r4) {
    const l4 = await this.fetchTileIndex();
    return f(r4), this._getIndexedDataKey(l4, e6);
  }
  _getIndexedDataKey(e6, t2) {
    const l4 = [t2];
    if (t2.level < 0 || t2.row < 0 || t2.col < 0 || t2.row >> t2.level > 0 || t2.col >> t2.level > 0)
      return null;
    let i2 = t2;
    for (; 0 !== i2.level; )
      i2 = new e4(i2.level - 1, i2.row >> 1, i2.col >> 1, i2.world), l4.push(i2);
    let o6, s6, n7 = e6, a3 = l4.pop();
    if (1 === n7)
      return a3;
    for (; l4.length; )
      if (o6 = l4.pop(), s6 = (1 & o6.col) + ((1 & o6.row) << 1), n7) {
        if (0 === n7[s6]) {
          a3 = null;
          break;
        }
        if (1 === n7[s6]) {
          a3 = o6;
          break;
        }
        a3 = o6, n7 = n7[s6];
      }
    return a3;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TilemapRequest.js
var r2 = class {
  constructor(e6, t2) {
    this._tilemap = e6, this._tileIndexUrl = t2;
  }
  async fetchTileIndex(t2) {
    return this._tileIndexPromise || (this._tileIndexPromise = U(this._tileIndexUrl, { query: { ...t2 == null ? void 0 : t2.query } }).then((e6) => e6.data.index)), this._tileIndexPromise;
  }
  dataKey(e6, r4) {
    const { level: l4, row: s6, col: o6 } = e6, n7 = new e4(e6);
    return this._tilemap.fetchAvailabilityUpsample(l4, s6, o6, n7, r4).then(() => (n7.world = e6.world, n7)).catch((e7) => {
      if (j(e7))
        throw e7;
      return null;
    });
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/style/VectorTilesRequestManager.js
var r3 = /* @__PURE__ */ new Map();
function n5(e6, t2, r4, n7, c2) {
  return o5(e6.replace(/\{z\}/gi, t2.toString()).replace(/\{y\}/gi, r4.toString()).replace(/\{x\}/gi, n7.toString()), c2);
}
function o5(n7, o6) {
  const c2 = r3.get(n7);
  if (c2)
    return c2.then((e6) => y(e6));
  const i2 = U(n7, { responseType: "array-buffer", ...o6 }).then(({ data: e6 }) => (r3.delete(n7), e6)).catch((e6) => {
    throw r3.delete(n7), e6;
  });
  return r3.set(n7, i2), i2;
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/style/VectorTileSource.js
var h2 = class {
  constructor(u, h4, m2) {
    this.tilemap = null, this.tileInfo = null, this.capabilities = null, this.fullExtent = null, this.name = u, this.sourceUrl = h4;
    const f2 = j2(this.sourceUrl), c2 = y(m2), x2 = c2.tiles;
    if (f2)
      for (let t2 = 0; t2 < x2.length; t2++) {
        const s6 = j2(x2[t2]);
        s6 && (K(s6.path) || (s6.path = G(f2.path, s6.path)), x2[t2] = Bt(s6.path, { ...f2.query, ...s6.query }));
      }
    this.tileServers = x2;
    const d3 = m2.capabilities && m2.capabilities.split(",").map((t2) => t2.toLowerCase().trim()), y5 = true === (m2 == null ? void 0 : m2.exportTilesAllowed), T = true === (d3 == null ? void 0 : d3.includes("tilemap")), g2 = y5 && m2.hasOwnProperty("maxExportTilesCount") ? m2.maxExportTilesCount : 0;
    this.capabilities = { operations: { supportsExportTiles: y5, supportsTileMap: T }, exportTiles: y5 ? { maxExportTilesCount: +g2 } : null }, this.tileInfo = n3(c2.tileInfo, c2, null, { ignoreMinMaxLOD: true });
    const M = m2.tileMap ? Bt(G(f2.path, m2.tileMap), f2.query) : null;
    T ? (this.type = "vector-tile", this.tilemap = new r2(new z({ layer: { parsedUrl: f2, tileInfo: this.tileInfo, type: "vector-tile", tileServers: this.tileServers } }), M)) : M && (this.tilemap = new l3(M)), this.fullExtent = w2.fromJSON(m2.fullExtent);
  }
  destroy() {
  }
  async getRefKey(t2, e6) {
    var _a, _b;
    return (_b = (_a = this.tilemap) == null ? void 0 : _a.dataKey(t2, e6)) != null ? _b : t2;
  }
  requestTile(t2, e6, i2, r4) {
    const l4 = this.tileServers[e6 % this.tileServers.length];
    return n5(l4, t2, e6, i2, r4);
  }
  isCompatibleWith(t2) {
    const e6 = this.tileInfo, i2 = t2.tileInfo;
    if (!e6.spatialReference.equals(i2.spatialReference))
      return false;
    if (!e6.origin.equals(i2.origin))
      return false;
    if (Math.round(e6.dpi) !== Math.round(i2.dpi))
      return false;
    const r4 = e6.lods, l4 = i2.lods, s6 = Math.min(r4.length, l4.length);
    for (let o6 = 0; o6 < s6; o6++) {
      const t3 = r4[o6], e7 = l4[o6];
      if (t3.level !== e7.level || Math.round(t3.scale) !== Math.round(e7.scale))
        return false;
    }
    return true;
  }
};

// node_modules/@arcgis/core/layers/support/vectorTileLayerLoader.js
var y4 = s.defaults && s.defaults.io.corsEnabledServers;
async function m(e6, r4) {
  const t2 = { source: null, sourceBase: null, sourceUrl: null, validatedSource: null, style: null, styleBase: null, styleUrl: null, sourceNameToSource: {}, primarySourceName: "", spriteFormat: "png" }, [s6, o6] = "string" == typeof e6 ? [e6, null] : [null, e6.jsonUrl];
  await S(t2, "esri", e6, o6, r4);
  const l4 = { layerDefinition: t2.validatedSource, url: s6, serviceUrl: t2.sourceUrl, style: t2.style, styleUrl: t2.styleUrl, spriteUrl: t2.style.sprite && h3(t2.styleBase, t2.style.sprite), spriteFormat: t2.spriteFormat, glyphsUrl: t2.style.glyphs && h3(t2.styleBase, t2.style.glyphs), sourceNameToSource: t2.sourceNameToSource, primarySourceName: t2.primarySourceName };
  return d2(l4.spriteUrl), d2(l4.glyphsUrl), l4;
}
function d2(e6) {
  if (!e6)
    return;
  const r4 = H(e6);
  y4 && !y4.includes(r4) && y4.push(r4);
}
function h3(...e6) {
  let r4;
  for (let t2 = 0; t2 < e6.length; ++t2)
    if (ft(e6[t2])) {
      if (r4) {
        const s6 = r4.split("://")[0];
        r4 = s6 + ":" + e6[t2].trim();
      }
    } else
      r4 = K(e6[t2]) ? e6[t2] : G(r4, e6[t2]);
  return Ct(r4);
}
async function S(e6, s6, o6, l4, n7) {
  let i2, c2, a3;
  if (f(n7), "string" == typeof o6) {
    const e7 = F(o6);
    d2(e7), a3 = await U(e7, { ...n7, responseType: "json", query: { f: "json", ...n7 == null ? void 0 : n7.query } }), a3.ssl && (i2 && (i2 = i2.replace(/^http:/i, "https:")), c2 && (c2 = c2.replace(/^http:/i, "https:"))), i2 = e7, c2 = e7;
  } else
    a3 = { data: o6 }, i2 = o6.jsonUrl || null, c2 = l4;
  const f2 = a3.data;
  if (U2(f2))
    return e6.styleUrl = i2 || null, x(e6, f2, c2, n7);
  if (w3(f2))
    return e6.sourceUrl ? g(e6, f2, c2, false, s6, n7) : (e6.sourceUrl = i2 || null, g(e6, f2, c2, true, s6, n7));
  throw new Error("You must specify the URL or the JSON for a service or for a style.");
}
function U2(e6) {
  return !!e6.sources;
}
function w3(e6) {
  return !U2(e6);
}
async function x(e6, r4, t2, s6) {
  const o6 = t2 ? Ot(t2) : C();
  e6.styleBase = o6, e6.style = r4, e6.styleUrl && d2(e6.styleUrl), r4["sprite-format"] && "webp" === r4["sprite-format"].toLowerCase() && (e6.spriteFormat = "webp");
  const l4 = [];
  if (r4.sources && r4.sources.esri) {
    const t3 = r4.sources.esri;
    t3.url ? await S(e6, "esri", h3(o6, t3.url), void 0, s6) : l4.push(S(e6, "esri", t3, o6, s6));
  }
  for (const n7 of Object.keys(r4.sources))
    "esri" !== n7 && "vector" === r4.sources[n7].type && (r4.sources[n7].url ? l4.push(S(e6, n7, h3(o6, r4.sources[n7].url), void 0, s6)) : r4.sources[n7].tiles && l4.push(S(e6, n7, r4.sources[n7], o6, s6)));
  await Promise.all(l4);
}
async function g(e6, r4, t2, s6, o6, l4) {
  const n7 = t2 ? Ct(t2) + "/" : C(), u = v2(r4, n7), c2 = new h2(o6, Bt(n7, l4 == null ? void 0 : l4.query), u);
  if (!s6 && e6.primarySourceName in e6.sourceNameToSource) {
    const r5 = e6.sourceNameToSource[e6.primarySourceName];
    if (!r5.isCompatibleWith(c2))
      return;
    null != c2.fullExtent && (null != r5.fullExtent ? r5.fullExtent.union(c2.fullExtent) : r5.fullExtent = c2.fullExtent.clone()), r5.tileInfo.lods.length < c2.tileInfo.lods.length && (r5.tileInfo = c2.tileInfo);
  }
  if (s6 ? (e6.sourceBase = n7, e6.source = r4, e6.validatedSource = u, e6.primarySourceName = o6, e6.sourceUrl && d2(e6.sourceUrl)) : d2(n7), e6.sourceNameToSource[o6] = c2, !e6.style) {
    if (null == r4.defaultStyles)
      throw new Error();
    return "string" == typeof r4.defaultStyles ? S(e6, "", h3(n7, r4.defaultStyles, "root.json"), void 0, l4) : S(e6, "", r4.defaultStyles, h3(n7, "root.json"), l4);
  }
}
function v2(e6, r4) {
  if (e6.hasOwnProperty("tileInfo"))
    return e6;
  const t2 = { xmin: -20037507067161843e-9, ymin: -20037507067161843e-9, xmax: 20037507067161843e-9, ymax: 20037507067161843e-9, spatialReference: { wkid: 102100 } }, s6 = 512;
  let o6 = 78271.51696400007, l4 = 2958287637957775e-7;
  const n7 = [], i2 = e6.hasOwnProperty("minzoom") ? +e6.minzoom : 0, u = e6.hasOwnProperty("maxzoom") ? +e6.maxzoom : 22;
  for (let c2 = 0; c2 <= u; c2++)
    c2 >= i2 && n7.push({ level: c2, scale: l4, resolution: o6 }), o6 /= 2, l4 /= 2;
  for (const c2 of e6.tiles)
    d2(h3(r4, c2));
  return { capabilities: "TilesOnly", initialExtent: t2, fullExtent: t2, minScale: 0, maxScale: 0, tiles: e6.tiles, tileInfo: { rows: s6, cols: s6, dpi: 96, format: "pbf", origin: { x: -20037508342787e-6, y: 20037508342787e-6 }, lods: n7, spatialReference: { wkid: 102100 } } };
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/tileInfoUtils.js
var e5 = 1e-6;
function n6(l4, n7) {
  if (l4 === n7)
    return true;
  if (null == l4 && null != n7)
    return false;
  if (null != l4 && null == n7)
    return false;
  if (null == l4 || null == n7)
    return false;
  if (!l4.spatialReference.equals(n7.spatialReference) || l4.dpi !== n7.dpi)
    return false;
  const s6 = l4.origin, r4 = n7.origin;
  if (Math.abs(s6.x - r4.x) >= e5 || Math.abs(s6.y - r4.y) >= e5)
    return false;
  let o6, t2;
  l4.lods[0].scale > n7.lods[0].scale ? (o6 = l4, t2 = n7) : (t2 = l4, o6 = n7);
  for (let i2 = o6.lods[0].scale; i2 >= t2.lods[t2.lods.length - 1].scale - e5; i2 /= 2)
    if (Math.abs(i2 - t2.lods[0].scale) < e5)
      return true;
  return false;
}
function s5(e6, n7) {
  if (e6 === n7)
    return e6;
  if (null == e6 && null != n7)
    return n7;
  if (null != e6 && null == n7)
    return e6;
  if (null == e6 || null == n7)
    return null;
  const s6 = e6.size[0], r4 = e6.format, o6 = e6.dpi, t2 = { x: e6.origin.x, y: e6.origin.y }, i2 = e6.spatialReference.toJSON(), u = e6.lods[0].scale > n7.lods[0].scale ? e6.lods[0] : n7.lods[0], a3 = e6.lods[e6.lods.length - 1].scale <= n7.lods[n7.lods.length - 1].scale ? e6.lods[e6.lods.length - 1] : n7.lods[n7.lods.length - 1], f2 = u.scale, d3 = u.resolution, c2 = a3.scale, p2 = [];
  let g2 = f2, h4 = d3, x2 = 0;
  for (; g2 > c2; )
    p2.push({ level: x2, resolution: h4, scale: g2 }), x2++, g2 /= 2, h4 /= 2;
  return new j4({ size: [s6, s6], dpi: o6, format: r4 || "pbf", origin: t2, lods: p2, spatialReference: i2 });
}

// node_modules/@arcgis/core/layers/VectorTileLayer.js
var B = class extends n2(t(s4(p(c(v(o3(i(O(b))))))))) {
  constructor(...e6) {
    super(...e6), this._spriteSourceMap = /* @__PURE__ */ new Map(), this.currentStyleInfo = null, this.style = null, this.isReference = null, this.operationalLayerType = "VectorTileLayer", this.type = "vector-tile", this.url = null, this.showCollisionBoxes = "none", this.path = null;
  }
  normalizeCtorArgs(e6, t2) {
    return "string" == typeof e6 ? { url: e6, ...t2 } : e6;
  }
  destroy() {
    if (this.sourceNameToSource)
      for (const e6 of Object.values(this.sourceNameToSource))
        e6 == null ? void 0 : e6.destroy();
    this._spriteSourceMap.clear();
  }
  async prefetchResources(e6) {
    await this.loadSpriteSource(globalThis.devicePixelRatio || 1, e6);
  }
  load(e6) {
    const r4 = this.loadFromPortal({ supportedTypes: ["Vector Tile Service"], supportsData: false }, e6).catch(w).then(async () => {
      if (!this.portalItem || !this.portalItem.id)
        return;
      const r5 = `${this.portalItem.itemUrl}/resources/styles/root.json`;
      (await U(r5, { ...e6, query: { f: "json", ...this.customParameters, token: this.apiKey } })).data && this.read({ url: r5 }, e3(this.portalItem));
    }).catch(w).then(() => this._loadStyle(e6));
    return this.addResolvingPromise(r4), Promise.resolve(this);
  }
  get attributionDataUrl() {
    const e6 = this.currentStyleInfo, t2 = e6 && e6.serviceUrl && j2(e6.serviceUrl);
    if (!t2)
      return null;
    const r4 = this._getDefaultAttribution(t2.path);
    return r4 ? Bt(r4, { ...this.customParameters, token: this.apiKey }) : null;
  }
  get capabilities() {
    const e6 = this.primarySource;
    return e6 ? e6.capabilities : { operations: { supportsExportTiles: false, supportsTileMap: false }, exportTiles: null };
  }
  get fullExtent() {
    var _a;
    return ((_a = this.primarySource) == null ? void 0 : _a.fullExtent) || null;
  }
  get parsedUrl() {
    return this.serviceUrl ? j2(this.serviceUrl) : null;
  }
  get serviceUrl() {
    return this.currentStyleInfo && this.currentStyleInfo.serviceUrl || null;
  }
  get spatialReference() {
    return this.tileInfo && this.tileInfo.spatialReference || null;
  }
  get styleUrl() {
    return this.currentStyleInfo && this.currentStyleInfo.styleUrl || null;
  }
  writeStyleUrl(e6, t2) {
    e6 && ft(e6) && (e6 = `https:${e6}`);
    const r4 = e(a2(e6));
    t2.styleUrl = y3(e6, r4);
  }
  get tileInfo() {
    var _a;
    const e6 = [];
    for (const r4 in this.sourceNameToSource)
      e6.push(this.sourceNameToSource[r4]);
    let t2 = ((_a = this.primarySource) == null ? void 0 : _a.tileInfo) || new j4();
    if (e6.length > 1)
      for (let r4 = 0; r4 < e6.length; r4++)
        n6(t2, e6[r4].tileInfo) && (t2 = s5(t2, e6[r4].tileInfo));
    return t2;
  }
  readVersion(e6, t2) {
    return t2.version ? parseFloat(t2.version) : parseFloat(t2.currentVersion);
  }
  async loadSpriteSource(e6 = 1, t2) {
    var _a, _b;
    if (!this._spriteSourceMap.has(e6)) {
      const r4 = l2("2d").maxTextureSize, o6 = ((_a = this.currentStyleInfo) == null ? void 0 : _a.spriteUrl) ? Bt(this.currentStyleInfo.spriteUrl, { ...this.customParameters, token: this.apiKey }) : null, s6 = new n4({ type: "url", spriteUrl: o6, pixelRatio: e6, spriteFormat: (_b = this.currentStyleInfo) == null ? void 0 : _b.spriteFormat }, r4);
      await s6.load(t2), this._spriteSourceMap.set(e6, s6);
    }
    return this._spriteSourceMap.get(e6);
  }
  async setSpriteSource(e6, t2) {
    if (!e6)
      return null;
    const r4 = l2("2d").maxTextureSize, o6 = e6.spriteUrl, s6 = o6 ? Bt(o6, { ...this.customParameters, token: this.apiKey }) : null;
    if (!s6 && "url" === e6.type)
      return null;
    const i2 = new n4(e6, r4);
    try {
      await i2.load(t2);
      const r5 = e6.pixelRatio || 1;
      return this._spriteSourceMap.clear(), this._spriteSourceMap.set(r5, i2), s6 && this.currentStyleInfo && (this.currentStyleInfo.spriteUrl = s6), this.emit("spriteSource-change", { spriteSource: i2 }), i2;
    } catch (l4) {
      w(l4);
    }
    return null;
  }
  async loadStyle(e6, t2) {
    var _a;
    const o6 = e6 || this.style || this.url;
    return this._loadingTask && "string" == typeof o6 && this.url === o6 || ((_a = this._loadingTask) == null ? void 0 : _a.abort(), this._loadingTask = j3((e7) => (this._spriteSourceMap.clear(), this._getSourceAndStyle(o6, { signal: e7 })), t2)), this._loadingTask.promise;
  }
  getStyleLayerId(e6) {
    return this.styleRepository.getStyleLayerId(e6);
  }
  getStyleLayerIndex(e6) {
    return this.styleRepository.getStyleLayerIndex(e6);
  }
  getPaintProperties(e6) {
    return y(this.styleRepository.getPaintProperties(e6));
  }
  setPaintProperties(e6, t2) {
    const r4 = this.styleRepository.isPainterDataDriven(e6);
    this.styleRepository.setPaintProperties(e6, t2);
    const o6 = this.styleRepository.isPainterDataDriven(e6);
    this.emit("paint-change", { layer: e6, paint: t2, isDataDriven: r4 || o6 });
  }
  getStyleLayer(e6) {
    return y(this.styleRepository.getStyleLayer(e6));
  }
  setStyleLayer(e6, t2) {
    this.styleRepository.setStyleLayer(e6, t2), this.emit("style-layer-change", { layer: e6, index: t2 });
  }
  deleteStyleLayer(e6) {
    this.styleRepository.deleteStyleLayer(e6), this.emit("delete-style-layer", { layer: e6 });
  }
  getLayoutProperties(e6) {
    return y(this.styleRepository.getLayoutProperties(e6));
  }
  setLayoutProperties(e6, t2) {
    this.styleRepository.setLayoutProperties(e6, t2), this.emit("layout-change", { layer: e6, layout: t2 });
  }
  setStyleLayerVisibility(e6, t2) {
    this.styleRepository.setStyleLayerVisibility(e6, t2), this.emit("style-layer-visibility-change", { layer: e6, visibility: t2 });
  }
  getStyleLayerVisibility(e6) {
    return this.styleRepository.getStyleLayerVisibility(e6);
  }
  write(e6, t2) {
    return (t2 == null ? void 0 : t2.origin) && !this.styleUrl ? (t2.messages && t2.messages.push(new s3("vectortilelayer:unsupported", `VectorTileLayer (${this.title}, ${this.id}) with style defined by JSON only are not supported`, { layer: this })), null) : super.write(e6, t2);
  }
  getTileUrl(e6, t2, r4) {
    return null;
  }
  async _getSourceAndStyle(e6, t2) {
    if (!e6)
      throw new Error("invalid style!");
    const r4 = await m(e6, { ...t2, query: { ...this.customParameters, token: this.apiKey } });
    if ("webp" === r4.spriteFormat) {
      await o4("lossy") || (r4.spriteFormat = "png");
    }
    this._set("currentStyleInfo", { ...r4 }), "string" == typeof e6 ? (this.url = e6, this.style = null) : (this.url = null, this.style = e6), this._set("sourceNameToSource", r4.sourceNameToSource), this._set("primarySource", r4.sourceNameToSource[r4.primarySourceName]), this._set("styleRepository", new l(r4.style)), this.read(r4.layerDefinition, { origin: "service" }), this.emit("load-style");
  }
  _getDefaultAttribution(e6) {
    const t2 = e6.match(/^https?:\/\/(?:basemaps|basemapsbeta|basemapsdev)(?:-api)?\.arcgis\.com(\/[^\/]+)?\/arcgis\/rest\/services\/([^\/]+(\/[^\/]+)*)\/vectortileserver/i), r4 = ["OpenStreetMap_v2", "OpenStreetMap_Daylight_v2", "OpenStreetMap_Export_v2", "OpenStreetMap_FTS_v2", "OpenStreetMap_GCS_v2", "World_Basemap", "World_Basemap_v2", "World_Basemap_Export_v2", "World_Basemap_GCS_v2", "World_Basemap_WGS84", "World_Contours_v2"];
    if (!t2)
      return;
    const o6 = t2[2] && t2[2].toLowerCase();
    if (!o6)
      return;
    const s6 = t2[1] || "";
    for (const i2 of r4)
      if (i2.toLowerCase().includes(o6))
        return F(`//static.arcgis.com/attribution/Vector${s6}/${i2}`);
  }
  async _loadStyle(e6) {
    var _a, _b;
    return (_b = (_a = this._loadingTask) == null ? void 0 : _a.promise) != null ? _b : this.loadStyle(null, e6);
  }
};
e2([y2({ readOnly: true })], B.prototype, "attributionDataUrl", null), e2([y2({ type: ["show", "hide"] })], B.prototype, "listMode", void 0), e2([y2({ json: { read: true, write: true } })], B.prototype, "blendMode", void 0), e2([y2({ readOnly: true, json: { read: false } })], B.prototype, "capabilities", null), e2([y2({ readOnly: true })], B.prototype, "currentStyleInfo", void 0), e2([y2({ json: { read: false }, readOnly: true, type: w2 })], B.prototype, "fullExtent", null), e2([y2()], B.prototype, "style", void 0), e2([y2({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], B.prototype, "isReference", void 0), e2([y2({ type: ["VectorTileLayer"] })], B.prototype, "operationalLayerType", void 0), e2([y2({ readOnly: true })], B.prototype, "parsedUrl", null), e2([y2({ readOnly: true })], B.prototype, "serviceUrl", null), e2([y2({ type: k, readOnly: true })], B.prototype, "spatialReference", null), e2([y2({ readOnly: true })], B.prototype, "styleRepository", void 0), e2([y2({ readOnly: true })], B.prototype, "sourceNameToSource", void 0), e2([y2({ readOnly: true })], B.prototype, "primarySource", void 0), e2([y2({ type: String, readOnly: true, json: { write: { ignoreOrigin: true }, origins: { "web-document": { write: { ignoreOrigin: true, isRequired: true } } } } })], B.prototype, "styleUrl", null), e2([r(["portal-item", "web-document"], "styleUrl")], B.prototype, "writeStyleUrl", null), e2([y2({ json: { read: false, origins: { service: { read: false } } }, readOnly: true, type: j4 })], B.prototype, "tileInfo", null), e2([y2({ json: { read: false }, readOnly: true, value: "vector-tile" })], B.prototype, "type", void 0), e2([y2({ json: { origins: { "web-document": { read: { source: "styleUrl" } }, "portal-item": { read: { source: "url" } } }, write: false, read: false } })], B.prototype, "url", void 0), e2([y2({ readOnly: true })], B.prototype, "version", void 0), e2([o2("version", ["version", "currentVersion"])], B.prototype, "readVersion", null), e2([y2({ type: String })], B.prototype, "showCollisionBoxes", void 0), e2([y2({ type: String, json: { origins: { "web-scene": { read: true, write: true } }, read: false } })], B.prototype, "path", void 0), B = e2([n("esri.layers.VectorTileLayer")], B);
var E = B;
export {
  E as default
};
//# sourceMappingURL=VectorTileLayer-BCNP44YZ.js.map
