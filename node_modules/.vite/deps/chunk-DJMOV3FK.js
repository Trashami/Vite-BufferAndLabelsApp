import {
  o as o2
} from "./chunk-WWLBKNPY.js";
import {
  T
} from "./chunk-ZNZ4EIIF.js";
import {
  O
} from "./chunk-RUM3DXFX.js";
import {
  n as n3
} from "./chunk-XP6I2GEX.js";
import {
  l,
  m
} from "./chunk-C5H57NTD.js";
import {
  H,
  P,
  _,
  e,
  o,
  r,
  u,
  x,
  z
} from "./chunk-3LR5O4WA.js";
import {
  n
} from "./chunk-D4V6J5BT.js";
import {
  n as n2,
  p,
  t
} from "./chunk-6QC7MLLS.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/edgeRendering/bufferLayouts.js
var A = T().vec3f(O.POSITION).u16(O.COMPONENTINDEX).u16(O.U16PADDING);
var e2 = T().vec2u8(O.SIDENESS);
var T2 = o2(e2);
var E = T().vec3f(O.POSITION0).vec3f(O.POSITION1).u16(O.COMPONENTINDEX).u8(O.VARIANTOFFSET, { glNormalized: true }).u8(O.VARIANTSTROKE).u8(O.VARIANTEXTENSION, { glNormalized: true }).u8(O.U8PADDING, { glPadding: true }).u16(O.U16PADDING, { glPadding: true });
var S = E.clone().vec3f(O.NORMAL);
var r2 = E.clone().vec3f(O.NORMALA).vec3f(O.NORMALB);
var o3 = /* @__PURE__ */ new Map([[O.POSITION0, 0], [O.POSITION1, 1], [O.COMPONENTINDEX, 2], [O.VARIANTOFFSET, 3], [O.VARIANTSTROKE, 4], [O.VARIANTEXTENSION, 5], [O.NORMAL, 6], [O.NORMALA, 6], [O.NORMALB, 7], [O.SIDENESS, 8]]);

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/edgeRendering/edgePreprocessing.js
var p2 = -1;
var u2;
function h(n4, i, l3, f3 = N) {
  const g3 = n4.vertices.position, m4 = n4.vertices.componentIndex, u5 = m(f3.anglePlanar), h3 = m(f3.angleSignificantEdge), V2 = Math.cos(h3), S2 = Math.cos(u5), j = I.edge, x2 = j.position0, E2 = j.position1, D = j.faceNormal0, F = j.faceNormal1, L = y(n4), U = w(n4), b = U.length / 4, k = i.allocate(b);
  let C = 0;
  const H2 = b, K = l3.allocate(H2);
  let M = 0, O2 = 0, P2 = 0;
  const T3 = p(0, b), q = new Float32Array(b);
  n2(q, (e3, t3, n5) => {
    g3.getVec(U[4 * t3 + 0], x2), g3.getVec(U[4 * t3 + 1], E2), n5[t3] = x(x2, E2);
  }), T3.sort((e3, t3) => q[t3] - q[e3]);
  const z2 = new Array(), B = new Array();
  for (let e3 = 0; e3 < b; e3++) {
    const t3 = T3[e3], n5 = q[t3], o4 = U[4 * t3 + 0], r3 = U[4 * t3 + 1], f4 = U[4 * t3 + 2], h4 = U[4 * t3 + 3], w3 = h4 === p2;
    if (g3.getVec(o4, x2), g3.getVec(r3, E2), w3)
      o(D, L[3 * f4 + 0], L[3 * f4 + 1], L[3 * f4 + 2]), r(F, D), j.componentIndex = m4.get(o4), j.cosAngle = P(D, F);
    else {
      if (o(D, L[3 * f4 + 0], L[3 * f4 + 1], L[3 * f4 + 2]), o(F, L[3 * h4 + 0], L[3 * h4 + 1], L[3 * h4 + 2]), j.componentIndex = m4.get(o4), j.cosAngle = P(D, F), A2(j, S2))
        continue;
      j.cosAngle < -0.9999 && r(F, D);
    }
    O2 += n5, P2++, w3 || v(j, V2) ? (i.write(k, C++, j), z2.push(n5)) : d(j, u5) && (l3.write(K, M++, j), B.push(n5));
  }
  const G = new Float32Array(z2.reverse()), J = new Float32Array(B.reverse());
  return { regular: { instancesData: i.trim(k, C), lodInfo: { lengths: G } }, silhouette: { instancesData: l3.trim(K, M), lodInfo: { lengths: J } }, averageEdgeLength: O2 / P2 };
}
function v(e3, t3) {
  return e3.cosAngle < t3;
}
function A2(e3, t3) {
  return e3.cosAngle > t3;
}
function d(e3, t3) {
  const o4 = l(e3.cosAngle), r3 = I.fwd, s = I.ortho;
  H(r3, e3.position1, e3.position0);
  return o4 * (P(_(s, e3.faceNormal0, e3.faceNormal1), r3) > 0 ? -1 : 1) > t3;
}
function w(e3) {
  const t3 = e3.faces.length / 3, n4 = e3.faces, o4 = e3.neighbors;
  let r3 = 0;
  for (let a3 = 0; a3 < t3; a3++) {
    const e4 = o4[3 * a3 + 0], t4 = o4[3 * a3 + 1], s2 = o4[3 * a3 + 2], c3 = n4[3 * a3 + 0], i = n4[3 * a3 + 1], l3 = n4[3 * a3 + 2];
    r3 += e4 === p2 || c3 < i ? 1 : 0, r3 += t4 === p2 || i < l3 ? 1 : 0, r3 += s2 === p2 || l3 < c3 ? 1 : 0;
  }
  const s = new Int32Array(4 * r3);
  let c2 = 0;
  for (let a3 = 0; a3 < t3; a3++) {
    const e4 = o4[3 * a3 + 0], t4 = o4[3 * a3 + 1], r4 = o4[3 * a3 + 2], i = n4[3 * a3 + 0], l3 = n4[3 * a3 + 1], f3 = n4[3 * a3 + 2];
    (e4 === p2 || i < l3) && (s[c2++] = i, s[c2++] = l3, s[c2++] = a3, s[c2++] = e4), (t4 === p2 || l3 < f3) && (s[c2++] = l3, s[c2++] = f3, s[c2++] = a3, s[c2++] = t4), (r4 === p2 || f3 < i) && (s[c2++] = f3, s[c2++] = i, s[c2++] = a3, s[c2++] = r4);
  }
  return s;
}
function y(e3) {
  const t3 = e3.faces.length / 3, n4 = e3.vertices.position, o4 = e3.faces, r3 = V.v0, s = V.v1, c2 = V.v2, a3 = new Float32Array(3 * t3);
  for (let i = 0; i < t3; i++) {
    const e4 = o4[3 * i + 0], t4 = o4[3 * i + 1], m4 = o4[3 * i + 2];
    n4.getVec(e4, r3), n4.getVec(t4, s), n4.getVec(m4, c2), e(s, s, r3), e(c2, c2, r3), _(r3, s, c2), z(r3, r3), a3[3 * i + 0] = r3[0], a3[3 * i + 1] = r3[1], a3[3 * i + 2] = r3[2];
  }
  return a3;
}
!function(e3) {
  e3[e3.SOLID = 0] = "SOLID", e3[e3.SKETCH = 1] = "SKETCH";
}(u2 || (u2 = {}));
var I = { edge: { position0: n(), position1: n(), faceNormal0: n(), faceNormal1: n(), componentIndex: 0, cosAngle: 0 }, ortho: n(), fwd: n() };
var V = { v0: n(), v1: n(), v2: n() };
var N = { anglePlanar: 4, angleSignificantEdge: 35 };

// node_modules/@arcgis/core/views/3d/support/meshProcessing.js
function t2(t3, o4, n4) {
  const r3 = o4 / 3, c2 = new Uint32Array(n4 + 1), e3 = new Uint32Array(n4 + 1), s = (t4, o5) => {
    t4 < o5 ? c2[t4 + 1]++ : e3[o5 + 1]++;
  };
  for (let x2 = 0; x2 < r3; x2++) {
    const o5 = t3[3 * x2], n5 = t3[3 * x2 + 1], r4 = t3[3 * x2 + 2];
    s(o5, n5), s(n5, r4), s(r4, o5);
  }
  let f3 = 0, l3 = 0;
  for (let x2 = 0; x2 < n4; x2++) {
    const t4 = c2[x2 + 1], o5 = e3[x2 + 1];
    c2[x2 + 1] = f3, e3[x2 + 1] = l3, f3 += t4, l3 += o5;
  }
  const i = new Uint32Array(6 * r3), a3 = c2[n4], w3 = (t4, o5, n5) => {
    if (t4 < o5) {
      const r4 = c2[t4 + 1]++;
      i[2 * r4] = o5, i[2 * r4 + 1] = n5;
    } else {
      const r4 = e3[o5 + 1]++;
      i[2 * a3 + 2 * r4] = t4, i[2 * a3 + 2 * r4 + 1] = n5;
    }
  };
  for (let x2 = 0; x2 < r3; x2++) {
    const o5 = t3[3 * x2], n5 = t3[3 * x2 + 1], r4 = t3[3 * x2 + 2];
    w3(o5, n5, x2), w3(n5, r4, x2), w3(r4, o5, x2);
  }
  const y3 = (t4, o5) => {
    const n5 = 2 * t4, r4 = o5 - t4;
    for (let c3 = 1; c3 < r4; c3++) {
      const t5 = i[n5 + 2 * c3], o6 = i[n5 + 2 * c3 + 1];
      let r5 = c3 - 1;
      for (; r5 >= 0 && i[n5 + 2 * r5] > t5; r5--)
        i[n5 + 2 * r5 + 2] = i[n5 + 2 * r5], i[n5 + 2 * r5 + 3] = i[n5 + 2 * r5 + 1];
      i[n5 + 2 * r5 + 2] = t5, i[n5 + 2 * r5 + 3] = o6;
    }
  };
  for (let x2 = 0; x2 < n4; x2++)
    y3(c2[x2], c2[x2 + 1]), y3(a3 + e3[x2], a3 + e3[x2 + 1]);
  const A3 = new Int32Array(3 * r3), U = (o5, n5) => o5 === t3[3 * n5] ? 0 : o5 === t3[3 * n5 + 1] ? 1 : o5 === t3[3 * n5 + 2] ? 2 : -1, u5 = (t4, o5) => {
    const n5 = U(t4, o5);
    A3[3 * o5 + n5] = -1;
  }, p5 = (t4, o5, n5, r4) => {
    const c3 = U(t4, o5);
    A3[3 * o5 + c3] = r4;
    const e4 = U(n5, r4);
    A3[3 * r4 + e4] = o5;
  };
  for (let x2 = 0; x2 < n4; x2++) {
    let t4 = c2[x2];
    const o5 = c2[x2 + 1];
    let n5 = e3[x2];
    const r4 = e3[x2 + 1];
    for (; t4 < o5 && n5 < r4; ) {
      const o6 = i[2 * t4], r5 = i[2 * a3 + 2 * n5];
      o6 === r5 ? (p5(x2, i[2 * t4 + 1], r5, i[2 * a3 + 2 * n5 + 1]), t4++, n5++) : o6 < r5 ? (u5(x2, i[2 * t4 + 1]), t4++) : (u5(r5, i[2 * a3 + 2 * n5 + 1]), n5++);
    }
    for (; t4 < o5; )
      u5(x2, i[2 * t4 + 1]), t4++;
    for (; n5 < r4; ) {
      u5(i[2 * a3 + 2 * n5], i[2 * a3 + 2 * n5 + 1]), n5++;
    }
  }
  return A3;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/edgeRendering/edgeBufferWriters.js
var a = class {
  updateSettings(t3) {
    this.settings = t3, this._edgeHashFunction = t3.reducedPrecision ? f : p3;
  }
  write(t3, o4, e3) {
    const n4 = this._edgeHashFunction(e3);
    y2.seed = n4;
    const i = y2.getIntRange(0, 255), r3 = y2.getIntRange(0, this.settings.variants - 1), s = 0.7, a3 = y2.getFloat(), c2 = 255 * (0.5 * g(-(1 - Math.min(a3 / s, 1)) + Math.max(0, a3 - s) / (1 - s), 1.2) + 0.5);
    t3.position0.setVec(o4, e3.position0), t3.position1.setVec(o4, e3.position1), t3.componentIndex.set(o4, e3.componentIndex), t3.variantOffset.set(o4, i), t3.variantStroke.set(o4, r3), t3.variantExtension.set(o4, c2);
  }
  trim(t3, o4) {
    return t3.slice(0, o4);
  }
};
var c = new Float32Array(6);
var m2 = new Uint32Array(c.buffer);
var u3 = new Uint32Array(1);
function p3(t3) {
  const o4 = c;
  o4[0] = t3.position0[0], o4[1] = t3.position0[1], o4[2] = t3.position0[2], o4[3] = t3.position1[0], o4[4] = t3.position1[1], o4[5] = t3.position1[2], u3[0] = 5381;
  for (let e3 = 0; e3 < m2.length; e3++)
    u3[0] = 31 * u3[0] + m2[e3];
  return u3[0];
}
function f(t3) {
  const o4 = c;
  o4[0] = h2(t3.position0[0]), o4[1] = h2(t3.position0[1]), o4[2] = h2(t3.position0[2]), o4[3] = h2(t3.position1[0]), o4[4] = h2(t3.position1[1]), o4[5] = h2(t3.position1[2]), u3[0] = 5381;
  for (let e3 = 0; e3 < m2.length; e3++)
    u3[0] = 31 * u3[0] + m2[e3];
  return u3[0];
}
var l2 = 1e4;
function h2(t3) {
  return Math.round(t3 * l2) / l2;
}
function g(t3, o4) {
  const e3 = t3 < 0 ? -1 : 1;
  return Math.abs(t3) ** o4 * e3;
}
var d2 = class {
  constructor() {
    this._commonWriter = new a();
  }
  updateSettings(t3) {
    this._commonWriter.updateSettings(t3);
  }
  allocate(t3) {
    return S.createBuffer(t3);
  }
  write(t3, n4, i) {
    this._commonWriter.write(t3, n4, i), u(_2, i.faceNormal0, i.faceNormal1), z(_2, _2), t3.normal.setVec(n4, _2);
  }
  trim(t3, o4) {
    return this._commonWriter.trim(t3, o4);
  }
};
d2.Layout = S, d2.glLayout = o2(S, 1);
var w2 = class {
  constructor() {
    this._commonWriter = new a();
  }
  updateSettings(t3) {
    this._commonWriter.updateSettings(t3);
  }
  allocate(t3) {
    return r2.createBuffer(t3);
  }
  write(t3, o4, e3) {
    this._commonWriter.write(t3, o4, e3), t3.normalA.setVec(o4, e3.faceNormal0), t3.normalB.setVec(o4, e3.faceNormal1);
  }
  trim(t3, o4) {
    return this._commonWriter.trim(t3, o4);
  }
};
w2.Layout = r2, w2.glLayout = o2(r2, 1);
var _2 = n();
var y2 = new t();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/edgeRendering/edgeProcessing.js
function f2(e3) {
  const t3 = u4(e3.data, e3.skipDeduplicate, e3.indices, e3.indicesLength);
  return p4.updateSettings(e3.writerSettings), d3.updateSettings(e3.writerSettings), h(t3, p4, d3);
}
function u4(i, r3, n4, o4) {
  if (r3) {
    const e3 = t2(n4, o4, i.count);
    return new g2(n4, o4, e3, i);
  }
  const c2 = n3(i.buffer, i.stride / 4, { originalIndices: n4, originalIndicesLength: o4 }), f3 = t2(c2.indices, o4, c2.uniqueCount);
  return { faces: c2.indices, facesLength: c2.indices.length, neighbors: f3, vertices: A.createView(c2.buffer) };
}
var g2 = class {
  constructor(e3, t3, i, r3) {
    this.faces = e3, this.facesLength = t3, this.neighbors = i, this.vertices = r3;
  }
};
var p4 = new d2();
var d3 = new w2();
var a2 = T().vec3f(O.POSITION0).vec3f(O.POSITION1);
var m3 = T().vec3f(O.POSITION0).vec3f(O.POSITION1).u16(O.COMPONENTINDEX).u16(O.U16PADDING, { glPadding: true });

export {
  A,
  h,
  f2 as f,
  u4 as u,
  a2 as a,
  m3 as m
};
//# sourceMappingURL=chunk-DJMOV3FK.js.map
