import {
  i as i3,
  r as r2
} from "./chunk-QXJIQKLY.js";
import {
  c,
  e as e4
} from "./chunk-7N2Z7KNR.js";
import {
  l as l2,
  n as n2
} from "./chunk-JMGHYNUW.js";
import {
  f
} from "./chunk-XBFCIW4K.js";
import {
  J,
  Q,
  le,
  me
} from "./chunk-6TBB7UXB.js";
import {
  B,
  C,
  D as D3,
  E as E3,
  F,
  G as G2,
  H,
  M as M2,
  N,
  O,
  P as P2,
  R,
  ct,
  o as o2
} from "./chunk-XO5VJRK4.js";
import {
  x
} from "./chunk-O4DPVR3F.js";
import {
  E as E2
} from "./chunk-MATM5L52.js";
import {
  D as D2,
  G,
  L,
  M,
  P,
  V,
  Y
} from "./chunk-3OFVLRSL.js";
import {
  l
} from "./chunk-GX2FDWTU.js";
import {
  e as e3
} from "./chunk-IQBIGNPU.js";
import {
  i as i2,
  s as s3
} from "./chunk-ZNRXLY4R.js";
import {
  n
} from "./chunk-JEA4MMTV.js";
import {
  o as o3,
  s as s4
} from "./chunk-RG3AHHRL.js";
import {
  e as e2
} from "./chunk-QWNKYSI4.js";
import {
  m
} from "./chunk-KDO6J2FO.js";
import {
  $
} from "./chunk-WJCI2CGX.js";
import {
  u
} from "./chunk-NRP45AHD.js";
import {
  D
} from "./chunk-MJXQTGI2.js";
import {
  s as s2
} from "./chunk-LIZHLHNA.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";
import {
  has
} from "./chunk-HVKDYDPP.js";
import {
  A,
  E,
  b,
  e,
  i,
  o,
  r,
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/WGLTile.js
var h = class {
  acquire(s5) {
    return { refCount: 1, version: -1, labelMat2d: e3(), tileMat3: e3(), dvs: e3() };
  }
  release(s5) {
  }
};
var m2 = class extends r2 {
  constructor(s5, t2, r4, e5) {
    super(s5, t2, r4, e5, o2, o2);
  }
  destroy() {
    super.destroy(), this._transforms && m2.TransformCache.release(this.key.hash);
  }
  setTransform(i5) {
    const o5 = this.resolution / i5.resolution, n3 = this.transforms.tileMat3, [h3, m3] = i5.toScreenNoRotation([0, 0], [this.x, this.y]), c3 = this.width / this.rangeX * o5, f2 = this.height / this.rangeY * o5;
    s3(n3, c3, 0, 0, 0, f2, 0, h3, m3, 1), i2(this.transforms.dvs, i5.displayViewMat3, n3);
    const d = this.transforms.labelMat2d, l3 = window.devicePixelRatio, u2 = s4(n(), c3 * l3, 0, 0, f2 * l3, h3 * l3, m3 * l3);
    o3(d, i5.viewMat2d, u2);
  }
  _createTransforms() {
    return m2.TransformCache.acquire(this.key.hash);
  }
};
m2.TransformCache = new h();

// node_modules/@arcgis/core/views/2d/engine/webgl/AttributeStoreView.js
var B2 = s.getLogger("esri.views.2d.engine.webgl.AttributeStoreView");
var V2 = n2(l2, B2);
var L2 = class {
  constructor(t2, e5, i5) {
    this._texture = null, this._lastTexture = null, this._fbos = {}, this.texelSize = 4;
    const { buffer: s5, pixelType: r4, textureOnly: a } = t2, h3 = me(r4);
    this.shared = i5, this.pixelType = r4, this.size = e5, this.textureOnly = a, a || (this.data = new h3(e(s5))), this._resetRange();
  }
  destroy() {
    o(this._texture, (t2) => t2.dispose());
    for (const t2 in this._fbos)
      o(this._fbos[t2], (e5) => {
        "0" === t2 && e5.detachColorTexture(), e5.dispose();
      }), this._fbos[t2] = null;
    this._texture = null;
  }
  get _textureDesc() {
    return { target: M.TEXTURE_2D, wrapMode: D2.CLAMP_TO_EDGE, pixelFormat: P.RGBA, dataType: this.pixelType, samplingMode: L.NEAREST, width: this.size, height: this.size };
  }
  setData(t2, e5, i5) {
    const s5 = f(t2), r4 = e(this.data), a = s5 * this.texelSize + e5;
    !r4 || a >= r4.length || (r4[a] = i5, this.dirtyStart = Math.min(this.dirtyStart, s5), this.dirtyEnd = Math.max(this.dirtyEnd, s5));
  }
  getData(t2, e5) {
    if (t(this.data))
      return null;
    const s5 = f(t2) * this.texelSize + e5;
    return !this.data || s5 >= this.data.length ? null : this.data[s5];
  }
  getTexture(t2) {
    return i(this._texture, () => this._initTexture(t2));
  }
  getFBO(t2, e5 = 0) {
    if (t(this._fbos[e5])) {
      const i5 = { colorTarget: Y.TEXTURE, depthStencilTarget: V.NONE }, s5 = 0 === e5 ? this.getTexture(t2) : this._textureDesc;
      this._fbos[e5] = new x(t2, i5, s5);
    }
    return this._fbos[e5];
  }
  get locked() {
    return !(this.pixelType !== G.UNSIGNED_BYTE || !this.shared || this.textureOnly || !has("esri-atomics") || !this.data) && 1 === Atomics.load(this.data, 0);
  }
  get hasDirty() {
    const t2 = this.dirtyStart;
    return this.dirtyEnd >= t2;
  }
  updateTexture(e5, i5) {
    if (!this.locked) {
      try {
        const i6 = this.dirtyStart, s5 = this.dirtyEnd;
        if (!this.hasDirty)
          return;
        this._resetRange();
        const r4 = e(this.data).buffer, a = this.getTexture(e5), h3 = 4, n3 = (i6 - i6 % this.size) / this.size, o5 = (s5 - s5 % this.size) / this.size, u2 = n3, l3 = this.size, p = o5, x2 = n3 * this.size * h3, _2 = (l3 + p * this.size) * h3 - x2, g = me(this.pixelType), c3 = new g(r4, x2 * g.BYTES_PER_ELEMENT, _2), T = this.size, f2 = p - u2 + 1;
        if (f2 > this.size)
          return void B2.error(new s2("mapview-webgl", "Out-of-bounds index when updating AttributeData"));
        a.updateData(0, 0, u2, T, f2, c3);
      } catch (s5) {
      }
      i5();
    }
  }
  update(t2) {
    const { data: e5, start: i5, end: s5 } = t2;
    if (r(e5)) {
      const s6 = this.data, r4 = i5 * this.texelSize;
      for (let i6 = 0; i6 < e5.length; i6++) {
        const a = 1 << i6 % this.texelSize;
        t2.layout & a && (s6[r4 + i6] = e5[i6]);
      }
    }
    this.dirtyStart = Math.min(this.dirtyStart, i5), this.dirtyEnd = Math.max(this.dirtyEnd, s5);
  }
  resize(t2, e5) {
    const i5 = this.size;
    if (this.size = e5, this.textureOnly)
      return void (i5 !== this.size && (this._lastTexture = this._texture, this._texture = null));
    const s5 = me(this.pixelType);
    this.destroy(), this.data = new s5(e(t2.buffer));
  }
  _resetRange() {
    this.dirtyStart = 2147483647, this.dirtyEnd = 0;
  }
  _initTexture(t2) {
    const e5 = new E2(t2, this._textureDesc, i(this.data, void 0));
    if (r(this._lastTexture) && this._fbos[0]) {
      const i5 = this._lastTexture.descriptor.width, s5 = this._lastTexture.descriptor.height, r4 = this._lastTexture.descriptor.dataType, a = this._lastTexture.descriptor.pixelFormat, d = this.getFBO(t2), h3 = le(r4), n3 = new (me(r4))(new ArrayBuffer(i5 * s5 * h3 * this.texelSize)), o5 = t2.getBoundFramebufferObject(), { x: u2, y: l3, width: p, height: x2 } = t2.getViewport();
      t2.bindFramebuffer(d), d.readPixels(0, 0, i5, s5, a, r4, n3), e5.updateData(0, 0, 0, 2 * i5, s5 / 2, n3), t2.setViewport(u2, l3, p, x2), t2.bindFramebuffer(o5);
    }
    return this.destroy(), this._texture = e5, this._texture;
  }
};
var G3 = class {
  constructor(t2) {
    this._onUpdate = t2, this._initialized = false, this._forceNextUpload = false, this._locked = false;
  }
  initialize(t2) {
    const { blocks: e5, shared: a, size: d } = t2;
    if (this.shared = a, this.size = d, V2("Initializing AttributeStoreView", t2), t(this._data))
      this._data = A(e5, (t3) => new L2(t3, d, a));
    else
      for (let s5 = 0; s5 < this._data.length; s5++) {
        const t3 = this._data[s5], h3 = e5[s5];
        r(h3) && (t(t3) ? this._data[s5] = new L2(h3, d, a) : t3.resize(h3, d));
      }
    this._initialized = true;
  }
  destroy() {
    o(this._data, (t2) => A(t2, (t3) => t3.destroy())), o(this._defaultTexture, (t2) => t2.dispose());
  }
  isEmpty() {
    const t2 = this._data;
    return t(t2);
  }
  isUpdating() {
    const t2 = r(this._pendingAttributeUpdate), e5 = t2;
    return has("esri-2d-log-updating") && console.log(`Updating AttributeStoreView ${e5}
  -> hasPendingUpdate ${t2}`), e5;
  }
  getBlock(t2) {
    if (t(this._data))
      return null;
    return this._data[t2];
  }
  setLabelMinZoom(t2, e5) {
    this.setData(t2, 0, 1, e5);
  }
  getLabelMinZoom(t2) {
    return this.getData(t2, 0, 1, 255);
  }
  getFilterFlags(t2) {
    return this.getData(t2, 0, 0, 0);
  }
  getVVSize(t2) {
    return this.getData(t2, P2, 0, 0);
  }
  getData(t2, e5, s5, a) {
    if (!this._data)
      return 0;
    const h3 = e(this._data)[e5];
    if (t(h3))
      return 0;
    const n3 = h3.getData(t2, s5);
    return r(n3) ? n3 : a;
  }
  setData(t2, e5, i5, s5) {
    const r4 = e(this._data)[e5];
    e(r4).setData(t2, i5, s5);
  }
  lockTextureUpload() {
    this._locked = true;
  }
  unlockTextureUpload() {
    this._locked = false;
  }
  forceTextureUpload() {
    this._forceNextUpload = true;
  }
  async requestUpdate(e5) {
    if (this._pendingAttributeUpdate)
      return void B2.error(new s2("mapview-webgl", "Tried to update attribute data with a pending update"));
    const i5 = D();
    return V2("AttributeStoreView Update Requested", e5), this._pendingAttributeUpdate = { data: e5, resolver: i5 }, this._onUpdate(), i5.promise;
  }
  update() {
    if (this._initialized && r(this._pendingAttributeUpdate)) {
      has("esri-2d-update-debug") && console.debug("AttributeStoreView::update");
      const { data: t2, resolver: e5 } = this._pendingAttributeUpdate, i5 = e(this._data);
      for (let s5 = 0; s5 < t2.blocks.length; s5++) {
        const e6 = t2.blocks[s5], r4 = i5[s5];
        o(r4, (t3) => o(e6, (e7) => {
          V2(`Updating block ${s5}`, e7), t3.update(e7);
        }));
      }
      this._pendingAttributeUpdate = null, e5(), this._onUpdate();
    }
  }
  bindTextures(t2, e5 = true) {
    const i5 = this._getDefaultTexture(t2);
    if (!this._initialized)
      return t2.bindTexture(i5, B), void (e5 && (t2.bindTexture(i5, C), t2.bindTexture(i5, D3), t2.bindTexture(i5, E3), t2.bindTexture(i5, F), t2.bindTexture(i5, G2), t2.bindTexture(i5, H)));
    const s5 = e(this._data);
    this._locked && !this._forceNextUpload || (E(s5, (e6) => e6.updateTexture(t2, () => this._onUpdate())), this._forceNextUpload = false), t2.bindTexture(b(s5[M2], i5, (e6) => e6.getTexture(t2)), B), e5 && (t2.bindTexture(b(s5[O], i5, (e6) => e6.getTexture(t2)), H), t2.bindTexture(b(s5[N], i5, (e6) => e6.getTexture(t2)), C), t2.bindTexture(b(s5[P2], i5, (e6) => e6.getTexture(t2)), D3), t2.bindTexture(b(s5[R], i5, (e6) => e6.getTexture(t2)), E3), t2.bindTexture(b(s5[F], i5, (e6) => e6.getTexture(t2)), F), t2.bindTexture(b(s5[G2], i5, (e6) => e6.getTexture(t2)), G2));
  }
  _getDefaultTexture(t2) {
    if (t(this._defaultTexture)) {
      const e5 = { wrapMode: D2.CLAMP_TO_EDGE, pixelFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, samplingMode: L.NEAREST, width: 1, height: 1 };
      this._defaultTexture = new E2(t2, e5, new Uint8Array(4));
    }
    return this._defaultTexture;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/WGLRendererInfo.js
function c2(e5, t2) {
  const i5 = t2.length;
  if (e5 < t2[0].value || 1 === i5)
    return t2[0].size;
  for (let s5 = 1; s5 < i5; s5++)
    if (e5 < t2[s5].value) {
      const i6 = (e5 - t2[s5 - 1].value) / (t2[s5].value - t2[s5 - 1].value);
      return t2[s5 - 1].size + i6 * (t2[s5].size - t2[s5 - 1].size);
    }
  return t2[i5 - 1].size;
}
var h2 = class {
  constructor() {
    this.symbolLevels = [], this.vvColorValues = new Float32Array(8), this.vvColors = new Float32Array(32), this.vvOpacityValues = new Float32Array(8), this.vvOpacities = new Float32Array(8), this.vvSizeMinMaxValue = new Float32Array(4), this._vvMaterialParameters = { vvSizeEnabled: false, vvColorEnabled: false, vvRotationEnabled: false, vvRotationType: "geographic", vvOpacityEnabled: false }, this._technique = e4;
  }
  getSizeVVFieldStops(i5) {
    const s5 = this._vvSizeFieldStops;
    switch (s5.type) {
      case "static":
        return s5;
      case "level-dependent":
        return i(s5.levels[i5], () => {
          let e5 = 1 / 0, a = 0;
          for (const t2 in s5.levels) {
            const s6 = parseFloat(t2), r5 = Math.abs(i5 - s6);
            r5 < e5 && (e5 = r5, a = s6);
          }
          if (e5 === 1 / 0)
            return { sizes: new Float32Array([0, 0, 0, 0, 0, 0]), values: new Float32Array([0, 0, 0, 0, 0, 0]) };
          const r4 = 2 ** ((i5 - a) / 2), o5 = e(s5.levels[a]), l3 = new Float32Array(o5.values);
          return l3[2] *= r4, l3[3] *= r4, { sizes: e(o5.sizes), values: l3 };
        });
    }
  }
  get vvMaterialParameters() {
    return this._vvMaterialParameters;
  }
  update(e5) {
    r(this._vvInfo) && this._updateVisualVariables(this._vvInfo.vvRanges, e5);
  }
  setInfo(e5, t2, i5) {
    this._updateEffects(i5), this._vvInfo = t2, this._technique = c(e5), this.rendererSchema = this._technique.createOrUpdateRendererSchema(this.rendererSchema, e5);
  }
  getVariation() {
    return { ...this._technique.getVariation(this.rendererSchema), outsideLabelsVisible: this.outsideLabelsVisible, supportsTextureFloat: l("2d").supportsTextureFloat };
  }
  getVariationHash() {
    return this._technique.getVariationHash(this.rendererSchema) << 1 | (this.outsideLabelsVisible ? 1 : 0);
  }
  _updateEffects(e5) {
    r(e5) ? this.outsideLabelsVisible = e5.excludedLabelsVisible : this.outsideLabelsVisible = false;
  }
  _updateVisualVariables(e5, t2) {
    const i5 = this._vvMaterialParameters;
    if (i5.vvOpacityEnabled = false, i5.vvSizeEnabled = false, i5.vvColorEnabled = false, i5.vvRotationEnabled = false, !e5)
      return;
    const n3 = e5.size;
    if (n3) {
      if (i5.vvSizeEnabled = true, n3.minMaxValue) {
        const e6 = n3.minMaxValue;
        let i6, a;
        if (J(e6.minSize) && J(e6.maxSize))
          if (Q(e6.minSize) && Q(e6.maxSize))
            i6 = u(e6.minSize), a = u(e6.maxSize);
          else {
            const r4 = t2.scale;
            i6 = u(c2(r4, e6.minSize.stops)), a = u(c2(r4, e6.maxSize.stops));
          }
        this.vvSizeMinMaxValue.set([e6.minDataValue, e6.maxDataValue, i6, a]);
      }
      if (n3.scaleStops && (this.vvSizeScaleStopsValue = u(c2(t2.scale, n3.scaleStops.stops))), n3.unitValue) {
        const e6 = $(t2.spatialReference) / m[n3.unitValue.unit];
        this.vvSizeUnitValueToPixelsRatio = e6 / t2.resolution;
      }
      n3.fieldStops && (this._vvSizeFieldStops = n3.fieldStops);
    }
    const v = e5.color;
    v && (i5.vvColorEnabled = true, this.vvColorValues.set(v.values), this.vvColors.set(v.colors));
    const u2 = e5.opacity;
    u2 && (i5.vvOpacityEnabled = true, this.vvOpacityValues.set(u2.values), this.vvOpacities.set(u2.opacities));
    const h3 = e5.rotation;
    h3 && (i5.vvRotationEnabled = true, i5.vvRotationType = h3.type);
  }
};

// node_modules/@arcgis/core/views/2d/engine/FeatureContainer.js
var o4 = class extends i3 {
  constructor(e5) {
    super(e5), this._rendererInfo = new h2(), this._materialItemsRequestQueue = new e2(), this.attributeView = new G3(() => this.onAttributeStoreUpdate());
  }
  destroy() {
    this.children.forEach((e5) => e5.destroy()), this.removeAllChildren(), this.attributeView.destroy(), this._materialItemsRequestQueue.clear();
  }
  setRendererInfo(e5, t2, r4) {
    this._rendererInfo.setInfo(e5, t2, r4), this.requestRender();
  }
  async getMaterialItems(t2, r4) {
    if (!t2 || 0 === t2.length)
      return null;
    const s5 = D();
    return this._materialItemsRequestQueue.push({ items: t2, abortOptions: r4, resolver: s5 }), this.requestRender(), s5.promise;
  }
  doRender(e5) {
    if (e5.context.capabilities.enable("textureFloat"), e5.context.capabilities.enable("vao"), this._materialItemsRequestQueue.length > 0) {
      let t2 = this._materialItemsRequestQueue.pop();
      for (; t2; )
        this._processMaterialItemRequest(e5, t2), t2 = this._materialItemsRequestQueue.pop();
    }
    super.doRender(e5);
  }
  renderChildren(e5) {
    for (const t2 of this.children)
      t2.commit(e5);
    this._rendererInfo.update(e5.state), super.renderChildren(e5);
  }
  updateTransforms(e5) {
    if (this.children.some((e6) => e6.hasData))
      for (const t2 of this.children)
        t2.setTransform(e5);
  }
  createRenderParams(e5) {
    const t2 = super.createRenderParams(e5);
    return t2.rendererInfo = this._rendererInfo, t2.attributeView = this.attributeView, t2;
  }
  onAttributeStoreUpdate() {
  }
  _processMaterialItemRequest(e5, { items: t2, abortOptions: r4, resolver: s5 }) {
    const { painter: i5, pixelRatio: o5 } = e5, n3 = t2.map((e6) => i5.textureManager.rasterizeItem(e6.symbol, o5, e6.glyphIds, r4));
    Promise.all(n3).then((e6) => {
      if (!this.stage)
        return void s5.reject();
      const r5 = e6.map((e7, r6) => ({ id: t2[r6].id, mosaicItem: e7 }));
      s5.resolve(r5);
    }, s5.reject);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/DisplayRecordReader.js
var r3 = 2147483647;
var i4 = class {
  constructor(t2) {
    this._head = t2, this._cursor = t2;
  }
  static from(t2, e5 = 0, s5 = t2.byteLength / _.BYTES_PER_RECORD - e5) {
    const r4 = new _(new Int32Array(t2, e5 * _.BYTES_PER_RECORD, s5 * _.ELEMENTS_PER_RECORD));
    return new i4(r4);
  }
  size() {
    let t2 = this._cursor, e5 = 0;
    for (; t2; )
      e5 += t2.size(), t2 = t2._link;
    return e5;
  }
  get id() {
    return this._cursor.id;
  }
  set id(t2) {
    this._cursor.id = t2;
  }
  get materialKey() {
    return this._cursor.materialKey;
  }
  set materialKey(t2) {
    this._cursor.materialKey = t2;
  }
  get insertAfter() {
    return this._cursor.insertAfter;
  }
  get indexFrom() {
    return this._cursor.indexFrom;
  }
  set indexFrom(t2) {
    this._cursor.indexFrom = t2;
  }
  get indexCount() {
    return this._cursor.indexCount;
  }
  set indexCount(t2) {
    this._cursor.indexCount = t2;
  }
  get vertexFrom() {
    return this._cursor.vertexFrom;
  }
  set vertexFrom(t2) {
    this._cursor.vertexFrom = t2;
  }
  get vertexCount() {
    return this._cursor.vertexCount;
  }
  set vertexCount(t2) {
    this._cursor.vertexCount = t2;
  }
  get sortKey() {
    return this._cursor.sortKey;
  }
  set sortKey(t2) {
    this._cursor.sortKey = t2;
  }
  get index() {
    return this._cursor._indexStart + this._cursor._index;
  }
  seekIndex(t2) {
    let e5 = t2;
    for (this._cursor = this._head; this._cursor; ) {
      const t3 = this._cursor.size();
      if (e5 < t3)
        return this._cursor._index = e5, true;
      e5 -= t3, this._cursor = this._cursor._link;
    }
    return false;
  }
  forEach(t2) {
    const e5 = this.getCursor();
    for (; e5.next(); )
      t2(e5);
  }
  link(t2) {
    if (!this._head)
      return void (this._head = t2._head);
    let e5 = this._head;
    for (; e5._link; )
      e5 = e5._link;
    e5._link = t2._head, e5._link._indexStart = e5._indexStart + e5.size();
  }
  getCursor() {
    return this.copy();
  }
  lookup(t2) {
    for (this._cursor = this._head; this._cursor && !this._cursor.lookup(t2); ) {
      if (!this._cursor._link)
        return false;
      this._cursor = this._cursor._link;
    }
    return !!this._cursor;
  }
  copy() {
    var _a;
    const t2 = new i4((_a = this._head) == null ? void 0 : _a.copy());
    if (!t2._head)
      return t2;
    let e5 = t2._head, s5 = t2._head._link;
    for (; s5; )
      e5._link = s5.copy(), e5 = s5, s5 = e5._link;
    return t2;
  }
  next() {
    return !!this._cursor && (!!this._cursor.next() || !!this._cursor._link && (this._cursor = this._cursor._link, this.next()));
  }
  peekId() {
    var _a;
    return (_a = this._cursor.peekId()) != null ? _a : this._cursor._link.peekId();
  }
  delete(e5) {
    let s5 = this._head, r4 = null;
    for (; s5; ) {
      if (s5.delete(e5))
        return s5.isEmpty() && (r(r4) && (r4._link = s5._link), s5 === this._head && (this._head = s5._link), s5 === this._cursor && (this._cursor = s5._link)), true;
      r4 = s5, s5 = s5._link;
    }
    return false;
  }
};
i4.ELEMENTS_PER_RECORD = ct, i4.BYTES_PER_RECORD = i4.ELEMENTS_PER_RECORD * Int32Array.BYTES_PER_ELEMENT;
var _ = class {
  constructor(t2) {
    this._link = null, this._index = -1, this._indexStart = 0, this._packedRecordsF32 = null, this._deletedCount = 0, this._offsets = { instance: null }, this._packedRecords = t2;
  }
  static from(t2, e5 = 0, s5 = t2.byteLength / this.BYTES_PER_RECORD - e5) {
    return new _(new Int32Array(t2, e5 * this.BYTES_PER_RECORD, s5 * this.ELEMENTS_PER_RECORD));
  }
  delete(t2) {
    const e5 = this._index, s5 = this.lookup(t2);
    if (s5)
      for (this.id = r3, ++this._deletedCount; this.next() && this.id === t2; )
        this.id = r3, ++this._deletedCount;
    return this._index = e5, s5;
  }
  isEmpty() {
    return this._deletedCount === this.size();
  }
  link(t2) {
    this._link ? this._link.link(t2) : this._link = t2;
  }
  lookup(t2) {
    if (t(this._offsets.instance)) {
      this._offsets.instance = /* @__PURE__ */ new Map();
      const t3 = this.copy();
      t3._index = -1;
      let e5 = 0;
      for (; t3.next(); )
        t3.id !== e5 && (this._offsets.instance.set(t3.id, t3._index), e5 = t3.id);
    }
    if (!this._offsets.instance.has(t2))
      return false;
    const s5 = this._index;
    return this._index = this._offsets.instance.get(t2), this.id !== r3 || (this._index = s5, false);
  }
  get id() {
    return this._packedRecords[this._index * _.ELEMENTS_PER_RECORD];
  }
  set id(t2) {
    this._packedRecords[this._index * _.ELEMENTS_PER_RECORD] = t2;
  }
  get materialKey() {
    return this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 1];
  }
  set materialKey(t2) {
    this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 1] = t2;
  }
  get insertAfter() {
    return this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 2];
  }
  get indexFrom() {
    return this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 3];
  }
  set indexFrom(t2) {
    this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 3] = t2;
  }
  get indexCount() {
    return this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 4];
  }
  set indexCount(t2) {
    this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 4] = t2;
  }
  get vertexFrom() {
    return this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 5];
  }
  set vertexFrom(t2) {
    this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 5] = t2;
  }
  get vertexCount() {
    return this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 6];
  }
  set vertexCount(t2) {
    this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 6] = t2;
  }
  get sortKey() {
    return this._packedRecordsF32 || (this._packedRecordsF32 = new Float32Array(this._packedRecords.buffer)), this._packedRecordsF32[this._index * _.ELEMENTS_PER_RECORD + 7];
  }
  set sortKey(t2) {
    this._packedRecordsF32 || (this._packedRecordsF32 = new Float32Array(this._packedRecords.buffer)), this._packedRecordsF32[this._index * _.ELEMENTS_PER_RECORD + 7] = t2;
  }
  get index() {
    return this._index;
  }
  size() {
    return this._packedRecords.length / _.ELEMENTS_PER_RECORD;
  }
  next() {
    for (; ++this._index < this.size() && this.id === r3; )
      ;
    return this._index < this.size();
  }
  peekId() {
    const t2 = (this._index + 1) * _.ELEMENTS_PER_RECORD;
    return t2 >= this._packedRecords.length ? 0 : this._packedRecords[t2];
  }
  getCursor() {
    return this.copy();
  }
  copy() {
    const t2 = new _(this._packedRecords);
    return t2._indexStart = this._indexStart, t2._link = this._link, t2._index = this._index, t2._offsets = this._offsets, t2._deletedCount = this._deletedCount, t2;
  }
};
_.ELEMENTS_PER_RECORD = ct, _.BYTES_PER_RECORD = _.ELEMENTS_PER_RECORD * Int32Array.BYTES_PER_ELEMENT;

export {
  m2 as m,
  i4 as i,
  o4 as o
};
//# sourceMappingURL=chunk-DPGI5XTT.js.map
