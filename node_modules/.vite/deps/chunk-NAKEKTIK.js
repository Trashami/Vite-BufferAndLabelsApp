import {
  e
} from "./chunk-QWNKYSI4.js";
import {
  a as a2,
  a2 as a3,
  c
} from "./chunk-ZHAW7FZS.js";
import {
  r as r2
} from "./chunk-OOLCFNXJ.js";
import {
  A,
  C,
  a,
  f,
  j,
  p,
  r2 as r3,
  v
} from "./chunk-MJXQTGI2.js";
import {
  s as s2
} from "./chunk-LIZHLHNA.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";
import {
  has
} from "./chunk-HVKDYDPP.js";
import {
  h,
  r
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/core/workers/utils.js
var t;
!function(t2) {
  t2[t2.HANDSHAKE = 0] = "HANDSHAKE", t2[t2.OPEN = 1] = "OPEN", t2[t2.OPENED = 2] = "OPENED", t2[t2.RESPONSE = 3] = "RESPONSE", t2[t2.INVOKE = 4] = "INVOKE", t2[t2.ABORT = 5] = "ABORT", t2[t2.CLOSE = 6] = "CLOSE", t2[t2.OPEN_PORT = 7] = "OPEN_PORT", t2[t2.ON = 8] = "ON";
}(t || (t = {}));
var e2 = 0;
function r4() {
  return e2++;
}
function n(t2) {
  return t2 && "object" == typeof t2 && ("result" in t2 || "transferList" in t2);
}
function s3(t2) {
  return t2 ? "string" == typeof t2 ? JSON.stringify({ name: "message", message: t2 }) : t2.toJSON ? JSON.stringify(t2) : JSON.stringify({ name: t2.name, message: t2.message, details: t2.details || { stack: t2.stack } }) : null;
}
function o(e3, r5, f4, a5) {
  if (r5.type === t.OPEN_PORT)
    return void e3.postMessage(r5, [r5.port]);
  if (r5.type !== t.INVOKE && r5.type !== t.RESPONSE)
    return void e3.postMessage(r5);
  let u;
  if (n(f4) ? (u = i(f4.transferList), r5.data = f4.result) : (u = i(a5), r5.data = f4), u) {
    if (has("ff")) {
      for (const n2 of u)
        if ("byteLength" in n2 && n2.byteLength > 267386880) {
          const n3 = "Worker call with large ArrayBuffer would crash Firefox";
          switch (r5.type) {
            case t.INVOKE:
              throw n3;
            case t.RESPONSE:
              return void o(e3, { type: t.RESPONSE, jobId: r5.jobId, error: s3(n3) });
          }
        }
    }
    e3.postMessage(r5, u);
  } else
    e3.postMessage(r5);
}
function f2(t2) {
  if (!t2)
    return null;
  const e3 = t2.data;
  return e3 ? "string" == typeof e3 ? JSON.parse(e3) : e3 : null;
}
function i(t2) {
  if (!t2 || !t2.length)
    return null;
  if (has("esri-workers-arraybuffer-transfer"))
    return t2;
  const e3 = t2.filter((t3) => !a4(t3));
  return e3.length ? e3 : null;
}
function a4(t2) {
  return t2 instanceof ArrayBuffer || t2 && t2.constructor && "ArrayBuffer" === t2.constructor.name;
}

// node_modules/@arcgis/core/core/workers/RemoteClient.js
var k = { statsWorker: () => import("./statsWorker-W42LOGAT.js"), geometryEngineWorker: () => import("./geometryEngineWorker-WNDUTWH2.js"), CSVSourceWorker: () => import("./CSVSourceWorker-ZFMZRKOK.js"), EdgeProcessingWorker: () => import("./EdgeProcessingWorker-ZWVRZWTI.js"), ElevationSamplerWorker: () => import("./ElevationSamplerWorker-XLJOENNI.js"), FeatureServiceSnappingSourceWorker: () => import("./FeatureServiceSnappingSourceWorker-2ZPCBCPA.js"), GeoJSONSourceWorker: () => import("./GeoJSONSourceWorker-YOQOIOO4.js"), LercWorker: () => import("./LercWorker-OQYNKVGJ.js"), MemorySourceWorker: () => import("./MemorySourceWorker-SVGSP7J2.js"), PBFDecoderWorker: () => import("./PBFDecoderWorker-HBDEGVKL.js"), Pipeline: () => import("./Pipeline-XKLRG2GG.js"), PointCloudWorker: () => import("./PointCloudWorker-K7YKLZ6M.js"), RasterWorker: () => import("./RasterWorker-ZLC4C4GY.js"), SceneLayerSnappingSourceWorker: () => import("./SceneLayerSnappingSourceWorker-B6B47U5B.js"), SceneLayerWorker: () => import("./SceneLayerWorker-SMLPBGFN.js"), WFSSourceWorker: () => import("./WFSSourceWorker-F2QF34VU.js"), WorkerTileHandler: () => import("./WorkerTileHandler-7YBVJQER.js") };
var { CLOSE: b, ABORT: v2, INVOKE: y, RESPONSE: j2, OPEN_PORT: S, ON: f3 } = t;
var W = 2;
var M = class {
  constructor(e3) {
    this._timer = null, this._cancelledJobIds = /* @__PURE__ */ new Set(), this._invokeMessages = [], this._invoke = e3, this._timer = null, this._process = this._process.bind(this);
  }
  push(e3) {
    e3.type === t.ABORT ? this._cancelledJobIds.add(e3.jobId) : (this._invokeMessages.push(e3), null === this._timer && (this._timer = setTimeout(this._process, 0)));
  }
  clear() {
    this._invokeMessages.length = 0, this._cancelledJobIds.clear(), this._timer = null;
  }
  _process() {
    this._timer = null;
    for (const e3 of this._invokeMessages)
      this._cancelledJobIds.has(e3.jobId) || this._invoke(e3);
    this._cancelledJobIds.clear(), this._invokeMessages.length = 0;
  }
};
var w = class {
  constructor(e3, s4, t2) {
    this._port = e3, this._getNextJob = t2, this._outJobs = /* @__PURE__ */ new Map(), this._inJobs = /* @__PURE__ */ new Map(), this._invokeQueue = new M((e4) => this._onInvokeMessage(e4)), this._client = s4.client, this._onMessage = this._onMessage.bind(this), this._channel = s4.channel, this._schedule = s4.schedule, this._port.addEventListener("message", this._onMessage), this._port.start();
  }
  static connect(e3) {
    const s4 = new MessageChannel();
    let t2;
    t2 = "function" == typeof e3 ? new e3() : "default" in e3 && "function" == typeof e3.default ? new e3.default() : e3;
    const o2 = new w(s4.port1, { channel: s4, client: t2 }, () => null);
    return "object" == typeof t2 && "remoteClient" in t2 && (t2.remoteClient = o2), w.clients.set(o2, t2), s4.port2;
  }
  static loadWorker(e3) {
    const s4 = k[e3];
    return s4 ? s4() : Promise.resolve(null);
  }
  close() {
    this._post({ type: b }), this._close();
  }
  isBusy() {
    return this._outJobs.size > 0;
  }
  invoke(e3, t2, r5) {
    const c2 = r5 && r5.signal, l = r5 && r5.transferList;
    if (!this._port)
      return Promise.reject(new s2("worker:port-closed", `Cannot call invoke('${e3}'), port is closed`, { methodName: e3, data: t2 }));
    const h3 = r4();
    return new Promise((s4, r6) => {
      if (p(c2))
        return this._processWork(), void r6(a());
      const p2 = v(c2, () => {
        const e4 = this._outJobs.get(h3);
        e4 && (this._outJobs.delete(h3), this._processWork(), h(e4.abortHandle), this._post({ type: v2, jobId: h3 }), r6(a()));
      }), u = { resolve: s4, reject: r6, abortHandle: p2, debugInfo: e3 };
      this._outJobs.set(h3, u), this._post({ type: y, jobId: h3, methodName: e3, abortable: null != c2 }, t2, l);
    });
  }
  on(e3, s4) {
    const t2 = new MessageChannel();
    function o2(e4) {
      s4(e4.data);
    }
    return this._port.postMessage({ type: t.ON, eventType: e3, port: t2.port2 }, [t2.port2]), t2.port1.addEventListener("message", o2), t2.port1.start(), { remove() {
      t2.port1.postMessage({ type: t.CLOSE }), t2.port1.close(), t2.port1.removeEventListener("message", o2);
    } };
  }
  jobAdded() {
    this._processWork();
  }
  openPort() {
    const e3 = new MessageChannel();
    return this._post({ type: S, port: e3.port2 }), e3.port1;
  }
  _processWork() {
    if (this._outJobs.size >= W)
      return;
    const e3 = this._getNextJob();
    if (!e3)
      return;
    const { methodName: s4, data: t2, invokeOptions: o2, deferred: r5 } = e3;
    this.invoke(s4, t2, o2).then((e4) => r5.resolve(e4)).catch((e4) => r5.reject(e4));
  }
  _close() {
    this._channel && (this._channel = void 0), this._port.removeEventListener("message", this._onMessage), this._port.close(), this._outJobs.forEach((e3) => {
      h(e3.abortHandle), e3.reject(a(`Worker closing, aborting job calling '${e3.debugInfo}'`));
    }), this._inJobs.clear(), this._outJobs.clear(), this._invokeQueue.clear(), this._port = this._client = this._schedule = null;
  }
  _onMessage(e3) {
    r(this._schedule) ? this._schedule(() => this._processMessage(e3)) : this._processMessage(e3);
  }
  _processMessage(e3) {
    const s4 = f2(e3);
    if (s4)
      switch (s4.type) {
        case j2:
          this._onResponseMessage(s4);
          break;
        case y:
          this._invokeQueue.push(s4);
          break;
        case v2:
          this._onAbortMessage(s4);
          break;
        case b:
          this._onCloseMessage();
          break;
        case S:
          this._onOpenPortMessage(s4);
          break;
        case f3:
          this._onOnMessage(s4);
      }
  }
  _onAbortMessage(e3) {
    const s4 = this._inJobs, t2 = e3.jobId, o2 = s4.get(t2);
    this._invokeQueue.push(e3), o2 && (o2.controller && o2.controller.abort(), s4.delete(t2));
  }
  _onCloseMessage() {
    const e3 = this._client;
    this._close(), e3 && "destroy" in e3 && w.clients.get(this) === e3 && e3.destroy(), w.clients.delete(this), e3 && e3.remoteClient && (e3.remoteClient = null);
  }
  _onInvokeMessage(e3) {
    const { methodName: s4, jobId: t2, data: o2, abortable: r5 } = e3, i2 = r5 ? new AbortController() : null, n2 = this._inJobs;
    let a5, p2 = this._client, h3 = p2[s4];
    try {
      if (!h3 && s4 && s4.includes(".")) {
        const e4 = s4.split(".");
        for (let s5 = 0; s5 < e4.length - 1; s5++)
          p2 = p2[e4[s5]], h3 = p2[e4[s5 + 1]];
      }
      if ("function" != typeof h3)
        throw new TypeError(`${s4} is not a function`);
      a5 = h3.call(p2, o2, { client: this, signal: i2 ? i2.signal : null });
    } catch (u) {
      return void this._post({ type: j2, jobId: t2, error: s3(u) });
    }
    C(a5) ? (n2.set(t2, { controller: i2, promise: a5 }), a5.then((e4) => {
      n2.has(t2) && (n2.delete(t2), this._post({ type: j2, jobId: t2 }, e4));
    }, (e4) => {
      n2.has(t2) && (n2.delete(t2), j(e4) || this._post({ type: j2, jobId: t2, error: s3(e4 || { message: `Error encountered at method ${s4}` }) }));
    })) : this._post({ type: j2, jobId: t2 }, a5);
  }
  _onOpenPortMessage(e3) {
    new w(e3.port, { client: this._client }, () => null);
  }
  _onOnMessage(e3) {
    const { port: s4 } = e3, o2 = this._client.on(e3.eventType, (e4) => {
      s4.postMessage(e4);
    }), r5 = r3(e3.port, "message", (e4) => {
      var _a;
      ((_a = f2(e4)) == null ? void 0 : _a.type) === t.CLOSE && (r5.remove(), o2.remove(), s4.close());
    });
  }
  _onResponseMessage(e3) {
    const { jobId: t2, error: r5, data: i2 } = e3, n2 = this._outJobs;
    if (!n2.has(t2))
      return;
    const a5 = n2.get(t2);
    n2.delete(t2), this._processWork(), h(a5.abortHandle), r5 ? a5.reject(s2.fromJSON(JSON.parse(r5))) : a5.resolve(i2);
  }
  _post(e3, s4, t2) {
    return o(this._port, e3, s4, t2);
  }
};
w.kernelInfo = { revision: a2, version: a3, buildDate: c }, w.clients = /* @__PURE__ */ new Map();

// node_modules/@arcgis/core/core/workers/Connection.js
var h2 = class {
  constructor() {
    this._inUseClients = new Array(), this._clients = new Array(), this._clientPromises = new Array(), this._ongoingJobsQueue = new e();
  }
  destroy() {
    this.close();
  }
  get closed() {
    return !this._clients || !this._clients.length;
  }
  open(e3, t2) {
    return new Promise((n2, i2) => {
      let r5 = true;
      const h3 = (e4) => {
        f(t2.signal), r5 && (r5 = false, e4());
      };
      this._clients.length = e3.length, this._clientPromises.length = e3.length, this._inUseClients.length = e3.length;
      for (let o2 = 0; o2 < e3.length; ++o2) {
        const r6 = e3[o2];
        C(r6) ? this._clientPromises[o2] = r6.then((e4) => (this._clients[o2] = new w(e4, t2, () => {
          var _a;
          return (_a = this._ongoingJobsQueue.pop()) != null ? _a : null;
        }), h3(n2), this._clients[o2]), () => (h3(i2), null)) : (this._clients[o2] = new w(r6, t2, () => {
          var _a;
          return (_a = this._ongoingJobsQueue.pop()) != null ? _a : null;
        }), this._clientPromises[o2] = Promise.resolve(this._clients[o2]), h3(n2));
      }
    });
  }
  broadcast(e3, t2, s4) {
    const n2 = new Array(this._clientPromises.length);
    for (let i2 = 0; i2 < this._clientPromises.length; ++i2) {
      const o2 = this._clientPromises[i2];
      n2[i2] = o2.then((n3) => n3 == null ? void 0 : n3.invoke(e3, t2, s4));
    }
    return n2;
  }
  close() {
    let e3;
    for (; e3 = this._ongoingJobsQueue.pop(); )
      e3.deferred.reject(a(`Worker closing, aborting job calling '${e3.methodName}'`));
    for (const t2 of this._clientPromises)
      t2.then((e4) => e4 == null ? void 0 : e4.close());
    this._clients.length = 0, this._clientPromises.length = 0;
  }
  invoke(e3, s4, n2) {
    let o2;
    Array.isArray(n2) ? (s.getLogger("esri.core.workers.Connection").warn("invoke()", "The transferList parameter is deprecated, use the options object instead"), o2 = { transferList: n2 }) : o2 = n2;
    const r5 = A();
    this._ongoingJobsQueue.push({ methodName: e3, data: s4, invokeOptions: o2, deferred: r5 });
    for (let t2 = 0; t2 < this._clientPromises.length; t2++) {
      const e4 = this._clients[t2];
      e4 ? e4.jobAdded() : this._clientPromises[t2].then((e5) => e5 == null ? void 0 : e5.jobAdded());
    }
    return r5.promise;
  }
  on(t2, s4) {
    return Promise.all(this._clientPromises).then(() => r2(this._clients.map((e3) => e3.on(t2, s4))));
  }
  openPorts() {
    return new Promise((e3) => {
      const t2 = new Array(this._clientPromises.length);
      let s4 = t2.length;
      for (let n2 = 0; n2 < this._clientPromises.length; ++n2) {
        this._clientPromises[n2].then((i2) => {
          i2 && (t2[n2] = i2.openPort()), 0 == --s4 && e3(t2);
        });
      }
    });
  }
  get test() {
    return { numClients: this._clients.length };
  }
};

export {
  t,
  r4 as r,
  s3 as s,
  o,
  f2 as f,
  w,
  h2 as h
};
//# sourceMappingURL=chunk-NAKEKTIK.js.map
