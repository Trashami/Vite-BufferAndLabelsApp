import {
  G,
  w
} from "./chunk-UWG37XSU.js";

// node_modules/@arcgis/core/arcade/functions/centroid.js
function e(t, n, e2) {
  return Math.sqrt((t[0] - n[0]) ** 2 + (t[1] - n[1]) ** 2 + (void 0 !== t[2] && void 0 !== n[2] ? (t[2] * e2 - n[2] * e2) ** 2 : 0));
}
var r = [];
for (const v of [[9002, 56146130, 6131, 6132, 8050, 8051, 8228], [9003, 5702, 6358, 6359, 6360, 8052, 8053], [9095, 5754]]) {
  const t = v[0];
  for (let n = 1; n < v.length; n++)
    r[v[n]] = t;
}
var o = [];
function s(t) {
  return t.vcsWkid && void 0 !== r[t.vcsWkid] ? o[r[t.vcsWkid]] : t.latestVcsWkid && void 0 !== r[t.latestVcsWkid] ? o[r[t.latestVcsWkid]] : 1;
}
function c(t, n, e2) {
  const r2 = { x: 0, y: 0 };
  n && (r2.z = 0), e2 && (r2.m = 0);
  let o2 = 0, s2 = t[0];
  for (let c2 = 0; c2 < t.length; c2++) {
    const a2 = t[c2];
    if (false === f(a2, s2)) {
      const t2 = h(s2, a2, n), c3 = i(s2, a2, n, e2);
      c3.x *= t2, c3.y *= t2, r2.x += c3.x, r2.y += c3.y, n && (c3.z *= t2, r2.z += c3.z), e2 && (c3.m *= t2, r2.m += c3.m), o2 += t2, s2 = a2;
    }
  }
  return o2 > 0 ? (r2.x /= o2, r2.y /= o2, n && (r2.z /= o2), e2 && (r2.m /= o2)) : (r2.x = t[0][0], r2.y = t[0][1], n && (r2.z = t[0][2]), e2 && n ? r2.m = t[0][3] : e2 && (r2.m = t[0][2])), r2;
}
function i(t, n, e2, r2) {
  const o2 = { x: (t[0] + n[0]) / 2, y: (t[1] + n[1]) / 2 };
  return e2 && (o2.z = (t[2] + n[2]) / 2), e2 && r2 ? o2.m = (t[3] + n[3]) / 2 : r2 && (o2.m = (t[2] + n[2]) / 2), o2;
}
function a(t, n) {
  if (t.length <= 1)
    return 0;
  let e2 = 0;
  for (let r2 = 1; r2 < t.length; r2++)
    e2 += h(t[r2 - 1], t[r2], n);
  return e2;
}
function h(t, n, e2) {
  const r2 = n[0] - t[0], o2 = n[1] - t[1];
  if (e2) {
    const t2 = n[2] - n[2];
    return Math.sqrt(r2 * r2 + o2 * o2 + t2 * t2);
  }
  return Math.sqrt(r2 * r2 + o2 * o2);
}
function f(t, n) {
  if (t.length !== n.length)
    return false;
  for (let e2 = 0; e2 < t.length; e2++)
    if (t[e2] !== n[e2])
      return false;
  return true;
}
function l(n) {
  const e2 = { x: 0, y: 0, spatialReference: n.spatialReference.toJSON() }, r2 = { x: 0, y: 0, spatialReference: n.spatialReference.toJSON() };
  let o2 = 0, s2 = 0;
  for (let t = 0; t < n.paths.length; t++) {
    if (0 === n.paths[t].length)
      continue;
    const i2 = a(n.paths[t], true === n.hasZ);
    if (0 === i2) {
      const r3 = c(n.paths[t], true === n.hasZ, true === n.hasM);
      e2.x += r3.x, e2.y += r3.y, true === n.hasZ && (e2.z += r3.z), true === n.hasM && (e2.m += r3.m), ++o2;
    } else {
      const e3 = c(n.paths[t], true === n.hasZ, true === n.hasM);
      r2.x += e3.x * i2, r2.y += e3.y * i2, true === n.hasZ && (r2.z += e3.z * i2), true === n.hasM && (r2.m += e3.m * i2), s2 += i2;
    }
  }
  return s2 > 0 ? (r2.x /= s2, r2.y /= s2, true === n.hasZ && (r2.z /= s2), true === n.hasM && (r2.m /= s2), new w(r2)) : o2 > 0 ? (e2.x /= o2, e2.y /= o2, true === n.hasZ && (r2.z /= o2), true === n.hasM && (e2.m /= o2), new w(e2)) : null;
}
function u(n) {
  if (0 === n.points.length)
    return null;
  let e2 = 0, r2 = 0, o2 = 0, s2 = 0;
  for (let t = 0; t < n.points.length; t++) {
    const c3 = n.getPoint(t);
    true === c3.hasZ && (o2 += c3.z), true === c3.hasM && (s2 += c3.m), e2 += c3.x, r2 += c3.y, s2 += c3.m;
  }
  const c2 = { x: e2 / n.points.length, y: r2 / n.points.length, spatialReference: null };
  return c2.spatialReference = n.spatialReference.toJSON(), true === n.hasZ && (c2.z = o2 / n.points.length), true === n.hasM && (c2.m = s2 / n.points.length), new w(c2);
}
function y(t, n) {
  return t.x * n.x + t.y * n.y;
}
function x(t, n) {
  return t.x * n.y - n.x * t.y;
}
function m(t, n, e2 = 0) {
  for (; t < e2; )
    t += n;
  const r2 = e2 + n;
  for (; t >= r2; )
    t -= n;
  return t;
}
function g(t, n) {
  return Math.atan2(n.y - t.y, n.x - t.x);
}
function p(t, n) {
  return m(g(t, n), 2 * Math.PI) * (180 / Math.PI);
}
function M(t, n) {
  return m(Math.PI / 2 - g(t, n), 2 * Math.PI) * (180 / Math.PI);
}
function z(t, n, e2) {
  const r2 = { x: t.x - n.x, y: t.y - n.y }, o2 = { x: e2.x - n.x, y: e2.y - n.y };
  return Math.atan2(x(r2, o2), y(r2, o2));
}
function P(t, n, e2) {
  return m(z(t, n, e2), 2 * Math.PI) * (180 / Math.PI);
}
function d(t, n, e2) {
  return m(-1 * z(t, n, e2), 2 * Math.PI) * (180 / Math.PI);
}
o[9002] = 0.3048, o[9003] = 0.3048006096012192, o[9095] = 0.3048007491;
var I = [0, 0];
function Z(t) {
  for (let e2 = 0; e2 < t.length; e2++) {
    const r2 = t[e2];
    for (let s2 = 0; s2 < r2.length - 1; s2++) {
      const o3 = r2[s2], c2 = r2[s2 + 1];
      for (let r3 = e2 + 1; r3 < t.length; r3++)
        for (let e3 = 0; e3 < t[r3].length - 1; e3++) {
          const s3 = t[r3][e3], i2 = t[r3][e3 + 1];
          if (G(o3, c2, s3, i2, I) && !(I[0] === o3[0] && I[1] === o3[1] || I[0] === s3[0] && I[1] === s3[1] || I[0] === c2[0] && I[1] === c2[1] || I[0] === i2[0] && I[1] === i2[1]))
            return true;
        }
    }
    const o2 = r2.length;
    if (!(o2 < 3))
      for (let t2 = 0; t2 <= o2 - 2; t2++) {
        const e3 = r2[t2], s2 = r2[t2 + 1];
        for (let c2 = t2 + 2; c2 <= o2 - 2; c2++) {
          const t3 = r2[c2], o3 = r2[c2 + 1];
          if (G(e3, s2, t3, o3, I) && !(I[0] === e3[0] && I[1] === e3[1] || I[0] === t3[0] && I[1] === t3[1] || I[0] === s2[0] && I[1] === s2[1] || I[0] === o3[0] && I[1] === o3[1]))
            return true;
        }
      }
  }
  return false;
}

export {
  e,
  s,
  l,
  u,
  p,
  M,
  P,
  d,
  Z
};
//# sourceMappingURL=chunk-YHCS4AQC.js.map
