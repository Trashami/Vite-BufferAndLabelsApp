import {
  g
} from "./chunk-MQZ56CH5.js";
import {
  l as l2,
  m,
  s as s2,
  u as u2
} from "./chunk-3W7B4MPK.js";
import {
  L,
  N
} from "./chunk-C6PPKAZD.js";
import "./chunk-ERETLMFB.js";
import "./chunk-LX2NI53X.js";
import "./chunk-IZUZZJS7.js";
import {
  An,
  mn
} from "./chunk-FFVIDMFN.js";
import "./chunk-I4RYNNL6.js";
import {
  i
} from "./chunk-VGNX3TFX.js";
import "./chunk-YTOF4Z6B.js";
import {
  p
} from "./chunk-HAVCYBU2.js";
import {
  v as v2
} from "./chunk-G3HEFWHV.js";
import {
  c as c2
} from "./chunk-FX6IXM55.js";
import {
  O
} from "./chunk-QFFP6A5Q.js";
import "./chunk-J5VTDQTQ.js";
import {
  d
} from "./chunk-YGVY4EIZ.js";
import "./chunk-HUQX7WZO.js";
import "./chunk-BYSA56OH.js";
import "./chunk-ZWUEORSX.js";
import "./chunk-US2IWMHE.js";
import "./chunk-ZPYDYUP5.js";
import {
  t as t4
} from "./chunk-XJCUKRCO.js";
import {
  b
} from "./chunk-SOEQPPQP.js";
import "./chunk-YM6PUX7G.js";
import "./chunk-QEYOWTXD.js";
import "./chunk-KDO6J2FO.js";
import "./chunk-RT3T2K4S.js";
import "./chunk-WJCI2CGX.js";
import "./chunk-BLJKKR5D.js";
import {
  c
} from "./chunk-X2S4RQJ4.js";
import "./chunk-376OPXM4.js";
import "./chunk-DER356EU.js";
import "./chunk-NAN5J6QS.js";
import "./chunk-6M2AHKYV.js";
import "./chunk-SZIJNKCV.js";
import "./chunk-6O43OEU5.js";
import "./chunk-J2K7ZDSV.js";
import "./chunk-2UML3WQZ.js";
import {
  j as j2
} from "./chunk-UDND2Z3V.js";
import "./chunk-23Y3DIC6.js";
import "./chunk-JUVQV3R3.js";
import "./chunk-C5H57NTD.js";
import "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import "./chunk-YWAQYJRC.js";
import "./chunk-B356PXLT.js";
import "./chunk-EHPBHJYZ.js";
import {
  v2 as v
} from "./chunk-3MNMDUQZ.js";
import "./chunk-UWG37XSU.js";
import "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import {
  r as r2
} from "./chunk-HLM6QCL2.js";
import {
  o
} from "./chunk-RXYULINL.js";
import {
  U,
  a
} from "./chunk-5NXILPDI.js";
import "./chunk-THVR7IAM.js";
import "./chunk-ZWJJTUFL.js";
import {
  U as U2
} from "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import {
  j
} from "./chunk-KAN4HXCG.js";
import "./chunk-4FEGON7M.js";
import "./chunk-VWYWOOPX.js";
import "./chunk-M5VHU5LK.js";
import {
  l,
  u2 as u
} from "./chunk-7QMMKGW4.js";
import {
  e,
  n2 as n,
  t2,
  t5 as t3,
  y as y2
} from "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import {
  w
} from "./chunk-MJXQTGI2.js";
import {
  s
} from "./chunk-LIZHLHNA.js";
import "./chunk-BTUHYGXO.js";
import "./chunk-UA3YPL2R.js";
import {
  y
} from "./chunk-HVKDYDPP.js";
import "./chunk-6QC7MLLS.js";
import {
  q,
  r,
  t
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/layers/support/SceneModification.js
var m2;
var y3 = m2 = class extends l {
  constructor(e2) {
    super(e2), this.geometry = null, this.type = "clip";
  }
  writeGeometry(e2, r3, o2, s3) {
    if (s3.layer && s3.layer.spatialReference && !s3.layer.spatialReference.equals(this.geometry.spatialReference)) {
      if (!An(e2.spatialReference, s3.layer.spatialReference))
        return void (s3 && s3.messages && s3.messages.push(new t2("scenemodification:unsupported", "Scene modifications with incompatible spatial references are not supported", { modification: this, spatialReference: s3.layer.spatialReference, context: s3 })));
      const p2 = new v();
      mn(e2, p2, s3.layer.spatialReference), r3[o2] = p2.toJSON(s3);
    } else
      r3[o2] = e2.toJSON(s3);
    delete r3[o2].spatialReference;
  }
  clone() {
    return new m2({ geometry: y(this.geometry), type: this.type });
  }
};
e([y2({ type: v }), g()], y3.prototype, "geometry", void 0), e([r2(["web-scene", "portal-item"], "geometry")], y3.prototype, "writeGeometry", null), e([y2({ type: ["clip", "mask", "replace"], nonNullable: true }), g()], y3.prototype, "type", void 0), y3 = m2 = e([n("esri.layers.support.SceneModification")], y3);
var f = y3;

// node_modules/@arcgis/core/layers/support/SceneModifications.js
var a2;
var n2 = a2 = class extends u(j2.ofType(f)) {
  constructor(r3) {
    super(r3), this.url = null;
  }
  clone() {
    return new a2({ url: this.url, items: this.items.map((r3) => r3.clone()) });
  }
  toJSON(r3) {
    return this.toArray().map((o2) => o2.toJSON(r3)).filter((r4) => !!r4.geometry);
  }
  static fromJSON(r3, o2) {
    const t5 = new a2();
    for (const e2 of r3)
      t5.add(f.fromJSON(e2, o2));
    return t5;
  }
  static async fromUrl(r3, t5, e2) {
    const c3 = { url: j(r3), origin: "service" }, p2 = await U2(r3, { responseType: "json", signal: q(e2, "signal") }), n3 = t5.toJSON(), l4 = [];
    for (const o2 of p2.data)
      l4.push(f.fromJSON({ ...o2, geometry: { ...o2.geometry, spatialReference: n3 } }, c3));
    return new a2({ url: r3, items: l4 });
  }
};
e([y2({ type: String })], n2.prototype, "url", void 0), n2 = a2 = e([n("esri.layers.support.SceneModifications")], n2);
var l3 = n2;

// node_modules/@arcgis/core/layers/IntegratedMeshLayer.js
var b2 = class extends N(p(c2(v2(t4(O(i(b))))))) {
  constructor(...e2) {
    super(...e2), this._handles = new t3(), this.geometryType = "mesh", this.operationalLayerType = "IntegratedMeshLayer", this.type = "integrated-mesh", this.nodePages = null, this.materialDefinitions = null, this.textureSetDefinitions = null, this.geometryDefinitions = null, this.serviceUpdateTimeStamp = null, this.profile = "mesh-pyramids", this.modifications = null, this._modificationsSource = null, this.elevationInfo = null, this.path = null;
  }
  destroy() {
    this._handles.destroy();
  }
  initialize() {
    this._handles.add(a(() => this.modifications, "after-changes", () => this.modifications = this.modifications, U));
  }
  normalizeCtorArgs(e2, t5) {
    return "string" == typeof e2 ? { url: e2, ...t5 } : e2;
  }
  readModifications(e2, t5, r3) {
    this._modificationsSource = { url: c(e2, r3), context: r3 };
  }
  async load(e2) {
    return this.addResolvingPromise(this._doLoad(e2)), this;
  }
  async _doLoad(e2) {
    const t5 = q(e2, "signal");
    try {
      await this.loadFromPortal({ supportedTypes: ["Scene Service"] }, e2);
    } catch (r3) {
      w(r3);
    }
    if (await this._fetchService(t5), r(this._modificationsSource)) {
      const t6 = await l3.fromUrl(this._modificationsSource.url, this.spatialReference, e2);
      this.setAtOrigin("modifications", t6, this._modificationsSource.context.origin), this._modificationsSource = null;
    }
    await this._fetchIndexAndUpdateExtent(this.nodePages, t5);
  }
  beforeSave() {
    if (!t(this._modificationsSource))
      return this.load().then(() => {
      }, () => {
      });
  }
  async saveAs(e2, t5) {
    return this._debouncedSaveOperations(L.SAVE_AS, { ...t5, getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "integrated-mesh" }, e2);
  }
  async save() {
    const e2 = { getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "integrated-mesh" };
    return this._debouncedSaveOperations(L.SAVE, e2);
  }
  validateLayer(e2) {
    if (e2.layerType && "IntegratedMesh" !== e2.layerType)
      throw new s("integrated-mesh-layer:layer-type-not-supported", "IntegratedMeshLayer does not support this layer type", { layerType: e2.layerType });
    if (isNaN(this.version.major) || isNaN(this.version.minor))
      throw new s("layer:service-version-not-supported", "Service version is not supported.", { serviceVersion: this.version.versionString, supportedVersions: "1.x" });
    if (this.version.major > 1)
      throw new s("layer:service-version-too-new", "Service version is too new.", { serviceVersion: this.version.versionString, supportedVersions: "1.x" });
  }
  _getTypeKeywords() {
    return ["IntegratedMeshLayer"];
  }
};
e([y2({ type: String, readOnly: true })], b2.prototype, "geometryType", void 0), e([y2({ type: ["show", "hide"] })], b2.prototype, "listMode", void 0), e([y2({ type: ["IntegratedMeshLayer"] })], b2.prototype, "operationalLayerType", void 0), e([y2({ json: { read: false }, readOnly: true })], b2.prototype, "type", void 0), e([y2({ type: s2, readOnly: true })], b2.prototype, "nodePages", void 0), e([y2({ type: [l2], readOnly: true })], b2.prototype, "materialDefinitions", void 0), e([y2({ type: [u2], readOnly: true })], b2.prototype, "textureSetDefinitions", void 0), e([y2({ type: [m], readOnly: true })], b2.prototype, "geometryDefinitions", void 0), e([y2({ readOnly: true })], b2.prototype, "serviceUpdateTimeStamp", void 0), e([y2({ type: l3 }), g({ origins: ["web-scene", "portal-item"], type: "resource", prefix: "modifications" })], b2.prototype, "modifications", void 0), e([o(["web-scene", "portal-item"], "modifications")], b2.prototype, "readModifications", null), e([y2(d)], b2.prototype, "elevationInfo", void 0), e([y2({ type: String, json: { origins: { "web-scene": { read: true, write: true }, "portal-item": { read: true, write: true } }, read: false } })], b2.prototype, "path", void 0), b2 = e([n("esri.layers.IntegratedMeshLayer")], b2);
var A = b2;
export {
  A as default
};
//# sourceMappingURL=IntegratedMeshLayer-HQYHTO3W.js.map
