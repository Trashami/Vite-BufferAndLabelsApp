import {
  n as n2,
  s as s3
} from "./chunk-P53ZRUMX.js";
import {
  o as o4
} from "./chunk-WKJPACEU.js";
import "./chunk-OP2HNSVZ.js";
import {
  a,
  a2
} from "./chunk-GNLPM47O.js";
import {
  f as f3,
  t as t2,
  x as x4
} from "./chunk-UKETAWZI.js";
import "./chunk-HKYKZCGY.js";
import "./chunk-5MBCFCGH.js";
import {
  pt,
  rt
} from "./chunk-TJ2I6XQT.js";
import "./chunk-EDHROVWI.js";
import "./chunk-34YPGGJT.js";
import {
  v as v2
} from "./chunk-NCXAKZRR.js";
import "./chunk-DUCSW4OU.js";
import {
  f as f2
} from "./chunk-WVDA5Z37.js";
import {
  i
} from "./chunk-M3NPSHCI.js";
import {
  v as v3
} from "./chunk-SBKKCBDN.js";
import {
  c as c3,
  d
} from "./chunk-MLVV3H5S.js";
import "./chunk-A4HIS5ZJ.js";
import {
  K,
  x as x3
} from "./chunk-AMLHWG76.js";
import "./chunk-OFQYIOO7.js";
import {
  r as r2
} from "./chunk-ZJZBAYFU.js";
import {
  g
} from "./chunk-J5VTDQTQ.js";
import {
  x as x2
} from "./chunk-UK3I5WXR.js";
import "./chunk-GLGOVVCK.js";
import "./chunk-BUVDI6S7.js";
import "./chunk-GY2AJLN6.js";
import {
  o as o3
} from "./chunk-ZWUEORSX.js";
import {
  T
} from "./chunk-US2IWMHE.js";
import "./chunk-WJCI2CGX.js";
import {
  g as g2
} from "./chunk-J6LQZWZI.js";
import "./chunk-OD3FDQCI.js";
import "./chunk-J2PJNRU7.js";
import "./chunk-56SPM3WK.js";
import "./chunk-XMZAPOBR.js";
import "./chunk-BLJKKR5D.js";
import "./chunk-ZGNCYHMZ.js";
import "./chunk-X2S4RQJ4.js";
import "./chunk-FUPLN7UM.js";
import "./chunk-376OPXM4.js";
import "./chunk-DER356EU.js";
import "./chunk-MZIWIEIR.js";
import "./chunk-TQEOEDAZ.js";
import "./chunk-SHFHZMHO.js";
import "./chunk-NRP45AHD.js";
import "./chunk-IWQ7452U.js";
import "./chunk-NAN5J6QS.js";
import "./chunk-B4DKBAM3.js";
import "./chunk-6M2AHKYV.js";
import "./chunk-SZIJNKCV.js";
import {
  m as m2
} from "./chunk-6O43OEU5.js";
import "./chunk-J2K7ZDSV.js";
import "./chunk-2UML3WQZ.js";
import "./chunk-KXVMEIWT.js";
import "./chunk-UDND2Z3V.js";
import "./chunk-23Y3DIC6.js";
import "./chunk-JUVQV3R3.js";
import "./chunk-RAX2HD42.js";
import "./chunk-ZYRIJWLX.js";
import "./chunk-C5H57NTD.js";
import "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import "./chunk-YWAQYJRC.js";
import "./chunk-B356PXLT.js";
import {
  c as c2,
  v
} from "./chunk-EHPBHJYZ.js";
import "./chunk-3MNMDUQZ.js";
import {
  w2 as w
} from "./chunk-UWG37XSU.js";
import {
  k2 as k
} from "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import "./chunk-HLM6QCL2.js";
import "./chunk-RXYULINL.js";
import "./chunk-THVR7IAM.js";
import "./chunk-ZWJJTUFL.js";
import "./chunk-XQN7F674.js";
import {
  U
} from "./chunk-DMI7A7TC.js";
import {
  o as o2
} from "./chunk-ZHAW7FZS.js";
import {
  G,
  S,
  j,
  nt
} from "./chunk-KAN4HXCG.js";
import "./chunk-4FEGON7M.js";
import "./chunk-VWYWOOPX.js";
import {
  s as s2
} from "./chunk-M5VHU5LK.js";
import "./chunk-CXFRNDG4.js";
import "./chunk-7QMMKGW4.js";
import {
  e as e2,
  m,
  n2 as n,
  y
} from "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import {
  x,
  y as y2
} from "./chunk-MJXQTGI2.js";
import {
  s
} from "./chunk-LIZHLHNA.js";
import "./chunk-BTUHYGXO.js";
import "./chunk-UA3YPL2R.js";
import {
  has,
  o
} from "./chunk-HVKDYDPP.js";
import "./chunk-6QC7MLLS.js";
import {
  c,
  e,
  f,
  r,
  t
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/layers/graphics/assetEditingSupport.js
var E;
!function(E3) {
  E3[E3.PROJECT_VERTICES = 1] = "PROJECT_VERTICES";
}(E || (E = {}));

// node_modules/@arcgis/core/rest/query/operations/pbfJSONFeatureSet.js
function n3(e3, t3) {
  return t3;
}
function a3(e3, t3, r4, s8) {
  switch (r4) {
    case 0:
      return c4(e3, t3 + s8, 0);
    case 1:
      return "lowerLeft" === e3.originPosition ? c4(e3, t3 + s8, 1) : l(e3, t3 + s8, 1);
  }
}
function h(e3, t3, r4, s8) {
  return 2 === r4 ? c4(e3, t3, 2) : a3(e3, t3, r4, s8);
}
function u(e3, t3, r4, s8) {
  return 2 === r4 ? c4(e3, t3, 3) : a3(e3, t3, r4, s8);
}
function d2(e3, t3, r4, s8) {
  return 3 === r4 ? c4(e3, t3, 3) : h(e3, t3, r4, s8);
}
function c4({ translate: e3, scale: t3 }, r4, s8) {
  return e3[s8] + r4 * t3[s8];
}
function l({ translate: e3, scale: t3 }, r4, s8) {
  return e3[s8] - r4 * t3[s8];
}
var f4 = class {
  constructor(e3) {
    this._options = e3, this.geometryTypes = ["esriGeometryPoint", "esriGeometryMultipoint", "esriGeometryPolyline", "esriGeometryPolygon"], this._previousCoordinate = [0, 0], this._transform = null, this._applyTransform = n3, this._lengths = [], this._currentLengthIndex = 0, this._toAddInCurrentPath = 0, this._vertexDimension = 0, this._coordinateBuffer = null, this._coordinateBufferPtr = 0, this._attributesConstructor = class {
    };
  }
  createFeatureResult() {
    return { fields: [], features: [] };
  }
  finishFeatureResult(t3) {
    if (this._options.applyTransform && (t3.transform = null), this._attributesConstructor = class {
    }, this._coordinateBuffer = null, this._lengths.length = 0, !t3.hasZ)
      return;
    const r4 = o3(t3.geometryType, this._options.sourceSpatialReference, t3.spatialReference);
    if (!t(r4))
      for (const e3 of t3.features)
        r4(e3.geometry);
  }
  createSpatialReference() {
    return {};
  }
  addField(e3, r4) {
    const s8 = e3.fields;
    c(s8), s8.push(r4);
    const o6 = s8.map((e4) => e4.name);
    this._attributesConstructor = function() {
      for (const e4 of o6)
        this[e4] = null;
    };
  }
  addFeature(e3, t3) {
    e3.features.push(t3);
  }
  prepareFeatures(e3) {
    switch (this._transform = e3.transform, this._options.applyTransform && e3.transform && (this._applyTransform = this._deriveApplyTransform(e3)), this._vertexDimension = 2, e3.hasZ && this._vertexDimension++, e3.hasM && this._vertexDimension++, e3.geometryType) {
      case "esriGeometryPoint":
        this.addCoordinate = (e4, t3, r4) => this.addCoordinatePoint(e4, t3, r4), this.createGeometry = (e4) => this.createPointGeometry(e4);
        break;
      case "esriGeometryPolygon":
        this.addCoordinate = (e4, t3, r4) => this._addCoordinatePolygon(e4, t3, r4), this.createGeometry = (e4) => this._createPolygonGeometry(e4);
        break;
      case "esriGeometryPolyline":
        this.addCoordinate = (e4, t3, r4) => this._addCoordinatePolyline(e4, t3, r4), this.createGeometry = (e4) => this._createPolylineGeometry(e4);
        break;
      case "esriGeometryMultipoint":
        this.addCoordinate = (e4, t3, r4) => this._addCoordinateMultipoint(e4, t3, r4), this.createGeometry = (e4) => this._createMultipointGeometry(e4);
    }
  }
  createFeature() {
    return this._lengths.length = 0, this._currentLengthIndex = 0, this._previousCoordinate[0] = 0, this._previousCoordinate[1] = 0, this._coordinateBuffer = null, this._coordinateBufferPtr = 0, { attributes: new this._attributesConstructor() };
  }
  allocateCoordinates() {
  }
  addLength(e3, t3, r4) {
    0 === this._lengths.length && (this._toAddInCurrentPath = t3), this._lengths.push(t3);
  }
  addQueryGeometry(e3, t3) {
    const { queryGeometry: r4, queryGeometryType: s8 } = t3, n8 = pt(r4.clone(), r4, false, false, this._transform), a7 = rt(n8, s8, false, false);
    e3.queryGeometryType = s8, e3.queryGeometry = { ...a7 };
  }
  createPointGeometry(e3) {
    const t3 = { x: 0, y: 0, spatialReference: e3.spatialReference };
    return e3.hasZ && (t3.z = 0), e3.hasM && (t3.m = 0), t3;
  }
  addCoordinatePoint(e3, t3, s8) {
    const o6 = f(this._transform, "transform");
    switch (t3 = this._applyTransform(o6, t3, s8, 0), s8) {
      case 0:
        e3.x = t3;
        break;
      case 1:
        e3.y = t3;
        break;
      case 2:
        "z" in e3 ? e3.z = t3 : e3.m = t3;
        break;
      case 3:
        e3.m = t3;
    }
  }
  _transformPathLikeValue(e3, t3) {
    let s8 = 0;
    t3 <= 1 && (s8 = this._previousCoordinate[t3], this._previousCoordinate[t3] += e3);
    const o6 = f(this._transform, "transform");
    return this._applyTransform(o6, e3, t3, s8);
  }
  _addCoordinatePolyline(e3, t3, r4) {
    this._dehydratedAddPointsCoordinate(e3.paths, t3, r4);
  }
  _addCoordinatePolygon(e3, t3, r4) {
    this._dehydratedAddPointsCoordinate(e3.rings, t3, r4);
  }
  _addCoordinateMultipoint(e3, t3, r4) {
    0 === r4 && e3.points.push([]);
    const s8 = this._transformPathLikeValue(t3, r4);
    e3.points[e3.points.length - 1].push(s8);
  }
  _createPolygonGeometry(e3) {
    return { rings: [[]], spatialReference: e3.spatialReference, hasZ: !!e3.hasZ, hasM: !!e3.hasM };
  }
  _createPolylineGeometry(e3) {
    return { paths: [[]], spatialReference: e3.spatialReference, hasZ: !!e3.hasZ, hasM: !!e3.hasM };
  }
  _createMultipointGeometry(e3) {
    return { points: [], spatialReference: e3.spatialReference, hasZ: !!e3.hasZ, hasM: !!e3.hasM };
  }
  _dehydratedAddPointsCoordinate(e3, t3, r4) {
    0 === r4 && 0 == this._toAddInCurrentPath-- && (e3.push([]), this._toAddInCurrentPath = this._lengths[++this._currentLengthIndex] - 1, this._previousCoordinate[0] = 0, this._previousCoordinate[1] = 0);
    const s8 = this._transformPathLikeValue(t3, r4), o6 = e3[e3.length - 1];
    0 === r4 && (this._coordinateBufferPtr = 0, this._coordinateBuffer = new Array(this._vertexDimension), o6.push(this._coordinateBuffer)), this._coordinateBuffer[this._coordinateBufferPtr++] = s8;
  }
  _deriveApplyTransform(e3) {
    const { hasZ: t3, hasM: r4 } = e3;
    return t3 && r4 ? d2 : t3 ? h : r4 ? u : a3;
  }
};

// node_modules/@arcgis/core/rest/query/executeQueryPBF.js
async function n4(o6, s8, n8) {
  const p3 = f2(o6), i3 = { ...n8 }, u3 = x3.from(s8), m6 = !u3.quantizationParameters, { data: f5 } = await f3(p3, u3, new f4({ sourceSpatialReference: u3.sourceSpatialReference, applyTransform: m6 }), i3);
  return f5;
}

// node_modules/@arcgis/core/rest/query/operations/queryAttachments.js
function n5(t3) {
  const o6 = t3.toJSON();
  return o6.attachmentTypes && (o6.attachmentTypes = o6.attachmentTypes.join(",")), o6.keywords && (o6.keywords = o6.keywords.join(",")), o6.globalIds && (o6.globalIds = o6.globalIds.join(",")), o6.objectIds && (o6.objectIds = o6.objectIds.join(",")), o6.size && (o6.size = o6.size.join(",")), o6;
}
function a4(o6, r4) {
  const n8 = {};
  for (const a7 of o6) {
    const { parentObjectId: o7, parentGlobalId: c7, attachmentInfos: i3 } = a7;
    for (const a8 of i3) {
      const { id: i4 } = a8, m6 = S(o2(`${r4}/${o7}/attachments/${i4}`)), p3 = a2.fromJSON(a8);
      p3.set({ url: m6, parentObjectId: o7, parentGlobalId: c7 }), n8[o7] ? n8[o7].push(p3) : n8[o7] = [p3];
    }
  }
  return n8;
}
function c5(t3, e3, s8) {
  let a7 = { query: t2({ ...t3.query, f: "json", ...n5(e3) }) };
  return s8 && (a7 = { ...s8, ...a7, query: { ...s8.query, ...a7.query } }), U(t3.path + "/queryAttachments", a7);
}

// node_modules/@arcgis/core/rest/query/executeAttachmentQuery.js
async function a5(a7, m6, n8) {
  const s8 = f2(a7);
  return c5(s8, c3.from(m6), { ...n8 }).then((t3) => a4(t3.data.attachmentGroups, s8.path));
}

// node_modules/@arcgis/core/rest/query/executeForExtent.js
async function m3(m6, n8, s8) {
  const p3 = f2(m6);
  return x4(p3, x3.from(n8), { ...s8 }).then((t3) => ({ count: t3.data.count, extent: w.fromJSON(t3.data.extent) }));
}

// node_modules/@arcgis/core/rest/query/operations/queryRelatedRecords.js
function o5(e3, t3) {
  const o6 = e3.toJSON();
  return o6.objectIds && (o6.objectIds = o6.objectIds.join(",")), o6.orderByFields && (o6.orderByFields = o6.orderByFields.join(",")), o6.outFields && !(t3 == null ? void 0 : t3.returnCountOnly) ? o6.outFields.includes("*") ? o6.outFields = "*" : o6.outFields = o6.outFields.join(",") : delete o6.outFields, o6.outSpatialReference && (o6.outSR = o6.outSR.wkid || JSON.stringify(o6.outSR.toJSON()), delete o6.outSpatialReference), o6.dynamicDataSource && (o6.layer = JSON.stringify({ source: o6.dynamicDataSource }), delete o6.dynamicDataSource), o6;
}
async function r3(e3, t3, o6) {
  const r4 = await s4(e3, t3, o6), n8 = r4.data, a7 = n8.geometryType, d4 = n8.spatialReference, c7 = {};
  for (const s8 of n8.relatedRecordGroups) {
    const e4 = { fields: void 0, objectIdFieldName: void 0, geometryType: a7, spatialReference: d4, hasZ: !!n8.hasZ, hasM: !!n8.hasM, features: s8.relatedRecords };
    if (null != s8.objectId)
      c7[s8.objectId] = e4;
    else
      for (const t4 in s8)
        s8.hasOwnProperty(t4) && "relatedRecords" !== t4 && (c7[s8[t4]] = e4);
  }
  return { ...r4, data: c7 };
}
async function n6(e3, t3, o6) {
  const r4 = await s4(e3, t3, o6, { returnCountOnly: true }), n8 = r4.data, a7 = {};
  for (const s8 of n8.relatedRecordGroups)
    null != s8.objectId && (a7[s8.objectId] = s8.count);
  return { ...r4, data: a7 };
}
async function s4(r4, n8, s8 = {}, a7) {
  const d4 = t2({ ...r4.query, f: "json", ...a7, ...o5(n8, a7) });
  return U(r4.path + "/queryRelatedRecords", { ...s8, query: { ...s8.query, ...d4 } });
}

// node_modules/@arcgis/core/rest/query/executeRelationshipQuery.js
async function n7(e3, n8, u3) {
  n8 = d.from(n8);
  const a7 = f2(e3);
  return r3(a7, n8, u3).then((t3) => {
    const r4 = t3.data, e4 = {};
    return Object.keys(r4).forEach((t4) => e4[t4] = x2.fromJSON(r4[t4])), e4;
  });
}
async function u2(r4, o6, n8) {
  o6 = d.from(o6);
  const u3 = f2(r4);
  return n6(u3, o6, { ...n8 }).then((t3) => t3.data);
}

// node_modules/@arcgis/core/rest/query/operations/queryTopFeatures.js
var l2 = "Layer does not support extent calculation.";
function y3(t3, r4) {
  var _a, _b;
  const o6 = t3.geometry, i3 = t3.toJSON(), s8 = i3;
  if (r(o6) && (s8.geometry = JSON.stringify(o6), s8.geometryType = c2(o6), s8.inSR = o6.spatialReference.wkid || JSON.stringify(o6.spatialReference)), ((_a = i3.topFilter) == null ? void 0 : _a.groupByFields) && (s8.topFilter.groupByFields = i3.topFilter.groupByFields.join(",")), ((_b = i3.topFilter) == null ? void 0 : _b.orderByFields) && (s8.topFilter.orderByFields = i3.topFilter.orderByFields.join(",")), i3.topFilter && (s8.topFilter = JSON.stringify(s8.topFilter)), i3.objectIds && (s8.objectIds = i3.objectIds.join(",")), i3.orderByFields && (s8.orderByFields = i3.orderByFields.join(",")), i3.outFields && !((r4 == null ? void 0 : r4.returnCountOnly) || (r4 == null ? void 0 : r4.returnExtentOnly) || (r4 == null ? void 0 : r4.returnIdsOnly)) ? i3.outFields.includes("*") ? s8.outFields = "*" : s8.outFields = i3.outFields.join(",") : delete s8.outFields, i3.outSR ? s8.outSR = i3.outSR.wkid || JSON.stringify(i3.outSR) : o6 && i3.returnGeometry && (s8.outSR = s8.inSR), i3.returnGeometry && delete i3.returnGeometry, i3.timeExtent) {
    const t4 = i3.timeExtent, { start: e3, end: r5 } = t4;
    null == e3 && null == r5 || (s8.time = e3 === r5 ? e3 : `${e3 != null ? e3 : "null"},${r5 != null ? r5 : "null"}`), delete i3.timeExtent;
  }
  return s8;
}
async function d3(t3, e3, r4, o6) {
  const n8 = await c6(t3, e3, "json", o6);
  return r2(e3, r4, n8.data), n8;
}
async function m4(t3, r4, o6) {
  return r(r4.timeExtent) && r4.timeExtent.isEmpty ? { data: { objectIds: [] } } : c6(t3, r4, "json", o6, { returnIdsOnly: true });
}
async function p(t3, r4, o6) {
  return r(r4.timeExtent) && r4.timeExtent.isEmpty ? { data: { count: 0, extent: null } } : c6(t3, r4, "json", o6, { returnExtentOnly: true, returnCountOnly: true }).then((t4) => {
    const e3 = t4.data;
    if (e3.hasOwnProperty("extent"))
      return t4;
    if (e3.features)
      throw new Error(l2);
    if (e3.hasOwnProperty("count"))
      throw new Error(l2);
    return t4;
  });
}
function a6(t3, r4, o6) {
  return r(r4.timeExtent) && r4.timeExtent.isEmpty ? Promise.resolve({ data: { count: 0 } }) : c6(t3, r4, "json", o6, { returnIdsOnly: true, returnCountOnly: true });
}
function c6(n8, u3, l3, d4 = {}, m6 = {}) {
  const p3 = "string" == typeof n8 ? j(n8) : n8, a7 = u3.geometry ? [u3.geometry] : [];
  return d4.responseType = "pbf" === l3 ? "array-buffer" : "json", v2(a7, null, d4).then((r4) => {
    const n9 = r4 && r4[0];
    r(n9) && ((u3 = u3.clone()).geometry = n9);
    const i3 = t2({ ...p3.query, f: l3, ...m6, ...y3(u3, m6) });
    return U(G(p3.path, "queryTopFeatures"), { ...d4, query: { ...i3, ...d4.query } });
  });
}

// node_modules/@arcgis/core/rest/query/executeTopFeaturesQuery.js
async function s5(s8, p3, u3, a7) {
  const m6 = f2(s8), i3 = { ...a7 }, { data: f5 } = await d3(m6, v3.from(p3), u3, i3);
  return x2.fromJSON(f5);
}

// node_modules/@arcgis/core/rest/query/executeForTopIds.js
async function s6(s8, e3, p3) {
  const a7 = f2(s8);
  return (await m4(a7, v3.from(e3), { ...p3 })).data.objectIds;
}

// node_modules/@arcgis/core/rest/query/executeForTopExtents.js
async function m5(m6, s8, n8) {
  const p3 = f2(m6), a7 = await p(p3, v3.from(s8), { ...n8 });
  return { count: a7.data.count, extent: w.fromJSON(a7.data.extent) };
}

// node_modules/@arcgis/core/rest/query/executeForTopCount.js
async function s7(s8, e3, p3) {
  const u3 = f2(s8);
  return (await a6(u3, v3.from(e3), { ...p3 })).data.count;
}

// node_modules/@arcgis/core/tasks/Task.js
var i2 = class extends m {
  constructor(...r4) {
    super(...r4), this.requestOptions = null, this.url = null;
  }
  normalizeCtorArgs(r4, s8) {
    return "string" != typeof r4 ? r4 : { url: r4, ...s8 };
  }
  get parsedUrl() {
    return this._parseUrl(this.url);
  }
  _parseUrl(r4) {
    return j(r4);
  }
  _encode(r4, s8, t3) {
    const e3 = {};
    for (const o6 in r4) {
      if ("declaredClass" === o6)
        continue;
      const i3 = r4[o6];
      if (null != i3 && "function" != typeof i3)
        if (Array.isArray(i3)) {
          e3[o6] = [];
          for (let r5 = 0; r5 < i3.length; r5++)
            e3[o6][r5] = this._encode(i3[r5]);
        } else if ("object" == typeof i3)
          if (i3.toJSON) {
            const r5 = i3.toJSON(t3 && t3[o6]);
            e3[o6] = s8 ? r5 : JSON.stringify(r5);
          } else
            e3[o6] = s8 ? i3 : JSON.stringify(i3);
        else
          e3[o6] = i3;
    }
    return e3;
  }
};
e2([y({ readOnly: true })], i2.prototype, "parsedUrl", null), e2([y()], i2.prototype, "requestOptions", void 0), e2([y({ type: String })], i2.prototype, "url", void 0), i2 = e2([n("esri.tasks.Task")], i2);
var p2 = i2;

// node_modules/@arcgis/core/layers/graphics/sources/support/QueryTask.js
var q = class extends p2 {
  constructor(t3) {
    super(t3), this.dynamicDataSource = null, this.fieldsIndex = null, this.format = "json", this.gdbVersion = null, this.infoFor3D = null, this.sourceSpatialReference = null;
  }
  async execute(t3, e3) {
    const r4 = await this.executeJSON(t3, e3);
    return this.featureSetFromJSON(t3, r4, e3);
  }
  async executeJSON(t3, e3) {
    var _a;
    const r4 = { ...this.requestOptions, ...e3 }, o6 = this._normalizeQuery(t3), s8 = null != ((_a = t3.outStatistics) == null ? void 0 : _a[0]), i3 = has("featurelayer-pbf-statistics"), u3 = !s8 || i3;
    let n8;
    if ("pbf" === this.format && u3)
      try {
        n8 = await n4(this.url, o6, r4);
      } catch (p3) {
        if ("query:parsing-pbf" !== p3.name)
          throw p3;
        this.format = "json";
      }
    return "json" !== this.format && u3 || (n8 = await a(this.url, o6, r4)), this._normalizeFields(n8.fields), n8;
  }
  async featureSetFromJSON(t3, e3, o6) {
    if (!this._queryIs3DObjectFormat(t3) || t(this.infoFor3D) || !e3.assetMaps || !e3.features || !e3.features.length)
      return x2.fromJSON(e3);
    const { meshFeatureSetFromJSON: i3 } = await y2(import("./meshFeatureSet-27B4YK23.js"), o6);
    return i3(t3, this.infoFor3D, e3);
  }
  executeForCount(t3, e3) {
    const r4 = { ...this.requestOptions, ...e3 }, o6 = this._normalizeQuery(t3);
    return n2(this.url, o6, r4);
  }
  executeForExtent(t3, e3) {
    const r4 = { ...this.requestOptions, ...e3 }, o6 = this._normalizeQuery(t3);
    return m3(this.url, o6, r4);
  }
  executeForIds(t3, e3) {
    const r4 = { ...this.requestOptions, ...e3 }, o6 = this._normalizeQuery(t3);
    return s3(this.url, o6, r4);
  }
  executeRelationshipQuery(t3, e3) {
    t3 = d.from(t3);
    const r4 = { ...this.requestOptions, ...e3 };
    return (this.gdbVersion || this.dynamicDataSource) && ((t3 = t3.clone()).gdbVersion = t3.gdbVersion || this.gdbVersion, t3.dynamicDataSource = t3.dynamicDataSource || this.dynamicDataSource), n7(this.url, t3, r4);
  }
  executeRelationshipQueryForCount(t3, e3) {
    t3 = d.from(t3);
    const r4 = { ...this.requestOptions, ...e3 };
    return (this.gdbVersion || this.dynamicDataSource) && ((t3 = t3.clone()).gdbVersion = t3.gdbVersion || this.gdbVersion, t3.dynamicDataSource = t3.dynamicDataSource || this.dynamicDataSource), u2(this.url, t3, r4);
  }
  executeAttachmentQuery(t3, e3) {
    const r4 = { ...this.requestOptions, ...e3 };
    return a5(this.url, t3, r4);
  }
  executeTopFeaturesQuery(t3, e3) {
    const r4 = { ...this.requestOptions, ...e3 };
    return s5(this.parsedUrl, t3, this.sourceSpatialReference, r4);
  }
  executeForTopIds(t3, e3) {
    const r4 = { ...this.requestOptions, ...e3 };
    return s6(this.parsedUrl, t3, r4);
  }
  executeForTopExtents(t3, e3) {
    const r4 = { ...this.requestOptions, ...e3 };
    return m5(this.parsedUrl, t3, r4);
  }
  executeForTopCount(t3, e3) {
    const r4 = { ...this.requestOptions, ...e3 };
    return s7(this.parsedUrl, t3, r4);
  }
  _normalizeQuery(t3) {
    let s8 = x3.from(t3);
    if (s8.sourceSpatialReference = s8.sourceSpatialReference || this.sourceSpatialReference, (this.gdbVersion || this.dynamicDataSource) && (s8 = s8 === t3 ? s8.clone() : s8, s8.gdbVersion = t3.gdbVersion || this.gdbVersion, s8.dynamicDataSource = t3.dynamicDataSource ? K.from(t3.dynamicDataSource) : this.dynamicDataSource), r(this.infoFor3D) && this._queryIs3DObjectFormat(t3)) {
      s8 = s8 === t3 ? s8.clone() : s8, s8.formatOf3DObjects = null;
      for (const t4 of this.infoFor3D.queryFormats) {
        if ("3D_glb" === t4) {
          s8.formatOf3DObjects = t4;
          break;
        }
        "3D_gltf" !== t4 || s8.formatOf3DObjects || (s8.formatOf3DObjects = t4);
      }
      if (!s8.formatOf3DObjects)
        throw new s("query:unsupported-3d-query-formats", "Could not find any supported 3D object query format. Only supported formats are 3D_glb and 3D_gltf");
      if (t(s8.outFields) || !s8.outFields.includes("*")) {
        s8 = s8 === t3 ? s8.clone() : s8, t(s8.outFields) && (s8.outFields = []);
        const { originX: e3, originY: o6, originZ: i3, translationX: u3, translationY: n8, translationZ: a7, scaleX: c7, scaleY: p3, scaleZ: m6, rotationX: f5, rotationY: l3, rotationZ: h2, rotationDeg: d4 } = this.infoFor3D.transformFieldRoles;
        s8.outFields.push(e3, o6, i3, u3, n8, a7, c7, p3, m6, f5, l3, h2, d4);
      }
    }
    return s8;
  }
  _normalizeFields(t3) {
    if (r(this.fieldsIndex) && r(t3))
      for (const e3 of t3) {
        const t4 = this.fieldsIndex.get(e3.name);
        t4 && Object.assign(e3, t4.toJSON());
      }
  }
  _queryIs3DObjectFormat(t3) {
    return r(this.infoFor3D) && t3.returnGeometry && "xyFootprint" !== t3.multipatchOption && !t3.outStatistics;
  }
};
e2([y({ type: K })], q.prototype, "dynamicDataSource", void 0), e2([y()], q.prototype, "fieldsIndex", void 0), e2([y()], q.prototype, "format", void 0), e2([y()], q.prototype, "gdbVersion", void 0), e2([y()], q.prototype, "infoFor3D", void 0), e2([y()], q.prototype, "sourceSpatialReference", void 0), q = e2([n("esri.tasks.QueryTask")], q);
var g3 = q;

// node_modules/@arcgis/core/layers/graphics/sources/FeatureLayerSource.js
var O = new s2({ originalAndCurrentFeatures: "original-and-current-features", none: "none" });
async function E2(e3) {
  if ("string" == typeof e3) {
    const t3 = nt(e3);
    return t3 || { data: e3 };
  }
  return new Promise((t3, s8) => {
    const a7 = new FileReader();
    a7.readAsDataURL(e3), a7.onload = () => t3(nt(a7.result)), a7.onerror = (e4) => s8(e4);
  });
}
var S2 = /* @__PURE__ */ new Set(["Feature Layer", "Table"]);
var j2 = new s2({ Started: "published", Publishing: "publishing", Stopped: "unavailable" });
var T2 = class extends m2 {
  constructor() {
    super(...arguments), this.type = "feature-layer", this.refresh = x(async () => {
      var _a, _b;
      await this.load();
      const e3 = (_a = this.sourceJSON.editingInfo) == null ? void 0 : _a.lastEditDate;
      if (null == e3)
        return { dataChanged: true, updates: {} };
      try {
        await this._fetchService(null);
      } catch {
        return { dataChanged: true, updates: {} };
      }
      const t3 = e3 !== ((_b = this.sourceJSON.editingInfo) == null ? void 0 : _b.lastEditDate);
      return { dataChanged: t3, updates: t3 ? { editingInfo: this.sourceJSON.editingInfo, extent: this.sourceJSON.extent } : null };
    });
  }
  load(e3) {
    const t3 = r(e3) ? e3.signal : null;
    return this.addResolvingPromise(this._fetchService(this.layer.sourceJSON, t3)), Promise.resolve(this);
  }
  get queryTask() {
    const { capabilities: { query: { supportsFormatPBF: e3 } }, parsedUrl: t3, dynamicDataSource: s8, infoFor3D: a7, gdbVersion: r4, spatialReference: o6, fieldsIndex: i3 } = this.layer, n8 = has("featurelayer-pbf") && e3 && t(a7) ? "pbf" : "json";
    return new g3({ url: t3.path, format: n8, fieldsIndex: i3, infoFor3D: a7, dynamicDataSource: s8, gdbVersion: r4, sourceSpatialReference: o6 });
  }
  async addAttachment(e3, t3) {
    await this.load();
    const a7 = e3.attributes[this.layer.objectIdField], r4 = this.layer.parsedUrl.path + "/" + a7 + "/addAttachment", o6 = this._getLayerRequestOptions(), i3 = this._getFormDataForAttachment(t3, o6.query);
    try {
      const e4 = await U(r4, { body: i3 });
      return this._createFeatureEditResult(e4.data.addAttachmentResult);
    } catch (n8) {
      throw this._createAttachmentErrorResult(a7, n8);
    }
  }
  async updateAttachment(e3, t3, a7) {
    await this.load();
    const r4 = e3.attributes[this.layer.objectIdField], o6 = this.layer.parsedUrl.path + "/" + r4 + "/updateAttachment", i3 = this._getLayerRequestOptions({ query: { attachmentId: t3 } }), n8 = this._getFormDataForAttachment(a7, i3.query);
    try {
      const e4 = await U(o6, { body: n8 });
      return this._createFeatureEditResult(e4.data.updateAttachmentResult);
    } catch (u3) {
      throw this._createAttachmentErrorResult(r4, u3);
    }
  }
  async applyEdits(e3, t3) {
    await this.load();
    const a7 = this.layer.infoFor3D, r4 = r(a7), o6 = r4 || (t3 == null ? void 0 : t3.globalIdUsed), i3 = e3.addFeatures.map((e4) => this._serializeFeature(e4, a7)), u3 = e3.updateFeatures.map((e4) => this._serializeFeature(e4, a7)), d4 = this._getFeatureIds(e3.deleteFeatures, o6);
    i(i3, u3, this.layer.spatialReference);
    const c7 = [], p3 = [], h2 = [...e3.deleteAttachments];
    for (const s8 of e3.addAttachments)
      c7.push(await this._serializeAttachment(s8));
    for (const s8 of e3.updateAttachments)
      p3.push(await this._serializeAttachment(s8));
    const y4 = c7.length || p3.length || h2.length ? { adds: c7, updates: p3, deletes: h2 } : null;
    let m6, f5 = null;
    if (r4) {
      f5 = /* @__PURE__ */ new Map();
      const t4 = [];
      for (const a8 of e3.addAssets)
        t4.push(this._serializeAssetMapEditAndUploadAssets(a8, f5));
      const s8 = await Promise.all(t4);
      m6 = s8.length ? { adds: s8, updates: [], deletes: [] } : void 0;
    }
    const g4 = { gdbVersion: (t3 == null ? void 0 : t3.gdbVersion) || this.layer.gdbVersion, rollbackOnFailure: t3 == null ? void 0 : t3.rollbackOnFailureEnabled, useGlobalIds: o6, returnEditMoment: t3 == null ? void 0 : t3.returnEditMoment, usePreviousEditMoment: t3 == null ? void 0 : t3.usePreviousEditMoment, sessionId: t3 == null ? void 0 : t3.sessionId };
    (t3 == null ? void 0 : t3.returnServiceEditsOption) ? (g4.edits = JSON.stringify([{ id: this.layer.layerId, adds: i3, updates: u3, deletes: d4, attachments: y4, assetMaps: e(m6) }]), g4.returnServiceEditsOption = O.toJSON(t3 == null ? void 0 : t3.returnServiceEditsOption), g4.returnServiceEditsInSourceSR = t3 == null ? void 0 : t3.returnServiceEditsInSourceSR) : (g4.adds = i3.length ? JSON.stringify(i3) : null, g4.updates = u3.length ? JSON.stringify(u3) : null, g4.deletes = d4.length ? o6 ? JSON.stringify(d4) : d4.join(",") : null, g4.attachments = y4 && JSON.stringify(y4), g4.assetMaps = r(m6) ? JSON.stringify(m6) : void 0);
    const R = this._getLayerRequestOptions({ method: "post", query: g4 }), F = (t3 == null ? void 0 : t3.returnServiceEditsOption) ? this.layer.url : this.layer.parsedUrl.path, b = await U(F + "/applyEdits", R);
    if (r4 && null != b.data && null != b.data.assetMaps) {
      const e4 = b.data, t4 = this.layer.objectIdField, a8 = [];
      for (const s8 of e4.addResults)
        s8.success && a8.push(s8.objectId);
      for (const s8 of e4.updateResults)
        s8.success && a8.push(s8.objectId);
      const r5 = this._createRequestQueryOptions(), o7 = await U(F + "/query", { ...r5, query: { f: "json", formatOf3DObjects: "3D_glb", where: `OBJECTID IN (${a8.join(",")})`, outFields: `${t4}` } });
      if (o7 && o7.data && o7.data.assetMaps && r(f5)) {
        const e5 = o7.data.assetMaps;
        for (const t5 of e5) {
          const e6 = f5.get(t5.parentGlobalId).geometry;
          r(e6) && "mesh" === e6.type && e6.updateExternalSource({ source: [{ name: t5.assetName, source: t5.assetName }], extent: e6.extent });
        }
      }
    }
    return this._createEditsResult(b);
  }
  async deleteAttachments(e3, t3) {
    await this.load();
    const a7 = e3.attributes[this.layer.objectIdField], r4 = this.layer.parsedUrl.path + "/" + a7 + "/deleteAttachments";
    try {
      return (await U(r4, this._getLayerRequestOptions({ query: { attachmentIds: t3.join(",") }, method: "post" }))).data.deleteAttachmentResults.map(this._createFeatureEditResult);
    } catch (o6) {
      throw this._createAttachmentErrorResult(a7, o6);
    }
  }
  fetchRecomputedExtents(e3 = {}) {
    const t3 = e3.signal;
    return this.load({ signal: t3 }).then(async () => {
      const t4 = this._getLayerRequestOptions({ ...e3, query: { returnUpdates: true } }), { layerId: r4, url: o6 } = this.layer, { data: i3 } = await U(`${o6}/${r4}`, t4), { id: n8, extent: u3, fullExtent: l3, timeExtent: d4 } = i3, c7 = u3 || l3;
      return { id: n8, fullExtent: c7 && w.fromJSON(c7), timeExtent: d4 && T.fromJSON({ start: d4[0], end: d4[1] }) };
    });
  }
  async queryAttachments(e3, t3 = {}) {
    const { parsedUrl: a7 } = this.layer, r4 = a7.path;
    await this.load();
    const o6 = this._getLayerRequestOptions(t3);
    if (!this.layer.get("capabilities.operations.supportsQueryAttachments")) {
      const { objectIds: t4 } = e3, a8 = [];
      for (const e4 of t4) {
        const t5 = r4 + "/" + e4 + "/attachments";
        a8.push(U(t5, o6));
      }
      return Promise.all(a8).then((e4) => t4.map((t5, s8) => ({ parentObjectId: t5, attachmentInfos: e4[s8].data.attachmentInfos }))).then((e4) => a4(e4, r4));
    }
    return this.queryTask.executeAttachmentQuery(e3, o6);
  }
  async queryFeatures(e3, t3) {
    return await this.load(), this.queryTask.execute(e3, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryFeaturesJSON(e3, t3) {
    return await this.load(), this.queryTask.executeJSON(e3, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryObjectIds(e3, t3) {
    return await this.load(), this.queryTask.executeForIds(e3, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryFeatureCount(e3, t3) {
    return await this.load(), this.queryTask.executeForCount(e3, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryExtent(e3, t3) {
    return await this.load(), this.queryTask.executeForExtent(e3, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryRelatedFeatures(e3, t3) {
    return await this.load(), this.queryTask.executeRelationshipQuery(e3, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryRelatedFeaturesCount(e3, t3) {
    return await this.load(), this.queryTask.executeRelationshipQueryForCount(e3, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryTopFeatures(e3, t3) {
    return await this.load(), this.queryTask.executeTopFeaturesQuery(e3, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryTopObjectIds(e3, t3) {
    return await this.load(), this.queryTask.executeForTopIds(e3, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryTopExtents(e3, t3) {
    return await this.load(), this.queryTask.executeForTopExtents(e3, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryTopCount(e3, t3) {
    return await this.load(), this.queryTask.executeForTopCount(e3, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async fetchPublishingStatus() {
    if (!g(this.layer.url))
      return "unavailable";
    const e3 = G(this.layer.url, "status"), t3 = await U(e3, { query: { f: "json" } });
    return j2.fromJSON(t3.data.status);
  }
  _createRequestQueryOptions(e3) {
    const t3 = { ...this.layer.customParameters, token: this.layer.apiKey, ...e3 == null ? void 0 : e3.query };
    return this.layer.datesInUnknownTimezone && (t3.timeReferenceUnknownClient = true), t3;
  }
  async _fetchService(e3, t3) {
    if (!e3) {
      const { data: a8 } = await U(this.layer.parsedUrl.path, this._getLayerRequestOptions({ query: has("featurelayer-advanced-symbols") ? { returnAdvancedSymbols: true } : {}, signal: t3 }));
      e3 = a8;
    }
    this.sourceJSON = this._patchServiceJSON(e3);
    const a7 = e3.type;
    if (!S2.has(a7))
      throw new s("feature-layer-source:unsupported-type", `Source type "${a7}" is not supported`);
  }
  _patchServiceJSON(e3) {
    var _a;
    if ("Table" !== e3.type && e3.geometryType && !((_a = e3 == null ? void 0 : e3.drawingInfo) == null ? void 0 : _a.renderer) && !e3.defaultSymbol) {
      const t3 = o4(e3.geometryType).renderer;
      o("drawingInfo.renderer", t3, e3);
    }
    return "esriGeometryMultiPatch" === e3.geometryType && e3.infoFor3D && (e3.geometryType = "mesh"), e3;
  }
  _serializeFeature(e3, t3) {
    const { geometry: s8, attributes: a7 } = e3;
    if (r(t3) && r(e3.geometry) && "mesh" === e3.geometry.type) {
      const s9 = { ...a7 }, r4 = e3.geometry, o6 = r4.origin, i3 = r4.transform;
      if (s9[t3.transformFieldRoles.originX] = o6.x, s9[t3.transformFieldRoles.originY] = o6.y, s9[t3.transformFieldRoles.originZ] = o6.z, r(i3)) {
        const e4 = i3.translation, a8 = i3.scale, r5 = i3.rotation;
        s9[t3.transformFieldRoles.translationX] = e4[0], s9[t3.transformFieldRoles.translationY] = e4[1], s9[t3.transformFieldRoles.translationZ] = e4[2], s9[t3.transformFieldRoles.scaleX] = a8[0], s9[t3.transformFieldRoles.scaleY] = a8[1], s9[t3.transformFieldRoles.scaleZ] = a8[2], s9[t3.transformFieldRoles.rotationX] = r5[0], s9[t3.transformFieldRoles.rotationY] = r5[1], s9[t3.transformFieldRoles.rotationZ] = r5[2], s9[t3.transformFieldRoles.rotationDeg] = r5[3];
      }
      return { geometry: null, attributes: s9 };
    }
    return t(s8) ? { attributes: a7 } : "mesh" === s8.type || "extent" === s8.type ? null : { geometry: s8.toJSON(), attributes: a7 };
  }
  async _serializeAttachment(e3) {
    const { feature: t3, attachment: s8 } = e3, { globalId: a7, name: r4, contentType: o6, data: i3, uploadId: n8 } = s8, u3 = { globalId: a7, parentGlobalId: null, contentType: null, name: null, uploadId: null, data: null };
    if (t3 && (u3.parentGlobalId = "attributes" in t3 ? t3.attributes && t3.attributes[this.layer.globalIdField] : t3.globalId), n8)
      u3.uploadId = n8;
    else if (i3) {
      const e4 = await E2(i3);
      u3.contentType = e4.mediaType, u3.data = e4.data, i3 instanceof File && (u3.name = i3.name);
    }
    return r4 && (u3.name = r4), o6 && (u3.contentType = o6), u3;
  }
  async _serializeAssetMapEditAndUploadAssets(e3, t3) {
    const a7 = this.layer.url;
    let o6 = null;
    try {
      const t4 = new Blob([e3.data], { type: e3.mimeType }), i4 = new FormData();
      i4.append("f", "json"), i4.append("file", t4, `${e3.assetName}`);
      const n9 = { body: i4, method: "post", responseType: "json" }, { data: u3 } = await U(`${a7}/uploads/upload`, n9);
      if (!u3.success)
        throw new s("feature-layer-source:upload-failure", "Expected upload to be successfull.");
      o6 = { assetType: e3.assetType, assetUploadId: u3.item.itemID };
    } catch (h2) {
      o6 = null;
    }
    if (t(o6)) {
      const t4 = await E2(new Blob([e3.data]));
      if (!t4.isBase64)
        throw new s("feature-layer-source:uploadAssets-failure", "Expected gltf data in base64 format after conversion.");
      o6 = { assetType: e3.assetType, assetData: t4.data };
    }
    if (t(o6))
      throw new s("feature-layer-source:uploadAssets-failure", "Unable to prepare uploadAsset request options.");
    const i3 = { method: "post", query: { f: "json", assets: JSON.stringify([o6]) }, responseType: "json" }, n8 = await U(G(this.layer.parsedUrl.path, "uploadAssets"), i3);
    if (1 !== n8.data.uploadResults.length || !n8.data.uploadResults[0].success)
      throw new s("feature-layer-source:uploadAssets-failure", "Bad response.");
    const l3 = n8.data.uploadResults[0].assetHash, d4 = [];
    e3.flags & E.PROJECT_VERTICES && d4.push("PROJECT_VERTICES");
    const c7 = { globalId: e3.assetMapGlobalId, parentGlobalId: e3.featureGlobalId, assetName: e3.assetName, assetHash: l3, flags: d4 };
    return t3.set(e3.featureGlobalId, e3.feature), c7;
  }
  _getFeatureIds(e3, t3) {
    const s8 = e3[0];
    return s8 ? this._canUseGlobalIds(t3, e3) ? this._getGlobalIdsFromFeatureIdentifier(e3) : "objectId" in s8 ? this._getObjectIdsFromFeatureIdentifier(e3) : this._getIdsFromFeatures(e3) : [];
  }
  _getIdsFromFeatures(e3) {
    const t3 = this.layer.objectIdField;
    return e3.map((e4) => e4.attributes && e4.attributes[t3]);
  }
  _canUseGlobalIds(e3, t3) {
    return e3 && "globalId" in t3[0];
  }
  _getObjectIdsFromFeatureIdentifier(e3) {
    return e3.map((e4) => e4.objectId);
  }
  _getGlobalIdsFromFeatureIdentifier(e3) {
    return e3.map((e4) => e4.globalId);
  }
  _createEditsResult(e3) {
    const t3 = e3.data, { layerId: s8 } = this.layer, a7 = [];
    let r4 = null;
    if (Array.isArray(t3))
      for (const n8 of t3)
        a7.push({ id: n8.id, editedFeatures: n8.editedFeatures }), n8.id === s8 && (r4 = { addResults: n8.addResults, updateResults: n8.updateResults, deleteResults: n8.deleteResults, attachments: n8.attachments, editMoment: n8.editMoment });
    else
      r4 = t3;
    const o6 = r4 == null ? void 0 : r4.attachments, i3 = { addFeatureResults: r4.addResults ? r4.addResults.map(this._createFeatureEditResult, this) : [], updateFeatureResults: r4.updateResults ? r4.updateResults.map(this._createFeatureEditResult, this) : [], deleteFeatureResults: r4.deleteResults ? r4.deleteResults.map(this._createFeatureEditResult, this) : [], addAttachmentResults: o6 && o6.addResults ? o6.addResults.map(this._createFeatureEditResult, this) : [], updateAttachmentResults: o6 && o6.updateResults ? o6.updateResults.map(this._createFeatureEditResult, this) : [], deleteAttachmentResults: o6 && o6.deleteResults ? o6.deleteResults.map(this._createFeatureEditResult, this) : [] };
    if (r4.editMoment && (i3.editMoment = r4.editMoment), a7.length > 0) {
      i3.editedFeatureResults = [];
      for (const e4 of a7) {
        const { adds: t4, updates: s9, deletes: a8, spatialReference: r5 } = e4.editedFeatures, o7 = r5 ? new k(r5) : null;
        i3.editedFeatureResults.push({ layerId: e4.id, editedFeatures: { adds: (t4 == null ? void 0 : t4.map((e5) => this._createEditedFeature(e5, o7))) || [], updates: (s9 == null ? void 0 : s9.map((e5) => ({ original: this._createEditedFeature(e5[0], o7), current: this._createEditedFeature(e5[1], o7) }))) || [], deletes: (a8 == null ? void 0 : a8.map((e5) => this._createEditedFeature(e5, o7))) || [], spatialReference: o7 } });
      }
    }
    return i3;
  }
  _createEditedFeature(e3, s8) {
    return new g2({ attributes: e3.attributes, geometry: v({ ...e3.geometry, spatialReference: s8 }) });
  }
  _createFeatureEditResult(e3) {
    const t3 = true === e3.success ? null : e3.error || { code: void 0, description: void 0 };
    return { objectId: e3.objectId, globalId: e3.globalId, error: t3 ? new s("feature-layer-source:edit-failure", t3.description, { code: t3.code }) : null };
  }
  _createAttachmentErrorResult(e3, t3) {
    const s8 = t3.details.messages && t3.details.messages[0] || t3.message, a7 = t3.details.httpStatus || t3.details.messageCode;
    return { objectId: e3, globalId: null, error: new s("feature-layer-source:attachment-failure", s8, { code: a7 }) };
  }
  _getFormDataForAttachment(e3, t3) {
    const s8 = e3 instanceof FormData ? e3 : e3 && e3.elements ? new FormData(e3) : null;
    if (s8)
      for (const a7 in t3) {
        const e4 = t3[a7];
        null != e4 && (s8.set ? s8.set(a7, e4) : s8.append(a7, e4));
      }
    return s8;
  }
  _getLayerRequestOptions(e3 = {}) {
    const { parsedUrl: t3, gdbVersion: s8, dynamicDataSource: a7 } = this.layer;
    return { ...e3, query: { gdbVersion: s8, layer: a7 ? JSON.stringify({ source: a7 }) : void 0, ...t3.query, f: "json", ...this._createRequestQueryOptions(e3) }, responseType: "json" };
  }
};
e2([y()], T2.prototype, "type", void 0), e2([y({ constructOnly: true })], T2.prototype, "layer", void 0), e2([y({ readOnly: true })], T2.prototype, "queryTask", null), T2 = e2([n("esri.layers.graphics.sources.FeatureLayerSource")], T2);
var A = T2;
export {
  A as default
};
//# sourceMappingURL=FeatureLayerSource-KUKCXBFR.js.map
