import {
  o as o2
} from "./chunk-GQHKPMYA.js";
import "./chunk-YBAOLQVA.js";
import {
  D
} from "./chunk-PZ5MIROQ.js";
import {
  f as f2
} from "./chunk-DJMOV3FK.js";
import "./chunk-WWLBKNPY.js";
import "./chunk-ZNZ4EIIF.js";
import "./chunk-4OM3EX6P.js";
import {
  E
} from "./chunk-FCIHN4UG.js";
import "./chunk-RUM3DXFX.js";
import {
  h as h2
} from "./chunk-JLDKIFMH.js";
import "./chunk-X6GHUY4U.js";
import "./chunk-3OFVLRSL.js";
import "./chunk-XP6I2GEX.js";
import "./chunk-67RD6CZ4.js";
import "./chunk-XFDO4CMR.js";
import "./chunk-IVLBGTXL.js";
import "./chunk-GHN7C53L.js";
import {
  e as e2
} from "./chunk-VRX4W75V.js";
import "./chunk-2J2YGTXG.js";
import {
  E as E2
} from "./chunk-C6BDJNUQ.js";
import "./chunk-OJ2HHY2O.js";
import "./chunk-75RMBUYZ.js";
import "./chunk-ZEEU5HOK.js";
import "./chunk-NDQ5FHGV.js";
import "./chunk-ZL4T4NIV.js";
import "./chunk-NAKEKTIK.js";
import "./chunk-QWNKYSI4.js";
import "./chunk-FMJZBZWF.js";
import "./chunk-GOYVJTGW.js";
import "./chunk-ZPYDYUP5.js";
import "./chunk-QEYOWTXD.js";
import "./chunk-KDO6J2FO.js";
import "./chunk-RT3T2K4S.js";
import "./chunk-WJCI2CGX.js";
import {
  d
} from "./chunk-REIQNAQW.js";
import "./chunk-RAX2HD42.js";
import "./chunk-ZYRIJWLX.js";
import "./chunk-C5H57NTD.js";
import "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import {
  n
} from "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import "./chunk-HLM6QCL2.js";
import "./chunk-5NXILPDI.js";
import "./chunk-XQN7F674.js";
import "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import "./chunk-KAN4HXCG.js";
import "./chunk-4FEGON7M.js";
import "./chunk-M5VHU5LK.js";
import "./chunk-7QMMKGW4.js";
import {
  e,
  m,
  n2,
  t as t2,
  y
} from "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import {
  f,
  p as p2
} from "./chunk-MJXQTGI2.js";
import "./chunk-LIZHLHNA.js";
import "./chunk-BTUHYGXO.js";
import "./chunk-UA3YPL2R.js";
import "./chunk-HVKDYDPP.js";
import {
  s2 as s
} from "./chunk-6QC7MLLS.js";
import {
  h,
  o,
  p,
  r,
  t
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/edgeRendering/EdgeWorkerHandle.js
var n3 = class extends h2 {
  constructor(e3) {
    super("EdgeProcessingWorker", "extract", { extract: (e4) => [e4.dataBuffer], extractComponentsEdgeLocations: (e4) => [e4.dataBuffer], extractEdgeLocations: (e4) => [e4.dataBuffer] }, e3);
  }
  async process(e3, t3, r2) {
    if (r2)
      return f2(e3);
    const n4 = await this.invoke(new a(e3), t3);
    return this._unpackOutput(n4);
  }
  async extractEdgeLocations(e3, t3) {
    const s2 = await this.invokeMethod("extractEdgeLocations", new a(e3), t3);
    return D(s2);
  }
  async extractComponentsEdgeLocations(e3, t3) {
    const s2 = await this.invokeMethod("extractComponentsEdgeLocations", new a(e3), t3);
    return D(s2);
  }
  _unpackOutput(e3) {
    return { regular: { instancesData: D(e3.regular.instancesData), lodInfo: { lengths: new Float32Array(e3.regular.lodInfo.lengths) } }, silhouette: { instancesData: D(e3.silhouette.instancesData), lodInfo: { lengths: new Float32Array(e3.silhouette.lodInfo.lengths) } }, averageEdgeLength: e3.averageEdgeLength };
  }
};
var a = class {
  constructor(t3) {
    this.dataBuffer = t3.data.buffer, this.writerSettings = t3.writerSettings, this.skipDeduplicate = t3.skipDeduplicate, this.indices = Array.isArray(t3.indices) ? t3.indices : t3.indices.buffer, this.indicesType = Array.isArray(t3.indices) ? "Array" : s(t3.indices) ? "Uint32Array" : "Uint16Array", this.indicesLength = t3.indicesLength;
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/sceneLayerSource/SceneLayerSnappingSourceWorkerHandle.js
var p3 = class extends d {
  constructor(e3) {
    super(e3), this.availability = 0, this._ids = /* @__PURE__ */ new Set(), this._tmpP = n();
  }
  destroy() {
    this._workerHandle.destroy(), this._workerHandle = null;
  }
  initialize() {
    this._workerHandle = new l(this.schedule, { fetchAllEdgeLocations: (e3, t3) => this._fetchAllEdgeLocations(e3, t3) });
  }
  async fetchCandidates(e3, t3) {
    const r2 = e3.coordinateHelper, o3 = r2.toXYZ(e3.point);
    this.renderCoordsHelper.toRenderCoords(o3, r2.spatialReference, o3);
    const s2 = e3.distance, n4 = "number" == typeof s2 ? s2 : s2.distance, a2 = await this._workerHandle.invoke({ bounds: E(o3[0], o3[1], o3[2], n4), types: e3.types }, t3);
    return a2.candidates.sort((e4, t4) => e4.distance - t4.distance), a2.candidates.map((e4) => this._convertCandidate(r2, e4));
  }
  async add(e3, t3) {
    this._ids.add(e3.id), await this._workerHandle.invokeMethod("add", e3, t3);
  }
  async remove(e3, t3) {
    this._ids.delete(e3.id), await this._workerHandle.invokeMethod("remove", e3, t3);
  }
  _convertCandidate(e3, t3) {
    switch (t3.type) {
      case "edge":
        return new e2({ coordinateHelper: e3, objectId: t3.objectId, targetPoint: this._convertRenderCoordinate(e3, t3.target), edgeStart: this._convertRenderCoordinate(e3, t3.start), edgeEnd: this._convertRenderCoordinate(e3, t3.end), elevationInfo: E2 });
      case "vertex":
        return new o2({ coordinateHelper: e3, objectId: t3.objectId, targetPoint: this._convertRenderCoordinate(e3, t3.target), elevationInfo: E2 });
    }
  }
  _convertRenderCoordinate(e3, t3) {
    return this.renderCoordsHelper.fromRenderCoords(t3, this._tmpP, e3.spatialReference), e3.fromXYZ(this._tmpP);
  }
  async _fetchAllEdgeLocations(e3, t3) {
    const r2 = [], o3 = [];
    for (const { id: s2, uid: n4 } of e3.components)
      this._ids.has(s2) && r2.push((async () => {
        const e4 = await this.fetchEdgeLocations(s2, t3.signal);
        return o3.push(e4.locations.buffer), { id: s2, uid: n4, objectIds: e4.objectIds, locations: e4.locations.buffer, origin: e4.origin, type: e4.type };
      })());
    return { result: { components: (await Promise.all(r2)).filter(({ id: e4 }) => this._ids.has(e4)) }, transferList: o3 };
  }
};
e([y({ constructOnly: true })], p3.prototype, "renderCoordsHelper", void 0), e([y({ constructOnly: true })], p3.prototype, "fetchEdgeLocations", void 0), e([y({ constructOnly: true })], p3.prototype, "schedule", void 0), e([y({ readOnly: true })], p3.prototype, "availability", void 0), p3 = e([n2("esri.views.interactive.snapping.featureSources.sceneLayerSource.SceneLayerSnappingSourceWorker")], p3);
var l = class extends h2 {
  constructor(e3, t3) {
    super("SceneLayerSnappingSourceWorker", "fetchCandidates", {}, e3, { strategy: "dedicated", client: t3 });
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/I3SSnappingSource.js
var h3 = class extends d {
  constructor(e3) {
    super(e3), this.availability = 1, this._abortController = new AbortController();
  }
  get updating() {
    return this.updatingHandles.updating;
  }
  destroy() {
    this._tracker = h(this._tracker), this._abortController = p(this._abortController);
  }
  initialize() {
    const { view: e3 } = this, r2 = e3.resourceController;
    this._edgeWorker = new n3((e4) => r2.schedule(e4)), this._workerHandle = new p3({ renderCoordsHelper: this.view.renderCoordsHelper, schedule: (e4) => r2.schedule(e4), fetchEdgeLocations: async (e4, r3) => {
      if (t(this._tracker))
        throw new Error("tracker-not-initialized");
      return this._tracker.fetchEdgeLocations(e4, this._edgeWorker, r3);
    } }), this.updatingHandles.addPromise(this._setupLayerView()), this.handles.add([t2(this._workerHandle), t2(this._edgeWorker)]);
  }
  async fetchCandidates(e3, r2) {
    return this._workerHandle.fetchCandidates(e3, r2);
  }
  refresh() {
  }
  async _setupLayerView() {
    if (this.destroyed)
      return;
    const e3 = o(this._abortController, (e4) => e4.signal), r2 = await this.getLayerView();
    t(r2) || p2(e3) || (this._tracker = r2.trackSnappingSources({ add: (r3, t3) => {
      this.updatingHandles.addPromise(this._workerHandle.add({ id: r3, bounds: t3 }, e3));
    }, remove: (r3) => {
      this.updatingHandles.addPromise(this._workerHandle.remove({ id: r3 }, e3));
    } }));
  }
};
e([y({ constructOnly: true })], h3.prototype, "getLayerView", void 0), e([y({ constructOnly: true })], h3.prototype, "view", void 0), e([y({ readOnly: true })], h3.prototype, "updating", null), e([y({ readOnly: true })], h3.prototype, "availability", void 0), h3 = e([n2("esri.views.interactive.snapping.featureSources.I3SSnappingSource")], h3);

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/SceneLayerSnappingSource.js
var c = class extends m {
  constructor(e3) {
    super(e3), this.availability = 1, this._i3sSources = [];
  }
  get updating() {
    return this._i3sSources.some((e3) => e3.updating);
  }
  destroy() {
    this._i3sSources.forEach((e3) => e3.destroy()), this._i3sSources.length = 0;
  }
  initialize() {
    const { view: e3 } = this, r2 = this.layerSource.layer;
    this._i3sSources = "building-scene" === r2.type ? this._getBuildingSceneI3SSources(e3, r2) : [this._getSceneLayerI3SSource(e3, r2)];
  }
  async fetchCandidates(e3, r2) {
    const t3 = await Promise.all(this._i3sSources.map((t4) => t4.fetchCandidates(e3, r2)));
    return f(r2), t3.flat();
  }
  refresh() {
    this._i3sSources.forEach((e3) => e3.refresh());
  }
  _getBuildingSceneI3SSources(e3, r2) {
    return r2.allSublayers.toArray().map((t3) => "building-component" === t3.type ? new h3({ getLayerView: async () => (await e3.whenLayerView(r2)).whenSublayerView(t3), view: e3 }) : null).filter(r);
  }
  _getSceneLayerI3SSource(e3, r2) {
    return new h3({ getLayerView: async () => {
      const t3 = await e3.whenLayerView(r2);
      return "scene-layer-graphics-3d" === t3.type ? void 0 : t3;
    }, view: e3 });
  }
};
e([y({ constructOnly: true })], c.prototype, "layerSource", void 0), e([y({ constructOnly: true })], c.prototype, "view", void 0), e([y({ readOnly: true })], c.prototype, "updating", null), e([y({ readOnly: true })], c.prototype, "availability", void 0), c = e([n2("esri.views.interactive.snapping.featureSources.SceneLayerSnappingSource")], c);
export {
  c as SceneLayerSnappingSource
};
//# sourceMappingURL=SceneLayerSnappingSource-YJMSXW6X.js.map
