import {
  U
} from "./chunk-KG5RWWIW.js";
import {
  a
} from "./chunk-6TBB7UXB.js";
import {
  E,
  S
} from "./chunk-EQNT4A7P.js";
import {
  r as r2,
  s as s2
} from "./chunk-XO5VJRK4.js";
import {
  C
} from "./chunk-3OFVLRSL.js";
import {
  a as a2
} from "./chunk-FV3CMB37.js";
import {
  e
} from "./chunk-IQBIGNPU.js";
import {
  u as u2
} from "./chunk-INL7BDTP.js";
import {
  u
} from "./chunk-NRP45AHD.js";
import {
  l
} from "./chunk-RAX2HD42.js";
import {
  n
} from "./chunk-THVR7IAM.js";
import {
  D
} from "./chunk-MJXQTGI2.js";
import {
  s
} from "./chunk-LIZHLHNA.js";
import {
  has
} from "./chunk-HVKDYDPP.js";
import {
  r,
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/views/2d/engine/DisplayObject.js
var i = 1 / has("mapview-transitions-duration");
var r3 = class extends n {
  constructor() {
    super(...arguments), this._fadeOutResolver = null, this._fadeInResolver = null, this._clips = null, this.computedVisible = true, this.computedOpacity = 1, this.fadeTransitionEnabled = false, this.inFadeTransition = false, this._isReady = false, this._opacity = 1, this._stage = null, this._visible = true;
  }
  get clips() {
    return this._clips;
  }
  set clips(e3) {
    this._clips = e3, this.requestRender();
  }
  get isReady() {
    return this._isReady;
  }
  get opacity() {
    return this._opacity;
  }
  set opacity(e3) {
    this._opacity !== e3 && (this._opacity = Math.min(1, Math.max(e3, 0)), this.requestRender());
  }
  get stage() {
    return this._stage;
  }
  set stage(e3) {
    if (this._stage === e3)
      return;
    const t2 = this._stage;
    this._stage = e3, e3 ? this._stage.untrashDisplayObject(this) || (this.onAttach(), this.emit("attach")) : t2.trashDisplayObject(this);
  }
  get transforms() {
    return this._getTransforms();
  }
  _getTransforms() {
    return t(this._transforms) && (this._transforms = this._createTransforms()), this._transforms;
  }
  get visible() {
    return this._visible;
  }
  set visible(e3) {
    this._visible !== e3 && (this._visible = e3, this.requestRender());
  }
  fadeIn() {
    return this._fadeInResolver || (this._fadeOutResolver && (this._fadeOutResolver(), this._fadeOutResolver = null), this.opacity = 1, this.computedOpacity = 0, this.fadeTransitionEnabled = true, this._fadeInResolver = D(), this.requestRender()), this._fadeInResolver.promise;
  }
  fadeOut() {
    return this._fadeOutResolver || (this.opacity = 0, this._fadeInResolver && (this._fadeInResolver(), this._fadeInResolver = null), this.fadeTransitionEnabled = true, this._fadeOutResolver = D(), this.requestRender()), this._fadeOutResolver.promise;
  }
  endTransitions() {
    var _a, _b;
    (_a = this._fadeInResolver) == null ? void 0 : _a.call(this), this._fadeInResolver = null, (_b = this._fadeOutResolver) == null ? void 0 : _b.call(this), this._fadeOutResolver = null, this.computedOpacity = this.visible ? this.opacity : 0, this.requestRender();
  }
  beforeRender(e3) {
    this.updateTransitionProperties(e3.deltaTime, e3.state.scale);
  }
  afterRender(e3) {
    this._fadeInResolver && this.computedOpacity === this.opacity ? (this._fadeInResolver(), this._fadeInResolver = null) : this._fadeOutResolver && 0 === this.computedOpacity && (this._fadeOutResolver(), this._fadeOutResolver = null);
  }
  remove() {
    var _a;
    (_a = this.parent) == null ? void 0 : _a.removeChild(this);
  }
  setTransform(e3) {
  }
  processRender(e3) {
    this.stage && this.computedVisible && this.doRender(e3);
  }
  requestRender() {
    this.stage && this.stage.requestRender();
  }
  processDetach() {
    this._fadeInResolver && (this._fadeInResolver(), this._fadeInResolver = null), this._fadeOutResolver && (this._fadeOutResolver(), this._fadeOutResolver = null), this.onDetach(), this.emit("detach");
  }
  updateTransitionProperties(e3, t2) {
    if (this.fadeTransitionEnabled) {
      const t3 = this._fadeOutResolver || !this.visible ? 0 : this.opacity, s4 = this.computedOpacity;
      if (s4 === t3)
        this.computedVisible = this.visible;
      else {
        const r4 = e3 * i;
        this.computedOpacity = s4 > t3 ? Math.max(t3, s4 - r4) : Math.min(t3, s4 + r4), this.computedVisible = this.computedOpacity > 0;
        const a3 = t3 === this.computedOpacity;
        this.inFadeTransition = !a3, a3 || this.requestRender();
      }
    } else
      this.computedOpacity = this.opacity, this.computedVisible = this.visible;
  }
  onAttach() {
  }
  onDetach() {
  }
  doRender(e3) {
  }
  ready() {
    this._isReady || (this._isReady = true, this.emit("isReady"), this.requestRender());
  }
};

// node_modules/@arcgis/core/views/2d/engine/Container.js
var i2 = class extends r3 {
  constructor() {
    super(...arguments), this._childrenSet = /* @__PURE__ */ new Set(), this._needsSort = false, this.children = [], this._effectView = null;
  }
  get blendMode() {
    return this._blendMode;
  }
  set blendMode(e3) {
    this._blendMode = e3, this.requestRender();
  }
  get clips() {
    return this._clips;
  }
  set clips(e3) {
    this._clips = e3, this.children.forEach((t2) => t2.clips = e3);
  }
  get computedEffects() {
    var _a, _b;
    return (_b = (_a = this._effectView) == null ? void 0 : _a.effects) != null ? _b : null;
  }
  get effect() {
    var _a, _b;
    return (_b = (_a = this._effectView) == null ? void 0 : _a.effect) != null ? _b : "";
  }
  set effect(e3) {
    (this._effectView || e3) && (this._effectView || (this._effectView = new a2()), this._effectView.effect = e3, this.requestRender());
  }
  updateTransitionProperties(e3, t2) {
    super.updateTransitionProperties(e3, t2), this._effectView && (this._effectView.transitionStep(e3, t2), this._effectView.transitioning && this.requestRender());
  }
  doRender(e3) {
    const t2 = this.createRenderParams(e3);
    this.renderChildren(t2);
  }
  addChild(e3) {
    return this.addChildAt(e3, this.children.length);
  }
  addChildAt(e3, t2 = this.children.length) {
    if (!e3)
      return e3;
    if (this.contains(e3))
      return e3;
    this._needsSort = true;
    const s4 = e3.parent;
    return s4 && s4 !== this && s4.removeChild(e3), t2 >= this.children.length ? this.children.push(e3) : this.children.splice(t2, 0, e3), this._childrenSet.add(e3), e3.parent = this, e3.stage = this.stage, this !== this.stage && (e3.clips = this.clips), this.requestRender(), e3;
  }
  contains(e3) {
    return this._childrenSet.has(e3);
  }
  endTransitions() {
    super.endTransitions(), this._effectView && (this._effectView.endTransitions(), this.requestRender());
  }
  removeAllChildren() {
    this._childrenSet.clear(), this._needsSort = true;
    for (const e3 of this.children)
      this !== this.stage && (e3.clips = null), e3.stage = null, e3.parent = null;
    this.children.length = 0;
  }
  removeChild(e3) {
    return this.contains(e3) ? this.removeChildAt(this.children.indexOf(e3)) : e3;
  }
  removeChildAt(e3) {
    if (e3 < 0 || e3 >= this.children.length)
      return null;
    this._needsSort = true;
    const t2 = this.children.splice(e3, 1)[0];
    return this._childrenSet.delete(t2), this !== this.stage && (t2.clips = null), t2.stage = null, t2.parent = null, t2;
  }
  sortChildren(e3) {
    this._needsSort && (this.children.sort(e3), this._needsSort = false);
  }
  beforeRender(e3) {
    super.beforeRender(e3);
    for (const t2 of this.children)
      t2.beforeRender(e3);
  }
  afterRender(e3) {
    super.afterRender(e3);
    for (const t2 of this.children)
      t2.afterRender(e3);
  }
  _createTransforms() {
    return { dvs: e() };
  }
  onAttach() {
    super.onAttach();
    const e3 = this.stage;
    for (const t2 of this.children)
      t2.stage = e3;
  }
  onDetach() {
    super.onDetach();
    for (const e3 of this.children)
      e3.stage = null;
  }
  renderChildren(e3) {
    for (const t2 of this.children)
      t2.processRender(e3);
  }
  createRenderParams(e3) {
    return { ...e3, blendMode: this.blendMode, effects: this.computedEffects, globalOpacity: e3.globalOpacity * this.computedOpacity, inFadeTransition: this.inFadeTransition };
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/techniques/Technique.js
var e2 = class {
  static getStorageSpec(t2) {
    return null;
  }
  static createOrUpdateRendererSchema(e3, r4) {
    return r(e3) && "default" === e3.type ? e3 : { type: "default" };
  }
  static getVariation(t2) {
    return {};
  }
  static getVariationHash(t2) {
    return 0;
  }
};
e2.type = "default", e2.programSpec = null;

// node_modules/@arcgis/core/views/2d/engine/webgl/techniques/dotDensity/TechniqueDotDensity.js
var n2 = class extends e2 {
  static getStorageSpec({ attributes: e3 }) {
    return { visualVariables: false, attributes: e3 != null ? e3 : null };
  }
  static _createRendererSchema() {
    return { type: "dot-density", colors: new Float32Array(32), dotValue: -1, dotSize: -1, dotScale: -1, dotBlending: false, backgroundColor: new Float32Array(4), activeDots: new Float32Array(8), seed: -1 };
  }
  static createOrUpdateRendererSchema(r4, a3) {
    const { attributes: n4, dotValue: i3, referenceScale: d, dotSize: l3, dotBlendingEnabled: s4, seed: c2, backgroundColor: u3 } = a3, m = r(r4) && "dot-density" === r4.type ? r4 : this._createRendererSchema();
    m.dotValue = i3, m.dotSize = l3, m.dotScale = d, m.dotBlending = s4, m.seed = c2;
    const { colors: g, activeDots: p2, backgroundColor: y } = m;
    for (let e3 = 0; e3 < r2; e3++) {
      const o = e3 >= n4.length ? null : n4[e3].color;
      a(g, o, 4 * e3);
    }
    for (let e3 = 0; e3 < 8; e3++)
      p2[e3] = e3 < a3.attributes.length ? 1 : 0;
    return a(y, u3), m;
  }
  static getVariation(e3) {
    return { ddDotBlending: e3.dotBlending };
  }
  static getVariationHash(e3) {
    return e3.dotBlending ? 1 : 0;
  }
};
n2.type = "dot-density", n2.programSpec = { shader: "materials/fill", vertexLayout: { geometry: [{ location: 0, name: "a_pos", count: 2, type: C.SHORT }, { location: 1, name: "a_id", count: 3, type: C.UNSIGNED_BYTE }, { location: 2, name: "a_bitset", count: 1, type: C.UNSIGNED_BYTE }, { location: 3, name: "a_inverseArea", count: 1, type: C.FLOAT }] } };

// node_modules/@arcgis/core/views/2d/engine/webgl/techniques/heatmap/TechniqueHeatmap.js
var n3 = class extends e2 {
  static getStorageSpec({ field: e3, valueExpression: t2 }) {
    return { visualVariables: false, attributes: e3 || t2 ? [{ field: e3, valueExpression: t2 }] : null };
  }
  static _createRendererSchema() {
    return { type: "heatmap", radius: -1, referenceScale: -1, isFieldActive: 0, minDensity: -1, densityRange: -1, kernel: null, gradient: null, gradientHash: "invalid" };
  }
  static createOrUpdateRendererSchema(a3, i3) {
    const { radius: n4, minDensity: s4, maxDensity: o, referenceScale: c2, field: l3, valueExpression: m, colorStops: p2 } = i3, d = o - s4, u3 = l3 || m ? 1 : 0, y = p2.map(({ color: e3, ratio: t2 }) => `${t2}:${e3.toString()}`).join();
    let h, S2 = true;
    return r(a3) && "heatmap" === a3.type ? (h = a3, S2 = y !== a3.gradientHash) : h = this._createRendererSchema(), h.radius = u(n4), h.minDensity = s4, h.densityRange = d, h.referenceScale = c2, h.isFieldActive = u3, S2 && (h.gradient = u2(p2), h.gradientHash = y), h;
  }
};
n3.type = "heatmap", n3.programSpec = { shader: "materials/icon/heatmapAccumulate", vertexLayout: { geometry: [{ location: 0, name: "a_pos", count: 2, type: C.SHORT }, { location: 1, name: "a_vertexOffset", count: 2, type: C.SHORT }, { location: 4, name: "a_id", count: 4, type: C.UNSIGNED_BYTE }] } };

// node_modules/@arcgis/core/views/2d/engine/webgl/techniques/pieChart/TechniquePieChart.js
var l2 = class extends e2 {
  static getStorageSpec({ attributes: e3 }) {
    return { visualVariables: true, attributes: e3 != null ? e3 : null };
  }
  static _createRendererSchema() {
    return { type: "pie-chart", colors: new Float32Array(4 * s2), defaultColor: new Float32Array(4), othersColor: new Float32Array(4), outlineColor: new Float32Array(4), holePercentage: 0, sectorThreshold: 0, outlineWidth: 1, numberOfFields: 10 };
  }
  static createOrUpdateRendererSchema(n4, i3) {
    const { attributes: l3, defaultColor: s4, holePercentage: c2, othersCategory: m, outline: u3 } = i3, d = r(n4) && "pie-chart" === n4.type ? n4 : this._createRendererSchema();
    for (let t2 = 0; t2 < s2; t2++) {
      const o = t2 >= l3.length ? new l([0, 0, 0, 0]) : l3[t2].color;
      a(d.colors, o, 4 * t2);
    }
    return a(d.defaultColor, s4), a(d.othersColor, m == null ? void 0 : m.color), a(d.outlineColor, u3 == null ? void 0 : u3.color), d.outlineWidth = u((u3 == null ? void 0 : u3.width) || 0), d.holePercentage = c2, d.sectorThreshold = (m == null ? void 0 : m.threshold) || 0, d.numberOfFields = l3.length, d;
  }
  static getVariation(e3) {
    return { numberOfFields: e3.numberOfFields };
  }
  static getVariationHash(e3) {
    return e3.numberOfFields;
  }
};
l2.type = "pie-chart", l2.programSpec = { shader: "materials/pie", vertexLayout: { geometry: [{ location: 0, name: "a_pos", count: 2, type: C.SHORT }, { location: 1, name: "a_vertexOffset", count: 2, type: C.SHORT }, { location: 2, name: "a_texCoords", count: 2, type: C.UNSIGNED_SHORT }, { location: 3, name: "a_bitSetAndDistRatio", count: 2, type: C.UNSIGNED_SHORT }, { location: 4, name: "a_id", count: 4, type: C.UNSIGNED_BYTE }, { location: 5, name: "a_color", count: 4, type: C.UNSIGNED_BYTE, normalized: true }, { location: 6, name: "a_outlineColor", count: 4, type: C.UNSIGNED_BYTE, normalized: true }, { location: 7, name: "a_sizeAndOutlineWidth", count: 4, type: C.UNSIGNED_BYTE }, { location: 8, name: "a_zoomRange", count: 2, type: C.UNSIGNED_SHORT }] }, hittestAttributes: ["a_vertexOffset", "a_texCoords"] };

// node_modules/@arcgis/core/views/2d/engine/webgl/techniques/utils.js
function s3(r4, t2) {
  if (r4.type !== t2)
    throw new s("material-view-model:unexpected-renderer-schema", `expected to find renderer schema of type "${t2}" but found type "${r4.type}"`);
}
function c(e3) {
  switch (e3 == null ? void 0 : e3.type) {
    case "dot-density":
      return n2;
    case "heatmap":
      return n3;
    case "pie-chart":
      return l2;
    default:
      return e2;
  }
}
function p(e3) {
  const { geometryType: s4, symbologyType: c2 } = U.load(e3);
  switch (s4) {
    case E.FILL:
      if (c2 === S.DOT_DENSITY)
        return n2;
      break;
    case E.MARKER:
      switch (c2) {
        case S.HEATMAP:
          return n3;
        case S.PIE_CHART:
          return l2;
      }
  }
  return e2;
}

export {
  r3 as r,
  i2 as i,
  e2 as e,
  s3 as s,
  c,
  p
};
//# sourceMappingURL=chunk-7N2Z7KNR.js.map
