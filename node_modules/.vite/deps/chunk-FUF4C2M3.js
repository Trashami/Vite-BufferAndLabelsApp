import {
  i,
  n as n3,
  o as o3
} from "./chunk-KBM2LGNP.js";
import {
  s
} from "./chunk-OPS2DUBP.js";
import {
  e as e4,
  o as o4
} from "./chunk-WEBU4A2Q.js";
import {
  a
} from "./chunk-372DRRBO.js";
import {
  r as r4
} from "./chunk-X7GQR2IY.js";
import {
  e as e3,
  t as t2
} from "./chunk-6WTG5RYO.js";
import {
  U
} from "./chunk-HNRPDSCT.js";
import {
  o as o7
} from "./chunk-ZSBQER52.js";
import {
  d as d2
} from "./chunk-GDICPMRK.js";
import {
  e as e5
} from "./chunk-JPRTIOCM.js";
import {
  c,
  i2
} from "./chunk-AMNM3DGI.js";
import {
  t
} from "./chunk-RNRS2JL4.js";
import {
  h
} from "./chunk-SBPLVEUA.js";
import {
  u
} from "./chunk-3IISYLTT.js";
import {
  d,
  o as o5,
  v
} from "./chunk-7QNA4ADD.js";
import {
  e as e2
} from "./chunk-FGA4AGTH.js";
import {
  o as o6,
  r as r3
} from "./chunk-6VLXCUNV.js";
import {
  C
} from "./chunk-D2XA6Z6P.js";
import {
  f
} from "./chunk-BQL7VXQR.js";
import {
  o as o8
} from "./chunk-735C75BI.js";
import {
  n as n2
} from "./chunk-ZLTZ3KAT.js";
import {
  r as r2
} from "./chunk-XP4QUBSF.js";
import {
  O
} from "./chunk-RUM3DXFX.js";
import {
  o as o2
} from "./chunk-IVLBGTXL.js";
import {
  o
} from "./chunk-3LR5O4WA.js";
import {
  n
} from "./chunk-D4V6J5BT.js";
import {
  e
} from "./chunk-OOLCFNXJ.js";
import {
  r
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/Offset.glsl.js
function e6(e9) {
  e9.vertex.code.add(n2`vec4 offsetBackfacingClipPosition(vec4 posClip, vec3 posWorld, vec3 normalWorld, vec3 camPosWorld) {
vec3 camToVert = posWorld - camPosWorld;
bool isBackface = dot(camToVert, normalWorld) > 0.0;
if (isBackface) {
posClip.z += 0.0000003 * posClip.w;
}
return posClip;
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/InstancedDoublePrecision.glsl.js
var v2 = class extends t2 {
  constructor() {
    super(...arguments), this.instancedDoublePrecision = false;
  }
};
function p(e9, i6) {
  i6.instanced && i6.instancedDoublePrecision && (e9.attributes.add(O.MODELORIGINHI, "vec3"), e9.attributes.add(O.MODELORIGINLO, "vec3"), e9.attributes.add(O.MODEL, "mat3"), e9.attributes.add(O.MODELNORMAL, "mat3"));
  const c2 = e9.vertex;
  i6.instancedDoublePrecision && (c2.include(c, i6), c2.uniforms.add(new o5("viewOriginHi", (e10, i7) => o6(o(b, i7.camera.viewInverseTransposeMatrix[3], i7.camera.viewInverseTransposeMatrix[7], i7.camera.viewInverseTransposeMatrix[11]), b))), c2.uniforms.add(new o5("viewOriginLo", (e10, i7) => r3(o(b, i7.camera.viewInverseTransposeMatrix[3], i7.camera.viewInverseTransposeMatrix[7], i7.camera.viewInverseTransposeMatrix[11]), b)))), c2.code.add(n2`
    vec3 calculateVPos() {
      ${i6.instancedDoublePrecision ? "return model * localPosition().xyz;" : "return localPosition().xyz;"}
    }
    `), c2.code.add(n2`
    vec3 subtractOrigin(vec3 _pos) {
      ${i6.instancedDoublePrecision ? n2`
          vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);
          return _pos - originDelta;` : "return vpos;"}
    }
    `), c2.code.add(n2`
    vec3 dpNormal(vec4 _normal) {
      ${i6.instancedDoublePrecision ? "return normalize(modelNormal * _normal.xyz);" : "return normalize(_normal.xyz);"}
    }
    `), i6.output === h.Normal && (d(c2), c2.code.add(n2`
    vec3 dpNormalView(vec4 _normal) {
      ${i6.instancedDoublePrecision ? "return normalize((viewNormal * vec4(modelNormal * _normal.xyz, 1.0)).xyz);" : "return normalize((viewNormal * _normal).xyz);"}
    }
    `)), i6.hasVertexTangents && c2.code.add(n2`
    vec4 dpTransformVertexTangent(vec4 _tangent) {
      ${i6.instancedDoublePrecision ? "return vec4(modelNormal * _tangent.xyz, _tangent.w);" : "return _tangent;"}

    }
    `);
}
e([e3()], v2.prototype, "instancedDoublePrecision", void 0);
var b = n();

// node_modules/@arcgis/core/views/3d/webgl-engine/collections/Component/Material/shader/DecodeSymbolColor.glsl.js
function e7(e9) {
  e9.vertex.code.add(n2`
    vec4 decodeSymbolColor(vec4 symbolColor, out int colorMixMode) {
      float symbolAlpha = 0.0;

      const float maxTint = 85.0;
      const float maxReplace = 170.0;
      const float scaleAlpha = 3.0;

      if (symbolColor.a > maxReplace) {
        colorMixMode = ${n2.int(r2.Multiply)};
        symbolAlpha = scaleAlpha * (symbolColor.a - maxReplace);
      } else if (symbolColor.a > maxTint) {
        colorMixMode = ${n2.int(r2.Replace)};
        symbolAlpha = scaleAlpha * (symbolColor.a - maxTint);
      } else if (symbolColor.a > 0.0) {
        colorMixMode = ${n2.int(r2.Tint)};
        symbolAlpha = scaleAlpha * symbolColor.a;
      } else {
        colorMixMode = ${n2.int(r2.Multiply)};
        symbolAlpha = 0.0;
      }

      return vec4(symbolColor.r, symbolColor.g, symbolColor.b, symbolAlpha);
    }
  `);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/SymbolColor.glsl.js
function i3(i6, t3) {
  t3.hasSymbolColors ? (i6.include(e7), i6.attributes.add(O.SYMBOLCOLOR, "vec4"), i6.varyings.add("colorMixMode", "mediump float"), i6.vertex.code.add(n2`int symbolColorMixMode;
vec4 getSymbolColor() {
return decodeSymbolColor(symbolColor, symbolColorMixMode) * 0.003921568627451;
}
void forwardColorMixMode() {
colorMixMode = float(symbolColorMixMode) + 0.5;
}`)) : (i6.fragment.uniforms.add(new e4("colorMixMode", (o9) => U[o9.colorMixMode])), i6.vertex.code.add(n2`vec4 getSymbolColor() { return vec4(1.0); }
void forwardColorMixMode() {}`));
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/DiscardOrAdjustAlphaBlend.glsl.js
function d3(d4) {
  d4.fragment.code.add(n2`
    #define discardOrAdjustAlpha(color) { if (color.a < ${n2.float(t)}) { discard; } }
  `);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl.js
function s2(a3, e9) {
  l(a3, e9, new o8("textureAlphaCutoff", (a4) => a4.textureAlphaCutoff));
}
function l(e9, r5, s3) {
  const t3 = e9.fragment;
  switch (r5.alphaDiscardMode !== C.Mask && r5.alphaDiscardMode !== C.MaskBlend || t3.uniforms.add(s3), r5.alphaDiscardMode) {
    case C.Blend:
      return e9.include(d3);
    case C.Opaque:
      t3.code.add(n2`void discardOrAdjustAlpha(inout vec4 color) {
color.a = 1.0;
}`);
      break;
    case C.Mask:
      t3.code.add(n2`#define discardOrAdjustAlpha(color) { if (color.a < textureAlphaCutoff) { discard; } else { color.a = 1.0; } }`);
      break;
    case C.MaskBlend:
      e9.fragment.code.add(n2`#define discardOrAdjustAlpha(color) { if (color.a < textureAlphaCutoff) { discard; } }`);
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/default/DefaultMaterialAuxiliaryPasses.glsl.js
function b2(b3, O2) {
  const { vertex: w, fragment: C2 } = b3, T = O2.hasModelTransformation;
  T && w.uniforms.add(new e2("model", (e9) => r(e9.modelTransformation) ? e9.modelTransformation : o2));
  const V = O2.hasColorTexture && O2.alphaDiscardMode !== C.Opaque;
  switch (O2.output) {
    case h.Depth:
    case h.Shadow:
    case h.ShadowHighlight:
    case h.ShadowExludeHighlight:
    case h.ObjectAndLayerIdColor:
      v(w, O2), b3.include(r4, O2), b3.include(o4, O2), b3.include(s, O2), b3.include(o7, O2), b3.include(u, O2), b3.include(d2, O2), i2(b3), b3.varyings.add("depth", "float"), V && C2.uniforms.add(new f("tex", (o9) => o9.texture)), w.code.add(n2`
          void main(void) {
            vpos = calculateVPos();
            vpos = subtractOrigin(vpos);
            vpos = addVerticalOffset(vpos, localOrigin);
            gl_Position = transformPositionWithDepth(proj, view, ${T ? "model," : ""} vpos, nearFar, depth);
            forwardTextureCoordinates();
            forwardObjectAndLayerIdColor();
          }
        `), b3.include(s2, O2), C2.code.add(n2`
          void main(void) {
            discardBySlice(vpos);
            ${V ? n2`
                    vec4 texColor = texture2D(tex, ${O2.hasColorTextureTransform ? n2`colorUV` : n2`vuv0`});
                    discardOrAdjustAlpha(texColor);` : ""}
            ${O2.output === h.ObjectAndLayerIdColor ? n2`outputObjectAndLayerIdColor();` : n2`outputDepth(depth);`}
          }
        `);
      break;
    case h.Normal:
      v(w, O2), b3.include(r4, O2), b3.include(o3, O2), b3.include(n3, O2), b3.include(o4, O2), b3.include(s, O2), V && C2.uniforms.add(new f("tex", (o9) => o9.texture)), b3.varyings.add("vPositionView", "vec3"), w.code.add(n2`
          void main(void) {
            vpos = calculateVPos();
            vpos = subtractOrigin(vpos);
            ${O2.normalType === i.Attribute ? n2`
            vNormalWorld = dpNormalView(vvLocalNormal(normalModel()));` : ""}
            vpos = addVerticalOffset(vpos, localOrigin);
            gl_Position = transformPosition(proj, view, ${T ? "model," : ""} vpos);
            forwardTextureCoordinates();
          }
        `), b3.include(u, O2), b3.include(s2, O2), C2.code.add(n2`
          void main() {
            discardBySlice(vpos);
            ${V ? n2`
                    vec4 texColor = texture2D(tex, ${O2.hasColorTextureTransform ? n2`colorUV` : n2`vuv0`});
                    discardOrAdjustAlpha(texColor);` : ""}

            ${O2.normalType === i.ScreenDerivative ? n2`
                vec3 normal = screenDerivativeNormal(vPositionView);` : n2`
                vec3 normal = normalize(vNormalWorld);
                if (gl_FrontFacing == false) normal = -normal;`}
            gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);
          }
        `);
      break;
    case h.Highlight:
      v(w, O2), b3.include(r4, O2), b3.include(o4, O2), b3.include(s, O2), V && C2.uniforms.add(new f("tex", (o9) => o9.texture)), w.code.add(n2`
          void main(void) {
            vpos = calculateVPos();
            vpos = subtractOrigin(vpos);
            vpos = addVerticalOffset(vpos, localOrigin);
            gl_Position = transformPosition(proj, view, ${T ? "model," : ""} vpos);
            forwardTextureCoordinates();
          }
        `), b3.include(u, O2), b3.include(s2, O2), b3.include(a, O2), C2.code.add(n2`
          void main() {
            discardBySlice(vpos);
            ${V ? n2`
                    vec4 texColor = texture2D(tex, ${O2.hasColorTextureTransform ? n2`colorUV` : n2`vuv0`});
                    discardOrAdjustAlpha(texColor);` : ""}
            outputHighlight();
          }
        `);
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/MixExternalColor.glsl.js
function i5(i6) {
  i6.include(e5), i6.code.add(n2`
    vec3 mixExternalColor(vec3 internalColor, vec3 textureColor, vec3 externalColor, int mode) {
      // workaround for artifacts in OSX using Intel Iris Pro
      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475
      vec3 internalMixed = internalColor * textureColor;
      vec3 allMixed = internalMixed * externalColor;

      if (mode == ${n2.int(r2.Multiply)}) {
        return allMixed;
      }
      if (mode == ${n2.int(r2.Ignore)}) {
        return internalMixed;
      }
      if (mode == ${n2.int(r2.Replace)}) {
        return externalColor;
      }

      // tint (or something invalid)
      float vIn = rgb2v(internalMixed);
      vec3 hsvTint = rgb2hsv(externalColor);
      vec3 hsvOut = vec3(hsvTint.x, hsvTint.y, vIn * hsvTint.z);
      return hsv2rgb(hsvOut);
    }

    float mixExternalOpacity(float internalOpacity, float textureOpacity, float externalOpacity, int mode) {
      // workaround for artifacts in OSX using Intel Iris Pro
      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475
      float internalMixed = internalOpacity * textureOpacity;
      float allMixed = internalMixed * externalOpacity;

      if (mode == ${n2.int(r2.Ignore)}) {
        return internalMixed;
      }
      if (mode == ${n2.int(r2.Replace)}) {
        return externalOpacity;
      }

      // multiply or tint (or something invalid)
      return allMixed;
    }
  `);
}

export {
  e6 as e,
  p,
  i3 as i,
  s2 as s,
  b2 as b,
  i5 as i2
};
//# sourceMappingURL=chunk-FUF4C2M3.js.map
