import {
  l
} from "./chunk-GX2FDWTU.js";
import {
  o
} from "./chunk-NRP45AHD.js";
import {
  s as s2
} from "./chunk-LIZHLHNA.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";
import {
  has
} from "./chunk-HVKDYDPP.js";

// node_modules/@arcgis/core/views/2d/layers/features/support/rendererUtils.js
var s3 = 8;
var l2 = s3 - 2;
var a = s.getLogger("esri.views.2d.layers.features.support.rendererUtils");
var n = (e) => {
  if (!("visualVariables" in e) || !e.visualVariables || !e.visualVariables.length)
    return e;
  const r = e.clone(), t = r.visualVariables.map((e2) => u(e2) ? p(e2) : e2);
  return r.visualVariables = t, r;
};
function i(e) {
  return e.map((e2) => u(e2) ? p(e2.clone()) : e2);
}
function u(e) {
  return ("size" === e.type || "color" === e.type || "opacity" === e.type) && null != e.stops;
}
function p(e) {
  return e.stops = m(e.type, e.stops), e;
}
function c(e, r, t) {
  return (1 - t) * e + t * r;
}
function f(e, r) {
  const [o2, ...s4] = r, a2 = s4.pop(), n2 = s4[0].value, i2 = s4[s4.length - 1].value, u2 = (i2 - n2) / l2, p2 = [];
  for (let l3 = n2; l3 < i2; l3 += u2) {
    let o3 = 0;
    for (; l3 >= s4[o3].value; )
      o3++;
    const a3 = s4[o3], n3 = r[o3 - 1], i3 = l3 - n3.value, u3 = a3.value === n3.value ? 1 : i3 / (a3.value - n3.value);
    if ("color" === e) {
      const e2 = s4[o3], t = r[o3 - 1], a4 = e2.color.clone();
      a4.r = c(t.color.r, a4.r, u3), a4.g = c(t.color.g, a4.g, u3), a4.b = c(t.color.b, a4.b, u3), a4.a = c(t.color.a, a4.a, u3), p2.push({ value: l3, color: a4, label: e2.label });
    } else if ("size" === e) {
      const e2 = s4[o3], a4 = r[o3 - 1], n4 = o(e2.size), i4 = c(o(a4.size), n4, u3);
      p2.push({ value: l3, size: i4, label: e2.label });
    } else {
      const e2 = s4[o3], t = c(r[o3 - 1].opacity, e2.opacity, u3);
      p2.push({ value: l3, opacity: t, label: e2.label });
    }
  }
  return [o2, ...p2, a2];
}
function b(e) {
  const [r, ...t] = e, o2 = t.pop();
  for (; t.length > l2; ) {
    let e2 = 0, r2 = 0;
    for (let o3 = 1; o3 < t.length; o3++) {
      const s4 = t[o3 - 1], l3 = t[o3], a2 = Math.abs(l3.value - s4.value);
      a2 > r2 && (r2 = a2, e2 = o3);
    }
    t.splice(e2, 1);
  }
  return [r, ...t, o2];
}
function m(e, r) {
  return r.length <= s3 ? r : (a.warn(`Found ${r.length} Visual Variable stops, but MapView only supports ${s3}. Displayed stops will be simplified.`), r.length > 2 * s3 ? f(e, r) : b(r));
}
function g() {
  if (has("heatmap-force-raster"))
    return "raster";
  const { supportsTextureFloat: e, supportsTextureHalfFloat: r, supportsColorBufferFloat: t, supportsColorBufferFloatBlend: s4, supportsColorBufferHalfFloat: l3 } = l("2d");
  return e && t && s4 || r && l3 ? "symbol" : has("heatmap-allow-raster-fallback") ? "raster" : "none";
}
function h(r) {
  if (!r)
    return true;
  switch (r.type) {
    case "dot-density":
      if (!l("2d").supportsTextureFloat)
        return a.error(new s2("webgl-missing-extension", "Missing WebGL extension OES_Texture_Float which is required for DotDensity")), false;
      break;
    case "heatmap": {
      const r2 = g();
      if ("none" === r2 || "raster" === r2 && !has("heatmap-force-raster")) {
        const t = l("2d"), s4 = ["supportsTextureFloat", "supportsTextureHalfFloat", "supportsColorBufferFloat", "supportsColorBufferFloatBlend", "supportsColorBufferHalfFloat"].filter((e) => !t[e]).join(", ");
        if ("none" === r2)
          return a.errorOnce(new s2("webgl-missing-extension", `Missing WebGL${t.type} requirements for Heatmap: ${s4}`)), false;
        "raster" === r2 && a.warnOnce(`Missing WebGL${t.type} requirements for accelerated Heatmap: ${s4}. Feature support may be limited.`);
      }
      break;
    }
  }
  return true;
}

export {
  n,
  i,
  g,
  h
};
//# sourceMappingURL=chunk-EWYYYS2T.js.map
