import {
  p
} from "./chunk-6TQO4FJO.js";
import {
  i as i3,
  m as m2,
  o as o2
} from "./chunk-DPGI5XTT.js";
import {
  $ as $2,
  c as c4,
  d,
  g as g3,
  h as h2,
  p as p2,
  u as u4,
  w as w2,
  y as y3
} from "./chunk-LL5ZGGZR.js";
import {
  r as r6
} from "./chunk-7N2Z7KNR.js";
import {
  o
} from "./chunk-4Y3VLNR2.js";
import {
  E as E4,
  e as e4,
  l as l5,
  l2 as l6,
  x
} from "./chunk-MU26VSON.js";
import {
  n as n3
} from "./chunk-5HIF32ZE.js";
import {
  Q,
  V,
  ae as ae2,
  n as n2
} from "./chunk-57QYUXCA.js";
import {
  U as U4
} from "./chunk-KG5RWWIW.js";
import {
  c as c3,
  r as r5,
  v
} from "./chunk-XNT3PUPA.js";
import {
  G,
  K,
  W,
  X,
  ae,
  ge,
  he,
  ie,
  se
} from "./chunk-6TBB7UXB.js";
import {
  S
} from "./chunk-EQNT4A7P.js";
import {
  b
} from "./chunk-ESF7LLEL.js";
import {
  U as U3
} from "./chunk-XO5VJRK4.js";
import {
  E2 as E3,
  a as a2
} from "./chunk-O4DPVR3F.js";
import {
  r as r4
} from "./chunk-A22ACVMF.js";
import {
  C as C2,
  E as E2,
  F,
  I,
  R as R2
} from "./chunk-3OFVLRSL.js";
import {
  f as f4,
  g as g2
} from "./chunk-OEFH2SLX.js";
import {
  O,
  U
} from "./chunk-I4YZGF7W.js";
import {
  i as i2
} from "./chunk-QU433TMZ.js";
import {
  l as l4
} from "./chunk-GX2FDWTU.js";
import {
  t as t3
} from "./chunk-UDYHZLTE.js";
import {
  e as e3
} from "./chunk-IQBIGNPU.js";
import {
  M,
  f as f3,
  h,
  i,
  r as r3
} from "./chunk-ZNRXLY4R.js";
import {
  $,
  C,
  at,
  et,
  ht
} from "./chunk-TJ2I6XQT.js";
import {
  t as t2
} from "./chunk-34YPGGJT.js";
import {
  U as U2
} from "./chunk-NCXAKZRR.js";
import {
  N,
  O as O2,
  j as j2
} from "./chunk-NCONZRBI.js";
import {
  a
} from "./chunk-REIQNAQW.js";
import {
  u as u2
} from "./chunk-NRP45AHD.js";
import {
  E,
  e as e2,
  l as l3,
  q,
  s as s2,
  u as u3
} from "./chunk-6M2AHKYV.js";
import {
  s as s3
} from "./chunk-23Y3DIC6.js";
import {
  c as c2,
  f as f2,
  l,
  s,
  u,
  y as y2
} from "./chunk-EHPBHJYZ.js";
import {
  c2 as c,
  g,
  r2
} from "./chunk-3MNMDUQZ.js";
import {
  R,
  k2 as k
} from "./chunk-LNZAOBFW.js";
import {
  l as l2
} from "./chunk-5NXILPDI.js";
import {
  e,
  m,
  n2 as n,
  y
} from "./chunk-OOLCFNXJ.js";
import {
  f,
  j,
  w
} from "./chunk-MJXQTGI2.js";
import {
  has
} from "./chunk-HVKDYDPP.js";
import {
  r,
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/DirtyMap.js
var t4 = -1;
var e5 = class {
  constructor() {
    this._dirties = [{ vertexFrom: t4, vertexCount: t4, indexFrom: t4, indexCount: t4, allDirty: false }, { vertexFrom: t4, vertexCount: t4, indexFrom: t4, indexCount: t4, allDirty: false }, { vertexFrom: t4, vertexCount: t4, indexFrom: t4, indexCount: t4, allDirty: false }, { vertexFrom: t4, vertexCount: t4, indexFrom: t4, indexCount: t4, allDirty: false }, { vertexFrom: t4, vertexCount: t4, indexFrom: t4, indexCount: t4, allDirty: false }];
  }
  hasDirty() {
    return this._dirties.some((e11) => e11.indexCount !== t4 || e11.allDirty);
  }
  markAllClean() {
    for (const e11 of this._dirties)
      e11.indexFrom = t4, e11.indexCount = t4, e11.vertexFrom = t4, e11.vertexCount = t4, e11.allDirty = false;
  }
  markAllDirty() {
    for (const t11 of this._dirties)
      t11.allDirty = true;
  }
  forEach(e11) {
    for (let r10 = 0; r10 < this._dirties.length; ++r10) {
      const { indexCount: i5, indexFrom: o7, vertexCount: n7, vertexFrom: x4, allDirty: l8 } = this._dirties[r10], s7 = {};
      let d5, m3 = false;
      (l8 || x4 !== t4 && n7 > 0) && (s7.geometry = { count: n7, from: x4, allDirty: l8 }, m3 = true), (l8 || o7 !== t4 && i5 > 0) && (d5 = { count: i5, from: o7, allDirty: l8 }, m3 = true), m3 && e11({ indices: d5, vertices: s7 }, r10);
    }
  }
  markDirtyIndices(e11, r10, i5) {
    const o7 = this._dirties[e11], n7 = r10, x4 = i5;
    if (!o7.allDirty)
      if (o7.indexCount !== t4) {
        const t11 = Math.min(o7.indexFrom, n7), e12 = Math.max(o7.indexFrom + o7.indexCount, n7 + x4) - t11;
        o7.indexFrom = t11, o7.indexCount = e12;
      } else
        o7.indexFrom = n7, o7.indexCount = x4;
  }
  markDirtyVertices(e11, r10, i5, o7) {
    const n7 = this._dirties[e11], x4 = i5, l8 = o7;
    if (!n7.allDirty)
      if (n7.vertexCount !== t4) {
        const t11 = Math.min(n7.vertexFrom, x4), e12 = Math.max(n7.vertexFrom + n7.vertexCount, x4 + l8) - t11;
        n7.vertexFrom = t11, n7.vertexCount = e12;
      } else
        n7.vertexFrom = x4, n7.vertexCount = l8;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/FreeList.js
var e6 = class {
  constructor(e11) {
    this._largestRange = null, this._parent = e11, this._updateLargestRange();
  }
  get largestRange() {
    return this._largestRange;
  }
  rangeCreated(e11) {
    (!this._largestRange || e11.count > this._largestRange.count) && (this._largestRange = e11);
  }
  rangeResized(e11, t11) {
    e11 === this._largestRange ? e11.count < t11 && this._updateLargestRange() : (!this._largestRange || e11.count > this._largestRange.count) && (this._largestRange = e11);
  }
  findBestRange(e11) {
    let t11 = this._parent._freeHead, n7 = null;
    for (; null !== t11; )
      t11.count >= e11 && (!n7 || t11.count - e11 < n7.count - e11) && (n7 = t11), t11 = t11.next;
    return n7;
  }
  findAdjacentRanges(e11, t11) {
    let n7 = true, r10 = false, s7 = null, o7 = this._parent._freeHead;
    for (; n7 && !r10; ) {
      const a4 = null !== s7 ? s7.from + s7.count : 0, l8 = null !== o7 ? o7.from : this._parent._size;
      e11 >= a4 && e11 + t11 <= l8 ? (n7 = false, r10 = true) : null !== o7 ? (s7 = o7, o7 = o7.next) : n7 = false;
    }
    return [s7, o7];
  }
  _updateLargestRange() {
    let e11 = null, t11 = this._parent._freeHead;
    for (; null !== t11; )
      (!e11 || t11.count > e11.count) && (e11 = t11), t11 = t11.next;
    this._largestRange = e11;
  }
};
var t5 = class {
  constructor(t11, n7) {
    this._allocated = 0, this._size = t11, this._freeHead = t11 > 0 ? { from: 0, count: t11, prev: null, next: null } : null, this._bookKeeper = n7 || new e6(this), this._freeHead && this._bookKeeper.rangeCreated(this._freeHead);
  }
  allocate(e11) {
    const n7 = this._bookKeeper.findBestRange(e11);
    if (null === n7)
      return -1;
    const r10 = n7.from, s7 = n7.count;
    if (n7.from += e11, n7.count -= e11, this._bookKeeper.rangeResized(n7, r10, s7), this._allocated += e11, 0 === n7.count) {
      const e12 = null !== n7.prev ? this._freeHead : n7.next;
      t5._removeRange(n7), this._freeHead = e12;
    }
    return r10;
  }
  free(e11, n7) {
    const [r10, s7] = this._bookKeeper.findAdjacentRanges(e11, n7), o7 = { from: e11, count: n7, prev: r10, next: s7 };
    if (null !== r10 && (r10.next = o7), null !== s7 && (s7.prev = o7), this._bookKeeper.rangeCreated(o7), this._allocated -= n7, null !== s7 && o7.from + o7.count === s7.from) {
      const e12 = o7.from, n8 = o7.count;
      t5._fuse(o7, s7), t5._removeRange(s7), this._bookKeeper.rangeResized(o7, e12, n8), this._bookKeeper.rangeResized(s7, void 0, 0);
    }
    if (null !== r10 && r10.from + r10.count === o7.from) {
      const e12 = r10.from, n8 = r10.count;
      t5._fuse(r10, o7), t5._removeRange(o7), this._bookKeeper.rangeResized(r10, e12, n8), this._bookKeeper.rangeResized(o7, void 0, 0);
    }
    this._freeHead = null !== o7.prev ? this._freeHead : o7;
  }
  get fragmentation() {
    const e11 = this._size - this._allocated;
    if (0 === e11)
      return 0;
    return 1 - this._bookKeeper.largestRange.count / e11;
  }
  static _removeRange(e11) {
    null !== e11.prev ? null !== e11.next ? (e11.prev.next = e11.next, e11.next.prev = e11.prev) : e11.prev.next = null : null !== e11.next && (e11.next.prev = null);
  }
  static _fuse(e11, t11) {
    e11.count += t11.count, e11.next = t11.next, t11.from += t11.count, t11.count = 0, null !== t11.next && (t11.next.prev = e11);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/DisplayRecordStore.js
var s4 = ["FILL", "LINE", "MARKER", "TEXT", "LABEL"];
function o3(e11) {
  const t11 = e11.getStrides(), r10 = {};
  for (let i5 = 0; i5 < t11.length; i5++)
    r10[s4[i5]] = t11[i5];
  return r10;
}
var n4 = 0.5;
var d2 = class {
  constructor(r10, i5, s7, o7) {
    this._strides = r10, this._displayList = i5, this._freeListsAndStorage = {}, this._dirtyMap = null, this._dirtyMap = s7;
    for (const n7 in r10) {
      this._freeListsAndStorage[n7] = { vtxFreeList: o7 ? new t5(o7) : null, idxFreeList: o7 ? new t5(o7) : null, vertexBuffers: {}, indexBuffer: o7 ? new Uint32Array(o7) : null };
      for (const e11 in r10[n7])
        this._freeListsAndStorage[n7].vertexBuffers[e11] = { data: o7 ? K(o7, r10[n7][e11]) : null, stride: r10[n7][e11] };
    }
  }
  static fromTileData(t11, i5) {
    const n7 = o3(t11), a4 = [0, 0, 0, 0, 0], x4 = [0, 0, 0, 0, 0], u5 = t11.tileDisplayData.displayObjects;
    for (const e11 of u5)
      for (const t12 of e11.displayRecords)
        a4[t12.geometryType] = Math.max(a4[t12.geometryType], t12.vertexFrom + t12.vertexCount), x4[t12.geometryType] = Math.max(x4[t12.geometryType], t12.indexFrom + t12.indexCount);
    const f9 = new d2(n7, t11.tileDisplayData.displayList, i5, null);
    for (let o7 = 0; o7 < t11.tileBufferData.geometries.length; ++o7) {
      const i6 = a4[o7], n8 = x4[o7], d5 = t11.tileBufferData.geometries[o7], u6 = s4[o7], l8 = f9._storageFor(u6), c5 = t11.tileBufferData.geometries[o7].indexBuffer;
      let m3;
      l8.indexBuffer = c5, l8.idxFreeList = new t5(c5.length), l8.idxFreeList.allocate(n8);
      for (const e11 in d5.vertexBuffer) {
        const i7 = t11.tileBufferData.geometries[o7].vertexBuffer[e11];
        l8.vertexBuffers[e11].data = i7.data, l8.vertexBuffers[e11].stride = i7.stride;
        const s7 = X(i7.stride), n9 = i7.data.length * s7 / i7.stride;
        m3 || (m3 = n9);
      }
      l8.vtxFreeList = new t5(m3), l8.vtxFreeList.allocate(i6);
    }
    return f9;
  }
  delete(e11) {
    const t11 = s4[e11.geometryType];
    this._freeVertices(t11, e11.vertexFrom, e11.vertexCount), this._freeIndices(t11, e11.indexFrom, e11.indexCount), this._displayList.removeFromList(e11), e11.vertexFrom = void 0, e11.indexFrom = void 0;
  }
  setMeshData(e11, t11, r10, o7, n7) {
    const d5 = s4[e11.geometryType];
    let a4, x4;
    e11.meshData = null, void 0 === e11.vertexFrom ? (x4 = t11.vertexCount, a4 = this._allocateVertices(d5, x4)) : t11.vertexCount > e11.vertexCount ? (this._freeVertices(d5, e11.vertexFrom, e11.vertexCount), x4 = t11.vertexCount, a4 = this._allocateVertices(d5, x4)) : t11.vertexCount === e11.vertexCount ? (a4 = e11.vertexFrom, x4 = e11.vertexCount) : (this._freeVertices(d5, e11.vertexFrom + t11.vertexCount, e11.vertexCount - t11.vertexCount), a4 = e11.vertexFrom, x4 = t11.vertexCount);
    let u5, f9, l8, c5 = true;
    if (void 0 === e11.indexFrom ? (u5 = n7, l8 = t11.indexCount, f9 = this._allocateIndices(d5, l8)) : t11.indexCount > e11.indexCount ? (u5 = this._displayList.removeFromList(e11), this._freeIndices(d5, e11.indexFrom, e11.indexCount), l8 = t11.indexCount, f9 = this._allocateIndices(d5, l8)) : t11.indexCount === e11.indexCount ? (c5 = false, f9 = e11.indexFrom, l8 = e11.indexCount) : (u5 = this._displayList.removeFromList(e11), this._freeIndices(d5, e11.indexFrom + t11.indexCount, e11.indexCount - t11.indexCount), f9 = e11.indexFrom, l8 = t11.indexCount), -1 !== a4 && -1 !== f9) {
      const s7 = this._storageFor(d5);
      if (ae(a4, f9, s7.vertexBuffers, s7.indexBuffer, t11, r10, o7), e11.vertexFrom = a4, e11.indexFrom = f9, e11.vertexCount = t11.vertexCount, e11.indexCount = t11.indexCount, this._dirtyMap) {
        this._dirtyMap.markDirtyIndices(e11.geometryType, e11.indexFrom, e11.indexCount);
        for (const t12 in r10)
          this._dirtyMap.markDirtyVertices(e11.geometryType, t12, e11.vertexFrom, e11.vertexCount);
      }
      return c5 && this._displayList.addToList(e11, u5), true;
    }
    return -1 !== a4 && this._freeVertices(d5, a4, x4), -1 !== f9 && this._freeIndices(d5, f9, l8), e11.setMeshDataFromBuffers(t11, r10, o7), e11.vertexFrom = void 0, e11.vertexCount = 0, e11.indexFrom = void 0, e11.indexCount = 0, false;
  }
  tryAddMeshData(e11, t11) {
    const r10 = t11.vertexBuffer, o7 = t11.indexBuffer, n7 = s4[e11.geometryType], d5 = this._allocateVertices(n7, e11.vertexCount);
    if (-1 === d5)
      return this._freeVertices(n7, d5, e11.vertexCount), false;
    const a4 = this._allocateIndices(n7, e11.indexCount);
    if (-1 === a4)
      return this._freeVertices(n7, d5, e11.vertexCount), this._freeIndices(n7, a4, e11.indexCount), false;
    const x4 = this._storageFor(n7);
    if (ae(d5, a4, x4.vertexBuffers, x4.indexBuffer, e11, r10, o7), e11.vertexFrom = d5, e11.indexFrom = a4, this._dirtyMap) {
      this._dirtyMap.markDirtyIndices(e11.geometryType, e11.indexFrom, e11.indexCount);
      for (const t12 in r10)
        this._dirtyMap.markDirtyVertices(e11.geometryType, t12, d5, e11.vertexCount);
    }
    return this._displayList.addToList(e11), true;
  }
  _allocateVertices(e11, t11) {
    const r10 = this._storageFor(e11), i5 = r10.vtxFreeList.allocate(t11);
    if (-1 === i5)
      return -1;
    return r10.vtxFreeList.fragmentation > n4 ? -1 : i5;
  }
  _freeVertices(e11, t11, r10) {
    this._storageFor(e11).vtxFreeList.free(t11, r10);
  }
  _freeIndices(e11, t11, r10) {
    this._storageFor(e11).idxFreeList.free(t11, r10);
  }
  _allocateIndices(e11, t11) {
    const r10 = this._storageFor(e11), i5 = r10.idxFreeList.allocate(t11);
    if (-1 === i5)
      return -1;
    return r10.idxFreeList.fragmentation > n4 ? -1 : i5;
  }
  _storageFor(e11) {
    return this._freeListsAndStorage[e11];
  }
  _stridesFor(e11, t11) {
    return this._strides[e11][t11];
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/WGLBuffers.js
var f5 = class {
  constructor(a4) {
    this.geometryMap = ie(() => ({ indexBuffer: E3.createIndex(a4, F.STATIC_DRAW), vao: null }), (e11, s7) => ({ vertexBuffer: E3.createVertex(a4, se[s7]) }));
  }
  dispose() {
    for (let e11 = 0; e11 < 5; e11++) {
      const t11 = this.geometryMap[e11];
      if (t11) {
        t11.data.vao && t11.data.vao.dispose(false), t11.data.indexBuffer && t11.data.indexBuffer.dispose();
        for (const e12 in t11.buffers)
          t11.buffers[e12] && t11.buffers[e12].data.vertexBuffer.dispose();
      }
    }
  }
  get(e11) {
    const t11 = this.geometryMap[e11];
    return { getVAO(e12, r10, s7) {
      if (!t11.data.vao) {
        const f9 = {};
        for (const e13 in t11.buffers)
          f9[e13] = t11.buffers[e13].data.vertexBuffer;
        t11.data.vao = new a2(e12, s7, r10, f9, t11.data.indexBuffer);
      }
      return t11.data.vao;
    } };
  }
  has(e11) {
    return null != this.geometryMap[e11];
  }
  upload(e11, t11) {
    t11.forEach((t12, r10) => {
      this._upload(t12, r10, e11);
    });
  }
  _upload(e11, t11, r10) {
    if (e11.indices && (e11.indices.allDirty ? this._uploadIndices(r10, t11) : null != e11.indices.from && null != e11.indices.count && this._uploadIndices(r10, t11, e11.indices.from, e11.indices.count)), e11.vertices) {
      const s7 = e11.vertices;
      for (const e12 in s7) {
        const a4 = s7[e12];
        a4.allDirty ? this._uploadVertices(r10, t11, e12) : null != a4.from && null != a4.count && this._uploadVertices(r10, t11, e12, a4.from, a4.count);
      }
    }
  }
  _uploadVertices(e11, t11, r10, s7, a4) {
    const f9 = this.geometryMap[t11];
    if (!f9)
      return;
    const o7 = e11.geometries[t11].vertexBuffer[r10];
    if (!o7)
      return;
    const { data: i5, stride: n7 } = o7;
    if (f9.buffers[r10] && i5.length > 0) {
      const e12 = n7 / i5.BYTES_PER_ELEMENT;
      null != s7 && null != a4 ? f9.buffers[r10].data.vertexBuffer.setSubData(i5, s7 * e12, s7 * e12, (s7 + a4) * e12) : f9.buffers[r10].data.vertexBuffer.setData(i5);
    }
  }
  _uploadIndices(e11, t11, r10, s7) {
    const a4 = this.geometryMap[t11];
    if (!a4)
      return;
    const f9 = e11.geometries[t11].indexBuffer;
    a4.data.indexBuffer && f9.length > 0 && (null != r10 && null != s7 ? a4.data.indexBuffer.setSubData(f9, r10, r10, r10 + s7) : a4.data.indexBuffer.setData(f9));
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/GraphicTile.js
var a3 = class extends m2 {
  constructor() {
    super(...arguments), this._data = null, this._displayList = null, this._lastCommitTime = 0, this._hasData = false, this._invalidated = false, this._wglBuffers = null, this._dirtyMap = new e5();
  }
  destroy() {
    super.destroy(), this.clear();
  }
  get hasData() {
    return !!this._hasData;
  }
  get displayObjects() {
    var _a2;
    return (_a2 = this._displayObjects) != null ? _a2 : [];
  }
  getGeometry(t11) {
    return this._wglBuffers && this._wglBuffers.has(t11) ? this._wglBuffers.get(t11) : null;
  }
  getDisplayList() {
    return this._displayList;
  }
  patch(e11) {
    if (true === e11.clear)
      return this.clear(), void (this._hasData = false);
    const i5 = e11.addOrUpdate, a4 = e11.remove;
    !this._data && i5 && i5.tileDisplayData.displayObjects.length ? (i5.tileDisplayData.computeDisplayList(), this._dirtyMap = new e5(), this._dispRecStore = d2.fromTileData(i5, this._dirtyMap), this._data = i5, this._dirtyMap.markAllDirty(), this._hasData = true, e11.end && this.ready()) : this._data && (i5 && i5.tileDisplayData.displayObjects.length || a4.length) ? this._doPatchData(e11) : e11.end && this.ready(), e11.end && !this._data && this.clear(), this.requestRender(), this.emit("change");
  }
  commit(t11) {
    t11.time && t11.time === this._lastCommitTime || (this._lastCommitTime = t11.time, this.visible && this._data && (this._wglBuffers || (this._wglBuffers = new f5(t11.context)), (this._dirtyMap.hasDirty() || this._invalidated) && (this._invalidated = false, this._wglBuffers.upload(this._data.tileBufferData, this._dirtyMap), this._displayList = this._data.tileDisplayData.displayList.clone(), this._displayObjects = this._data.tileDisplayData.displayObjects.slice(), this._dirtyMap.markAllClean())));
  }
  clear() {
    this._data = null, this._displayList = null, this._dispRecStore = null, this._wglBuffers && (this._wglBuffers.dispose(), this._wglBuffers = null);
  }
  _doPatchData(t11) {
    this._invalidated = true, this._patchData(t11) || (this._dirtyMap.markAllDirty(), this._data.reshuffle(), this._dispRecStore = d2.fromTileData(this._data, this._dirtyMap)), this.requestRender();
  }
  _patchData(t11) {
    let s7 = true;
    const e11 = t11.addOrUpdate && t11.addOrUpdate.tileDisplayData && t11.addOrUpdate.tileDisplayData.displayObjects || [], i5 = (t11.remove || []).slice();
    for (const l8 of e11)
      null != l8.insertAfter && i5.push(l8.id);
    let a4;
    i5.length > 0 && (a4 = new Set(i5));
    for (const l8 of i5) {
      const t12 = this._data.tileDisplayData.displayObjectRegistry.get(l8);
      if (t12) {
        this._data.tileDisplayData.displayList.removeFromList(t12.displayRecords);
        for (const s8 of t12.displayRecords)
          this._dispRecStore.delete(s8);
        this._data.tileDisplayData.displayObjectRegistry.delete(l8);
      }
    }
    a4 && a4.size && (this._data.tileDisplayData.displayObjects = this._data.tileDisplayData.displayObjects.filter((t12) => !a4.has(t12.id)));
    for (const l8 of e11) {
      let e12, i6 = this._data.tileDisplayData.displayObjectRegistry.get(l8.id);
      if (i6) {
        const t12 = i6.displayRecords;
        i6.set(l8), i6.displayRecords = t12;
        const s8 = i6.displayRecords.length;
        for (let e13 = 0; e13 < s8; ++e13) {
          const t13 = i6.displayRecords[e13], s9 = l8.displayRecords[e13];
          (e13 >= l8.displayRecords.length || t13.geometryType !== s9.geometryType || t13.symbolLevel !== s9.symbolLevel || t13.zOrder !== s9.zOrder || t13.materialKey !== s9.materialKey) && (this._dispRecStore.delete(i6.displayRecords[e13]), e13 < l8.displayRecords.length && (i6.displayRecords[e13] = void 0));
        }
        i6.displayRecords.length = l8.displayRecords.length;
      } else {
        let t12;
        i6 = l8.copy(), i6.displayRecords = [], this._data.tileDisplayData.displayObjectRegistry.set(l8.id, i6);
        const s8 = this._data.tileDisplayData.displayObjects;
        if (null != i6.insertAfter)
          if (e12 = {}, i6.insertAfter >= 0) {
            const e13 = this._data.tileDisplayData.displayObjectRegistry.get(i6.insertAfter);
            e13 ? (t12 = s8.indexOf(e13) + 1, t12 < s8.length ? s8.splice(t12, 0, i6) : (s8.push(i6), t12 = s8.length)) : (s8.push(i6), t12 = s8.length);
          } else
            s8.unshift(i6), t12 = 0;
        else
          s8.push(i6), t12 = s8.length;
        if (e12) {
          const i7 = l8.displayRecords.length > 0 ? 1 : 0;
          let a6 = 0;
          for (let l9 = t12 - 1; l9 >= 0 && a6 < i7; --l9)
            for (let t13 = s8[l9].displayRecords.length - 1; t13 >= 0 && a6 < i7; --t13) {
              const i8 = s8[l9].displayRecords[t13], d5 = this._data.tileDisplayData.displayList.getDPInfoType();
              e12[d5] || (e12[d5] = i8, ++a6);
            }
        }
      }
      const a5 = l8.displayRecords.length;
      for (let d5 = 0; d5 < a5; ++d5) {
        const a6 = l8.displayRecords[d5];
        let r10 = i6.displayRecords[d5];
        r10 ? (r10.meshData = a6.meshData, r10.materialKey = a6.materialKey) : (r10 = a6.copy(), r10.vertexFrom = void 0, r10.indexFrom = void 0, i6.displayRecords[d5] = r10);
        const h4 = a6.geometryType, p4 = this._data.tileDisplayData.displayList.getDPInfoType(), o7 = t11.addOrUpdate.tileBufferData.geometries[h4], y7 = o7.vertexBuffer, c5 = o7.indexBuffer;
        let n7;
        e12 && (n7 = e12[p4] ? this._data.tileDisplayData.displayList.splitAfter(e12[p4]) : -1), s7 = this._dispRecStore.setMeshData(r10, a6, y7, c5, n7) && s7, e12 && null != r10.indexFrom && null != r10.indexFrom && (e12[p4] = r10);
      }
    }
    return s7;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/MemoryRequirements.js
var e7 = class {
  constructor() {
    this._byGeometryType = null;
  }
  get satisfied() {
    return !this._byGeometryType;
  }
  reset() {
    this._byGeometryType = null;
  }
  verticesFor(e11) {
    return this._byGeometryType ? this._byGeometryType[e11].vertices : 0;
  }
  indicesFor(e11) {
    return this._byGeometryType ? this._byGeometryType[e11].indices : 0;
  }
  needMore(e11, t11, i5) {
    if (!t11 && !i5)
      return;
    this._byGeometryType || (this._byGeometryType = [{ vertices: 0, indices: 0 }, { vertices: 0, indices: 0 }, { vertices: 0, indices: 0 }, { vertices: 0, indices: 0 }, { vertices: 0, indices: 0 }]);
    const s7 = this._byGeometryType[e11];
    s7.vertices += t11, s7.indices += i5;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/TileBufferData.js
var r7 = 5;
var f6 = class {
  constructor() {
    this.geometries = [{ indexBuffer: void 0, vertexBuffer: {} }, { indexBuffer: void 0, vertexBuffer: {} }, { indexBuffer: void 0, vertexBuffer: {} }, { indexBuffer: void 0, vertexBuffer: {} }, { indexBuffer: void 0, vertexBuffer: {} }];
  }
  clone() {
    const e11 = new f6();
    for (let r10 = 0; r10 < this.geometries.length; r10++) {
      const f9 = this.geometries[r10], t11 = e11.geometries[r10];
      t11.indexBuffer = f9.indexBuffer.slice(), t11.vertexBuffer = {};
      for (const e12 in f9.vertexBuffer) {
        const { data: r11, stride: i5 } = f9.vertexBuffer[e12];
        t11.vertexBuffer[e12] = { data: r11.slice(), stride: i5 };
      }
    }
    return e11;
  }
  static deserialize(t11) {
    const i5 = new f6();
    for (let f9 = 0; f9 < r7; ++f9) {
      i5.geometries[f9].indexBuffer = new Uint32Array(t11.geometries[f9].indexBuffer), i5.geometries[f9].vertexBuffer = {};
      for (const r10 in t11.geometries[f9].vertexBuffer)
        i5.geometries[f9].vertexBuffer[r10] = { data: W(t11.geometries[f9].vertexBuffer[r10].data, t11.geometries[f9].vertexBuffer[r10].stride), stride: t11.geometries[f9].vertexBuffer[r10].stride };
    }
    return i5;
  }
  serialize() {
    const e11 = { geometries: [{ indexBuffer: this.geometries[0].indexBuffer.buffer, vertexBuffer: {} }, { indexBuffer: this.geometries[1].indexBuffer.buffer, vertexBuffer: {} }, { indexBuffer: this.geometries[2].indexBuffer.buffer, vertexBuffer: {} }, { indexBuffer: this.geometries[3].indexBuffer.buffer, vertexBuffer: {} }, { indexBuffer: this.geometries[4].indexBuffer.buffer, vertexBuffer: {} }] };
    for (let f9 = 0; f9 < r7; ++f9)
      for (const r10 in this.geometries[f9].vertexBuffer)
        e11.geometries[f9].vertexBuffer[r10] = { data: this.geometries[f9].vertexBuffer[r10].data.buffer, stride: this.geometries[f9].vertexBuffer[r10].stride };
    return e11;
  }
  getBuffers() {
    const e11 = [];
    for (let f9 = 0; f9 < r7; ++f9) {
      e11.push(this.geometries[f9].indexBuffer.buffer);
      for (const r10 in this.geometries[f9].vertexBuffer)
        e11.push(this.geometries[f9].vertexBuffer[r10].data.buffer);
    }
    return e11;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/GraphicDisplayList.js
function t6(e11, t11, n7, ...o7) {
  t11 < e11.length ? e11.splice(t11, n7, ...o7) : e11.push(...o7);
}
var n5 = class {
  constructor() {
    this.symbolLevels = [];
  }
  replay(t11, n7, o7) {
    for (const i5 of this.symbolLevels)
      for (const r10 of i5.zLevels) {
        const i6 = r10.geometryDPInfo.unified;
        if (i6)
          for (const r11 of i6) {
            const { geometryType: i7, materialKey: l8, indexFrom: s7, indexCount: m3 } = r11, y7 = U4.load(l8).symbologyType, d5 = t11.painter.getBrush(i7, y7), u5 = { geometryType: i7, materialKey: l8, indexFrom: s7, indexCount: m3, target: n7.getGeometry(i7) };
            d5.prepareState(t11), d5.drawGeometry(t11, n7, u5, o7);
          }
      }
  }
  get empty() {
    return !this.symbolLevels || 0 === this.symbolLevels.length;
  }
  clear() {
    this.symbolLevels.length = 0;
  }
  addToList(e11, t11) {
    if (Array.isArray(e11))
      for (const n7 of e11)
        this._addToList(n7, t11);
    else
      this._addToList(e11, t11);
  }
  removeFromList(e11) {
    Array.isArray(e11) || (e11 = [e11]);
    let t11 = null;
    for (const n7 of e11)
      t11 = this._removeFromList(n7);
    return t11;
  }
  clone() {
    const e11 = new n5();
    for (const t11 of this.symbolLevels)
      e11.symbolLevels.push(t11.clone());
    return e11;
  }
  splitAfter(e11) {
    const t11 = this._getDisplayList(e11.symbolLevel, e11.zOrder), n7 = t11.length, i5 = e11.indexFrom + e11.indexCount;
    for (let r10 = 0; r10 < n7; ++r10) {
      const n8 = t11[r10];
      if (n8.geometryType === e11.geometryType && i5 > n8.indexFrom && i5 <= n8.indexFrom + n8.indexCount) {
        if (i5 < n8.indexFrom + n8.indexCount) {
          const e12 = new o4();
          e12.geometryType = n8.geometryType, e12.materialKey = n8.materialKey, e12.indexFrom = i5, e12.indexCount = n8.indexFrom + n8.indexCount - i5, t11.splice(r10 + 1, 0, e12), n8.indexCount = i5 - n8.indexFrom;
        }
        return r10;
      }
    }
  }
  _addToList(e11, n7) {
    const i5 = e11.symbolLevel, r10 = e11.zOrder, l8 = this._getDisplayList(i5, r10), s7 = null != n7 ? n7 : l8.length - 1, m3 = s7 >= 0 && s7 < l8.length ? l8[s7] : null;
    if (null !== m3 && m3.materialKey === e11.materialKey && m3.indexFrom + m3.indexCount === e11.indexFrom && m3.geometryType === e11.geometryType)
      m3.indexCount += e11.indexCount;
    else {
      const n8 = new o4();
      n8.indexFrom = e11.indexFrom, n8.indexCount = e11.indexCount, n8.materialKey = e11.materialKey, n8.geometryType = e11.geometryType, t6(l8, s7 + 1, 0, n8);
    }
  }
  _removeFromList(e11) {
    const n7 = e11.symbolLevel, i5 = e11.zOrder, r10 = this._getDisplayList(n7, i5), l8 = r10.length;
    let s7;
    for (let t11 = 0; t11 < l8; ++t11) {
      const n8 = r10[t11];
      if (e11.indexFrom + e11.indexCount > n8.indexFrom && e11.indexFrom < n8.indexFrom + n8.indexCount && n8.geometryType === e11.geometryType) {
        s7 = t11;
        break;
      }
    }
    if (void 0 !== s7) {
      const n8 = r10[s7];
      if (e11.indexFrom === n8.indexFrom)
        return n8.indexCount -= e11.indexCount, n8.indexFrom += e11.indexCount, 0 === n8.indexCount && t6(r10, s7, 1), s7 - 1;
      if (e11.indexFrom + e11.indexCount === n8.indexFrom + n8.indexCount)
        return n8.indexCount -= e11.indexCount, 0 === n8.indexCount ? (t6(r10, s7, 1), s7 - 1) : s7;
      {
        const i6 = n8.indexFrom, l9 = e11.indexFrom - n8.indexFrom, m3 = e11.indexCount, y7 = n8.indexFrom + n8.indexCount - (e11.indexFrom + e11.indexCount);
        n8.indexCount = l9;
        const d5 = new o4();
        return d5.geometryType = n8.geometryType, d5.materialKey = n8.materialKey, d5.indexFrom = i6 + l9 + m3, d5.indexCount = y7, t6(r10, s7 + 1, 0, d5), s7;
      }
    }
    return null;
  }
  _getDisplayList(e11, t11) {
    let n7;
    const o7 = this.symbolLevels.length;
    for (let i5 = 0; i5 < o7; i5++)
      if (this.symbolLevels[i5].symbolLevel === e11) {
        n7 = this.symbolLevels[i5];
        break;
      }
    let s7;
    n7 || (n7 = new l7(), n7.symbolLevel = e11, this.symbolLevels.push(n7));
    const m3 = n7.zLevels.length;
    for (let i5 = 0; i5 < m3; i5++)
      if (n7.zLevels[i5].zLevel === t11) {
        s7 = n7.zLevels[i5];
        break;
      }
    return s7 || (s7 = new r8(), s7.geometryDPInfo = new i4(), s7.zLevel = t11, n7.zLevels.push(s7)), s7.geometryDPInfo.unified || (s7.geometryDPInfo.unified = []), s7.geometryDPInfo.unified;
  }
  getDPInfoType() {
    return "unified";
  }
};
var o4 = class {
  constructor() {
    this.materialKey = null, this.indexFrom = 0, this.indexCount = 0;
  }
  clone() {
    const e11 = new o4();
    return e11.geometryType = this.geometryType, e11.materialKey = this.materialKey, e11.indexFrom = this.indexFrom, e11.indexCount = this.indexCount, e11;
  }
};
var i4 = class {
  constructor() {
    this.fill = null, this.line = null, this.marker = null, this.text = null, this.label = null, this.unified = null;
  }
  clone() {
    const e11 = new i4();
    return e11.fill = this.fill && this.fill.map((e12) => e12.clone()), e11.line = this.line && this.line.map((e12) => e12.clone()), e11.marker = this.marker && this.marker.map((e12) => e12.clone()), e11.text = this.text && this.text.map((e12) => e12.clone()), e11.label = this.label && this.label.map((e12) => e12.clone()), e11.unified = this.unified && this.unified.map((e12) => e12.clone()), e11;
  }
};
var r8 = class {
  constructor() {
    this.geometryDPInfo = new i4();
  }
  clone() {
    const e11 = new r8();
    return e11.zLevel = this.zLevel, e11.geometryDPInfo = this.geometryDPInfo.clone(), e11;
  }
};
var l7 = class {
  constructor() {
    this.zLevels = [];
  }
  clone() {
    const e11 = new l7();
    e11.symbolLevel = this.symbolLevel;
    for (const t11 of this.zLevels)
      e11.zLevels.push(t11.clone());
    return e11;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/MeshData.js
var t7 = class {
  constructor() {
    this.vertexData = /* @__PURE__ */ new Map(), this.vertexCount = 0, this.indexData = [];
  }
  clear() {
    this.vertexData.clear(), this.vertexCount = 0, this.indexData = [];
  }
  update(t11, e11, a4) {
    for (const s7 in t11)
      this.vertexData.set(s7, t11[s7]);
    for (const s7 in this.vertexData)
      null === t11[s7] && this.vertexData.delete(s7);
    this.vertexCount = e11, this.indexData = a4;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/WGLDisplayRecord.js
var s5 = class {
  constructor(t11, e11, s7, r10 = 0, i5 = 0) {
    this.id = t11, this.geometryType = e11, this.materialKey = s7, this.minZoom = r10, this.maxZoom = i5, this.meshData = null, this.symbolLevel = 0, this.zOrder = 0, this.vertexFrom = 0, this.vertexCount = 0, this.indexFrom = 0, this.indexCount = 0;
  }
  get sortKey() {
    return void 0 === this._sortKey && this._computeSortKey(), this._sortKey;
  }
  clone() {
    return this.copy();
  }
  copy() {
    const t11 = new s5(this.id, this.geometryType, this.materialKey);
    return t11.vertexFrom = this.vertexFrom, t11.vertexCount = this.vertexCount, t11.indexFrom = this.indexFrom, t11.indexCount = this.indexCount, t11.zOrder = this.zOrder, t11.symbolLevel = this.symbolLevel, t11.meshData = this.meshData, t11.minZoom = this.minZoom, t11.maxZoom = this.maxZoom, t11;
  }
  setMeshDataFromBuffers(s7, r10, i5) {
    const o7 = new t7();
    for (const t11 in r10) {
      const i6 = r10[t11].stride, a4 = r10[t11].data, h4 = [], n7 = X(i6);
      for (let t12 = 0; t12 < i6 * s7.vertexCount / n7; ++t12)
        h4[t12] = a4[t12 + i6 * s7.vertexFrom / n7];
      o7.vertexData.set(t11, h4);
    }
    o7.indexData.length = 0;
    for (let t11 = 0; t11 < s7.indexCount; ++t11)
      o7.indexData[t11] = i5[t11 + s7.indexFrom] - s7.vertexFrom;
    o7.vertexCount = s7.vertexCount, this.meshData = o7;
  }
  readMeshDataFromBuffers(s7, r10) {
    this.meshData ? this.meshData.clear() : this.meshData = new t7();
    for (const t11 in s7) {
      const r11 = s7[t11].stride, i5 = s7[t11].data, o7 = [], a4 = X(r11);
      for (let t12 = 0; t12 < r11 * this.vertexCount / a4; ++t12)
        o7[t12] = i5[t12 + r11 * this.vertexFrom / a4];
      this.meshData.vertexData.set(t11, o7);
    }
    this.meshData.indexData.length = 0;
    for (let t11 = 0; t11 < this.indexCount; ++t11)
      this.meshData.indexData[t11] = r10[t11 + this.indexFrom] - this.vertexFrom;
    this.meshData.vertexCount = this.vertexCount;
  }
  writeMeshDataToBuffers(t11, s7, r10, i5) {
    for (const o7 in s7) {
      const r11 = s7[o7].stride, i6 = this.meshData.vertexData.get(o7), a4 = s7[o7].data, h4 = X(r11);
      for (let e11 = 0; e11 < r11 * this.meshData.vertexCount / h4; ++e11)
        a4[e11 + r11 * t11 / h4] = i6[e11];
    }
    for (let e11 = 0; e11 < this.meshData.indexData.length; ++e11)
      i5[e11 + r10] = this.meshData.indexData[e11] + t11;
    this.vertexFrom = t11, this.vertexCount = this.meshData.vertexCount, this.indexFrom = r10, this.indexCount = this.meshData.indexData.length;
  }
  static writeAllMeshDataToBuffers(t11, e11, s7) {
    let r10 = 0, i5 = 0;
    for (const o7 of t11)
      o7.writeMeshDataToBuffers(r10, e11, i5, s7), r10 += o7.vertexCount, i5 += o7.indexCount;
  }
  _computeSortKey() {
    this._sortKey = (31 & this.symbolLevel) << 12 | (127 & this.zOrder) << 4 | 7 & this.geometryType;
  }
  serialize(t11) {
    return t11.push(this.geometryType), t11.push(this.materialKey), t11.push(this.vertexFrom), t11.push(this.vertexCount), t11.push(this.indexFrom), t11.push(this.indexCount), t11.push(this.minZoom), t11.push(this.maxZoom), t11;
  }
  static deserialize(t11, e11) {
    const r10 = t11.readInt32(), i5 = t11.readInt32(), o7 = new s5(e11.id, r10, i5);
    return o7.vertexFrom = t11.readInt32(), o7.vertexCount = t11.readInt32(), o7.indexFrom = t11.readInt32(), o7.indexCount = t11.readInt32(), o7.minZoom = t11.readInt32(), o7.maxZoom = t11.readInt32(), o7;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/serializationUtils.js
function e8(e11, n7) {
  if (null !== n7) {
    e11.push(n7.length);
    for (const r10 of n7)
      r10.serialize(e11);
    return e11;
  }
  e11.push(0);
}
function n6(e11, n7, r10) {
  const t11 = e11.readInt32(), o7 = new Array(t11);
  for (let i5 = 0; i5 < o7.length; i5++)
    o7[i5] = n7.deserialize(e11, r10);
  return o7;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/WGLDisplayObject.js
var e9 = class {
  constructor(s7) {
    this.insertAfter = null, this.id = s7, this.displayRecords = [];
  }
  copy() {
    const s7 = new e9(this.id);
    return s7.set(this), s7;
  }
  clone() {
    const s7 = new e9(this.id);
    return s7.displayRecords = this.displayRecords.map((s8) => s8.clone()), s7.insertAfter = this.insertAfter, s7;
  }
  set(s7) {
    this.id = s7.id, this.displayRecords = s7.displayRecords, this.insertAfter = s7.insertAfter;
  }
  serialize(s7) {
    return s7.push(this.id), e8(s7, this.displayRecords), s7;
  }
  static deserialize(i5) {
    const r10 = i5.readInt32(), d5 = new e9(r10), o7 = { id: r10 };
    return d5.displayRecords = n6(i5, s5, o7), d5;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/TileDisplayData.js
var e10 = class {
  get displayObjectRegistry() {
    if (!this._displayObjectRegistry) {
      this._displayObjectRegistry = /* @__PURE__ */ new Map();
      for (const s7 of this.displayObjects)
        this._displayObjectRegistry.set(s7.id, s7);
    }
    return this._displayObjectRegistry;
  }
  get displayList() {
    return this._displayList;
  }
  computeDisplayList() {
    this._displayList = new n5();
    for (const s7 of this.displayObjects)
      for (const t11 of s7.displayRecords)
        this._displayList.addToList(t11);
  }
  clone() {
    const s7 = new e10();
    return this.displayObjects && (s7.displayObjects = this.displayObjects.map((s8) => s8.clone())), s7;
  }
  serialize(s7) {
    return e8(s7, this.displayObjects), s7;
  }
  _deserializeObjects(s7) {
    const i5 = s7.readInt32(), e11 = new Array(i5), a4 = /* @__PURE__ */ new Map();
    for (let l8 = 0; l8 < e11.length; ++l8) {
      const i6 = e9.deserialize(s7);
      e11[l8] = i6, a4.set(i6.id, i6);
    }
    this.displayObjects = e11, this._displayList = null, this._displayObjectRegistry = a4;
  }
  static deserialize(s7) {
    const t11 = new e10();
    return t11._deserializeObjects(s7), t11;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/VertexBuffer.js
var t8 = class {
  constructor(e11, t11) {
    this.data = e11, this.stride = t11;
  }
  static decode(r10) {
    const s7 = W(r10.data, r10.stride), n7 = r10.stride;
    return new t8(s7, n7);
  }
  static fromVertexVector(r10) {
    const s7 = W(r10.data.buffer(), r10.stride), n7 = r10.stride;
    return new t8(s7, n7);
  }
};
var r9 = class {
  constructor(e11, t11, r10) {
    this.geometryType = e11, this.indexBuffer = new Uint32Array(t11), this.namedBuffers = r10;
  }
  static decode(e11) {
    const s7 = e11.geometryType, n7 = e11.indexBuffer, o7 = {};
    for (const r10 in e11.namedBuffers)
      o7[r10] = t8.decode(e11.namedBuffers[r10]);
    return new r9(s7, n7, o7);
  }
  static fromVertexData(s7, n7) {
    const o7 = s7.indices, c5 = W(s7.vertices, s7.stride), i5 = s7.stride, d5 = { geometry: new t8(c5, i5) };
    return new r9(n7, o7, d5);
  }
  static fromVertexVectors(e11) {
    const s7 = e11.geometryType, n7 = e11.indexVector.buffer(), o7 = {};
    for (const r10 in e11.namedVectors)
      o7[r10] = t8.fromVertexVector(e11.namedVectors[r10]);
    return new r9(s7, n7, o7);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/VertexVector.js
var s6 = class {
  constructor(t11, e11) {
    this.data = t11, this.stride = e11;
  }
  get vertexCount() {
    const t11 = this.stride / 4, e11 = this.data.length / t11;
    return e11 !== (0 | e11) && console.debug("Corrupted stride"), e11;
  }
  transfer(t11, e11) {
    const r10 = this.data.buffer();
    t11.vertexCount = this.vertexCount, t11.data = r10, t11.stride = this.stride, e11.push(r10);
  }
};
var o5 = class {
  constructor(e11, o7, n7) {
    this.geometryType = e11, this.indexVector = new e4(Uint32Array, 6 * o7), this.namedVectors = {};
    const i5 = G(e11, n7);
    for (const t11 in i5) {
      const e12 = i5[t11];
      let n8;
      switch (e12 % 4) {
        case 0:
        case 2:
          n8 = new e4(Uint32Array, e12 * o7);
          break;
        case 1:
        case 3:
          n8 = new e4(Uint8Array, e12 * o7);
      }
      this.namedVectors[t11] = new s6(n8, e12);
    }
  }
  get(t11) {
    return this.namedVectors[t11].data;
  }
  getVector(t11) {
    return this.namedVectors[t11];
  }
  transfer(t11, e11) {
    const r10 = this.indexVector.buffer(), s7 = {};
    e11.push(r10);
    for (const o7 in this.namedVectors) {
      const t12 = this.namedVectors[o7];
      s7[o7] = {}, t12.transfer(s7[o7], e11);
    }
    t11.geometryType = this.geometryType, t11.indexBuffer = r10, t11.namedBuffers = s7, this.destroy();
  }
  intoBuffers() {
    const t11 = r9.fromVertexVectors(this);
    return this.destroy(), t11;
  }
  destroy() {
    this.indexVector = null, this.namedVectors = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/TileData.js
var D = new e7();
var d3 = new e7();
var p3 = 1.5;
var h3 = 5;
function x2(e11, t11) {
  const r10 = {};
  for (const s7 in e11) {
    const i5 = { data: K(t11, e11[s7]), stride: e11[s7] };
    r10[s7] = i5;
  }
  return r10;
}
function y4(e11) {
  return [e11.fill || {}, e11.line || {}, e11.icon || {}, e11.text || {}, e11.label || {}];
}
function B(e11) {
  const t11 = [[], [], [], [], []], r10 = e11;
  for (const s7 of r10)
    for (const e12 of s7.displayRecords)
      t11[e12.geometryType].push(e12);
  return t11;
}
var g4 = class {
  constructor() {
    this.tileDisplayData = null, this.tileBufferData = null;
  }
  reshuffle() {
    D.reset();
    const e11 = B(this.tileDisplayData.displayObjects);
    for (const s7 of e11)
      for (const e12 of s7)
        e12 && D.needMore(e12.geometryType, e12.meshData ? e12.meshData.vertexCount : e12.vertexCount, e12.meshData ? e12.meshData.indexData.length : e12.indexCount);
    const t11 = e11.length, r10 = new f6();
    for (let s7 = 0; s7 < t11; ++s7) {
      r10.geometries[s7].indexBuffer = new Uint32Array(Math.round(p3 * D.indicesFor(s7)));
      const e12 = [];
      for (const r11 in this.tileBufferData.geometries[s7].vertexBuffer)
        e12.push(this.tileBufferData.geometries[s7].vertexBuffer[r11].stride);
      const t12 = g4._computeVertexAlignment(e12), i5 = Math.round(p3 * D.verticesFor(s7)), a4 = g4._align(i5, t12);
      for (const f9 in this.tileBufferData.geometries[s7].vertexBuffer) {
        const e13 = this.tileBufferData.geometries[s7].vertexBuffer[f9].stride;
        r10.geometries[s7].vertexBuffer[f9] = { stride: e13, data: K(a4, e13) };
      }
    }
    d3.reset(), this.tileDisplayData.displayList.clear();
    for (let s7 = 0; s7 < t11; ++s7) {
      const t12 = e11[s7];
      for (const e12 of t12) {
        if (e12.meshData)
          e12.writeMeshDataToBuffers(d3.verticesFor(s7), r10.geometries[s7].vertexBuffer, d3.indicesFor(s7), r10.geometries[s7].indexBuffer), e12.meshData = null;
        else {
          const t13 = this.tileBufferData.geometries[s7].vertexBuffer, i5 = this.tileBufferData.geometries[s7].indexBuffer, o7 = r10.geometries[s7].vertexBuffer, f9 = r10.geometries[s7].indexBuffer, n7 = d3.verticesFor(s7), l8 = d3.indicesFor(s7);
          ae(n7, l8, o7, f9, e12, t13, i5), e12.vertexFrom = n7, e12.indexFrom = l8;
        }
        d3.needMore(s7, e12.vertexCount, e12.indexCount);
      }
    }
    for (const s7 of this.tileDisplayData.displayObjects)
      this.tileDisplayData.displayList.addToList(s7.displayRecords);
    this.tileBufferData = r10;
  }
  getStrides() {
    const e11 = [];
    for (let t11 = 0; t11 < this.tileBufferData.geometries.length; ++t11) {
      const r10 = this.tileBufferData.geometries[t11];
      e11[t11] = {};
      for (const s7 in r10.vertexBuffer)
        e11[t11][s7] = r10.vertexBuffer[s7].stride;
    }
    return e11;
  }
  clone() {
    const e11 = new g4();
    return e11.tileBufferData = this.tileBufferData.clone(), e11.tileDisplayData = this.tileDisplayData.clone(), e11;
  }
  _guessSize() {
    const { displayObjects: e11 } = this.tileDisplayData, t11 = Math.min(e11.length, 4), r10 = 12, s7 = 40;
    let i5 = 0;
    for (let o7 = 0; o7 < t11; o7++)
      i5 = Math.max(i5, e11[o7].displayRecords.length);
    return 2 * (e11.length * r10 + e11.length * i5 * s7);
  }
  serialize() {
    const e11 = this.tileBufferData.serialize(), t11 = this.tileBufferData.getBuffers(), r10 = this.tileDisplayData.serialize(new e4(Int32Array, this._guessSize())).buffer();
    return t11.push(r10), { result: { displayData: r10, bufferData: e11 }, transferList: t11 };
  }
  static fromVertexData(r10, s7) {
    const i5 = {}, o7 = /* @__PURE__ */ new Map();
    for (const e11 of s7)
      o7.set(e11.id, e11);
    return he((s8) => {
      const a4 = r10.data[s8];
      if (r(a4)) {
        const e11 = i3.from(a4.records).getCursor();
        for (; e11.next(); ) {
          const t11 = e11.id, r11 = e11.materialKey, i6 = e11.indexFrom, a5 = e11.indexCount, f9 = e11.vertexFrom, l8 = e11.vertexCount, u5 = o7.get(t11), c5 = new s5(t11, s8, r11);
          c5.indexFrom = i6, c5.indexCount = a5, c5.vertexFrom = f9, c5.vertexCount = l8, u5.displayRecords.push(c5);
        }
        i5[s8] = r9.fromVertexData(a4, s8);
      } else
        i5[s8] = new o5(s8, 0, S.DEFAULT).intoBuffers();
    }), g4.fromMeshData({ displayObjects: s7, vertexBuffersMap: i5 });
  }
  static fromMeshData(e11) {
    const t11 = new g4(), r10 = new e10(), o7 = new f6();
    r10.displayObjects = e11.displayObjects;
    for (const s7 in e11.vertexBuffersMap) {
      const t12 = e11.vertexBuffersMap[s7];
      o7.geometries[s7].indexBuffer = t12.indexBuffer, o7.geometries[s7].vertexBuffer = t12.namedBuffers;
    }
    return t11.tileDisplayData = r10, t11.tileBufferData = o7, t11;
  }
  static bind(e11, t11) {
    const r10 = new g4();
    return r10.tileDisplayData = e11, r10.tileBufferData = t11, r10;
  }
  static create(e11, t11) {
    const r10 = new g4();
    r10.tileDisplayData = new e10(), r10.tileDisplayData.displayObjects = e11;
    const o7 = [0, 0, 0, 0, 0], a4 = [0, 0, 0, 0, 0], f9 = [[], [], [], [], []];
    for (const s7 of e11)
      for (const e12 of s7.displayRecords)
        f9[e12.geometryType].push(e12), o7[e12.geometryType] += e12.meshData.vertexCount, a4[e12.geometryType] += e12.meshData.indexData.length;
    const l8 = new f6(), u5 = y4(t11);
    for (let s7 = 0; s7 < h3; s7++) {
      const e12 = new Uint32Array(a4[s7]), t12 = x2(u5[s7], o7[s7]);
      s5.writeAllMeshDataToBuffers(f9[s7], t12, e12), l8.geometries[s7] = { indexBuffer: e12, vertexBuffer: t12 };
    }
    return r10.tileBufferData = l8, r10;
  }
  static _align(e11, t11) {
    const r10 = e11 % t11;
    return 0 === r10 ? e11 : e11 + (t11 - r10);
  }
  static _computeVertexAlignment(e11) {
    let t11 = false, r10 = false;
    for (const s7 of e11)
      s7 % 4 == 2 ? t11 = true : s7 % 4 != 0 && (r10 = true);
    return r10 ? 4 : t11 ? 2 : 1;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/GraphicsReader.js
var o6 = class extends c3 {
  constructor(r10, t11, e11) {
    super(r10, t11, null), this._transform = e11;
  }
  static from(s7, n7, i5) {
    const c5 = b.createInstance(), u5 = [], a4 = s7.filter((r10) => !!r10.geometry);
    for (const e11 of a4) {
      const s8 = c2(e11.geometry);
      et(u5, [e11], s8, false, false, n7);
    }
    return new o6(c5, u5, i5);
  }
  get geometryType() {
    const r10 = this._current;
    return r10 ? r10.geometryType : null;
  }
  get insertAfter() {
    return this._current.insertAfter;
  }
  readGraphic() {
    return this._current;
  }
  getCursor() {
    return this.copy();
  }
  copy() {
    const r10 = new o6(this.instance, this._features, this._transform);
    return this.copyInto(r10), r10;
  }
};

// node_modules/@arcgis/core/views/2d/layers/graphics/GraphicStoreItem.js
var y5 = new t2();
var g5 = new t2();
var f7 = "esriGeometryPolyline";
function d4(t11) {
  t11.coords.length = 0, t11.lengths.length = 0;
}
var b2 = class {
  constructor() {
    this.bounds = u3(), this.graphic = null;
  }
  static acquire(t11 = null, e11, s7, r10, o7) {
    let i5;
    return 0 === b2._pool.length ? i5 = new b2() : (i5 = b2._pool.pop(), this._set.delete(i5)), i5.acquire(t11, e11, s7, r10, o7), i5;
  }
  static release(t11) {
    t11 && !this._set.has(t11) && (t11.release(), this._pool.push(t11), this._set.add(t11));
  }
  static getCentroidQuantized(e11, s7) {
    if (y2(e11.geometry)) {
      const o7 = e11.symbol;
      if (t(o7))
        return null;
      if ((o7 == null ? void 0 : o7.layers.length) > 0 && o7.layers.some((t11) => "text" === t11.type || "marker" === t11.type)) {
        const t11 = r2(e11.geometry);
        return null !== t11 ? O(s7, {}, { x: t11[0], y: t11[1] }, false, false) : null;
      }
    }
    return null;
  }
  acquire(t11 = null, e11, s7, r10, o7) {
    t11 && this.set(t11, e11, s7, r10, o7);
  }
  release() {
    this.graphic = null, this.symbolResource = null, this.geometry = null;
  }
  get symbol() {
    return this.symbolResource.symbol;
  }
  set(t11, e11, s7, r10, o7) {
    this.graphic = t11, this.geometry = s7, this.symbolResource = e11, this.bounds = r10, o7 && (this.size = o7);
  }
  getGeometryQuantized(e11, r10, o7, n7) {
    const c5 = this.geometry, b5 = c2(c5);
    if (t(b5))
      return null;
    switch (b5) {
      case "esriGeometryPolygon": {
        const t11 = c5, { rings: s7 } = t11;
        if (!s7 || 0 === s7.length)
          return null;
        let r11;
        if (r11 = 1 === s7.length && 2 === s7[0].length ? U(e11, { paths: [[s7[0][0], s7[0][1]]] }) : U(e11, this.geometry), !r11) {
          const t12 = { x: s7[0][0][0], y: s7[0][0][1] };
          if (r11 = U(e11, t12), r11) {
            const { x: t13, y: e12 } = r11;
            return { rings: [[[t13 - 1, e12], [1, -1], [1, 1], [-1, 1], [-1, -1]]] };
          }
        }
        return r11;
      }
      case "esriGeometryPolyline": {
        const t11 = c5;
        return d4(y5), d4(g5), C(y5, t11), ht(g5, y5, t11.hasZ, t11.hasM, f7, e11.scale[0]), at(y5, g5, t11.hasZ, t11.hasM, f7, e11), $(y5, t11.hasZ, t11.hasM);
      }
      case "esriGeometryMultipoint": {
        const t11 = c5, i5 = 0.5 * n7 * Math.max(Math.abs(this.size[0]) + this.size[2] - this.size[0], Math.abs(this.size[1]) + this.size[3] - this.size[1]), h4 = R(o7);
        let u5 = t11.points;
        if (h4) {
          const [t12, e12] = h4.valid, o8 = e12 - t12;
          u5 = u5.filter((n8) => {
            if (n8[0] + i5 > e12 || n8[0] - i5 < t12) {
              const t13 = [...n8];
              return n8[0] + i5 > e12 ? t13[0] -= o8 : t13[0] += o8, q(r10, n8, i5) || q(r10, t13, i5);
            }
            return q(r10, n8, i5);
          });
        }
        return 0 === u5.length ? { points: u5 } : U(e11, { points: u5 });
      }
    }
    return U(e11, this.geometry);
  }
};
b2._pool = [], b2._set = /* @__PURE__ */ new Set();

// node_modules/@arcgis/core/views/2d/layers/graphics/GraphicStore.js
var g6 = { minX: 0, minY: 0, maxX: 0, maxY: 0 };
var f8 = u3();
var _ = 1e-5;
function b3(e11, t11, r10, i5, s7) {
  return g6.minX = t11, g6.minY = r10, g6.maxX = i5, g6.maxY = s7, e11.search(g6);
}
function y6(e11) {
  return { minX: e11.bounds[0], minY: e11.bounds[1], maxX: e11.bounds[2], maxY: e11.bounds[3] };
}
var I2 = class {
  constructor(e11, t11, r10, s7, o7, n7, h4) {
    this._graphics = s7, this._onAdd = o7, this._onRemove = n7, this._hashToCIM = h4, this._index = i2(9, y6), this._itemByGraphic = /* @__PURE__ */ new Map(), this._inflatedSizeHelper = new ae2(), this._tileInfoView = e11, this._uidFieldName = r10;
    const a4 = e11.getClosestInfoForScale(t11);
    a4 && (this._resolution = this._tileInfoView.getTileResolution(a4.level));
  }
  setResourceManager(e11) {
    this._cimResourceManager = e11, this._hittestDrawHelper = new V(e11);
  }
  hitTest(e11, t11, r10, i5, n7) {
    e11 = U2(e11, this._tileInfoView.spatialReference);
    const h4 = 0.5 * i5 * window.devicePixelRatio * r10;
    f8[0] = e11 - h4, f8[1] = t11 - h4, f8[2] = e11 + h4, f8[3] = t11 + h4;
    const u5 = 0.5 * i5 * (r10 + g3), l8 = b3(this._index, e11 - u5, t11 - u5, e11 + u5, t11 + u5);
    if (!l8 || 0 === l8.length)
      return [];
    const c5 = [], d5 = u3(), p4 = u3();
    for (const s7 of l8) {
      const { geometry: e12, symbolResource: t12 } = s7;
      this._getSymbolBounds(d5, t12, e12, p4, n7), p4[3] = p4[2] = p4[1] = p4[0] = 0, E(d5, f8) && s7.graphic.visible && c5.push(s7);
    }
    if (0 === c5.length)
      return [];
    const g8 = this._hittestDrawHelper, _2 = [];
    for (const s7 of c5) {
      const { geometry: e12, symbolResource: t12 } = s7, { hash: r11, textInfo: o7 } = t12, h5 = this._hashToCIM.get(r11);
      h5 && (g8.hitTest(f8, h5.symbol, e12, o7, n7, i5) && _2.push(s7));
    }
    return _2.sort(z), _2.map((e12) => e12.graphic);
  }
  getGraphicsData(e11, t11, r10) {
    const i5 = this._searchForItems(t11);
    if (0 === i5.length || 0 === r10.length)
      return [];
    i5.sort((e12, t12) => e12.zorder - t12.zorder), i5[0].insertAfter = -1;
    for (let l8 = 1; l8 < i5.length; l8++)
      i5[l8].insertAfter = i5[l8 - 1].graphic.uid;
    i5.sort((e12, t12) => e12.graphic.uid - t12.graphic.uid), r10.sort((e12, t12) => e12.uid - t12.uid);
    let s7, o7 = 0, n7 = 0;
    const h4 = t11.resolution, a4 = [], u5 = { originPosition: "upperLeft", scale: [h4, h4], translate: [t11.bounds[0], t11.bounds[3]] };
    for (const l8 of r10) {
      for (n7 = -2; o7 < i5.length; )
        if (s7 = i5[o7], o7++, l8.uid === s7.graphic.uid) {
          n7 = s7.insertAfter;
          break;
        }
      if (!s7.geometry || -2 === n7)
        continue;
      const r11 = s7.getGeometryQuantized(u5, t11.bounds, this._tileInfoView.spatialReference, h4), c5 = { ...s7.graphic.attributes };
      c5[this._uidFieldName] = l8.uid, null == s7.groupId && (s7.groupId = e11.createTemplateGroup(s7.symbol, null)), a4.push({ centroid: b2.getCentroidQuantized(s7, u5), geometry: r11, attributes: c5, symbol: s7.symbol, groupId: s7.groupId, insertAfter: n7, zorder: s7.zorder });
    }
    return a4.sort((e12, t12) => e12.zorder - t12.zorder), a4;
  }
  queryTileData(e11, t11) {
    if (0 === this._graphics.length)
      return [];
    const { bounds: r10, resolution: i5 } = t11, s7 = this._searchForItems(t11), o7 = [];
    return 0 === s7.length || this._createTileGraphics(o7, e11, s7, { originPosition: "upperLeft", scale: [i5, i5], translate: [r10[0], r10[3]] }, t11), o7;
  }
  has(e11) {
    return this._itemByGraphic.has(e11);
  }
  getBounds(e11) {
    const t11 = this._itemByGraphic.get(e11);
    return t11 ? t11.bounds : null;
  }
  getAllBounds() {
    return Array.from(this._itemByGraphic.values()).filter((e11) => e11.graphic.visible).map((e11) => e11.bounds);
  }
  addOrModify(r10, i5, s7) {
    if (!r10 || t(i5))
      return;
    this.has(r10) && this.remove(r10), this._onAdd(r10);
    const o7 = [0, 0, 0, 0], n7 = this._getSymbolBounds(null, i5, s7, o7, 0), h4 = b2.acquire(r10, i5, s7, r(n7) ? n7 : null, o7);
    return this._itemByGraphic.set(r10, h4), s7 && this._index.insert(h4), h4.bounds;
  }
  remove(e11) {
    if (!this._itemByGraphic.has(e11))
      return;
    this._onRemove(e11);
    const t11 = this._itemByGraphic.get(e11);
    t11.bounds && this._index.remove(t11), this._itemByGraphic.delete(e11);
  }
  updateZ() {
    const e11 = this._graphics.items;
    let t11, r10;
    for (let i5 = 0; i5 < e11.length; i5++)
      r10 = e11[i5], t11 = this._itemByGraphic.get(r10), t11 && (t11.zorder = i5);
  }
  update(e11, r10, i5) {
    const s7 = this._itemByGraphic.get(e11);
    s7.groupId = null;
    const o7 = e2(s7.bounds);
    this._index.remove(s7);
    const h4 = this._getSymbolBounds(s7.bounds, r10, i5, s7.size, 0);
    return r(h4) && s7.set(e11, r10, i5, h4, s7.size), i5 && this._index.insert(s7), { oldBounds: o7, newBounds: s7.bounds };
  }
  updateLevel(e11) {
    if (this._resolution === e11)
      return;
    this._resolution = e11, this._index.clear();
    const r10 = this._itemByGraphic, i5 = [];
    for (const [s7, o7] of r10) {
      const e12 = this._getSymbolBounds(o7.bounds, o7.symbolResource, o7.geometry, o7.size, 0);
      o7.geometry && r(e12) && (o7.bounds = e12, i5.push(o7));
    }
    this._index.load(i5);
  }
  clear() {
    this._itemByGraphic.clear(), this._index.clear();
  }
  _createTileGraphics(e11, t11, r10, i5, s7) {
    const o7 = this._uidFieldName, n7 = this._tileInfoView.spatialReference, { bounds: h4, resolution: a4 } = s7;
    let u5, l8, c5, m3;
    r10.sort((e12, t12) => e12.zorder - t12.zorder);
    for (let p4 = 0; p4 < r10.length; p4++) {
      c5 = r10[p4], u5 = c5.graphic, l8 = c5.getGeometryQuantized(i5, h4, n7, a4), m3 = 0 === p4 ? -1 : r10[p4 - 1].graphic.uid;
      const s8 = { ...c5.graphic.attributes };
      s8[o7] = u5.uid, null == c5.groupId && (c5.groupId = t11.createTemplateGroup(c5.symbol, null)), e11.push({ centroid: b2.getCentroidQuantized(c5, i5), geometry: l8, attributes: s8, symbol: c5.symbol, groupId: c5.groupId, insertAfter: m3, zorder: c5.zorder });
    }
  }
  _searchForItems(e11) {
    const t11 = this._tileInfoView.spatialReference, r10 = e11.bounds;
    if (t11.isWrappable) {
      const [i5, o7] = R(t11).valid, n7 = Math.abs(r10[2] - o7) < _, h4 = Math.abs(r10[0] - i5) < _;
      if ((!n7 || !h4) && (n7 || h4)) {
        const t12 = e11.resolution;
        let h5;
        h5 = u3(n7 ? [i5, r10[1], i5 + t12 * g3, r10[3]] : [o7 - t12 * g3, r10[1], o7, r10[3]]);
        const a4 = b3(this._index, r10[0], r10[1], r10[2], r10[3]), u5 = b3(this._index, h5[0], h5[1], h5[2], h5[3]);
        return [.../* @__PURE__ */ new Set([...a4, ...u5])];
      }
    }
    return b3(this._index, r10[0], r10[1], r10[2], r10[3]);
  }
  _getSymbolBounds(e11, t11, i5, o7, n7) {
    if (!t11 || !t11.symbol || !i5)
      return null;
    if (e11 || (e11 = u3()), c(e11, i5), !o7 || 0 === o7[0] && 0 === o7[1] && 0 === o7[2] && 0 === o7[3]) {
      const { hash: e12, textInfo: i6 } = t11, s7 = this._hashToCIM.get(e12);
      if (!s7)
        return null;
      o7 || (o7 = [0, 0, 0, 0]);
      const h4 = this._inflatedSizeHelper.getSymbolInflateSize(o7, s7.symbol, this._cimResourceManager, n7, i6);
      o7[0] = u2(h4[0]), o7[1] = u2(h4[1]), o7[2] = u2(h4[2]), o7[3] = u2(h4[3]);
    }
    const a4 = this._resolution, u5 = ae2.safeSize(o7);
    return e11[0] -= u5 * a4, e11[1] -= u5 * a4, e11[2] += u5 * a4, e11[3] += u5 * a4, e11;
  }
};
var z = (e11, t11) => {
  const r10 = y3(e11.graphic), i5 = y3(t11.graphic);
  return r10 === i5 ? t11.zorder - e11.zorder : r10 - i5;
};

// node_modules/@arcgis/core/views/layers/GraphicsView.js
var t9 = (t11) => {
  let p4 = class extends s3(t11) {
    constructor() {
      super(...arguments), this.graphics = null, this.renderer = null;
    }
  };
  return e([y()], p4.prototype, "graphics", void 0), e([y()], p4.prototype, "renderer", void 0), e([y()], p4.prototype, "updating", void 0), e([y()], p4.prototype, "view", void 0), p4 = e([n("esri.views.layers.GraphicsView")], p4), p4;
};

// node_modules/@arcgis/core/views/2d/layers/graphics/GraphicsView2D.js
var se2 = has("esri-2d-graphic-debug");
function ie2(e11, t11, s7) {
  if (s7.has(e11))
    return s7.get(e11);
  const i5 = { tile: t11, addedOrModified: [], removed: [] };
  return s7.set(e11, i5), i5;
}
var re = class extends t9(a(m)) {
  constructor(e11) {
    super(e11), this._storage = new r5(), this._displayIds = /* @__PURE__ */ new Map(), this._controller = new AbortController(), this._tiles = /* @__PURE__ */ new Map(), this._graphicStoreUpdate = false, this._graphicsSet = /* @__PURE__ */ new Set(), this._matcher = Promise.resolve(null), this._tileUpdateSet = /* @__PURE__ */ new Set(), this._tilesToUpdate = /* @__PURE__ */ new Map(), this._graphicIdToAbortController = /* @__PURE__ */ new Map(), this._attached = false, this._updatingGraphicsTimer = null, this._hashToExpandedSymbol = /* @__PURE__ */ new Map(), this._hashToExpandedSymbolPromise = /* @__PURE__ */ new Map(), this._hashToCIMSymbolPromise = /* @__PURE__ */ new Map(), this._hashToCIM = /* @__PURE__ */ new Map(), this._processing = false, this._needsProcessing = false, this._pendingUpdate = { added: /* @__PURE__ */ new Set(), updated: /* @__PURE__ */ new Set(), removed: /* @__PURE__ */ new Set() }, this.lastUpdateId = -1, this.updateRequested = false, this.graphicUpdateHandler = this.graphicUpdateHandler.bind(this);
  }
  destroy() {
    this._updatingGraphicsTimer && (clearTimeout(this._updatingGraphicsTimer), this._updatingGraphicsTimer = null, this.notifyChange("updating")), this._controller.abort(), this.container.destroy(), this._set("graphics", null), this._graphicStore.clear(), this._attributeStore = null, this._hashToExpandedSymbol.clear(), this.view = null, this.renderer = null, this._hashToCIM.clear(), this._hashToCIMSymbolPromise.clear(), this._hashToExpandedSymbolPromise.clear();
  }
  _createMatcher(e11, t11, s7) {
    if (e11) {
      const i5 = w2(e11), r10 = $2({ indexCount: 0, fields: {} }, "feature", e11, i5);
      this._matcher = l6(r10, t11, null, s7);
    }
  }
  _createDisplayId(e11) {
    return this._displayIds.has(e11) || this._displayIds.set(e11, this._storage.createDisplayId()), this._displayIds.get(e11);
  }
  initialize() {
    this._attributeStore = new v({ type: "local", initialize: (e12) => Promise.resolve(this.container.attributeView.initialize(e12)), update: (e12) => this.container.attributeView.requestUpdate(e12), render: () => this.container.requestRender() }, l4("2d"), () => this.notifyChange("updating")), this.container.hasHighlight = () => this._attributeStore.hasHighlight;
    const e11 = (e12) => {
      this._createDisplayId(e12.uid), this._setFilterState(e12.uid, e12.visible);
    }, t11 = (e12) => {
      const t12 = this._displayIds.get(e12.uid);
      this._displayIds.delete(e12.uid), this._storage.releaseDisplayId(t12);
    }, s7 = new x(this.container.getMaterialItems.bind(this.container), this.view.featuresTilingScheme.tileInfo);
    this._graphicStore = new I2(this.view.featuresTilingScheme, this.view.state.scale, this.uid, this.graphics, e11, t11, this._hashToCIM), this._meshFactory = new l5(null, this.uid, s7), this._templateStore = s7, this.handles.add([l2(() => this.renderer, (e12) => {
      this._createMatcher(e12, s7, this.container.stage.resourceManager);
      for (const t12 of this.graphics)
        this._pendingUpdate.updated.add(t12);
      this.requestUpdate();
    }), this.view.graphicsTileStore.on("update", this._onTileUpdate.bind(this)), this.container.on("attach", () => {
      se2 && this.container.enableRenderingBounds(() => this._graphicStore.getAllBounds()), this.graphics.items.length > 0 && this._graphicsChangeHandler({ target: this.graphics, added: this.graphics.items, removed: [], moved: [] }), this.handles.add(this.graphics.on("change", (e13) => this._graphicsChangeHandler(e13)), "graphics");
      const e12 = this.container.stage.resourceManager;
      this._createMatcher(this.renderer, s7, e12), this._graphicStore.setResourceManager(e12), this._attached = true, this.notifyChange("updating");
    })]);
    const i5 = this.view.graphicsTileStore.tiles;
    this._onTileUpdate({ added: i5, removed: [] });
  }
  get updating() {
    return !this._attached || null !== this._updatingGraphicsTimer || this._tileUpdateSet.size > 0 || this._tilesToUpdate.size > 0 || this._attributeStore.isUpdating();
  }
  hitTest(e11) {
    if (!this.view || !this.view.position)
      return [];
    const { resolution: t11, rotation: s7 } = this.view.state;
    return this._graphicStore.hitTest(e11.x, e11.y, 2, t11, s7);
  }
  update(e11) {
    f(this._controller.signal);
    const t11 = e11.state, { resolution: s7 } = t11;
    if (this._graphicStore.updateLevel(s7), this._graphicStoreUpdate = true, this.updateRequested = false, this._pendingUpdate.updated.size > 0) {
      if (!this._processing)
        return void this._updateGraphics();
      this._needsProcessing = true;
    }
  }
  viewChange() {
    this.requestUpdate();
  }
  requestUpdate() {
    this.updateRequested || (this.updateRequested = true, this.requestUpdateCallback());
  }
  processUpdate(e11) {
    this.updateRequested && (this.updateRequested = false, this.update(e11));
  }
  graphicUpdateHandler(e11) {
    const { graphic: t11, property: s7 } = e11;
    switch (s7) {
      case "attributes":
      case "geometry":
      case "symbol":
        this._pendingUpdate.updated.add(t11), this.requestUpdate();
        break;
      case "visible":
        this._setFilterState(t11.uid, t11.visible), this._attributeStore.sendUpdates();
    }
  }
  setHighlight(e11) {
    const t11 = e11.map((e12) => this._displayIds.get(e12));
    this._attributeStore.setHighlight(e11, t11);
  }
  _getIntersectingTiles(e11) {
    const t11 = this._graphicStore.getBounds(e11);
    if (!t11 || 0 === s2(t11) || 0 === l3(t11))
      return [];
    const s7 = p2(t11, this.view.spatialReference);
    return r(s7) ? [.../* @__PURE__ */ new Set([...this.view.graphicsTileStore.boundsIntersections(s7[0]), ...this.view.graphicsTileStore.boundsIntersections(s7[1])])] : this.view.graphicsTileStore.boundsIntersections(t11);
  }
  async _updateTile(e11) {
    f(this._controller.signal);
    const t11 = e11.tile, s7 = this._getGraphicsData(this._templateStore, t11, e11.addedOrModified), i5 = await this._processGraphics(t11, s7);
    return f(this._controller.signal), this._patchTile(t11.key, { type: "update", addOrUpdate: i5, remove: e11.removed, end: true, clear: false, sort: false }), i5;
  }
  _patchTile(e11, t11) {
    if (!this._tiles.has(e11))
      return;
    const s7 = this._tiles.get(e11);
    this.container.onTileData(s7, t11), this.container.requestRender();
  }
  _graphicsChangeHandler(e11) {
    const t11 = this._pendingUpdate;
    for (const s7 of e11.added)
      t11.added.add(s7);
    for (const s7 of e11.moved)
      t11.updated.add(s7);
    for (const s7 of e11.removed)
      this._pendingUpdate.added.has(s7) ? t11.added.delete(s7) : t11.removed.add(s7);
    this._processing ? this._needsProcessing = true : this._updateGraphics();
  }
  _getGraphicsToUpdate() {
    const e11 = { added: [], removed: [], updated: [] };
    if (!this.graphics)
      return e11;
    const t11 = this._pendingUpdate;
    for (const s7 of this.graphics.items)
      t11.added.has(s7) ? e11.added.push(s7) : t11.updated.has(s7) && e11.updated.push(s7);
    for (const s7 of t11.removed)
      this._graphicStore.has(s7) && e11.removed.push(s7);
    return t11.added.clear(), t11.removed.clear(), t11.updated.clear(), e11;
  }
  async _updateGraphics() {
    this._processing = true;
    const { added: e11, removed: t11, updated: s7 } = this._getGraphicsToUpdate(), i5 = this._tilesToUpdate;
    let r10;
    try {
      if (!this._graphicStoreUpdate) {
        const e12 = this.view.state, { resolution: t12 } = e12;
        this._graphicStore.updateLevel(t12);
      }
      const o7 = [], a4 = new Array(e11.length + t11.length);
      for (let e12 = 0; e12 < s7.length; e12++) {
        const t12 = s7[e12], h5 = this._getIntersectingTiles(t12);
        for (const e13 of h5) {
          r10 = e13.id;
          ie2(r10, e13, i5).removed.push(this._displayIds.get(t12.uid));
        }
        o7.push(this._updateGraphic(t12, null)), a4[e12] = t12;
      }
      const h4 = s7.length;
      for (let t12 = 0; t12 < e11.length; t12++) {
        const s8 = e11[t12];
        a4[h4 + t12] = s8, this._graphicsSet.add(s8), o7.push(this._addGraphic(s8));
      }
      for (const e12 of t11) {
        this._abortProcessingGraphic(e12.uid);
        const t12 = this._getIntersectingTiles(e12);
        for (const s8 of t12) {
          r10 = s8.id;
          ie2(r10, s8, i5).removed.push(this._displayIds.get(e12.uid));
        }
        this._graphicsSet.delete(e12), this._graphicStore.remove(e12);
      }
      let n7;
      this._flipUpdatingGraphics(), await Promise.all(o7);
      for (let e12 = 0; e12 < a4.length; e12++) {
        n7 = a4[e12];
        const t12 = this._getIntersectingTiles(n7);
        for (const e13 of t12) {
          r10 = e13.id;
          ie2(r10, e13, i5).addedOrModified.push(n7);
        }
      }
      this._graphicStore.updateZ();
      const l8 = [];
      for (const [e12, t12] of i5)
        l8.push(this._updateTile(t12));
      await Promise.all(l8);
    } catch (o7) {
      j(o7), 0;
    }
    for (const a4 of t11)
      try {
        const e12 = await this._getSymbolForGraphic(a4, null);
        if (e12) {
          const t12 = e12.hash();
          this._hashToExpandedSymbol.delete(t12);
        }
      } catch (o7) {
        j(o7), 0;
      }
    i5.clear(), this.notifyChange("updating"), this._processing = false, this._needsProcessing && (this._needsProcessing = false, this._updateGraphics());
  }
  _getArcadeInfo(e11) {
    const t11 = (e11.attributes ? Object.keys(e11.attributes) : []).map((t12) => ({ name: t12, alias: t12, type: "string" == typeof e11.attributes[t12] ? "esriFieldTypeString" : "esriFieldTypeDouble" }));
    return t(e11.geometry) ? null : { geometryType: c2(e11.geometry), spatialReference: k.fromJSON(e11.geometry.spatialReference), fields: t11 };
  }
  _getSymbolForGraphic(e11, t11) {
    return f(this._controller.signal), r(e11.symbol) ? Promise.resolve(e11.symbol) : r(this.renderer) ? this.renderer.getSymbolAsync(e11, { scale: this.view.scale, signal: r(t11) ? t11.signal : null }) : Promise.resolve(this._getNullSymbol(e11));
  }
  _getCIMSymbol(e11, t11, s7) {
    let i5 = this._hashToCIM.get(t11);
    if (i5)
      return Promise.resolve(i5);
    const o7 = Q(e11);
    if (r(o7)) {
      if ("CIMSymbolReference" === o7.type)
        return i5 = o7, this._hashToCIM.set(t11, i5), Promise.resolve(i5);
      let e12 = this._hashToCIMSymbolPromise.get(t11);
      return e12 || (e12 = o7.fetchCIMSymbol(s7).then((e13) => (this._hashToCIM.set(t11, e13.data), this._hashToCIMSymbolPromise.delete(t11), e13)).catch((e13) => (this._hashToCIMSymbolPromise.delete(t11), w(e13), null)), this._hashToCIMSymbolPromise.set(t11, e12), e12);
    }
    return Promise.resolve(null);
  }
  _expandCIMSymbol(e11, t11, s7, i5) {
    const r10 = this._hashToExpandedSymbol.get(s7);
    if (r10)
      return Promise.resolve(r10);
    let o7 = this._hashToExpandedSymbolPromise.get(s7);
    if (o7)
      return o7;
    const a4 = this.container.stage, h4 = this._getArcadeInfo(t11), n7 = w2(null), l8 = o(e11, n7);
    return o7 = n3(l8, h4, a4.resourceManager, i5), this._hashToExpandedSymbolPromise.set(s7, o7), o7.then((e12) => (this._hashToExpandedSymbol.set(s7, e12), this._hashToExpandedSymbolPromise.delete(s7), e12)), o7;
  }
  async _getSymbolResources(e11, t11) {
    f(this._controller.signal);
    return this.container.stage ? this._getSymbolForGraphic(e11, t11).then((i5) => {
      const r10 = i5.hash();
      return this._getCIMSymbol(i5, r10, t11).then((i6) => t(i6) ? null : this._expandCIMSymbol(i6, e11, r10, t11).then((e12) => {
        const t12 = e12.layers.filter((e13) => "text" === e13.type && "string" == typeof e13.text);
        if (t12 && t12.length > 0) {
          const i7 = new Array(t12.length);
          for (let e13 = 0; e13 < t12.length; e13++) {
            const r11 = t12[e13], o8 = [], [a4] = n2(r11.text);
            r11.text = a4;
            for (let e14 = 0; e14 < a4.length; e14++)
              o8.push(a4.charCodeAt(e14));
            i7[e13] = { symbol: r11, id: e13, glyphIds: o8 };
          }
          const o7 = /* @__PURE__ */ new Map();
          return this.container.getMaterialItems(i7).then((s7) => {
            for (let e13 = 0; e13 < t12.length; e13++) {
              const i8 = t12[e13];
              o7.set(i8.cim, { text: i8.text, mosaicItem: s7[e13].mosaicItem });
            }
            return { symbol: e12, textInfo: o7, hash: r10 };
          });
        }
        return { symbol: e12, hash: r10 };
      }));
    }).catch((e12) => (w(e12), null)) : null;
  }
  async _projectAndNormalizeGeometry(e11, t11) {
    if (f(this._controller.signal), t(e11.geometry) || "mesh" === e11.geometry.type)
      return null;
    let s7 = e11.geometry;
    if (y2(s7)) {
      const e12 = s7.rings;
      s7.rings = e12;
    } else if (f2(s7)) {
      const e12 = s7.paths;
      s7.paths = e12;
    } else if (u(s7)) {
      const i6 = await this._getSymbolForGraphic(e11, t11);
      if (f(this._controller.signal), h2(i6.type) || u4(i6.type)) {
        s7 = s7.center;
      } else
        s7 = d(s7);
    }
    await f4(s7.spatialReference, this.view.spatialReference);
    const i5 = p(s7), r10 = g2(i5, s7.spatialReference, this.view.spatialReference);
    return r10 && g(r10), r10;
  }
  _onTileUpdate(e11) {
    const t11 = R(this.view.spatialReference);
    if (e11.added && e11.added.length > 0)
      for (const s7 of e11.added)
        this._addNewTile(s7, t11);
    if (e11.removed && e11.removed.length > 0)
      for (const s7 of e11.removed)
        this._removeTile(s7.key);
  }
  async _addGraphic(e11) {
    this._abortProcessingGraphic(e11.uid), f(this._controller.signal);
    const t11 = new AbortController();
    this._graphicIdToAbortController.set(e11.uid, t11);
    const s7 = { signal: t11.signal };
    try {
      await this._addOrUpdateGraphic(e11, s7), f(this._controller.signal), this._graphicIdToAbortController.delete(e11.uid);
    } catch (i5) {
      if (this._graphicIdToAbortController.delete(e11.uid), !j(i5))
        throw i5;
    }
  }
  _updateGraphic(e11, t11) {
    f(this._controller.signal);
    const s7 = this._projectAndNormalizeGeometry(e11, t11), i5 = this._getSymbolResources(e11, t11);
    return Promise.all([s7, i5]).then(([t12, s8]) => {
      f(this._controller.signal), this._graphicStore.addOrModify(e11, s8, t12);
    });
  }
  _addOrUpdateGraphic(e11, t11) {
    f(this._controller.signal);
    const s7 = this._projectAndNormalizeGeometry(e11, t11), i5 = this._getSymbolResources(e11, t11);
    return Promise.all([s7, i5]).then(([t12, s8]) => {
      f(this._controller.signal), this._graphicsSet.has(e11) && this._graphicStore.addOrModify(e11, s8, t12);
    });
  }
  _addTile(e11) {
    const t11 = this.view.featuresTilingScheme.getTileBounds(u3(), e11), s7 = this.view.featuresTilingScheme.getTileResolution(e11.level), i5 = new a3(e11, s7, t11[0], t11[3]);
    return this._tiles.set(e11, i5), this.container.addChild(i5), i5;
  }
  async _addNewTile(e11, t11) {
    const s7 = this._addTile(e11.key), i5 = this._graphicStore.queryTileData(this._templateStore, e11);
    if (0 === i5.length)
      return;
    if (t11) {
      const s8 = Math.round((t11.valid[1] - t11.valid[0]) / e11.resolution);
      for (const e12 of i5)
        e12.geometry && (s(e12.geometry) || l(e12.geometry)) && this._wrapPoints(e12, s8);
    }
    const r10 = e11.key;
    this._tileUpdateSet.add(e11.key), this.notifyChange("updating");
    try {
      const t12 = { type: "update", clear: false, addOrUpdate: await this._processGraphics(e11, i5), remove: [], end: true, sort: false };
      s7.patch(t12), this._tileUpdateSet.delete(r10), this.notifyChange("updating");
    } catch (o7) {
      if (this._tileUpdateSet.delete(r10), this.notifyChange("updating"), !j(o7))
        throw o7;
    }
  }
  _removeTile(e11) {
    if (!this._tiles.has(e11))
      return;
    const t11 = this._tiles.get(e11);
    this.container.removeChild(t11), t11.destroy(), this._tiles.delete(e11);
  }
  _setFilterState(e11, t11) {
    const s7 = this._displayIds.get(e11), i5 = this._attributeStore.getHighlightFlag(e11);
    this._attributeStore.setData(s7, 0, 0, i5 | (t11 ? U3 : 0));
  }
  _getGraphicsData(e11, t11, s7) {
    const i5 = this.view, r10 = R(i5.spatialReference), o7 = this._graphicStore.getGraphicsData(e11, t11, s7);
    if (r10) {
      const e12 = Math.round((r10.valid[1] - r10.valid[0]) / t11.resolution);
      for (const t12 of o7)
        t12.geometry && (s(t12.geometry) || l(t12.geometry)) && this._wrapPoints(t12, e12);
    }
    return o7;
  }
  _wrapPoints(e11, t11) {
    const s7 = e11.geometry;
    l(s7) ? this._wrapMultipoint(s7, t11) : this._wrapPoint(e11, t11);
  }
  _wrapMultipoint(e11, t11) {
    const s7 = e11.points, i5 = [];
    let r10 = 0, o7 = 0;
    for (const [a4, h4] of s7) {
      if (i5.push([a4 + r10, h4]), r10 = 0, t11 === c4) {
        const e12 = 5 * g3;
        a4 + o7 < e12 ? (i5.push([t11, 0]), r10 = -t11) : a4 + o7 > c4 - e12 && (i5.push([-t11, 0]), r10 = t11);
      } else
        a4 + o7 < -g3 ? (i5.push([t11, 0]), r10 = -t11) : a4 + o7 > c4 + g3 && (i5.push([-t11, 0]), r10 = t11);
      o7 += a4;
    }
    e11.points = i5;
  }
  _wrapPoint(e11, t11) {
    const s7 = e11.geometry;
    if (t11 === c4) {
      const i5 = 5 * g3;
      s7.x < i5 ? e11.geometry = { points: [[s7.x, s7.y], [t11, 0]] } : s7.x > c4 - i5 && (e11.geometry = { points: [[s7.x, s7.y], [-t11, 0]] });
    } else
      s7.x < -g3 ? e11.geometry = { points: [[s7.x, s7.y], [t11, 0]] } : s7.x > c4 + g3 && (e11.geometry = { points: [[s7.x, s7.y], [-t11, 0]] });
  }
  _processGraphics(e11, t11, s7) {
    if (!(t11 && t11.length) || !this._meshFactory)
      return null;
    const i5 = o6.from(t11, this.uid, e11.transform), r10 = this._meshFactory;
    return this._matcher.then((t12) => r10.analyzeGraphics(i5, this.container.stage.resourceManager, t12, null, null, s7).then(() => (this._attributeStore.sendUpdates(), this._processAnalyzedGraphics(e11, i5))));
  }
  _processAnalyzedGraphics(e11, t11) {
    const s7 = this._meshFactory, i5 = t11.getSize(), r10 = t11.getCursor(), o7 = { features: i5, records: i5, metrics: 0 }, a4 = new E4(e11.key.id, o7, S.DEFAULT, false, false), h4 = [];
    for (; r10.next(); ) {
      const t12 = r10.readGraphic();
      t12.insertAfter = -1 === t12.insertAfter ? -1 : this._displayIds.get(t12.insertAfter), t12.displayId = this._displayIds.get(t12.attributes[this.uid]);
      const i6 = new e9(t12.displayId);
      i6.insertAfter = t12.insertAfter, h4.push(i6), s7.writeGraphic(a4, r10, e11.level, this.container.stage.resourceManager);
    }
    const n7 = e11.tileInfoView.tileInfo.isWrappable, l8 = a4.serialize(n7);
    if (1 !== l8.length)
      return new g4();
    const d5 = l8[0].message;
    return g4.fromVertexData(d5, h4);
  }
  _abortProcessingGraphic(e11) {
    if (this._graphicIdToAbortController.has(e11)) {
      this._graphicIdToAbortController.get(e11).abort();
    }
  }
  _getNullSymbol(e11) {
    const t11 = e11.geometry;
    return f2(t11) ? O2 : y2(t11) || u(t11) ? j2 : N;
  }
  _flipUpdatingGraphics() {
    this._updatingGraphicsTimer && clearTimeout(this._updatingGraphicsTimer), this._updatingGraphicsTimer = setTimeout(() => {
      this._updatingGraphicsTimer = null, this.notifyChange("updating");
    }, 160), this.notifyChange("updating");
  }
};
e([y({ constructOnly: true })], re.prototype, "requestUpdateCallback", void 0), e([y()], re.prototype, "container", void 0), e([y({ constructOnly: true })], re.prototype, "graphics", void 0), e([y()], re.prototype, "updating", null), e([y()], re.prototype, "view", void 0), e([y()], re.prototype, "updateRequested", void 0), re = e([n("esri.views.2d.layers.support.GraphicsView2D")], re);
var oe = re;

// node_modules/@arcgis/core/views/2d/layers/graphics/GraphicBoundsRenderer.js
var g7 = Math.PI / 180;
var v2 = 4;
var x3 = class extends r6 {
  constructor(t11) {
    super(), this._dvsMat3 = e3(), this._localOrigin = { x: 0, y: 0 }, this._getBounds = t11;
  }
  destroy() {
    this._vao && (this._vao.dispose(true), this._vao = null, this._vertexBuffer = null, this._indexBuffer = null), this._program && (this._program.dispose(), this._program = null);
  }
  doRender(t11) {
    const { context: e11 } = t11, s7 = this._getBounds();
    if (s7.length < 1)
      return;
    this._createShaderProgram(e11), this._updateMatricesAndLocalOrigin(t11), this._updateBufferData(e11, s7), e11.setBlendingEnabled(true), e11.setDepthTestEnabled(false), e11.setStencilWriteMask(0), e11.setStencilTestEnabled(false), e11.setBlendFunction(R2.ONE, R2.ONE_MINUS_SRC_ALPHA), e11.setColorMask(true, true, true, true);
    const r10 = this._program;
    e11.bindVAO(this._vao), e11.useProgram(r10), r10.setUniformMatrix3fv("u_dvsMat3", this._dvsMat3), e11.gl.lineWidth(1), e11.drawElements(E2.LINES, 8 * s7.length, C2.UNSIGNED_INT, 0), e11.bindVAO();
  }
  _createTransforms() {
    return { dvs: e3() };
  }
  _createShaderProgram(t11) {
    if (this._program)
      return;
    const e11 = "precision highp float;\n        uniform mat3 u_dvsMat3;\n\n        attribute vec2 a_position;\n\n        void main() {\n          mediump vec3 pos = u_dvsMat3 * vec3(a_position, 1.0);\n          gl_Position = vec4(pos.xy, 0.0, 1.0);\n        }", s7 = "precision mediump float;\n      void main() {\n        gl_FragColor = vec4(0.75, 0.0, 0.0, 0.75);\n      }";
    this._program = t11.programCache.acquire(e11, s7, b4().attributes);
  }
  _updateMatricesAndLocalOrigin(o7) {
    const { state: l8 } = o7, { displayMat3: u5, size: c5, resolution: _2, pixelRatio: h4, rotation: m3, viewpoint: d5 } = l8, p4 = g7 * m3, { x: v3, y: x4 } = d5.targetGeometry, b5 = U2(v3, l8.spatialReference);
    this._localOrigin.x = b5, this._localOrigin.y = x4;
    const y7 = h4 * c5[0], B2 = h4 * c5[1], M2 = _2 * y7, A = _2 * B2, O3 = r3(this._dvsMat3);
    i(O3, O3, u5), M(O3, O3, t3(y7 / 2, B2 / 2)), f3(O3, O3, r4(c5[0] / M2, -B2 / A, 1)), h(O3, O3, -p4);
  }
  _updateBufferData(t11, e11) {
    const { x: s7, y: r10 } = this._localOrigin, i5 = 2 * v2 * e11.length, o7 = new Float32Array(i5), a4 = new Uint32Array(8 * e11.length);
    let n7 = 0, f9 = 0;
    for (const l8 of e11)
      l8 && (o7[2 * n7 + 0] = l8[0] - s7, o7[2 * n7 + 1] = l8[1] - r10, o7[2 * n7 + 2] = l8[0] - s7, o7[2 * n7 + 3] = l8[3] - r10, o7[2 * n7 + 4] = l8[2] - s7, o7[2 * n7 + 5] = l8[3] - r10, o7[2 * n7 + 6] = l8[2] - s7, o7[2 * n7 + 7] = l8[1] - r10, a4[f9 + 0] = n7 + 0, a4[f9 + 1] = n7 + 3, a4[f9 + 2] = n7 + 3, a4[f9 + 3] = n7 + 2, a4[f9 + 4] = n7 + 2, a4[f9 + 5] = n7 + 1, a4[f9 + 6] = n7 + 1, a4[f9 + 7] = n7 + 0, n7 += 4, f9 += 8);
    if (this._vertexBuffer ? this._vertexBuffer.setData(o7.buffer) : this._vertexBuffer = E3.createVertex(t11, F.DYNAMIC_DRAW, o7.buffer), this._indexBuffer ? this._indexBuffer.setData(a4) : this._indexBuffer = E3.createIndex(t11, F.DYNAMIC_DRAW, a4), !this._vao) {
      const e12 = b4();
      this._vao = new a2(t11, e12.attributes, e12.bufferLayouts, { geometry: this._vertexBuffer }, this._indexBuffer);
    }
  }
};
var b4 = () => ge("bounds", { geometry: [{ location: 0, name: "a_position", count: 2, type: C2.FLOAT }] });

// node_modules/@arcgis/core/views/2d/layers/graphics/BaseGraphicContainer.js
var t10 = class extends o2 {
  constructor(e11) {
    super(e11), this.hasHighlight = () => true;
  }
  destroy() {
    super.destroy(), this._boundsRenderer && (this._boundsRenderer.destroy(), this._boundsRenderer = null);
  }
  enableRenderingBounds(e11) {
    this._boundsRenderer = new x3(e11), this.requestRender();
  }
  get hasLabels() {
    return false;
  }
  onTileData(e11, s7) {
    e11.patch(s7), this.contains(e11) || this.addChild(e11), this.requestRender();
  }
  onTileError(e11) {
    e11.clear(), this.contains(e11) || this.addChild(e11);
  }
  _renderChildren(e11, s7) {
    for (const t11 of this.children)
      t11.isReady && t11.hasData && (t11.commit(e11), e11.context.setStencilFunction(I.EQUAL, t11.stencilRef, 255), t11._displayList.replay(e11, t11, s7));
  }
};

export {
  oe,
  t10 as t
};
//# sourceMappingURL=chunk-L26SDFYA.js.map
