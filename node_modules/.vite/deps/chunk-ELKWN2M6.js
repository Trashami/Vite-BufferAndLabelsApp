import {
  o as o5
} from "./chunk-FGBXDVCJ.js";
import {
  s
} from "./chunk-OF6PIPJD.js";
import {
  e as e3
} from "./chunk-6WTG5RYO.js";
import {
  e2 as e4,
  o3 as o2,
  o4 as o3
} from "./chunk-HNRPDSCT.js";
import {
  h
} from "./chunk-SBPLVEUA.js";
import {
  e as e2
} from "./chunk-6ZCPLPAF.js";
import {
  o
} from "./chunk-MYQCUAHK.js";
import {
  o as o4
} from "./chunk-735C75BI.js";
import {
  n
} from "./chunk-ZLTZ3KAT.js";
import {
  O
} from "./chunk-RUM3DXFX.js";
import {
  e
} from "./chunk-OOLCFNXJ.js";
import {
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/LineMarkerTechniqueConfiguration.js
var p;
var s2;
!function(o7) {
  o7[o7.Draped = 0] = "Draped", o7[o7.Screen = 1] = "Screen", o7[o7.World = 2] = "World", o7[o7.COUNT = 3] = "COUNT";
}(p || (p = {})), function(o7) {
  o7[o7.Center = 0] = "Center", o7[o7.Tip = 1] = "Tip", o7[o7.COUNT = 2] = "COUNT";
}(s2 || (s2 = {}));
var a = class extends s {
  constructor() {
    super(...arguments), this.output = h.Color, this.transparencyPassType = o.NONE, this.occluder = false, this.hasSlicePlane = false, this.writeDepth = false, this.space = p.Screen, this.hideOnShortSegments = false, this.hasCap = false, this.anchor = s2.Center, this.hasTip = false, this.vvSize = false, this.vvColor = false, this.vvOpacity = false, this.hasOccludees = false, this.hasMultipassTerrain = false, this.cullAboveGround = false;
  }
};
e([e3({ count: h.COUNT })], a.prototype, "output", void 0), e([e3({ count: o.COUNT })], a.prototype, "transparencyPassType", void 0), e([e3()], a.prototype, "occluder", void 0), e([e3()], a.prototype, "hasSlicePlane", void 0), e([e3()], a.prototype, "writeDepth", void 0), e([e3({ count: p.COUNT })], a.prototype, "space", void 0), e([e3()], a.prototype, "hideOnShortSegments", void 0), e([e3()], a.prototype, "hasCap", void 0), e([e3({ count: s2.COUNT })], a.prototype, "anchor", void 0), e([e3()], a.prototype, "hasTip", void 0), e([e3()], a.prototype, "vvSize", void 0), e([e3()], a.prototype, "vvColor", void 0), e([e3()], a.prototype, "vvOpacity", void 0), e([e3()], a.prototype, "hasOccludees", void 0), e([e3()], a.prototype, "hasMultipassTerrain", void 0), e([e3()], a.prototype, "cullAboveGround", void 0), e([e3({ constValue: true })], a.prototype, "hasVvInstancing", void 0), e([e3({ constValue: true })], a.prototype, "hasSliceTranslatedView", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/RibbonVertexPosition.glsl.js
var l = 8;
function s3(s4, u) {
  const c = s4.vertex;
  c.uniforms.add(new o4("intrinsicWidth", (e6) => e6.width)), u.vvSize ? (s4.attributes.add(O.SIZEFEATUREATTRIBUTE, "float"), c.uniforms.add(new e2("vvSizeMinSize", (e6) => e6.vvSizeMinSize)), c.uniforms.add(new e2("vvSizeMaxSize", (e6) => e6.vvSizeMaxSize)), c.uniforms.add(new e2("vvSizeOffset", (e6) => e6.vvSizeOffset)), c.uniforms.add(new e2("vvSizeFactor", (e6) => e6.vvSizeFactor)), c.code.add(n`float getSize() {
return intrinsicWidth * clamp(vvSizeOffset + sizeFeatureAttribute * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).x;
}`)) : (s4.attributes.add(O.SIZE, "float"), c.code.add(n`float getSize(){
return intrinsicWidth * size;
}`)), u.vvOpacity ? (s4.attributes.add(O.OPACITYFEATUREATTRIBUTE, "float"), c.constants.add("vvOpacityNumber", "int", 8), c.uniforms.add([new o2("vvOpacityValues", (e6) => e6.vvOpacityValues, l), new o2("vvOpacityOpacities", (e6) => e6.vvOpacityOpacities, l)]), c.code.add(n`float interpolateOpacity( float value ){
if (value <= vvOpacityValues[0]) {
return vvOpacityOpacities[0];
}
for (int i = 1; i < vvOpacityNumber; ++i) {
if (vvOpacityValues[i] >= value) {
float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);
return mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f);
}
}
return vvOpacityOpacities[vvOpacityNumber - 1];
}
vec4 applyOpacity( vec4 color ){
return vec4(color.xyz, interpolateOpacity(opacityFeatureAttribute));
}`)) : c.code.add(n`vec4 applyOpacity( vec4 color ){
return color;
}`), u.vvColor ? (s4.attributes.add(O.COLORFEATUREATTRIBUTE, "float"), c.constants.add("vvColorNumber", "int", o3), c.uniforms.add(new o2("vvColorValues", (e6) => e6.vvColorValues, o3)), c.uniforms.add(new e4("vvColorColors", (e6) => e6.vvColorColors, o3)), c.code.add(n`vec4 interpolateColor( float value ) {
if (value <= vvColorValues[0]) {
return vvColorColors[0];
}
for (int i = 1; i < vvColorNumber; ++i) {
if (vvColorValues[i] >= value) {
float f = (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);
return mix(vvColorColors[i-1], vvColorColors[i], f);
}
}
return vvColorColors[vvColorNumber - 1];
}
vec4 getColor(){
return applyOpacity(interpolateColor(colorFeatureAttribute));
}`)) : (s4.attributes.add(O.COLOR, "vec4"), c.code.add(n`vec4 getColor(){
return applyOpacity(color);
}`));
}

// node_modules/@arcgis/core/views/3d/support/engineContent/marker.js
var t2 = 64;
var o6 = t2 / 2;
var i = o6 / 5;
var m = t2 / i;
var e5 = 0.25;
function f(m2, e6) {
  return m2.fromData(`${e6}-marker`, () => o5(e6, t2, o6, i));
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/MarkerSizing.glsl.js
function i2(i3, n2) {
  const d = i3.vertex;
  i3.constants.add("markerSizePerLineWidth", "float", m), d.uniforms.add(new o4("pixelRatio", (e6, r) => r.camera.pixelRatio)), t(d.uniforms.get("markerScale")) && d.constants.add("markerScale", "float", 1), d.code.add(n`float getLineWidth() {
return max(getSize(), 1.0) * pixelRatio;
}
float getScreenMarkerSize() {
return markerSizePerLineWidth * markerScale * getLineWidth();
}`), n2.space === p.World && (d.constants.add("maxSegmentLengthFraction", "float", 0.45), d.uniforms.add(new o4("perRenderPixelRatio", (e6, r) => r.camera.perRenderPixelRatio)), d.code.add(n`float getWorldMarkerSize(vec4 pos) {
float distanceToCamera = length(pos.xyz);
float screenToWorldRatio = perRenderPixelRatio * distanceToCamera * 0.5;
return getScreenMarkerSize() * screenToWorldRatio;
}
bool areWorldMarkersHidden(vec4 pos, vec4 other) {
vec3 midPoint = mix(pos.xyz, other.xyz, 0.5);
float distanceToCamera = length(midPoint);
float screenToWorldRatio = perRenderPixelRatio * distanceToCamera * 0.5;
float worldMarkerSize = getScreenMarkerSize() * screenToWorldRatio;
float segmentLen = length(pos.xyz - other.xyz);
return worldMarkerSize > maxSegmentLengthFraction * segmentLen;
}`));
}

export {
  p,
  s2 as s,
  a,
  s3 as s2,
  t2 as t,
  o6 as o,
  e5 as e,
  f,
  i2 as i
};
//# sourceMappingURL=chunk-ELKWN2M6.js.map
