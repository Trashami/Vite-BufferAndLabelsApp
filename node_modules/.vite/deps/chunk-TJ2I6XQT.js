import {
  e
} from "./chunk-EDHROVWI.js";
import {
  s as s4,
  t as t2
} from "./chunk-34YPGGJT.js";
import {
  f,
  l,
  s as s3,
  y
} from "./chunk-EHPBHJYZ.js";
import {
  s as s2
} from "./chunk-LIZHLHNA.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";
import {
  c,
  r,
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/layers/graphics/featureConversionUtils.js
function h(t3, e2) {
  return t3 ? e2 ? 4 : 3 : e2 ? 3 : 2;
}
var d = s.getLogger("esri.layers.graphics.featureConversionUtils");
var m = { esriGeometryPoint: 0, esriGeometryPolyline: 2, esriGeometryPolygon: 3, esriGeometryMultipoint: 0 };
var g = (t3, e2, o, n, r2, s5) => {
  t3[o] = r2, t3[o + 1] = s5;
};
var y2 = (t3, e2, o, n, r2, s5) => {
  t3[o] = r2, t3[o + 1] = s5, t3[o + 2] = e2[n + 2];
};
var p = (t3, e2, o, n, r2, s5) => {
  t3[o] = r2, t3[o + 1] = s5, t3[o + 2] = e2[n + 3];
};
var I = (t3, e2, o, n, r2, s5) => {
  t3[o] = r2, t3[o + 1] = s5, t3[o + 2] = e2[n + 2], t3[o + 3] = e2[n + 3];
};
function b(t3, e2, o, n) {
  if (t3) {
    if (o)
      return e2 && n ? I : y2;
    if (e2 && n)
      return p;
  } else if (e2 && n)
    return y2;
  return g;
}
function w({ scale: t3, translate: e2 }, o) {
  return Math.round((o - e2[0]) / t3[0]);
}
function M({ scale: t3, translate: e2 }, o) {
  return Math.round((e2[1] - o) / t3[1]);
}
function T({ scale: t3, translate: e2 }, o, n) {
  return o * t3[n] + e2[n];
}
function F(t3, e2, o) {
  return t3 ? e2 ? o ? E(t3) : Z(t3) : o ? k(t3) : P(t3) : null;
}
function P(t3) {
  const e2 = t3.coords;
  return { x: e2[0], y: e2[1] };
}
function x(t3, e2) {
  return t3.coords[0] = e2.x, t3.coords[1] = e2.y, t3;
}
function Z(t3) {
  const e2 = t3.coords;
  return { x: e2[0], y: e2[1], z: e2[2] };
}
function j(t3, e2) {
  return t3.coords[0] = e2.x, t3.coords[1] = e2.y, t3.coords[2] = e2.z, t3;
}
function k(t3) {
  const e2 = t3.coords;
  return { x: e2[0], y: e2[1], m: e2[2] };
}
function v(t3, e2) {
  return t3.coords[0] = e2.x, t3.coords[1] = e2.y, t3.coords[2] = e2.m, t3;
}
function E(t3) {
  const e2 = t3.coords;
  return { x: e2[0], y: e2[1], z: e2[2], m: e2[3] };
}
function z(t3, e2) {
  return t3.coords[0] = e2.x, t3.coords[1] = e2.y, t3.coords[2] = e2.z, t3.coords[3] = e2.m, t3;
}
function S(t3, e2, n, r2) {
  let s5 = P;
  n && r2 ? s5 = E : n ? s5 = Z : r2 && (s5 = k);
  for (const c2 of e2) {
    const { geometry: e3, attributes: n2 } = c2, r3 = r(e3) ? s5(e3) : null;
    t3.push({ attributes: n2, geometry: r3 });
  }
  return t3;
}
function V(t3, e2) {
  return t3 && e2 ? z : t3 ? j : e2 ? v : x;
}
function Y(t3, e2, n, r2, s5) {
  const c2 = V(n, r2);
  for (const { geometry: u, attributes: l2 } of e2) {
    const e3 = r(u) ? c2(new t2(), u) : null;
    t3.push(new s4(e3, l2, null, s5 ? l2[s5] : void 0));
  }
  return t3;
}
function _(t3, e2, o = V(null != e2.z, null != e2.m)) {
  return o(t3, e2);
}
function L(t3, e2, n, r2) {
  for (const { geometry: s5, attributes: c2 } of e2)
    t3.push({ attributes: c2, geometry: r(s5) ? O(s5, n, r2) : null });
  return t3;
}
function O(t3, e2, o) {
  if (t(t3))
    return null;
  const r2 = h(e2, o), s5 = [];
  for (let n = 0; n < t3.coords.length; n += r2) {
    const e3 = [];
    for (let o2 = 0; o2 < r2; o2++)
      e3.push(t3.coords[n + o2]);
    s5.push(e3);
  }
  return e2 ? o ? { points: s5, hasZ: e2, hasM: o } : { points: s5, hasZ: e2 } : o ? { points: s5, hasM: o } : { points: s5 };
}
function U(t3, e2, n, r2, s5) {
  const c2 = h(n, r2);
  for (const { geometry: u, attributes: l2 } of e2) {
    const e3 = r(u) ? A(new t2(), u, c2) : null;
    t3.push(new s4(e3, l2, null, s5 ? l2[s5] : void 0));
  }
  return t3;
}
function A(t3, e2, o = h(e2.hasZ, e2.hasM)) {
  t3.lengths[0] = e2.points.length;
  const n = t3.coords;
  let r2 = 0;
  for (const s5 of e2.points)
    for (let t4 = 0; t4 < o; t4++)
      n[r2++] = s5[t4];
  return t3;
}
function q(t3, e2, n, r2) {
  for (const { geometry: s5, attributes: c2 } of e2)
    t3.push({ attributes: c2, geometry: r(s5) ? $(s5, n, r2) : null });
  return t3;
}
function $(t3, e2, o) {
  if (!t3)
    return null;
  const n = h(e2, o), { coords: r2, lengths: s5 } = t3, c2 = [];
  let u = 0;
  for (const l2 of s5) {
    const t4 = [];
    for (let e3 = 0; e3 < l2; e3++) {
      const e4 = [];
      for (let t5 = 0; t5 < n; t5++)
        e4.push(r2[u++]);
      t4.push(e4);
    }
    c2.push(t4);
  }
  return e2 ? o ? { paths: c2, hasZ: e2, hasM: o } : { paths: c2, hasZ: e2 } : o ? { paths: c2, hasM: o } : { paths: c2 };
}
function R(t3, e2, n, r2, s5) {
  const c2 = h(n, r2);
  for (const { geometry: u, attributes: l2 } of e2) {
    const e3 = r(u) ? C(new t2(), u, c2) : null;
    t3.push(new s4(e3, l2, null, s5 ? l2[s5] : void 0));
  }
  return t3;
}
function C(t3, e2, o = h(e2.hasZ, e2.hasM)) {
  const { lengths: n, coords: r2 } = t3;
  let s5 = 0;
  for (const c2 of e2.paths) {
    for (const t4 of c2)
      for (let e3 = 0; e3 < o; e3++)
        r2[s5++] = t4[e3];
    n.push(c2.length);
  }
  return t3;
}
function B(t3, e2, n, r2) {
  for (const { geometry: s5, attributes: c2, centroid: u } of e2) {
    const e3 = r(s5) ? D(s5, n, r2) : null;
    if (r(u)) {
      const o = P(u);
      t3.push({ attributes: c2, centroid: o, geometry: e3 });
    } else
      t3.push({ attributes: c2, geometry: e3 });
  }
  return t3;
}
function D(t3, e2, o) {
  if (!t3)
    return null;
  const n = h(e2, o), { coords: r2, lengths: s5 } = t3, c2 = [];
  let u = 0;
  for (const l2 of s5) {
    const t4 = [];
    for (let e3 = 0; e3 < l2; e3++) {
      const e4 = [];
      for (let t5 = 0; t5 < n; t5++)
        e4.push(r2[u++]);
      t4.push(e4);
    }
    c2.push(t4);
  }
  return e2 ? o ? { rings: c2, hasZ: e2, hasM: o } : { rings: c2, hasZ: e2 } : o ? { rings: c2, hasM: o } : { rings: c2 };
}
function H(t3, e2, n, r2, s5) {
  for (const { geometry: c2, centroid: u, attributes: l2 } of e2) {
    const e3 = r(c2) ? J(new t2(), c2, n, r2) : null, f2 = s5 ? l2[s5] : void 0;
    r(u) ? t3.push(new s4(e3, l2, x(new t2(), u), f2)) : t3.push(new s4(e3, l2, null, f2));
  }
  return t3;
}
function J(t3, e2, o = e2.hasZ, n = e2.hasM) {
  return K(t3, e2.rings, o, n), t3;
}
function K(t3, e2, o, n) {
  const r2 = h(o, n), { lengths: s5, coords: c2 } = t3;
  let u = 0;
  Tt(t3);
  for (const l2 of e2) {
    for (const t4 of l2)
      for (let e3 = 0; e3 < r2; e3++)
        c2[u++] = t4[e3];
    s5.push(l2.length);
  }
  return t3;
}
var Q = [];
var W = [];
function X(t3, e2, o, n, r2) {
  Q[0] = t3;
  const [s5] = tt(W, Q, e2, o, n, r2);
  return Ft(Q), Ft(W), s5;
}
function tt(e2, o, n, r2, s5, c2) {
  if (Ft(e2), !n) {
    for (const t3 of o) {
      const o2 = c2 ? t3.attributes[c2] : void 0;
      e2.push(new s4(null, t3.attributes, null, o2));
    }
    return e2;
  }
  switch (n) {
    case "esriGeometryPoint":
      return Y(e2, o, r2, s5, c2);
    case "esriGeometryMultipoint":
      return U(e2, o, r2, s5, c2);
    case "esriGeometryPolyline":
      return R(e2, o, r2, s5, c2);
    case "esriGeometryPolygon":
      return H(e2, o, r2, s5, c2);
    default:
      d.error("convertToFeatureSet:unknown-geometry", new s2(`Unable to parse unknown geometry type '${n}'`)), Ft(e2);
  }
  return e2;
}
function et(e2, o, n, r2, s5, c2) {
  const u = e2.length;
  switch (n) {
    case "esriGeometryPoint":
      Y(e2, o, r2, s5, c2);
      break;
    case "esriGeometryMultipoint":
      U(e2, o, r2, s5, c2);
      break;
    case "esriGeometryPolyline":
      R(e2, o, r2, s5, c2);
      break;
    case "esriGeometryPolygon":
      H(e2, o, r2, s5, c2);
      break;
    default:
      d.error("convertToFeatureSet:unknown-geometry", new s2(`Unable to parse unknown geometry type '${n}'`));
  }
  for (let t3 = 0; t3 < o.length; t3++)
    e2[t3 + u].geometryType = n, e2[t3 + u].insertAfter = o[t3].insertAfter, e2[t3 + u].groupId = o[t3].groupId;
  return e2;
}
function ot(t3, e2, o, n) {
  W[0] = t3, ct(Q, W, e2, o, n);
  const r2 = Q[0];
  return Ft(Q), Ft(W), r2;
}
function nt(e2, o, r2) {
  if (t(e2))
    return null;
  const i = new t2();
  if ("hasZ" in e2 && null == o && (o = e2.hasZ), "hasM" in e2 && null == r2 && (r2 = e2.hasM), s3(e2)) {
    return V(null != o ? o : null != e2.z, null != r2 ? r2 : null != e2.m)(i, e2);
  }
  return y(e2) ? J(i, e2, o, r2) : f(e2) ? C(i, e2, h(o, r2)) : l(e2) ? A(i, e2, h(o, r2)) : void d.error("convertFromGeometry:unknown-geometry", new s2(`Unable to parse unknown geometry type '${e2}'`));
}
function rt(e2, o, r2, s5) {
  const c2 = e2 && ("coords" in e2 ? e2 : e2.geometry);
  if (t(c2))
    return null;
  switch (o) {
    case "esriGeometryPoint": {
      let t3 = P;
      return r2 && s5 ? t3 = E : r2 ? t3 = Z : s5 && (t3 = k), t3(c2);
    }
    case "esriGeometryMultipoint":
      return O(c2, r2, s5);
    case "esriGeometryPolyline":
      return $(c2, r2, s5);
    case "esriGeometryPolygon":
      return D(c2, r2, s5);
    default:
      return d.error("convertToGeometry:unknown-geometry", new s2(`Unable to parse unknown geometry type '${o}'`)), null;
  }
}
function st(t3, e2) {
  for (const o of e2)
    t3.push({ attributes: o.attributes });
  return t3;
}
function ct(e2, o, r2, s5, c2) {
  if (Ft(e2), t(r2))
    return st(e2, o);
  switch (r2) {
    case "esriGeometryPoint":
      return S(e2, o, s5, c2);
    case "esriGeometryMultipoint":
      return L(e2, o, s5, c2);
    case "esriGeometryPolyline":
      return q(e2, o, s5, c2);
    case "esriGeometryPolygon":
      return B(e2, o, s5, c2);
    default:
      d.error("convertToFeatureSet:unknown-geometry", new s2(`Unable to parse unknown geometry type '${r2}'`));
  }
  return e2;
}
function ut(t3) {
  const { objectIdFieldName: e2, spatialReference: o, transform: n, fields: r2, hasM: s5, hasZ: c2, features: u, geometryType: l2, exceededTransferLimit: i, uniqueIdField: f2, queryGeometry: a, queryGeometryType: h2 } = t3, d2 = { features: ct([], u, l2, c2, s5), fields: r2, geometryType: l2, objectIdFieldName: e2, spatialReference: o, uniqueIdField: f2, queryGeometry: rt(a, h2, false, false) };
  return n && (d2.transform = n), i && (d2.exceededTransferLimit = i), s5 && (d2.hasM = s5), c2 && (d2.hasZ = c2), d2;
}
function lt(e2, o) {
  var _a;
  const n = new e(), { hasM: r2, hasZ: s5, features: c2, objectIdFieldName: u, spatialReference: l2, geometryType: i, exceededTransferLimit: a, transform: h2, fields: m2 } = e2;
  return m2 && (n.fields = m2), n.geometryType = i != null ? i : null, n.objectIdFieldName = (_a = u != null ? u : o) != null ? _a : null, n.spatialReference = l2 != null ? l2 : null, n.objectIdFieldName ? (c2 && tt(n.features, c2, i, s5, r2, n.objectIdFieldName), a && (n.exceededTransferLimit = a), r2 && (n.hasM = r2), s5 && (n.hasZ = s5), h2 && (n.transform = h2), n) : (d.error(new s2("optimized-features:invalid-objectIdFieldName", "objectIdFieldName is missing")), n);
}
function it(t3) {
  const { transform: e2, features: n, hasM: r2, hasZ: s5 } = t3;
  if (!e2)
    return t3;
  for (const c2 of n)
    r(c2.geometry) && pt(c2.geometry, c2.geometry, r2, s5, e2), r(c2.centroid) && pt(c2.centroid, c2.centroid, r2, s5, e2);
  return t3.transform = null, t3;
}
function ft(t3, e2) {
  const { geometryType: o, features: n, hasM: r2, hasZ: s5 } = e2;
  if (!t3)
    return e2;
  for (let c2 = 0; c2 < n.length; c2++) {
    const e3 = n[c2], u = e3.weakClone();
    u.geometry = new t2(), at(u.geometry, e3.geometry, r2, s5, o, t3), e3.centroid && (u.centroid = new t2(), at(u.centroid, e3.centroid, r2, s5, "esriGeometryPoint", t3)), n[c2] = u;
  }
  return e2.transform = t3, e2;
}
function at(t3, e2, o, r2, s5, c2, u = o, l2 = r2) {
  if (Tt(t3), t(e2) || !e2.coords.length)
    return null;
  const i = m[s5], { coords: f2, lengths: a } = e2, d2 = h(o, r2), g2 = h(o && u, r2 && l2), y3 = b(o, r2, u, l2);
  if (!a.length)
    return y3(t3.coords, f2, 0, 0, w(c2, f2[0]), M(c2, f2[1])), Tt(t3, d2, 0), t3;
  let p2, I2, N, G, T2 = 0, F2 = 0, P2 = F2;
  for (const n of a) {
    if (n < i)
      continue;
    let e3 = 0;
    F2 = P2, N = p2 = w(c2, f2[T2]), G = I2 = M(c2, f2[T2 + 1]), y3(t3.coords, f2, F2, T2, N, G), e3++, T2 += d2, F2 += g2;
    for (let o2 = 1; o2 < n; o2++, T2 += d2)
      N = w(c2, f2[T2]), G = M(c2, f2[T2 + 1]), N === p2 && G === I2 || (y3(t3.coords, f2, F2, T2, N - p2, G - I2), F2 += g2, e3++, p2 = N, I2 = G);
    e3 >= i && (t3.lengths.push(e3), P2 = F2);
  }
  return Ft(t3.coords, P2), t3.coords.length ? t3 : null;
}
function ht(t3, e2, o, n, r2, s5, c2 = o, u = n) {
  if (Tt(t3), !e2 || !e2.coords.length)
    return null;
  const l2 = m[r2], { coords: i, lengths: f2 } = e2, a = h(o, n), d2 = h(o && c2, n && u), g2 = b(o, n, c2, u);
  if (!f2.length)
    return g2(t3.coords, i, 0, 0, i[0], i[1]), Tt(t3, a, 0), t3;
  let y3 = 0;
  const p2 = s5 * s5;
  for (const h2 of f2) {
    if (h2 < l2) {
      y3 += h2 * a;
      continue;
    }
    const e3 = t3.coords.length / d2, o2 = y3, n2 = y3 + (h2 - 1) * a;
    g2(t3.coords, i, t3.coords.length, o2, i[o2], i[o2 + 1]), mt(t3.coords, i, a, p2, g2, o2, n2), g2(t3.coords, i, t3.coords.length, n2, i[n2], i[n2 + 1]);
    const r3 = t3.coords.length / d2 - e3;
    r3 >= l2 ? t3.lengths.push(r3) : Ft(t3.coords, e3 * d2), y3 += h2 * a;
  }
  return t3.coords.length ? t3 : null;
}
function dt(t3, e2, o, n) {
  const r2 = t3[e2], s5 = t3[e2 + 1], c2 = t3[o], u = t3[o + 1], l2 = t3[n], i = t3[n + 1];
  let f2 = c2, a = u, h2 = l2 - f2, d2 = i - a;
  if (0 !== h2 || 0 !== d2) {
    const t4 = ((r2 - f2) * h2 + (s5 - a) * d2) / (h2 * h2 + d2 * d2);
    t4 > 1 ? (f2 = l2, a = i) : t4 > 0 && (f2 += h2 * t4, a += d2 * t4);
  }
  return h2 = r2 - f2, d2 = s5 - a, h2 * h2 + d2 * d2;
}
function mt(t3, e2, o, n, r2, s5, c2) {
  let u, l2 = n, i = 0;
  for (let f2 = s5 + o; f2 < c2; f2 += o)
    u = dt(e2, f2, s5, c2), u > l2 && (i = f2, l2 = u);
  l2 > n && (i - s5 > o && mt(t3, e2, o, n, r2, s5, i), r2(t3, e2, t3.length, i, e2[i], e2[i + 1]), c2 - i > o && mt(t3, e2, o, n, r2, i, c2));
}
function gt(t3, e2, o, r2) {
  if (t(e2) || !e2.coords || !e2.coords.length)
    return null;
  const s5 = h(o, r2);
  let c2 = Number.POSITIVE_INFINITY, u = Number.POSITIVE_INFINITY, l2 = Number.NEGATIVE_INFINITY, i = Number.NEGATIVE_INFINITY;
  if (e2 && e2.coords) {
    const t4 = e2.coords;
    for (let e3 = 0; e3 < t4.length; e3 += s5) {
      const o2 = t4[e3], n = t4[e3 + 1];
      c2 = Math.min(c2, o2), l2 = Math.max(l2, o2), u = Math.min(u, n), i = Math.max(i, n);
    }
  }
  return t3[0] = c2, t3[1] = u, t3[2] = l2, t3[3] = i, t3;
}
function pt(t3, e2, o, n, s5) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const { coords: c2, lengths: u } = e2, l2 = h(o, n);
  if (!c2.length)
    return t3 !== e2 && Tt(t3), t3;
  c(s5);
  const { originPosition: i, scale: f2, translate: a } = s5, d2 = Pt;
  d2.originPosition = i;
  const m2 = d2.scale;
  m2[0] = (_a = f2[0]) != null ? _a : 1, m2[1] = -((_b = f2[1]) != null ? _b : 1), m2[2] = (_c = f2[2]) != null ? _c : 1, m2[3] = (_d = f2[3]) != null ? _d : 1;
  const g2 = d2.translate;
  if (g2[0] = (_e = a[0]) != null ? _e : 0, g2[1] = (_f = a[1]) != null ? _f : 0, g2[2] = (_g = a[2]) != null ? _g : 0, g2[3] = (_h = a[3]) != null ? _h : 0, !u.length) {
    for (let e3 = 0; e3 < l2; ++e3)
      t3.coords[e3] = T(d2, c2[e3], e3);
    return t3 !== e2 && Tt(t3, l2, 0), t3;
  }
  let y3 = 0;
  for (let r2 = 0; r2 < u.length; r2++) {
    const e3 = u[r2];
    t3.lengths[r2] = e3;
    for (let r3 = 0; r3 < l2; ++r3)
      t3.coords[y3 + r3] = T(d2, c2[y3 + r3], r3);
    let o2 = t3.coords[y3], n2 = t3.coords[y3 + 1];
    y3 += l2;
    for (let r3 = 1; r3 < e3; r3++, y3 += l2) {
      o2 += c2[y3] * m2[0], n2 += c2[y3 + 1] * m2[1], t3.coords[y3] = o2, t3.coords[y3 + 1] = n2;
      for (let e4 = 2; e4 < l2; ++e4)
        t3.coords[y3 + e4] = T(d2, c2[y3 + e4], e4);
    }
  }
  return t3 !== e2 && Tt(t3, c2.length, u.length), t3;
}
function It(t3, e2, o, n, r2, s5) {
  if (Tt(t3), t3.lengths.push(...e2.lengths), o === r2 && n === s5)
    for (let c2 = 0; c2 < e2.coords.length; c2++)
      t3.coords.push(e2.coords[c2]);
  else {
    const c2 = h(o, n), u = b(o, n, r2, s5), l2 = e2.coords;
    for (let e3 = 0; e3 < l2.length; e3 += c2)
      u(t3.coords, l2, t3.coords.length, e3, l2[e3], l2[e3 + 1]);
  }
  return t3;
}
function wt(t3, e2, o, n) {
  let r2 = 0, s5 = t3[n * e2], c2 = t3[n * (e2 + 1)];
  for (let u = 1; u < o; u++) {
    const o2 = s5 + t3[n * (e2 + u)], l2 = c2 + t3[n * (e2 + u) + 1], i = (o2 - s5) * (l2 + c2);
    s5 = o2, c2 = l2, r2 += i;
  }
  return 0.5 * r2;
}
function Mt(t3, e2) {
  const { coords: o, lengths: n } = t3;
  let r2 = 0, s5 = 0;
  for (let c2 = 0; c2 < n.length; c2++) {
    const t4 = n[c2];
    s5 += wt(o, r2, t4, e2), r2 += t4;
  }
  return Math.abs(s5);
}
function Gt(t3, e2) {
  if (t(t3))
    return null;
  const o = t3.clone(), r2 = t3.coords, s5 = t3.lengths;
  let c2 = 0;
  for (let n = 0; n < s5.length; n++) {
    const t4 = s5[n];
    let u = r2[e2 * c2], l2 = r2[e2 * c2 + 1];
    for (let n2 = 1; n2 < t4; n2++) {
      const t5 = u + r2[e2 * (c2 + n2)], s6 = l2 + r2[e2 * (c2 + n2) + 1];
      o.coords[e2 * (c2 + n2)] = t5, o.coords[e2 * (c2 + n2) + 1] = s6, u = t5, l2 = s6;
    }
    c2 += t4;
  }
  return o;
}
function Tt(t3, e2 = 0, o = 0) {
  Ft(t3.lengths, o), Ft(t3.coords, e2);
}
function Ft(t3, e2 = 0) {
  t3.length !== e2 && (t3.length = e2);
}
var Pt = { originPosition: "lowerLeft", scale: [1, 1, 1, 1], translate: [0, 0, 0, 0] };

export {
  w,
  M,
  F,
  _,
  O,
  $,
  C,
  D,
  J,
  K,
  X,
  tt,
  et,
  ot,
  nt,
  rt,
  ut,
  lt,
  it,
  ft,
  at,
  ht,
  gt,
  pt,
  It,
  Mt,
  Gt
};
//# sourceMappingURL=chunk-TJ2I6XQT.js.map
