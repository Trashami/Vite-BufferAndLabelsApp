import {
  E as E4,
  d,
  e as e13,
  f2 as f4,
  m as m2,
  o as o9,
  y
} from "./chunk-7ZSUZDMT.js";
import {
  s as s4
} from "./chunk-OF6PIPJD.js";
import {
  L as L2
} from "./chunk-IMFUUJSK.js";
import {
  A as A3,
  S as S2,
  a as a3,
  c as c4,
  l as l2
} from "./chunk-5SEVEYDG.js";
import {
  T
} from "./chunk-ZNZ4EIIF.js";
import {
  X
} from "./chunk-ZZLJFOS7.js";
import {
  i as i7
} from "./chunk-K3TAVS2D.js";
import {
  R
} from "./chunk-J3QY3JS6.js";
import {
  c as c5,
  f as f3,
  i as i6
} from "./chunk-KBM2LGNP.js";
import {
  e as e12,
  o as o8,
  t as t6
} from "./chunk-HP6QT5KY.js";
import {
  d as d2,
  d2 as d3,
  h as h3
} from "./chunk-WEBU4A2Q.js";
import {
  e as e14
} from "./chunk-6WTG5RYO.js";
import {
  E as E3,
  L as L3,
  d2 as d4,
  o2 as o5,
  x as x2
} from "./chunk-HNRPDSCT.js";
import {
  i as i8
} from "./chunk-AMNM3DGI.js";
import {
  o as o7
} from "./chunk-RNRS2JL4.js";
import {
  h as h2
} from "./chunk-SBPLVEUA.js";
import {
  t as t5
} from "./chunk-XTFH7327.js";
import {
  W,
  _,
  a as a2,
  h as h4
} from "./chunk-MOPTUDCV.js";
import {
  C,
  e as e11,
  n as n4
} from "./chunk-D2XA6Z6P.js";
import {
  o as o6
} from "./chunk-MYQCUAHK.js";
import {
  O as O3
} from "./chunk-RUM3DXFX.js";
import {
  e as e8,
  f2,
  i as i4,
  m,
  n2,
  n3,
  o as o2,
  o2 as o3,
  o3 as o4,
  r as r6,
  r2 as r7,
  t as t3
} from "./chunk-2DWNY35K.js";
import {
  D,
  E as E2,
  I
} from "./chunk-3OFVLRSL.js";
import {
  e2 as e7,
  f,
  r as r5,
  t as t2
} from "./chunk-C6HDWDWX.js";
import {
  E,
  L,
  O as O2,
  c as c2,
  i as i2,
  u,
  x
} from "./chunk-67RD6CZ4.js";
import {
  e as e6
} from "./chunk-IVLBGTXL.js";
import {
  e as e5
} from "./chunk-GHN7C53L.js";
import {
  a
} from "./chunk-4HL6BBWO.js";
import {
  c as c3,
  i as i5
} from "./chunk-UDYHZLTE.js";
import {
  e as e10,
  t as t4
} from "./chunk-IQBIGNPU.js";
import {
  r as r9
} from "./chunk-4JNOVZUK.js";
import {
  e as e9
} from "./chunk-OJ2HHY2O.js";
import {
  g as g2,
  i as i3
} from "./chunk-ZNRXLY4R.js";
import {
  r as r8
} from "./chunk-4BIBXEQB.js";
import {
  l
} from "./chunk-MFXTPFHI.js";
import {
  r as r4
} from "./chunk-NDQ5FHGV.js";
import {
  b
} from "./chunk-HUQX7WZO.js";
import {
  h
} from "./chunk-RT3T2K4S.js";
import {
  A as A2,
  c
} from "./chunk-XMZAPOBR.js";
import {
  A,
  O,
  P,
  S,
  e as e3,
  g,
  i,
  o,
  r as r3,
  s,
  z
} from "./chunk-3LR5O4WA.js";
import {
  e as e2,
  n,
  r as r2
} from "./chunk-D4V6J5BT.js";
import {
  U
} from "./chunk-DMI7A7TC.js";
import {
  e as e4
} from "./chunk-OOLCFNXJ.js";
import {
  w
} from "./chunk-MJXQTGI2.js";
import {
  s as s3
} from "./chunk-LIZHLHNA.js";
import {
  s2
} from "./chunk-UA3YPL2R.js";
import {
  has
} from "./chunk-HVKDYDPP.js";
import {
  e,
  q,
  r,
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/views/3d/glTF/internal/TextureTransformUtils.js
function c6(c8) {
  if (t(c8))
    return null;
  const m3 = r(c8.offset) ? c8.offset : c3, e15 = r(c8.rotation) ? c8.rotation : 0, i9 = r(c8.scale) ? c8.scale : i5, h5 = t4(1, 0, 0, 0, 1, 0, m3[0], m3[1], 1), u2 = t4(Math.cos(e15), -Math.sin(e15), 0, Math.sin(e15), Math.cos(e15), 0, 0, 0, 1), p = t4(i9[0], 0, 0, 0, i9[1], 0, 0, 0, 1), j3 = e10();
  return i3(j3, u2, p), i3(j3, h5, j3), j3;
}

// node_modules/@arcgis/core/views/3d/layers/graphics/ProcessedObjectResource.js
var s5 = class {
  constructor(s6, t8, e15, h5, i9) {
    this.name = s6, this.stageResources = t8, this.lodThreshold = e15, this.pivotOffset = h5, this.numberOfVertices = i9;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/DefaultMaterialTechnique.js
var k = class extends f3 {
  constructor() {
    super(...arguments), this.isSchematic = false, this.usePBR = false, this.mrrFactors = r2(0, 1, 0.5), this.hasVertexColors = false, this.hasSymbolColors = false, this.doubleSided = false, this.doubleSidedType = "normal", this.cullFace = n4.Back, this.emissiveFactor = r2(0, 0, 0), this.instancedDoublePrecision = false, this.normals = "default", this.receiveSSAO = true, this.receiveShadows = true, this.castShadows = true, this.shadowMappingEnabled = false, this.ambient = r2(0.2, 0.2, 0.2), this.diffuse = r2(0.8, 0.8, 0.8), this.externalColor = r4(1, 1, 1, 1), this.colorMixMode = "multiply", this.opacity = 1, this.layerOpacity = 1, this.origin = n(), this.hasSlicePlane = false, this.hasSliceHighlight = true, this.offsetTransparentBackfaces = false, this.vvSizeEnabled = false, this.vvSizeMinSize = [1, 1, 1], this.vvSizeMaxSize = [100, 100, 100], this.vvSizeOffset = [0, 0, 0], this.vvSizeFactor = [1, 1, 1], this.vvSizeValue = [1, 1, 1], this.vvColorEnabled = false, this.vvColorValues = [0, 0, 0, 0, 0, 0, 0, 0], this.vvColorColors = [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], this.vvSymbolAnchor = [0, 0, 0], this.vvSymbolRotationMatrix = e5(), this.vvOpacityEnabled = false, this.vvOpacityValues = [], this.vvOpacityOpacities = [], this.transparent = false, this.writeDepth = true, this.customDepthTest = e11.Less, this.textureAlphaMode = C.Blend, this.textureAlphaCutoff = o7, this.textureAlphaPremultiplied = false, this.hasOccludees = false, this.renderOccluded = o5.Occlude;
  }
};
var E5 = class extends c5 {
  constructor() {
    super(...arguments), this.origin = n(), this.slicePlaneLocalOrigin = this.origin;
  }
};
var _2 = class extends e12 {
  initializeConfiguration(e15, t8) {
    t8.hasWebGL2Context = e15.rctx.type === r9.WEBGL2, t8.spherical = e15.viewingMode === l.Global, t8.doublePrecisionRequiresObfuscation = i8(e15.rctx), t8.textureCoordinateType = t8.hasColorTexture || t8.hasMetallicRoughnessTexture || t8.hasEmissionTexture || t8.hasOcclusionTexture || t8.hasNormalTexture ? d2.Default : d2.None, t8.objectAndLayerIdColorInstanced = t8.instanced;
  }
  initializeProgram(e15) {
    return this._initializeProgram(e15, _2.shader);
  }
  _initializeProgram(e15, t8) {
    return new o8(e15.rctx, t8.get().build(this.configuration), E3);
  }
  _convertDepthTestFunction(e15) {
    return e15 === e11.Lequal ? I.LEQUAL : I.LESS;
  }
  _makePipeline(e15, t8) {
    const i9 = this.configuration, s6 = e15 === o6.NONE, r10 = e15 === o6.FrontFace;
    return W({ blending: i9.output !== h2.Color && i9.output !== h2.Alpha || !i9.transparent ? null : s6 ? c4 : A3(e15), culling: V(i9) && h4(i9.cullFace), depthTest: { func: l2(e15, this._convertDepthTestFunction(i9.customDepthTest)) }, depthWrite: s6 || r10 ? i9.writeDepth && a2 : null, colorWrite: _, stencilWrite: i9.hasOccludees ? e13 : null, stencilTest: i9.hasOccludees ? t8 ? o9 : f4 : null, polygonOffset: s6 || r10 ? null : a3(i9.enableOffset) });
  }
  initializePipeline() {
    return this._occludeePipelineState = this._makePipeline(this.configuration.transparencyPassType, true), this._makePipeline(this.configuration.transparencyPassType, false);
  }
  getPipelineState(e15, t8) {
    return t8 ? this._occludeePipelineState : super.getPipelineState(e15, t8);
  }
};
function V(e15) {
  return e15.cullFace !== n4.None || !e15.hasSlicePlane && (!e15.transparent && !e15.doubleSidedMode);
}
_2.shader = new t6(X, () => import("./DefaultMaterial.glsl-2HPLQF47.js"));

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/DefaultMaterialTechniqueConfiguration.js
var c7 = class extends s4 {
  constructor() {
    super(...arguments), this.output = h2.Color, this.alphaDiscardMode = C.Opaque, this.doubleSidedMode = i7.None, this.pbrMode = d3.Disabled, this.cullFace = n4.None, this.transparencyPassType = o6.NONE, this.normalType = i6.Attribute, this.textureCoordinateType = d2.None, this.customDepthTest = e11.Less, this.spherical = false, this.hasVertexColors = false, this.hasSymbolColors = false, this.hasVerticalOffset = false, this.hasSlicePlane = false, this.hasSliceHighlight = true, this.hasColorTexture = false, this.hasMetallicRoughnessTexture = false, this.hasEmissionTexture = false, this.hasOcclusionTexture = false, this.hasNormalTexture = false, this.hasScreenSizePerspective = false, this.hasVertexTangents = false, this.hasOccludees = false, this.hasMultipassTerrain = false, this.hasModelTransformation = false, this.offsetBackfaces = false, this.vvSize = false, this.vvColor = false, this.receiveShadows = false, this.receiveAmbientOcclusion = false, this.textureAlphaPremultiplied = false, this.instanced = false, this.instancedColor = false, this.objectAndLayerIdColorInstanced = false, this.instancedDoublePrecision = false, this.doublePrecisionRequiresObfuscation = false, this.writeDepth = true, this.transparent = false, this.enableOffset = true, this.cullAboveGround = false, this.snowCover = false, this.hasColorTextureTransform = false, this.hasEmissionTextureTransform = false, this.hasNormalTextureTransform = false, this.hasOcclusionTextureTransform = false, this.hasMetallicRoughnessTextureTransform = false;
  }
};
e4([e14({ count: h2.COUNT })], c7.prototype, "output", void 0), e4([e14({ count: C.COUNT })], c7.prototype, "alphaDiscardMode", void 0), e4([e14({ count: i7.COUNT })], c7.prototype, "doubleSidedMode", void 0), e4([e14({ count: d3.COUNT })], c7.prototype, "pbrMode", void 0), e4([e14({ count: n4.COUNT })], c7.prototype, "cullFace", void 0), e4([e14({ count: o6.COUNT })], c7.prototype, "transparencyPassType", void 0), e4([e14({ count: i6.COUNT })], c7.prototype, "normalType", void 0), e4([e14({ count: d2.COUNT })], c7.prototype, "textureCoordinateType", void 0), e4([e14({ count: e11.COUNT })], c7.prototype, "customDepthTest", void 0), e4([e14()], c7.prototype, "spherical", void 0), e4([e14()], c7.prototype, "hasVertexColors", void 0), e4([e14()], c7.prototype, "hasSymbolColors", void 0), e4([e14()], c7.prototype, "hasVerticalOffset", void 0), e4([e14()], c7.prototype, "hasSlicePlane", void 0), e4([e14()], c7.prototype, "hasSliceHighlight", void 0), e4([e14()], c7.prototype, "hasColorTexture", void 0), e4([e14()], c7.prototype, "hasMetallicRoughnessTexture", void 0), e4([e14()], c7.prototype, "hasEmissionTexture", void 0), e4([e14()], c7.prototype, "hasOcclusionTexture", void 0), e4([e14()], c7.prototype, "hasNormalTexture", void 0), e4([e14()], c7.prototype, "hasScreenSizePerspective", void 0), e4([e14()], c7.prototype, "hasVertexTangents", void 0), e4([e14()], c7.prototype, "hasOccludees", void 0), e4([e14()], c7.prototype, "hasMultipassTerrain", void 0), e4([e14()], c7.prototype, "hasModelTransformation", void 0), e4([e14()], c7.prototype, "offsetBackfaces", void 0), e4([e14()], c7.prototype, "vvSize", void 0), e4([e14()], c7.prototype, "vvColor", void 0), e4([e14()], c7.prototype, "receiveShadows", void 0), e4([e14()], c7.prototype, "receiveAmbientOcclusion", void 0), e4([e14()], c7.prototype, "textureAlphaPremultiplied", void 0), e4([e14()], c7.prototype, "instanced", void 0), e4([e14()], c7.prototype, "instancedColor", void 0), e4([e14()], c7.prototype, "objectAndLayerIdColorInstanced", void 0), e4([e14()], c7.prototype, "instancedDoublePrecision", void 0), e4([e14()], c7.prototype, "doublePrecisionRequiresObfuscation", void 0), e4([e14()], c7.prototype, "writeDepth", void 0), e4([e14()], c7.prototype, "transparent", void 0), e4([e14()], c7.prototype, "enableOffset", void 0), e4([e14()], c7.prototype, "cullAboveGround", void 0), e4([e14()], c7.prototype, "snowCover", void 0), e4([e14()], c7.prototype, "hasColorTextureTransform", void 0), e4([e14()], c7.prototype, "hasEmissionTextureTransform", void 0), e4([e14()], c7.prototype, "hasNormalTextureTransform", void 0), e4([e14()], c7.prototype, "hasOcclusionTextureTransform", void 0), e4([e14()], c7.prototype, "hasMetallicRoughnessTextureTransform", void 0), e4([e14({ constValue: true })], c7.prototype, "hasVvInstancing", void 0), e4([e14({ constValue: false })], c7.prototype, "useCustomDTRExponentForWater", void 0), e4([e14({ constValue: false })], c7.prototype, "supportsTextureAtlas", void 0), e4([e14({ constValue: true })], c7.prototype, "useFillLights", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/RealisticTreeTechnique.js
var t7 = class extends _2 {
  initializeConfiguration(i9, a4) {
    super.initializeConfiguration(i9, a4), a4.hasMetallicRoughnessTexture = false, a4.hasEmissionTexture = false, a4.hasOcclusionTexture = false, a4.hasNormalTexture = false, a4.hasModelTransformation = false, a4.normalType = i6.Attribute, a4.doubleSidedMode = i7.WindingOrder, a4.hasVertexTangents = false;
  }
  initializeProgram(e15) {
    return this._initializeProgram(e15, t7.shader);
  }
};
t7.shader = new t6(R, () => import("./RealisticTree.glsl-RMRUGX6B.js"));

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/DefaultMaterial.js
var C2 = class extends d4 {
  constructor(e15) {
    super(e15, P2), this.supportsEdges = true, this._configuration = new c7(), this._vertexBufferLayout = j(this.parameters), this._instanceBufferLayout = e15.instanced ? B(this.parameters) : null;
  }
  isVisibleForOutput(e15) {
    return e15 !== h2.Shadow && e15 !== h2.ShadowExludeHighlight && e15 !== h2.ShadowHighlight || this.parameters.castShadows;
  }
  isVisible() {
    const t8 = this.parameters;
    if (!super.isVisible() || 0 === t8.layerOpacity)
      return false;
    const { instanced: r10, hasVertexColors: a4, hasSymbolColors: s6, vvColorEnabled: i9 } = t8, o10 = r(r10) && r10.includes("color"), n5 = "replace" === t8.colorMixMode, h5 = t8.opacity > 0, c8 = t8.externalColor && t8.externalColor[3] > 0;
    return a4 && (o10 || i9 || s6) ? !!n5 || h5 : a4 ? n5 ? c8 : h5 : o10 || i9 || s6 ? !!n5 || h5 : n5 ? c8 : h5;
  }
  getConfiguration(t8, r10) {
    return this._configuration.output = t8, this._configuration.hasNormalTexture = !!this.parameters.normalTextureId, this._configuration.hasColorTexture = !!this.parameters.textureId, this._configuration.hasVertexTangents = this.parameters.hasVertexTangents, this._configuration.instanced = !!this.parameters.instanced, this._configuration.instancedDoublePrecision = this.parameters.instancedDoublePrecision, this._configuration.vvSize = this.parameters.vvSizeEnabled, this._configuration.hasVerticalOffset = r(this.parameters.verticalOffset), this._configuration.hasScreenSizePerspective = r(this.parameters.screenSizePerspective), this._configuration.hasSlicePlane = this.parameters.hasSlicePlane, this._configuration.hasSliceHighlight = this.parameters.hasSliceHighlight, this._configuration.alphaDiscardMode = this.parameters.textureAlphaMode, this._configuration.normalType = "screenDerivative" === this.parameters.normals ? i6.ScreenDerivative : i6.Attribute, this._configuration.transparent = this.parameters.transparent, this._configuration.writeDepth = this.parameters.writeDepth, r(this.parameters.customDepthTest) && (this._configuration.customDepthTest = this.parameters.customDepthTest), this._configuration.hasOccludees = this.parameters.hasOccludees, this._configuration.cullFace = this.parameters.hasSlicePlane ? n4.None : this.parameters.cullFace, this._configuration.hasMultipassTerrain = r10.multipassTerrain.enabled, this._configuration.cullAboveGround = r10.multipassTerrain.cullAboveGround, this._configuration.hasModelTransformation = r(this.parameters.modelTransformation), t8 !== h2.Color && t8 !== h2.Alpha || (this._configuration.hasVertexColors = this.parameters.hasVertexColors, this._configuration.hasSymbolColors = this.parameters.hasSymbolColors, this.parameters.treeRendering ? this._configuration.doubleSidedMode = i7.WindingOrder : this._configuration.doubleSidedMode = this.parameters.doubleSided && "normal" === this.parameters.doubleSidedType ? i7.View : this.parameters.doubleSided && "winding-order" === this.parameters.doubleSidedType ? i7.WindingOrder : i7.None, this._configuration.instancedColor = r(this.parameters.instanced) && this.parameters.instanced.includes("color"), this._configuration.receiveShadows = this.parameters.receiveShadows && this.parameters.shadowMappingEnabled, this._configuration.receiveAmbientOcclusion = !!r10.ssaoHelper.ready && this.parameters.receiveSSAO, this._configuration.vvColor = this.parameters.vvColorEnabled, this._configuration.textureAlphaPremultiplied = !!this.parameters.textureAlphaPremultiplied, this._configuration.pbrMode = this.parameters.usePBR ? this.parameters.isSchematic ? d3.Schematic : d3.Normal : d3.Disabled, this._configuration.hasMetallicRoughnessTexture = !!this.parameters.metallicRoughnessTextureId, this._configuration.hasEmissionTexture = !!this.parameters.emissiveTextureId, this._configuration.hasOcclusionTexture = !!this.parameters.occlusionTextureId, this._configuration.offsetBackfaces = !(!this.parameters.transparent || !this.parameters.offsetTransparentBackfaces), this._configuration.transparencyPassType = r10.transparencyPassType, this._configuration.enableOffset = r10.camera.relativeElevation < S2, this._configuration.snowCover = this.hasSnowCover(r10), this._configuration.hasColorTextureTransform = !!this.parameters.colorTextureTransformMatrix, this._configuration.hasNormalTextureTransform = !!this.parameters.normalTextureTransformMatrix, this._configuration.hasEmissionTextureTransform = !!this.parameters.emissiveTextureTransformMatrix, this._configuration.hasOcclusionTextureTransform = !!this.parameters.occlusionTextureTransformMatrix, this._configuration.hasMetallicRoughnessTextureTransform = !!this.parameters.metallicRoughnessTextureTransformMatrix), this._configuration;
  }
  hasSnowCover(t8) {
    return r(t8.weather) && t8.weatherVisible && "snowy" === t8.weather.type && "enabled" === t8.weather.snowCover;
  }
  intersect(c8, u2, m3, p, d5, f5, g3) {
    if (r(this.parameters.verticalOffset)) {
      const e15 = p.camera;
      o(k2, m3[12], m3[13], m3[14]);
      let c9 = null;
      switch (p.viewingMode) {
        case l.Global:
          c9 = z(U2, k2);
          break;
        case l.Local:
          c9 = r3(U2, G);
      }
      let u3 = 0;
      const g4 = e3(q2, k2, e15.eye), T3 = s(g4), _3 = g(g4, g4, 1 / T3);
      let b3 = null;
      this.parameters.screenSizePerspective && (b3 = P(c9, _3)), u3 += L3(e15, T3, this.parameters.verticalOffset, b3, this.parameters.screenSizePerspective), g(c9, c9, u3), S(z2, c9, p.transform.inverseRotation), d5 = e3(V2, d5, z2), f5 = e3(H, f5, z2);
    }
    x2(c8, u2, p, d5, f5, y(p.verticalOffset), g3);
  }
  requiresSlot(e15, t8) {
    if (t8 === h2.Color || t8 === h2.Alpha || t8 === h2.Depth || t8 === h2.Normal || t8 === h2.Shadow || t8 === h2.ShadowHighlight || t8 === h2.ShadowExludeHighlight || t8 === h2.Highlight || t8 === h2.ObjectAndLayerIdColor) {
      return e15 === (this.parameters.transparent ? this.parameters.writeDepth ? E4.TRANSPARENT_MATERIAL : E4.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL : E4.OPAQUE_MATERIAL) || e15 === E4.DRAPED_MATERIAL || t8 === h2.ObjectAndLayerIdColor;
    }
    return false;
  }
  createGLMaterial(e15) {
    return new R2(e15);
  }
  createBufferWriter() {
    return new N(this._vertexBufferLayout, this._instanceBufferLayout);
  }
};
var R2 = class extends h3 {
  constructor(e15) {
    super({ ...e15, ...e15.material.parameters });
  }
  _updateParameters(e15) {
    const r10 = this._material.parameters;
    this.updateTexture(r10.textureId);
    const a4 = e15.camera.viewInverseTransposeMatrix;
    return o(r10.origin, a4[3], a4[7], a4[11]), this._material.setParameters(this.textureBindParameters), this.ensureTechnique(r10.treeRendering ? t7 : _2, e15);
  }
  _updateShadowState(e15) {
    e15.shadowMap.enabled !== this._material.parameters.shadowMappingEnabled && this._material.setParameters({ shadowMappingEnabled: e15.shadowMap.enabled });
  }
  _updateOccludeeState(e15) {
    e15.hasOccludees !== this._material.parameters.hasOccludees && this._material.setParameters({ hasOccludees: e15.hasOccludees });
  }
  beginSlot(e15) {
    return this._output !== h2.Color && this._output !== h2.Alpha || (this._updateShadowState(e15), this._updateOccludeeState(e15)), this._updateParameters(e15);
  }
};
var D2 = class extends k {
  constructor() {
    super(...arguments), this.initTextureTransparent = false, this.treeRendering = false, this.hasVertexTangents = false;
  }
};
var P2 = new D2();
var N = class {
  constructor(e15, t8) {
    this.vertexBufferLayout = e15, this.instanceBufferLayout = t8;
  }
  allocate(e15) {
    return this.vertexBufferLayout.createBuffer(e15);
  }
  elementCount(e15) {
    return e15.indices.get(O3.POSITION).length;
  }
  write(e15, t8, r10, a4, s6) {
    m2(r10, this.vertexBufferLayout, e15, t8, a4, s6);
  }
};
function j(e15) {
  const t8 = e15.textureId || e15.normalTextureId || e15.metallicRoughnessTextureId || e15.emissiveTextureId || e15.occlusionTextureId, r10 = T().vec3f(O3.POSITION).vec3f(O3.NORMAL);
  return e15.hasVertexTangents && r10.vec4f(O3.TANGENT), t8 && r10.vec2f(O3.UV0), e15.hasVertexColors && r10.vec4u8(O3.COLOR), e15.hasSymbolColors && r10.vec4u8(O3.SYMBOLCOLOR), has("enable-feature:objectAndLayerId-rendering") && r10.vec4u8(O3.OBJECTANDLAYERIDCOLOR), r10;
}
function B(t8) {
  let r10 = T();
  return r10 = t8.instancedDoublePrecision ? r10.vec3f(O3.MODELORIGINHI).vec3f(O3.MODELORIGINLO).mat3f(O3.MODEL).mat3f(O3.MODELNORMAL) : r10.mat4f(O3.MODEL).mat4f(O3.MODELNORMAL), r(t8.instanced) && t8.instanced.includes("color") && (r10 = r10.vec4f(O3.INSTANCECOLOR)), r(t8.instanced) && t8.instanced.includes("featureAttribute") && (r10 = r10.vec4f(O3.INSTANCEFEATUREATTRIBUTE)), r(t8.instanced) && t8.instanced.includes("objectAndLayerIdColor") && (r10 = r10.vec4u8(O3.OBJECTANDLAYERIDCOLOR_INSTANCED)), r10;
}
var V2 = n();
var H = n();
var G = r2(0, 0, 1);
var U2 = n();
var z2 = n();
var k2 = n();
var q2 = n();

// node_modules/@arcgis/core/views/3d/layers/graphics/wosrLoader.js
var w2 = s2.getLogger("esri.views.3d.layers.graphics.objectResourceUtils");
async function b2(e15, t8) {
  const n5 = await v(e15, t8), s6 = await E6(n5.textureDefinitions, t8);
  let a4 = 0;
  for (const r10 in s6)
    if (s6.hasOwnProperty(r10)) {
      const e16 = s6[r10];
      a4 += (e16 == null ? void 0 : e16.image) ? e16.image.width * e16.image.height * 4 : 0;
    }
  return { resource: n5, textures: s6, size: a4 + e9(n5) };
}
async function v(r10, n5) {
  const s6 = r(n5) && n5.streamDataRequester;
  if (s6)
    return j2(r10, s6, n5);
  const u2 = await b(U(r10, e(n5)));
  if (true === u2.ok)
    return u2.value.data;
  w(u2.error), A4(u2.error);
}
async function j2(e15, r10, n5) {
  const s6 = await b(r10.request(e15, "json", n5));
  if (true === s6.ok)
    return s6.value;
  w(s6.error), A4(s6.error.details.url);
}
function A4(e15) {
  throw new s3("", `Request for object resource failed: ${e15}`);
}
function M(e15) {
  const t8 = e15.params, r10 = t8.topology;
  let n5 = true;
  switch (t8.vertexAttributes || (w2.warn("Geometry must specify vertex attributes"), n5 = false), t8.topology) {
    case "PerAttributeArray":
      break;
    case "Indexed":
    case null:
    case void 0: {
      const e16 = t8.faces;
      if (e16) {
        if (t8.vertexAttributes)
          for (const r11 in t8.vertexAttributes) {
            const t9 = e16[r11];
            t9 && t9.values ? (null != t9.valueType && "UInt32" !== t9.valueType && (w2.warn(`Unsupported indexed geometry indices type '${t9.valueType}', only UInt32 is currently supported`), n5 = false), null != t9.valuesPerElement && 1 !== t9.valuesPerElement && (w2.warn(`Unsupported indexed geometry values per element '${t9.valuesPerElement}', only 1 is currently supported`), n5 = false)) : (w2.warn(`Indexed geometry does not specify face indices for '${r11}' attribute`), n5 = false);
          }
      } else
        w2.warn("Indexed geometries must specify faces"), n5 = false;
      break;
    }
    default:
      w2.warn(`Unsupported topology '${r10}'`), n5 = false;
  }
  e15.params.material || (w2.warn("Geometry requires material"), n5 = false);
  const s6 = e15.params.vertexAttributes;
  for (const a4 in s6) {
    s6[a4].values || (w2.warn("Geometries with externally defined attributes are not yet supported"), n5 = false);
  }
  return n5;
}
function P3(e15, t8) {
  const r10 = [], n5 = [], s6 = [], o10 = [], i9 = e15.resource, c8 = r8.parse(i9.version || "1.0", "wosr");
  k3.validate(c8);
  const m3 = i9.model.name, p = i9.model.geometries, d5 = i9.materialDefinitions, h5 = e15.textures;
  let w3 = 0;
  const b3 = /* @__PURE__ */ new Map();
  for (let u2 = 0; u2 < p.length; u2++) {
    const e16 = p[u2];
    if (!M(e16))
      continue;
    const i10 = T2(e16), c9 = e16.params.vertexAttributes, m4 = [];
    for (const t9 in c9) {
      const e17 = c9[t9], r11 = e17.values;
      m4.push([t9, { data: r11, size: e17.valuesPerElement, exclusive: true }]);
    }
    const v2 = [];
    if ("PerAttributeArray" !== e16.params.topology) {
      const t9 = e16.params.faces;
      for (const e17 in t9)
        v2.push([e17, t9[e17].values]);
    }
    const j3 = h5 && h5[i10.texture];
    if (j3 && !b3.has(i10.texture)) {
      const { image: e17, params: t9 } = j3, r11 = new L2(e17, t9);
      o10.push(r11), b3.set(i10.texture, r11);
    }
    const A5 = b3.get(i10.texture), P4 = A5 ? A5.id : void 0;
    let U4 = s6[i10.material] ? s6[i10.material][i10.texture] : null;
    if (!U4) {
      const e17 = d5[i10.material.substring(i10.material.lastIndexOf("/") + 1)].params;
      1 === e17.transparency && (e17.transparency = 0);
      const r11 = j3 && j3.alphaChannelUsage, n6 = e17.transparency > 0 || "transparency" === r11 || "maskAndTransparency" === r11, o11 = j3 ? I2(j3.alphaChannelUsage) : void 0, u3 = { ambient: e2(e17.diffuse), diffuse: e2(e17.diffuse), opacity: 1 - (e17.transparency || 0), transparent: n6, textureAlphaMode: o11, textureAlphaCutoff: 0.33, textureId: P4, initTextureTransparent: true, doubleSided: true, cullFace: n4.None, colorMixMode: e17.externalColorMixMode || "tint", textureAlphaPremultiplied: !!j3 && !!j3.params.preMultiplyAlpha };
      r(t8) && t8.materialParamsMixin && Object.assign(u3, t8.materialParamsMixin), U4 = new C2(u3), s6[i10.material] || (s6[i10.material] = {}), s6[i10.material][i10.texture] = U4;
    }
    n5.push(U4);
    const E7 = new d(m4, v2);
    w3 += v2.position ? v2.position.length : 0, r10.push(E7);
  }
  return { engineResources: [{ name: m3, stageResources: { textures: o10, materials: n5, geometries: r10 }, pivotOffset: i9.model.pivotOffset, numberOfVertices: w3, lodThreshold: null }], referenceBoundingBox: U3(r10) };
}
function U3(e15) {
  const t8 = A2();
  return e15.forEach((e16) => {
    const r10 = e16.boundingInfo;
    r(r10) && (c(t8, r10.getBBMin()), c(t8, r10.getBBMax()));
  }), t8;
}
async function E6(e15, t8) {
  const r10 = [];
  for (const o10 in e15) {
    const n6 = e15[o10], s7 = n6.images[0].data;
    if (!s7) {
      w2.warn("Externally referenced texture data is not yet supported");
      continue;
    }
    const i9 = n6.encoding + ";base64," + s7, u2 = "/textureDefinitions/" + o10, l3 = "rgba" === n6.channels ? n6.alphaChannelUsage || "transparency" : "none", c8 = { noUnpackFlip: true, wrap: { s: D.REPEAT, t: D.REPEAT }, preMultiplyAlpha: I2(l3) !== C.Opaque }, m3 = r(t8) && t8.disableTextures ? Promise.resolve(null) : t5(i9, t8);
    r10.push(m3.then((e16) => ({ refId: u2, image: e16, params: c8, alphaChannelUsage: l3 })));
  }
  const n5 = await Promise.all(r10), s6 = {};
  for (const a4 of n5)
    s6[a4.refId] = a4;
  return s6;
}
function I2(e15) {
  switch (e15) {
    case "mask":
      return C.Mask;
    case "maskAndTransparency":
      return C.MaskBlend;
    case "none":
      return C.Opaque;
    default:
      return C.Blend;
  }
}
function T2(e15) {
  const t8 = e15.params;
  return { id: 1, material: t8.material, texture: t8.texture, region: t8.texture };
}
var k3 = new r8(1, 2, "wosr");

// node_modules/@arcgis/core/views/3d/layers/graphics/objectResourceUtils.js
async function Y(s6, o10) {
  const i9 = Z(a(s6));
  if ("wosr" === i9.fileType) {
    const e15 = await (o10.cache ? o10.cache.loadWOSR(i9.url, o10) : b2(i9.url, o10)), { engineResources: t8, referenceBoundingBox: r10 } = P3(e15, o10);
    return { lods: t8, referenceBoundingBox: r10, isEsriSymbolResource: false, isWosr: true };
  }
  const n5 = await (o10.cache ? o10.cache.loadGLTF(i9.url, o10, o10.usePBR) : m(new n3(o10.streamDataRequester), i9.url, o10, o10.usePBR)), a4 = q(n5.model.meta, "ESRI_proxyEllipsoid"), u2 = n5.meta.isEsriSymbolResource && r(a4) && n5.meta.uri.includes("/RealisticTrees/");
  u2 && !n5.customMeta.esriTreeRendering && (n5.customMeta.esriTreeRendering = true, ie(n5, a4));
  const l3 = n5.meta.isEsriSymbolResource ? { usePBR: o10.usePBR, isSchematic: false, treeRendering: u2, mrrFactors: [0, 1, 0.2] } : { usePBR: o10.usePBR, isSchematic: false, treeRendering: false, mrrFactors: [0, 1, 0.5] }, c8 = { ...o10.materialParamsMixin, treeRendering: u2 }, { engineResources: m3, referenceBoundingBox: f5 } = ee(n5, l3, c8, o10.skipHighLods && null == i9.specifiedLodIndex ? { skipHighLods: true } : { skipHighLods: false, singleLodIndex: i9.specifiedLodIndex });
  return { lods: m3, referenceBoundingBox: f5, isEsriSymbolResource: n5.meta.isEsriSymbolResource, isWosr: false };
}
function Z(e15) {
  const t8 = e15.match(/(.*\.(gltf|glb))(\?lod=([0-9]+))?$/);
  if (t8)
    return { fileType: "gltf", url: t8[1], specifiedLodIndex: null != t8[4] ? Number(t8[4]) : null };
  return e15.match(/(.*\.(json|json\.gz))$/) ? { fileType: "wosr", url: e15, specifiedLodIndex: null } : { fileType: "unknown", url: e15, specifiedLodIndex: null };
}
function ee(e15, t8, o10, i9) {
  const n5 = e15.model, a4 = new Array(), u2 = /* @__PURE__ */ new Map(), l3 = /* @__PURE__ */ new Map(), c8 = n5.lods.length, m3 = A2();
  return n5.lods.forEach((e16, f5) => {
    const d5 = true === i9.skipHighLods && (c8 > 1 && 0 === f5 || c8 > 3 && 1 === f5) || false === i9.skipHighLods && null != i9.singleLodIndex && f5 !== i9.singleLodIndex;
    if (d5 && 0 !== f5)
      return;
    const p = new Array();
    let g3 = 0;
    if (e16.parts.forEach((e17) => {
      const { geometry: t9, vertexCount: s6 } = te(e17);
      p.push(t9), g3 += s6;
      const o11 = t9.boundingInfo;
      r(o11) && 0 === f5 && (c(m3, o11.getBBMin()), c(m3, o11.getBBMax()));
    }), d5)
      return;
    const h5 = new s5(e16.name, { textures: new Array(), materials: new Array(), geometries: p }, e16.lodThreshold, [0, 0, 0], g3);
    a4.push(h5), e16.parts.forEach((e17) => {
      const i10 = e17.material + (e17.attributes.normal ? "_normal" : "") + (e17.attributes.color ? "_color" : "") + (e17.attributes.texCoord0 ? "_texCoord0" : "") + (e17.attributes.tangent ? "_tangent" : ""), a5 = n5.materials.get(e17.material), c9 = r(e17.attributes.texCoord0), m4 = r(e17.attributes.normal);
      if (t(a5))
        return;
      const f6 = se(a5.alphaMode);
      if (!u2.has(i10)) {
        if (c9) {
          const e18 = (e19, t9 = false) => {
            if (r(e19) && !l3.has(e19)) {
              const s7 = n5.textures.get(e19);
              r(s7) && l3.set(e19, new L2(s7.data, t9 ? { ...s7.parameters, preMultiplyAlpha: t9 } : s7.parameters));
            }
          };
          e18(a5.textureColor, f6 !== C.Opaque), e18(a5.textureNormal), e18(a5.textureOcclusion), e18(a5.textureEmissive), e18(a5.textureMetallicRoughness);
        }
        const s6 = a5.color[0] ** (1 / o4), d6 = a5.color[1] ** (1 / o4), p2 = a5.color[2] ** (1 / o4), g4 = a5.emissiveFactor[0] ** (1 / o4), x3 = a5.emissiveFactor[1] ** (1 / o4), h6 = a5.emissiveFactor[2] ** (1 / o4), b3 = r(a5.textureColor) && c9 ? l3.get(a5.textureColor) : null;
        u2.set(i10, new C2({ ...t8, transparent: f6 === C.Blend, customDepthTest: e11.Lequal, textureAlphaMode: f6, textureAlphaCutoff: a5.alphaCutoff, diffuse: [s6, d6, p2], ambient: [s6, d6, p2], opacity: a5.opacity, doubleSided: a5.doubleSided, doubleSidedType: "winding-order", cullFace: a5.doubleSided ? n4.None : n4.Back, hasVertexColors: !!e17.attributes.color, hasVertexTangents: !!e17.attributes.tangent, normals: m4 ? "default" : "screenDerivative", castShadows: true, receiveSSAO: true, textureId: r(b3) ? b3.id : void 0, colorMixMode: a5.colorMixMode, normalTextureId: r(a5.textureNormal) && c9 ? l3.get(a5.textureNormal).id : void 0, textureAlphaPremultiplied: r(b3) && !!b3.params.preMultiplyAlpha, occlusionTextureId: r(a5.textureOcclusion) && c9 ? l3.get(a5.textureOcclusion).id : void 0, emissiveTextureId: r(a5.textureEmissive) && c9 ? l3.get(a5.textureEmissive).id : void 0, metallicRoughnessTextureId: r(a5.textureMetallicRoughness) && c9 ? l3.get(a5.textureMetallicRoughness).id : void 0, emissiveFactor: [g4, x3, h6], mrrFactors: [a5.metallicFactor, a5.roughnessFactor, t8.mrrFactors[2]], isSchematic: false, colorTextureTransformMatrix: c6(a5.colorTextureTransform), normalTextureTransformMatrix: c6(a5.normalTextureTransform), occlusionTextureTransformMatrix: c6(a5.occlusionTextureTransform), emissiveTextureTransformMatrix: c6(a5.emissiveTextureTransform), metallicRoughnessTextureTransformMatrix: c6(a5.metallicRoughnessTextureTransform), ...o10 }));
      }
      if (h5.stageResources.materials.push(u2.get(i10)), c9) {
        const e18 = (e19) => {
          r(e19) && h5.stageResources.textures.push(l3.get(e19));
        };
        e18(a5.textureColor), e18(a5.textureNormal), e18(a5.textureOcclusion), e18(a5.textureEmissive), e18(a5.textureMetallicRoughness);
      }
    });
  }), { engineResources: a4, referenceBoundingBox: m3 };
}
function te(e15) {
  const t8 = oe(e15.indices || e15.attributes.position.count, e15.primitiveType), s6 = e15.attributes.position.count, i9 = r7(i2, s6);
  t2(i9, e15.attributes.position, e15.transform);
  const n5 = [[O3.POSITION, { data: i9.typedBuffer, size: i9.elementCount, exclusive: true }]], a4 = [[O3.POSITION, t8]];
  if (r(e15.attributes.normal)) {
    const r10 = r7(i2, s6);
    g2(re, e15.transform), r5(r10, e15.attributes.normal, re), n5.push([O3.NORMAL, { data: r10.typedBuffer, size: r10.elementCount, exclusive: true }]), a4.push([O3.NORMAL, t8]);
  }
  if (r(e15.attributes.tangent)) {
    const r10 = r7(c2, s6);
    g2(re, e15.transform), r6(r10, e15.attributes.tangent, re), n5.push([O3.TANGENT, { data: r10.typedBuffer, size: r10.elementCount, exclusive: true }]), a4.push([O3.TANGENT, t8]);
  }
  if (r(e15.attributes.texCoord0)) {
    const r10 = r7(u, s6);
    n2(r10, e15.attributes.texCoord0), n5.push([O3.UV0, { data: r10.typedBuffer, size: r10.elementCount, exclusive: true }]), a4.push([O3.UV0, t8]);
  }
  if (r(e15.attributes.color)) {
    const r10 = r7(x, s6);
    if (4 === e15.attributes.color.elementCount)
      e15.attributes.color instanceof c2 ? o2(r10, e15.attributes.color, 255) : e15.attributes.color instanceof x ? e8(r10, e15.attributes.color) : e15.attributes.color instanceof L && o2(r10, e15.attributes.color, 1 / 256);
    else {
      t3(r10, 255, 255, 255, 255);
      const t9 = new O2(r10.buffer, 0, 4);
      e15.attributes.color instanceof i2 ? f(t9, e15.attributes.color, 255) : e15.attributes.color instanceof O2 ? e7(t9, e15.attributes.color) : e15.attributes.color instanceof E && f(t9, e15.attributes.color, 1 / 256);
    }
    n5.push([O3.COLOR, { data: r10.typedBuffer, size: r10.elementCount, exclusive: true }]), a4.push([O3.COLOR, t8]);
  }
  return { geometry: new d(n5, a4), vertexCount: s6 };
}
var re = e5();
function se(e15) {
  switch (e15) {
    case "BLEND":
      return C.Blend;
    case "MASK":
      return C.Mask;
    case "OPAQUE":
    case null:
    case void 0:
      return C.Opaque;
  }
}
function oe(e15, t8) {
  switch (t8) {
    case E2.TRIANGLES:
      return o3(e15);
    case E2.TRIANGLE_STRIP:
      return f2(e15);
    case E2.TRIANGLE_FAN:
      return i4(e15);
  }
}
function ie(e15, t8) {
  for (let r10 = 0; r10 < e15.model.lods.length; ++r10) {
    const o10 = e15.model.lods[r10];
    for (const i9 of o10.parts) {
      const o11 = i9.attributes.normal;
      if (t(o11))
        return;
      const g3 = i9.attributes.position, x3 = g3.count, b3 = n(), T3 = n(), v2 = n(), M2 = r7(x, x3), y2 = r7(i2, x3), j3 = h(e6(), i9.transform);
      for (let s6 = 0; s6 < x3; s6++) {
        g3.getVec(s6, T3), o11.getVec(s6, b3), O(T3, T3, i9.transform), e3(v2, T3, t8.center), i(v2, v2, t8.radius);
        const n5 = v2[2], a4 = s(v2), p = Math.min(0.45 + 0.55 * a4 * a4, 1);
        i(v2, v2, t8.radius), null !== j3 && O(v2, v2, j3), z(v2, v2), r10 + 1 !== e15.model.lods.length && e15.model.lods.length > 1 && A(v2, v2, b3, n5 > -1 ? 0.2 : Math.min(-4 * n5 - 3.8, 1)), y2.setVec(s6, v2), M2.set(s6, 0, 255 * p), M2.set(s6, 1, 255 * p), M2.set(s6, 2, 255 * p), M2.set(s6, 3, 255);
      }
      i9.attributes.normal = y2, i9.attributes.color = M2;
    }
  }
}

export {
  c6 as c,
  E5 as E,
  C2 as C,
  B,
  Y,
  Z,
  ee
};
//# sourceMappingURL=chunk-SSCI2ECM.js.map
