import {
  A as A2,
  G,
  j,
  p2 as p3
} from "./chunk-ZX55SO5Y.js";
import {
  R,
  T,
  V,
  _,
  d,
  f,
  k,
  k2,
  p as p2,
  r as r5,
  s
} from "./chunk-FCIHN4UG.js";
import {
  c
} from "./chunk-EGV5SNBD.js";
import {
  r as r4
} from "./chunk-NDQ5FHGV.js";
import {
  h,
  u as u2
} from "./chunk-RT3T2K4S.js";
import {
  A,
  g,
  o,
  p,
  r as r3,
  u
} from "./chunk-3LR5O4WA.js";
import {
  w
} from "./chunk-GDVNKPJ7.js";
import {
  n,
  r as r2
} from "./chunk-D4V6J5BT.js";
import {
  l
} from "./chunk-OOLCFNXJ.js";
import {
  e
} from "./chunk-U2XHEJM7.js";
import {
  r
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/geometry/support/clipRay.js
function s3(r6) {
  return r6 ? { ray: d(r6.ray), c0: r6.c0, c1: r6.c1 } : { ray: d(), c0: 0, c1: Number.MAX_VALUE };
}
function p4(r6, c3 = s3()) {
  return k(r6, c3.ray), c3.c0 = 0, c3.c1 = Number.MAX_VALUE, c3;
}
function v2(r6, c3) {
  return b(r6, r6.c0, c3);
}
function A3(r6, c3) {
  return b(r6, r6.c1, c3);
}
function b(r6, c3, n2) {
  return u(n2, r6.ray.origin, g(n2, r6.ray.direction, c3));
}
var k3 = new s(() => s3());

// node_modules/@arcgis/core/geometry/support/frustum.js
function H(T3) {
  return T3 ? [p3(T3[0]), p3(T3[1]), p3(T3[2]), p3(T3[3]), p3(T3[4]), p3(T3[5])] : [p3(), p3(), p3(), p3(), p3(), p3()];
}
function I() {
  return [n(), n(), n(), n(), n(), n(), n(), n()];
}
function u3(T3, _2) {
  for (let O2 = 0; O2 < v3.NUM; O2++)
    A2(T3[O2], _2[O2]);
}
function s4(T3, t, E2, F2 = y) {
  const r6 = u2(f.get(), t, T3);
  h(r6, r6);
  for (let _2 = 0; _2 < h2.NUM; ++_2) {
    const T4 = w(r5.get(), g2[_2], r6);
    o(F2[_2], T4[0] / T4[3], T4[1] / T4[3], T4[2] / T4[3]);
  }
  L(E2, F2);
}
function L(T3, _2) {
  j(_2[l2.FAR_BOTTOM_LEFT], _2[l2.NEAR_BOTTOM_LEFT], _2[l2.NEAR_TOP_LEFT], T3[U.LEFT]), j(_2[l2.NEAR_BOTTOM_RIGHT], _2[l2.FAR_BOTTOM_RIGHT], _2[l2.FAR_TOP_RIGHT], T3[U.RIGHT]), j(_2[l2.FAR_BOTTOM_LEFT], _2[l2.FAR_BOTTOM_RIGHT], _2[l2.NEAR_BOTTOM_RIGHT], T3[U.BOTTOM]), j(_2[l2.NEAR_TOP_LEFT], _2[l2.NEAR_TOP_RIGHT], _2[l2.FAR_TOP_RIGHT], T3[U.TOP]), j(_2[l2.NEAR_BOTTOM_LEFT], _2[l2.NEAR_BOTTOM_RIGHT], _2[l2.NEAR_TOP_RIGHT], T3[U.NEAR]), j(_2[l2.FAR_BOTTOM_RIGHT], _2[l2.FAR_BOTTOM_LEFT], _2[l2.FAR_TOP_LEFT], T3[U.FAR]);
}
function i(T3, _2) {
  for (let O2 = 0; O2 < v3.NUM; O2++) {
    const R4 = T3[O2];
    if (R4[0] * _2[0] + R4[1] * _2[1] + R4[2] * _2[2] + R4[3] >= _2[3])
      return false;
  }
  return true;
}
function a(T3, _2) {
  for (let O2 = 0; O2 < v3.NUM; O2++) {
    const R4 = T3[O2];
    if (!G(R4, _2))
      return false;
  }
  return true;
}
var U;
var l2;
!function(T3) {
  T3[T3.LEFT = 0] = "LEFT", T3[T3.RIGHT = 1] = "RIGHT", T3[T3.BOTTOM = 2] = "BOTTOM", T3[T3.TOP = 3] = "TOP", T3[T3.NEAR = 4] = "NEAR", T3[T3.FAR = 5] = "FAR";
}(U || (U = {})), function(T3) {
  T3[T3.NEAR_BOTTOM_LEFT = 0] = "NEAR_BOTTOM_LEFT", T3[T3.NEAR_BOTTOM_RIGHT = 1] = "NEAR_BOTTOM_RIGHT", T3[T3.NEAR_TOP_RIGHT = 2] = "NEAR_TOP_RIGHT", T3[T3.NEAR_TOP_LEFT = 3] = "NEAR_TOP_LEFT", T3[T3.FAR_BOTTOM_LEFT = 4] = "FAR_BOTTOM_LEFT", T3[T3.FAR_BOTTOM_RIGHT = 5] = "FAR_BOTTOM_RIGHT", T3[T3.FAR_TOP_RIGHT = 6] = "FAR_TOP_RIGHT", T3[T3.FAR_TOP_LEFT = 7] = "FAR_TOP_LEFT";
}(l2 || (l2 = {}));
var k4 = { bottom: [l2.FAR_BOTTOM_RIGHT, l2.NEAR_BOTTOM_RIGHT, l2.NEAR_BOTTOM_LEFT, l2.FAR_BOTTOM_LEFT], near: [l2.NEAR_BOTTOM_LEFT, l2.NEAR_BOTTOM_RIGHT, l2.NEAR_TOP_RIGHT, l2.NEAR_TOP_LEFT], far: [l2.FAR_BOTTOM_RIGHT, l2.FAR_BOTTOM_LEFT, l2.FAR_TOP_LEFT, l2.FAR_TOP_RIGHT], right: [l2.NEAR_BOTTOM_RIGHT, l2.FAR_BOTTOM_RIGHT, l2.FAR_TOP_RIGHT, l2.NEAR_TOP_RIGHT], left: [l2.FAR_BOTTOM_LEFT, l2.NEAR_BOTTOM_LEFT, l2.NEAR_TOP_LEFT, l2.FAR_TOP_LEFT], top: [l2.FAR_TOP_LEFT, l2.NEAR_TOP_LEFT, l2.NEAR_TOP_RIGHT, l2.FAR_TOP_RIGHT] };
var v3;
var h2;
!function(T3) {
  T3[T3.NUM = 6] = "NUM";
}(v3 || (v3 = {})), function(T3) {
  T3[T3.NUM = 8] = "NUM";
}(h2 || (h2 = {}));
var g2 = [r4(-1, -1, -1, 1), r4(1, -1, -1, 1), r4(1, 1, -1, 1), r4(-1, 1, -1, 1), r4(-1, -1, 1, 1), r4(1, -1, 1, 1), r4(1, 1, 1, 1), r4(-1, 1, 1, 1)];
var b2 = new s(s3);
var y = I();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Octree.js
var g3 = class {
  constructor(e2, t) {
    this._objectToBoundingSphere = e2, this._maximumObjectsPerNode = 10, this._maximumDepth = 20, this._degenerateObjects = /* @__PURE__ */ new Set(), this._root = new O(), this._objectCount = 0, t && (void 0 !== t.maximumObjectsPerNode && (this._maximumObjectsPerNode = t.maximumObjectsPerNode), void 0 !== t.maximumDepth && (this._maximumDepth = t.maximumDepth));
  }
  get bounds() {
    return this._root.bounds;
  }
  get halfSize() {
    return this._root.halfSize;
  }
  get root() {
    return this._root.node;
  }
  get maximumObjectsPerNode() {
    return this._maximumObjectsPerNode;
  }
  get maximumDepth() {
    return this._maximumDepth;
  }
  get objectCount() {
    return this._objectCount;
  }
  destroy() {
    this._degenerateObjects.clear(), O.clearPool(), B[0] = null, w2.prune(), W.prune();
  }
  add(e2, t = e2.length) {
    this._objectCount += t, this._grow(e2, t);
    const n2 = O.acquire();
    for (let o2 = 0; o2 < t; o2++) {
      const t2 = e2[o2];
      this._isDegenerate(t2) ? this._degenerateObjects.add(t2) : (n2.init(this._root), this._add(t2, n2));
    }
    O.release(n2);
  }
  remove(t, n2 = null) {
    this._objectCount -= t.length;
    const o2 = O.acquire();
    for (const r6 of t) {
      const t2 = r(n2) ? n2 : _(this._objectToBoundingSphere(r6), C);
      z2(t2[3]) ? (o2.init(this._root), this._remove(r6, t2, o2)) : this._degenerateObjects.delete(r6);
    }
    O.release(o2), this._shrink();
  }
  update(e2, t) {
    if (!z2(t[3]) && this._isDegenerate(e2))
      return;
    const n2 = R3(e2);
    this.remove(n2, t), this.add(n2);
  }
  forEachAlongRay(e2, t, n2) {
    const o2 = p2(e2, t);
    this._forEachNode(this._root, (e3) => {
      if (!this._intersectsNode(o2, e3))
        return false;
      const t2 = e3.node;
      return t2.terminals.forAll((e4) => {
        this._intersectsObject(o2, e4) && n2(e4);
      }), null !== t2.residents && t2.residents.forAll((e4) => {
        this._intersectsObject(o2, e4) && n2(e4);
      }), true;
    });
  }
  forEachAlongRayWithVerticalOffset(e2, t, n2, o2) {
    const r6 = p2(e2, t);
    this._forEachNode(this._root, (e3) => {
      if (!this._intersectsNodeWithOffset(r6, e3, o2))
        return false;
      const t2 = e3.node;
      return t2.terminals.forAll((e4) => {
        this._intersectsObjectWithOffset(r6, e4, o2) && n2(e4);
      }), null !== t2.residents && t2.residents.forAll((e4) => {
        this._intersectsObjectWithOffset(r6, e4, o2) && n2(e4);
      }), true;
    });
  }
  forEach(e2) {
    this._forEachNode(this._root, (t) => {
      const n2 = t.node;
      return n2.terminals.forAll(e2), null !== n2.residents && n2.residents.forAll(e2), true;
    }), this._degenerateObjects.forEach(e2);
  }
  forEachDegenerateObject(e2) {
    this._degenerateObjects.forEach(e2);
  }
  findClosest(e2, t, n2, s5 = () => true, i2 = 1 / 0) {
    let h3 = 1 / 0, a2 = 1 / 0, d2 = null;
    const c3 = E(e2, t), u4 = (o2) => {
      if (--i2, !s5(o2))
        return;
      const r6 = this._objectToBoundingSphere(o2);
      if (!i(n2, r6))
        return;
      const c4 = M(e2, t, k2(r6)), u5 = c4 - r6[3], f2 = c4 + r6[3];
      u5 < h3 && (h3 = u5, a2 = f2, d2 = o2);
    };
    return this._forEachNodeDepthOrdered(this._root, (s6) => {
      if (i2 <= 0 || !i(n2, s6.bounds))
        return false;
      g(F, c3, s6.halfSize), u(F, F, s6.bounds);
      if (M(e2, t, F) > a2)
        return false;
      const h4 = s6.node;
      return h4.terminals.forAll((e3) => u4(e3)), null !== h4.residents && h4.residents.forAll((e3) => u4(e3)), true;
    }, e2, t), d2;
  }
  forEachInDepthRange(e2, t, n2, s5, i2, h3, a2) {
    let d2 = -1 / 0, c3 = 1 / 0;
    const u4 = { setRange: (e3) => {
      n2 === g3.DepthOrder.FRONT_TO_BACK ? (d2 = Math.max(d2, e3.near), c3 = Math.min(c3, e3.far)) : (d2 = Math.max(d2, -e3.far), c3 = Math.min(c3, -e3.near));
    } };
    u4.setRange(s5);
    const f2 = M(t, n2, e2), m = E(t, n2), p5 = E(t, -n2), b3 = (e3) => {
      if (!a2(e3))
        return;
      const o2 = this._objectToBoundingSphere(e3), r6 = k2(o2), s6 = M(t, n2, r6) - f2, m2 = s6 - o2[3], p6 = s6 + o2[3];
      m2 > c3 || p6 < d2 || !i(h3, o2) || i2(e3, u4);
    };
    this._forEachNodeDepthOrdered(this._root, (e3) => {
      if (!i(h3, e3.bounds))
        return false;
      g(F, m, e3.halfSize), u(F, F, e3.bounds);
      if (M(t, n2, F) - f2 > c3)
        return false;
      g(F, p5, e3.halfSize), u(F, F, e3.bounds);
      if (M(t, n2, F) - f2 < d2)
        return false;
      const s6 = e3.node;
      return s6.terminals.forAll((e4) => b3(e4)), null !== s6.residents && s6.residents.forAll((e4) => b3(e4)), true;
    }, t, n2);
  }
  forEachNode(e2) {
    this._forEachNode(this._root, (t) => e2(t.node, t.bounds, t.halfSize));
  }
  forEachNeighbor(e2, t) {
    const n2 = T(t), o2 = k2(t), r6 = (t2) => {
      const r7 = this._objectToBoundingSphere(t2), i3 = T(r7), h4 = n2 + i3;
      return !(p(k2(r7), o2) - h4 * h4 <= 0) || e2(t2);
    };
    let i2 = true;
    const h3 = (e3) => {
      i2 && (i2 = r6(e3));
    };
    this._forEachNode(this._root, (e3) => {
      const t2 = T(e3.bounds), r7 = n2 + t2;
      if (p(k2(e3.bounds), o2) - r7 * r7 > 0)
        return false;
      const a2 = e3.node;
      return a2.terminals.forAll(h3), i2 && null !== a2.residents && a2.residents.forAll(h3), i2;
    }), i2 && this.forEachDegenerateObject(h3);
  }
  _intersectsNode(e2, t) {
    return x(t.bounds, 2 * -t.halfSize, k5), x(t.bounds, 2 * t.halfSize, q), c(e2.origin, e2.direction, k5, q);
  }
  _intersectsNodeWithOffset(e2, t, n2) {
    return x(t.bounds, 2 * -t.halfSize, k5), x(t.bounds, 2 * t.halfSize, q), n2.applyToMinMax(k5, q), c(e2.origin, e2.direction, k5, q);
  }
  _intersectsObject(e2, t) {
    const n2 = this._objectToBoundingSphere(t);
    return !(n2[3] > 0) || V(n2, e2);
  }
  _intersectsObjectWithOffset(e2, t, n2) {
    const o2 = this._objectToBoundingSphere(t);
    return !(o2[3] > 0) || V(n2.applyToBoundingSphere(o2), e2);
  }
  _forEachNode(e2, t) {
    let n2 = O.acquire().init(e2);
    const o2 = [n2];
    for (; 0 !== o2.length; ) {
      if (n2 = o2.pop(), t(n2) && !n2.isLeaf())
        for (let e3 = 0; e3 < n2.node.children.length; e3++) {
          n2.node.children[e3] && o2.push(O.acquire().init(n2).advance(e3));
        }
      O.release(n2);
    }
  }
  _forEachNodeDepthOrdered(e2, t, n2, o2 = g3.DepthOrder.FRONT_TO_BACK) {
    let r6 = O.acquire().init(e2);
    const s5 = [r6];
    for (T2(n2, o2, V2); 0 !== s5.length; ) {
      if (r6 = s5.pop(), t(r6) && !r6.isLeaf())
        for (let e3 = 7; e3 >= 0; --e3) {
          const t2 = V2[e3];
          r6.node.children[t2] && s5.push(O.acquire().init(r6).advance(t2));
        }
      O.release(r6);
    }
  }
  _remove(e2, t, n2) {
    w2.clear();
    const o2 = n2.advanceTo(t, (e3, t2) => {
      w2.push(e3.node), w2.push(t2);
    }) ? n2.node.terminals : n2.node.residents;
    if (o2.removeUnordered(e2), 0 === o2.length)
      for (let r6 = w2.length - 2; r6 >= 0; r6 -= 2) {
        const e3 = w2.data[r6], t2 = w2.data[r6 + 1];
        if (!this._purge(e3, t2))
          break;
      }
  }
  _nodeIsEmpty(e2) {
    if (0 !== e2.terminals.length)
      return false;
    if (null !== e2.residents)
      return 0 === e2.residents.length;
    for (let t = 0; t < e2.children.length; t++)
      if (e2.children[t])
        return false;
    return true;
  }
  _purge(e2, t) {
    return t >= 0 && (e2.children[t] = null), !!this._nodeIsEmpty(e2) && (null === e2.residents && (e2.residents = new l({ shrink: true })), true);
  }
  _add(e2, t) {
    t.advanceTo(this._objectToBoundingSphere(e2)) ? t.node.terminals.push(e2) : (t.node.residents.push(e2), t.node.residents.length > this._maximumObjectsPerNode && t.depth < this._maximumDepth && this._split(t));
  }
  _split(e2) {
    const t = e2.node.residents;
    e2.node.residents = null;
    for (let n2 = 0; n2 < t.length; n2++) {
      const o2 = O.acquire().init(e2);
      this._add(t.getItemAt(n2), o2), O.release(o2);
    }
  }
  _grow(e2, t) {
    if (0 !== t && (N(e2, t, (e3) => this._objectToBoundingSphere(e3), I2), z2(I2[3]) && !this._fitsInsideTree(I2)))
      if (this._nodeIsEmpty(this._root.node))
        _(I2, this._root.bounds), this._root.halfSize = 1.25 * I2[3];
      else {
        const e3 = this._rootBoundsForRootAsSubNode(I2);
        this._placingRootViolatesMaxDepth(e3) ? this._rebuildTree(I2, e3) : this._growRootAsSubNode(e3), O.release(e3);
      }
  }
  _rebuildTree(e2, t) {
    r3(P, t.bounds), P[3] = t.halfSize, N([e2, P], 2, (e3) => e3, L2);
    const n2 = O.acquire().init(this._root);
    this._root.initFrom(null, L2, 1.25 * L2[3]), this._forEachNode(n2, (e3) => (this.add(e3.node.terminals.data, e3.node.terminals.length), null !== e3.node.residents && this.add(e3.node.residents.data, e3.node.residents.length), true)), O.release(n2);
  }
  _placingRootViolatesMaxDepth(e2) {
    const t = Math.log(e2.halfSize / this._root.halfSize) * Math.LOG2E;
    let n2 = 0;
    return this._forEachNode(this._root, (e3) => (n2 = Math.max(n2, e3.depth), n2 + t <= this._maximumDepth)), n2 + t > this._maximumDepth;
  }
  _rootBoundsForRootAsSubNode(e2) {
    const t = e2[3], n2 = e2;
    let o2 = -1 / 0;
    const r6 = this._root.bounds, s5 = this._root.halfSize;
    for (let i2 = 0; i2 < 3; i2++) {
      const e3 = r6[i2] - s5 - (n2[i2] - t), h3 = n2[i2] + t - (r6[i2] + s5), a2 = Math.max(0, Math.ceil(e3 / (2 * s5))), d2 = Math.max(0, Math.ceil(h3 / (2 * s5))) + 1, l3 = 2 ** Math.ceil(Math.log(a2 + d2) * Math.LOG2E);
      o2 = Math.max(o2, l3), K[i2].min = a2, K[i2].max = d2;
    }
    for (let i2 = 0; i2 < 3; i2++) {
      let e3 = K[i2].min, t2 = K[i2].max;
      const n3 = (o2 - (e3 + t2)) / 2;
      e3 += Math.ceil(n3), t2 += Math.floor(n3);
      const h3 = r6[i2] - s5 - e3 * s5 * 2;
      y2[i2] = h3 + (t2 + e3) * s5;
    }
    return y2[3] = o2 * s5 * v4, O.acquire().initFrom(null, y2, o2 * s5, 0);
  }
  _growRootAsSubNode(e2) {
    const t = this._root.node;
    r3(I2, this._root.bounds), I2[3] = this._root.halfSize, this._root.init(e2), e2.advanceTo(I2, null, true), e2.node.children = t.children, e2.node.residents = t.residents, e2.node.terminals = t.terminals;
  }
  _shrink() {
    for (; ; ) {
      const e2 = this._findShrinkIndex();
      if (-1 === e2)
        break;
      this._root.advance(e2), this._root.depth = 0;
    }
  }
  _findShrinkIndex() {
    if (0 !== this._root.node.terminals.length || this._root.isLeaf())
      return -1;
    let e2 = null;
    const t = this._root.node.children;
    let n2 = 0, o2 = 0;
    for (; o2 < t.length && null == e2; )
      n2 = o2++, e2 = t[n2];
    for (; o2 < t.length; )
      if (t[o2++])
        return -1;
    return n2;
  }
  _isDegenerate(e2) {
    return !z2(this._objectToBoundingSphere(e2)[3]);
  }
  _fitsInsideTree(e2) {
    const t = this._root.bounds, n2 = this._root.halfSize;
    return e2[3] <= n2 && e2[0] >= t[0] - n2 && e2[0] <= t[0] + n2 && e2[1] >= t[1] - n2 && e2[1] <= t[1] + n2 && e2[2] >= t[2] - n2 && e2[2] <= t[2] + n2;
  }
};
var O = class {
  constructor() {
    this.bounds = R(), this.halfSize = 0, this.initFrom(null, null, 0, 0);
  }
  init(e2) {
    return this.initFrom(e2.node, e2.bounds, e2.halfSize, e2.depth);
  }
  initFrom(t, n2, o2, r6 = this.depth) {
    return this.node = r(t) ? t : O.createEmptyNode(), r(n2) && _(n2, this.bounds), this.halfSize = o2, this.depth = r6, this;
  }
  advance(e2) {
    let t = this.node.children[e2];
    t || (t = O.createEmptyNode(), this.node.children[e2] = t), this.node = t, this.halfSize /= 2, this.depth++;
    const n2 = A4[e2];
    return this.bounds[0] += n2[0] * this.halfSize, this.bounds[1] += n2[1] * this.halfSize, this.bounds[2] += n2[2] * this.halfSize, this.bounds[3] = this.halfSize * v4, this;
  }
  advanceTo(e2, t, n2 = false) {
    for (; ; ) {
      if (this.isTerminalFor(e2))
        return t && t(this, -1), true;
      if (this.isLeaf()) {
        if (!n2)
          return t && t(this, -1), false;
        this.node.residents = null;
      }
      const o2 = this._childIndex(e2);
      t && t(this, o2), this.advance(o2);
    }
  }
  isLeaf() {
    return null != this.node.residents;
  }
  isTerminalFor(e2) {
    return e2[3] > this.halfSize / 2;
  }
  _childIndex(e2) {
    const t = this.bounds;
    return (t[0] < e2[0] ? 1 : 0) + (t[1] < e2[1] ? 2 : 0) + (t[2] < e2[2] ? 4 : 0);
  }
  static createEmptyNode() {
    return { children: [null, null, null, null, null, null, null, null], terminals: new l({ shrink: true }), residents: new l({ shrink: true }) };
  }
  static acquire() {
    return O._pool.acquire();
  }
  static release(e2) {
    O._pool.release(e2);
  }
  static clearPool() {
    O._pool.prune();
  }
};
function j3(e2, t) {
  e2[0] = Math.min(e2[0], t[0] - t[3]), e2[1] = Math.min(e2[1], t[1] - t[3]), e2[2] = Math.min(e2[2], t[2] - t[3]);
}
function S(e2, t) {
  e2[0] = Math.max(e2[0], t[0] + t[3]), e2[1] = Math.max(e2[1], t[1] + t[3]), e2[2] = Math.max(e2[2], t[2] + t[3]);
}
function x(e2, t, n2) {
  n2[0] = e2[0] + t, n2[1] = e2[1] + t, n2[2] = e2[2] + t;
}
function N(e2, t, n2, o2) {
  if (1 === t) {
    const t2 = n2(e2[0]);
    _(t2, o2);
  } else {
    k5[0] = 1 / 0, k5[1] = 1 / 0, k5[2] = 1 / 0, q[0] = -1 / 0, q[1] = -1 / 0, q[2] = -1 / 0;
    for (let o3 = 0; o3 < t; o3++) {
      const t2 = n2(e2[o3]);
      z2(t2[3]) && (j3(k5, t2), S(q, t2));
    }
    A(o2, k5, q, 0.5), o2[3] = Math.max(q[0] - k5[0], q[1] - k5[1], q[2] - k5[2]) / 2;
  }
}
function T2(e2, t, n2) {
  if (!W.length)
    for (let o2 = 0; o2 < 8; ++o2)
      W.push({ index: 0, distance: 0 });
  for (let o2 = 0; o2 < 8; ++o2) {
    const n3 = A4[o2];
    W.data[o2].index = o2, W.data[o2].distance = M(e2, t, n3);
  }
  W.sort((e3, t2) => e3.distance - t2.distance);
  for (let o2 = 0; o2 < 8; ++o2)
    n2[o2] = W.data[o2].index;
}
function E(e2, t) {
  let n2, o2 = 1 / 0;
  for (let r6 = 0; r6 < 8; ++r6) {
    const s5 = M(e2, t, D2[r6]);
    s5 < o2 && (o2 = s5, n2 = D2[r6]);
  }
  return n2;
}
function M(e2, t, n2) {
  return t * (e2[0] * n2[0] + e2[1] * n2[1] + e2[2] * n2[2]);
}
function z2(e2) {
  return !isNaN(e2) && e2 !== -1 / 0 && e2 !== 1 / 0 && e2 > 0;
}
O._pool = new e(O), function(e2) {
  var t;
  (t = e2.DepthOrder || (e2.DepthOrder = {}))[t.FRONT_TO_BACK = 1] = "FRONT_TO_BACK", t[t.BACK_TO_FRONT = -1] = "BACK_TO_FRONT";
}(g3 || (g3 = {}));
var A4 = [r2(-1, -1, -1), r2(1, -1, -1), r2(-1, 1, -1), r2(1, 1, -1), r2(-1, -1, 1), r2(1, -1, 1), r2(-1, 1, 1), r2(1, 1, 1)];
var D2 = [r2(-1, -1, -1), r2(-1, -1, 1), r2(-1, 1, -1), r2(-1, 1, 1), r2(1, -1, -1), r2(1, -1, 1), r2(1, 1, -1), r2(1, 1, 1)];
var v4 = Math.sqrt(3);
var B = [null];
function R3(e2) {
  return B[0] = e2, B;
}
var y2 = R();
var F = n();
var k5 = n();
var q = n();
var w2 = new l();
var C = R();
var I2 = R();
var P = R();
var L2 = R();
var K = [{ min: 0, max: 0 }, { min: 0, max: 0 }, { min: 0, max: 0 }];
var W = new l();
var V2 = [0, 0, 0, 0, 0, 0, 0, 0];
var G2 = g3;

export {
  s3 as s,
  p4 as p,
  v2 as v,
  A3 as A,
  H,
  u3 as u,
  s4 as s2,
  a,
  U,
  G2 as G
};
//# sourceMappingURL=chunk-FXVIA5BW.js.map
