import {
  y as y3
} from "./chunk-NCONZRBI.js";
import {
  _,
  f,
  g,
  u,
  w,
  x
} from "./chunk-76CXRT5P.js";
import {
  c
} from "./chunk-HSDU7DIL.js";
import {
  F,
  P
} from "./chunk-OD3FDQCI.js";
import {
  o as o2
} from "./chunk-NRP45AHD.js";
import {
  r
} from "./chunk-HLM6QCL2.js";
import {
  o
} from "./chunk-RXYULINL.js";
import {
  s as s3
} from "./chunk-M5VHU5LK.js";
import {
  l
} from "./chunk-7QMMKGW4.js";
import {
  e,
  n2 as n,
  y as y2
} from "./chunk-OOLCFNXJ.js";
import {
  s as s2
} from "./chunk-LIZHLHNA.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";
import {
  y
} from "./chunk-HVKDYDPP.js";

// node_modules/@arcgis/core/layers/support/LabelExpressionInfo.js
var l2;
var n2 = l2 = class extends l {
  constructor() {
    super(...arguments), this.expression = null, this.title = null, this.value = null;
  }
  readExpression(r2, e2) {
    return e2.value ? w(e2.value) : r2;
  }
  writeExpression(r2, e2, s5) {
    null != this.value && (r2 = w(this.value)), null != r2 && (e2[s5] = r2);
  }
  clone() {
    return new l2({ expression: this.expression, title: this.title, value: this.value });
  }
};
e([y2({ type: String, json: { write: { writerEnsuresNonNull: true } } })], n2.prototype, "expression", void 0), e([o("expression", ["expression", "value"])], n2.prototype, "readExpression", null), e([r("expression")], n2.prototype, "writeExpression", null), e([y2({ type: String, json: { write: true, origins: { "web-scene": { write: false } } } })], n2.prototype, "title", void 0), e([y2({ json: { read: false, write: false } })], n2.prototype, "value", void 0), n2 = l2 = e([n("esri.layers.support.LabelExpressionInfo")], n2);
var a = n2;

// node_modules/@arcgis/core/layers/support/LabelClass.js
var y4;
var d = new s3({ esriServerPointLabelPlacementAboveCenter: "above-center", esriServerPointLabelPlacementAboveLeft: "above-left", esriServerPointLabelPlacementAboveRight: "above-right", esriServerPointLabelPlacementBelowCenter: "below-center", esriServerPointLabelPlacementBelowLeft: "below-left", esriServerPointLabelPlacementBelowRight: "below-right", esriServerPointLabelPlacementCenterCenter: "center-center", esriServerPointLabelPlacementCenterLeft: "center-left", esriServerPointLabelPlacementCenterRight: "center-right", esriServerLinePlacementAboveAfter: "above-after", esriServerLinePlacementAboveAlong: "above-along", esriServerLinePlacementAboveBefore: "above-before", esriServerLinePlacementAboveStart: "above-start", esriServerLinePlacementAboveEnd: "above-end", esriServerLinePlacementBelowAfter: "below-after", esriServerLinePlacementBelowAlong: "below-along", esriServerLinePlacementBelowBefore: "below-before", esriServerLinePlacementBelowStart: "below-start", esriServerLinePlacementBelowEnd: "below-end", esriServerLinePlacementCenterAfter: "center-after", esriServerLinePlacementCenterAlong: "center-along", esriServerLinePlacementCenterBefore: "center-before", esriServerLinePlacementCenterStart: "center-start", esriServerLinePlacementCenterEnd: "center-end", esriServerPolygonPlacementAlwaysHorizontal: "always-horizontal" }, { ignoreUnknown: true });
function x2(e2) {
  var _a;
  return !e2 || "service" !== e2.origin && !("map-image" === ((_a = e2.layer) == null ? void 0 : _a.type));
}
function L(e2) {
  return "map-image" === (e2 == null ? void 0 : e2.type);
}
function P2(e2) {
  var _a, _b;
  return !!L(e2) && !!((_b = (_a = e2.capabilities) == null ? void 0 : _a.exportMap) == null ? void 0 : _b.supportsArcadeExpressionForLabeling);
}
function g2(e2) {
  return x2(e2) || P2(e2.layer);
}
var E = y4 = class extends l {
  constructor(e2) {
    super(e2), this.type = "label", this.name = null, this.allowOverrun = false, this.deconflictionStrategy = "static", this.labelExpression = null, this.labelExpressionInfo = null, this.labelPlacement = null, this.labelPosition = "curved", this.maxScale = 0, this.minScale = 0, this.repeatLabel = true, this.repeatLabelDistance = null, this.symbol = y3, this.useCodedValues = void 0, this.where = null;
  }
  static evaluateWhere(e2, r2) {
    const t = (e3, r3, t2) => {
      switch (r3) {
        case "=":
          return e3 == t2;
        case "<>":
          return e3 != t2;
        case ">":
          return e3 > t2;
        case ">=":
          return e3 >= t2;
        case "<":
          return e3 < t2;
        case "<=":
          return e3 <= t2;
      }
      return false;
    };
    try {
      if (null == e2)
        return true;
      const o3 = e2.split(" ");
      if (3 === o3.length)
        return t(r2[o3[0]], o3[1], o3[2]);
      if (7 === o3.length) {
        const e3 = t(r2[o3[0]], o3[1], o3[2]), n4 = o3[3], s5 = t(r2[o3[4]], o3[5], o3[6]);
        switch (n4) {
          case "AND":
            return e3 && s5;
          case "OR":
            return e3 || s5;
        }
      }
      return false;
    } catch (o3) {
      console.log("Error.: can't parse = " + e2);
    }
  }
  readLabelExpression(e2, r2) {
    const t = r2.labelExpressionInfo;
    if (!t || !t.value && !t.expression)
      return e2;
  }
  writeLabelExpression(e2, r2, t) {
    if (this.labelExpressionInfo) {
      if (null != this.labelExpressionInfo.value)
        e2 = u(this.labelExpressionInfo.value);
      else if (null != this.labelExpressionInfo.expression) {
        const r3 = _(this.labelExpressionInfo.expression);
        r3 && (e2 = "[" + r3 + "]");
      }
    }
    null != e2 && (r2[t] = e2);
  }
  writeLabelExpressionInfo(e2, r2, t, o3) {
    if (null == e2 && null != this.labelExpression && x2(o3))
      e2 = new a({ expression: this.getLabelExpressionArcade() });
    else if (!e2)
      return;
    const n4 = e2.toJSON(o3);
    n4.expression && (r2[t] = n4);
  }
  writeMaxScale(e2, r2) {
    (e2 || this.minScale) && (r2.maxScale = e2);
  }
  writeMinScale(e2, r2) {
    (e2 || this.maxScale) && (r2.minScale = e2);
  }
  getLabelExpression() {
    return x(this);
  }
  getLabelExpressionArcade() {
    return f(this);
  }
  getLabelExpressionSingleField() {
    return g(this);
  }
  hash() {
    return JSON.stringify(this);
  }
  clone() {
    return new y4({ allowOverrun: this.allowOverrun, deconflictionStrategy: this.deconflictionStrategy, labelExpression: this.labelExpression, labelExpressionInfo: y(this.labelExpressionInfo), labelPosition: this.labelPosition, labelPlacement: this.labelPlacement, maxScale: this.maxScale, minScale: this.minScale, name: this.name, repeatLabel: this.repeatLabel, repeatLabelDistance: this.repeatLabelDistance, symbol: y(this.symbol), where: this.where, useCodedValues: this.useCodedValues });
  }
};
e([y2({ type: String, json: { write: true } })], E.prototype, "name", void 0), e([y2({ type: Boolean, json: { write: true, default: false, origins: { "web-scene": { write: false } } } })], E.prototype, "allowOverrun", void 0), e([y2({ type: String, json: { write: true, default: "static", origins: { "web-scene": { write: false } } } })], E.prototype, "deconflictionStrategy", void 0), e([y2({ type: String, json: { write: { overridePolicy(e2, r2, t) {
  return this.labelExpressionInfo && "service" === (t == null ? void 0 : t.origin) && P2(t.layer) ? { enabled: false } : { allowNull: true };
} } } })], E.prototype, "labelExpression", void 0), e([o("labelExpression")], E.prototype, "readLabelExpression", null), e([r("labelExpression")], E.prototype, "writeLabelExpression", null), e([y2({ type: a, json: { write: { overridePolicy: (e2, r2, t) => g2(t) ? { allowNull: true } : { enabled: false } } } })], E.prototype, "labelExpressionInfo", void 0), e([r("labelExpressionInfo")], E.prototype, "writeLabelExpressionInfo", null), e([y2({ type: d.apiValues, json: { type: d.jsonValues, read: d.read, write: d.write } })], E.prototype, "labelPlacement", void 0), e([y2({ type: ["curved", "parallel"], json: { write: true, origins: { "web-map": { write: false }, "web-scene": { write: false }, "portal-item": { write: false } } } })], E.prototype, "labelPosition", void 0), e([y2({ type: Number })], E.prototype, "maxScale", void 0), e([r("maxScale")], E.prototype, "writeMaxScale", null), e([y2({ type: Number })], E.prototype, "minScale", void 0), e([r("minScale")], E.prototype, "writeMinScale", null), e([y2({ type: Boolean, json: { write: true, origins: { "web-scene": { write: false }, "portal-item": { write: false } } } })], E.prototype, "repeatLabel", void 0), e([y2({ type: Number, cast: o2, json: { write: true, origins: { "web-scene": { write: false } } } })], E.prototype, "repeatLabelDistance", void 0), e([y2({ types: P, json: { origins: { "web-scene": { types: F, write: c, default: null } }, write: c, default: null } })], E.prototype, "symbol", void 0), e([y2({ type: Boolean, json: { write: true } })], E.prototype, "useCodedValues", void 0), e([y2({ type: String, json: { write: true } })], E.prototype, "where", void 0), E = y4 = e([n("esri.layers.support.LabelClass")], E);
var j = E;

// node_modules/@arcgis/core/layers/support/labelingInfo.js
var n3 = s.getLogger("esri.layers.support.labelingInfo");
var l3 = /\[([^\[\]]+)\]/gi;
function i(e2, r2, o3) {
  return e2 ? e2.map((e3) => {
    const n4 = new j();
    if (n4.read(e3, o3), n4.labelExpression) {
      const e4 = r2.fields || r2.layerDefinition && r2.layerDefinition.fields || this.fields;
      n4.labelExpression = n4.labelExpression.replace(l3, (r3, o4) => `[${s4(o4, e4)}]`);
    }
    return n4;
  }) : null;
}
function s4(e2, r2) {
  if (!r2)
    return e2;
  const o3 = e2.toLowerCase();
  for (let t = 0; t < r2.length; t++) {
    const e3 = r2[t].name;
    if (e3.toLowerCase() === o3)
      return e3;
  }
  return e2;
}
var a2 = { esriGeometryPoint: ["above-right", "above-center", "above-left", "center-center", "center-left", "center-right", "below-center", "below-left", "below-right"], esriGeometryPolygon: ["always-horizontal"], esriGeometryPolyline: ["center-along"], esriGeometryMultipoint: null };
function c2(e2, o3) {
  const t = y(e2);
  return t.some((e3) => f2(e3, o3)) ? [] : t;
}
function f2(r2, o3) {
  const t = r2.labelPlacement, l4 = a2[o3];
  if (!r2.symbol)
    return n3.warn("No ILabelClass symbol specified."), true;
  if (!l4)
    return n3.error(new s2("labeling:unsupported-geometry-type", `Unable to create labels for layer, geometry type '${o3}' is not supported`)), true;
  if (!l4.includes(t)) {
    const e2 = l4[0];
    t && n3.warn(`Found invalid label placement type ${t} for ${o3}. Defaulting to ${e2}`), r2.labelPlacement = e2;
  }
  return false;
}

export {
  j,
  i,
  c2 as c
};
//# sourceMappingURL=chunk-2T7LFOXQ.js.map
