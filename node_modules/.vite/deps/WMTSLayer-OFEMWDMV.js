import {
  o as o2
} from "./chunk-YINMVLPI.js";
import {
  o as o3
} from "./chunk-ELA7HWPA.js";
import {
  p as p2,
  x
} from "./chunk-WRRXNIRL.js";
import {
  j as j3
} from "./chunk-OOOPZLJE.js";
import "./chunk-U2WD23Z5.js";
import {
  v
} from "./chunk-G3HEFWHV.js";
import {
  p
} from "./chunk-3GENFQBG.js";
import {
  c
} from "./chunk-FX6IXM55.js";
import {
  O as O2
} from "./chunk-QFFP6A5Q.js";
import "./chunk-YGVY4EIZ.js";
import "./chunk-HUQX7WZO.js";
import "./chunk-BYSA56OH.js";
import "./chunk-US2IWMHE.js";
import "./chunk-ZPYDYUP5.js";
import {
  n as n2
} from "./chunk-TDV3ZXCQ.js";
import {
  t as t2
} from "./chunk-XJCUKRCO.js";
import {
  b
} from "./chunk-SOEQPPQP.js";
import "./chunk-22F6X66Z.js";
import "./chunk-AIDV7EKX.js";
import "./chunk-FZQZIM7U.js";
import "./chunk-YM6PUX7G.js";
import "./chunk-QEYOWTXD.js";
import "./chunk-CZBRZ6SU.js";
import "./chunk-KDO6J2FO.js";
import "./chunk-RT3T2K4S.js";
import {
  s as s2
} from "./chunk-WJCI2CGX.js";
import "./chunk-BLJKKR5D.js";
import "./chunk-X2S4RQJ4.js";
import "./chunk-376OPXM4.js";
import "./chunk-DER356EU.js";
import "./chunk-NRP45AHD.js";
import "./chunk-6M2AHKYV.js";
import "./chunk-SZIJNKCV.js";
import "./chunk-6O43OEU5.js";
import "./chunk-J2K7ZDSV.js";
import "./chunk-2UML3WQZ.js";
import {
  j as j2
} from "./chunk-UDND2Z3V.js";
import "./chunk-23Y3DIC6.js";
import "./chunk-JUVQV3R3.js";
import "./chunk-ZYRIJWLX.js";
import "./chunk-C5H57NTD.js";
import "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import "./chunk-YWAQYJRC.js";
import "./chunk-B356PXLT.js";
import "./chunk-EHPBHJYZ.js";
import "./chunk-3MNMDUQZ.js";
import {
  w as w2,
  w2 as w3
} from "./chunk-UWG37XSU.js";
import {
  r as r3
} from "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import {
  r as r2
} from "./chunk-HLM6QCL2.js";
import {
  o
} from "./chunk-RXYULINL.js";
import {
  U,
  a,
  l as l2
} from "./chunk-5NXILPDI.js";
import "./chunk-THVR7IAM.js";
import "./chunk-ZWJJTUFL.js";
import {
  U as U2
} from "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import {
  I,
  j
} from "./chunk-KAN4HXCG.js";
import "./chunk-4FEGON7M.js";
import "./chunk-VWYWOOPX.js";
import "./chunk-M5VHU5LK.js";
import {
  l
} from "./chunk-7QMMKGW4.js";
import {
  e,
  n2 as n,
  y as y2
} from "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import {
  O,
  w
} from "./chunk-MJXQTGI2.js";
import {
  s
} from "./chunk-LIZHLHNA.js";
import "./chunk-BTUHYGXO.js";
import "./chunk-UA3YPL2R.js";
import {
  t,
  y
} from "./chunk-HVKDYDPP.js";
import "./chunk-6QC7MLLS.js";
import {
  r
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/layers/support/TileInfoTilemapCache.js
var l3 = class {
  constructor(i2, l5 = 0, a2 = i2.lods.length - 1) {
    this.tileInfo = i2, this.minLOD = l5, this.maxLOD = a2;
  }
  getAvailability(i2, l5, a2) {
    var _a;
    const t3 = (_a = this.tileInfo) == null ? void 0 : _a.lodAt(i2);
    return !t3 || i2 < this.minLOD || i2 > this.maxLOD ? "unavailable" : t3.cols && t3.rows ? a2 >= t3.cols[0] && a2 <= t3.cols[1] && l5 >= t3.rows[0] && l5 <= t3.rows[1] ? "available" : "unavailable" : "available";
  }
  async fetchAvailability(l5, a2, t3, e2) {
    return await O(e2), this.getAvailability(l5, a2, t3);
  }
  async fetchAvailabilityUpsample(l5, a2, t3, e2, s3) {
    await O(s3), e2.level = l5, e2.row = a2, e2.col = t3;
    const o5 = this.tileInfo;
    for (o5.updateTileInfo(e2); ; ) {
      const i2 = this.getAvailability(e2.level, e2.row, e2.col);
      if ("unavailable" !== i2)
        return i2;
      if (!o5.upsampleTile(e2))
        return "unavailable";
    }
  }
};

// node_modules/@arcgis/core/layers/support/TileMatrixSet.js
var l4;
var n3 = l4 = class extends l {
  constructor(t3) {
    super(t3), this.fullExtent = null, this.id = null, this.tileInfo = null;
  }
  clone() {
    const t3 = new l4();
    return this.hasOwnProperty("fullExtent") && (t3.fullExtent = this.fullExtent && this.fullExtent.clone()), this.hasOwnProperty("id") && (t3.id = this.id), this.hasOwnProperty("tileInfo") && (t3.tileInfo = this.tileInfo && this.tileInfo.clone()), t3;
  }
};
e([y2({ type: w3, json: { read: { source: "fullExtent" } } })], n3.prototype, "fullExtent", void 0), e([y2({ type: String, json: { read: { source: "id" } } })], n3.prototype, "id", void 0), e([y2({ type: j3, json: { read: { source: "tileInfo" } } })], n3.prototype, "tileInfo", void 0), n3 = l4 = e([n("esri.layer.support.TileMatrixSet")], n3);
var p3 = n3;

// node_modules/@arcgis/core/layers/support/WMTSStyle.js
var o4;
var i = o4 = class extends l {
  constructor(r4) {
    super(r4), this.id = null, this.title = null, this.description = null, this.legendUrl = null;
  }
  clone() {
    const r4 = new o4();
    return this.hasOwnProperty("description") && (r4.description = this.description), this.hasOwnProperty("id") && (r4.id = this.id), this.hasOwnProperty("isDefault") && (r4.isDefault = this.isDefault), this.hasOwnProperty("keywords") && (r4.keywords = this.keywords && this.keywords.slice()), this.hasOwnProperty("legendUrl") && (r4.legendUrl = this.legendUrl), this.hasOwnProperty("title") && (r4.title = this.title), r4;
  }
};
e([y2({ json: { read: { source: "id" } } })], i.prototype, "id", void 0), e([y2({ json: { read: { source: "title" } } })], i.prototype, "title", void 0), e([y2({ json: { read: { source: "abstract" } } })], i.prototype, "description", void 0), e([y2({ json: { read: { source: "legendUrl" } } })], i.prototype, "legendUrl", void 0), e([y2({ json: { read: { source: "isDefault" } } })], i.prototype, "isDefault", void 0), e([y2({ json: { read: { source: "keywords" } } })], i.prototype, "keywords", void 0), i = o4 = e([n("esri.layer.support.WMTSStyle")], i);
var p4 = i;

// node_modules/@arcgis/core/layers/support/WMTSSublayer.js
var p5;
var m = p5 = class extends l {
  constructor(t3) {
    super(t3), this.fullExtent = null, this.fullExtents = null, this.imageFormats = null, this.id = null, this.layer = null, this.styles = null, this.tileMatrixSetId = null, this.tileMatrixSets = null;
  }
  get description() {
    return this._get("description");
  }
  set description(t3) {
    this._set("description", t3);
  }
  readFullExtent(t3, e2) {
    return (t3 = e2.fullExtent) ? w3.fromJSON(t3) : null;
  }
  readFullExtents(t3, e2) {
    var _a, _b, _c;
    return ((_a = e2.fullExtents) == null ? void 0 : _a.length) ? e2.fullExtents.map((t4) => w3.fromJSON(t4)) : (_c = (_b = e2.tileMatrixSets) == null ? void 0 : _b.map((t4) => w3.fromJSON(t4.fullExtent)).filter((t4) => t4)) != null ? _c : [];
  }
  get imageFormat() {
    let t3 = this._get("imageFormat");
    return t3 || (t3 = this.imageFormats && this.imageFormats.length ? this.imageFormats[0] : ""), t3;
  }
  set imageFormat(t3) {
    const e2 = this.imageFormats;
    t3 && (t3.includes("image/") || e2 && !e2.includes(t3)) && (t3.includes("image/") || (t3 = "image/" + t3), e2 && !e2.includes(t3)) ? console.error("The layer doesn't support the format of " + t3) : this._set("imageFormat", t3);
  }
  get styleId() {
    var _a;
    let t3 = this._get("styleId");
    return t3 || (t3 = ((_a = this.styles) == null ? void 0 : _a.length) ? this.styles.getItemAt(0).id : ""), t3;
  }
  set styleId(t3) {
    this._set("styleId", t3);
  }
  get title() {
    return this._get("title");
  }
  set title(t3) {
    this._set("title", t3);
  }
  get tileMatrixSet() {
    return this.tileMatrixSets ? this.tileMatrixSets.find((t3) => t3.id === this.tileMatrixSetId) : null;
  }
  clone() {
    var _a;
    const t3 = new p5();
    return this.hasOwnProperty("description") && (t3.description = this.description), this.hasOwnProperty("imageFormats") && (t3.imageFormats = this.imageFormats && this.imageFormats.slice()), this.hasOwnProperty("imageFormat") && (t3.imageFormat = this.imageFormat), this.hasOwnProperty("fullExtent") && (t3.fullExtent = this.fullExtent && this.fullExtent.clone()), this.hasOwnProperty("id") && (t3.id = this.id), this.hasOwnProperty("layer") && (t3.layer = this.layer), this.hasOwnProperty("styleId") && (t3.styleId = this.styleId), this.hasOwnProperty("styles") && (t3.styles = this.styles && this.styles.clone()), this.hasOwnProperty("tileMatrixSetId") && (t3.tileMatrixSetId = this.tileMatrixSetId), this.hasOwnProperty("tileMatrixSets") && (t3.tileMatrixSets = (_a = this.tileMatrixSets) == null ? void 0 : _a.clone()), this.hasOwnProperty("title") && (t3.title = this.title), t3;
  }
};
e([y2()], m.prototype, "description", null), e([y2()], m.prototype, "fullExtent", void 0), e([o("fullExtent", ["fullExtent"])], m.prototype, "readFullExtent", null), e([y2({ readOnly: true })], m.prototype, "fullExtents", void 0), e([o("fullExtents", ["fullExtents", "tileMatrixSets"])], m.prototype, "readFullExtents", null), e([y2()], m.prototype, "imageFormat", null), e([y2({ json: { read: { source: "formats" } } })], m.prototype, "imageFormats", void 0), e([y2()], m.prototype, "id", void 0), e([y2()], m.prototype, "layer", void 0), e([y2()], m.prototype, "styleId", null), e([y2({ type: j2.ofType(p4), json: { read: { source: "styles" } } })], m.prototype, "styles", void 0), e([y2({ value: null, json: { write: { ignoreOrigin: true } } })], m.prototype, "title", null), e([y2()], m.prototype, "tileMatrixSetId", void 0), e([y2({ readOnly: true })], m.prototype, "tileMatrixSet", null), e([y2({ type: j2.ofType(p3), json: { read: { source: "tileMatrixSets" } } })], m.prototype, "tileMatrixSets", void 0), m = p5 = e([n("esri.layers.support.WMTSSublayer")], m);
var u = m;

// node_modules/@arcgis/core/layers/support/wmtsUtils.js
var c2 = 90.71428571428571;
function u2(t3) {
  const n4 = t3.replace(/ows:/gi, "");
  if (!m2("Contents", new DOMParser().parseFromString(n4, "text/xml").documentElement))
    throw new s("wmtslayer:wmts-capabilities-xml-is-not-valid", "the wmts get capabilities response is not compliant", { text: t3 });
}
function p6(t3, n4) {
  var _a, _b;
  t3 = t3.replace(/ows:/gi, "");
  const i2 = new DOMParser().parseFromString(t3, "text/xml").documentElement, r4 = /* @__PURE__ */ new Map(), o5 = /* @__PURE__ */ new Map(), l5 = m2("Contents", i2);
  if (!l5)
    throw new s("wmtslayer:wmts-capabilities-xml-is-not-valid");
  const s3 = (_a = m2("OperationsMetadata", i2)) == null ? void 0 : _a.querySelector("[name='GetTile']"), a2 = s3 == null ? void 0 : s3.getElementsByTagName("Get"), c3 = a2 && Array.prototype.slice.call(a2), u3 = (_b = n4.url) == null ? void 0 : _b.indexOf("https"), p7 = void 0 !== u3 && u3 > -1;
  let f2, d2, x3 = n4.serviceMode, M2 = n4 == null ? void 0 : n4.url;
  if (c3 && c3.length && c3.some((e2) => {
    const t4 = m2("Constraint", e2);
    return !t4 || w4("AllowedValues", "Value", x3, t4) ? (M2 = e2.attributes[0].nodeValue, true) : (!t4 || w4("AllowedValues", "Value", "RESTful", t4) || w4("AllowedValues", "Value", "REST", t4) ? d2 = e2.attributes[0].nodeValue : t4 && !w4("AllowedValues", "Value", "KVP", t4) || (f2 = e2.attributes[0].nodeValue), false);
  }), !M2)
    if (d2)
      M2 = d2, x3 = "RESTful";
    else if (f2)
      M2 = f2, x3 = "KVP";
    else {
      const e2 = m2("ServiceMetadataURL", i2);
      M2 = e2 == null ? void 0 : e2.getAttribute("xlink:href");
    }
  const T2 = M2.indexOf("1.0.0/");
  -1 === T2 && "RESTful" === x3 ? M2 += "/" : T2 > -1 && (M2 = M2.substring(0, T2)), "KVP" === x3 && (M2 += T2 > -1 ? "" : "?"), p7 && (M2 = M2.replace(/^http:/i, "https:"));
  const y4 = h("ServiceIdentification>ServiceTypeVersion", i2), R2 = h("ServiceIdentification>AccessConstraints", i2), S2 = R2 && /^none$/i.test(R2) ? null : R2, V3 = g("Layer", l5), b3 = g("TileMatrixSet", l5), E2 = V3.map((e2) => {
    const t4 = h("Identifier", e2);
    return r4.set(t4, e2), C(t4, e2, b3, p7, y4);
  });
  return { copyright: S2, dimensionMap: o5, layerMap: r4, layers: E2, serviceMode: x3, tileUrl: M2 };
}
function f(e2) {
  return e2.layers.forEach((e3) => {
    var _a;
    (_a = e3.tileMatrixSets) == null ? void 0 : _a.forEach((e4) => {
      var _a2;
      const t3 = e4.tileInfo;
      t3 && 96 !== t3.dpi && ((_a2 = t3.lods) == null ? void 0 : _a2.forEach((n4) => {
        var _a3;
        n4.scale = 96 * n4.scale / t3.dpi, n4.resolution = U3((_a3 = t3.spatialReference) == null ? void 0 : _a3.wkid, n4.scale * c2 / 96, e4.id);
      }), t3.dpi = 96);
    });
  }), e2;
}
function d(e2) {
  return e2.nodeType === Node.ELEMENT_NODE;
}
function m2(e2, t3) {
  for (let n4 = 0; n4 < t3.childNodes.length; n4++) {
    const i2 = t3.childNodes[n4];
    if (d(i2) && i2.nodeName === e2)
      return i2;
  }
  return null;
}
function g(e2, t3) {
  const n4 = [];
  for (let i2 = 0; i2 < t3.childNodes.length; i2++) {
    const r4 = t3.childNodes[i2];
    d(r4) && r4.nodeName === e2 && n4.push(r4);
  }
  return n4;
}
function x2(e2, n4) {
  const i2 = [];
  for (let t3 = 0; t3 < n4.childNodes.length; t3++) {
    const r4 = n4.childNodes[t3];
    d(r4) && r4.nodeName === e2 && i2.push(r4);
  }
  return i2.map((e3) => e3.textContent).filter(r);
}
function h(e2, t3) {
  return e2.split(">").forEach((e3) => {
    t3 && (t3 = m2(e3, t3));
  }), t3 && t3.textContent;
}
function w4(e2, t3, n4, i2) {
  let r4;
  return Array.prototype.slice.call(i2.childNodes).some((i3) => {
    if (i3.nodeName.includes(e2)) {
      const e3 = m2(t3, i3), o5 = e3 && e3.textContent;
      if (o5 === n4 || n4.split(":") && n4.split(":")[1] === o5)
        return r4 = i3, true;
    }
    return false;
  }), r4;
}
function C(e2, t3, n4, i2, r4) {
  const o5 = h("Abstract", t3), l5 = x2("Format", t3);
  return { id: e2, fullExtent: S(t3), fullExtents: V(t3), description: o5, formats: l5, styles: b2(t3, i2), title: h("Title", t3), tileMatrixSets: E(r4, t3, n4) };
}
function M(e2, t3) {
  var _a;
  const n4 = [], i2 = (_a = e2.layerMap) == null ? void 0 : _a.get(t3);
  if (!i2)
    return null;
  const r4 = g("ResourceURL", i2), o5 = g("Dimension", i2);
  let l5, s3, a2, c3;
  return o5.length && (l5 = h("Identifier", o5[0]), s3 = x2("Default", o5[0]) || x2("Value", o5[0])), o5.length > 1 && (a2 = h("Identifier", o5[1]), c3 = x2("Default", o5[1]) || x2("Value", o5[1])), e2.dimensionMap.set(t3, { dimensions: s3, dimensions2: c3 }), r4.forEach((e3) => {
    let t4 = e3.getAttribute("template");
    if ("tile" === e3.getAttribute("resourceType")) {
      if (l5 && s3.length)
        if (t4.includes("{" + l5 + "}"))
          t4 = t4.replace("{" + l5 + "}", "{dimensionValue}");
        else {
          const e4 = t4.toLowerCase().indexOf("{" + l5.toLowerCase() + "}");
          e4 > -1 && (t4 = t4.substring(0, e4) + "{dimensionValue}" + t4.substring(e4 + l5.length + 2));
        }
      if (a2 && c3.length)
        if (t4.includes("{" + a2 + "}"))
          t4 = t4.replace("{" + a2 + "}", "{dimensionValue2}");
        else {
          const e4 = t4.toLowerCase().indexOf("{" + a2.toLowerCase() + "}");
          e4 > -1 && (t4 = t4.substring(0, e4) + "{dimensionValue2}" + t4.substring(e4 + a2.length + 2));
        }
      n4.push({ template: t4, format: e3.getAttribute("format"), resourceType: "tile" });
    }
  }), n4;
}
function T(e2, t3, n4, i2, r4, o5, l5, s3) {
  var _a, _b;
  const a2 = y3(e2, t3, i2);
  if (!((a2 == null ? void 0 : a2.length) > 0))
    return "";
  const { dimensionMap: c3 } = e2, u3 = (_a = c3.get(t3).dimensions) == null ? void 0 : _a[0], p7 = (_b = c3.get(t3).dimensions2) == null ? void 0 : _b[0];
  return a2[l5 % a2.length].template.replace(/\{Style\}/gi, r4 != null ? r4 : "").replace(/\{TileMatrixSet\}/gi, n4 != null ? n4 : "").replace(/\{TileMatrix\}/gi, o5).replace(/\{TileRow\}/gi, "" + l5).replace(/\{TileCol\}/gi, "" + s3).replace(/\{dimensionValue\}/gi, u3).replace(/\{dimensionValue2\}/gi, p7);
}
function y3(e2, t3, n4) {
  var _a;
  const i2 = M(e2, t3), r4 = i2 == null ? void 0 : i2.filter((e3) => e3.format === n4);
  return (_a = (r4 == null ? void 0 : r4.length) ? r4 : i2) != null ? _a : [];
}
function R(e2, t3, n4, i2) {
  const { dimensionMap: r4 } = e2, o5 = M(e2, t3);
  let l5 = "";
  if (o5 && o5.length > 0) {
    const e3 = r4.get(t3).dimensions && r4.get(t3).dimensions[0], s3 = r4.get(t3).dimensions2 && r4.get(t3).dimensions2[0];
    l5 = o5[0].template, l5.indexOf(".xxx") === l5.length - 4 && (l5 = l5.slice(0, l5.length - 4)), l5 = l5.replace(/\{Style\}/gi, i2), l5 = l5.replace(/\{TileMatrixSet\}/gi, n4), l5 = l5.replace(/\{TileMatrix\}/gi, "{level}"), l5 = l5.replace(/\{TileRow\}/gi, "{row}"), l5 = l5.replace(/\{TileCol\}/gi, "{col}"), l5 = l5.replace(/\{dimensionValue\}/gi, e3), l5 = l5.replace(/\{dimensionValue2\}/gi, s3);
  }
  return l5;
}
function S(e2) {
  const t3 = m2("WGS84BoundingBox", e2), n4 = t3 ? h("LowerCorner", t3).split(" ") : ["-180", "-90"], i2 = t3 ? h("UpperCorner", t3).split(" ") : ["180", "90"];
  return { xmin: parseFloat(n4[0]), ymin: parseFloat(n4[1]), xmax: parseFloat(i2[0]), ymax: parseFloat(i2[1]), spatialReference: { wkid: 4326 } };
}
function V(e2) {
  const t3 = [];
  return o2(e2, { BoundingBox: (e3) => {
    if (!e3.getAttribute("crs"))
      return;
    const n4 = e3.getAttribute("crs").toLowerCase(), i2 = I2(n4), r4 = n4.includes("epsg") && o3(i2.wkid);
    let o5, a2, c3, u3;
    o2(e3, { LowerCorner: (e4) => {
      [o5, a2] = e4.textContent.split(" ").map((e5) => Number.parseFloat(e5)), r4 && ([o5, a2] = [a2, o5]);
    }, UpperCorner: (e4) => {
      [c3, u3] = e4.textContent.split(" ").map((e5) => Number.parseFloat(e5)), r4 && ([c3, u3] = [u3, c3]);
    } }), t3.push({ xmin: o5, ymin: a2, xmax: c3, ymax: u3, spatialReference: i2 });
  } }), t3;
}
function b2(e2, t3) {
  return g("Style", e2).map((e3) => {
    const n4 = m2("LegendURL", e3), i2 = m2("Keywords", e3), r4 = i2 ? x2("Keyword", i2) : [];
    let o5 = n4 && n4.getAttribute("xlink:href");
    t3 && (o5 = o5 && o5.replace(/^http:/i, "https:"));
    return { abstract: h("Abstract", e3), id: h("Identifier", e3), isDefault: "true" === e3.getAttribute("isDefault"), keywords: r4, legendUrl: o5, title: h("Title", e3) };
  });
}
function E(e2, t3, n4) {
  return g("TileMatrixSetLink", t3).map((t4) => L(e2, t4, n4));
}
function L(e2, t3, n4) {
  const i2 = m2("TileMatrixSet", t3).textContent, r4 = x2("TileMatrix", t3), o5 = n4.find((e3) => {
    const t4 = m2("Identifier", e3), n5 = t4 && t4.textContent;
    return !!(n5 === i2 || i2.split(":") && i2.split(":")[1] === n5);
  }), l5 = m2("TileMatrixSetLimits", t3), s3 = l5 && g("TileMatrixLimits", l5), c3 = /* @__PURE__ */ new Map();
  if (s3 == null ? void 0 : s3.length)
    for (const a2 of s3) {
      const e3 = m2("TileMatrix", a2).textContent, t4 = +m2("MinTileRow", a2).textContent, n5 = +m2("MaxTileRow", a2).textContent, i3 = +m2("MinTileCol", a2).textContent, r5 = +m2("MaxTileCol", a2).textContent;
      c3.set(e3, { minCol: i3, maxCol: r5, minRow: t4, maxRow: n5 });
    }
  const u3 = h("SupportedCRS", o5).toLowerCase(), p7 = N(o5, u3), f2 = p7.spatialReference, d2 = m2("TileMatrix", o5), C2 = [parseInt(h("TileWidth", d2), 10), parseInt(h("TileHeight", d2), 10)], M2 = [];
  if (r4.length)
    r4.forEach((e3, t4) => {
      const n5 = w4("TileMatrix", "Identifier", e3, o5);
      M2.push(D(n5, u3, t4, i2, c3));
    });
  else {
    g("TileMatrix", o5).forEach((e3, t4) => {
      M2.push(D(e3, u3, t4, i2, c3));
    });
  }
  const T2 = v2(e2, o5, p7, C2, M2[0]).toJSON(), y4 = new j3({ dpi: 96, spatialReference: f2, size: C2, origin: p7, lods: M2 }).toJSON();
  return { id: i2, fullExtent: T2, tileInfo: y4 };
}
function I2(e2) {
  e2 = e2.toLowerCase();
  let n4 = parseInt(e2.split(":").pop(), 10);
  900913 !== n4 && 3857 !== n4 || (n4 = 102100);
  const i2 = k(e2);
  return r(i2) && (n4 = i2), { wkid: n4 };
}
function N(e2, t3) {
  return A(m2("TileMatrix", e2), t3);
}
function A(e2, t3) {
  const n4 = I2(t3), [r4, o5] = h("TopLeftCorner", e2).split(" ").map((e3) => parseFloat(e3)), s3 = t3.includes("epsg") && o3(n4.wkid);
  return new w2(s3 ? { x: o5, y: r4, spatialReference: n4 } : { x: r4, y: o5, spatialReference: n4 });
}
function v2(e2, t3, i2, r4, o5) {
  const l5 = m2("BoundingBox", t3);
  let s3, a2, c3, u3, p7, f2;
  if (l5 && (s3 = h("LowerCorner", l5).split(" "), a2 = h("UpperCorner", l5).split(" ")), s3 && s3.length > 1 && a2 && a2.length > 1)
    c3 = parseFloat(s3[0]), p7 = parseFloat(s3[1]), u3 = parseFloat(a2[0]), f2 = parseFloat(a2[1]);
  else {
    const e3 = m2("TileMatrix", t3), n4 = parseInt(h("MatrixWidth", e3), 10), l6 = parseInt(h("MatrixHeight", e3), 10);
    c3 = i2.x, f2 = i2.y, u3 = c3 + n4 * r4[0] * o5.resolution, p7 = f2 - l6 * r4[1] * o5.resolution;
  }
  return F(e2, i2.spatialReference, i2) ? new w3(p7, c3, f2, u3, i2.spatialReference) : new w3(c3, p7, u3, f2, i2.spatialReference);
}
function F(e2, t3, n4) {
  return "1.0.0" === e2 && o3(t3.wkid) && !(n4.spatialReference.isGeographic && n4.x < -90 && n4.y >= -90);
}
var O3;
function k(e2) {
  return e2.includes("crs84") || e2.includes("crs:84") ? O3.CRS84 : e2.includes("crs83") || e2.includes("crs:83") ? O3.CRS83 : e2.includes("crs27") || e2.includes("crs:27") ? O3.CRS27 : null;
}
function D(e2, t3, n4, i2, r4) {
  var _a;
  const o5 = I2(t3), l5 = h("Identifier", e2);
  let s3 = parseFloat(h("ScaleDenominator", e2));
  const a2 = U3(o5.wkid, s3, i2);
  s3 *= 96 / c2;
  const u3 = +h("MatrixWidth", e2), p7 = +h("MatrixHeight", e2), { maxCol: f2 = u3 - 1, maxRow: d2 = p7 - 1, minCol: m3 = 0, minRow: g2 = 0 } = (_a = r4.get(l5)) != null ? _a : {}, { x: x3, y: w5 } = A(e2, t3);
  return { cols: [m3, f2], level: n4, levelValue: l5, origin: [x3, w5], scale: s3, resolution: a2, rows: [g2, d2] };
}
function U3(e2, t3, n4) {
  let i2;
  return i2 = r3.hasOwnProperty("" + e2) ? r3.values[r3[e2]] : "default028mm" === n4 ? 6370997 * Math.PI / 180 : s2(e2).metersPerDegree, 7 * t3 / 25e3 / i2;
}
!function(e2) {
  e2[e2.CRS84 = 4326] = "CRS84", e2[e2.CRS83 = 4269] = "CRS83", e2[e2.CRS27 = 4267] = "CRS27";
}(O3 || (O3 = {}));

// node_modules/@arcgis/core/layers/WMTSLayer.js
var W = { "image/png": ".png", "image/png8": ".png", "image/png24": ".png", "image/png32": ".png", "image/jpg": ".jpg", "image/jpeg": ".jpeg", "image/gif": ".gif", "image/bmp": ".bmp", "image/tiff": ".tif", "image/jpgpng": "", "image/jpegpng": "", "image/unknown": "" };
var A2 = /* @__PURE__ */ new Set(["version", "service", "request", "layer", "style", "format", "tilematrixset", "tilematrix", "tilerow", "tilecol"]);
var F2 = class extends n2(p(t2(c(v(O2(b)))))) {
  constructor(...e2) {
    super(...e2), this.copyright = "", this.customParameters = null, this.customLayerParameters = null, this.fullExtent = null, this.operationalLayerType = "WebTiledLayer", this.resourceInfo = null, this.serviceMode = "RESTful", this.sublayers = null, this.type = "wmts", this.version = "1.0.0", this.addHandles([l2(() => this.activeLayer, (e3, t3) => {
      t3 && (t3.layer = null), e3 && (e3.layer = this);
    }, U), a(() => this.sublayers, "after-add", ({ item: e3 }) => {
      e3.layer = this;
    }, U), a(() => this.sublayers, "after-remove", ({ item: e3 }) => {
      e3.layer = null;
    }, U), l2(() => this.sublayers, (e3, t3) => {
      if (t3)
        for (const r4 of t3)
          r4.layer = null;
      if (e3)
        for (const r4 of e3)
          r4.layer = this;
    }, U)]);
  }
  normalizeCtorArgs(e2, t3) {
    return "string" == typeof e2 ? { url: e2, ...t3 } : e2;
  }
  load(e2) {
    if ("KVP" === this.serviceMode || "RESTful" === this.serviceMode)
      return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["WMTS"] }, e2).catch(w).then(() => this._fetchService(e2)).catch((e3) => {
        throw w(e3), new s("wmtslayer:unsupported-service-data", "Invalid response from the WMTS service.", { error: e3 });
      })), Promise.resolve(this);
    console.error("WMTS mode could only be 'KVP' or 'RESTful'");
  }
  get activeLayer() {
    return this._get("activeLayer");
  }
  set activeLayer(e2) {
    this._set("activeLayer", e2);
  }
  readActiveLayerFromService(e2, t3, r4) {
    this.activeLayer || (this.activeLayer = new u());
    let i2 = t3.layers.find((e3) => e3.id === this.activeLayer.id);
    return i2 || (i2 = t3.layers[0]), this.activeLayer.read(i2, r4), this.activeLayer;
  }
  readActiveLayerFromItemOrWebDoc(e2, t3) {
    const { templateUrl: r4, wmtsInfo: i2 } = t3, s3 = r4 ? this._getLowerCasedUrlParams(r4) : null, a2 = i2 == null ? void 0 : i2.layerIdentifier;
    let o5 = null;
    const l5 = i2 == null ? void 0 : i2.tileMatrixSet;
    l5 && (Array.isArray(l5) ? l5.length && (o5 = l5[0]) : o5 = l5);
    const n4 = s3 == null ? void 0 : s3.format, m3 = s3 == null ? void 0 : s3.style;
    return new u({ id: a2, imageFormat: n4, styleId: m3, tileMatrixSetId: o5 });
  }
  writeActiveLayer(e2, t3, r4, i2) {
    const s3 = this.activeLayer;
    t3.templateUrl = this.getUrlTemplate(s3.id, s3.tileMatrixSetId, s3.imageFormat, s3.styleId);
    const a2 = t("tileMatrixSet.tileInfo", s3);
    t3.tileInfo = a2 ? a2.toJSON(i2) : null, t3.wmtsInfo = { ...t3.wmtsInfo, layerIdentifier: s3.id, tileMatrixSet: s3.tileMatrixSetId };
  }
  readCustomParameters(e2, t3) {
    const r4 = t3.wmtsInfo;
    return r4 ? this._mergeParams(r4.customParameters, r4.url) : null;
  }
  get fullExtents() {
    return this.activeLayer.fullExtents;
  }
  readServiceMode(e2, t3) {
    return t3.templateUrl.includes("?") ? "KVP" : "RESTful";
  }
  readSublayersFromService(e2, t3, r4) {
    return V2(t3.layers, r4);
  }
  get supportedSpatialReferences() {
    var _a, _b;
    return (_b = (_a = this.activeLayer.tileMatrixSets) == null ? void 0 : _a.map((e2) => {
      var _a2;
      return (_a2 = e2.tileInfo) == null ? void 0 : _a2.spatialReference;
    }).toArray().filter(r)) != null ? _b : [];
  }
  get tilemapCache() {
    var _a, _b;
    const e2 = (_b = (_a = this.activeLayer) == null ? void 0 : _a.tileMatrixSet) == null ? void 0 : _b.tileInfo;
    return e2 ? new l3(e2) : void 0;
  }
  get title() {
    var _a, _b;
    return (_b = (_a = this.activeLayer) == null ? void 0 : _a.title) != null ? _b : "Layer";
  }
  set title(e2) {
    this._overrideIfSome("title", e2);
  }
  get url() {
    return this._get("url");
  }
  set url(e2) {
    e2 && "/" === e2.substr(-1) ? this._set("url", e2.slice(0, -1)) : this._set("url", e2);
  }
  createWebTileLayer(e2) {
    var _a;
    const t3 = this.getUrlTemplate(this.activeLayer.id, this.activeLayer.tileMatrixSetId, this.activeLayer.imageFormat, this.activeLayer.styleId), r4 = (_a = this._getTileMatrixSetById(e2.tileMatrixSetId)) == null ? void 0 : _a.tileInfo, i2 = e2.fullExtent, s3 = new p2({ layerIdentifier: e2.id, tileMatrixSet: e2.tileMatrixSetId, url: this.url });
    return this.customLayerParameters && (s3.customLayerParameters = this.customLayerParameters), this.customParameters && (s3.customParameters = this.customParameters), new x({ fullExtent: i2, urlTemplate: t3, tileInfo: r4, wmtsInfo: s3 });
  }
  fetchTile(e2, r4, i2) {
    const s3 = this.getTileUrl(e2, r4, i2);
    return U2(s3, { responseType: "image" }).then((e3) => e3.data);
  }
  async fetchImageBitmapTile(e2, r4, i2) {
    const s3 = this.getTileUrl(e2, r4, i2), { data: a2 } = await U2(s3, { responseType: "blob" });
    return createImageBitmap(a2);
  }
  findSublayerById(e2) {
    var _a;
    return (_a = this.sublayers) == null ? void 0 : _a.find((t3) => t3.id === e2);
  }
  getTileUrl(e2, t3, r4) {
    var _a, _b;
    const i2 = (_b = (_a = this._getTileMatrixSetById(this.activeLayer.tileMatrixSetId)) == null ? void 0 : _a.tileInfo) == null ? void 0 : _b.lods[e2], s3 = i2 ? i2.levelValue ? i2.levelValue : `${i2.level}` : `${e2}`;
    let a2 = this.resourceInfo ? "" : T({ dimensionMap: this.dimensionMap, layerMap: this.layerMap }, this.activeLayer.id, this.activeLayer.tileMatrixSetId, this.activeLayer.imageFormat, this.activeLayer.styleId, s3, t3, r4);
    if (!a2) {
      a2 = this.getUrlTemplate(this.activeLayer.id, this.activeLayer.tileMatrixSetId, this.activeLayer.imageFormat, this.activeLayer.styleId).replace(/\{level\}/gi, s3).replace(/\{row\}/gi, `${t3}`).replace(/\{col\}/gi, `${r4}`);
    }
    return a2 = this._appendCustomLayerParameters(a2), a2;
  }
  getUrlTemplate(e2, t3, r4, i2) {
    if (!this.resourceInfo) {
      const r5 = R({ dimensionMap: this.dimensionMap, layerMap: this.layerMap }, e2, t3, i2);
      if (r5)
        return r5;
    }
    if ("KVP" === this.serviceMode)
      return this.url + "?SERVICE=WMTS&VERSION=" + this.version + "&REQUEST=GetTile&LAYER=" + e2 + "&STYLE=" + i2 + "&FORMAT=" + r4 + "&TILEMATRIXSET=" + t3 + "&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}";
    if ("RESTful" === this.serviceMode) {
      let s3 = "";
      return W[r4.toLowerCase()] && (s3 = W[r4.toLowerCase()]), this.url + e2 + "/" + i2 + "/" + t3 + "/{level}/{row}/{col}" + s3;
    }
    return "";
  }
  async _fetchService(e2) {
    let t3;
    if (this.resourceInfo)
      "KVP" === this.resourceInfo.serviceMode && (this.url += this.url.includes("?") ? "" : "?"), t3 = { ssl: false, data: this.resourceInfo };
    else
      try {
        t3 = await this._getCapabilities(this.serviceMode, e2), u2(t3.data);
      } catch {
        const s3 = "KVP" === this.serviceMode ? "RESTful" : "KVP";
        try {
          t3 = await this._getCapabilities(s3, e2), u2(t3.data), this.serviceMode = s3;
        } catch (r4) {
          throw new s("wmtslayer:unsupported-service-data", "Services does not support RESTful or KVP service modes.", { error: r4 });
        }
      }
    this.resourceInfo ? t3.data = f(t3.data) : t3.data = p6(t3.data, { serviceMode: this.serviceMode, url: this.url }), t3.data && this.read(t3.data, { origin: "service" });
  }
  async _getCapabilities(e2, r4) {
    const i2 = this._getCapabilitiesUrl(e2);
    return await U2(i2, { ...r4, responseType: "text" });
  }
  _getTileMatrixSetById(e2) {
    var _a, _b;
    const t3 = (_b = (_a = this.findSublayerById(this.activeLayer.id)) == null ? void 0 : _a.tileMatrixSets) == null ? void 0 : _b.find((t4) => t4.id === e2);
    return t3;
  }
  _appendCustomParameters(e2) {
    return this._appendParameters(e2, this.customParameters);
  }
  _appendCustomLayerParameters(e2) {
    return this._appendParameters(e2, { ...y(this.customParameters), ...this.customLayerParameters });
  }
  _appendParameters(e2, t3) {
    const r4 = j(e2), i2 = { ...r4.query, ...t3 }, s3 = I(i2);
    return "" === s3 ? r4.path : `${r4.path}?${s3}`;
  }
  _getCapabilitiesUrl(e2) {
    this.url = this.url.split("?")[0];
    const t3 = "KVP" === e2 ? `${this.url}?request=GetCapabilities&service=WMTS&version=${this.version}` : `${this.url}/${this.version}/WMTSCapabilities.xml`;
    return this._appendCustomParameters(t3);
  }
  _getLowerCasedUrlParams(e2) {
    if (!e2)
      return null;
    const t3 = j(e2).query;
    if (!t3)
      return null;
    const r4 = {};
    return Object.keys(t3).forEach((e3) => {
      r4[e3.toLowerCase()] = t3[e3];
    }), r4;
  }
  _mergeParams(e2, t3) {
    const r4 = this._getLowerCasedUrlParams(t3);
    if (r4) {
      const t4 = Object.keys(r4);
      t4.length && (e2 = e2 ? y(e2) : {}, t4.forEach((t5) => {
        e2.hasOwnProperty(t5) || A2.has(t5) || (e2[t5] = r4[t5]);
      }));
    }
    return e2;
  }
};
function V2(e2, t3) {
  return e2.map((e3) => {
    const r4 = new u();
    return r4.read(e3, t3), r4;
  });
}
e([y2()], F2.prototype, "dimensionMap", void 0), e([y2()], F2.prototype, "layerMap", void 0), e([y2({ type: u, json: { origins: { "web-document": { write: { ignoreOrigin: true } } } } })], F2.prototype, "activeLayer", null), e([o("service", "activeLayer", ["layers"])], F2.prototype, "readActiveLayerFromService", null), e([o(["web-document", "portal-item"], "activeLayer", ["wmtsInfo"])], F2.prototype, "readActiveLayerFromItemOrWebDoc", null), e([r2(["web-document", "portal-item"], "activeLayer", { templateUrl: { type: String }, tileInfo: { type: j3 }, "wmtsInfo.layerIdentifier": { type: String }, "wmtsInfo.tileMatrixSet": { type: String } })], F2.prototype, "writeActiveLayer", null), e([y2({ type: String, value: "", json: { write: true } })], F2.prototype, "copyright", void 0), e([y2({ type: ["show", "hide"] })], F2.prototype, "listMode", void 0), e([y2({ json: { read: true, write: true } })], F2.prototype, "blendMode", void 0), e([y2({ json: { origins: { "web-document": { read: { source: ["wmtsInfo.customParameters", "wmtsInfo.url"] }, write: { target: "wmtsInfo.customParameters" } }, "portal-item": { read: { source: ["wmtsInfo.customParameters", "wmtsInfo.url"] }, write: { target: "wmtsInfo.customParameters" } } } } })], F2.prototype, "customParameters", void 0), e([o(["portal-item", "web-document"], "customParameters")], F2.prototype, "readCustomParameters", null), e([y2({ json: { origins: { "web-document": { read: { source: "wmtsInfo.customLayerParameters" }, write: { target: "wmtsInfo.customLayerParameters" } }, "portal-item": { read: { source: "wmtsInfo.customLayerParameters" }, write: { target: "wmtsInfo.customLayerParameters" } } } } })], F2.prototype, "customLayerParameters", void 0), e([y2({ type: w3, json: { write: { ignoreOrigin: true }, origins: { "web-document": { read: { source: "fullExtent" } }, "portal-item": { read: { source: "fullExtent" } } } } })], F2.prototype, "fullExtent", void 0), e([y2({ readOnly: true })], F2.prototype, "fullExtents", null), e([y2({ type: ["WebTiledLayer"] })], F2.prototype, "operationalLayerType", void 0), e([y2()], F2.prototype, "resourceInfo", void 0), e([y2()], F2.prototype, "serviceMode", void 0), e([o(["portal-item", "web-document"], "serviceMode", ["templateUrl"])], F2.prototype, "readServiceMode", null), e([y2({ type: j2.ofType(u) })], F2.prototype, "sublayers", void 0), e([o("service", "sublayers", ["layers"])], F2.prototype, "readSublayersFromService", null), e([y2({ readOnly: true })], F2.prototype, "supportedSpatialReferences", null), e([y2({ readOnly: true })], F2.prototype, "tilemapCache", null), e([y2({ json: { read: { source: "title" } } })], F2.prototype, "title", null), e([y2({ json: { read: false }, readOnly: true, value: "wmts" })], F2.prototype, "type", void 0), e([y2({ json: { origins: { service: { read: { source: "tileUrl" } }, "web-document": { read: { source: "wmtsInfo.url" }, write: { target: "wmtsInfo.url" } }, "portal-item": { read: { source: "wmtsInfo.url" }, write: { target: "wmtsInfo.url" } } } } })], F2.prototype, "url", null), e([y2()], F2.prototype, "version", void 0), F2 = e([n("esri.layers.WMTSLayer")], F2);
var $ = F2;
export {
  $ as default
};
//# sourceMappingURL=WMTSLayer-OFEMWDMV.js.map
