import {
  r as r3
} from "./chunk-7CB5BEGB.js";
import {
  O
} from "./chunk-QGJM2PN7.js";
import {
  e as e6
} from "./chunk-EGV5SNBD.js";
import {
  I
} from "./chunk-LT5KLTS5.js";
import "./chunk-SERWCSJG.js";
import {
  a as a5,
  l as l2
} from "./chunk-MFXTPFHI.js";
import {
  j as j5
} from "./chunk-OOOPZLJE.js";
import "./chunk-U2WD23Z5.js";
import "./chunk-RW4M3CI3.js";
import "./chunk-ZEEU5HOK.js";
import {
  L,
  h as h3
} from "./chunk-K3N3RUKL.js";
import {
  x
} from "./chunk-3KEVP6XQ.js";
import "./chunk-745B43YA.js";
import "./chunk-CN5IW2C7.js";
import {
  c as c2,
  e as e5,
  t as t4
} from "./chunk-RLIJP6DT.js";
import {
  An,
  Re,
  en,
  tn
} from "./chunk-FFVIDMFN.js";
import {
  n as n4
} from "./chunk-VJ7HYCLP.js";
import {
  t as t3
} from "./chunk-RDNOEC45.js";
import {
  M,
  e2 as e4
} from "./chunk-NWBHRPMR.js";
import {
  n2 as n3
} from "./chunk-IIUWTGWW.js";
import "./chunk-K6AYGXUT.js";
import "./chunk-BHXTNOEK.js";
import "./chunk-IS4TIT4N.js";
import "./chunk-I4RYNNL6.js";
import "./chunk-NDQ5FHGV.js";
import "./chunk-HUQX7WZO.js";
import "./chunk-BYSA56OH.js";
import "./chunk-ZWUEORSX.js";
import "./chunk-FMJZBZWF.js";
import "./chunk-GOYVJTGW.js";
import {
  a as a3
} from "./chunk-ZPYDYUP5.js";
import "./chunk-RT3T2K4S.js";
import {
  $
} from "./chunk-WJCI2CGX.js";
import {
  a as a4
} from "./chunk-REIQNAQW.js";
import "./chunk-B4DKBAM3.js";
import {
  b,
  c as c3,
  q,
  u as u2
} from "./chunk-6M2AHKYV.js";
import {
  j as j6
} from "./chunk-SZIJNKCV.js";
import {
  m as m4
} from "./chunk-6O43OEU5.js";
import "./chunk-J2K7ZDSV.js";
import "./chunk-2UML3WQZ.js";
import {
  j as j4
} from "./chunk-UDND2Z3V.js";
import {
  s as s6
} from "./chunk-23Y3DIC6.js";
import "./chunk-JUVQV3R3.js";
import {
  A,
  D,
  g as g2,
  j,
  m
} from "./chunk-C5H57NTD.js";
import {
  P,
  e as e2,
  g,
  r as r2,
  u
} from "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import {
  n
} from "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import "./chunk-3MNMDUQZ.js";
import {
  c,
  f as f2,
  w2 as w
} from "./chunk-UWG37XSU.js";
import {
  E,
  P as P2,
  k2 as k,
  s as s4
} from "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import "./chunk-HLM6QCL2.js";
import "./chunk-RXYULINL.js";
import {
  a as a2,
  f as f3,
  h as h2,
  j as j3,
  l
} from "./chunk-5NXILPDI.js";
import "./chunk-THVR7IAM.js";
import {
  m as m3
} from "./chunk-ZWJJTUFL.js";
import "./chunk-XQN7F674.js";
import {
  U
} from "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import "./chunk-KAN4HXCG.js";
import "./chunk-4FEGON7M.js";
import {
  s as s5
} from "./chunk-VWYWOOPX.js";
import "./chunk-M5VHU5LK.js";
import "./chunk-7QMMKGW4.js";
import {
  e as e3,
  m as m2,
  n2,
  t5 as t2,
  y as y2
} from "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import {
  D as D2,
  a,
  f,
  j as j2,
  v as v2
} from "./chunk-MJXQTGI2.js";
import {
  s as s3
} from "./chunk-LIZHLHNA.js";
import "./chunk-BTUHYGXO.js";
import {
  s2
} from "./chunk-UA3YPL2R.js";
import {
  y
} from "./chunk-HVKDYDPP.js";
import {
  v
} from "./chunk-6QC7MLLS.js";
import {
  e,
  h,
  p,
  r,
  s,
  t
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/views/3d/support/AsyncWorkerQueue.js
var s7 = class {
  constructor(t5) {
    this.client = t5, this._cancelled = false, this.size = 0, this.duration = 0;
  }
};
var e7 = class {
  constructor(t5) {
    this.typeWorkerQuota = t5, this.tasks = new Array(), this.numWorkers = 0, this.statistics = new r4();
  }
};
var r4 = class {
  constructor() {
    this.requests = 0, this.size = 0, this.duration = 0, this.speed = 0;
  }
};
var i = class {
  constructor(t5, s8, r5, i2) {
    this._workerFunc = t5, this._callbackFunc = s8, this._maxTotalNumWorkers = r5, this._totalNumWorkers = 0, this._clients = i2.map((t6) => new e7(t6));
  }
  destroy() {
    this._clients.length = 0;
  }
  hasQuota(t5) {
    const s8 = this._clients[t5];
    return !!s8 && (this._totalNumWorkers < this._maxTotalNumWorkers || s8.numWorkers + s8.tasks.length < s8.typeWorkerQuota);
  }
  push(t5) {
    const s8 = this._clients[t5.client];
    s8 && (this._totalNumWorkers < this._maxTotalNumWorkers ? (s8.numWorkers++, this._totalNumWorkers++, this._workerFunc(t5, (t6, s9) => this._taskCallback(t6, s9))) : s8.tasks.push(t5));
  }
  cancel(t5) {
    this._taskFinished(t5), t5._cancelled = true;
  }
  _taskFinished(s8) {
    const e8 = this._clients[s8.client];
    this._totalNumWorkers--, e8.numWorkers--, e8.statistics.requests++, e8.statistics.size += s8.size || 0, e8.statistics.duration += s8.duration || 0, e8.statistics.speed = e8.statistics.duration > 0 ? e8.statistics.size / e8.statistics.duration : 0, e6(e8.numWorkers >= 0), this._next();
  }
  _next() {
    for (const t5 of this._clients)
      if (t5 && t5.numWorkers < t5.typeWorkerQuota && this._processQueue(t5))
        return;
    for (const t5 of this._clients)
      if (t5 && this._processQueue(t5))
        return;
  }
  _processQueue(t5) {
    for (; t5.tasks.length > 0; )
      if (this._workerFunc(t5.tasks.shift(), (t6, s8) => this._taskCallback(t6, s8)))
        return t5.numWorkers++, this._totalNumWorkers++, true;
    return false;
  }
  _taskCallback(t5, s8) {
    t5._cancelled || (this._callbackFunc(t5, s8), this._taskFinished(t5));
  }
  getStatsForType(t5) {
    const s8 = this._clients[t5];
    return s8 ? { quota: s8.typeWorkerQuota, workers: s8.numWorkers, queueSize: s8.tasks.length, requestStats: s8.statistics } : null;
  }
  get test() {
    const t5 = this;
    return { set workerFunc(s8) {
      t5._workerFunc = s8;
    } };
  }
};

// node_modules/@arcgis/core/views/3d/support/StreamDataLoader.js
var y3 = class extends m2 {
  constructor() {
    super(...arguments), this._tasks = /* @__PURE__ */ new Map(), this._onLoadQueue = new Array(), this._doneQueue = new Array(), this.updating = false;
  }
  setup(e8, t5, s8) {
    this._loadQueue = new i((e9, t6) => this._startLoading(e9, t6), (e9, t6) => this._doneLoadingCB(e9, t6), e8, t5), s8 && (this._frameTask = s8.registerTask(I.STREAM_DATA_LOADER, this));
  }
  destroy() {
    this._frameTask = h(this._frameTask), this._tasks.forEach((e8) => p(e8.abortController)), this._loadQueue = s(this._loadQueue), this._onLoadQueue = null, this._doneQueue = null, this._tasks = null;
  }
  hasDownloadSlots(e8) {
    return this._loadQueue.hasQuota(e8);
  }
  request(e8, t5, s8, r5 = {}) {
    const o = D2();
    o.__signal = r(r5) ? r5.signal : null;
    const a10 = this._createOrUpdateTask(e8, t5, s8, r5, o);
    return v2(r5, () => this._cancelRequest(a10, o)), o.promise;
  }
  _createTask(e8, t5, s8, r5, o, a10) {
    const n5 = new Q(e8, t5, s8, r5, o);
    return this._updateTask(n5, a10), this._tasks.set(o, n5), 1 === this._tasks.size && this._set("updating", true), this._loadQueue.push(n5), n5;
  }
  _cancelRequest(e8, t5) {
    var _a;
    v(e8.resolvers, t5), t5.reject(a()), 0 === e8.resolvers.length && (e8.status === E2.DOWNLOADING && (e8.status = E2.CANCELLED, this._loadQueue.cancel(e8), (_a = e8.abortController) == null ? void 0 : _a.abort(), e8.request = null, e8.abortController = null), e8.status = E2.CANCELLED, this._tasks.delete(e8.key), 0 === this._tasks.size && this._set("updating", false));
  }
  _updateTask(e8, t5) {
    e8.resolvers.push(t5);
  }
  _createOrUpdateTask(e8, t5, s8, r5, o) {
    const a10 = T(r(r5) && r5.uid || e8, t5, s8), n5 = this._tasks.get(a10);
    return n5 ? (this._updateTask(n5, o), n5) : this._createTask(e8, r5, t5, s8, a10, o);
  }
  _doneLoadingCB(e8, t5) {
    this._loadQueue && (e6(e8.status === E2.DOWNLOADING), e8.status = E2.DOWNLOADED, this._frameTask ? this._doneQueue.push({ task: e8, err: t5 }) : this._doneLoading(e8, t5));
  }
  get running() {
    return this._doneQueue.length > 0 || this._onLoadQueue.length > 0;
  }
  runTask(e8) {
    for (; !e8.done && this._onLoadQueue.length > 0; ) {
      const t5 = this._onLoadQueue.shift();
      f(t5.task.abortController), t5.task.abortController = null, t5.callback(t5.task), e8.madeProgress();
    }
    for (; !e8.done && this._doneQueue.length > 0; ) {
      const t5 = this._doneQueue.shift();
      t5.task.status !== E2.DOWNLOADED && (t5.err = t5.err || a()), this._doneLoading(t5.task, t5.err), e8.madeProgress();
    }
  }
  _doneLoading(e8, t5) {
    if (t5 && !j2(t5) && e8.numRetries > 0)
      return --e8.numRetries, void this._loadQueue.push(e8);
    let s8 = e8.result instanceof HTMLImageElement ? 0 : e8.resolvers.length;
    for (const r5 of e8.resolvers)
      if (t5)
        j2(t5) ? r5.reject(t5) : r5.reject(new s3("stream-data-loader:request-error", `Failed to request resource at '${e8.url}'. ${t5}`, { url: e8.url, error: t5 }));
      else {
        --s8;
        const t6 = s8 <= 0 ? e8.result : y(e8.result);
        r5.resolve(t6);
      }
    this._tasks.delete(e8.key), 0 === this._tasks.size && this._set("updating", false);
  }
  _startLoading(e8, s8) {
    if (e8.status === E2.CANCELLED)
      return false;
    let r5, o;
    switch (e8.startTime = performance.now(), e8.status = E2.DOWNLOADING, e8.docType) {
      case "binary":
        o = "array-buffer", r5 = 0;
        break;
      case "image":
        o = "image";
        break;
      case "image+type":
        o = "array-buffer";
        break;
      default:
        o = "json";
    }
    e8.abortController = new AbortController();
    const a10 = e8.abortController.signal;
    e8.request = U(e8.url, { ...e8.options, responseType: o, timeout: r5, signal: a10 });
    let n5 = () => {
    };
    const i2 = (t5) => {
      e8.duration = performance.now() - e8.startTime, e8.size = t5 instanceof ArrayBuffer ? t5.byteLength : e8.size || 0, e8.result = t5, this._frameTask ? this._onLoadQueue.push({ callback: s8, task: e8 }) : (e8.abortController = null, s8(e8));
    }, u6 = (t5) => {
      e8.status === E2.DOWNLOADING && s8(e8, t5), n5();
    };
    return "image+type" !== e8.docType ? (e8.request.then((e9) => i2(e9.data), u6), true) : (e8.request.then((s9) => {
      const l4 = s9.data, h6 = A2(l4);
      if (o = "image", e8.size = l4.byteLength, "unknown" === h6)
        return e8.request = U(e8.url, { responseType: o, timeout: r5, signal: a10 }), void e8.request.then((e9) => i2(e9.data), u6);
      const c7 = new Blob([l4], { type: h6 }), d2 = window.URL.createObjectURL(c7);
      n5 = () => window.URL.revokeObjectURL(d2), e8.request = U(d2, { responseType: o, timeout: r5, signal: a10 }), e8.request.then((e9) => i2(new O2(e9.data, h6, n5)), u6);
    }, u6), true);
  }
  get test() {
    return { loadQueue: this._loadQueue };
  }
};
e3([y2({ readOnly: true })], y3.prototype, "updating", void 0), y3 = e3([n2("esri.views.3d.support.StreamDataLoader")], y3);
var b2 = { numRetries: 0 };
function A2(e8) {
  if (e8.byteLength < 2)
    return "unknown";
  const t5 = new Uint8Array(e8, 0, e8.byteLength);
  return 137 === t5[0] && 80 === t5[1] ? "image/png" : 71 === t5[0] && 73 === t5[1] ? "image/gif" : 66 === t5[0] && 77 === t5[1] ? "image/bmp" : 255 === t5[0] && 216 === t5[1] ? "image/jpeg" : "unknown";
}
var O2 = class {
  constructor(e8, t5, s8) {
    this.image = e8, this.type = t5, this.release = s8;
  }
  get isOpaque() {
    return "image/jpeg" === this.type;
  }
};
var Q = class extends s7 {
  constructor(e8, t5, s8, r5, o) {
    super(r5), this.url = e8, this.options = t5, this.docType = s8, this.key = o, this.result = null, this.status = E2.QUEUED, this.request = null, this.abortController = null, this.resolvers = new Array(), this.startTime = 0, this.numRetries = b2.numRetries;
  }
};
function T(e8, t5, s8) {
  return `${e8}:${t5}:${s8}`;
}
var E2;
!function(e8) {
  e8[e8.QUEUED = 1] = "QUEUED", e8[e8.DOWNLOADING = 2] = "DOWNLOADING", e8[e8.DOWNLOADED = 3] = "DOWNLOADED", e8[e8.CANCELLED = 4] = "CANCELLED";
}(E2 || (E2 = {}));

// node_modules/@arcgis/core/views/3d/terrain/TilingScheme.js
var v3 = 12;
var M2 = class {
  constructor(e8) {
    const i2 = M2.checkUnsupported(e8);
    if (r(i2))
      throw i2;
    const t5 = e(e8);
    this.spatialReference = t5.spatialReference, this._isWebMercator = this.spatialReference.isWebMercator, this._isGCS = Re(this.spatialReference) || P2(this.spatialReference) || s4(this.spatialReference), this.origin = [t5.origin.x, t5.origin.y], this.pixelSize = t5.size[0], this.dpi = t5.dpi;
    const s8 = t5.lods.reduce((e9, i3, t6) => (i3.level < e9.min && (e9.min = i3.level, e9.minIndex = t6), e9.max = Math.max(e9.max, i3.level), e9), { min: 1 / 0, minIndex: 0, max: -1 / 0 }), l4 = t5.lods[s8.minIndex], o = 2 ** l4.level;
    let a10 = l4.resolution * o, c7 = l4.scale * o;
    this.levels = new Array(s8.max + 1);
    for (let r5 = 0; r5 < this.levels.length; r5++)
      this.levels[r5] = { resolution: a10, scale: c7, tileSize: [a10 * t5.size[0], a10 * t5.size[1]] }, a10 /= 2, c7 /= 2;
  }
  clone() {
    return new M2(this.toTileInfo());
  }
  toTileInfo() {
    return new j5({ dpi: this.dpi, origin: { x: this.origin[0], y: this.origin[1], spatialReference: this.spatialReference }, size: [this.pixelSize, this.pixelSize], spatialReference: this.spatialReference, lods: this.levels.map((e8, i2) => ({ level: i2, scale: e8.scale, resolution: e8.resolution })) });
  }
  getExtent(e8, i2, t5, s8) {
    const r5 = this.levels[e8], l4 = r5.tileSize[0], n5 = r5.tileSize[1];
    s8[0] = this.origin[0] + t5 * l4, s8[2] = this.origin[0] + (t5 + 1) * l4, s8[3] = this.origin[1] - i2 * n5, s8[1] = this.origin[1] - (i2 + 1) * n5;
  }
  convertExtentToRadians(e8, t5) {
    this._isWebMercator ? (t5[0] = f2(e8[0]), t5[1] = c(e8[1]), t5[2] = f2(e8[2]), t5[3] = c(e8[3])) : this._isGCS && (t5[0] = m(e8[0]), t5[1] = m(e8[1]), t5[2] = m(e8[2]), t5[3] = m(e8[3]));
  }
  getExtentGeometry(e8, i2, t5, s8 = new w()) {
    return this.getExtent(e8, i2, t5, w2), s8.spatialReference = this.spatialReference, s8.xmin = w2[0], s8.ymin = w2[1], s8.xmax = w2[2], s8.ymax = w2[3], s8.zmin = void 0, s8.zmax = void 0, s8;
  }
  ensureMaxLod(e8) {
    if (null == e8)
      return false;
    let i2 = false;
    for (; this.levels.length <= e8; ) {
      const e9 = this.levels[this.levels.length - 1], t5 = e9.resolution / 2;
      this.levels.push({ resolution: t5, scale: e9.scale / 2, tileSize: [t5 * this.pixelSize, t5 * this.pixelSize] }), i2 = true;
    }
    return i2;
  }
  capMaxLod(e8) {
    this.levels.length > e8 + 1 && (this.levels.length = e8 + 1);
  }
  getMaxLod() {
    return this.levels.length - 1;
  }
  scaleAtLevel(e8) {
    return this.levels[0].scale / 2 ** e8;
  }
  levelAtScale(e8) {
    const i2 = this.levels[0].scale;
    return e8 >= i2 ? 0 : Math.log(i2 / e8) * Math.LOG2E;
  }
  resolutionAtLevel(e8) {
    return this.levels[0].resolution / 2 ** e8;
  }
  compatibleWith(e8) {
    if (!(e8 instanceof M2)) {
      if (M2.checkUnsupported(e8))
        return false;
      e8 = new M2(e8);
    }
    if (!e8.spatialReference.equals(this.spatialReference))
      return false;
    if (e8.pixelSize !== this.pixelSize)
      return false;
    const i2 = Math.min(this.levels.length, e8.levels.length) - 1, s8 = this.levels[i2].resolution;
    let r5 = 0.5 * s8;
    if (!g2(e8.origin[0], this.origin[0], r5) || !g2(e8.origin[1], this.origin[1], r5))
      return false;
    return r5 = 0.5 * s8 / 2 ** i2 / this.pixelSize * v3, g2(s8, e8.levels[i2].resolution, r5);
  }
  rootTilesInExtent(e8, i2 = null, t5 = 1 / 0) {
    const s8 = new Array(), n5 = this.levels[0].tileSize;
    if (t(e8) || 0 === n5[0] || 0 === n5[1])
      return s8;
    M2.computeRowColExtent(e8, n5, this.origin, w2);
    let o = w2[1], a10 = w2[3], h6 = w2[0], c7 = w2[2];
    const m8 = c7 - h6, u6 = a10 - o;
    if (m8 * u6 > t5) {
      const e9 = Math.floor(Math.sqrt(t5));
      u6 > e9 && (o = o + Math.floor(0.5 * u6) - Math.floor(0.5 * e9), a10 = o + e9), m8 > e9 && (h6 = h6 + Math.floor(0.5 * m8) - Math.floor(0.5 * e9), c7 = h6 + e9);
    }
    for (let r5 = o; r5 < a10; r5++)
      for (let e9 = h6; e9 < c7; e9++)
        s8.push([0, r5, e9]);
    return r(i2) && (i2[0] = this.origin[0] + h6 * n5[0], i2[1] = this.origin[1] - a10 * n5[1], i2[2] = this.origin[0] + c7 * n5[0], i2[3] = this.origin[1] - o * n5[1]), s8;
  }
  static computeRowColExtent(e8, i2, t5, s8) {
    const r5 = 1e-3 * (e8[2] - e8[0] + (e8[3] - e8[1]));
    s8[0] = Math.max(0, Math.floor((e8[0] + r5 - t5[0]) / i2[0])), s8[2] = Math.max(0, Math.ceil((e8[2] - r5 - t5[0]) / i2[0])), s8[1] = Math.max(0, Math.floor((t5[1] - e8[3] + r5) / i2[1])), s8[3] = Math.max(0, Math.ceil((t5[1] - e8[1] - r5) / i2[1]));
  }
  static isPowerOfTwo(e8) {
    const i2 = e8.lods, t5 = i2[0].resolution * 2 ** i2[0].level;
    return !i2.some((e9) => !j(e9.resolution, t5 / 2 ** e9.level));
  }
  static hasGapInLevels(e8) {
    const i2 = e8.lods.map((e9) => e9.level);
    i2.sort((e9, i3) => e9 - i3);
    for (let t5 = 1; t5 < i2.length; t5++)
      if (i2[t5] !== i2[0] + t5)
        return true;
    return false;
  }
  static tileSizeSupported(e8) {
    const i2 = e8.size[1];
    return i2 === e8.size[0] && 0 == (i2 & i2 - 1) && i2 >= 128 && i2 <= 512;
  }
  static hasOriginPerLODs(e8) {
    const i2 = e8.origin;
    return e8.lods.some((e9) => null != e9.origin && (e9.origin[0] !== i2.x || e9.origin[1] !== i2.y));
  }
  static getMissingTileInfoError() {
    return new s3("tilingscheme:tile-info-missing", "Tiling scheme must have tiling information");
  }
  static checkUnsupported(i2) {
    return t(i2) ? d() : i2.lods.length < 1 ? new s3("tilingscheme:generic", "Tiling scheme must have at least one level") : M2.isPowerOfTwo(i2) ? M2.hasGapInLevels(i2) ? new s3("tilingscheme:gaps", "Tiling scheme levels must not have gaps between min and max level") : M2.tileSizeSupported(i2) ? M2.hasOriginPerLODs(i2) ? new s3("tilingscheme:multiple-origin", "Tiling scheme levels must not have their own origin") : null : new s3("tilingscheme:tile-size", "Tiles must be square and size must be one of [128, 256, 512]") : new s3("tilingscheme:power-of-two", "Tiling scheme must be power of two");
  }
  static fromExtent(e8, i2) {
    const t5 = e8[2] - e8[0], s8 = e8[3] - e8[1], r5 = $(i2), l4 = 1.2 * Math.max(t5, s8), n5 = 256, a10 = 96, h6 = 0.0254, c7 = new M2(new j5({ size: [n5, n5], origin: { x: e8[0] - 0.5 * (l4 - t5), y: e8[3] + 0.5 * (l4 - s8) }, lods: [{ level: 0, resolution: l4 / n5, scale: 1 / (n5 / a10 * h6 / (l4 * r5)) }], spatialReference: i2 }));
    return c7.ensureMaxLod(20), c7;
  }
  static makeWebMercatorAuxiliarySphere(e8) {
    const i2 = new M2(M2.WebMercatorAuxiliarySphereTileInfo);
    return i2.ensureMaxLod(e8), i2;
  }
  static makeGCSWithTileSize(e8, i2 = 256, t5 = 16) {
    const s8 = 256 / i2, r5 = new M2(new j5({ size: [i2, i2], origin: { x: -180, y: 90, spatialReference: e8 }, spatialReference: e8, lods: [{ level: 0, resolution: 0.703125 * s8, scale: 295497598570834e-6 * s8 }] }));
    return r5.ensureMaxLod(t5), r5;
  }
  get test() {
    return { isWebMercator: this._isWebMercator, isGCS: this._isGCS };
  }
};
function d() {
  return new s3("tilingscheme:tile-info-missing", "Tiling scheme must have tiling information");
}
M2.WebMercatorAuxiliarySphereTileInfo = new j5({ size: [256, 256], origin: { x: -20037508342787e-6, y: 20037508342787e-6, spatialReference: k.WebMercator }, spatialReference: k.WebMercator, lods: [{ level: 0, resolution: 156543.03392800014, scale: 591657527591555e-6 }] }), M2.WebMercatorAuxiliarySphere = M2.makeWebMercatorAuxiliarySphere(19);
var w2 = u2();

// node_modules/@arcgis/core/views/3d/terrain/TerrainConst.js
var a6 = 64;
var l3 = A(D / 10);
var m5 = u2();
M2.WebMercatorAuxiliarySphere.getExtent(0, 0, 0, m5);
var p2 = u2([-180, -90, 180, 90]);

// node_modules/@arcgis/core/chunks/terrainUtilsPlanar.js
var M3 = n();
var x2 = n();
var S = n();
var j7 = n();
function v4(e8, o, r5 = 0) {
  const n5 = e8.extent;
  if (t(n5))
    return false;
  if (0 === r5)
    return b(n5, o);
  const i2 = Math.min(n5[2] - n5[0], n5[3] - n5[1]);
  return q(n5, o, r5 * i2);
}
function y4(e8, t5, o, l4) {
  r2(M3, o), M3[l4] = t5[l4];
  const c7 = e2(M3, M3, t5), f6 = e2(x2, e8, t5), u6 = P(f6, c7), m8 = P(c7, c7);
  let p3;
  p3 = u6 <= 0 ? t5 : m8 <= u6 ? o : u(M3, t5, g(c7, c7, u6 / m8));
  const h6 = e2(M3, e8, p3);
  return Math.PI / 2 - Math.atan(h6[2] / Math.sqrt(h6[0] * h6[0] + h6[1] * h6[1]));
}
function T2(e8, o, r5) {
  const n5 = e8.extent;
  if (t(n5))
    return 0;
  S[0] = n5[0], S[1] = n5[1], S[2] = r5, j7[0] = n5[2], j7[1] = n5[3], j7[2] = r5;
  let i2 = 1 / 0, s8 = 1 / 0;
  return o[0] < S[0] ? i2 = y4(o, S, j7, 0) : o[0] > j7[0] && (i2 = y4(o, j7, S, 0)), o[1] < S[1] ? s8 = y4(o, S, j7, 1) : o[1] > j7[1] && (s8 = y4(o, j7, S, 1)), Math.min(i2, s8);
}
function w3(r5, n5, i2) {
  if (t(r5))
    return d();
  if (r5.spatialReference.isGeographic && !Re(r5.spatialReference))
    return new s3("tilingscheme:local-unsupported-spatial-reference", "The tiling scheme spatial reference is not supported in local scenes");
  const s8 = M2.checkUnsupported(r5);
  if (r(s8))
    return s8;
  if (t(i2))
    return new s3("tilingscheme:extent-not-exist", "The layer does not provide a layer extent.");
  const a10 = R(r5, i2);
  if (a10)
    return a10;
  const l4 = r5.spatialReference;
  return r(n5) && !(l4.equals(n5) || n5.isWGS84 && l4.isWebMercator) ? new s3("tilingscheme:spatial-reference-mismatch", "The tiling scheme does not match the spatial reference of the local scene") : null;
}
function R(t5, o) {
  const r5 = t5.lods, n5 = r5[0].resolution * 2 ** r5[0].level, i2 = [n5 * t5.size[0], n5 * t5.size[1]], s8 = [t5.origin.x, t5.origin.y], a10 = c3(o), l4 = u2();
  M2.computeRowColExtent(a10, i2, s8, l4);
  const c7 = (l4[2] - l4[0]) * (l4[3] - l4[1]);
  if (c7 > a6) {
    const o2 = r5[0].scale * 2 ** r5[0].level;
    let i3 = Math.max((a10[3] - a10[1]) / t5.size[1], (a10[2] - a10[0]) / t5.size[0]) * o2 / n5;
    const s9 = Math.floor(Math.log(i3) / Math.log(10));
    return i3 = Math.ceil(i3 / 10 ** s9) * 10 ** s9, new s3("tilingscheme:too-many-root-tiles", "Scale of level 0 of the tiling scheme (1:" + Math.floor(o2).toLocaleString() + ") is too large for the layer's extent. Suggested scale: 1:" + i3.toLocaleString() + ".", { level0Scale: o2, suggestedLevel0Scale: i3, requiredNumRootTiles: c7, allowedNumRootTiles: a6 });
  }
  return null;
}
var b3 = Object.freeze(Object.defineProperty({ __proto__: null, isInsideExtent: v4, tiltToExtentEdge: T2, checkIfTileInfoSupportedForViewSR: w3 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/terrainUtilsSpherical.js
function c4() {
  return true;
}
function a7() {
  return 0;
}
function m6(c7, a10) {
  if (t(c7))
    return d();
  const m8 = c7.lods.length - 1, h6 = c7.spatialReference, p3 = Re(h6) || P2(h6) || s4(h6);
  if (h6.isWebMercator) {
    if (!M2.makeWebMercatorAuxiliarySphere(m8).compatibleWith(c7))
      return new s3("tilingscheme:incompatible-global-web-mercator", "The tiling scheme is not compatible with the ArcGIS Online Web Mercator tiling scheme");
  } else {
    if (!p3)
      return new s3("tilingscheme:global-unsupported-spatial-reference", "The tiling scheme spatial reference is not supported in global scenes");
    if (!M2.makeGCSWithTileSize(c7.spatialReference, c7.size[0], m8).compatibleWith(c7))
      return c7.spatialReference.isWGS84 ? new s3("tilingscheme:incompatible-global-wgs84", "The tiling scheme is not compatible with the ArcGIS Online WGS84 tiling scheme") : new s3("tilingscheme:incompatible-global", "The tiling scheme is not compatible with the ArcGIS Online tiling scheme");
  }
  return r(a10) && !c7.spatialReference.equals(a10) ? new s3("tilingscheme:spatial-reference-mismatch", "The tiling scheme does not match the spatial reference of the global scene") : void 0;
}
var h4 = Object.freeze(Object.defineProperty({ __proto__: null, isInsideExtent: c4, tiltToExtentEdge: a7, checkIfTileInfoSupportedForViewSR: m6 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/views/3d/terrain/terrainUtils.js
var a8 = { [l2.Global]: h4, [l2.Local]: b3 };
function b4(t5, n5, e8, r5) {
  return a8[r5].checkIfTileInfoSupportedForViewSR(t5, e8, n5);
}
function M4(e8, r5, i2) {
  const l4 = c2(e8);
  if (r(l4)) {
    if (!j4.isCollection(l4))
      return { tileInfo: l4.tileInfo, fullExtent: l4.fullExtent };
    {
      const t5 = l4.find((t6) => null == b4(t6.tileInfo, t6.fullExtent, r5, i2));
      if (t5)
        return { tileInfo: t5.tileInfo, fullExtent: t5.fullExtent };
    }
  }
  return { tileInfo: null, fullExtent: null };
}
var Y = [O.NORTH, O.EAST, O.SOUTH, O.WEST];
var Z = [O.NORTH_EAST, O.SOUTH_EAST, O.SOUTH_WEST, O.NORTH_WEST];

// node_modules/@arcgis/core/widgets/BasemapGallery/support/basemapCompatibilityUtils.js
async function f4(e8, t5 = {}) {
  await y5(e8, t5), f(t5);
}
async function u4(e8, t5 = {}) {
  const { basemap: a10, view: n5 } = e8;
  if (f(t5), "spatialReferenceLocked" in n5 && !n5.spatialReferenceLocked)
    return;
  if (await a10.load(t5), f(t5), 0 === a10.baseLayers.length)
    return;
  const s8 = a10.baseLayers.getItemAt(0);
  if (!t4(s8))
    return;
  if (a10.spatialReference) {
    if (n5.spatialReference.equals(a10.spatialReference))
      return;
    w4();
  }
  await s8.load(t5), f(t5);
  const o = (("supportedSpatialReferences" in s8 ? s8.supportedSpatialReferences : null) || ["tileInfo" in s8 ? s8.tileInfo.spatialReference : null]).filter(Boolean);
  0 !== o.length && o.every((e9) => !n5.spatialReference.equals(e9)) && w4();
}
function w4() {
  throw new s3("basemap-compatibility:incompatible-spatial-reference", "Basemap spatial reference is not compatible with the view");
}
async function y5(t5, a10) {
  const { basemap: i2, view: r5 } = t5;
  if (await i2.load(a10), 0 === i2.baseLayers.length)
    return;
  const s8 = i2.baseLayers.concat(i2.referenceLayers).toArray().filter((e8) => !e5(e8)).map((t6) => new s3("basemap-compatibility:unsupported-basemap-layer-type", "Unsupported basemap layer type ${operationalLayerType}", { layer: t6, operationalLayerType: t6.operationalLayerType || "unknown" }));
  if (s8.length)
    throw s8[0];
  const o = i2.baseLayers.getItemAt(0);
  if (e5(o)) {
    try {
      await o.load(a10);
    } catch (l4) {
      const t6 = "basemap-compatibility:unknown-error", a11 = "Unknown basemap compatibility error", { name: i3 = t6, message: r6 = a11, details: n5 } = l4;
      throw new s3(i3, r6, n5);
    }
    b5(o, r5);
  }
}
function b5(i2, r5) {
  const n5 = r5.state.viewingMode;
  if (!n5)
    return;
  let f6, u6;
  if ("wmts" === (i2 == null ? void 0 : i2.type)) {
    const a10 = M4(i2, r5.spatialReference, n5);
    if (t(a10.tileInfo))
      throw new s3("basemapgalleryitem:tiling-scheme-incompatible", "Basemap tiling scheme is incompatible with the view");
    f6 = a10.tileInfo, u6 = a10.fullExtent;
  } else
    f6 = i2.tileInfo, u6 = i2.fullExtent;
  if (t(f6))
    return;
  if (!r3(f6.spatialReference, n5))
    throw new s3(`basemapgalleryitem:spatial-reference-unsupported-${a5(n5)}`, `Basemap spatial reference is unsupported in ${a5(n5)} mode`);
  const w5 = f6.spatialReference.isGeographic, y7 = "vector-tile" === (i2 == null ? void 0 : i2.type) ? f6.getOrCreateCompatible(256, w5 ? 1 : 2) : null;
  if (n5 === l2.Global) {
    let t5 = b4(f6, u6, null, n5);
    if (t5 && "vector-tile" === (i2 == null ? void 0 : i2.type) && r(u6) && y7 && !b4(y7, u6, null, n5) && (t5 = null), t5) {
      const a10 = f6.spatialReference.isWebMercator ? "web-mercator" : "wgs84";
      throw new s3(`basemapgalleryitem:tiling-scheme-unsupported-${a10}-global`, "Basemap tiling scheme is unsupported in global mode", { error: t5 });
    }
  } else if (M2.checkUnsupported(f6))
    throw new s3("basemapgalleryitem:tiling-scheme-unsupported-local", "Basemap tiling scheme is unsupported in local mode");
  const b8 = r5.get("basemapTerrain.tilingScheme");
  if (b8 && !b8.compatibleWith(f6) && ("vector-tile" !== (i2 == null ? void 0 : i2.type) || !y7 || !b8.compatibleWith(y7)))
    throw new s3("basemapgalleryitem:tiling-scheme-incompatible", "Basemap tiling scheme is incompatible with the view");
}

// node_modules/@arcgis/core/widgets/BasemapGallery/support/BasemapGalleryItem.js
var c5 = class extends s6(a4(m2)) {
  constructor(e8) {
    super(e8), this.compatibilityFunction = null, this.error = null, this.state = "loading", this.view = null;
  }
  initialize() {
    const e8 = () => this.refresh();
    this.handles.add([l(() => {
      var _a;
      return (_a = this.basemap) == null ? void 0 : _a.loadStatus;
    }, e8), l(() => this.compatibilityFunction, e8), l(() => {
      var _a;
      return this.view && "basemapTerrain" in this.view && ((_a = this.view.basemapTerrain) == null ? void 0 : _a.tilingScheme);
    }, e8), l(() => {
      var _a;
      return (_a = this.view) == null ? void 0 : _a.ready;
    }, e8), l(() => {
      var _a;
      return (_a = this.view) == null ? void 0 : _a.spatialReference;
    }, e8)]), this.refresh();
  }
  destroy() {
    this._cancelRefresh(), this.basemap = null, this.compatibilityFunction = null, this.view = null;
  }
  get _spatialReferenceTask() {
    return h3(this.view, this.basemap);
  }
  set basemap(e8) {
    const t5 = this._get("basemap");
    t5 && t5.cancelLoad(), e8 && e8.load().catch(() => {
    }), this._set("basemap", e8);
  }
  get spatialReference() {
    return this._spatialReferenceTask.spatialReference;
  }
  refresh() {
    var _a;
    this._cancelRefresh(), this._set("state", "loading");
    const e8 = (_a = this.basemap) == null ? void 0 : _a.loadStatus;
    if ("loaded" !== e8 && "failed" !== e8)
      return;
    if (!this.compatibilityFunction)
      return void ("loaded" === e8 ? (this._set("state", "ready"), this._set("error", null)) : (this._set("state", "error"), this._set("error", this.basemap.loadError)));
    const t5 = new AbortController(), { signal: s8 } = t5;
    this.compatibilityFunction(this, { signal: s8 }).then(() => j3(() => !this._spatialReferenceTask.updating, s8)).then(() => {
      this._set("state", "ready"), this._set("error", null);
    }).catch((e9) => {
      j2(e9) || (this._set("state", "error"), this._set("error", e9));
    }), this._refreshController = t5;
  }
  _cancelRefresh() {
    this._refreshController && (this._refreshController.abort(), this._refreshController = null);
  }
};
e3([y2({ readOnly: true })], c5.prototype, "_spatialReferenceTask", null), e3([y2()], c5.prototype, "basemap", null), e3([y2()], c5.prototype, "compatibilityFunction", void 0), e3([y2({ readOnly: true })], c5.prototype, "error", void 0), e3([y2({ readOnly: true })], c5.prototype, "spatialReference", null), e3([y2({ readOnly: true })], c5.prototype, "state", void 0), e3([y2()], c5.prototype, "view", void 0), c5 = e3([n2("esri.widgets.BasemapGallery.support.BasemapGalleryItem")], c5);
var h5 = c5;

// node_modules/@arcgis/core/widgets/BasemapGallery/support/LocalBasemapsSource.js
var a9 = j4.ofType(x);
var c6 = class extends m2 {
  constructor(r5) {
    super(r5), this.basemaps = new a9();
  }
  get state() {
    return "ready";
  }
  refresh() {
  }
};
e3([y2({ type: a9 })], c6.prototype, "basemaps", void 0), e3([y2({ readOnly: true })], c6.prototype, "state", null), c6 = e3([n2("esri.widgets.BasemapGallery.support.LocalBasemapsSource")], c6);
var m7 = c6;

// node_modules/@arcgis/core/widgets/BasemapGallery/support/PortalBasemapsSource.js
var f5 = j4.ofType(x);
var y6 = class extends m4.LoadableMixin(m3(m7)) {
  constructor(t5) {
    super(t5), this._handles = new t2(), this.basemaps = new f5(), this.filterFunction = null, this.portal = j6.getDefault(), this.query = null, this.updateBasemapsCallback = null;
  }
  initialize() {
    this._handles.add([l(() => {
      var _a, _b;
      return [this.filterFunction, this.loadStatus, (_a = this.portal) == null ? void 0 : _a.basemapGalleryGroupQuery, (_b = this.portal) == null ? void 0 : _b.user, this.query, this.updateBasemapsCallback];
    }, () => this.refresh(), h2)]);
  }
  destroy() {
    this._handles.destroy(), this._handles = null, this.filterFunction = null, this.portal = null;
  }
  get state() {
    return "not-loaded" === this.loadStatus ? "not-loaded" : "loading" === this.loadStatus || this._lastPortalBasemapFetchController ? "loading" : "ready";
  }
  load(t5) {
    return this.addResolvingPromise(this.portal.load(t5)), this.notifyChange("state"), Promise.resolve(this);
  }
  async refresh() {
    if ("ready" !== this.state)
      return;
    this._lastPortalBasemapFetchController && (this._lastPortalBasemapFetchController.abort(), this._lastPortalBasemapFetchController = null);
    const t5 = this.portal, s8 = new AbortController();
    this._lastPortalBasemapFetchController = s8, this.notifyChange("state");
    try {
      const e8 = await t5.fetchBasemaps(this._toQueryString(this.query), s8);
      this._updateBasemaps(e8);
    } catch (e8) {
      if (j2(e8))
        throw e8;
      s2.getLogger(this.declaredClass).warn(new s3("basemap-source:fetch-basemaps-error", "Could not fetch basemaps from portal.", { error: e8 })), this._updateBasemaps();
    }
    this._lastPortalBasemapFetchController = null, this.notifyChange("state");
  }
  _toQueryString(t5) {
    return t5 && "string" != typeof t5 ? Object.keys(t5).map((s8) => `${s8}:${t5[s8]}`).join(" AND ") : t5;
  }
  _updateBasemaps(t5 = []) {
    let s8 = this.filterFunction ? t5.filter(this.filterFunction) : t5;
    s8 = this.updateBasemapsCallback ? this.updateBasemapsCallback(s8) : s8, this.basemaps.removeAll(), this.basemaps.addMany(s8);
  }
};
e3([y2({ readOnly: true, type: f5 })], y6.prototype, "basemaps", void 0), e3([y2()], y6.prototype, "filterFunction", void 0), e3([y2({ type: j6 })], y6.prototype, "portal", void 0), e3([y2()], y6.prototype, "query", void 0), e3([y2({ readOnly: true })], y6.prototype, "state", null), e3([y2()], y6.prototype, "updateBasemapsCallback", void 0), y6 = e3([n2("esri.widgets.BasemapGallery.support.PortalBasemapsSource")], y6);
var b6 = y6;

// node_modules/@arcgis/core/widgets/BasemapGallery/BasemapGalleryViewModel.js
var g3 = j4.ofType(h5);
function B(e8) {
  return e8 && "esri.portal.Portal" === e8.declaredClass;
}
function _(e8) {
  return e8 && !(e8 instanceof b6) && (!!e8.portal || !!e8.query);
}
function I2(e8) {
  return e8 && "basemaps" in e8 && "state" in e8 && "refresh" in e8;
}
var R2 = class extends a4(m4) {
  constructor(e8) {
    super(e8), this._loadingProjectionEngine = false, this.items = new g3(), this.source = new b6(), this.view = null;
  }
  initialize() {
    const e8 = () => this._recreateItems();
    this.handles.add([l(() => "ready" === this.state ? this.compatibilityFunction : null, () => this._updateItems()), a2(() => {
      var _a;
      return (_a = this.source) == null ? void 0 : _a.basemaps;
    }, "change", e8, { onListenerAdd: e8 })]);
  }
  get activeBasemap() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this.view) == null ? void 0 : _a.map) == null ? void 0 : _b.basemap) != null ? _c : null;
  }
  set activeBasemap(e8) {
    var _a, _b;
    if (!this.view.map)
      return;
    const i2 = "string" == typeof e8 ? x.fromId(e8) : e8;
    if (!i2 || !this.view.ready)
      return this.view.map.basemap = i2, void this._clearOverride("activeBasemap");
    const s8 = i2.spatialReference || ((_b = (_a = this.items) == null ? void 0 : _a.find((e9) => this.basemapEquals(i2, e9.basemap))) == null ? void 0 : _b.spatialReference);
    if (s8 && "spatialReferenceLocked" in this.view && !this.view.spatialReferenceLocked) {
      const t5 = this.view.spatialReference;
      if (r(s8) && !E(t5, s8) && !An(this.view.spatialReference, s8) && !en())
        return this._override("activeBasemap", i2), this._loadingProjectionEngine = true, void tn().then(() => {
          this._get("activeBasemap") === e8 && (this.view.map.basemap = e8, this.view.spatialReference = s8, this._clearOverride("activeBasemap"));
        }, () => {
        }).then(() => {
          this._loadingProjectionEngine = false;
        });
      this.view.map.basemap = i2, this._clearOverride("activeBasemap"), r(s8) && !E(this.view.spatialReference, s8) && (this.view.spatialReference = s8);
    } else
      this.view.map.basemap = i2, this._clearOverride("activeBasemap");
  }
  get activeBasemapIndex() {
    const { state: e8, items: t5, activeBasemap: i2 } = this;
    if ("ready" !== e8)
      return -1;
    const s8 = t5.findIndex((e9) => e9.basemap === i2);
    return -1 === s8 ? t5.findIndex((e9) => this.basemapEquals(e9.basemap, i2)) : s8;
  }
  get compatibilityFunction() {
    var _a;
    return "3d" === ((_a = this.view) == null ? void 0 : _a.type) ? f4 : u4;
  }
  set compatibilityFunction(e8) {
    this._overrideIfSome("compatibilityFunction", e8);
  }
  castSource(e8) {
    return Array.isArray(e8) || j4.isCollection(e8) ? new m7({ basemaps: e8 }) : B(e8) ? new b6({ portal: e8 }) : _(e8) ? new b6(e8) : I2(e8) ? e8 : null;
  }
  get state() {
    var _a;
    return ((_a = this.view) == null ? void 0 : _a.ready) && this.source ? this._loadingProjectionEngine ? "loading" : "ready" : "disabled";
  }
  basemapEquals(e8, t5) {
    return L(e8, t5);
  }
  refresh() {
    this._recreateItems();
  }
  load(e8) {
    return this.addResolvingPromise(m4.isLoadable(this.source) ? this.source.load(e8) : null), Promise.resolve(this);
  }
  _recreateItems() {
    var _a;
    const e8 = (_a = this.source) == null ? void 0 : _a.basemaps, { view: t5, compatibilityFunction: i2 } = this;
    this.items.removeAll().forEach((e9) => e9.destroy()), e8 && this.items.addMany(e8.map((e9) => new h5({ basemap: e9, compatibilityFunction: i2, view: t5 })));
  }
  _updateItems() {
    for (const e8 of this.items)
      e8.compatibilityFunction = this.compatibilityFunction, e8.view = this.view;
  }
};
e3([y2()], R2.prototype, "_loadingProjectionEngine", void 0), e3([y2()], R2.prototype, "activeBasemap", null), e3([y2({ readOnly: true })], R2.prototype, "activeBasemapIndex", null), e3([y2()], R2.prototype, "compatibilityFunction", null), e3([y2({ readOnly: true, type: g3 })], R2.prototype, "items", void 0), e3([y2()], R2.prototype, "source", void 0), e3([s5("source")], R2.prototype, "castSource", null), e3([y2({ readOnly: true })], R2.prototype, "state", null), e3([y2()], R2.prototype, "view", void 0), R2 = e3([n2("esri.widgets.BasemapGallery.BasemapGalleryViewModel")], R2);
var E3 = R2;

// node_modules/@arcgis/core/widgets/BasemapGallery.js
var g4 = { base: "esri-basemap-gallery esri-widget esri-widget--panel-height-only", sourceLoading: "esri-basemap-gallery--source-loading", loader: "esri-basemap-gallery__loader", item: "esri-basemap-gallery__item", itemContainer: "esri-basemap-gallery__item-container", itemTitle: "esri-basemap-gallery__item-title", itemThumbnail: "esri-basemap-gallery__item-thumbnail", selectedItem: "esri-basemap-gallery__item--selected", itemError: "esri-basemap-gallery__item--error", emptyMessage: "esri-widget__content--empty", widgetIcon: "esri-icon-basemap", disabled: "esri-disabled", loaderAnimation: "esri-widget__loader-animation" };
var u5 = class extends M {
  constructor(e8, s8) {
    super(e8, s8), this._handles = new t2(), this._focusBasemapItemEnabled = false, this.disabled = false, this.headingLevel = 2, this.iconClass = g4.widgetIcon, this.messages = null, this.viewModel = new E3();
  }
  initialize() {
    const e8 = this._handles;
    this.addHandles([a2(() => this.viewModel.items, "change", (s8) => {
      const t5 = "basemap-gallery-item-changes", { added: a10, moved: i2 } = s8;
      e8.remove(t5), e8.add([...a10, ...i2].map((e9) => l(() => e9.state, () => this.scheduleRender())), t5), this.scheduleRender();
    }), f3(() => this.source, () => this.viewModel.load(), { initial: true, once: true })]);
  }
  destroy() {
    this._handles.destroy();
  }
  loadDependencies() {
    return import("./calcite-scrim-XZCNBCYF.js");
  }
  get activeBasemap() {
    return this.viewModel.activeBasemap;
  }
  set activeBasemap(e8) {
    this.viewModel.activeBasemap = e8;
  }
  get label() {
    var _a, _b;
    return (_b = (_a = this.messages) == null ? void 0 : _a.widgetLabel) != null ? _b : "";
  }
  set label(e8) {
    this._overrideIfSome("label", e8);
  }
  get source() {
    return this.viewModel.source;
  }
  set source(e8) {
    this.viewModel.source = e8;
  }
  get view() {
    return this.viewModel.view;
  }
  set view(e8) {
    this.viewModel.view = e8;
  }
  render() {
    const e8 = "loading" === this.source.state, s8 = this.disabled || "disabled" === this.viewModel.state, t5 = this.viewModel.items.map((e9, s9) => this._renderBasemapGalleryItem(e9, s9)).toArray(), a10 = { [g4.sourceLoading]: e8, [g4.disabled]: s8 }, i2 = e8 ? n3("div", { class: g4.loader, key: "esri-basemap-gallery__loader" }) : null, r5 = e8 ? null : t5.length > 0 ? n3("ul", { bind: this, "aria-disabled": this.disabled, "aria-label": this.label, class: g4.itemContainer, key: "esri-basemap-gallery__item-container", onkeydown: this._handleKeyDown, role: "radiogroup" }, t5) : n3("div", { class: g4.emptyMessage, key: "esri-basemap-gallery__empty-message" }, n3(n4, { level: this.headingLevel }, this.messages.noBasemaps));
    return n3("div", { class: this.classes(g4.base, a10) }, i2, r5);
  }
  _getRoundRobinIndex(e8, s8) {
    return (e8 + s8) % s8;
  }
  _handleKeyDown(e8) {
    const { key: s8 } = e8;
    if (!["ArrowUp", "ArrowDown", "ArrowRight", "ArrowLeft"].includes(s8))
      return;
    e8.preventDefault();
    const { items: t5, activeBasemapIndex: a10 } = this.viewModel, i2 = "ArrowUp" === s8 || "ArrowLeft" === s8 ? this._getRoundRobinIndex(Math.max(a10 - 1, -1), t5.length) : this._getRoundRobinIndex(a10 + 1, t5.length), r5 = t5.getItemAt(i2);
    "ready" === (r5 == null ? void 0 : r5.state) && (this.viewModel.activeBasemap = r5.basemap), this._focusBasemapItemEnabled = true;
  }
  _focusBasemapItem(e8) {
    this._focusBasemapItemEnabled && 0 === e8.tabIndex && (e8.focus(), this._focusBasemapItemEnabled = false);
  }
  _handleClick(e8) {
    const s8 = e8.currentTarget["data-item"];
    "ready" === s8.state && (this.viewModel.activeBasemap = s8.basemap);
  }
  _renderBasemapGalleryItem(e8, t5) {
    var _a, _b;
    const a10 = e8.basemap.thumbnailUrl || a3("esri/themes/base/images/basemap-toggle-64.svg"), i2 = e8.basemap.title, r5 = (_a = e8.basemap.portalItem) == null ? void 0 : _a.snippet, o = ((_b = e8.error) == null ? void 0 : _b.message) || r5 || i2, { viewModel: { state: l4, activeBasemapIndex: d2 } } = this, n5 = this.disabled || "disabled" === l4, m8 = d2 === t5, p3 = m8 || -1 === d2 && 0 === t5 ? 0 : -1, c7 = "loading" === l4, u6 = { [g4.selectedItem]: m8, [g4.itemError]: "error" === e8.state }, b8 = `basemapgallery-item-${e8.uid}`;
    return n3("li", { "aria-checked": m8.toString(), "aria-disabled": n5.toString(), "aria-labelledby": b8, bind: this, class: this.classes(g4.item, u6), "data-item": e8, onkeydown: this._handleClick, onclick: this._handleClick, role: "radio", tabIndex: p3, afterUpdate: this._focusBasemapItem, title: o }, n3("img", { alt: "", class: g4.itemThumbnail, src: a10 }), n3("div", { id: b8, class: g4.itemTitle }, i2), "loading" === e8.state || m8 && c7 ? n3("calcite-scrim", null, n3("span", { "aria-hidden": "true", role: "presentation", class: g4.loaderAnimation })) : null);
  }
};
e3([y2()], u5.prototype, "activeBasemap", null), e3([y2()], u5.prototype, "disabled", void 0), e3([y2()], u5.prototype, "headingLevel", void 0), e3([y2()], u5.prototype, "iconClass", void 0), e3([y2()], u5.prototype, "label", null), e3([y2(), e4("esri/widgets/BasemapGallery/t9n/BasemapGallery")], u5.prototype, "messages", void 0), e3([y2()], u5.prototype, "source", null), e3([y2()], u5.prototype, "view", null), e3([y2()], u5.prototype, "viewModel", void 0), e3([t3()], u5.prototype, "_handleClick", null), u5 = e3([n2("esri.widgets.BasemapGallery")], u5);
var b7 = u5;

// dep:@arcgis_core_widgets_BasemapGallery
var arcgis_core_widgets_BasemapGallery_default = b7;
export {
  arcgis_core_widgets_BasemapGallery_default as default
};
//# sourceMappingURL=@arcgis_core_widgets_BasemapGallery.js.map
