import {
  m
} from "./chunk-IPDZATIB.js";
import {
  I,
  e as e4,
  r as r2
} from "./chunk-FSTECXRH.js";
import {
  t as t3
} from "./chunk-A22ACVMF.js";
import {
  e as e2
} from "./chunk-XFDO4CMR.js";
import {
  e as e3
} from "./chunk-IVLBGTXL.js";
import {
  e
} from "./chunk-GHN7C53L.js";
import {
  Ze
} from "./chunk-53VWTVL2.js";
import {
  n as n2
} from "./chunk-NDQ5FHGV.js";
import {
  x
} from "./chunk-BYSA56OH.js";
import {
  u as u2
} from "./chunk-6M2AHKYV.js";
import {
  j
} from "./chunk-SZIJNKCV.js";
import {
  n,
  t as t2
} from "./chunk-D4V6J5BT.js";
import {
  U
} from "./chunk-DMI7A7TC.js";
import {
  s
} from "./chunk-ZHAW7FZS.js";
import {
  E,
  w
} from "./chunk-MJXQTGI2.js";
import {
  f,
  u2 as u
} from "./chunk-6QC7MLLS.js";
import {
  r,
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/layers/support/capabilities.js
var t4 = { analytics: { supportsCacheHint: false }, attachment: { supportsContentType: false, supportsExifInfo: false, supportsKeywords: false, supportsName: false, supportsSize: false, supportsCacheHint: false, supportsResize: false }, data: { isVersioned: false, supportsAttachment: false, supportsM: false, supportsZ: false }, editing: { supportsDeleteByAnonymous: false, supportsDeleteByOthers: false, supportsGeometryUpdate: false, supportsGlobalId: false, supportsReturnServiceEditsInSourceSpatialReference: false, supportsRollbackOnFailure: false, supportsUpdateByAnonymous: false, supportsUpdateByOthers: false, supportsUpdateWithoutM: false, supportsUploadWithItemId: false }, metadata: { supportsAdvancedFieldProperties: false }, operations: { supportsCalculate: false, supportsTruncate: false, supportsValidateSql: false, supportsAdd: false, supportsDelete: false, supportsEditing: false, supportsChangeTracking: false, supportsQuery: false, supportsQueryAnalytics: false, supportsQueryAttachments: false, supportsQueryTopFeatures: false, supportsResizeAttachments: false, supportsSync: false, supportsUpdate: false, supportsExceedsLimitStatistics: false }, queryRelated: { supportsCount: false, supportsOrderBy: false, supportsPagination: false, supportsCacheHint: false }, queryTopFeatures: { supportsCacheHint: false }, query: { maxRecordCount: 0, maxRecordCountFactor: 0, standardMaxRecordCount: 0, supportsCacheHint: false, supportsCentroid: false, supportsCompactGeometry: false, supportsDefaultSpatialReference: false, supportsFullTextSearch: false, supportsDisjointSpatialRelationship: false, supportsDistance: false, supportsDistinct: false, supportsExtent: false, supportsFormatPBF: false, supportsGeometryProperties: false, supportsHavingClause: false, supportsHistoricMoment: false, supportsMaxRecordCountFactor: false, supportsOrderBy: false, supportsPagination: false, supportsPercentileStatistics: false, supportsQuantization: false, supportsQuantizationEditMode: false, supportsQueryByOthers: false, supportsQueryGeometry: false, supportsResultType: false, supportsSqlExpression: false, supportsStandardizedQueriesOnly: false, supportsTopFeaturesQuery: false, supportsSpatialAggregationStatistics: false, supportedSpatialAggregationStatistics: { envelope: false, centroid: false, convexHull: false }, supportsStatistics: false, tileMaxRecordCount: 0 } };

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SProjectionUtil.js
var s2 = 1;
var c = 5 - s2;

// node_modules/@arcgis/core/views/3d/support/orientedBoundingBox.js
var w3 = e2();
var A = n();
var B2 = n();
var I2 = n2();
var C = e();
function E3(t5 = [0, 0, 0], e7 = [-1, -1, -1], a3 = [0, 0, 0, 1]) {
  return { center: t2(t5), halfSize: t3(e7), quaternion: r2(a3) };
}
var T = (() => {
  const t5 = new Int8Array(162);
  let e7 = 0;
  const a3 = (a4) => {
    for (let n5 = 0; n5 < a4.length; n5++)
      t5[e7 + n5] = a4[n5];
    e7 += 6;
  };
  return a3([6, 2, 3, 1, 5, 4]), a3([0, 2, 3, 1, 5, 4]), a3([0, 2, 3, 7, 5, 4]), a3([0, 1, 3, 2, 6, 4]), a3([0, 1, 3, 2, 0, 0]), a3([0, 1, 5, 7, 3, 2]), a3([0, 1, 3, 7, 6, 4]), a3([0, 1, 3, 7, 6, 2]), a3([0, 1, 5, 7, 6, 2]), a3([0, 1, 5, 4, 6, 2]), a3([0, 1, 5, 4, 0, 0]), a3([0, 1, 3, 7, 5, 4]), a3([0, 2, 6, 4, 0, 0]), a3([0, 0, 0, 0, 0, 0]), a3([1, 3, 7, 5, 0, 0]), a3([2, 3, 7, 6, 4, 0]), a3([2, 3, 7, 6, 0, 0]), a3([2, 3, 1, 5, 7, 6]), a3([0, 1, 5, 7, 6, 2]), a3([0, 1, 5, 7, 6, 4]), a3([0, 1, 3, 7, 6, 4]), a3([4, 5, 7, 6, 2, 0]), a3([4, 5, 7, 6, 0, 0]), a3([4, 5, 1, 3, 7, 6]), a3([0, 2, 3, 7, 5, 4]), a3([6, 2, 3, 7, 5, 4]), a3([6, 2, 3, 1, 5, 4]), t5;
})();

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SUtil.js
var ie = u2();
var ce;
function ye(t5, r5, n5, o2, a3) {
  const s5 = [];
  for (const e7 of r5)
    if (e7 && a3.includes(e7.name)) {
      const r6 = `${t5}/nodes/${n5}/attributes/${e7.key}/0`;
      s5.push({ url: r6, storageInfo: e7 });
    }
  return E(s5.map((t6) => U(t6.url, { responseType: "array-buffer" }).then((e7) => I(t6.storageInfo, e7.data)))).then((e7) => {
    const t6 = [];
    for (const r6 of o2) {
      const n6 = {};
      for (let t7 = 0; t7 < e7.length; t7++)
        null != e7[t7].value && (n6[s5[t7].storageInfo.name] = be(e7[t7].value, r6));
      t6.push(n6);
    }
    return t6;
  });
}
!function(e7) {
  e7[e7.OUTSIDE = 0] = "OUTSIDE", e7[e7.INTERSECTS_CENTER_OUTSIDE = 1] = "INTERSECTS_CENTER_OUTSIDE", e7[e7.INTERSECTS_CENTER_INSIDE = 2] = "INTERSECTS_CENTER_INSIDE", e7[e7.INSIDE = 3] = "INSIDE";
}(ce || (ce = {}));
var Se = -32768;
var ge = -(2 ** 31);
function be(e7, t5) {
  if (!e7)
    return null;
  const r5 = e7[t5];
  if (u(e7))
    return r5 === Se ? null : r5;
  if (f(e7))
    return r5 === ge ? null : r5;
  return r5 != r5 ? null : r5;
}
var We = m({ color: [0, 0, 0, 0], opacity: 0 });
var Ge = n();
var Ke = n();
var Le = n();
var Be = e2();
var $e = new Float64Array(24);
var Ve = n();
var Ze2 = n();
var He = e();
var it = e3();
var st = e4();
var lt = u2();
var ft = u2();
var ut = E3();
var ht = { data: new Array(72), size: 3 };
var mt = e3();

// node_modules/@arcgis/core/layers/support/FetchAssociatedFeatureLayer.js
var l3 = class {
  constructor(t5, r5, e7, a3) {
    var _a;
    this._parsedUrl = t5, this._portalItem = r5, this._apiKey = e7, this.signal = a3, this._rootDocument = null;
    const i2 = (_a = this._parsedUrl) == null ? void 0 : _a.path.match(/^(.*)\/SceneServer\/layers\/([\d]*)\/?$/i);
    i2 && (this._urlParts = { root: i2[1], layerId: parseInt(i2[2], 10) });
  }
  async fetch() {
    var _a;
    if (!this._urlParts)
      return null;
    const t5 = (_a = this._portalItem) != null ? _a : await this._portalItemFromServiceItemId();
    if (t(t5))
      return this._loadFromUrl();
    const r5 = await this._findAndLoadRelatedPortalItem(t5);
    return t(r5) ? null : this._loadFeatureLayerFromPortalItem(r5);
  }
  async fetchPortalItem() {
    var _a;
    if (!this._urlParts)
      return null;
    const t5 = (_a = this._portalItem) != null ? _a : await this._portalItemFromServiceItemId();
    return t(t5) ? null : this._findAndLoadRelatedPortalItem(t5);
  }
  async _fetchRootDocument() {
    if (r(this._rootDocument))
      return this._rootDocument;
    if (t(this._urlParts))
      return this._rootDocument = {}, {};
    const t5 = { query: { f: "json", token: this._apiKey }, responseType: "json", signal: this.signal }, i2 = `${this._urlParts.root}/SceneServer`;
    try {
      const e7 = await U(i2, t5);
      this._rootDocument = e7.data;
    } catch {
      this._rootDocument = {};
    }
    return this._rootDocument;
  }
  async _fetchServiceOwningPortalUrl() {
    var _a, _b;
    const e7 = (_a = this._parsedUrl) == null ? void 0 : _a.path, a3 = e7 ? (_b = s) == null ? void 0 : _b.findServerInfo(e7) : null;
    if (a3 == null ? void 0 : a3.owningSystemUrl)
      return a3.owningSystemUrl;
    const s5 = e7 ? e7.replace(/(.*\/rest)\/.*/i, "$1") + "/info" : null;
    try {
      const t5 = (await U(s5, { query: { f: "json" }, responseType: "json", signal: this.signal })).data.owningSystemUrl;
      if (t5)
        return t5;
    } catch (n5) {
      w(n5);
    }
    return null;
  }
  async _findAndLoadRelatedPortalItem(t5) {
    try {
      return (await t5.fetchRelatedItems({ relationshipType: "Service2Service", direction: "reverse" }, { signal: this.signal })).find((t6) => "Feature Service" === t6.type) || null;
    } catch (r5) {
      return w(r5), null;
    }
  }
  async _loadFeatureLayerFromPortalItem(t5) {
    var _a;
    await t5.load({ signal: this.signal });
    const r5 = await this._findMatchingAssociatedSublayerUrl((_a = t5.url) != null ? _a : "");
    return new Ze({ url: r5, portalItem: t5 }).load({ signal: this.signal });
  }
  async _loadFromUrl() {
    var _a;
    const t5 = await this._findMatchingAssociatedSublayerUrl(`${(_a = this._urlParts) == null ? void 0 : _a.root}/FeatureServer`);
    return new Ze({ url: t5 }).load({ signal: this.signal });
  }
  async _findMatchingAssociatedSublayerUrl(t5) {
    var _a;
    const e7 = t5.replace(/^(.*FeatureServer)(\/[\d]*\/?)?$/i, "$1"), a3 = { query: { f: "json" }, responseType: "json", authMode: "no-prompt", signal: this.signal }, i2 = (_a = this._urlParts) == null ? void 0 : _a.layerId, s5 = this._fetchRootDocument(), n5 = U(e7, a3), [o2, l4] = await Promise.all([n5, s5]), c3 = l4 && l4.layers, u6 = o2.data && o2.data.layers;
    if (!Array.isArray(u6))
      throw new Error("expected layers array");
    if (Array.isArray(c3))
      for (let r5 = 0; r5 < Math.min(c3.length, u6.length); r5++) {
        if (c3[r5].id === i2)
          return `${e7}/${u6[r5].id}`;
      }
    else if (null != i2 && i2 < u6.length)
      return `${e7}/${u6[i2].id}`;
    throw new Error("could not find matching associated sublayer");
  }
  async _portalItemFromServiceItemId() {
    const t5 = (await this._fetchRootDocument()).serviceItemId;
    if (!t5)
      return null;
    const r5 = new x({ id: t5, apiKey: this._apiKey }), e7 = await this._fetchServiceOwningPortalUrl();
    r(e7) && (r5.portal = new j({ url: e7 }));
    try {
      return r5.load({ signal: this.signal });
    } catch (s5) {
      return w(s5), null;
    }
  }
};

export {
  t4 as t,
  ye,
  l3 as l
};
//# sourceMappingURL=chunk-PQIAEL3H.js.map
