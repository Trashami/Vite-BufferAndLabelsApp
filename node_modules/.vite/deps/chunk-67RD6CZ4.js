import {
  r as r2
} from "./chunk-75RMBUYZ.js";
import {
  o
} from "./chunk-3LR5O4WA.js";
import {
  r
} from "./chunk-GDVNKPJ7.js";

// node_modules/@arcgis/core/geometry/support/buffer/internals/Mat3.js
var t = class {
  constructor(t4, e4, r3 = 0, f, s) {
    this.TypedArrayConstructor = t4, this.elementCount = 9;
    const i2 = this.TypedArrayConstructor;
    void 0 === f && (f = 9 * i2.BYTES_PER_ELEMENT);
    const d2 = 0 === e4.byteLength ? 0 : r3;
    this.typedBuffer = null == s ? new i2(e4, d2) : new i2(e4, d2, (s - r3) / i2.BYTES_PER_ELEMENT), this.typedBufferStride = f / i2.BYTES_PER_ELEMENT, this.count = Math.ceil(this.typedBuffer.length / this.typedBufferStride), this.stride = this.typedBufferStride * this.TypedArrayConstructor.BYTES_PER_ELEMENT;
  }
  sliceBuffer(t4, e4, r3 = this.count - e4) {
    const f = this.typedBuffer.byteOffset + e4 * this.stride;
    return new t4(this.buffer, f, this.stride, f + r3 * this.stride);
  }
  getMat(t4, e4) {
    let r3 = t4 * this.typedBufferStride;
    for (let f = 0; f < 9; f++)
      e4[f] = this.typedBuffer[r3++];
    return e4;
  }
  setMat(t4, e4) {
    let r3 = t4 * this.typedBufferStride;
    for (let f = 0; f < 9; f++)
      this.typedBuffer[r3++] = e4[f];
  }
  get(t4, e4) {
    return this.typedBuffer[t4 * this.typedBufferStride + e4];
  }
  set(t4, e4, r3) {
    this.typedBuffer[t4 * this.typedBufferStride + e4] = r3;
  }
  copyFrom(t4, e4, r3) {
    const f = this.typedBuffer, s = e4.typedBuffer;
    let i2 = t4 * this.typedBufferStride, d2 = r3 * e4.typedBufferStride;
    for (let u2 = 0; u2 < 9; ++u2)
      f[i2++] = s[d2++];
  }
  get buffer() {
    return this.typedBuffer.buffer;
  }
};
t.ElementCount = 9;

// node_modules/@arcgis/core/geometry/support/buffer/internals/Mat4.js
var t2 = class {
  constructor(t4, e4, r3 = 0, f, s) {
    this.TypedArrayConstructor = t4, this.elementCount = 16;
    const i2 = this.TypedArrayConstructor;
    void 0 === f && (f = 16 * i2.BYTES_PER_ELEMENT);
    const d2 = 0 === e4.byteLength ? 0 : r3;
    this.typedBuffer = null == s ? new i2(e4, d2) : new i2(e4, d2, (s - r3) / i2.BYTES_PER_ELEMENT), this.typedBufferStride = f / i2.BYTES_PER_ELEMENT, this.count = Math.ceil(this.typedBuffer.length / this.typedBufferStride), this.stride = this.typedBufferStride * this.TypedArrayConstructor.BYTES_PER_ELEMENT;
  }
  sliceBuffer(t4, e4, r3 = this.count - e4) {
    const f = this.typedBuffer.byteOffset + e4 * this.stride;
    return new t4(this.buffer, f, this.stride, f + r3 * this.stride);
  }
  getMat(t4, e4) {
    let r3 = t4 * this.typedBufferStride;
    for (let f = 0; f < 16; f++)
      e4[f] = this.typedBuffer[r3++];
    return e4;
  }
  setMat(t4, e4) {
    let r3 = t4 * this.typedBufferStride;
    for (let f = 0; f < 16; f++)
      this.typedBuffer[r3++] = e4[f];
  }
  get(t4, e4) {
    return this.typedBuffer[t4 * this.typedBufferStride + e4];
  }
  set(t4, e4, r3) {
    this.typedBuffer[t4 * this.typedBufferStride + e4] = r3;
  }
  copyFrom(t4, e4, r3) {
    const f = this.typedBuffer, s = e4.typedBuffer;
    let i2 = t4 * this.typedBufferStride, d2 = r3 * e4.typedBufferStride;
    for (let u2 = 0; u2 < 16; ++u2)
      f[i2++] = s[d2++];
  }
  get buffer() {
    return this.typedBuffer.buffer;
  }
};
t2.ElementCount = 16;

// node_modules/@arcgis/core/geometry/support/buffer/internals/Scalar.js
var t3 = class {
  constructor(t4, e4, r3 = 0, s, i2) {
    this.TypedArrayConstructor = t4, this.elementCount = 1;
    const f = this.TypedArrayConstructor;
    void 0 === s && (s = f.BYTES_PER_ELEMENT);
    const u2 = 0 === e4.byteLength ? 0 : r3;
    this.typedBuffer = null == i2 ? new f(e4, u2) : new f(e4, u2, (i2 - r3) / f.BYTES_PER_ELEMENT), this.stride = s, this.typedBufferStride = s / f.BYTES_PER_ELEMENT, this.count = Math.ceil(this.typedBuffer.length / this.typedBufferStride);
  }
  sliceBuffer(t4, e4, r3 = this.count - e4) {
    const s = this.typedBuffer.byteOffset + e4 * this.stride;
    return new t4(this.buffer, s, this.stride, s + r3 * this.stride);
  }
  get(t4) {
    return this.typedBuffer[t4 * this.typedBufferStride];
  }
  set(t4, e4) {
    this.typedBuffer[t4 * this.typedBufferStride] = e4;
  }
  get buffer() {
    return this.typedBuffer.buffer;
  }
};
t3.ElementCount = 1;

// node_modules/@arcgis/core/geometry/support/buffer/internals/Vec2.js
var e = class {
  constructor(t4, e4, r3 = 0, f, s) {
    this.TypedArrayConstructor = t4, this.elementCount = 2;
    const i2 = this.TypedArrayConstructor;
    void 0 === f && (f = 2 * i2.BYTES_PER_ELEMENT);
    const u2 = 0 === e4.byteLength ? 0 : r3;
    this.typedBuffer = null == s ? new i2(e4, u2) : new i2(e4, u2, (s - r3) / i2.BYTES_PER_ELEMENT), this.typedBufferStride = f / i2.BYTES_PER_ELEMENT, this.count = Math.ceil(this.typedBuffer.length / this.typedBufferStride), this.stride = this.typedBufferStride * this.TypedArrayConstructor.BYTES_PER_ELEMENT;
  }
  sliceBuffer(t4, e4, r3 = this.count - e4) {
    const f = this.typedBuffer.byteOffset + e4 * this.stride;
    return new t4(this.buffer, f, this.stride, f + r3 * this.stride);
  }
  getVec(e4, r3) {
    return e4 *= this.typedBufferStride, r2(r3, this.typedBuffer[e4], this.typedBuffer[e4 + 1]);
  }
  setVec(t4, e4) {
    t4 *= this.typedBufferStride, this.typedBuffer[t4++] = e4[0], this.typedBuffer[t4] = e4[1];
  }
  get(t4, e4) {
    return this.typedBuffer[t4 * this.typedBufferStride + e4];
  }
  set(t4, e4, r3) {
    this.typedBuffer[t4 * this.typedBufferStride + e4] = r3;
  }
  setValues(t4, e4, r3) {
    t4 *= this.typedBufferStride, this.typedBuffer[t4++] = e4, this.typedBuffer[t4] = r3;
  }
  copyFrom(t4, e4, r3) {
    const f = this.typedBuffer, s = e4.typedBuffer;
    let i2 = t4 * this.typedBufferStride, u2 = r3 * e4.typedBufferStride;
    f[i2++] = s[u2++], f[i2] = s[u2];
  }
  get buffer() {
    return this.typedBuffer.buffer;
  }
};
e.ElementCount = 2;

// node_modules/@arcgis/core/geometry/support/buffer/internals/Vec3.js
var e2 = class {
  constructor(t4, e4, r3 = 0, f, s) {
    this.TypedArrayConstructor = t4, this.elementCount = 3;
    const i2 = this.TypedArrayConstructor;
    void 0 === f && (f = 3 * i2.BYTES_PER_ELEMENT);
    const u2 = 0 === e4.byteLength ? 0 : r3;
    this.typedBuffer = null == s ? new i2(e4, u2) : new i2(e4, u2, (s - r3) / i2.BYTES_PER_ELEMENT), this.typedBufferStride = f / i2.BYTES_PER_ELEMENT, this.count = Math.ceil(this.typedBuffer.length / this.typedBufferStride), this.stride = this.typedBufferStride * this.TypedArrayConstructor.BYTES_PER_ELEMENT;
  }
  sliceBuffer(t4, e4, r3 = this.count - e4) {
    const f = this.typedBuffer.byteOffset + e4 * this.stride;
    return new t4(this.buffer, f, this.stride, f + r3 * this.stride);
  }
  getVec(e4, r3) {
    return e4 *= this.typedBufferStride, o(r3, this.typedBuffer[e4], this.typedBuffer[e4 + 1], this.typedBuffer[e4 + 2]);
  }
  setVec(t4, e4) {
    t4 *= this.typedBufferStride, this.typedBuffer[t4++] = e4[0], this.typedBuffer[t4++] = e4[1], this.typedBuffer[t4] = e4[2];
  }
  get(t4, e4) {
    return this.typedBuffer[t4 * this.typedBufferStride + e4];
  }
  set(t4, e4, r3) {
    this.typedBuffer[t4 * this.typedBufferStride + e4] = r3;
  }
  setValues(t4, e4, r3, f) {
    t4 *= this.typedBufferStride, this.typedBuffer[t4++] = e4, this.typedBuffer[t4++] = r3, this.typedBuffer[t4] = f;
  }
  copyFrom(t4, e4, r3) {
    const f = this.typedBuffer, s = e4.typedBuffer;
    let i2 = t4 * this.typedBufferStride, u2 = r3 * e4.typedBufferStride;
    f[i2++] = s[u2++], f[i2++] = s[u2++], f[i2] = s[u2];
  }
  get buffer() {
    return this.typedBuffer.buffer;
  }
};
e2.ElementCount = 3;

// node_modules/@arcgis/core/geometry/support/buffer/internals/Vec4.js
var e3 = class {
  constructor(t4, e4, r3 = 0, f, s) {
    this.TypedArrayConstructor = t4, this.start = r3, this.elementCount = 4;
    const i2 = this.TypedArrayConstructor;
    void 0 === f && (f = 4 * i2.BYTES_PER_ELEMENT);
    const u2 = 0 === e4.byteLength ? 0 : r3;
    this.typedBuffer = null == s ? new i2(e4, u2) : new i2(e4, u2, (s - r3) / i2.BYTES_PER_ELEMENT), this.typedBufferStride = f / i2.BYTES_PER_ELEMENT, this.count = Math.ceil(this.typedBuffer.length / this.typedBufferStride), this.stride = this.typedBufferStride * this.TypedArrayConstructor.BYTES_PER_ELEMENT;
  }
  sliceBuffer(t4, e4, r3 = this.count - e4) {
    const f = this.typedBuffer.byteOffset + e4 * this.stride;
    return new t4(this.buffer, f, this.stride, f + r3 * this.stride);
  }
  getVec(e4, r3) {
    return e4 *= this.typedBufferStride, r(r3, this.typedBuffer[e4++], this.typedBuffer[e4++], this.typedBuffer[e4++], this.typedBuffer[e4]);
  }
  setVec(t4, e4) {
    t4 *= this.typedBufferStride, this.typedBuffer[t4++] = e4[0], this.typedBuffer[t4++] = e4[1], this.typedBuffer[t4++] = e4[2], this.typedBuffer[t4] = e4[3];
  }
  get(t4, e4) {
    return this.typedBuffer[t4 * this.typedBufferStride + e4];
  }
  set(t4, e4, r3) {
    this.typedBuffer[t4 * this.typedBufferStride + e4] = r3;
  }
  setValues(t4, e4, r3, f, s) {
    t4 *= this.typedBufferStride, this.typedBuffer[t4++] = e4, this.typedBuffer[t4++] = r3, this.typedBuffer[t4++] = f, this.typedBuffer[t4] = s;
  }
  copyFrom(t4, e4, r3) {
    const f = this.typedBuffer, s = e4.typedBuffer;
    let i2 = t4 * this.typedBufferStride, u2 = r3 * e4.typedBufferStride;
    f[i2++] = s[u2++], f[i2++] = s[u2++], f[i2++] = s[u2++], f[i2] = s[u2];
  }
  get buffer() {
    return this.typedBuffer.buffer;
  }
};
e3.ElementCount = 4;

// node_modules/@arcgis/core/geometry/support/buffer/BufferView.js
var y = class extends t3 {
  constructor(e4, t4 = 0, r3, s) {
    super(Float32Array, e4, t4, r3, s), this.elementType = "f32";
  }
  static fromTypedArray(e4, t4) {
    return new y(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
y.ElementType = "f32";
var u = class extends e {
  constructor(e4, t4 = 0, r3, s) {
    super(Float32Array, e4, t4, r3, s), this.elementType = "f32";
  }
  slice(e4, t4) {
    return this.sliceBuffer(u, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new u(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
u.ElementType = "f32";
var i = class extends e2 {
  constructor(e4, t4 = 0, r3, s) {
    super(Float32Array, e4, t4, r3, s), this.elementType = "f32";
  }
  slice(e4, t4) {
    return this.sliceBuffer(i, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new i(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
i.ElementType = "f32";
var c = class extends e3 {
  constructor(e4, t4 = 0, r3, s) {
    super(Float32Array, e4, t4, r3, s), this.elementType = "f32";
  }
  slice(e4, t4) {
    return this.sliceBuffer(c, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new c(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
c.ElementType = "f32";
var l = class extends t {
  constructor(e4, t4 = 0, r3, s) {
    super(Float32Array, e4, t4, r3, s), this.elementType = "f32";
  }
  slice(e4, t4) {
    return this.sliceBuffer(l, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new l(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
l.ElementType = "f32";
var a = class extends t {
  constructor(e4, t4 = 0, r3, s) {
    super(Float64Array, e4, t4, r3, s), this.elementType = "f64";
  }
  slice(e4, t4) {
    return this.sliceBuffer(a, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new a(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
a.ElementType = "f64";
var p = class extends t2 {
  constructor(e4, t4 = 0, r3, s) {
    super(Float32Array, e4, t4, r3, s), this.elementType = "f32";
  }
  slice(e4, t4) {
    return this.sliceBuffer(p, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new p(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
p.ElementType = "f32";
var b = class extends t2 {
  constructor(e4, t4 = 0, r3, s) {
    super(Float64Array, e4, t4, r3, s), this.elementType = "f64";
  }
  slice(e4, t4) {
    return this.sliceBuffer(b, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new b(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
b.ElementType = "f64";
var o2 = class extends t3 {
  constructor(e4, t4 = 0, r3, s) {
    super(Float64Array, e4, t4, r3, s), this.elementType = "f64";
  }
  slice(e4, t4) {
    return this.sliceBuffer(o2, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new o2(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
o2.ElementType = "f64";
var m = class extends e {
  constructor(e4, t4 = 0, r3, s) {
    super(Float64Array, e4, t4, r3, s), this.elementType = "f64";
  }
  slice(e4, t4) {
    return this.sliceBuffer(m, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new m(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
m.ElementType = "f64";
var T = class extends e2 {
  constructor(e4, t4 = 0, r3, s) {
    super(Float64Array, e4, t4, r3, s), this.elementType = "f64";
  }
  slice(e4, t4) {
    return this.sliceBuffer(T, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new T(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
T.ElementType = "f64";
var h = class extends e3 {
  constructor(e4, t4 = 0, r3, s) {
    super(Float64Array, e4, t4, r3, s), this.elementType = "f64";
  }
  slice(e4, t4) {
    return this.sliceBuffer(h, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new h(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
h.ElementType = "f64";
var d = class extends t3 {
  constructor(e4, t4 = 0, r3, s) {
    super(Uint8Array, e4, t4, r3, s), this.elementType = "u8";
  }
  slice(e4, t4) {
    return this.sliceBuffer(d, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new d(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
d.ElementType = "u8";
var A = class extends e {
  constructor(e4, t4 = 0, r3, s) {
    super(Uint8Array, e4, t4, r3, s), this.elementType = "u8";
  }
  slice(e4, t4) {
    return this.sliceBuffer(A, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new A(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
A.ElementType = "u8";
var O = class extends e2 {
  constructor(e4, t4 = 0, r3, s) {
    super(Uint8Array, e4, t4, r3, s), this.elementType = "u8";
  }
  slice(e4, t4) {
    return this.sliceBuffer(O, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new O(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
O.ElementType = "u8";
var x = class extends e3 {
  constructor(e4, t4 = 0, r3, s) {
    super(Uint8Array, e4, t4, r3, s), this.elementType = "u8";
  }
  slice(e4, t4) {
    return this.sliceBuffer(x, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new x(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
x.ElementType = "u8";
var g = class extends t3 {
  constructor(e4, t4 = 0, r3, s) {
    super(Uint16Array, e4, t4, r3, s), this.elementType = "u16";
  }
  slice(e4, t4) {
    return this.sliceBuffer(g, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new g(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
g.ElementType = "u16";
var w = class extends e {
  constructor(e4, t4 = 0, r3, s) {
    super(Uint16Array, e4, t4, r3, s), this.elementType = "u16";
  }
  slice(e4, t4) {
    return this.sliceBuffer(w, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new w(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
w.ElementType = "u16";
var E = class extends e2 {
  constructor(e4, t4 = 0, r3, s) {
    super(Uint16Array, e4, t4, r3, s), this.elementType = "u16";
  }
  slice(e4, t4) {
    return this.sliceBuffer(E, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new E(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
E.ElementType = "u16";
var L = class extends e3 {
  constructor(e4, t4 = 0, r3, s) {
    super(Uint16Array, e4, t4, r3, s), this.elementType = "u16";
  }
  slice(e4, t4) {
    return this.sliceBuffer(L, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new L(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
L.ElementType = "u16";
var B = class extends t3 {
  constructor(e4, t4 = 0, r3, s) {
    super(Uint32Array, e4, t4, r3, s), this.elementType = "u32";
  }
  slice(e4, t4) {
    return this.sliceBuffer(B, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new B(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
B.ElementType = "u32";
var F = class extends e {
  constructor(e4, t4 = 0, r3, s) {
    super(Uint32Array, e4, t4, r3, s), this.elementType = "u32";
  }
  slice(e4, t4) {
    return this.sliceBuffer(F, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new F(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
F.ElementType = "u32";
var I = class extends e2 {
  constructor(e4, t4 = 0, r3, s) {
    super(Uint32Array, e4, t4, r3, s), this.elementType = "u32";
  }
  slice(e4, t4) {
    return this.sliceBuffer(I, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new I(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
I.ElementType = "u32";
var U = class extends e3 {
  constructor(e4, t4 = 0, r3, s) {
    super(Uint32Array, e4, t4, r3, s), this.elementType = "u32";
  }
  slice(e4, t4) {
    return this.sliceBuffer(U, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new U(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
U.ElementType = "u32";
var j = class extends t3 {
  constructor(e4, t4 = 0, r3, s) {
    super(Int8Array, e4, t4, r3, s), this.elementType = "i8";
  }
  slice(e4, t4) {
    return this.sliceBuffer(j, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new j(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
j.ElementType = "i8";
var V = class extends e {
  constructor(e4, t4 = 0, r3, s) {
    super(Int8Array, e4, t4, r3, s), this.elementType = "i8";
  }
  slice(e4, t4) {
    return this.sliceBuffer(V, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new V(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
V.ElementType = "i8";
var M = class extends e2 {
  constructor(e4, t4 = 0, r3, s) {
    super(Int8Array, e4, t4, r3, s), this.elementType = "i8";
  }
  slice(e4, t4) {
    return this.sliceBuffer(M, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new M(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
M.ElementType = "i8";
var S = class extends e3 {
  constructor(e4, t4 = 0, r3, s) {
    super(Int8Array, e4, t4, r3, s), this.elementType = "i8";
  }
  slice(e4, t4) {
    return this.sliceBuffer(S, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new S(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
S.ElementType = "i8";
var k = class extends t3 {
  constructor(e4, t4 = 0, r3, s) {
    super(Int16Array, e4, t4, r3, s), this.elementType = "i16";
  }
  slice(e4, t4) {
    return this.sliceBuffer(k, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new k(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
k.ElementType = "i16";
var q = class extends e {
  constructor(e4, t4 = 0, r3, s) {
    super(Int16Array, e4, t4, r3, s), this.elementType = "i16";
  }
  slice(e4, t4) {
    return this.sliceBuffer(q, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new q(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
q.ElementType = "i16";
var v = class extends e2 {
  constructor(e4, t4 = 0, r3, s) {
    super(Int16Array, e4, t4, r3, s), this.elementType = "i16";
  }
  slice(e4, t4) {
    return this.sliceBuffer(v, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new v(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
v.ElementType = "i16";
var z = class extends e3 {
  constructor(e4, t4 = 0, r3, s) {
    super(Int16Array, e4, t4, r3, s), this.elementType = "i16";
  }
  slice(e4, t4) {
    return this.sliceBuffer(z, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new z(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
z.ElementType = "i16";
var C = class extends t3 {
  constructor(e4, t4 = 0, r3, s) {
    super(Int32Array, e4, t4, r3, s), this.elementType = "i32";
  }
  slice(e4, t4) {
    return this.sliceBuffer(C, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new C(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
C.ElementType = "i32";
var D = class extends e {
  constructor(e4, t4 = 0, r3, s) {
    super(Int32Array, e4, t4, r3, s), this.elementType = "i32";
  }
  slice(e4, t4) {
    return this.sliceBuffer(D, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new D(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
D.ElementType = "i32";
var G = class extends e2 {
  constructor(e4, t4 = 0, r3, s) {
    super(Int32Array, e4, t4, r3, s), this.elementType = "i32";
  }
  slice(e4, t4) {
    return this.sliceBuffer(G, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new G(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
G.ElementType = "i32";
var H = class extends e3 {
  constructor(e4, t4 = 0, r3, s) {
    super(Int32Array, e4, t4, r3, s), this.elementType = "i32";
  }
  slice(e4, t4) {
    return this.sliceBuffer(H, e4, t4);
  }
  static fromTypedArray(e4, t4) {
    return new H(e4.buffer, e4.byteOffset, t4, e4.byteOffset + e4.byteLength);
  }
};
H.ElementType = "i32";

export {
  y,
  u,
  i,
  c,
  l,
  a,
  p,
  b,
  o2 as o,
  m,
  T,
  h,
  d,
  A,
  O,
  x,
  g,
  w,
  E,
  L,
  B,
  F,
  I,
  U,
  j,
  V,
  M,
  S,
  k,
  q,
  v,
  z,
  C,
  D,
  G,
  H
};
//# sourceMappingURL=chunk-67RD6CZ4.js.map
