import {
  a2 as a,
  a3 as a2,
  d
} from "./chunk-WFTTVWLQ.js";
import {
  I,
  c,
  e,
  f,
  g
} from "./chunk-FSTECXRH.js";
import {
  n,
  r as r2
} from "./chunk-A22ACVMF.js";
import "./chunk-RUM3DXFX.js";
import {
  S
} from "./chunk-NGFMX3UT.js";
import "./chunk-XFDO4CMR.js";
import "./chunk-GHN7C53L.js";
import {
  xn
} from "./chunk-FFVIDMFN.js";
import "./chunk-R6OA44DQ.js";
import "./chunk-QTYVDCOW.js";
import "./chunk-ZWUEORSX.js";
import "./chunk-ZPYDYUP5.js";
import "./chunk-RT3T2K4S.js";
import "./chunk-WJCI2CGX.js";
import "./chunk-NAN5J6QS.js";
import "./chunk-6M2AHKYV.js";
import "./chunk-JUVQV3R3.js";
import "./chunk-RAX2HD42.js";
import "./chunk-ZYRIJWLX.js";
import "./chunk-C5H57NTD.js";
import {
  E
} from "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import "./chunk-3MNMDUQZ.js";
import "./chunk-UWG37XSU.js";
import {
  k2 as k
} from "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import "./chunk-HLM6QCL2.js";
import "./chunk-RXYULINL.js";
import "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import "./chunk-KAN4HXCG.js";
import "./chunk-VWYWOOPX.js";
import "./chunk-M5VHU5LK.js";
import "./chunk-7QMMKGW4.js";
import "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import "./chunk-MJXQTGI2.js";
import "./chunk-LIZHLHNA.js";
import "./chunk-BTUHYGXO.js";
import "./chunk-UA3YPL2R.js";
import "./chunk-HVKDYDPP.js";
import {
  o
} from "./chunk-6QC7MLLS.js";
import {
  r,
  t
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/views/3d/layers/i3s/PointCloudWorkerUtil.js
function f2(e2, o2, n2, s) {
  const { rendererJSON: i, isRGBRenderer: u } = e2;
  let f3 = null, c4 = null;
  if (o2 && u)
    f3 = o2;
  else if (o2 && "pointCloudUniqueValueRenderer" === i.type) {
    c4 = a2.fromJSON(i);
    const e3 = c4.colorUniqueValueInfos;
    f3 = new Uint8Array(3 * s);
    const r3 = p(c4.fieldTransformType);
    for (let t2 = 0; t2 < s; t2++) {
      const l = (r3 ? r3(o2[t2]) : o2[t2]) + "";
      for (let o3 = 0; o3 < e3.length; o3++)
        if (e3[o3].values.includes(l)) {
          f3[3 * t2] = e3[o3].color.r, f3[3 * t2 + 1] = e3[o3].color.g, f3[3 * t2 + 2] = e3[o3].color.b;
          break;
        }
    }
  } else if (o2 && "pointCloudStretchRenderer" === i.type) {
    c4 = a.fromJSON(i);
    const e3 = c4.stops;
    f3 = new Uint8Array(3 * s);
    const r3 = p(c4.fieldTransformType);
    for (let t2 = 0; t2 < s; t2++) {
      const l = r3 ? r3(o2[t2]) : o2[t2], n3 = e3.length - 1;
      if (l < e3[0].value)
        f3[3 * t2] = e3[0].color.r, f3[3 * t2 + 1] = e3[0].color.g, f3[3 * t2 + 2] = e3[0].color.b;
      else if (l >= e3[n3].value)
        f3[3 * t2] = e3[n3].color.r, f3[3 * t2 + 1] = e3[n3].color.g, f3[3 * t2 + 2] = e3[n3].color.b;
      else
        for (let o3 = 1; o3 < e3.length; o3++)
          if (l < e3[o3].value) {
            const r4 = (l - e3[o3 - 1].value) / (e3[o3].value - e3[o3 - 1].value);
            f3[3 * t2] = e3[o3].color.r * r4 + e3[o3 - 1].color.r * (1 - r4), f3[3 * t2 + 1] = e3[o3].color.g * r4 + e3[o3 - 1].color.g * (1 - r4), f3[3 * t2 + 2] = e3[o3].color.b * r4 + e3[o3 - 1].color.b * (1 - r4);
            break;
          }
    }
  } else if (o2 && "pointCloudClassBreaksRenderer" === i.type) {
    c4 = d.fromJSON(i);
    const e3 = c4.colorClassBreakInfos;
    f3 = new Uint8Array(3 * s);
    const t2 = p(c4.fieldTransformType);
    for (let r3 = 0; r3 < s; r3++) {
      const l = t2 ? t2(o2[r3]) : o2[r3];
      for (let o3 = 0; o3 < e3.length; o3++)
        if (l >= e3[o3].minValue && l <= e3[o3].maxValue) {
          f3[3 * r3] = e3[o3].color.r, f3[3 * r3 + 1] = e3[o3].color.g, f3[3 * r3 + 2] = e3[o3].color.b;
          break;
        }
    }
  } else {
    f3 = new Uint8Array(3 * s);
    for (let e3 = 0; e3 < f3.length; e3++)
      f3[e3] = 255;
  }
  if (n2 && c4 && c4.colorModulation) {
    const e3 = c4.colorModulation.minValue, o3 = c4.colorModulation.maxValue, r3 = 0.3;
    for (let t2 = 0; t2 < s; t2++) {
      const l = n2[t2], s2 = l >= o3 ? 1 : l <= e3 ? r3 : r3 + (1 - r3) * (l - e3) / (o3 - e3);
      f3[3 * t2] = s2 * f3[3 * t2], f3[3 * t2 + 1] = s2 * f3[3 * t2 + 1], f3[3 * t2 + 2] = s2 * f3[3 * t2 + 2];
    }
  }
  return f3;
}
function c2(o2, r3) {
  if (null == o2.encoding || "" === o2.encoding) {
    const t2 = g(r3, o2);
    if (t(t2.vertexAttributes.position))
      return;
    const l = f(r3, t2.vertexAttributes.position), i = t2.header.fields, u = [i.offsetX, i.offsetY, i.offsetZ], f3 = [i.scaleX, i.scaleY, i.scaleZ], c4 = l.length / 3, a4 = new Float64Array(3 * c4);
    for (let e2 = 0; e2 < c4; e2++)
      a4[3 * e2] = l[3 * e2] * f3[0] + u[0], a4[3 * e2 + 1] = l[3 * e2 + 1] * f3[1] + u[1], a4[3 * e2 + 2] = l[3 * e2 + 2] * f3[2] + u[2];
    return a4;
  }
  if ("lepcc-xyz" === o2.encoding)
    return c(r3).result;
}
function a3(e2, r3, t2) {
  return r(e2) && e2.attributeInfo.useElevation ? d2(r3, t2) : r(e2) ? I(e2.attributeInfo.storageInfo, e2.buffer, t2) : null;
}
function d2(e2, o2) {
  const r3 = new Float64Array(o2);
  for (let t2 = 0; t2 < o2; t2++)
    r3[t2] = e2[3 * t2 + 2];
  return r3;
}
function m(e2, o2, r3, t2, l) {
  const n2 = e2.length / 3;
  let s = 0;
  for (let i = 0; i < n2; i++) {
    let n3 = true;
    for (let e3 = 0; e3 < t2.length && n3; e3++) {
      const { filterJSON: o3 } = t2[e3], r4 = l[e3].values[i];
      switch (o3.type) {
        case "pointCloudValueFilter": {
          const e4 = "exclude" === o3.mode;
          o3.values.includes(r4) === e4 && (n3 = false);
          break;
        }
        case "pointCloudBitfieldFilter": {
          const e4 = b(o3.requiredSetBits), t3 = b(o3.requiredClearBits);
          (r4 & e4) === e4 && 0 == (r4 & t3) || (n3 = false);
          break;
        }
        case "pointCloudReturnFilter": {
          const e4 = 15 & r4, t3 = r4 >>> 4 & 15, l2 = t3 > 1, s2 = 1 === e4, i2 = e4 === t3;
          let u = false;
          for (const r5 of o3.includedReturns)
            if ("last" === r5 && i2 || "firstOfMany" === r5 && s2 && l2 || "lastOfMany" === r5 && i2 && l2 || "single" === r5 && !l2) {
              u = true;
              break;
            }
          u || (n3 = false);
          break;
        }
      }
    }
    n3 && (r3[s] = i, e2[3 * s] = e2[3 * i], e2[3 * s + 1] = e2[3 * i + 1], e2[3 * s + 2] = e2[3 * i + 2], o2[3 * s] = o2[3 * i], o2[3 * s + 1] = o2[3 * i + 1], o2[3 * s + 2] = o2[3 * i + 2], s++);
  }
  return s;
}
function p(e2) {
  return null == e2 || "none" === e2 ? null : "low-four-bit" === e2 ? (e3) => 15 & e3 : "high-four-bit" === e2 ? (e3) => (240 & e3) >> 4 : "absolute-value" === e2 ? (e3) => Math.abs(e3) : "modulo-ten" === e2 ? (e3) => e3 % 10 : null;
}
function b(e2) {
  let o2 = 0;
  for (const r3 of e2 || [])
    o2 |= 1 << r3;
  return o2;
}

// node_modules/@arcgis/core/views/3d/layers/PointCloudWorker.js
var c3 = class {
  transform(e2) {
    const a4 = this._transform(e2), o2 = [a4.points.buffer, a4.rgb.buffer];
    r(a4.pointIdFilterMap) && o2.push(a4.pointIdFilterMap.buffer);
    for (const t2 of a4.attributes)
      "buffer" in t2.values && o(t2.values.buffer) && t2.values.buffer !== a4.rgb.buffer && o2.push(t2.values.buffer);
    return Promise.resolve({ result: a4, transferList: o2 });
  }
  _transform(r3) {
    const e2 = c2(r3.schema, r3.geometryBuffer);
    let a4 = e2.length / 3, o2 = null;
    const f3 = [], n2 = a3(r3.primaryAttributeData, e2, a4);
    r(r3.primaryAttributeData) && n2 && f3.push({ attributeInfo: r3.primaryAttributeData.attributeInfo, values: n2 });
    const s = a3(r3.modulationAttributeData, e2, a4);
    r(r3.modulationAttributeData) && s && f3.push({ attributeInfo: r3.modulationAttributeData.attributeInfo, values: s });
    let c4 = f2(r3.rendererInfo, n2, s, a4);
    if (r3.filterInfo && r3.filterInfo.length > 0 && r(r3.filterAttributesData)) {
      const t2 = r3.filterAttributesData.map((t3) => {
        const r4 = a3(t3, e2, a4), o3 = { attributeInfo: t3.attributeInfo, values: r4 };
        return f3.push(o3), o3;
      });
      o2 = new Uint32Array(a4), a4 = m(e2, c4, o2, r3.filterInfo, t2);
    }
    for (const t2 of r3.userAttributesData) {
      const r4 = a3(t2, e2, a4);
      f3.push({ attributeInfo: t2.attributeInfo, values: r4 });
    }
    3 * a4 < c4.length && (c4 = new Uint8Array(c4.buffer.slice(0, 3 * a4))), this._applyElevationOffsetInPlace(e2, a4, r3.elevationOffset);
    const p3 = this._transformCoordinates(e2, a4, r3.obb, k.fromJSON(r3.inSR), k.fromJSON(r3.outSR));
    return { obb: r3.obb, points: p3, rgb: c4, attributes: f3, pointIdFilterMap: o2 };
  }
  _transformCoordinates(t2, r3, a4, i, u) {
    if (!xn(t2, i, 0, t2, u, 0, r3))
      throw new Error("Can't reproject");
    const l = r2(a4.center[0], a4.center[1], a4.center[2]), b2 = n(), m2 = n();
    S(p2, a4.quaternion);
    const c4 = new Float32Array(3 * r3);
    for (let e2 = 0; e2 < r3; e2++)
      b2[0] = t2[3 * e2] - l[0], b2[1] = t2[3 * e2 + 1] - l[1], b2[2] = t2[3 * e2 + 2] - l[2], E(m2, b2, p2), a4.halfSize[0] = Math.max(a4.halfSize[0], Math.abs(m2[0])), a4.halfSize[1] = Math.max(a4.halfSize[1], Math.abs(m2[1])), a4.halfSize[2] = Math.max(a4.halfSize[2], Math.abs(m2[2])), c4[3 * e2] = b2[0], c4[3 * e2 + 1] = b2[1], c4[3 * e2 + 2] = b2[2];
    return c4;
  }
  _applyElevationOffsetInPlace(t2, r3, e2) {
    if (0 !== e2)
      for (let a4 = 0; a4 < r3; a4++)
        t2[3 * a4 + 2] += e2;
  }
};
var p2 = e();
function h() {
  return new c3();
}
export {
  h as default
};
//# sourceMappingURL=PointCloudWorker-K7YKLZ6M.js.map
