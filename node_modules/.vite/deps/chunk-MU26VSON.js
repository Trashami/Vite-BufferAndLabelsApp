import {
  i as i7,
  n as n6
} from "./chunk-5HIF32ZE.js";
import {
  a as a3,
  f as f6,
  g,
  j as j3,
  me,
  n as n2
} from "./chunk-57QYUXCA.js";
import {
  i as i6
} from "./chunk-J42Y5N2P.js";
import {
  c as c2,
  i as i4,
  n as n5,
  r as r4
} from "./chunk-JHLU6RPN.js";
import {
  M
} from "./chunk-EPMXCACW.js";
import {
  l
} from "./chunk-KUO7OCMN.js";
import {
  C,
  N,
  O,
  P,
  U,
  Z,
  b,
  f as f4,
  w as w2
} from "./chunk-KG5RWWIW.js";
import {
  a as a2,
  c,
  i as i5,
  n as n3,
  o as o6,
  r as r5,
  s as s6
} from "./chunk-27YO3FKC.js";
import {
  f as f2,
  p as p2
} from "./chunk-XBFCIW4K.js";
import {
  G,
  ee,
  f as f3,
  s as s5,
  te
} from "./chunk-6TBB7UXB.js";
import {
  w,
  x
} from "./chunk-UO3LS2M5.js";
import {
  E,
  S
} from "./chunk-EQNT4A7P.js";
import {
  s as s4
} from "./chunk-R24MO4IV.js";
import {
  e as e4,
  i as i2,
  o as o3
} from "./chunk-QISOH77W.js";
import {
  X,
  at,
  ct,
  et,
  f,
  ft,
  gt,
  ht,
  i as i3,
  j as j2,
  k,
  lt,
  mt,
  nt as nt2,
  o as o4,
  pt,
  rt,
  st,
  vt
} from "./chunk-XO5VJRK4.js";
import {
  e as e3
} from "./chunk-TFHLTN6F.js";
import {
  n,
  t as t4
} from "./chunk-UDYHZLTE.js";
import {
  n as n4
} from "./chunk-JEA4MMTV.js";
import {
  e as e5,
  f as f5
} from "./chunk-RG3AHHRL.js";
import {
  t as t3
} from "./chunk-SQSR6K2M.js";
import {
  r as r3,
  z
} from "./chunk-75RMBUYZ.js";
import {
  Gt,
  nt
} from "./chunk-TJ2I6XQT.js";
import {
  t as t2
} from "./chunk-34YPGGJT.js";
import {
  r as r2,
  s as s3,
  y
} from "./chunk-A4HIS5ZJ.js";
import {
  e as e2
} from "./chunk-E52E6T7N.js";
import {
  o as o5
} from "./chunk-DER356EU.js";
import {
  o as o2,
  u
} from "./chunk-NRP45AHD.js";
import {
  a
} from "./chunk-C5H57NTD.js";
import {
  D,
  j,
  p
} from "./chunk-MJXQTGI2.js";
import {
  s as s2
} from "./chunk-LIZHLHNA.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";
import {
  e,
  i,
  o,
  r,
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/heuristics.js
var i8 = /* @__PURE__ */ new Map();
function t5(r13, t10, c9) {
  const { indicesPerRecord: s9, multiplier: o11, verticesPerRecord: d7 } = i8.get(r13);
  return { recordBytes: c9 * ct * Uint32Array.BYTES_PER_ELEMENT, indexBytes: o11 * s9 * c9 * Uint32Array.BYTES_PER_ELEMENT, vertexBytes: o11 * d7 * c9 * t10 };
}
i8.set(E.MARKER, { multiplier: 1, indicesPerRecord: 6, verticesPerRecord: 4 }), i8.set(E.LINE, { multiplier: 1, indicesPerRecord: 24, verticesPerRecord: 8 }), i8.set(E.FILL, { multiplier: 1, indicesPerRecord: 10, verticesPerRecord: 10 }), i8.set(E.TEXT, { multiplier: 8, indicesPerRecord: 6, verticesPerRecord: 4 }), i8.set(E.LABEL, { multiplier: 8, indicesPerRecord: 6, verticesPerRecord: 4 });

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Writer.js
var t6 = 1.25;
var e6 = class {
  constructor(t10, e11) {
    this._pos = 0;
    const r13 = e11 ? this._roundToNearest(e11, t10.BYTES_PER_ELEMENT) : 40;
    this._array = new ArrayBuffer(r13), this._buffer = new t10(this._array), this._ctor = t10, this._i16View = new Int16Array(this._array);
  }
  get length() {
    return this._pos;
  }
  _roundToNearest(t10, e11) {
    const r13 = Math.round(t10);
    return r13 + (e11 - r13 % e11);
  }
  _ensureSize(e11) {
    if (this._pos + e11 >= this._buffer.length) {
      const r13 = this._roundToNearest((this._array.byteLength + e11 * this._buffer.BYTES_PER_ELEMENT) * t6, this._buffer.BYTES_PER_ELEMENT), s9 = new ArrayBuffer(r13), i12 = new this._ctor(s9);
      i12.set(this._buffer, 0), this._array = s9, this._buffer = i12, this._i16View = new Int16Array(this._array);
    }
  }
  ensureSize(t10) {
    this._ensureSize(t10);
  }
  writeF32(t10) {
    this._ensureSize(1);
    const e11 = this._pos;
    return new Float32Array(this._array, 4 * this._pos, 1)[0] = t10, this._pos++, e11;
  }
  push(t10) {
    this._ensureSize(1);
    const e11 = this._pos;
    return this._buffer[this._pos++] = t10, e11;
  }
  writeFixed(t10) {
    this._buffer[this._pos++] = t10;
  }
  setValue(t10, e11) {
    this._buffer[t10] = e11;
  }
  i1616Add(t10, e11, r13) {
    this._i16View[2 * t10] += e11, this._i16View[2 * t10 + 1] += r13;
  }
  getValue(t10) {
    return this._buffer[t10];
  }
  incr(t10) {
    if (this._buffer.length < t10)
      throw new Error("Increment index overflows the target buffer");
    this._buffer[t10]++;
  }
  decr(t10) {
    this._buffer[t10]--;
  }
  writeRegion(t10) {
    this._ensureSize(t10.length);
    const e11 = this._pos;
    return this._buffer.set(t10, this._pos), this._pos += t10.length, e11;
  }
  writeManyFrom(t10, e11, r13) {
    this._ensureSize(r13 - e11);
    for (let s9 = e11; s9 !== r13; s9++)
      this.writeFixed(t10._buffer[s9]);
  }
  buffer() {
    const t10 = this._array.slice(0, 4 * this._pos);
    return this.destroy(), t10;
  }
  toArray() {
    const t10 = this._array, e11 = [];
    for (let r13 = 0; r13 < t10.byteLength / 4; r13++)
      e11.push(t10[r13]);
    return e11;
  }
  seek(t10) {
    this._pos = t10;
  }
  destroy() {
    this._array = null, this._buffer = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/VertexDataWriter.js
var r6 = class {
  constructor(e11, r13, i12) {
    this._start = { index: 0, vertex: 0 };
    const h5 = t5(e11, r13, i12), c9 = r13 / 4;
    this.geometryType = e11, this._records = new e6(Int32Array, h5.recordBytes), this._indices = new e6(Uint32Array, h5.indexBytes), this._vertices = new e6(Uint32Array, h5.vertexBytes), this._metrics = new e6(Float32Array, 0), this._strideInt = c9;
  }
  serialize(e11) {
    const t10 = this._records.buffer(), s9 = this._indices.buffer(), r13 = this._vertices.buffer(), i12 = this._metrics.length ? this._metrics.buffer() : null, h5 = 4 * this._strideInt;
    return e11.push(t10, s9, r13), { stride: h5, records: t10, indices: s9, vertices: r13, metrics: i12 };
  }
  get strideInt() {
    return this._strideInt;
  }
  get recordCount() {
    return this._records.length / ct;
  }
  get vertexCount() {
    return this._vertices.length / this._strideInt;
  }
  get indexCount() {
    return this._indices.length;
  }
  get indexWriter() {
    return this._indices;
  }
  get vertexWriter() {
    return this._vertices;
  }
  get metricWriter() {
    return this._metrics;
  }
  vertexEnsureSize(e11) {
    this._vertices.ensureSize(e11);
  }
  indexEnsureSize(e11) {
    this._indices.ensureSize(e11);
  }
  recordStart() {
    this._start.index = this._indices.length, this._start.vertex = this._vertices.length;
  }
  recordEnd(e11, t10, s9, r13, i12, h5, c9, n10) {
    this._records.push(e11), this._records.push(t10), this._records.push(s9), this._records.push(r13), this._records.push(i12), this._records.push(h5), this._records.push(c9), this._records.writeF32(n10);
  }
  writeIndex(e11) {
    this._indices.push(e11);
  }
  writeVertex(e11) {
    this._vertices.push(e11);
  }
  writeVertexF32(e11) {
    this._vertices.writeF32(e11);
  }
  copyLastFrom(t10, s9, r13) {
    const i12 = t10._records.length - ct, h5 = t10._records.getValue(i12), c9 = t10._records.getValue(i12 + 1), n10 = t10._records.getValue(i12 + 2), _5 = t10._records.getValue(i12 + 4), d7 = t10._records.getValue(i12 + 6), o11 = t10._records.getValue(i12 + 7), u12 = this._vertices.length, l7 = (t10._start.vertex - this._vertices.length) / this._strideInt, g9 = this._indices.length, p9 = this.vertexCount;
    for (let e11 = t10._start.index; e11 !== t10._indices.length; e11++) {
      const s10 = t10._indices.getValue(e11);
      this._indices.push(s10 - l7);
    }
    for (let e11 = t10._start.vertex; e11 !== t10._vertices.length; e11++) {
      const s10 = t10._vertices.getValue(e11);
      this._vertices.push(s10);
    }
    for (let e11 = u12; e11 <= this._vertices.length; e11 += this._strideInt)
      this._vertices.i1616Add(e11, s9, r13);
    this._records.push(h5), this._records.push(c9), this._records.push(n10), this._records.push(g9), this._records.push(_5), this._records.push(p9), this._records.push(d7), this._records.push(o11);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/MeshData.js
var u2 = 1;
var c3 = 2;
var o7 = 4;
var _ = 8;
var l2 = 16;
var d = 32;
var g2 = 64;
var p3 = 128;
function x2(e11) {
  switch (e11) {
    case u2:
    case _:
    case d:
      return -1;
    case c3:
    case g2:
      return 0;
    case o7:
    case l2:
    case p3:
      return 1;
  }
}
function m(e11) {
  switch (e11) {
    case u2:
    case c3:
    case o7:
      return -1;
    case _:
    case l2:
      return 0;
    case d:
    case g2:
    case p3:
      return 1;
  }
}
var f7 = u2 | _ | d;
var y2 = o7 | l2 | p3;
var w3 = u2 | c3 | o7;
var v = d | g2 | p3;
var E2 = class {
  constructor(e11, t10, r13, i12, s9, n10 = 0) {
    this._hasAggregate = false, this.hasRecords = false, this._data = { self: /* @__PURE__ */ new Map(), neighbors: new Array() }, this._version = 0, this._current = { geometryType: 0, writer: null, overlaps: 0, start: 0, insertAfter: 0, sortKey: 0, id: 0, materialKey: 0, indexStart: 0, vertStart: 0, isDotDensity: false, bufferingEnabled: false, metricBoxLenPointer: 0 }, this.hint = t10, this.tileKey = e11, this._hasAggregate = i12, this._pixelBufferEnabled = s9, this._version = n10, this._symbologyType = r13;
  }
  get hasAggregates() {
    return this._hasAggregate;
  }
  get hasPixelBufferEnabled() {
    return this._pixelBufferEnabled;
  }
  serialize(t10) {
    const r13 = [];
    return r13.push(this._serializeTileVertexData(this.tileKey, this.tileKey, this._data.self)), this._data.neighbors.forEach((i12, s9) => {
      const n10 = 1 << s9, a7 = x2(n10), u12 = m(n10), c9 = l(new e3(this.tileKey), a7, u12, t10), o11 = this._serializeTileVertexData(this.tileKey, c9.id, i12.vertexData);
      o11.message.bufferIds = i12.displayIds, r13.push(o11);
    }), r13;
  }
  _serializeTileVertexData(e11, t10, r13) {
    var _a, _b, _c, _d, _e;
    const i12 = new Array();
    return { message: { tileKeyOrigin: e11, tileKey: t10, data: { [E.MARKER]: (_a = r13.get(E.MARKER)) == null ? void 0 : _a.serialize(i12), [E.FILL]: (_b = r13.get(E.FILL)) == null ? void 0 : _b.serialize(i12), [E.LINE]: (_c = r13.get(E.LINE)) == null ? void 0 : _c.serialize(i12), [E.TEXT]: (_d = r13.get(E.TEXT)) == null ? void 0 : _d.serialize(i12), [E.LABEL]: (_e = r13.get(E.LABEL)) == null ? void 0 : _e.serialize(i12) }, version: this._version }, transferList: i12 };
  }
  featureStart(e11, t10) {
    this._current.insertAfter = e11, this._current.sortKey = t10;
  }
  featureEnd() {
  }
  recordStart(e11, t10, r13, i12) {
    this._current.writer = this._getVertexWriter(r13), this._current.overlaps = 0, this._current.indexStart = this._current.writer.indexCount, this._current.vertStart = this._current.writer.vertexCount, this._current.bufferingEnabled = i12, this._current.id = e11, this._current.materialKey = t10, this._current.geometryType = r13, this._current.isDotDensity = false, this._current.writer.recordStart();
  }
  recordCount() {
    return this._current.writer.recordCount;
  }
  vertexCount() {
    return this._current.writer.vertexCount;
  }
  indexCount() {
    return this._current.writer.indexCount;
  }
  vertexEnsureSize(e11) {
    this._current.writer.vertexEnsureSize(e11);
  }
  indexEnsureSize(e11) {
    this._current.writer.indexEnsureSize(e11);
  }
  vertexBounds(e11, t10, r13, i12) {
    this._current.bufferingEnabled && this._addOverlap(e11, t10, r13, i12);
  }
  vertexWrite(e11) {
    this._current.writer.writeVertex(e11);
  }
  vertexWriteF32(e11) {
    this._current.writer.writeVertexF32(e11);
  }
  vertexEnd() {
  }
  vertexWriter() {
    return this._current.writer.vertexWriter;
  }
  indexWrite(e11) {
    this._current.writer.writeIndex(e11);
  }
  indexWriter() {
    return this._current.writer.indexWriter;
  }
  metricWriter() {
    return this._current.writer.metricWriter;
  }
  metricStart(e11, t10, r13, n10, a7, h5, u12, c9) {
    this._current.writer = this._getVertexWriter(E.LABEL);
    const o11 = this._current.writer.metricWriter;
    o11.push(f2(e11)), o11.push(t10), o11.push(r13), o11.push(n10), o11.push(a7), o11.push(h5), o11.push(u12), o11.push(c9), o11.push(255), this._current.metricBoxLenPointer = o11.push(0);
  }
  metricEnd() {
    const e11 = this._current.writer.metricWriter;
    0 === e11.getValue(this._current.metricBoxLenPointer) && e11.seek(e11.length - 10);
  }
  metricBoxWrite(e11, t10, r13, i12) {
    const s9 = this._current.writer.metricWriter;
    s9.incr(this._current.metricBoxLenPointer), s9.push(0), s9.push(0), s9.push(e11), s9.push(t10), s9.push(r13), s9.push(i12);
  }
  recordEnd() {
    const e11 = this._current.vertStart, r13 = this._current.writer.vertexCount - e11;
    if (!r13)
      return false;
    this.hasRecords = true;
    const i12 = this._current.indexStart, h5 = this._current.writer.indexCount - i12;
    if (this._current.writer.recordEnd(this._current.id, this._current.materialKey, this._current.insertAfter, i12, h5, e11, r13, this._current.sortKey), !this._pixelBufferEnabled || this._hasAggregate || 0 === this._current.overlaps || this._current.geometryType === E.LABEL)
      return true;
    const u12 = this._current.writer;
    for (let s9 = 0; s9 < 8; s9++) {
      const e12 = 1 << s9;
      if (!!(this._current.overlaps & e12)) {
        this._data.neighbors[s9] || (this._data.neighbors[s9] = { vertexData: /* @__PURE__ */ new Map(), displayIds: /* @__PURE__ */ new Set() });
        const r14 = this._data.neighbors[s9], i13 = this._current.geometryType;
        if (!r14.vertexData.has(i13)) {
          const e13 = G(i13, this._symbologyType).geometry, s10 = new r6(i13, e13, ht);
          r14.vertexData.set(i13, s10);
        }
        const h6 = r14.vertexData.get(this._current.geometryType), c9 = 8, o11 = 512 * -x2(e12) * c9, _5 = 512 * -m(e12) * c9;
        h6.copyLastFrom(u12, o11, _5), r14.displayIds.add(this._current.id);
      }
    }
    return true;
  }
  _addOverlap(e11, t10, i12, s9) {
    const n10 = 255 ^ ((e11 < 0 + i12 ? y2 : e11 >= o4 - i12 ? f7 : y2 | f7) | (t10 < 0 + s9 ? v : t10 >= o4 - s9 ? w3 : v | w3));
    this._current.overlaps |= n10;
  }
  _getVertexWriter(e11) {
    if (!this._data.self.has(e11)) {
      const t10 = this._data.self, r13 = G(e11, this._symbologyType).geometry;
      t10.set(e11, new r6(e11, r13, this.hint.records));
    }
    return this._data.self.get(e11);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/textUtils.js
function t7(t10) {
  const e11 = new Array(t10.length);
  for (let n10 = 0; n10 < t10.length; n10++)
    e11[n10] = t10.charCodeAt(n10);
  return e11;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/util.js
var n7 = 0;
var o8 = 100;
function t8(n10, o11, t10) {
  return n10[0] = o11[0] - t10[0], n10[1] = o11[1] - t10[1], n10;
}
function i9(n10, o11) {
  return Math.sqrt(n10 * n10 + o11 * o11);
}
function r7(n10) {
  const o11 = i9(n10[0], n10[1]);
  n10[0] /= o11, n10[1] /= o11;
}
function u3(n10, o11) {
  return i9(n10[0] - o11[0], n10[1] - o11[1]);
}
function c4(n10) {
  return "function" == typeof n10;
}
function e7(n10 = 2) {
  return 1 / Math.max(n10, 1);
}
function x3(t10, i12) {
  return [!!t10.minScale && i12.scaleToZoom(t10.minScale) || n7, !!t10.maxScale && i12.scaleToZoom(t10.maxScale) || o8];
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/bufcut.js
function e8(e11, t10, r13, i12, u12, o11, l7) {
  D2 = 0;
  const f14 = (i12 - r13) * o11, p9 = u12 && u12.length, c9 = p9 ? (u12[0] - r13) * o11 : f14;
  let v5, s9, h5, d7, Z4, a7 = n8(t10, r13, i12, 0, c9, o11, true);
  if (a7 && a7.next !== a7.prev) {
    if (p9 && (a7 = y3(t10, r13, i12, u12, a7, o11)), f14 > 80 * o11) {
      v5 = h5 = t10[0 + r13 * o11], s9 = d7 = t10[1 + r13 * o11];
      for (let e12 = o11; e12 < c9; e12 += o11) {
        const n10 = t10[e12 + r13 * o11], x10 = t10[e12 + 1 + r13 * o11];
        v5 = Math.min(v5, n10), s9 = Math.min(s9, x10), h5 = Math.max(h5, n10), d7 = Math.max(d7, x10);
      }
      Z4 = Math.max(h5 - v5, d7 - s9), Z4 = 0 !== Z4 ? 1 / Z4 : 0;
    }
    x4(a7, e11, o11, v5, s9, Z4, l7, 0);
  }
}
function n8(e11, n10, t10, x10, r13, i12, l7) {
  let y7;
  if (l7 === Z2(e11, n10, t10, x10, r13, i12) > 0)
    for (let o11 = x10; o11 < r13; o11 += i12)
      y7 = u4(o11 + n10 * i12, e11[o11 + n10 * i12], e11[o11 + 1 + n10 * i12], y7);
  else
    for (let o11 = r13 - i12; o11 >= x10; o11 -= i12)
      y7 = u4(o11 + n10 * i12, e11[o11 + n10 * i12], e11[o11 + 1 + n10 * i12], y7);
  return y7 && M2(y7, y7.next) && (o9(y7), y7 = y7.next), y7;
}
function t9(e11, n10 = e11) {
  if (!e11)
    return e11;
  let t10, x10 = e11;
  do {
    if (t10 = false, x10.steiner || !M2(x10, x10.next) && 0 !== s7(x10.prev, x10, x10.next))
      x10 = x10.next;
    else {
      if (o9(x10), x10 = n10 = x10.prev, x10 === x10.next)
        break;
      t10 = true;
    }
  } while (t10 || x10 !== n10);
  return n10;
}
function x4(e11, n10, u12, l7, y7, f14, p9, v5) {
  if (!e11)
    return;
  !v5 && f14 && (e11 = c5(e11, l7, y7, f14));
  let s9 = e11;
  for (; e11.prev !== e11.next; ) {
    const c9 = e11.prev, h5 = e11.next;
    if (f14 ? i10(e11, l7, y7, f14) : r8(e11))
      n10.push(c9.index / u12 + p9), n10.push(e11.index / u12 + p9), n10.push(h5.index / u12 + p9), o9(e11), e11 = h5.next, s9 = h5.next;
    else if ((e11 = h5) === s9) {
      v5 ? 1 === v5 ? x4(e11 = b2(e11, n10, u12, p9), n10, u12, l7, y7, f14, p9, 2) : 2 === v5 && g3(e11, n10, u12, l7, y7, f14, p9) : x4(t9(e11), n10, u12, l7, y7, f14, p9, 1);
      break;
    }
  }
}
function r8(e11) {
  const n10 = e11.prev, t10 = e11, x10 = e11.next;
  if (s7(n10, t10, x10) >= 0)
    return false;
  let r13 = e11.next.next;
  const i12 = r13;
  let u12 = 0;
  for (; r13 !== e11.prev && (0 === u12 || r13 !== i12); ) {
    if (u12++, a4(n10.x, n10.y, t10.x, t10.y, x10.x, x10.y, r13.x, r13.y) && s7(r13.prev, r13, r13.next) >= 0)
      return false;
    r13 = r13.next;
  }
  return true;
}
function i10(e11, n10, t10, x10) {
  const r13 = e11.prev, i12 = e11, u12 = e11.next;
  if (s7(r13, i12, u12) >= 0)
    return false;
  const o11 = r13.x < i12.x ? r13.x < u12.x ? r13.x : u12.x : i12.x < u12.x ? i12.x : u12.x, l7 = r13.y < i12.y ? r13.y < u12.y ? r13.y : u12.y : i12.y < u12.y ? i12.y : u12.y, y7 = r13.x > i12.x ? r13.x > u12.x ? r13.x : u12.x : i12.x > u12.x ? i12.x : u12.x, f14 = r13.y > i12.y ? r13.y > u12.y ? r13.y : u12.y : i12.y > u12.y ? i12.y : u12.y, p9 = z2(o11, l7, n10, t10, x10), c9 = z2(y7, f14, n10, t10, x10);
  let v5 = e11.prevZ, h5 = e11.nextZ;
  for (; v5 && v5.z >= p9 && h5 && h5.z <= c9; ) {
    if (v5 !== e11.prev && v5 !== e11.next && a4(r13.x, r13.y, i12.x, i12.y, u12.x, u12.y, v5.x, v5.y) && s7(v5.prev, v5, v5.next) >= 0)
      return false;
    if (v5 = v5.prevZ, h5 !== e11.prev && h5 !== e11.next && a4(r13.x, r13.y, i12.x, i12.y, u12.x, u12.y, h5.x, h5.y) && s7(h5.prev, h5, h5.next) >= 0)
      return false;
    h5 = h5.nextZ;
  }
  for (; v5 && v5.z >= p9; ) {
    if (v5 !== e11.prev && v5 !== e11.next && a4(r13.x, r13.y, i12.x, i12.y, u12.x, u12.y, v5.x, v5.y) && s7(v5.prev, v5, v5.next) >= 0)
      return false;
    v5 = v5.prevZ;
  }
  for (; h5 && h5.z <= c9; ) {
    if (h5 !== e11.prev && h5 !== e11.next && a4(r13.x, r13.y, i12.x, i12.y, u12.x, u12.y, h5.x, h5.y) && s7(h5.prev, h5, h5.next) >= 0)
      return false;
    h5 = h5.nextZ;
  }
  return true;
}
function u4(e11, n10, t10, x10) {
  const r13 = q.create(e11, n10, t10);
  return x10 ? (r13.next = x10.next, r13.prev = x10, x10.next.prev = r13, x10.next = r13) : (r13.prev = r13, r13.next = r13), r13;
}
function o9(e11) {
  e11.next.prev = e11.prev, e11.prev.next = e11.next, e11.prevZ && (e11.prevZ.nextZ = e11.nextZ), e11.nextZ && (e11.nextZ.prevZ = e11.prevZ);
}
function l3(e11) {
  let n10 = e11, t10 = e11;
  do {
    (n10.x < t10.x || n10.x === t10.x && n10.y < t10.y) && (t10 = n10), n10 = n10.next;
  } while (n10 !== e11);
  return t10;
}
function y3(e11, t10, x10, r13, i12, u12) {
  const o11 = new Array();
  for (let y7 = 0, f14 = r13.length; y7 < f14; y7++) {
    const i13 = n8(e11, t10, x10, r13[y7] * u12, y7 < f14 - 1 ? r13[y7 + 1] * u12 : x10 * u12, u12, false);
    i13 === i13.next && (i13.steiner = true), o11.push(l3(i13));
  }
  o11.sort(m2);
  for (const n10 of o11)
    i12 = f8(n10, i12);
  return i12;
}
function f8(e11, n10) {
  const x10 = p4(e11, n10);
  if (!x10)
    return n10;
  const r13 = j4(x10, e11);
  return t9(r13, r13.next), t9(x10, x10.next);
}
function p4(e11, n10) {
  let t10 = n10;
  const x10 = e11.x, r13 = e11.y;
  let i12, u12 = -1 / 0;
  do {
    if (r13 <= t10.y && r13 >= t10.next.y && t10.next.y !== t10.y) {
      const e12 = t10.x + (r13 - t10.y) * (t10.next.x - t10.x) / (t10.next.y - t10.y);
      if (e12 <= x10 && e12 > u12) {
        if (u12 = e12, e12 === x10) {
          if (r13 === t10.y)
            return t10;
          if (r13 === t10.next.y)
            return t10.next;
        }
        i12 = t10.x < t10.next.x ? t10 : t10.next;
      }
    }
    t10 = t10.next;
  } while (t10 !== n10);
  if (!i12)
    return null;
  if (x10 === u12)
    return i12.prev;
  const o11 = i12, l7 = i12.x, y7 = i12.y;
  let f14, p9 = 1 / 0;
  for (t10 = i12.next; t10 !== o11; )
    x10 >= t10.x && t10.x >= l7 && x10 !== t10.x && a4(r13 < y7 ? x10 : u12, r13, l7, y7, r13 < y7 ? u12 : x10, r13, t10.x, t10.y) && (f14 = Math.abs(r13 - t10.y) / (x10 - t10.x), (f14 < p9 || f14 === p9 && t10.x > i12.x) && w4(t10, e11) && (i12 = t10, p9 = f14)), t10 = t10.next;
  return i12;
}
function c5(e11, n10, t10, x10) {
  for (let r13; r13 !== e11; r13 = r13.next) {
    if (r13 = r13 || e11, null === r13.z && (r13.z = z2(r13.x, r13.y, n10, t10, x10)), r13.prev.next !== r13 || r13.next.prev !== r13)
      return r13.prev.next = r13, r13.next.prev = r13, c5(e11, n10, t10, x10);
    r13.prevZ = r13.prev, r13.nextZ = r13.next;
  }
  return e11.prevZ.nextZ = null, e11.prevZ = null, v2(e11);
}
function v2(e11) {
  let n10, t10 = 1;
  for (; ; ) {
    let x10, r13 = e11;
    e11 = null, n10 = null;
    let i12 = 0;
    for (; r13; ) {
      i12++, x10 = r13;
      let u12 = 0;
      for (; u12 < t10 && x10; u12++)
        x10 = x10.nextZ;
      let o11 = t10;
      for (; u12 > 0 || o11 > 0 && x10; ) {
        let t11;
        0 === u12 ? (t11 = x10, x10 = x10.nextZ, o11--) : 0 !== o11 && x10 ? r13.z <= x10.z ? (t11 = r13, r13 = r13.nextZ, u12--) : (t11 = x10, x10 = x10.nextZ, o11--) : (t11 = r13, r13 = r13.nextZ, u12--), n10 ? n10.nextZ = t11 : e11 = t11, t11.prevZ = n10, n10 = t11;
      }
      r13 = x10;
    }
    if (n10.nextZ = null, t10 *= 2, i12 < 2)
      return e11;
  }
}
function s7(e11, n10, t10) {
  return (n10.y - e11.y) * (t10.x - n10.x) - (n10.x - e11.x) * (t10.y - n10.y);
}
function h(e11, n10, t10, x10) {
  return !!(M2(e11, n10) && M2(t10, x10) || M2(e11, x10) && M2(t10, n10)) || s7(e11, n10, t10) > 0 != s7(e11, n10, x10) > 0 && s7(t10, x10, e11) > 0 != s7(t10, x10, n10) > 0;
}
function d2(e11, n10) {
  let t10 = e11;
  do {
    if (t10.index !== e11.index && t10.next.index !== e11.index && t10.index !== n10.index && t10.next.index !== n10.index && h(t10, t10.next, e11, n10))
      return true;
    t10 = t10.next;
  } while (t10 !== e11);
  return false;
}
function Z2(e11, n10, t10, x10, r13, i12) {
  let u12 = 0;
  for (let o11 = x10, l7 = r13 - i12; o11 < r13; o11 += i12)
    u12 += (e11[l7 + n10 * i12] - e11[o11 + n10 * i12]) * (e11[o11 + 1 + n10 * i12] + e11[l7 + 1 + n10 * i12]), l7 = o11;
  return u12;
}
function a4(e11, n10, t10, x10, r13, i12, u12, o11) {
  return (r13 - u12) * (n10 - o11) - (e11 - u12) * (i12 - o11) >= 0 && (e11 - u12) * (x10 - o11) - (t10 - u12) * (n10 - o11) >= 0 && (t10 - u12) * (i12 - o11) - (r13 - u12) * (x10 - o11) >= 0;
}
function w4(e11, n10) {
  return s7(e11.prev, e11, e11.next) < 0 ? s7(e11, n10, e11.next) >= 0 && s7(e11, e11.prev, n10) >= 0 : s7(e11, n10, e11.prev) < 0 || s7(e11, e11.next, n10) < 0;
}
function z2(e11, n10, t10, x10, r13) {
  return (e11 = 1431655765 & ((e11 = 858993459 & ((e11 = 252645135 & ((e11 = 16711935 & ((e11 = 32767 * (e11 - t10) * r13) | e11 << 8)) | e11 << 4)) | e11 << 2)) | e11 << 1)) | (n10 = 1431655765 & ((n10 = 858993459 & ((n10 = 252645135 & ((n10 = 16711935 & ((n10 = 32767 * (n10 - x10) * r13) | n10 << 8)) | n10 << 4)) | n10 << 2)) | n10 << 1)) << 1;
}
function M2(e11, n10) {
  return e11.x === n10.x && e11.y === n10.y;
}
function m2(e11, n10) {
  return e11.x - n10.x;
}
function b2(e11, n10, t10, x10) {
  let r13 = e11;
  do {
    const i12 = r13.prev, u12 = r13.next.next;
    !M2(i12, u12) && h(i12, r13, r13.next, u12) && w4(i12, u12) && w4(u12, i12) && (n10.push(i12.index / t10 + x10), n10.push(r13.index / t10 + x10), n10.push(u12.index / t10 + x10), o9(r13), o9(r13.next), r13 = e11 = u12), r13 = r13.next;
  } while (r13 !== e11);
  return r13;
}
function g3(e11, n10, r13, i12, u12, o11, l7) {
  let y7 = e11;
  do {
    let e12 = y7.next.next;
    for (; e12 !== y7.prev; ) {
      if (y7.index !== e12.index && k2(y7, e12)) {
        let f14 = j4(y7, e12);
        return y7 = t9(y7, y7.next), f14 = t9(f14, f14.next), x4(y7, n10, r13, i12, u12, o11, l7, 0), void x4(f14, n10, r13, i12, u12, o11, l7, 0);
      }
      e12 = e12.next;
    }
    y7 = y7.next;
  } while (y7 !== e11);
}
function k2(e11, n10) {
  return e11.next.index !== n10.index && e11.prev.index !== n10.index && !d2(e11, n10) && w4(e11, n10) && w4(n10, e11) && A(e11, n10);
}
function A(e11, n10) {
  let t10 = e11, x10 = false;
  const r13 = (e11.x + n10.x) / 2, i12 = (e11.y + n10.y) / 2;
  do {
    t10.y > i12 != t10.next.y > i12 && t10.next.y !== t10.y && r13 < (t10.next.x - t10.x) * (i12 - t10.y) / (t10.next.y - t10.y) + t10.x && (x10 = !x10), t10 = t10.next;
  } while (t10 !== e11);
  return x10;
}
function j4(e11, n10) {
  const t10 = q.create(e11.index, e11.x, e11.y), x10 = q.create(n10.index, n10.x, n10.y), r13 = e11.next, i12 = n10.prev;
  return e11.next = n10, n10.prev = e11, t10.next = r13, r13.prev = t10, x10.next = t10, t10.prev = x10, i12.next = x10, x10.prev = i12, x10;
}
var q = class {
  constructor() {
    this.index = 0, this.x = 0, this.y = 0, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
  }
  static create(e11, n10, t10) {
    const x10 = D2 < B.length ? B[D2++] : new q();
    return x10.index = e11, x10.x = n10, x10.y = t10, x10.prev = null, x10.next = null, x10.z = null, x10.prevZ = null, x10.nextZ = null, x10.steiner = false, x10;
  }
};
var B = new Array();
var C2 = 8096;
var D2 = 0;
for (let E4 = 0; E4 < C2; E4++)
  B.push(new q());

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/templateUtils.js
var f9 = 1e-5;
var c6 = new n5(0, 0, 0, 1, 0);
var u5 = new n5(0, 0, 0, 1, 0);
function h2(t10, e11, n10) {
  let o11 = 0;
  for (let r13 = 1; r13 < n10; r13++) {
    const n11 = t10[2 * (e11 + r13 - 1)], s9 = t10[2 * (e11 + r13 - 1) + 1];
    o11 += (t10[2 * (e11 + r13)] - n11) * (t10[2 * (e11 + r13) + 1] + s9);
  }
  return o11;
}
function g4(t10, e11, n10, o11, r13) {
  let s9 = 0;
  const l7 = 2;
  for (let i12 = n10; i12 < o11; i12 += 3) {
    const n11 = (t10[i12] - r13) * l7, o12 = (t10[i12 + 1] - r13) * l7, f14 = (t10[i12 + 2] - r13) * l7;
    s9 += Math.abs((e11[n11] - e11[f14]) * (e11[o12 + 1] - e11[n11 + 1]) - (e11[n11] - e11[o12]) * (e11[f14 + 1] - e11[n11 + 1]));
  }
  return s9;
}
function a5(t10, e11) {
  const { coords: n10, lengths: o11, hasIndeterminateRingOrder: r13 } = e11, s9 = 0, l7 = t10;
  if (r13)
    return false;
  let c9 = 0;
  for (let u12 = 0; u12 < o11.length; ) {
    let t11 = u12, e12 = o11[u12], r14 = h2(n10, c9, e12);
    const a7 = [];
    for (; ++t11 < o11.length; ) {
      const s10 = o11[t11], l8 = h2(n10, c9 + e12, s10);
      if (!(l8 > 0))
        break;
      r14 += l8, a7.push(c9 + e12), e12 += s10;
    }
    const m5 = l7.length;
    e8(l7, n10, c9, c9 + e12, a7, 2, s9);
    const p9 = g4(l7, n10, m5, l7.length, s9), d7 = Math.abs(r14);
    if (Math.abs((p9 - d7) / Math.max(1e-7, d7)) > f9)
      return l7.length = 0, false;
    u12 = t11, c9 += e12;
  }
  return true;
}
function p5(t10) {
  const { coords: e11, lengths: o11 } = t10, { buffer: r13 } = r4(e11, o11);
  return r13;
}
function d3(t10, e11, n10) {
  let o11 = 0;
  for (let r13 = 0; r13 < t10.lengths.length; r13++) {
    const s9 = t10.lengths[r13];
    for (let r14 = 0; r14 < s9; r14++) {
      const s10 = t10.coords[2 * (r14 + o11)], l7 = t10.coords[2 * (r14 + o11) + 1];
      if (s10 < e11 || s10 > n10 || l7 < e11 || l7 > n10)
        return true;
    }
    o11 += s9;
  }
  return false;
}
function b3(e11, n10) {
  if (t(e11))
    return null;
  if (!d3(e11, -128, o4 + 128))
    return e11;
  c6.setPixelMargin(n10), c6.reset(s4.Polygon);
  let l7 = 0;
  for (let t10 = 0; t10 < e11.lengths.length; t10++) {
    const n11 = e11.lengths[t10];
    let o11 = e11.coords[2 * (0 + l7)], r13 = e11.coords[2 * (0 + l7) + 1];
    c6.moveTo(o11, r13);
    for (let t11 = 1; t11 < n11; t11++)
      o11 = e11.coords[2 * (t11 + l7)], r13 = e11.coords[2 * (t11 + l7) + 1], c6.lineTo(o11, r13);
    c6.close(), l7 += n11;
  }
  const i12 = c6.result(false);
  if (!i12)
    return null;
  const f14 = [], u12 = [];
  for (const t10 of i12) {
    let e12 = 0;
    for (const n11 of t10)
      u12.push(n11.x), u12.push(n11.y), e12++;
    f14.push(e12);
  }
  return new t2(f14, u12);
}
function x6(t10, e11) {
  u5.setPixelMargin(e11);
  const n10 = u5, o11 = -e11, l7 = o4 + e11;
  let i12 = [], f14 = false, c9 = 0;
  for (; c9 < t10.length; ) {
    const e12 = [], r13 = t10[c9];
    if (!r13)
      return null;
    n10.reset(s4.LineString);
    let [u12, h5] = r13[0];
    if (f14)
      n10.moveTo(u12, h5);
    else {
      if (u12 < o11 || u12 > l7 || h5 < o11 || h5 > l7) {
        f14 = true;
        continue;
      }
      e12.push({ x: u12, y: h5 });
    }
    let g9 = false;
    const a7 = r13.length;
    for (let t11 = 1; t11 < a7; ++t11)
      if (u12 += r13[t11][0], h5 += r13[t11][1], f14)
        n10.lineTo(u12, h5);
      else {
        if (u12 < o11 || u12 > l7 || h5 < o11 || h5 > l7) {
          g9 = true;
          break;
        }
        e12.push({ x: u12, y: h5 });
      }
    if (g9)
      f14 = true;
    else {
      if (f14) {
        const t11 = n10.resultWithStarts();
        if (t11)
          for (const e13 of t11)
            i12.push(e13);
      } else
        i12.push({ line: e12, start: 0 });
      c9++, f14 = false;
    }
  }
  return i12 = i12.filter((t11) => t11.line.length > 1), 0 === i12.length ? null : i12;
}
c6.setExtent(o4), u5.setExtent(o4);

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLBaseLineTemplate.js
var m3 = 8;
var x7 = 16;
var p6 = 65535;
var f10 = (r13) => class extends r13 {
  constructor(...e11) {
    super(...e11), this.tessellationProperties = {}, this._tessellationOptions = { halfWidth: 0, pixelCoordRatio: 1, offset: 0 }, this.geometryType = E.LINE;
  }
  writeGeometry(e11, t10, i12, r14) {
    this._writeGeometry(e11, t10, i12, r14);
  }
  _initializeTessellator(e11) {
    const i12 = C.load(this._materialKey), r14 = w2.load(this._materialKey), s9 = this._tessellationOptions, h5 = i12.vvSizeFieldStops || i12.vvSizeMinMaxValue || i12.vvSizeScaleStops || i12.vvSizeUnitValue, d7 = this.tessellationProperties._halfWidth < X && !e11 && !h5;
    this.tessellationProperties.minMaxZoom = this._minMaxZoom, s9.wrapDistance = p6, s9.textured = this._isDashed || this._hasPattern, s9.offset = this.tessellationProperties.offset, s9.halfWidth = this.tessellationProperties._halfWidth;
    const m5 = d7 ? 0 : 1, x10 = O(r14) ? v3 : _2;
    this._lineTessellator = new c2(x10(this.tessellationProperties, m5, m5), u6(this.tessellationProperties), d7);
  }
  _write(e11, t10, i12, r14) {
    const s9 = "esriGeometryPoint" === t10.geometryType;
    e11.recordStart(t10.getDisplayId(), this._materialKey, this.geometryType, s9), this._writeGeometry(e11, t10, r14, s9), e11.recordEnd();
  }
  _writeGeometry(t10, i12, r14, s9) {
    const o11 = r14 != null ? r14 : i12.readLegacyGeometryForDisplay(), n10 = this._getLines(o11, s9);
    t(n10) || this._writeVertices(t10, i12, n10);
  }
  _getLines(t10, i12) {
    if (t(t10))
      return null;
    const r14 = t10.paths || t10.rings;
    if (t(r14))
      return null;
    return x6(r14, i12 ? 256 : 16);
  }
  _writeVertices(e11, t10, i12) {
    const r14 = t10.getDisplayId(), s9 = e11.vertexCount(), o11 = this.tessellationProperties, h5 = this._tessellationOptions;
    o11.out = e11, o11.id = r14, o11.indexCount = 0, o11.vertexCount = 0, o11.offset = s9, h5.capType = this._capType, h5.joinType = this._joinType;
    const d7 = w2.load(this._materialKey);
    this.tessellationProperties.key = O(d7) ? d7 : C.load(this._materialKey);
    for (const { line: n10, start: l7 } of i12)
      h5.initialDistance = l7 % p6, this._lineTessellator.tessellate(n10, h5);
  }
};
var _2 = (e11, t10, i12) => (o11, n10, l7, a7, h5, d7, p9, f14, _5, v5, u12) => {
  const c9 = w(u12, Math.ceil(x7 * e11._halfWidth)), y7 = x(Math.round(x7 * p9), Math.round(x7 * f14), Math.round(x7 * _5), Math.round(x7 * v5)), W = x(x7 * h5, x7 * d7, 0, e11._bitset), M8 = e11.out;
  return M8.vertexBounds(o11, n10, t10, i12), M8.vertexWrite(w(m3 * o11, m3 * n10)), M8.vertexWrite(e11.id), M8.vertexWrite(e11._fillColor), M8.vertexWrite(y7), M8.vertexWrite(c9), M8.vertexWrite(e11._tl), M8.vertexWrite(e11._br), M8.vertexWrite(W), M8.vertexWrite(w(Math.ceil(x7 * e11._halfReferenceWidth), 0)), M8.vertexWrite(e11.minMaxZoom), M8.vertexEnd(), e11.offset + e11.vertexCount++;
};
var v3 = (e11, t10, i12) => (o11, n10, l7, a7, d7, p9, f14, _5, v5, u12, c9) => {
  const y7 = w(x7 * e11._halfWidth, x7 * e11._halfReferenceWidth), W = x(x7 * f14 + 128, x7 * _5 + 128, x7 * v5 + 128, x7 * u12 + 128), M8 = e11.out, P4 = e11._bitset << 24 | e11.id;
  M8.vertexBounds(o11, n10, t10, i12), M8.vertexWrite(w(m3 * o11, m3 * n10)), M8.vertexWrite(P4), M8.vertexWrite(e11._fillColor);
  const T = b(e11.key);
  return T || (M8.vertexWrite(0), M8.vertexWrite(0)), M8.vertexWrite(0), M8.vertexWrite(y7), M8.vertexWrite(W), T || M8.vertexWrite(e11.minMaxZoom), M8.vertexEnd(), e11.offset + e11.vertexCount++;
};
var u6 = (e11) => (t10, i12, r13) => {
  const s9 = e11.out;
  s9.indexWrite(t10), s9.indexWrite(i12), s9.indexWrite(r13), e11.indexCount += 3;
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLMeshTemplate.js
var r9 = class {
  bindFeature(e11, t10, r13) {
  }
  write(r13, s9, f14, i12) {
    var _a;
    if (t(this._effects) || 0 === ((_a = this._effects) == null ? void 0 : _a.length))
      return this._write(r13, s9, i12);
    const c9 = f6.executeEffects(this._effects, s9.readLegacyGeometryForDisplay(), i12.geometryEngine);
    let o11 = f6.next(c9);
    for (; o11; )
      this._write(r13, s9, i12, o11), o11 = f6.next(c9);
  }
  _write(e11, t10, r13, s9) {
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLLineTemplate.js
var K = class extends f10(r9) {
  constructor(e11, t10, i12, r13, s9, o11, p9, f14, d7, y7, S4, _5, j7, g9, w7, K2, P4, x10, b6, O3) {
    super();
    const T = C.load(e11);
    t10 && (T.sdf = t10.sdf, T.pattern = true, T.textureBinding = t10.textureBinding), this._capType = r13, this._joinType = s9, this._miterLimitCosine = e7(o11), this.tessellationProperties._fillColor = p9, this.tessellationProperties._tl = f14, this.tessellationProperties._br = d7, this._hasPattern = y7, this._isDashed = S4, this._zOrder = P4, this._effects = x10, this._minMaxZoom = w(Math.round(b6 * at), Math.round(O3 * at)), this._materialKey = T.data;
    const M8 = (j7 ? nt2 : 0) | (g9 ? mt : 0) | (_5 ? lt : 0) | (w7 ? gt : 0);
    this.tessellationProperties._bitset = M8, this.tessellationProperties._halfWidth = 0.5 * i12, this.tessellationProperties._halfReferenceWidth = 0.5 * K2, this.tessellationProperties.offset = 0, this._initializeTessellator(false);
  }
  static fromCIMLine(e11, r13, l7) {
    const n10 = e11.color, a7 = e11.scaleFactor || 1, m5 = !!e11.dashTemplate;
    let c9 = e11.cap;
    m5 && c9 === e4.ROUND && (c9 = e4.SQUARE);
    const p9 = e11.join, f14 = u(e11.width) * a7, u12 = u(e11.referenceWidth), d7 = u(e11.miterLimit), y7 = n10 && f3(n10) || 0, [L3, _5] = x3(e11.scaleInfo, l7), j7 = false;
    if (!r13)
      return new K(e11.materialKey, r13, f14, c9, p9, d7, y7, 0, 0, false, m5, e11.scaleDash, e11.colorLocked, j7, e11.sampleAlphaOnly, u12, e11.zOrder, e11.effects, L3, _5);
    const { rect: g9, width: w7, height: P4 } = r13, x10 = g9.x + et, b6 = g9.y + et, O3 = x10 + w7, T = b6 + P4, M8 = w(x10, b6), W = w(O3, T), z4 = false;
    return new K(e11.materialKey, r13, f14, c9, p9, d7, y7, M8, W, true, m5, e11.scaleDash, e11.colorLocked, z4, e11.sampleAlphaOnly, u12, e11.zOrder, e11.effects, L3, _5);
  }
  static fromFillOutline(e11) {
    var _a;
    const t10 = w2.load(e11.materialKey);
    return O(t10) && e11.outline && "esriSLSSolid" === ((_a = e11.outline) == null ? void 0 : _a.style) ? K.fromSimpleLine({ hash: "", materialKey: e11.materialKey, ...e11.outline }, null, true) : null;
  }
  static fromSimpleLine(e11, i12, s9 = false) {
    const { color: l7 } = e11, n10 = "esriSLSSolid" !== e11.style && "esriSLSNull" !== e11.style, a7 = ee(e11.cap || "round"), m5 = te(e11.join || "round");
    let c9 = l7 && "esriSLSNull" !== e11.style && s5(l7) || 0;
    "esriSLSNull" === e11.style && (c9 = 0);
    const u12 = u(e11.width), d7 = e11.miterLimit;
    if (!i12)
      return new K(e11.materialKey, i12, u12, a7, m5, d7, c9, 0, 0, false, n10, true, false, s9, false, u12, 0, null, n7, o8);
    const { rect: y7, width: L3, height: S4 } = i12, g9 = y7.x + et, w7 = y7.y + et, P4 = g9 + L3, x10 = w7 + S4, b6 = w(g9, w7), O3 = w(P4, x10);
    return new K(e11.materialKey, i12, u12, a7, m5, d7, c9, b6, O3, true, n10, true, false, s9, false, u12, 0, null, n7, o8);
  }
  static fromPictureLineSymbol(t10, i12, r13, s9) {
    return s.getLogger("esri.views.2d.engine.webgl.WGLLineTemplate").error("PictureLineSymbol support does not exist!"), null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLBaseFillTemplate.js
var f11 = 100;
var u7 = 1;
var _3 = (_5) => class extends _5 {
  constructor(...e11) {
    super(...e11), this.forceLibtess = false, this._bitset = 0, this._lineTemplate = null, this.geometryType = E.FILL;
  }
  _maybeAddLineTemplate(e11) {
    this._lineTemplate = K.fromFillOutline(e11);
  }
  _write(t10, r13, i12, s9) {
    const o11 = "esriGeometryPoint" === r13.geometryType, m5 = w2.load(this._materialKey);
    t10.recordStart(r13.getDisplayId(), this._materialKey, this.geometryType, o11), this._writeGeometry(t10, r13, m5, s9, o11), O(m5) && r(this._lineTemplate) && this._lineTemplate.writeGeometry(t10, r13, s9, o11), t10.recordEnd();
  }
  _writeGeometry(e11, r13, i12, s9, o11) {
    const m5 = this._getGeometry(r13, s9, o11);
    if (t(m5))
      return;
    const l7 = [];
    if (!(m5.maxLength > f11) && !this.forceLibtess && a5(l7, m5))
      return void (l7.length && this._writeVertices(e11, r13, m5.coords, m5.lengths, i12, l7));
    const n10 = p5(m5);
    this._writeVertices(e11, r13, n10, [n10.length / 2], i12);
  }
  _writeVertex(e11, t10, r13, i12, s9, l7) {
    const n10 = w(u7 * i12, u7 * s9);
    if (e11.vertexBounds(i12, s9, 0, 0), e11.vertexWrite(n10), e11.vertexWrite(t10), r13.symbologyType === S.DOT_DENSITY)
      e11.vertexWriteF32(1 / Math.abs(l7.readGeometryArea()));
    else {
      e11.vertexWrite(this.fillColor);
      const t11 = b(r13);
      t11 || (e11.vertexWrite(this.tl), e11.vertexWrite(this.br)), e11.vertexWrite(this.aux21), e11.vertexWrite(this.aux22), e11.vertexWrite(this.aux3), t11 || e11.vertexWrite(this._minMaxZoom);
    }
  }
  _writeVertices(e11, t10, r13, i12, s9, o11) {
    const m5 = t10.getDisplayId(), n10 = this._bitset << 24 | m5, a7 = i12.reduce((e12, t11) => e12 + t11), h5 = G(s9.geometryType, s9.symbologyType).geometry / 4, y7 = e11.vertexCount();
    e11.vertexEnsureSize(h5 * a7);
    let p9 = 0;
    if (o11)
      for (const l7 of o11) {
        const i13 = r13[2 * l7], o12 = r13[2 * l7 + 1];
        this._writeVertex(e11, n10, s9, i13, o12, t10), p9++;
      }
    else
      for (let l7 = 0; l7 < r13.length; l7 += 2) {
        const i13 = Math.round(r13[l7]), o12 = Math.round(r13[l7 + 1]);
        this._writeVertex(e11, n10, s9, i13, o12, t10), p9++;
      }
    e11.indexEnsureSize(p9);
    for (let l7 = 0; l7 < p9; l7++)
      e11.indexWrite(l7 + y7);
  }
  _getGeometry(e11, t10, s9) {
    const o11 = t10 ? Gt(nt(t10), 2) : e11.readGeometryForDisplay();
    if (!o11)
      return null;
    return b3(o11, s9 ? 256 : 8);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLDynamicMeshTemplate.js
var i11 = s.getLogger("esri.views.2d.engine.webgl.WGLDynamicMeshTemplate");
var r10 = class extends r9 {
  constructor(e11) {
    super(), this._ongoingMaterialRequestMap = /* @__PURE__ */ new Map(), this._materialCache = /* @__PURE__ */ new Map(), this._dynamicPropertyMap = /* @__PURE__ */ new Map(), this._cimLayer = e11;
  }
  analyze(e11, s9, r13, n10, o11) {
    if (o11 && 0 === o11.length)
      return null;
    const l7 = o11 && o11.length > 0, m5 = s9.readLegacyFeature(), c9 = s9.getObjectId(), h5 = this._materialCache, u12 = this._cimLayer.materialHash;
    if (!u12)
      return i11.error("A Dynamic mesh template must have a material hash value or function!"), Promise.reject(null);
    const p9 = "function" == typeof u12 ? u12(m5, r13, n10, c9) : u12;
    if (h5.has(p9)) {
      const e12 = h5.get(p9);
      return Promise.resolve(e12);
    }
    const g9 = this._ongoingMaterialRequestMap.get(p9);
    if (g9)
      return g9;
    const y7 = this._cimLayer, M8 = me(y7.cim, this._cimLayer.materialOverrides);
    M8.mosaicHash = p9;
    const { type: d7, url: f14 } = y7, _5 = { cim: M8, type: d7, mosaicHash: p9, url: f14, size: null, dashTemplate: null, text: null, fontName: null, objectId: c9, animatedSymbolProperties: null };
    switch (d7) {
      case "marker":
        _5.size = t3(y7.size, m5, r13, n10), _5.animatedSymbolProperties = t3(y7.animatedSymbolProperties, m5, r13, n10);
        break;
      case "line":
        _5.dashTemplate = y7.dashTemplate;
        break;
      case "text":
        _5.text = t3(y7.text, m5, r13, n10), _5.fontName = t3(y7.fontName, m5, r13, n10);
    }
    const b6 = e11.getMosaicItem(_5, o11).then((e12) => (l7 || (this._ongoingMaterialRequestMap.delete(p9), h5.set(p9, e12)), e12)).catch((e12) => (this._ongoingMaterialRequestMap.delete(p9), i11.error(".analyze()", e12.message), null));
    return l7 || this._ongoingMaterialRequestMap.set(p9, b6), b6;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Result.js
function e9(e11, n10) {
  if (e11 && "name" in e11) {
    const o11 = e11;
    return n10 && n10.error(new s2(o11.name, o11.message, o11.details)), false;
  }
  return true;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLDynamicFillTemplate.js
var u8 = 128;
var M3 = class extends _3(r10) {
  constructor(a7, h5, f14) {
    var _a;
    if (super(a7), this._minMaxZoom = w(Math.round(h5 * at), Math.round(f14 * at)), c4(a7.color)) {
      const t10 = (t11, e11, i12) => {
        const o11 = a7.color(t11, e11, i12);
        return o11 && f3(o11) || 0;
      };
      this._dynamicPropertyMap.set("fillColor", t10);
    } else {
      const t10 = a7.color;
      this.fillColor = t10 && f3(t10) || 0;
    }
    const p9 = "CIMMarkerPlacementInsidePolygon" === ((_a = a7.cim.placement) == null ? void 0 : _a.type) && a7.cim.placement.shiftOddRows ? 2 : 1, _5 = a7.height;
    if (c4(_5)) {
      const t10 = (t11, e11, s9) => _5(t11, e11, s9) * p9;
      this._dynamicPropertyMap.set("_height", t10);
    } else
      this._height = (_5 || 0) * p9;
    const y7 = a7.offsetX;
    if (c4(y7)) {
      const t10 = (t11, s9, i12) => u(y7(t11, s9, i12));
      this._dynamicPropertyMap.set("_offsetX", t10);
    } else
      this._offsetX = u(y7 || 0);
    const d7 = a7.offsetY;
    if (c4(d7)) {
      const t10 = (t11, s9, i12) => u(-d7(t11, s9, i12));
      this._dynamicPropertyMap.set("_offsetY", t10);
    } else
      this._offsetY = u(-d7 || 0);
    const u12 = a7.scaleX;
    c4(u12) ? this._dynamicPropertyMap.set("_scaleX", u12) : this._scaleX = u12 || 1;
    const M8 = a7.angle;
    if (c4(M8)) {
      const t10 = (t11, e11, s9) => M(M8(t11, e11, s9));
      this._dynamicPropertyMap.set("_angle", t10);
    } else
      this._angle = M(M8) || 0;
    if (r(a7.effects)) {
      const t10 = a7.effects;
      c4(t10) ? this._dynamicPropertyMap.set("_effects", t10) : this._effects = t10;
    }
    this._cimFillLayer = a7, this._bitset = (a7.colorLocked ? nt2 : 0) | (a7.applyRandomOffset ? vt : 0) | (a7.sampleAlphaOnly ? gt : 0), this._fillMaterialKey = a7.materialKey;
  }
  static fromCIMFill(t10, e11) {
    const [s9, i12] = x3(t10.scaleInfo, e11);
    return new M3(t10, s9, i12);
  }
  bindFeature(t10, s9, i12) {
    const o11 = t10.readLegacyFeature();
    this._dynamicPropertyMap.forEach((t11, e11) => {
      this[e11] = t11(o11, s9, i12);
    });
    const r13 = w2.load(this._fillMaterialKey), l7 = this._materialCache, n10 = (0, this._cimFillLayer.materialHash)(o11, s9, i12), m5 = l7.get(n10);
    let p9 = null;
    if (m5 && e9(m5.spriteMosaicItem) && (p9 = m5.spriteMosaicItem), p9) {
      const { rect: t11, width: s10, height: i13 } = p9, o12 = t11.x + et, l8 = t11.y + et, n11 = o12 + s10, f14 = l8 + i13;
      let m6 = Math.round(u(this._height));
      m6 <= 0 && (m6 = f14 - l8);
      let _5 = Math.round(u(this._height / i13 * s10 || 0));
      _5 <= 0 && (_5 = n11 - o12);
      const y7 = this._scaleX, d7 = 1;
      this.tl = w(o12, l8), this.br = w(n11, f14), this.aux21 = w(_5, m6), this.aux22 = w(this._offsetX, this._offsetY), this.aux3 = x(y7 * u8, d7 * u8, this._angle, 0), r13.sdf = p9.sdf, r13.pattern = true, r13.textureBinding = p9.textureBinding;
    } else
      this.tl = 0, this.br = 0, this.aux21 = 0, this.aux22 = 0, this.aux3 = 0, r13.sdf = false, r13.pattern = false, r13.textureBinding = 0;
    this._materialKey = r13.data;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLDynamicLineTemplate.js
var y4 = class extends f10(r10) {
  constructor(a7, n10, p9) {
    super(a7), this._minMaxZoom = w(Math.round(n10 * at), Math.round(p9 * at)), this._cimLineLayer = a7;
    let _5 = 0;
    c4(a7.width) || (_5 = 0.5 * u(a7.width));
    const f14 = (t10, i12, s9) => c4(a7.width) ? 0.5 * u(a7.width(t10, i12, s9)) : _5;
    this._dynamicPropertyMap.set("_halfWidth", f14), c4(a7.cap) ? this._dynamicPropertyMap.set("_capType", a7.cap) : this._capType = a7.cap, c4(a7.join) ? this._dynamicPropertyMap.set("_joinType", a7.join) : this._joinType = a7.join;
    const d7 = a7.color;
    if (c4(d7)) {
      const t10 = (t11, e11, s9) => f3(d7(t11, e11, s9));
      this._dynamicPropertyMap.set("_fillColor", t10);
    } else
      this._fillColor = d7 && f3(d7) || 0;
    const y7 = a7.miterLimit;
    if (c4(y7)) {
      const t10 = (t11, e11, i12) => e7(y7(t11, e11, i12));
      this._dynamicPropertyMap.set("_miterLimitCosine", t10);
    } else
      this._miterLimitCosine = e7(y7);
    if (r(a7.effects)) {
      const t10 = a7.effects;
      c4(t10) ? this._dynamicPropertyMap.set("_effects", t10) : this._effects = t10;
    }
    this._scaleFactor = a7.scaleFactor || 1, this._isDashed = null != a7.dashTemplate;
    const P4 = a7.colorLocked ? nt2 : 0, u12 = a7.scaleDash ? lt : 0, j7 = a7.sampleAlphaOnly ? gt : 0;
    this.tessellationProperties._bitset = P4 | u12 | j7, this._materialKey = a7.materialKey, this._initializeTessellator(true);
  }
  static fromCIMLine(t10, e11) {
    const [i12, s9] = x3(t10.scaleInfo, e11);
    return new y4(t10, i12, s9);
  }
  bindFeature(t10, e11, i12) {
    const s9 = t10.readLegacyFeature();
    this._dynamicPropertyMap.forEach((t11, r14) => {
      this[r14] = t11(s9, e11, i12);
    }), this._halfWidth *= this._scaleFactor;
    const r13 = this._materialCache, o11 = (0, this._cimLineLayer.materialHash)(s9, e11, i12), l7 = r13.get(o11);
    let c9 = null;
    if (l7 && e9(l7.spriteMosaicItem) && (c9 = l7.spriteMosaicItem), c9) {
      this._hasPattern = true;
      const { rect: t11, width: e12, height: i13 } = c9, s10 = t11.x + et, r14 = t11.y + et, o12 = s10 + e12, l8 = r14 + i13;
      this.tessellationProperties._tl = w(s10, r14), this.tessellationProperties._br = w(o12, l8);
    } else
      this._hasPattern = false, this.tessellationProperties._tl = 0, this.tessellationProperties._br = 0;
    this.tessellationProperties._fillColor = this._fillColor, this.tessellationProperties._halfWidth = this._halfWidth, this.tessellationProperties.offset = 0, this.tessellationProperties._halfReferenceWidth = this.tessellationProperties._halfWidth;
    const m5 = C.load(this._materialKey);
    c9 && (m5.sdf = c9.sdf, m5.pattern = true, m5.textureBinding = c9.textureBinding), this._materialKey = m5.data;
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/CIMMarkerPlacementHelper.js
var e10 = class {
  static getPlacement(e11, o11, s9, c9) {
    const n10 = g(o11);
    if (!n10)
      return null;
    const m5 = a3(e11);
    return n10.execute(m5, o11, s9, c9);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLBaseMarkerTemplate.js
var g5 = 3.14159265359 / 180;
var y5 = 8;
var u9 = (u12) => class extends u12 {
  constructor(...t10) {
    super(...t10), this.angle = 0, this.xOffset = 0, this.yOffset = 0, this.width = 0, this.height = 0, this.boundsType = "square", this._anchorX = 0, this._anchorY = 0, this._computedWidth = 0, this._computedHeight = 0, this._vertexBoundsScaleX = 1, this._vertexBoundsScaleY = 1, this._offsets = { xUpperLeft: 0, yUpperLeft: 0, xUpperRight: 0, yUpperRight: 0, xBottomLeft: 0, yBottomLeft: 0, xBottomRight: 0, yBottomRight: 0 }, this.geometryType = E.MARKER;
  }
  _write(t10, e11, i12, r13) {
    const s9 = e11.getDisplayId();
    t10.recordStart(s9, this._materialKey, this.geometryType, true), this._writeGeometry(t10, e11, s9, i12, r13), t10.recordEnd();
  }
  _writeGeometry(i12, r13, s9, o11, h5) {
    if (r(this._markerPlacement))
      return this._writePlacedMarkers(i12, r13, o11, h5);
    if (!h5 && "esriGeometryPoint" === r13.geometryType) {
      const t10 = r13.getX(), e11 = r13.getY();
      if (!i12.hasAggregates && i12.hasPixelBufferEnabled && (t10 < 0 || t10 >= 513 || e11 < 0 || e11 >= 513))
        return;
      return this._writeVertices(i12, s9, this._getPos(t10, e11), t10, e11);
    }
    const f14 = h5 ? Gt(nt(h5), 2) : "esriGeometryPolygon" === r13.geometryType ? r13.readCentroid() : r13.readGeometryForDisplay();
    if (!t(f14)) {
      if (f14.isPoint) {
        const [t10, e11] = f14.coords;
        if (!i12.hasAggregates && i12.hasPixelBufferEnabled && (t10 < 0 || t10 >= 512 || e11 < 0 || e11 >= 512))
          return;
        return this._writeVertices(i12, s9, this._getPos(t10, e11), t10, e11);
      }
      f14.forEachVertex((t10, e11) => {
        const r14 = 2 * o4;
        t10 < -r14 || t10 >= r14 || e11 < -r14 || e11 >= r14 || this._writeVertices(i12, s9, this._getPos(t10, e11), t10, e11);
      });
    }
  }
  _writePlacedMarkers(t10, e11, s9, o11) {
    const f14 = o11 != null ? o11 : e11.readLegacyGeometryForDisplay(), n10 = e10.getPlacement(f14, e(this._markerPlacement), u(1), s9.geometryEngine);
    if (!n10)
      return;
    const x10 = e11.getDisplayId(), m5 = n(), _5 = n4(), c9 = -128, l7 = 640;
    let v5 = n10.next();
    for (; null != v5; ) {
      const e12 = v5.tx, i12 = -v5.ty;
      e12 >= c9 && e12 <= l7 && i12 >= c9 && i12 <= l7 && (this._applyTransformation(_5, m5, -v5.getAngle() / g5), this._writeVertices(t10, x10, this._getPos(e12, i12), e12, i12)), v5 = n10.next();
    }
  }
  _writeVertices(t10, e11, i12, r13, s9) {
    const o11 = N.load(this._materialKey);
    return o11.symbologyType === S.HEATMAP ? this._writeHeatmapVertices(t10, e11, i12) : this._writeMarkerVertices(t10, e11, o11, i12, r13, s9);
  }
  _writeMarkerVertices(t10, e11, i12, r13, s9, o11) {
    const h5 = i12.vvRotation, f14 = t10.vertexCount();
    let n10 = this._computedWidth * this._vertexBoundsScaleX, x10 = this._computedHeight * this._vertexBoundsScaleY;
    if (this.angle) {
      const t11 = Math.max(n10, x10);
      n10 = t11, x10 = t11;
    }
    if (h5) {
      const t11 = Math.max(this.xOffset, this.yOffset);
      n10 += t11, x10 += t11;
    }
    t10.vertexBounds(s9 + this.xOffset, o11 - this.yOffset, n10, x10), t10.vertexWrite(r13), t10.vertexWrite(this._offsetUpperLeft), t10.vertexWrite(this._texUpperLeft), t10.vertexWrite(this._bitestAndDistRatio), t10.vertexWrite(e11), t10.vertexWrite(this._fillColor), t10.vertexWrite(this._outlineColor), t10.vertexWrite(this._sizeOutlineWidth), t10.vertexWrite(this._minMaxZoom), t10.vertexEnd(), t10.vertexWrite(r13), t10.vertexWrite(this._offsetUpperRight), t10.vertexWrite(this._texUpperRight), t10.vertexWrite(this._bitestAndDistRatio), t10.vertexWrite(e11), t10.vertexWrite(this._fillColor), t10.vertexWrite(this._outlineColor), t10.vertexWrite(this._sizeOutlineWidth), t10.vertexWrite(this._minMaxZoom), t10.vertexEnd(), t10.vertexWrite(r13), t10.vertexWrite(this._offsetBottomLeft), t10.vertexWrite(this._texBottomLeft), t10.vertexWrite(this._bitestAndDistRatio), t10.vertexWrite(e11), t10.vertexWrite(this._fillColor), t10.vertexWrite(this._outlineColor), t10.vertexWrite(this._sizeOutlineWidth), t10.vertexWrite(this._minMaxZoom), t10.vertexEnd(), t10.vertexWrite(r13), t10.vertexWrite(this._offsetBottomRight), t10.vertexWrite(this._texBottomRight), t10.vertexWrite(this._bitestAndDistRatio), t10.vertexWrite(e11), t10.vertexWrite(this._fillColor), t10.vertexWrite(this._outlineColor), t10.vertexWrite(this._sizeOutlineWidth), t10.vertexWrite(this._minMaxZoom), t10.vertexEnd(), this._writeIndices(t10, f14);
  }
  _writeHeatmapVertices(t10, e11, i12) {
    const r13 = t10.vertexCount();
    t10.vertexWrite(i12), t10.vertexWrite(this._offsetUpperLeft), t10.vertexWrite(e11), t10.vertexEnd(), t10.vertexWrite(i12), t10.vertexWrite(this._offsetUpperRight), t10.vertexWrite(e11), t10.vertexEnd(), t10.vertexWrite(i12), t10.vertexWrite(this._offsetBottomLeft), t10.vertexWrite(e11), t10.vertexEnd(), t10.vertexWrite(i12), t10.vertexWrite(this._offsetBottomRight), t10.vertexWrite(e11), t10.vertexEnd(), this._writeIndices(t10, r13);
  }
  _writeIndices(t10, e11) {
    t10.indexWrite(e11 + 0), t10.indexWrite(e11 + 1), t10.indexWrite(e11 + 2), t10.indexWrite(e11 + 1), t10.indexWrite(e11 + 3), t10.indexWrite(e11 + 2);
  }
  _applyTransformation(t10, e11, i12 = 0) {
    f5(t10, t4(this.xOffset, -this.yOffset)), this.angle + i12 !== 0 && e5(t10, t10, g5 * (this.angle + i12));
    const r13 = this._computedWidth, h5 = this._computedHeight, a7 = -(0.5 + this._anchorX) * r13, m5 = -(0.5 - this._anchorY) * h5;
    r3(e11, a7, m5), z(e11, e11, t10), this._offsetUpperLeft = w(16 * e11[0], 16 * e11[1]), this._offsets.xUpperLeft = e11[0], this._offsets.yUpperLeft = e11[1], r3(e11, a7 + r13, m5), z(e11, e11, t10), this._offsetUpperRight = w(16 * e11[0], 16 * e11[1]), this._offsets.xUpperRight = e11[0], this._offsets.yUpperRight = e11[1], r3(e11, a7, m5 + h5), z(e11, e11, t10), this._offsetBottomLeft = w(16 * e11[0], 16 * e11[1]), this._offsets.xBottomLeft = e11[0], this._offsets.yBottomLeft = e11[1], r3(e11, a7 + r13, m5 + h5), z(e11, e11, t10), this._offsetBottomRight = w(16 * e11[0], 16 * e11[1]), this._offsets.xBottomRight = e11[0], this._offsets.yBottomRight = e11[1];
  }
  _getPos(t10, e11) {
    return w(Math.round(y5 * t10), Math.round(y5 * e11));
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLDynamicMarkerTemplate.js
var g6 = n();
var k3 = n4();
var P2 = class extends u9(r10) {
  constructor(t10, e11, o11) {
    super(t10), this._cimMarkerLayer = t10, this._minMaxZoom = w(Math.round(e11 * at), Math.round(o11 * at));
    const a7 = t10.color;
    if (c4(a7)) {
      const t11 = (t12, e12, i12) => f3(a7(t12, e12, i12));
      this._dynamicPropertyMap.set("_fillColor", t11);
    } else
      this._fillColor = f3(a7);
    const n10 = t10.outlineColor;
    if (c4(n10)) {
      const t11 = (t12, e12, i12) => f3(n10(t12, e12, i12));
      this._dynamicPropertyMap.set("_outlineColor", t11);
    } else
      this._outlineColor = f3(n10);
    const f14 = t10.size;
    if (c4(f14)) {
      const t11 = (t12, e12, i12) => u(f14(t12, e12, i12));
      this._dynamicPropertyMap.set("_size", t11);
    } else
      this._size = u(f14) || 0;
    const _5 = t10.scaleX;
    c4(_5) ? this._dynamicPropertyMap.set("_scaleX", _5) : this._scaleX = _5;
    const y7 = t10.offsetX;
    if (c4(y7)) {
      const t11 = (t12, e12, i12) => u(y7(t12, e12, i12));
      this._dynamicPropertyMap.set("xOffset", t11);
    } else
      this.xOffset = u(y7) || 0;
    const d7 = t10.offsetY;
    if (c4(d7)) {
      const t11 = (t12, e12, i12) => u(d7(t12, e12, i12));
      this._dynamicPropertyMap.set("yOffset", t11);
    } else
      this.yOffset = u(d7) || 0;
    const M8 = t10.outlineWidth;
    if (c4(M8)) {
      const t11 = (t12, e12, i12) => u(M8(t12, e12, i12));
      this._dynamicPropertyMap.set("_outlineWidth", t11);
    } else
      this._outlineWidth = u(M8) || 0;
    const u12 = t10.rotation;
    if (c4(u12) ? this._dynamicPropertyMap.set("_angle", u12) : this._angle = u12 || 0, r(t10.effects)) {
      const e12 = t10.effects;
      c4(e12) ? this._dynamicPropertyMap.set("_effects", e12) : this._effects = e12;
    }
    if (r(t10.markerPlacement)) {
      const e12 = t10.markerPlacement;
      c4(e12) ? this._dynamicPropertyMap.set("_markerPlacement", e12) : this._markerPlacement = e12;
    }
    this._scaleFactor = i(t10.scaleFactor, 1), this._bitSet = (t10.alignment === i2.MAP ? 1 : 0) | (t10.colorLocked ? 1 : 0) << 1 | (t10.scaleSymbolsProportionally ? 1 : 0) << 3, this._materialKey = t10.materialKey;
  }
  static fromCIMMarker(t10, e11) {
    const [i12, s9] = x3(t10.scaleInfo, e11);
    return new P2(t10, i12, s9);
  }
  bindFeature(i12, s9, o11) {
    const a7 = i12.readLegacyFeature(), h5 = i12.getObjectId();
    this._dynamicPropertyMap.forEach((t10, e11) => {
      this[e11] = t10(a7, s9, o11);
    });
    const c9 = this._cimMarkerLayer.materialHash, m5 = "function" == typeof c9 ? c9(a7, s9, o11, h5) : c9, p9 = this._materialCache.get(m5);
    if (!p9 || !e9(p9.spriteMosaicItem) || !p9.spriteMosaicItem)
      return void s.getLogger("esri.views.2d.engine.webgl.WGLDynamicMarkerTemplate").error(new s2("mapview-cim", "Encountered an error when binding feature"));
    const y7 = p9.spriteMosaicItem, d7 = this._cimMarkerLayer.sizeRatio, M8 = y7.width / y7.height * this._scaleX, P4 = this._cimMarkerLayer.rotateClockwise ? this._angle : -this._angle;
    let L3 = this._size, x10 = L3 * M8;
    const j7 = this.xOffset, b6 = this.yOffset;
    this.xOffset *= this._scaleFactor, this.yOffset *= this._scaleFactor;
    const O3 = this._cimMarkerLayer.scaleSymbolsProportionally && this._cimMarkerLayer.frameHeight ? this._size / u(this._cimMarkerLayer.frameHeight) : 1, w7 = this._outlineWidth * O3, z4 = u(this._cimMarkerLayer.referenceSize);
    let W = 0, C4 = 0;
    const F2 = this._cimMarkerLayer.anchorPoint;
    F2 && (this._cimMarkerLayer.isAbsoluteAnchorPoint ? this._size && (W = u(F2.x) / (this._size * M8), C4 = u(F2.y) / this._size) : (W = F2.x, C4 = F2.y)), this._anchorX = W, this._anchorY = C4, this._sizeOutlineWidth = x(Math.round(Math.min(Math.sqrt(128 * x10), 255)), Math.round(Math.min(Math.sqrt(128 * L3), 255)), Math.round(Math.min(Math.sqrt(128 * w7), 255)), Math.round(Math.min(Math.sqrt(128 * z4), 255))), this.angle = P4;
    const I2 = Math.round(64 * d7);
    this._bitestAndDistRatio = w(this._bitSet, I2);
    const K2 = y7.rect.x + et, X2 = y7.rect.y + et, B2 = K2 + y7.width, R = X2 + y7.height;
    this._texUpperLeft = w(K2, X2), this._texUpperRight = w(B2, X2), this._texBottomLeft = w(K2, R), this._texBottomRight = w(B2, R);
    const S4 = N.load(this._materialKey);
    S4.sdf = y7.sdf, S4.pattern = true, S4.textureBinding = y7.textureBinding, this._materialKey = S4.data, x10 *= d7, L3 *= d7, x10 *= this._scaleFactor, L3 *= this._scaleFactor, x10 *= y7.rect.width / y7.width, L3 *= y7.rect.height / y7.height, this._computedWidth = x10, this._computedHeight = L3, this._applyTransformation(k3, g6), this.xOffset = j7, this.yOffset = b6;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLBaseTextTemplate.js
var f12 = 8;
var _4 = (_5) => class extends _5 {
  constructor(...e11) {
    super(...e11), this._isCIM = false, this._vertexBoundsScale = 1, this.geometryType = E.TEXT, this._aux = x(0, 0, this._referenceSize, this._bitset);
  }
  bindTextInfo(t10, i12) {
    t10 && t10.length ? this._shapingInfo = o(t10, (e11) => j3(e11, i12, { scale: this._scale, angle: this._angle, xOffset: this._xOffset, yOffset: this._yOffset, hAlign: this._xAlignD, vAlign: this._yAlignD, maxLineWidth: Math.max(32, Math.min(this._lineWidth, 512)), lineHeight: f * Math.max(0.25, Math.min(this._lineHeight, 4)), decoration: this._decoration, isCIM: this._isCIM })) : this._shapingInfo = null;
  }
  _write(e11, t10, i12, r13) {
    const s9 = t10.getDisplayId();
    this._writeGeometry(e11, t10, s9, i12, r13);
  }
  _writeGeometry(e11, r13, s9, h5, a7) {
    const x10 = this._shapingInfo;
    if (t(x10))
      return;
    if (r(this._textPlacement)) {
      const t10 = a7 != null ? a7 : r13.readLegacyGeometryForDisplay();
      return this._writePlacedText(e11, s9, t10, x10, h5);
    }
    const l7 = a7 ? Gt(nt(a7), 2) : "esriGeometryPolygon" === r13.geometryType ? r13.readCentroid() : r13.readGeometryForDisplay();
    if (!t(l7)) {
      if (l7.isPoint) {
        const [t10, i12] = l7.coords;
        if (!e11.hasAggregates && e11.hasPixelBufferEnabled && (t10 < 0 || t10 >= 512 || i12 < 0 || i12 >= 512))
          return;
        return this._writeGlyphs(e11, s9, { x: t10, y: i12 }, x10);
      }
      l7.forEachVertex((t10, i12) => this._writeGlyphs(e11, s9, { x: t10, y: i12 }, x10));
    }
  }
  _writePlacedText(e11, t10, i12, o11, n10) {
    const a7 = e(this._textPlacement), x10 = e10.getPlacement(i12, a7, u(1), n10.geometryEngine);
    if (!x10)
      return;
    let l7 = x10.next();
    for (; null != l7; ) {
      const i13 = -l7.getAngle();
      o11.setRotation(i13);
      const r13 = l7.tx, s9 = -l7.ty;
      r13 < 0 || r13 >= 512 || s9 < 0 || s9 >= 512 ? l7 = x10.next() : (this._writeGlyphs(e11, t10, { x: r13, y: s9 }, o11), o11.setRotation(-i13), l7 = x10.next());
    }
  }
  _writeGlyphs(e11, t10, i12, r13) {
    const s9 = U.load(this._materialKey), o11 = w(Math.round(f12 * i12.x), Math.round(f12 * i12.y)), n10 = this._vertexBoundsScale, h5 = r13.bounds, a7 = 2 * Math.max(h5.width, h5.height);
    for (const x10 of r13.glyphs)
      s9.textureBinding = x10.textureBinding, e11.recordStart(t10, s9.data, this.geometryType, true), e11.vertexBounds(i12.x + h5.x + this._xOffset, i12.y + h5.y - this._yOffset, a7 * n10, a7 * n10), this._writeVertices(e11, t10, o11, x10), e11.recordEnd();
  }
  _writeGlyph(e11, t10, i12, r13, s9) {
    const o11 = U.load(this._materialKey), n10 = w(Math.round(f12 * i12), Math.round(f12 * r13));
    o11.textureBinding = s9.textureBinding, e11.recordStart(t10, o11.data, this.geometryType, true);
    const h5 = s9.bounds, a7 = this._vertexBoundsScale;
    e11.vertexBounds(i12 + h5.x * a7, r13 + h5.y * a7, h5.width * a7, h5.height * a7), this._writeVertices(e11, t10, n10, s9), e11.recordEnd();
  }
  _writeVertices(e11, t10, i12, r13) {
    const s9 = e11.vertexCount();
    this._writeVertexCommon(e11, t10, i12, r13), e11.vertexWrite(r13.offsets.upperLeft), e11.vertexWrite(r13.texcoords.upperLeft), e11.vertexEnd(), this._writeVertexCommon(e11, t10, i12, r13), e11.vertexWrite(r13.offsets.upperRight), e11.vertexWrite(r13.texcoords.upperRight), e11.vertexEnd(), this._writeVertexCommon(e11, t10, i12, r13), e11.vertexWrite(r13.offsets.lowerLeft), e11.vertexWrite(r13.texcoords.lowerLeft), e11.vertexEnd(), this._writeVertexCommon(e11, t10, i12, r13), e11.vertexWrite(r13.offsets.lowerRight), e11.vertexWrite(r13.texcoords.lowerRight), e11.vertexEnd(), e11.indexWrite(s9 + 0), e11.indexWrite(s9 + 1), e11.indexWrite(s9 + 2), e11.indexWrite(s9 + 1), e11.indexWrite(s9 + 3), e11.indexWrite(s9 + 2);
  }
  _writeVertexCommon(e11, t10, i12, r13) {
    const s9 = this._color, o11 = this._haloColor, n10 = x(0, 0, this._referenceSize, this._bitset), h5 = x(0, 0, this._size, this._haloSize);
    e11.vertexWrite(i12), e11.vertexWrite(t10), e11.vertexWrite(s9), e11.vertexWrite(o11), e11.vertexWrite(h5), e11.vertexWrite(n10), e11.vertexWrite(this._minMaxZoom);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLDynamicTextTemplate.js
var M4 = 5;
function d4(t10, e11, i12, s9) {
  return "string" == typeof t10.text ? t10.text : "function" == typeof t10.text ? t10.text(e11, i12, s9) : "";
}
var g7 = class extends _4(r10) {
  constructor(e11, o11, a7) {
    super(e11), this._horizontalAlignment = "center", this._verticalAlignment = "middle", this._textToGlyphs = /* @__PURE__ */ new Map(), this._minMaxZoom = w(Math.round(o11 * at), Math.round(a7 * at));
    const r13 = e11.scaleFactor || 1;
    this._cimTextLayer = e11;
    const _5 = e11.color;
    if (c4(_5)) {
      const t10 = (t11, e12, i12) => f3(_5(t11, e12, i12));
      this._dynamicPropertyMap.set("_color", t10);
    } else
      this._color = f3(_5);
    const f14 = e11.outlineColor;
    if (c4(f14)) {
      const t10 = (t11, e12, i12) => f3(f14(t11, e12, i12));
      this._dynamicPropertyMap.set("_haloColor", t10);
    } else
      this._haloColor = f3(f14);
    let y7;
    c4(e11.size) || (y7 = Math.min(Math.round(u(e11.size * e11.sizeRatio)), 127));
    const p9 = (t10, s9, o12) => c4(e11.size) ? Math.min(Math.round(u(e11.size(t10, s9, o12) * e11.sizeRatio)), 127) : y7;
    if (this._dynamicPropertyMap.set("_size", p9), c4(e11.outlineSize)) {
      const t10 = (t11, s9, o12) => Math.min(Math.floor(M4 * u(e11.outlineSize(t11, s9, o12) * e11.sizeRatio)), 127);
      this._dynamicPropertyMap.set("_haloSize", t10);
    } else
      this._haloSize = Math.min(Math.floor(M4 * u(e11.outlineSize * e11.sizeRatio)), 127);
    let d7;
    c4(e11.offsetX) || (d7 = Math.round(u(e11.offsetX * e11.sizeRatio)));
    const g9 = (t10, s9, o12) => c4(e11.offsetX) ? Math.round(u(e11.offsetX(t10, s9, o12) * e11.sizeRatio)) : d7;
    let u12;
    this._dynamicPropertyMap.set("_xOffset", g9), c4(e11.offsetY) || (u12 = Math.round(u(e11.offsetY * e11.sizeRatio)));
    const z4 = (t10, s9, o12) => c4(e11.offsetY) ? Math.round(u(e11.offsetY(t10, s9, o12) * e11.sizeRatio)) : u12;
    if (this._dynamicPropertyMap.set("_yOffset", z4), c4(e11.angle) ? this._dynamicPropertyMap.set("_angle", e11.angle) : this._angle = e11.angle, c4(e11.horizontalAlignment) ? this._dynamicPropertyMap.set("_horizontalAlignment", e11.horizontalAlignment) : this._horizontalAlignment = e11.horizontalAlignment, c4(e11.verticalAlignment) ? this._dynamicPropertyMap.set("_verticalAlignment", e11.verticalAlignment) : this._verticalAlignment = e11.verticalAlignment, r(e11.effects)) {
      const t10 = e11.effects;
      c4(t10) ? this._dynamicPropertyMap.set("_effects", t10) : this._effects = t10;
    }
    if (r(e11.markerPlacement)) {
      const t10 = e11.markerPlacement;
      c4(t10) ? this._dynamicPropertyMap.set("_markerPlacement", t10) : this._textPlacement = t10;
    }
    c4(e11.text) ? this._dynamicPropertyMap.set("_text", e11.text) : this._text = e11.text, this._scaleFactor = r13;
    const x10 = Math.min(Math.round(u(e11.referenceSize * e11.sizeRatio)), 127);
    this._referenceSize = Math.round(Math.sqrt(256 * x10)), this._materialKey = e11.materialKey;
    const P4 = P.load(this._materialKey);
    P4.sdf = true, this._bitset = (e11.alignment === i2.MAP ? 1 : 0) | (e11.colorLocked ? 1 : 0) << 1, this._materialKey = P4.data, this._decoration = "none", this._lineHeight = 1, this._lineWidth = 512, this._isCIM = true;
  }
  static fromCIMText(t10, e11) {
    const [i12, s9] = x3(t10.scaleInfo, e11);
    return new g7(t10, i12, s9);
  }
  async analyze(t10, e11, i12, s9) {
    const o11 = e11.readLegacyFeature(), a7 = d4(this._cimTextLayer, o11, i12, s9), n10 = await super.analyze(t10, e11, i12, s9, t7(a7));
    return n10 && n10.glyphMosaicItems && this._textToGlyphs.set(a7, n10.glyphMosaicItems), n10;
  }
  bindFeature(t10, i12, s9) {
    const n10 = t10.readLegacyFeature();
    if (this._dynamicPropertyMap.forEach((t11, e11) => {
      this[e11] = t11(n10, i12, s9);
    }), !this._text || 0 === this._text.length)
      return void (this._shapingInfo = null);
    this._size *= this._scaleFactor, this._scale = this._size / j2, this._xOffset *= this._scaleFactor, this._yOffset *= this._scaleFactor, this._xAlignD = r5(i(this._horizontalAlignment, "center")), this._yAlignD = n3(i(this._verticalAlignment, "baseline"));
    const l7 = this._textToGlyphs.get(this._text);
    this.bindTextInfo(l7, false);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLFillTemplate.js
var M5 = 128;
var j5 = class extends _3(r9) {
  constructor(t10, e11, i12, r13, o11, s9, l7, n10, m5, u12, d7, p9, y7, x10, M8, j7) {
    super(), this._effects = x10;
    const w7 = w2.load(t10);
    e11 && (w7.sdf = e11.sdf, w7.pattern = true, w7.textureBinding = e11.textureBinding), this.fillColor = i12, this.tl = r13, this.br = o11, this.aux21 = w(s9, l7), this.aux22 = w(n10, m5), this.aux3 = x(u12, d7, p9, 0), this._bitset = y7, this._minMaxZoom = w(Math.round(M8 * at), Math.round(j7 * at)), this._materialKey = w7.data;
  }
  static fromCIMFill(e11, a7, n10) {
    const c9 = e11.color, h5 = c9 && f3(c9) || 0, d7 = e11.materialKey, [p9, y7] = x3(e11.scaleInfo, n10), x10 = (e11.colorLocked ? nt2 : 0) | (e11.applyRandomOffset ? vt : 0) | (e11.sampleAlphaOnly ? gt : 0);
    if (!a7)
      return new j5(d7, null, h5, 0, 0, 0, 0, 0, 0, 0, 0, 0, x10, e11.effects, p9, y7);
    const { rect: w7, width: g9, height: K2 } = a7, _5 = e11.scaleX || 1, b6 = w7.x + et, F2 = w7.y + et, L3 = b6 + g9, T = F2 + K2, A3 = u(e11.height), B2 = _5 * A3;
    let G4 = Math.round(A3);
    G4 <= 0 && (G4 = T - F2);
    let S4 = Math.round(B2);
    S4 <= 0 && (S4 = L3 - b6);
    const C4 = u(e11.offsetX || 0), I2 = u(-e11.offsetY || 0), O3 = w(b6, F2), R = w(L3, T);
    return new j5(d7, a7, h5, O3, R, S4, G4, C4, I2, M5, M5, M(e11.angle), x10, e11.effects, p9, y7);
  }
  static fromSimpleFill(t10, i12, o11 = false) {
    const { color: s9 } = t10, a7 = s9 && "esriSFSNull" !== t10.style && s5(s9) || 0, n10 = o11 ? nt2 : 0, m5 = t10.materialKey;
    let c9;
    if (i12) {
      const { rect: t11, width: e11, height: r13, pixelRatio: o12 } = i12, s10 = t11.x + et, h5 = t11.y + et, u12 = s10 + e11, y7 = h5 + r13, x10 = w(s10, h5), w7 = w(u12, y7);
      c9 = new j5(m5, i12, a7, x10, w7, e11 / o12, r13 / o12, 0, 0, M5, M5, 0, n10, null, n7, o8);
    } else
      c9 = new j5(m5, null, a7, 0, 0, 0, 0, 0, 0, 0, 0, 0, n10, null, n7, o8);
    return c9._maybeAddLineTemplate(t10), c9;
  }
  static fromPictureFill(e11, i12, o11 = false) {
    const s9 = i3, { rect: a7, width: m5, height: c9 } = i12, h5 = a7.x + et, u12 = a7.y + et, y7 = h5 + m5, x10 = u12 + c9, w7 = w(h5, u12), g9 = w(y7, x10), K2 = Math.round(u(e11.width)), _5 = Math.round(u(e11.height)), b6 = u(e11.xoffset), F2 = u(-e11.yoffset), L3 = e11.materialKey, T = o11 ? nt2 : 0, A3 = new j5(L3, i12, s9, w7, g9, K2, _5, b6, F2, M5 * e11.xscale, M5 * e11.yscale, 0, T, null, n7, o8);
    return A3._maybeAddLineTemplate(e11), A3;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLMarkerTemplate.js
var b4 = class extends u9(r9) {
  constructor(t10, e11, r13, a7, n10, p9, S4, g9, V, z4, B2, b6, k5, L3, R, j7, w7, C4, P4, E4, U2, A3, T) {
    super(), this.angle = a7, this.height = S4, this.width = p9, this.xOffset = e11 * P4, this.yOffset = r13 * P4, this._markerPlacement = E4, this._effects = U2, this._anchorX = j7, this._anchorY = w7, this._minMaxZoom = w(Math.round(A3 * at), Math.round(T * at));
    const v5 = (L3 === i2.MAP ? rt : pt) | (B2 ? nt2 : 0) | (k5 ? st : 0) | (b6 ? ft : 0), K2 = R && R.sdf, W = N.load(t10);
    W.sdf = K2, W.pattern = true, W.textureBinding = R.textureBinding, this._materialKey = W.data, this._fillColor = n10, this._outlineColor = V, this._sizeOutlineWidth = x(Math.round(Math.min(Math.sqrt(128 * p9), 255)), Math.round(Math.min(Math.sqrt(128 * S4), 255)), Math.round(Math.min(Math.sqrt(128 * z4), 255)), Math.round(Math.min(Math.sqrt(128 * g9), 255)));
    const X2 = R.rect.x + et, q2 = R.rect.y + et, Y = X2 + R.width, H = q2 + R.height;
    this._offsets.xUpperLeft = X2, this._offsets.yUpperLeft = q2, this._offsets.xUpperRight = Y, this._offsets.yUpperRight = q2, this._offsets.xBottomLeft = X2, this._offsets.yBottomLeft = H, this._offsets.xBottomRight = Y, this._offsets.yBottomRight = H, W.symbologyType === S.PIE_CHART ? (this._texUpperLeft = w(0, 1), this._texUpperRight = w(1, 1), this._texBottomLeft = w(0, 0), this._texBottomRight = w(1, 0)) : (this._texUpperLeft = w(X2, q2), this._texUpperRight = w(Y, q2), this._texBottomLeft = w(X2, H), this._texBottomRight = w(Y, H)), p9 *= C4, S4 *= C4, p9 *= P4, S4 *= P4;
    const I2 = Math.round(64 * C4);
    this._bitestAndDistRatio = w(v5, I2), this._computedWidth = p9, this._computedHeight = S4;
    const N2 = n(), O3 = n4();
    this._applyTransformation(O3, N2);
  }
  static fromCIMMarker(o11, s9, r13) {
    const n10 = s9 && s9.width || 1, h5 = s9 && s9.height || 1, l7 = o11.size, m5 = n10 / h5 * o11.scaleX, f14 = o11.scaleSymbolsProportionally && o11.frameHeight ? l7 / o11.frameHeight : 1;
    let c9 = f3(o11.color);
    const u12 = f3(o11.outlineColor), d7 = u(l7), p9 = d7 * m5, x10 = u(o11.offsetX || 0), M8 = u(o11.offsetY || 0), y7 = u(o11.outlineWidth || 0) * f14, _5 = o11.alignment || i2.SCREEN, g9 = u(o11.referenceSize), [V, z4] = x3(o11.scaleInfo, r13);
    s9.sdf || 0 !== c9 || (c9 = -1);
    let B2 = o11.rotation || 0;
    o11.rotateClockwise || (B2 = -B2);
    let k5 = 0, L3 = 0;
    const R = o11.anchorPoint;
    R && (o11.isAbsoluteAnchorPoint ? l7 && (k5 = R.x / (l7 * m5), L3 = R.y / l7) : (k5 = R.x, L3 = R.y));
    const j7 = new b4(o11.materialKey, x10, M8, B2, c9, p9, d7, g9, u12, y7, o11.colorLocked, o11.scaleSymbolsProportionally, false, _5, s9, k5, L3, o11.sizeRatio, i(o11.scaleFactor, 1), o11.markerPlacement, o11.effects, V, z4);
    return j7._vertexBoundsScaleX = o11.maxVVSize ? o11.maxVVSize / p9 : 1, j7._vertexBoundsScaleY = o11.maxVVSize ? o11.maxVVSize / d7 : 1, j7;
  }
  static fromPictureMarker(t10, o11) {
    const s9 = Math.round(u(t10.width)), r13 = Math.round(u(t10.height)), a7 = i3, n10 = Math.round(u(t10.xoffset || 0)), h5 = Math.round(u(t10.yoffset || 0)), l7 = new b4(t10.materialKey, n10, h5, t10.angle, a7, s9, r13, r13, 0, 0, false, false, false, i2.SCREEN, o11, 0, 0, 1, 1, null, null, n7, o8);
    return l7._vertexBoundsScaleX = t10.maxVVSize ? t10.maxVVSize / t10.width : 1, l7._vertexBoundsScaleY = t10.maxVVSize ? t10.maxVVSize / t10.height : 1, l7;
  }
  static fromSimpleMarker(t10, o11) {
    const s9 = s5(t10.color), r13 = Math.round(u(t10.size)), a7 = r13, h5 = Math.round(u(t10.xoffset || 0)), l7 = Math.round(u(t10.yoffset || 0)), m5 = t10.style, f14 = t10.outline, c9 = 0 | (f14 && f14.color && s5(f14.color)), u12 = 0 | (f14 && f14.width && Math.round(u(f14.width))), d7 = new b4(t10.materialKey, h5, l7, t10.angle, s9, r13, a7, a7, c9, u12, false, false, "esriSMSCross" === m5 || "esriSMSX" === m5, i2.SCREEN, o11, 0, 0, 126 / 64, 1, null, null, n7, o8);
    return d7.boundsType = "esriSMSCircle" === m5 ? "circle" : "square", d7._vertexBoundsScaleX = t10.maxVVSize ? t10.maxVVSize / t10.size : 1, d7._vertexBoundsScaleY = t10.maxVVSize ? t10.maxVVSize / t10.size : 1, d7;
  }
  static fromLineSymbolMarker(t10, o11) {
    const s9 = s5(t10.color), a7 = 6, h5 = Math.round(u(a7 * t10.lineWidth)), l7 = h5, m5 = "cross" === t10.style || "x" === t10.style;
    let f14;
    switch (t10.placement) {
      case "begin-end":
        f14 = o3.Both;
        break;
      case "begin":
        f14 = o3.JustBegin;
        break;
      case "end":
        f14 = o3.JustEnd;
        break;
      default:
        f14 = o3.None;
    }
    const c9 = { type: "CIMMarkerPlacementAtExtremities", angleToLine: true, offset: 0, extremityPlacement: f14, offsetAlongLine: 0 }, u12 = new b4(t10.materialKey, 0, 0, 0, s9, h5, l7, l7 / a7, s9, m5 ? Math.round(u(t10.lineWidth)) : 0, false, false, m5, i2.MAP, o11, 0, 0, 126 / 64, 1, c9, null, n7, o8);
    return u12.boundsType = "circle" === t10.style ? "circle" : "square", u12;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLTextTemplate.js
var M6 = 5;
var p7 = class extends _4(r9) {
  constructor(t10, a7, l7, _5, d7, x10, z4, u12, p9, g9, j7, S4, y7, b6, T, V, A3, C4, I2 = false, K2, R) {
    super(), this._xOffset = u(y7), this._yOffset = u(b6), this._decoration = g9 || "none", this._color = d7, this._haloColor = x10, this._haloSize = Math.min(Math.floor(M6 * u(o2(l7))), 127), this._size = Math.min(Math.round(u(a7)), 127);
    const v5 = Math.min(Math.round(u(_5 || a7)), 127);
    this._referenceSize = Math.round(Math.sqrt(256 * v5)), this._scale = this._size / j2, this._angle = S4, this._justify = s6(z4 || "center"), this._xAlignD = r5(z4 || "center"), this._yAlignD = n3(u12 || "baseline"), this._baseline = "baseline" === (u12 || "baseline"), this._bitset = (p9 === i2.MAP ? 1 : 0) | (j7 ? 1 : 0) << 1;
    const B2 = U.load(t10);
    B2.sdf = true, this._materialKey = B2.data, this._lineWidth = u(T) || 512, this._lineHeight = V || 1, this._textPlacement = A3, this._effects = C4, this._isCIM = I2, this._minMaxZoom = w(Math.round(K2 * at), Math.round(R * at));
  }
  static fromText(e11, i12) {
    const s9 = new p7(e11.materialKey, e11.font.size, e11.haloSize || 0, e11.font.size, e11.color && s5(e11.color) || 0, e11.haloColor && s5(e11.haloColor) || 0, e11.horizontalAlignment, e11.verticalAlignment, i2.SCREEN, e11.font.decoration, false, e11.angle || 0, e11.xoffset, e11.yoffset, e11.lineWidth, e11.lineHeight, null, null, false, n7, o8), [, n10] = n2(e11.text);
    return s9.bindTextInfo(i12, n10), s9._vertexBoundsScale = e11.maxVVSize ? e11.maxVVSize / e11.font.size : 1, s9;
  }
  static fromCIMText(e11, i12, o11) {
    const s9 = e11.scaleFactor || 1, n10 = e11.size * e11.sizeRatio * s9, [r13, a7] = x3(e11.scaleInfo, o11), m5 = new p7(e11.materialKey, n10, e11.outlineSize * e11.sizeRatio, e11.referenceSize, f3(e11.color), f3(e11.outlineColor), e11.horizontalAlignment, e11.verticalAlignment, e11.alignment, e11.decoration, e11.colorLocked, e11.angle, e11.offsetX * e11.sizeRatio * s9, e11.offsetY * e11.sizeRatio * s9, 512, 1, e11.markerPlacement, e11.effects, true, r13, a7), [, h5] = n2(e11.text);
    return m5.bindTextInfo(i12, h5), m5._vertexBoundsScale = e11.maxVVSize ? e11.maxVVSize / n10 : 1, m5;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Lock.js
var r11 = class {
  constructor() {
    this._resolver = null;
  }
  isHeld() {
    return !!this._resolver;
  }
  async acquire() {
    this._resolver ? (await this._resolver.promise, await this.acquire()) : this._resolver = D();
  }
  release() {
    const e11 = this._resolver;
    this._resolver = null, e11 == null ? void 0 : e11.resolve();
  }
};
async function s8(e11, r13, s9) {
  try {
    await e11.acquire(), await r13(s9), e11.release();
  } catch (t10) {
    throw e11.release(), t10;
  }
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLTemplateStore.js
var S2 = s.getLogger("esri.views.2d.engine.webgl.mesh.templates.WGLTemplateStore");
var w5 = new Array();
var k4 = { isOutline: false, placement: null, symbologyType: S.DEFAULT, vvFlags: 0 };
var C3 = { ...r2, hash: JSON.stringify(r2), materialKey: f4(E.MARKER, k4) };
var L = { ...s3, hash: JSON.stringify(s3), materialKey: f4(E.LINE, k4) };
var b5 = { ...y, hash: JSON.stringify(y), materialKey: f4(E.FILL, k4) };
function E3(e11, t10) {
  const r13 = e11.length;
  return e11.push(null), t10.then((t11) => e11[r13] = t11), e11;
}
function G2(e11) {
  return !!(1 & e11);
}
function j6(e11) {
  return "worker:port-closed" === e11.name;
}
var x8 = class {
  constructor(e11, t10) {
    this._idCounter = 1, this._templateIdCounter = 1, this._idToTemplateGroup = /* @__PURE__ */ new Map(), this._symbolToTemplate = /* @__PURE__ */ new Map(), this._fetchQueue = [], this._idToResolver = /* @__PURE__ */ new Map(), this._cimTemplateCache = /* @__PURE__ */ new Map(), this._cimAnalyses = [], this._lock = new r11(), this._fetchResource = e11, this._tileInfo = t10;
  }
  get _markerError() {
    return this._errorTemplates.marker[0];
  }
  get _fillError() {
    return this._errorTemplates.fill[0];
  }
  get _lineError() {
    return this._errorTemplates.line[0];
  }
  get _textError() {
    return this._errorTemplates.line[0];
  }
  createTemplateGroup(e11, t10) {
    this._initErrorTemplates();
    const r13 = e11.hash;
    if (this._symbolToTemplate.has(r13))
      return this._symbolToTemplate.get(r13);
    const s9 = new Array();
    t10 && this._createMeshTemplates(s9, t10, true), this._createMeshTemplates(s9, e11, false);
    const i12 = this._createGroupId("expanded-cim" === e11.type && F(e11));
    return this._idToTemplateGroup.set(i12, s9), this._symbolToTemplate.set(r13, i12), i12;
  }
  getTemplateGroup(e11) {
    return this._idToTemplateGroup.has(e11) ? this._idToTemplateGroup.get(e11) : w5;
  }
  getDynamicTemplateGroup(e11) {
    return this._idToTemplateGroup.has(e11) ? (G2(e11) || S2.error("mapview-template-store", `Id ${e11} does not refer to a dynamic template`), this._idToTemplateGroup.get(e11)) : w5;
  }
  getMosaicItem(e11, t10) {
    const r13 = this._createTemplateId(), s9 = new Promise((e12) => this._idToResolver.set(r13, e12));
    return this._fetchQueue.push({ symbol: e11, id: r13, glyphIds: t10 }), s9;
  }
  finalize(e11) {
    return this._fetchQueue.length || this._lock.isHeld() ? s8(this._lock, this._fetchAllQueuedResources.bind(this), e11) : Promise.resolve();
  }
  _initErrorTemplates() {
    this._errorTemplates || (this._errorTemplates = { fill: this._createMeshTemplates([], b5, false), marker: this._createMeshTemplates([], C3, false), line: this._createMeshTemplates([], L, false) });
  }
  _fetchAllQueuedResources(t10) {
    if (!this._fetchQueue.length)
      return Promise.resolve();
    const s9 = this._fetchQueue, i12 = this._cimAnalyses;
    return this._fetchQueue = [], this._cimAnalyses = [], Promise.all(i12).then(() => this._fetchResource(s9, t10).then((e11) => {
      for (const { id: t11, mosaicItem: r13 } of e11) {
        this._idToResolver.get(t11)(r13), this._idToResolver.delete(t11);
      }
    })).catch((t11) => {
      j(t11) ? this._fetchQueue = this._fetchQueue.concat(s9) : j6(t11) || S2.error(new s2("mapview-template-store", "Unable to fetch requested texture resources", t11));
    });
  }
  _createGroupId(e11) {
    return this._idCounter++ << 1 | (e11 ? 1 : 0);
  }
  _createTemplateId() {
    return this._templateIdCounter++;
  }
  async _createSMS(e11) {
    const { spriteMosaicItem: t10 } = await this.getMosaicItem(e11);
    return e9(t10, S2) ? b4.fromSimpleMarker(e11, t10) : this._markerError;
  }
  async _createPMS(e11) {
    const { spriteMosaicItem: t10 } = await this.getMosaicItem(e11);
    return e9(t10, S2) ? b4.fromPictureMarker(e11, t10) : this._markerError;
  }
  async _createSFS(e11, t10) {
    const { spriteMosaicItem: r13 } = await this.getMosaicItem(e11);
    return e9(r13, S2) ? j5.fromSimpleFill(e11, r13, t10) : this._fillError;
  }
  async _createPFS(e11, t10) {
    const { spriteMosaicItem: r13 } = await this.getMosaicItem(e11);
    return e9(r13, S2) ? j5.fromPictureFill(e11, r13, t10) : this._fillError;
  }
  async _createSLS(e11, t10) {
    const { spriteMosaicItem: r13 } = await this.getMosaicItem(e11);
    return e9(r13, S2) ? K.fromSimpleLine(e11, r13) : this._lineError;
  }
  async _createLMS(e11) {
    const { spriteMosaicItem: t10 } = await this.getMosaicItem(e11);
    return e9(t10, S2) ? b4.fromLineSymbolMarker(e11, t10) : this._markerError;
  }
  async _createTS(e11) {
    const { glyphMosaicItems: t10 } = await this.getMosaicItem(e11);
    return p7.fromText(e11, t10);
  }
  async _createCIMText(e11) {
    const { glyphMosaicItems: t10 } = await this.getMosaicItem(i7(e11), t7(e11.text));
    return e9(t10, S2) ? p7.fromCIMText(e11, t10, this._tileInfo) : this._textError;
  }
  async _createCIMFill(e11) {
    const { spriteMosaicItem: t10 } = await this.getMosaicItem(i7(e11));
    return e9(t10, S2) ? j5.fromCIMFill(e11, t10, this._tileInfo) : this._fillError;
  }
  async _createCIMLine(e11) {
    const { spriteMosaicItem: t10 } = await this.getMosaicItem(i7(e11));
    return e9(t10, S2) ? K.fromCIMLine(e11, t10, this._tileInfo) : this._lineError;
  }
  async _createCIMMarker(e11) {
    const { spriteMosaicItem: t10 } = await this.getMosaicItem(i7(e11));
    return e9(t10, S2) ? b4.fromCIMMarker(e11, t10, this._tileInfo) : this._markerError;
  }
  async _createCIM(e11) {
    const t10 = e11.templateHash;
    if (this._cimTemplateCache.has(t10))
      return this._cimTemplateCache.get(t10);
    let r13;
    switch (e11.type) {
      case "marker":
        r13 = await this._createCIMMarker(e11);
        break;
      case "line":
        r13 = await this._createCIMLine(e11);
        break;
      case "fill":
        r13 = await this._createCIMFill(e11);
        break;
      case "text":
        r13 = await this._createCIMText(e11);
    }
    return this._cimTemplateCache.set(t10, r13), r13;
  }
  async _createDynamicCIM(e11) {
    const t10 = e11.templateHash;
    if (this._cimTemplateCache.has(t10))
      return this._cimTemplateCache.get(t10);
    let r13;
    switch (e11.type) {
      case "marker":
        r13 = P2.fromCIMMarker(e11, this._tileInfo);
        break;
      case "line":
        r13 = y4.fromCIMLine(e11, this._tileInfo);
        break;
      case "fill":
        r13 = M3.fromCIMFill(e11, this._tileInfo);
        break;
      case "text":
        r13 = g7.fromCIMText(e11, this._tileInfo);
    }
    return this._cimTemplateCache.set(t10, r13), r13;
  }
  _createPrimitiveMeshTemplates(e11, t10, r13) {
    switch (t10.type) {
      case "esriSMS":
        return E3(e11, this._createSMS(t10));
      case "esriPMS":
        return E3(e11, this._createPMS(t10));
      case "esriSFS":
        return E3(e11, this._createSFS(t10, r13));
      case "line-marker":
        return E3(e11, this._createLMS(t10));
      case "esriPFS":
        return E3(e11, this._createPFS(t10, r13));
      case "esriSLS":
        return E3(e11, this._createSLS(t10, false));
      case "esriTS":
        return E3(e11, this._createTS(t10));
      default:
        return S2.error("Unable to create mesh template for unknown symbol type {: $ }{symbol.type}"), e11;
    }
  }
  _createMeshTemplates(e11, t10, r13) {
    if (t10.type.includes("3d"))
      return S2.error("3D symbols are not supported with MapView"), e11;
    if ("expanded-cim" === t10.type) {
      for (const r14 of t10.layers)
        "function" == typeof r14.materialHash ? E3(e11, this._createDynamicCIM(r14)) : E3(e11, this._createCIM(r14));
      return e11;
    }
    if ("composite-symbol" === t10.type) {
      for (const s9 of t10.layers)
        this._createPrimitiveMeshTemplates(e11, s9, r13);
      return e11;
    }
    return "cim" === t10.type || "label" === t10.type || "web-style" === t10.type ? e11 : this._createPrimitiveMeshTemplates(e11, t10, r13);
  }
};
var F = (e11) => {
  if (!e11.layers)
    return false;
  for (const t10 of e11.layers)
    if ("function" == typeof t10.materialHash)
      return true;
  return false;
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/segmentUtils.js
function r12(t10, e11) {
  return t10[e11 + 1];
}
function h3(t10) {
  return t10.length - 1;
}
function a6(t10) {
  let e11 = 0;
  for (let s9 = 0; s9 < h3(t10); s9++)
    e11 += d5(t10, s9);
  return e11;
}
function d5(t10, e11, s9 = 1) {
  const [n10, i12] = r12(t10, e11);
  return Math.sqrt(n10 * n10 + i12 * i12) * s9;
}
var c7 = class {
  constructor(t10, e11, s9, n10, i12) {
    this._segments = t10, this._index = e11, this._distance = s9, this._xStart = n10, this._yStart = i12, this._done = false;
  }
  static create(t10) {
    return new c7(t10, 0, 0, t10[0][0], t10[0][1]);
  }
  clone() {
    return new c7(this._segments, this._index, this._distance, this.xStart, this.yStart);
  }
  equals(t10) {
    return this._index === t10._index || t10._index === this._index - 1 && (0 === this._distance || 1 === t10._distance) || t10._index === this._index + 1 && (1 === this._distance || 0 === t10._distance);
  }
  leq(t10) {
    return this._index < t10._index || this._index === t10._index && this._distance <= t10._distance;
  }
  geq(t10) {
    return this._index > t10._index || this._index === t10._index && this._distance >= t10._distance;
  }
  get _segment() {
    return this._segments[this._index + 1];
  }
  get angle() {
    const t10 = this.dy, e11 = (0 * t10 + -1 * -this.dx) / (1 * this.length);
    let s9 = Math.acos(e11);
    return t10 > 0 && (s9 = 2 * Math.PI - s9), s9;
  }
  get xStart() {
    return this._xStart;
  }
  get yStart() {
    return this._yStart;
  }
  get x() {
    return this.xStart + this.distance * this.dx;
  }
  get y() {
    return this.yStart + this.distance * this.dy;
  }
  get dx() {
    return this._segment[0];
  }
  get dy() {
    return this._segment[1];
  }
  get xMidpoint() {
    return this.xStart + 0.5 * this.dx;
  }
  get yMidpoint() {
    return this.yStart + 0.5 * this.dy;
  }
  get xEnd() {
    return this.xStart + this.dx;
  }
  get yEnd() {
    return this.yStart + this.dy;
  }
  get length() {
    const { dx: t10, dy: e11 } = this;
    return Math.sqrt(t10 * t10 + e11 * e11);
  }
  get remainingLength() {
    return this.length * (1 - this._distance);
  }
  get backwardLength() {
    return this.length * this._distance;
  }
  get distance() {
    return this._distance;
  }
  get done() {
    return this._done;
  }
  hasPrev() {
    return this._index - 1 >= 0;
  }
  hasNext() {
    return this._index + 1 < h3(this._segments);
  }
  next() {
    return this.hasNext() ? (this._xStart += this.dx, this._yStart += this.dy, this._distance = 0, this._index += 1, this) : null;
  }
  prev() {
    return this.hasPrev() ? (this._index -= 1, this._xStart -= this.dx, this._yStart -= this.dy, this._distance = 1, this) : (this._done = true, null);
  }
  _seekBackwards(t10, e11) {
    const s9 = this.backwardLength;
    if (t10 <= s9)
      return this._distance = (s9 - t10) / this.length, this;
    let n10 = this.backwardLength;
    for (; this.prev(); ) {
      if (n10 + this.length > t10)
        return this._seekBackwards(t10 - n10);
      n10 += this.length;
    }
    return this._distance = 0, e11 ? this : null;
  }
  seek(t10, e11 = false) {
    if (t10 < 0)
      return this._seekBackwards(Math.abs(t10), e11);
    if (t10 <= this.remainingLength)
      return this._distance = (this.backwardLength + t10) / this.length, this;
    let s9 = this.remainingLength;
    for (; this.next(); ) {
      if (s9 + this.length > t10)
        return this.seek(t10 - s9, e11);
      s9 += this.length;
    }
    return this._distance = 1, e11 ? this : null;
  }
};
function u10(t10, e11, s9, n10 = true) {
  const i12 = a6(t10), r13 = c7.create(t10), h5 = i12 / 2;
  if (!n10)
    return r13.seek(h5), void s9(r13.clone(), 0, h5 + 0 * e11, i12);
  const d7 = Math.max((i12 - e11) / 2, 0), u12 = Math.floor(d7 / e11), o11 = h5 - u12 * e11;
  r13.seek(o11);
  for (let a7 = -u12; a7 <= u12; a7++)
    r13.x < 512 && r13.x >= 0 && r13.y < 512 && r13.y >= 0 && s9(r13.clone(), a7, h5 + a7 * e11, i12), r13.seek(e11);
}
function l4(t10, e11) {
  const s9 = e11;
  for (let n10 = 0; n10 < t10.length; n10++) {
    let e12 = t10[n10];
    const i12 = [];
    i12.push(e12[0]);
    for (let t11 = 1; t11 < e12.length; t11++) {
      let [s10, n11] = i12[t11 - 1];
      s10 += e12[t11][0], n11 += e12[t11][1], i12.push([s10, n11]);
    }
    g8(i12, s9);
    const r13 = [];
    r13.push(i12[0]);
    for (let t11 = 1; t11 < i12.length; t11++) {
      const [e13, s10] = i12[t11 - 1], [n11, h5] = i12[t11], a7 = Math.round(n11 - e13), d7 = Math.round(h5 - s10);
      r13.push([a7, d7]);
    }
    t10[n10] = r13, e12 = r13;
  }
  return t10;
}
function g8(t10, e11) {
  const r13 = 1e-6;
  if (e11 <= 0)
    return;
  const h5 = t10.length;
  if (h5 < 3)
    return;
  const a7 = [];
  let d7 = 0;
  a7.push(0);
  for (let n10 = 1; n10 < h5; n10++)
    d7 += u3(t10[n10], t10[n10 - 1]), a7.push(d7);
  e11 = Math.min(e11, 0.2 * d7);
  const c9 = [];
  c9.push(t10[0][0]), c9.push(t10[0][1]);
  const u12 = t10[h5 - 1][0], o11 = t10[h5 - 1][1], _5 = t8([0, 0], t10[0], t10[1]);
  r7(_5), t10[0][0] += e11 * _5[0], t10[0][1] += e11 * _5[1], t8(_5, t10[h5 - 1], t10[h5 - 2]), r7(_5), t10[h5 - 1][0] += e11 * _5[0], t10[h5 - 1][1] += e11 * _5[1];
  for (let s9 = 1; s9 < h5; s9++)
    a7[s9] += e11;
  a7[h5 - 1] += e11;
  const l7 = 0.5 * e11;
  for (let s9 = 1; s9 < h5 - 1; s9++) {
    let n10 = 0, i12 = 0, d8 = 0;
    for (let h6 = s9 - 1; h6 >= 0 && !(a7[h6 + 1] < a7[s9] - l7); h6--) {
      const c10 = l7 + a7[h6 + 1] - a7[s9], u13 = a7[h6 + 1] - a7[h6], o12 = a7[s9] - a7[h6] < l7 ? 1 : c10 / u13;
      if (Math.abs(o12) < r13)
        break;
      const _6 = o12 * o12, g9 = o12 * c10 - 0.5 * _6 * u13, x10 = o12 * u13 / e11, f14 = t10[h6 + 1], y7 = t10[h6][0] - f14[0], k5 = t10[h6][1] - f14[1];
      n10 += x10 / g9 * (f14[0] * o12 * c10 + 0.5 * _6 * (c10 * y7 - u13 * f14[0]) - _6 * o12 * u13 * y7 / 3), i12 += x10 / g9 * (f14[1] * o12 * c10 + 0.5 * _6 * (c10 * k5 - u13 * f14[1]) - _6 * o12 * u13 * k5 / 3), d8 += x10;
    }
    for (let c10 = s9 + 1; c10 < h5 && !(a7[c10 - 1] > a7[s9] + l7); c10++) {
      const h6 = l7 - a7[c10 - 1] + a7[s9], u13 = a7[c10] - a7[c10 - 1], o12 = a7[c10] - a7[s9] < l7 ? 1 : h6 / u13;
      if (Math.abs(o12) < r13)
        break;
      const _6 = o12 * o12, g9 = o12 * h6 - 0.5 * _6 * u13, x10 = o12 * u13 / e11, f14 = t10[c10 - 1], y7 = t10[c10][0] - f14[0], k5 = t10[c10][1] - f14[1];
      n10 += x10 / g9 * (f14[0] * o12 * h6 + 0.5 * _6 * (h6 * y7 - u13 * f14[0]) - _6 * o12 * u13 * y7 / 3), i12 += x10 / g9 * (f14[1] * o12 * h6 + 0.5 * _6 * (h6 * k5 - u13 * f14[1]) - _6 * o12 * u13 * k5 / 3), d8 += x10;
    }
    c9.push(n10 / d8), c9.push(i12 / d8);
  }
  c9.push(u12), c9.push(o11);
  for (let s9 = 0, n10 = 0; s9 < h5; s9++)
    t10[s9][0] = c9[n10++], t10[s9][1] = c9[n10++];
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLLabelTemplate.js
var y6 = s.getLogger("esri.views.2d.engine.webgl.WGLLabelTemplate");
var x9 = (t10, i12 = "mapview-labeling") => y6.error(new s2(i12, t10));
var L2 = 1;
var P3 = 0;
var M7 = 4;
var S3 = 25;
function w6(e11, t10) {
  const n10 = !!e11.minScale && t10.scaleToZoom(e11.minScale) || 0;
  return a(n10, 0, 25.5);
}
function v4(e11, t10) {
  const n10 = !!e11.maxScale && t10.scaleToZoom(e11.maxScale) || 255;
  return a(n10, 0, 25.5);
}
function A2(e11) {
  const t10 = /* @__PURE__ */ new Map();
  return (i12) => (t10.has(i12) || t10.set(i12, e11(i12)), t10.get(i12));
}
var Z3 = A2((e11) => {
  let t10 = 0;
  if (0 === e11)
    return 1 / 0;
  for (; !(e11 % 2); )
    t10++, e11 /= 2;
  return t10;
});
var I = (e11) => Math.floor(127 * e11 + 127);
var O2 = (e11) => Math.floor(10 * e11);
var z3 = (e11) => Math.round(e11 * (254 / 360));
var G3 = class extends p7 {
  constructor(e11, t10, i12, n10) {
    var _a, _b, _c;
    super(e11, i12.font.size, i12.haloSize || 0, i12.font.size, i12.color && s5(i12.color) || 0, i12.haloColor && s5(i12.haloColor) || 0, i12.horizontalAlignment, i12.verticalAlignment, i5(t10.labelPlacement) ? i2.MAP : i2.SCREEN, i12.font.decoration, false, i12.angle || 0, i12.xoffset, i12.yoffset, i12.lineWidth, i12.lineHeight, null, null, null, null, null), this._outLineLabelAngle = 0, this._refPlacementPadding = 0, this._refPlacementDirX = 0, this._refPlacementDirY = 0, this._refOffsetX = 0, this._refOffsetY = 0, this._zoomLevel = 0, this.geometryType = E.LABEL, this._allowOverrun = (_a = t10.allowOverrun) != null ? _a : false, this._repeatLabel = (_b = t10.repeatLabel) != null ? _b : true, this._labelPosition = (_c = t10.labelPosition) != null ? _c : "curved";
    const o11 = w6(t10, n10), h5 = v4(t10, n10), c9 = t10.labelPlacement, [g9, u12] = a2(c9);
    this._xAlignD = g9, this._yAlignD = u12, this._minZoom = o11, this._maxZoom = h5, this._refPlacementPadding = u(i12.haloSize) + k, this._repeatLabelDistance = t10.repeatLabelDistance ? u(t10.repeatLabelDistance) : 128;
    const d7 = Z.load(e11);
    d7.sdf = true, this._materialKey = d7.data;
  }
  static fromLabelClass(e11, t10) {
    if ("esriServerLinePlacementCenterAlong" === e11.labelPlacement) {
      const t11 = e11.symbol;
      t11.xoffset = 0, t11.yoffset = 0, t11.angle = 0, t11.font.decoration = "none";
    }
    return new G3(e11.materialKey, e11, e11.symbol, t10);
  }
  get _shapedBox() {
    return e(this._shapingInfo).bounds;
  }
  setZoomLevel(e11) {
    this._zoomLevel = e11;
  }
  bindReferenceTemplate(e11) {
    let t10 = c(this._xAlignD), i12 = o6(this._yAlignD);
    if (this._refOffsetX = 0, this._refOffsetY = 0, t(e11))
      return void (this._refSymbolAndPlacementOffset = x(0, 0, I(t10), I(i12)));
    if ("circle" === e11.boundsType && (t10 || i12)) {
      const e12 = Math.sqrt(t10 * t10 + i12 * i12);
      t10 /= e12, i12 /= e12;
    }
    const n10 = Math.max(e11.height, e11.width), s9 = this._refPlacementPadding * M7;
    this._refSymbolAndPlacementOffset = x(s9, n10, I(t10), I(i12)), this._referenceSize = n10, this._refPlacementDirX = t10, this._refPlacementDirY = i12, this._refOffsetX = e11.xOffset, this._refOffsetY = e11.yOffset;
  }
  _write(e11, t10) {
    if (t(this._shapingInfo))
      return;
    const i12 = this._shapingInfo, n10 = t10.getDisplayId(), s9 = "esriGeometryPolygon" === t10.geometryType ? t10.readLegacyCentroid() : t10.readLegacyGeometry();
    if (s9)
      switch (this._current = { out: e11, inId: n10, inShaping: i12, zoomLevel: this._zoomLevel }, t10.geometryType) {
        case "esriGeometryPolyline":
          this._placeLineLabels(s9);
          break;
        case "esriGeometryPoint":
        case "esriGeometryPolygon":
          this._placePointLabels(s9);
          break;
        default:
          x9("mapview-labeling", `Geometry of type ${t10.geometryType} is not supported`);
      }
  }
  _isVisible(e11, t10) {
    const i12 = O2(this._current.zoomLevel);
    return O2(e11) <= i12 && i12 <= O2(t10);
  }
  _placePointLabels(e11) {
    const { out: t10, inId: i12, inShaping: n10 } = this._current;
    this._writeGlyphs(t10, i12, e11, n10);
  }
  _placeLineLabels(e11) {
    const t10 = l4(e11.paths, this._current.inShaping.bounds.width), i12 = this._placeSubdivGlyphs.bind(this), n10 = (this._shapedBox.width + this._repeatLabelDistance) / (1 << L2);
    for (const o11 of t10)
      u10(o11, n10, i12, this._repeatLabel);
  }
  _placeSubdivGlyphs(e11, t10, i12, n10) {
    const o11 = Z3(t10), s9 = this._shapedBox.width / (1 << L2), r13 = Math.sqrt(this._repeatLabelDistance) / (1 << L2), a7 = Math.min(i12, n10 - i12), l7 = this._current.inShaping.isMultiline ? S3 : Math.log2(a7 / (r13 + s9 / 2)), h5 = 0 === t10 ? l7 : Math.min(o11, l7), c9 = Math.max(this._minZoom, this._current.zoomLevel + L2 - h5), m5 = this._current.zoomLevel - c9, _5 = this._shapedBox.width / 2 * 2 ** m5;
    this._current.inShaping.isMultiline ? 0 === t10 && this._placeStraight(e11, c9) : this._allowOverrun && m5 < 0 ? this._placeStraightAlong(e11, this._minZoom) : "parallel" === this._labelPosition ? this._placeStraightAlong(e11, c9) : "curved" === this._labelPosition && this._placeCurved(e11, c9, _5);
  }
  _placeStraight(e11, t10) {
    const { out: i12, inId: n10, inShaping: o11 } = this._current, s9 = Math.ceil(e11.angle * (180 / Math.PI) % 360), r13 = Math.ceil((e11.angle * (180 / Math.PI) + 180) % 360);
    this._outLineLabelAngle = z3(s9), this._writeGlyphs(i12, n10, e11, o11, t10), this._outLineLabelAngle = z3(r13), this._writeGlyphs(i12, n10, e11, o11, t10);
  }
  _placeCurved(e11, t10, i12) {
    const { out: n10, inId: o11 } = this._current;
    n10.metricStart(o11, t10, e11.x, e11.y, 0, 0, 0, 0);
    const s9 = e11.clone(), r13 = e11.angle * (180 / Math.PI) % 360, a7 = (e11.angle * (180 / Math.PI) + 180) % 360;
    this._outLineLabelAngle = z3(r13), this._placeFirst(s9, t10, 1), this._placeBack(e11, s9, t10, i12, 1), this._placeForward(e11, s9, t10, i12, 1), this._outLineLabelAngle = z3(a7), this._placeFirst(s9, t10, 0), this._placeBack(e11, s9, t10, i12, 0), this._placeForward(e11, s9, t10, i12, 0), n10.metricEnd();
  }
  _placeStraightAlong(e11, t10) {
    const { out: i12, inId: n10 } = this._current;
    i12.metricStart(n10, t10, e11.x, e11.y, 0, 0, 0, 0);
    const o11 = e11.clone(), s9 = e11.angle * (180 / Math.PI) % 360, r13 = (e11.angle * (180 / Math.PI) + 180) % 360;
    this._outLineLabelAngle = z3(s9), this._placeFirst(o11, t10, 1, true), this._outLineLabelAngle = z3(r13), this._placeFirst(o11, t10, 0, true), i12.metricEnd();
  }
  _placeBack(e11, t10, i12, n10, o11) {
    const s9 = e11.clone();
    let r13 = e11.backwardLength + P3;
    for (; s9.prev() && !(r13 >= n10); )
      this._placeOnSegment(s9, t10, r13, i12, -1, o11), r13 += s9.length + P3;
  }
  _placeForward(e11, t10, i12, n10, o11) {
    const s9 = e11.clone();
    let r13 = e11.remainingLength + P3;
    for (; s9.next() && !(r13 >= n10); )
      this._placeOnSegment(s9, t10, r13, i12, 1, o11), r13 += s9.length + P3;
  }
  _placeFirst(e11, t10, i12, n10 = false) {
    const o11 = e11, s9 = this._current.inShaping, r13 = s9.glyphs, a7 = this._current.zoomLevel, { out: l7, inId: h5 } = this._current;
    for (const c9 of r13) {
      const r14 = c9.x > s9.bounds.x ? i12 : 1 - i12, m5 = r14 * e11.remainingLength + (1 - r14) * e11.backwardLength, _5 = Math.abs(c9.x + c9.width / 2 - s9.bounds.x), f14 = Math.max(0, a7 + Math.log2(_5 / (m5 + P3))), g9 = Math.max(t10, n10 ? 0 : f14);
      if (c9.maxZoom = S3, c9.angle = e11.angle + (1 - i12) * Math.PI, c9.minZoom = g9, this._writeGlyph(l7, h5, o11.x, o11.y, c9), i12 && this._isVisible(c9.minZoom, c9.maxZoom)) {
        const e12 = c9.bounds;
        l7.metricBoxWrite(e12.center[0], e12.center[1], e12.width, e12.height);
      }
    }
  }
  _placeOnSegment(e11, t10, i12, n10, o11, s9) {
    const r13 = this._current.inShaping.glyphs, { out: a7, inId: l7 } = this._current, h5 = this._current.inShaping, c9 = this._current.zoomLevel, m5 = e11.dx / e11.length, _5 = e11.dy / e11.length, f14 = { x: e11.x + i12 * -o11 * m5, y: e11.y + i12 * -o11 * _5 };
    for (const g9 of r13) {
      const r14 = g9.x > h5.bounds.x ? s9 : 1 - s9;
      if (!(r14 && 1 === o11 || !r14 && -1 === o11))
        continue;
      const m6 = Math.abs(g9.x + g9.width / 2 - h5.bounds.x), _6 = Math.max(0, c9 + Math.log2(m6 / i12) - 0.1), p9 = Math.max(n10, c9 + Math.log2(m6 / (i12 + e11.length + P3)));
      if (0 !== _6 && (g9.angle = e11.angle + (1 - s9) * Math.PI, g9.minZoom = p9, g9.maxZoom = _6, this._writeGlyph(a7, l7, f14.x, f14.y, g9), s9 && this._isVisible(g9.minZoom, g9.maxZoom))) {
        const i13 = g9.bounds, n11 = e11.x - t10.x, o12 = e11.y - t10.y;
        a7.metricBoxWrite(i13.center[0] + n11, i13.center[1] + o12, i13.width, i13.height);
      }
    }
  }
  _writeGlyphs(e11, t10, i12, n10, o11 = this._minZoom) {
    if (i12.x < 0 || i12.x >= 512 || i12.y < 0 || i12.y >= 512)
      return;
    const s9 = i12.x + this._refOffsetX, r13 = i12.y - this._refOffsetY;
    for (const c9 of n10.glyphs)
      c9.minZoom = o11, c9.maxZoom = this._maxZoom, this._writeGlyph(e11, t10, s9, r13, c9);
    const a7 = this._refPlacementDirX, l7 = this._refPlacementDirY, h5 = n10.boundsT;
    e11.metricStart(t10, o11, s9, r13, a7, l7, this._referenceSize, this._materialKey), e11.metricBoxWrite(h5.center[0], h5.center[1], h5.width, h5.height), e11.metricEnd();
  }
  _writeVertexCommon(e11, t10, i12, n10) {
    const o11 = this._color, s9 = this._haloColor, r13 = x(0, 0, this._size, this._haloSize), a7 = Math.max(n10.minZoom, this._minZoom), l7 = Math.min(n10.maxZoom, this._maxZoom), h5 = x(O2(a7), O2(l7), this._outLineLabelAngle, 0);
    e11.vertexWrite(i12), e11.vertexWrite(t10), e11.vertexWrite(o11), e11.vertexWrite(s9), e11.vertexWrite(r13), e11.vertexWrite(this._refSymbolAndPlacementOffset), e11.vertexWrite(h5);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/factories/WGLMeshFactory.js
var l5 = class {
  constructor(e11, t10, s9) {
    this._loadPromise = i4(), this._geometryType = e11, this._idField = t10, this._templateStore = s9;
  }
  update(t10, r13) {
    r(t10.mesh.labels) && (this._labelTemplates = this._createLabelTemplates(t10.mesh.labels, r13)), this._schema = t10;
  }
  _createLabelTemplates(e11, t10) {
    const r13 = /* @__PURE__ */ new Map();
    if ("simple" === e11.type) {
      for (const s9 of e11.classes) {
        const e12 = G3.fromLabelClass(s9, t10);
        r13.set(s9.index, e12);
      }
      return r13;
    }
    for (const s9 in e11.classes) {
      const o11 = e11.classes[s9];
      for (const e12 of o11) {
        const s10 = G3.fromLabelClass(e12, t10);
        r13.set(e12.index, s10);
      }
    }
    return r13;
  }
  get templates() {
    return this._templateStore;
  }
  async analyze(r13, i12, o11, l7, n10, m5, p9) {
    if (p(p9))
      return;
    let f14;
    "dictionary" === o11.type && (f14 = await o11.analyze(this._idField, r13.copy(), i12, n10, m5, p9));
    let c9 = 0;
    for (; r13.next(); ) {
      let t10;
      if (t10 = f14 ? f14[c9++] : r(l7) && p2(r13.getDisplayId()) && 1 !== r13.readAttribute("cluster_count") ? l7.match(this._idField, r13, this._geometryType, n10, m5) : o11.match(this._idField, r13, this._geometryType, n10, m5), r13.setGroupId(t10), G2(t10)) {
        const e11 = this._templateStore.getDynamicTemplateGroup(t10);
        for (const t11 of e11)
          t11 && t11.analyze && t11.analyze(this._templateStore, r13, n10, m5);
      }
    }
    return await this._loadPromise, this._templateStore.finalize(p9);
  }
  async analyzeGraphics(e11, r13, s9, i12, o11, l7) {
    if (p(l7))
      return;
    const n10 = e11.getCursor();
    for (s9 && await s9.analyze(this._idField, n10.copy(), r13, i12, o11, l7); n10.next(); ) {
      let e12 = n10.getGroupId();
      if (null != e12 && -1 !== e12 || (e12 = s9.match(this._idField, n10, n10.geometryType, i12, o11), n10.setGroupId(e12)), G2(e12)) {
        const t10 = this._templateStore.getDynamicTemplateGroup(e12);
        for (const e13 of t10)
          e13 && e13.analyze && e13.analyze(this._templateStore, n10, i12, o11);
      }
      n10.setGroupId(e12);
    }
    return await this._loadPromise, this._templateStore.finalize(l7);
  }
  writeGraphic(e11, t10, r13, s9) {
    const i12 = t10.getGroupId(), o11 = t10.getDisplayId(), l7 = this._templateStore.getTemplateGroup(i12);
    if (e11.featureStart(t10.insertAfter, 0), null != o11) {
      if (G2(i12))
        for (const e12 of l7)
          e12 && e12.bindFeature(t10, null, null);
      if (l7) {
        for (const i13 of l7)
          i13 && i13.write(e11, t10, r13, s9);
        e11.featureEnd();
      }
    }
  }
  writeCursor(t10, r13, s9, i12, o11, l7, n10) {
    const m5 = r13.getGroupId(), p9 = r13.getDisplayId(), f14 = this._templateStore.getTemplateGroup(m5), c9 = this._schema.mesh.sortKey;
    let d7 = 0;
    if (r(c9) && (d7 = null != c9.fieldIndex ? r13.getComputedNumericAtIndex(c9.fieldIndex) : null != c9.field ? r13.readAttribute(c9.field) : r13.readAttribute(this._idField), d7 *= "asc" === c9.order ? 1 : -1), t10.featureStart(0, null == d7 || isNaN(d7) ? 0 : d7), null != p9 && f14) {
      if (G2(m5))
        for (const e11 of f14)
          e11.bindFeature(r13, s9, i12);
      for (const e11 of f14)
        e11.write(t10, r13, o11, n10);
      if (r(l7) && t10.hasRecords) {
        const e11 = l7 && this._findLabelRef(f14);
        this._writeLabels(t10, r13, l7, e11, o11, n10);
      }
      t10.featureEnd();
    }
  }
  _findLabelRef(e11) {
    for (const t10 of e11)
      if (t10 instanceof b4)
        return t10;
    return null;
  }
  _writeLabels(t10, r13, s9, i12, o11, a7) {
    for (const l7 of s9)
      if (r(l7) && l7) {
        const { glyphs: e11, rtl: s10, index: n10 } = l7, m5 = this._labelTemplates.get(n10);
        m5.setZoomLevel(o11), m5.bindReferenceTemplate(i12), m5.bindTextInfo(e11, s10), m5.write(t10, r13, null, a7);
      }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Matcher.js
var n9 = s.getLogger("esri/views/2d/engine/webgl/util/Matcher");
async function l6(e11, t10, s9, r13) {
  switch (e11.type) {
    case "simple":
    case "heatmap":
      return o10.fromBasicRenderer(e11, t10, s9, r13);
    case "map":
      return m4.fromUVRenderer(e11, t10, s9, r13);
    case "interval":
      return c8.fromCBRenderer(e11, t10, s9, r13);
    case "dictionary":
      return p8.fromDictionaryRenderer(e11, t10, s9, r13);
    case "pie-chart":
      return u11.fromPieChartRenderer(e11, t10, s9, r13);
    case "subtype":
      return u11.fromSubtypes(e11, t10, s9, r13);
  }
}
var o10 = class {
  constructor() {
    this.type = "feature", this._defaultResult = null;
  }
  static async fromBasicRenderer(e11, t10, s9, r13) {
    const i12 = new o10();
    if (e11.symbol) {
      const n10 = await n6(e11.symbol, s9, r13), l7 = t10.createTemplateGroup(n10, null);
      i12.setDefault(l7);
    }
    return i12;
  }
  static async fromPieChartRenderer(e11, t10, s9, r13) {
    const i12 = new o10();
    if (e11.markerSymbol) {
      const n10 = await n6(e11.markerSymbol, s9, r13);
      let l7;
      e11.fillSymbol && (l7 = await n6(e11.fillSymbol, s9, r13));
      const o11 = t10.createTemplateGroup(n10, l7);
      i12.setDefault(o11);
    }
    return i12;
  }
  size() {
    return 1;
  }
  getDefault() {
    return this._defaultResult;
  }
  setDefault(e11) {
    this._defaultResult = e11;
  }
  match(e11, t10, s9, r13, i12) {
    return this.getDefault();
  }
  async analyze(e11, t10, s9, r13, i12, a7) {
    return null;
  }
};
var u11 = class extends o10 {
  constructor(e11, t10) {
    super(), this._subMatchers = e11, this._subtypeField = t10;
  }
  static async fromSubtypes(e11, t10, s9, r13) {
    const i12 = /* @__PURE__ */ new Map(), a7 = [];
    for (const n10 in e11.renderers) {
      const o11 = parseInt(n10, 10), u12 = l6(e11.renderers[n10], t10, s9, r13).then((e12) => i12.set(o11, e12));
      a7.push(u12);
    }
    return await Promise.all(a7), new u11(i12, e11.subtypeField);
  }
  match(e11, t10, s9, r13, i12) {
    const a7 = t10.readAttribute(this._subtypeField), n10 = this._subMatchers.get(a7);
    return n10 ? n10.match(e11, t10, s9, r13, i12) : null;
  }
};
var c8 = class extends o10 {
  constructor(e11, t10, s9, r13) {
    super(), this.type = "interval", this._intervals = [], this._isMaxInclusive = t10, this._fieldIndex = r13, this._field = e11, this._normalizationInfo = s9;
  }
  static async fromCBRenderer(e11, t10, s9, r13) {
    const { isMaxInclusive: i12, normalizationField: n10, normalizationTotal: l7, normalizationType: o11 } = e11, u12 = e11.field, m5 = new c8(u12, i12, { normalizationField: n10, normalizationTotal: l7, normalizationType: o11 }, e11.fieldIndex), d7 = await n6(e11.backgroundFillSymbol, s9, r13);
    await Promise.all(e11.intervals.map(async (e12) => {
      const i13 = await n6(e12.symbol, s9, r13), n11 = await t10.createTemplateGroup(i13, d7), l8 = { min: e12.min, max: e12.max };
      m5.add(l8, n11);
    }));
    const h5 = await n6(e11.defaultSymbol, s9, r13);
    if (h5) {
      const e12 = await t10.createTemplateGroup(h5, d7);
      m5.setDefault(e12);
    }
    return m5;
  }
  add(e11, t10) {
    this._intervals.push({ interval: e11, result: t10 }), this._intervals.sort((e12, t11) => e12.interval.min - t11.interval.min);
  }
  size() {
    return super.size() + this._intervals.length;
  }
  match(e11, t10, s9, r13, i12) {
    if (null == this._fieldIndex && !this._field)
      return this.getDefault();
    const a7 = null != this._fieldIndex ? t10.getComputedNumericAtIndex(this._fieldIndex) : this._getValueFromField(t10);
    if (null == a7 || isNaN(a7) || a7 === 1 / 0 || a7 === -1 / 0)
      return this.getDefault();
    for (let n10 = 0; n10 < this._intervals.length; n10++) {
      const { interval: e12, result: t11 } = this._intervals[n10], s10 = a7 >= e12.min, r14 = this._isMaxInclusive ? a7 <= e12.max : a7 < e12.max;
      if (s10 && r14)
        return t11;
    }
    return this.getDefault();
  }
  _needsNormalization() {
    const e11 = this._normalizationInfo;
    return e11 && (e11.normalizationField || e11.normalizationTotal || e11.normalizationType);
  }
  _getValueFromField(e11) {
    const t10 = e11.readAttribute(this._field);
    if (!this._needsNormalization() || null == t10)
      return t10;
    const { normalizationField: s9, normalizationTotal: r13, normalizationType: i12 } = this._normalizationInfo, a7 = !!s9 && e11.readAttribute(s9);
    if (i12)
      switch (i12) {
        case "esriNormalizeByField":
          return a7 ? t10 / a7 : void 0;
        case "esriNormalizeByLog":
          return Math.log(t10) * Math.LOG10E;
        case "esriNormalizeByPercentOfTotal":
          return t10 / r13 * 100;
        default:
          return void n9.error(`Found unknown normalization type: ${i12}`);
      }
    else
      n9.error("Normalization is required, but no type was set!");
  }
};
var m4 = class extends o10 {
  constructor(e11, t10, s9) {
    super(), this.type = "map", this._nullResult = null, this._resultsMap = /* @__PURE__ */ new Map(), this._fieldsIndex = s9, this._fields = e11, this._seperator = t10 || "";
  }
  static async fromUVRenderer(e11, t10, s9, r13) {
    const i12 = e11.fieldDelimiter, n10 = [e11.field];
    e11.field2 && n10.push(e11.field2), e11.field3 && n10.push(e11.field3);
    const l7 = await n6(e11.backgroundFillSymbol, s9, r13), o11 = new m4(n10, i12, e11.fieldIndex);
    await Promise.all(e11.map.map(async (e12) => {
      const i13 = await n6(e12.symbol, s9, r13), n11 = await t10.createTemplateGroup(i13, l7);
      "<Null>" === e12.value ? o11.setNullResult(n11) : o11.add(e12.value, n11);
    }));
    const u12 = await n6(e11.defaultSymbol, s9, r13);
    if (u12) {
      const e12 = await t10.createTemplateGroup(u12, l7);
      o11.setDefault(e12);
    }
    return o11;
  }
  setNullResult(e11) {
    this._nullResult = e11;
  }
  add(e11, t10) {
    this._resultsMap.set(e11.toString(), t10);
  }
  size() {
    return super.size() + this._resultsMap.size;
  }
  match(e11, t10, s9, r13, i12) {
    if (null == this._fieldsIndex && !this._fields)
      return this.getDefault();
    const a7 = null != this._fieldsIndex ? t10.getComputedStringAtIndex(this._fieldsIndex) : this._getValueFromFields(t10);
    if (null !== this._nullResult && (null == a7 || "" === a7 || "<Null>" === a7))
      return this._nullResult;
    if (null == a7)
      return this.getDefault();
    const n10 = a7.toString();
    return this._resultsMap.has(n10) ? this._resultsMap.get(n10) : this.getDefault();
  }
  _getValueFromFields(e11) {
    const t10 = [];
    for (const s9 of this._fields) {
      const r13 = e11.readAttribute(s9);
      null == r13 || "" === r13 ? t10.push("<Null>") : t10.push(r13);
    }
    return t10.join(this._seperator);
  }
};
async function d6(e11, t10) {
  const s9 = e11 || 1;
  if ("number" == typeof s9)
    return (e12, t11, r13) => s9;
  const a7 = await o5(s9, t10.spatialReference, t10.fields);
  return (e12, s10, r13) => i6(a7, e12, { $view: r13 }, t10.geometryType, s10) || 1;
}
var h4;
async function f13() {
  return h4 || (h4 = import("./createSymbolSchema-A3WMEA6H.js")), h4;
}
var p8 = class extends o10 {
  constructor(e11, t10, r13, i12, a7, n10) {
    super(), this.type = "dictionary", this._groupIdCache = new e2(100), this._loader = e11, this._fieldMap = e11.fieldMap, this._symbolFields = e11.getSymbolFields(), this._templates = t10, this._info = r13, this._scaleFn = i12, this._schemaUtilsModule = a7, this._symbolOptions = n10;
  }
  static async fromDictionaryRenderer(e11, t10, s9, r13) {
    const [{ DictionaryLoader: i12 }, a7] = await Promise.all([import("./DictionaryLoader-2CWRMXYN.js"), f13()]), n10 = new i12(e11.url, e11.config, e11.fieldMap);
    await n10.fetchResources({ spatialReference: s9.spatialReference, fields: s9.fields });
    const l7 = await d6(e11.scaleExpression, s9);
    return new p8(n10, t10, s9, l7, a7, e11.symbolOptions);
  }
  async _analyzeFeature(t10, s9, r13, i12, l7) {
    const o11 = t10.readLegacyFeature(), u12 = this._scaleFn(o11, r13, i12), c9 = this._attributeHash(o11) + "-" + u12, m5 = this._groupIdCache.get(c9);
    if (m5)
      return m5;
    const d7 = { ...i12, spatialReference: this._info.spatialReference, abortOptions: l7, fields: this._info.fields }, h5 = await this._loader.getSymbolAsync(o11, d7), f14 = this._schemaUtilsModule.createSymbolSchema(h5, this._symbolOptions), p9 = n6(f14, this._info, s9, l7).then((t11) => {
      if ("expanded-cim" !== t11.type)
        return n9.error(new s2("mapview-bad-type", `Found unexpected type ${t11.type} in dictionary response`)), null;
      t11.hash += "-" + u12;
      for (const e11 of t11.layers)
        e11.scaleFactor = u12, e11.templateHash += "-" + u12;
      return this._templates.createTemplateGroup(t11, null);
    });
    return this._groupIdCache.put(c9, p9, 1), p9;
  }
  async analyze(e11, t10, s9, r13, i12, a7) {
    const n10 = t10.getCursor(), l7 = [];
    for (; n10.next(); )
      l7.push(this._analyzeFeature(n10, s9, r13, i12, a7));
    return Promise.all(l7);
  }
  match(e11, t10, s9, r13, i12) {
    return null;
  }
  _attributeHash(e11) {
    let t10 = "";
    for (const s9 of this._symbolFields) {
      const r13 = this._fieldMap[s9];
      r13 && (t10 += e11.attributes[r13] + "-");
    }
    return t10;
  }
};

export {
  e6 as e,
  E2 as E,
  e9 as e2,
  t7 as t,
  x8 as x,
  l5 as l,
  l6 as l2
};
//# sourceMappingURL=chunk-MU26VSON.js.map
