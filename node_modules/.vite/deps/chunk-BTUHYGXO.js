import {
  s2 as s
} from "./chunk-UA3YPL2R.js";

// node_modules/@arcgis/core/core/MapUtils.js
function n(n2, t3) {
  for (const [r3, o2] of n2)
    if (t3(o2, r3))
      return true;
  return false;
}
function t(n2, t3) {
  for (const [r3, o2] of n2)
    if (t3(o2, r3))
      return o2;
  return null;
}
function r(n2, t3, r3) {
  const o2 = n2.get(t3);
  if (void 0 !== o2)
    return o2;
  const u2 = r3();
  return n2.set(t3, u2), u2;
}

// node_modules/@arcgis/core/core/accessorSupport/ensureType.js
var r2 = s.getLogger("esri.core.accessorSupport.ensureTypes");
function t2(e) {
  return null == e ? e : new Date(e);
}
function o(e) {
  return null == e ? e : !!e;
}
function u(e) {
  return null == e ? e : e.toString();
}
function a(e) {
  return null == e ? e : (e = parseFloat(e), isNaN(e) ? 0 : e);
}
function s2(e) {
  return null == e ? e : Math.round(parseFloat(e));
}
function i(e) {
  return e && e.constructor && void 0 !== e.constructor.__accessorMetadata__;
}
function l(e, n2) {
  return null != n2 && e && !(n2 instanceof e);
}
function c(e) {
  return e && "isCollection" in e;
}
function f(e) {
  return e && e.Type ? "function" == typeof e.Type ? e.Type : e.Type.base : null;
}
function p(e, n2) {
  if (!n2 || !n2.constructor || !c(n2.constructor))
    return y(e, n2) ? n2 : new e(n2);
  const r3 = f(e.prototype.itemType), t3 = f(n2.constructor.prototype.itemType);
  return r3 ? t3 ? r3 === t3 ? n2 : r3.prototype.isPrototypeOf(t3.prototype) ? new e(n2) : (y(e, n2), n2) : new e(n2) : n2;
}
function y(e, n2) {
  return !!i(n2) && (r2.error("Accessor#set", "Assigning an instance of '" + (n2.declaredClass || "unknown") + "' which is not a subclass of '" + g(e) + "'"), true);
}
function v(e, n2) {
  return null == n2 ? n2 : c(e) ? p(e, n2) : l(e, n2) ? y(e, n2) ? n2 : new e(n2) : n2;
}
function g(e) {
  return e && e.prototype && e.prototype.declaredClass || "unknown";
}
var d = /* @__PURE__ */ new WeakMap();
function h(e) {
  switch (e) {
    case Number:
      return a;
    case T:
      return s2;
    case Boolean:
      return o;
    case String:
      return u;
    case Date:
      return t2;
    default:
      return r(d, e, () => v.bind(null, e));
  }
}
function b(e, n2) {
  const r3 = h(e);
  return 1 === arguments.length ? r3 : r3(n2);
}
function m(e, n2, r3) {
  return 1 === arguments.length ? m.bind(null, e) : n2 ? Array.isArray(n2) ? n2.map((n3) => e(n3, r3)) : [e(n2, r3)] : n2;
}
function w(e, n2) {
  return 1 === arguments.length ? m(b.bind(null, e)) : m(b.bind(null, e), n2);
}
function A(e, n2, r3) {
  return 0 !== n2 && Array.isArray(r3) ? r3.map((r4) => A(e, n2 - 1, r4)) : e(r3);
}
function $(e, n2, r3) {
  if (2 === arguments.length)
    return $.bind(null, e, n2);
  if (!r3)
    return r3;
  let t3 = n2, o2 = r3 = A(e, n2, r3);
  for (; t3 > 0 && Array.isArray(o2); )
    t3--, o2 = o2[0];
  if (void 0 !== o2)
    for (let u2 = 0; u2 < t3; u2++)
      r3 = [r3];
  return r3;
}
function j(e, n2, r3) {
  return 2 === arguments.length ? $(b.bind(null, e), n2) : $(b.bind(null, e), n2, r3);
}
function k(e) {
  return !!Array.isArray(e) && !e.some((n2) => {
    const r3 = typeof n2;
    return !("string" === r3 || "number" === r3 || "function" === r3 && e.length > 1);
  });
}
function M(e, n2) {
  if (2 === arguments.length)
    return M(e).call(null, n2);
  const t3 = /* @__PURE__ */ new Set(), o2 = e.filter((e2) => "function" != typeof e2), u2 = e.filter((e2) => "function" == typeof e2);
  for (const r3 of e)
    "string" != typeof r3 && "number" != typeof r3 || t3.add(r3);
  let a2 = null, s3 = null;
  return (e2, n3) => {
    if (null == e2)
      return e2;
    const i2 = typeof e2, c2 = "string" === i2 || "number" === i2;
    return c2 && (t3.has(e2) || u2.some((e3) => "string" === i2 && e3 === String || "number" === i2 && e3 === Number)) || "object" === i2 && u2.some((n4) => !l(e2, n4)) ? e2 : (c2 && o2.length ? (a2 || (a2 = o2.map((e3) => "string" == typeof e3 ? `'${e3}'` : `${e3}`).join(", ")), r2.error("Accessor#set", `'${e2}' is not a valid value for this property, only the following values are valid: ${a2}`)) : "object" == typeof e2 && u2.length ? (s3 || (s3 = u2.map((e3) => g(e3)).join(", ")), r2.error("Accessor#set", `'${e2}' is not a valid value for this property, value must be one of ${s3}`)) : r2.error("Accessor#set", `'${e2}' is not a valid value for this property`), n3 && (n3.valid = false), null);
  };
}
function S(e, n2) {
  if (2 === arguments.length)
    return S(e).call(null, n2);
  const t3 = {}, o2 = [], u2 = [];
  for (const r3 in e.typeMap) {
    const n3 = e.typeMap[r3];
    t3[r3] = b(n3), o2.push(g(n3)), u2.push(r3);
  }
  const a2 = () => `'${o2.join("', '")}'`, s3 = () => `'${u2.join("', '")}'`, c2 = "string" == typeof e.key ? (n3) => n3[e.key] : e.key;
  return (n3) => {
    if (e.base && !l(e.base, n3))
      return n3;
    if (null == n3)
      return n3;
    const o3 = c2(n3) || e.defaultKeyValue, u3 = t3[o3];
    if (!u3)
      return r2.error("Accessor#set", `Invalid property value, value needs to be one of ${a2()}, or a plain object that can autocast (having .type = ${s3()})`), null;
    if (!l(e.typeMap[o3], n3))
      return n3;
    if ("string" == typeof e.key && !i(n3)) {
      const r3 = {};
      for (const t4 in n3)
        t4 !== e.key && (r3[t4] = n3[t4]);
      return u3(r3);
    }
    return u3(n3);
  };
}
var T = class {
};
var N = { native: (e) => ({ type: "native", value: e }), array: (e) => ({ type: "array", value: e }), oneOf: (e) => ({ type: "one-of", values: e }) };
function _(e) {
  if (!e || !("type" in e))
    return false;
  switch (e.type) {
    case "native":
    case "array":
    case "one-of":
      return true;
  }
  return false;
}
function B(e) {
  switch (e.type) {
    case "native":
      return b(e.value);
    case "array":
      return m(B(e.value));
    case "one-of":
      return C(e);
    default:
      return null;
  }
}
function C(e) {
  let n2 = null;
  return (t3, o2) => F(t3, e) ? t3 : (null == n2 && (n2 = D(e)), r2.error("Accessor#set", `Invalid property value, value needs to be of type ${n2}`), o2 && (o2.valid = false), null);
}
function D(e) {
  switch (e.type) {
    case "native":
      switch (e.value) {
        case Number:
          return "number";
        case String:
          return "string";
        case Boolean:
          return "boolean";
        case T:
          return "integer";
        case Date:
          return "date";
        default:
          return g(e.value);
      }
    case "array":
      return `array of ${D(e.value)}`;
    case "one-of": {
      const n2 = e.values.map((e2) => D(e2));
      return `one of ${n2.slice(0, n2.length - 1)} or ${n2[n2.length - 1]}`;
    }
  }
  return "unknown";
}
function F(e, n2) {
  if (null == e)
    return true;
  switch (n2.type) {
    case "native":
      switch (n2.value) {
        case Number:
        case T:
          return "number" == typeof e;
        case Boolean:
          return "boolean" == typeof e;
        case String:
          return "string" == typeof e;
      }
      return e instanceof n2.value;
    case "array":
      return !!Array.isArray(e) && !e.some((e2) => !F(e2, n2.value));
    case "one-of":
      return n2.values.some((n3) => F(e, n3));
  }
}

export {
  n,
  t,
  r,
  u,
  a,
  s2 as s,
  v,
  b,
  m,
  w,
  $,
  j,
  k,
  M,
  S,
  T,
  N,
  _,
  B
};
//# sourceMappingURL=chunk-BTUHYGXO.js.map
