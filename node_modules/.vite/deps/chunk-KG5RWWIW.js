import {
  i
} from "./chunk-27YO3FKC.js";
import {
  A,
  E,
  S,
  _
} from "./chunk-EQNT4A7P.js";
import {
  s
} from "./chunk-LIZHLHNA.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/materialKey/MaterialKey.js
function n(t, e, s2) {
  const n2 = A.SIZE_FIELD_STOPS | A.SIZE_MINMAX_VALUE | A.SIZE_SCALE_STOPS | A.SIZE_UNIT_VALUE, o2 = (e & (_.FIELD_TARGETS_OUTLINE | _.MINMAX_TARGETS_OUTLINE | _.SCALE_TARGETS_OUTLINE | _.UNIT_TARGETS_OUTLINE)) >>> 4;
  return t === E.LINE && s2.isOutline || t === E.FILL && _2(s2.symbologyType) ? n2 & o2 : n2 & ~o2;
}
var o = 0;
var v = 8;
var l = 7;
var h = 8;
var S2 = 11;
var u = 11;
var p = 12;
var c = 13;
var y = 14;
var V = 15;
var d = 16;
var g = 17;
var T = 18;
var m = 19;
var z = 20;
var E2 = 21;
var L = 26;
var M = Object.keys(S).filter((t) => "number" == typeof S[t]).reduce((t, e) => ({ ...t, [e]: S[e] }), {});
function I(t) {
  return t === S.SIMPLE || t === S.OUTLINE_FILL_SIMPLE;
}
function _2(t) {
  return t === S.OUTLINE_FILL || t === S.OUTLINE_FILL_SIMPLE;
}
function b(t) {
  return I(t.symbologyType);
}
function O(t) {
  return _2(t.symbologyType);
}
function f(t, e) {
  switch (t) {
    case E.FILL:
      return w.from(e);
    case E.LINE:
      return C.from(e);
    case E.MARKER:
      return N.from(e);
    case E.TEXT:
      return P.from(e);
    case E.LABEL:
      return Z.from(e);
    default:
      throw new Error(`Unable to createMaterialKey for unknown geometryType ${t}`);
  }
}
function A2(t) {
  switch (U.load(t).geometryType) {
    case E.MARKER:
      return new N(t);
    case E.FILL:
      return new w(t);
    case E.LINE:
      return new C(t);
    case E.TEXT:
      return new P(t);
    case E.LABEL:
      return new Z(t);
  }
}
var U = class {
  constructor(t) {
    this._data = 0, this._data = t;
  }
  static load(t) {
    const e = this.shared;
    return e.data = t, e;
  }
  set data(t) {
    this._data = t;
  }
  get data() {
    return this._data;
  }
  get geometryType() {
    return this.bits(h, S2);
  }
  set geometryType(t) {
    this.setBits(t, h, S2);
  }
  get mapAligned() {
    return !!this.bit(z);
  }
  set mapAligned(t) {
    this.setBit(z, t);
  }
  get sdf() {
    return !!this.bit(u);
  }
  set sdf(t) {
    this.setBit(u, t);
  }
  get pattern() {
    return !!this.bit(p);
  }
  set pattern(t) {
    this.setBit(p, t);
  }
  get textureBinding() {
    return this.bits(o, v);
  }
  set textureBinding(t) {
    this.setBits(t, o, v);
  }
  get symbologyType() {
    return this.bits(E2, L);
  }
  set symbologyType(t) {
    this.setBits(t, E2, L);
  }
  get geometryTypeString() {
    switch (this.geometryType) {
      case E.FILL:
        return "fill";
      case E.MARKER:
        return "marker";
      case E.LINE:
        return "line";
      case E.TEXT:
        return "text";
      case E.LABEL:
        return "label";
      default:
        throw new s(`Unable to handle unknown geometryType: ${this.geometryType}`);
    }
  }
  setBit(t, e) {
    const s2 = 1 << t;
    e ? this._data |= s2 : this._data &= ~s2;
  }
  bit(t) {
    return (this._data & 1 << t) >> t;
  }
  setBits(t, e, s2) {
    for (let i2 = e, a = 0; i2 < s2; i2++, a++)
      this.setBit(i2, 0 != (t & 1 << a));
  }
  bits(t, e) {
    let s2 = 0;
    for (let i2 = t, a = 0; i2 < e; i2++, a++)
      s2 |= this.bit(i2) << a;
    return s2;
  }
  hasVV() {
    return false;
  }
  setVV(t, e) {
  }
  getVariation() {
    return { mapAligned: this.mapAligned, pattern: this.pattern, sdf: this.sdf, symbologyType: { value: S[this.symbologyType], options: M, namespace: "SYMBOLOGY_TYPE" } };
  }
  getVariationHash() {
    return this._data & ~(l & this.textureBinding);
  }
};
U.shared = new U(0);
var F = (t) => class extends t {
  get vvSizeMinMaxValue() {
    return 0 !== this.bit(d);
  }
  set vvSizeMinMaxValue(t2) {
    this.setBit(d, t2);
  }
  get vvSizeScaleStops() {
    return 0 !== this.bit(g);
  }
  set vvSizeScaleStops(t2) {
    this.setBit(g, t2);
  }
  get vvSizeFieldStops() {
    return 0 !== this.bit(T);
  }
  set vvSizeFieldStops(t2) {
    this.setBit(T, t2);
  }
  get vvSizeUnitValue() {
    return 0 !== this.bit(m);
  }
  set vvSizeUnitValue(t2) {
    this.setBit(m, t2);
  }
  hasVV() {
    return super.hasVV() || this.vvSizeMinMaxValue || this.vvSizeScaleStops || this.vvSizeFieldStops || this.vvSizeUnitValue;
  }
  setVV(t2, e) {
    super.setVV(t2, e);
    const s2 = n(this.geometryType, t2, e) & t2;
    this.vvSizeMinMaxValue = !!(s2 & A.SIZE_MINMAX_VALUE), this.vvSizeFieldStops = !!(s2 & A.SIZE_FIELD_STOPS), this.vvSizeUnitValue = !!(s2 & A.SIZE_UNIT_VALUE), this.vvSizeScaleStops = !!(s2 & A.SIZE_SCALE_STOPS);
  }
};
var x = (t) => class extends t {
  get vvRotation() {
    return 0 !== this.bit(V);
  }
  set vvRotation(t2) {
    this.setBit(V, t2);
  }
  hasVV() {
    return super.hasVV() || this.vvRotation;
  }
  setVV(t2, e) {
    super.setVV(t2, e), this.vvRotation = !e.isOutline && !!(t2 & A.ROTATION);
  }
};
var B = (t) => class extends t {
  get vvColor() {
    return 0 !== this.bit(c);
  }
  set vvColor(t2) {
    this.setBit(c, t2);
  }
  hasVV() {
    return super.hasVV() || this.vvColor;
  }
  setVV(t2, e) {
    super.setVV(t2, e), this.vvColor = !e.isOutline && !!(t2 & A.COLOR);
  }
};
var R = (t) => class extends t {
  get vvOpacity() {
    return 0 !== this.bit(y);
  }
  set vvOpacity(t2) {
    this.setBit(y, t2);
  }
  hasVV() {
    return super.hasVV() || this.vvOpacity;
  }
  setVV(t2, e) {
    super.setVV(t2, e), this.vvOpacity = !e.isOutline && !!(t2 & A.OPACITY);
  }
};
var w = class extends B(R(F(U))) {
  static load(t) {
    const e = this.shared;
    return e.data = t, e;
  }
  static from(t) {
    const { symbologyType: e, vvFlags: a } = t, r = this.load(0);
    return r.geometryType = E.FILL, r.symbologyType = e, e !== S.DOT_DENSITY && r.setVV(a, t), r.data;
  }
  getVariation() {
    return { ...super.getVariation(), vvColor: this.vvColor, vvOpacity: this.vvOpacity, vvSizeFieldStops: this.vvSizeFieldStops, vvSizeMinMaxValue: this.vvSizeMinMaxValue, vvSizeScaleStops: this.vvSizeScaleStops, vvSizeUnitValue: this.vvSizeUnitValue };
  }
};
w.shared = new w(0);
var N = class extends B(R(x(F(U)))) {
  static load(t) {
    const e = this.shared;
    return e.data = t, e;
  }
  static from(t) {
    const { symbologyType: e, vvFlags: a } = t, r = this.load(0);
    return r.geometryType = E.MARKER, r.symbologyType = e, e !== S.HEATMAP && r.setVV(a, t), r.data;
  }
  getVariation() {
    return { ...super.getVariation(), vvColor: this.vvColor, vvRotation: this.vvRotation, vvOpacity: this.vvOpacity, vvSizeFieldStops: this.vvSizeFieldStops, vvSizeMinMaxValue: this.vvSizeMinMaxValue, vvSizeScaleStops: this.vvSizeScaleStops, vvSizeUnitValue: this.vvSizeUnitValue };
  }
};
N.shared = new N(0);
var C = class extends B(R(F(U))) {
  static load(t) {
    const e = this.shared;
    return e.data = t, e;
  }
  static from(t) {
    const e = this.load(0);
    return e.geometryType = E.LINE, e.symbologyType = t.symbologyType, e.setVV(t.vvFlags, t), e.data;
  }
  getVariation() {
    return { ...super.getVariation(), vvColor: this.vvColor, vvOpacity: this.vvOpacity, vvSizeFieldStops: this.vvSizeFieldStops, vvSizeMinMaxValue: this.vvSizeMinMaxValue, vvSizeScaleStops: this.vvSizeScaleStops, vvSizeUnitValue: this.vvSizeUnitValue };
  }
};
C.shared = new C(0);
var P = class extends B(R(x(F(U)))) {
  static load(t) {
    const e = this.shared;
    return e.data = t, e;
  }
  static from(t) {
    const e = this.load(0);
    return e.geometryType = E.TEXT, e.symbologyType = t.symbologyType, e.setVV(t.vvFlags, t), e.data;
  }
  getVariation() {
    return { ...super.getVariation(), vvColor: this.vvColor, vvOpacity: this.vvOpacity, vvRotation: this.vvRotation, vvSizeFieldStops: this.vvSizeFieldStops, vvSizeMinMaxValue: this.vvSizeMinMaxValue, vvSizeScaleStops: this.vvSizeScaleStops, vvSizeUnitValue: this.vvSizeUnitValue };
  }
};
P.shared = new P(0);
var Z = class extends F(U) {
  static load(t) {
    const e = this.shared;
    return e.data = t, e;
  }
  static from(t) {
    const s2 = this.load(0);
    return s2.geometryType = E.LABEL, s2.symbologyType = t.symbologyType, s2.setVV(t.vvFlags, t), s2.mapAligned = i(t.placement), s2.data;
  }
  getVariation() {
    return { ...super.getVariation(), vvSizeFieldStops: this.vvSizeFieldStops, vvSizeMinMaxValue: this.vvSizeMinMaxValue, vvSizeScaleStops: this.vvSizeScaleStops, vvSizeUnitValue: this.vvSizeUnitValue };
  }
};
Z.shared = new Z(0);

export {
  _2 as _,
  b,
  O,
  f,
  A2 as A,
  U,
  w,
  N,
  C,
  P,
  Z
};
//# sourceMappingURL=chunk-KG5RWWIW.js.map
