import {
  E,
  G,
  R,
  k,
  k2
} from "./chunk-LNZAOBFW.js";
import {
  s as s3
} from "./chunk-PF5I4XZQ.js";
import {
  r as r2
} from "./chunk-HLM6QCL2.js";
import {
  o
} from "./chunk-RXYULINL.js";
import {
  s as s2
} from "./chunk-VWYWOOPX.js";
import {
  l
} from "./chunk-7QMMKGW4.js";
import {
  e,
  n2,
  y as y2
} from "./chunk-OOLCFNXJ.js";
import {
  a
} from "./chunk-BTUHYGXO.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";
import {
  n2 as n,
  y
} from "./chunk-HVKDYDPP.js";
import {
  r,
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/geometry/Geometry.js
var c = class extends l {
  constructor(...e3) {
    super(...e3), this.type = null, this.hasM = false, this.hasZ = false, this.spatialReference = k2.WGS84;
  }
  get cache() {
    return this.commitProperty("spatialReference"), {};
  }
  get extent() {
    return null;
  }
  readSpatialReference(e3, r4) {
    if (e3 instanceof k2)
      return e3;
    if (null != e3) {
      const t4 = new k2();
      return t4.read(e3, r4), t4;
    }
    return e3;
  }
  clone() {
    return console.warn(".clone() is not implemented for " + this.declaredClass), null;
  }
  clearCache() {
    this.notifyChange("cache");
  }
  getCacheValue(e3) {
    return this.cache[e3];
  }
  setCacheValue(e3, r4) {
    this.cache[e3] = r4;
  }
};
e([y2()], c.prototype, "type", void 0), e([y2({ readOnly: true })], c.prototype, "cache", null), e([y2({ readOnly: true })], c.prototype, "extent", null), e([y2({ type: Boolean, json: { write: { overridePolicy: (e3) => ({ enabled: e3 }) } } })], c.prototype, "hasM", void 0), e([y2({ type: Boolean, json: { write: { overridePolicy: (e3) => ({ enabled: e3 }) } } })], c.prototype, "hasZ", void 0), e([y2({ type: k2, json: { write: true } })], c.prototype, "spatialReference", void 0), e([o("spatialReference")], c.prototype, "readSpatialReference", null), c = e([n2("esri.geometry.Geometry")], c);
var p = c;

// node_modules/@arcgis/core/geometry/support/webMercatorUtils.js
var o2 = 57.29577951308232;
var u = 0.017453292519943;
function l2(n3) {
  return n3 * o2;
}
function p2(n3) {
  return n3 * u;
}
function f(n3) {
  return n3 / s3.radius;
}
function c2(n3) {
  return Math.PI / 2 - 2 * Math.atan(Math.exp(-n3 / s3.radius));
}
function h(n3) {
  return null != n3.wkid || null != n3.wkt;
}
var m = [0, 0];
function x(n3, t4, e3, i3, r4) {
  const s6 = n3, a4 = r4;
  if (a4.spatialReference = e3, "x" in s6 && "x" in a4)
    [a4.x, a4.y] = t4(s6.x, s6.y, m, i3);
  else if ("xmin" in s6 && "xmin" in a4)
    [a4.xmin, a4.ymin] = t4(s6.xmin, s6.ymin, m, i3), [a4.xmax, a4.ymax] = t4(s6.xmax, s6.ymax, m, i3);
  else if ("paths" in s6 && "paths" in a4 || "rings" in s6 && "rings" in a4) {
    const n4 = "paths" in s6 ? s6.paths : s6.rings, e4 = [];
    let r5;
    for (let s7 = 0; s7 < n4.length; s7++) {
      const a5 = n4[s7];
      r5 = [], e4.push(r5);
      for (let n5 = 0; n5 < a5.length; n5++)
        r5.push(t4(a5[n5][0], a5[n5][1], [0, 0], i3)), a5[n5].length > 2 && r5[n5].push(a5[n5][2]), a5[n5].length > 3 && r5[n5].push(a5[n5][3]);
    }
    "paths" in a4 ? a4.paths = e4 : a4.rings = e4;
  } else if ("points" in s6 && "points" in a4) {
    const n4 = s6.points, e4 = [];
    for (let r5 = 0; r5 < n4.length; r5++)
      e4[r5] = t4(n4[r5][0], n4[r5][1], [0, 0], i3), n4[r5].length > 2 && e4[r5].push(n4[r5][2]), n4[r5].length > 3 && e4[r5].push(n4[r5][3]);
    a4.points = e4;
  }
  return r4;
}
function g(n3, t4) {
  const e3 = n3 && (h(n3) ? n3 : n3.spatialReference), i3 = t4 && (h(t4) ? t4 : t4.spatialReference);
  return !(n3 && "type" in n3 && "mesh" === n3.type || t4 && "type" in t4 && "mesh" === t4.type || !e3 || !i3) && (!!E(i3, e3) || (k(i3) && G(e3) || k(e3) && G(i3)));
}
function M(i3, o5) {
  if (t(i3))
    return null;
  const u4 = i3.spatialReference, l4 = o5 && (h(o5) ? o5 : o5.spatialReference);
  return g(u4, l4) ? E(u4, l4) ? y(i3) : k(l4) ? x(i3, y3, k2.WebMercator, false, y(i3)) : G(l4) ? x(i3, d, k2.WGS84, false, y(i3)) : null : null;
}
function y3(n3, t4, e3 = [0, 0]) {
  t4 > 89.99999 ? t4 = 89.99999 : t4 < -89.99999 && (t4 = -89.99999);
  const r4 = p2(t4);
  return e3[0] = p2(n3) * s3.radius, e3[1] = s3.halfSemiMajorAxis * Math.log((1 + Math.sin(r4)) / (1 - Math.sin(r4))), e3;
}
function d(n3, t4, e3 = [0, 0], r4 = false) {
  const s6 = l2(n3 / s3.radius);
  return e3[0] = r4 ? s6 : s6 - 360 * Math.floor((s6 + 180) / 360), e3[1] = l2(Math.PI / 2 - 2 * Math.atan(Math.exp(-t4 / s3.radius))), e3;
}
function R2(t4, i3 = false, r4 = y(t4)) {
  return x(t4, y3, k2.WebMercator, i3, r4);
}
function j(t4, i3 = false, r4 = y(t4)) {
  return x(t4, d, k2.WGS84, i3, r4);
}

// node_modules/@arcgis/core/geometry/support/pointUtils.js
function t2(t4, n3) {
  const s6 = t4.x - n3.x, r4 = t4.y - n3.y, a4 = t4.hasZ && n3.hasZ ? t4.z - n3.z : 0;
  return Math.sqrt(s6 * s6 + r4 * r4 + a4 * a4);
}

// node_modules/@arcgis/core/geometry/Point.js
var m2;
var f2 = [0, 0];
function g2(e3) {
  return e3 && ("esri.geometry.SpatialReference" === e3.declaredClass || null != e3.wkid);
}
var x2 = m2 = class extends p {
  constructor(...e3) {
    super(...e3), this.x = 0, this.y = 0, this.z = void 0, this.m = void 0, this.type = "point";
  }
  static copy(e3, t4) {
    t4._set("x", e3._get("x")), t4._set("y", e3._get("y")), t4._set("z", e3._get("z")), t4._set("m", e3._get("m"));
    const r4 = e3._get("spatialReference");
    t4._set("spatialReference", Object.isFrozen(r4) ? r4 : r4.clone());
  }
  normalizeCtorArgs(e3, r4, s6, i3, o5) {
    let a4;
    if (Array.isArray(e3))
      a4 = e3, o5 = r4, e3 = a4[0], r4 = a4[1], s6 = a4[2], i3 = a4[3];
    else if (e3 && "object" == typeof e3) {
      if (a4 = e3, e3 = null != a4.x ? a4.x : a4.longitude, r4 = null != a4.y ? a4.y : a4.latitude, s6 = a4.z, i3 = a4.m, (o5 = a4.spatialReference) && "esri.geometry.SpatialReference" !== o5.declaredClass && (o5 = new k2(o5)), null != a4.longitude || null != a4.latitude) {
        if (null == a4.longitude)
          s.getLogger(this.declaredClass).warn(".longitude=", "Latitude was defined without longitude");
        else if (null == a4.latitude)
          s.getLogger(this.declaredClass).warn(".latitude=", "Longitude was defined without latitude");
        else if (!a4.declaredClass && o5 && o5.isWebMercator) {
          const t4 = y3(a4.longitude, a4.latitude, f2);
          e3 = t4[0], r4 = t4[1];
        }
      }
    } else
      g2(s6) ? (o5 = s6, s6 = null) : g2(i3) && (o5 = i3, i3 = null);
    const l4 = { x: e3, y: r4 };
    return null == l4.x && null != l4.y ? s.getLogger(this.declaredClass).warn(".y=", "Y coordinate was defined without an X coordinate") : null == l4.y && null != l4.x && s.getLogger(this.declaredClass).warn(".x=", "X coordinate was defined without a Y coordinate"), null != o5 && (l4.spatialReference = o5), null != s6 && (l4.z = s6), null != i3 && (l4.m = i3), l4;
  }
  get cache() {
    return this.commitProperty("x"), this.commitProperty("y"), this.commitProperty("z"), this.commitProperty("m"), this.commitProperty("spatialReference"), {};
  }
  get hasM() {
    return void 0 !== this.m;
  }
  set hasM(e3) {
    e3 !== (void 0 !== this._get("m")) && (this._set("m", e3 ? 0 : void 0), this._set("hasM", e3));
  }
  get hasZ() {
    return void 0 !== this.z;
  }
  set hasZ(e3) {
    e3 !== (void 0 !== this._get("z")) && (this._set("z", e3 ? 0 : void 0), this._set("hasZ", e3));
  }
  get latitude() {
    const { spatialReference: e3, x: t4, y: r4 } = this;
    if (e3) {
      if (e3.isWebMercator)
        return d(t4, r4, f2)[1];
      if (e3.isGeographic)
        return r4;
    }
    return null;
  }
  set latitude(e3) {
    const { spatialReference: t4, x: r4 } = this;
    null != e3 && t4 && (t4.isWebMercator ? this._set("y", y3(r4, e3, f2)[1]) : t4.isGeographic && this._set("y", e3), this._set("latitude", e3));
  }
  get longitude() {
    const { x: e3, y: t4, spatialReference: r4 } = this;
    if (r4) {
      if (r4.isWebMercator)
        return d(e3, t4, f2)[0];
      if (r4.isGeographic)
        return e3;
    }
    return null;
  }
  set longitude(e3) {
    const { y: t4, spatialReference: r4 } = this;
    null != e3 && r4 && (r4.isWebMercator ? this._set("x", y3(e3, t4, f2)[0]) : r4.isGeographic && this._set("x", e3), this._set("longitude", e3));
  }
  writeX(e3, t4, r4) {
    t4[r4] = isNaN(e3) ? "NaN" : e3;
  }
  readX(e3) {
    return "string" == typeof e3 ? NaN : e3;
  }
  clone() {
    const e3 = new m2();
    return e3.x = this.x, e3.y = this.y, e3.z = this.z, e3.m = this.m, e3.spatialReference = this.spatialReference, e3;
  }
  copy(e3) {
    return m2.copy(e3, this), this;
  }
  equals(e3) {
    if (t(e3))
      return false;
    const { x: t4, y: s6, z: i3, m: o5, spatialReference: a4 } = this, { z: l4, m: n3 } = e3;
    let { x: c5, y: u4, spatialReference: p4 } = e3;
    if (!a4.equals(p4))
      if (a4.isWebMercator && p4.isWGS84)
        [c5, u4] = y3(c5, u4), p4 = a4;
      else {
        if (!a4.isWGS84 || !p4.isWebMercator)
          return false;
        [c5, u4] = d(c5, u4), p4 = a4;
      }
    return t4 === c5 && s6 === u4 && i3 === l4 && o5 === n3 && a4.wkid === p4.wkid;
  }
  offset(e3, t4, r4) {
    var _a;
    return this.x += e3, this.y += t4, null != r4 && (this.z = ((_a = this.z) != null ? _a : 0) + r4), this;
  }
  normalize() {
    if (!this.spatialReference)
      return this;
    const e3 = R(this.spatialReference);
    if (!e3)
      return this;
    let t4 = this.x;
    const [r4, s6] = e3.valid, i3 = 2 * s6;
    let o5;
    return t4 > s6 ? (o5 = Math.ceil(Math.abs(t4 - s6) / i3), t4 -= o5 * i3) : t4 < r4 && (o5 = Math.ceil(Math.abs(t4 - r4) / i3), t4 += o5 * i3), this._set("x", t4), this;
  }
  distance(e3) {
    return t2(this, e3);
  }
  toArray() {
    const e3 = this.hasZ, t4 = this.hasM;
    return e3 && t4 ? [this.x, this.y, this.z, this.m] : e3 ? [this.x, this.y, this.z] : t4 ? [this.x, this.y, this.m] : [this.x, this.y];
  }
  toJSON(e3) {
    return this.write({}, e3);
  }
};
e([y2({ readOnly: true })], x2.prototype, "cache", null), e([y2({ type: Boolean, json: { read: false, write: { enabled: false, overridePolicy: null } } })], x2.prototype, "hasM", null), e([y2({ type: Boolean, json: { read: false, write: { enabled: false, overridePolicy: null } } })], x2.prototype, "hasZ", null), e([y2({ type: Number })], x2.prototype, "latitude", null), e([y2({ type: Number })], x2.prototype, "longitude", null), e([y2({ type: Number, json: { type: [Number, String], write: { isRequired: true, allowNull: true } } }), s2((e3) => isNaN(e3) ? e3 : a(e3))], x2.prototype, "x", void 0), e([r2("x")], x2.prototype, "writeX", null), e([o("x")], x2.prototype, "readX", null), e([y2({ type: Number, json: { write: true } })], x2.prototype, "y", void 0), e([y2({ type: Number, json: { write: { overridePolicy() {
  return { enabled: this.hasZ };
} } } })], x2.prototype, "z", void 0), e([y2({ type: Number, json: { write: { overridePolicy() {
  return { enabled: this.hasM };
} } } })], x2.prototype, "m", void 0), x2 = m2 = e([n2("esri.geometry.Point")], x2), x2.prototype.toJSON.isDefaultToJSON = true;
var w = x2;

// node_modules/@arcgis/core/geometry/support/contains.js
var t3 = [0, 0];
function r3(t4, r4) {
  return !!r(r4) && f3(t4, r4.x, r4.y, r4.z);
}
function i(n3, t4) {
  if (!t4.points || t4.points.length)
    return false;
  for (const r4 of t4.points)
    if (!u2(n3, r4))
      return false;
  return true;
}
function o3(n3, t4) {
  const { xmin: r4, ymin: i3, zmin: o5, xmax: u4, ymax: e3, zmax: c5 } = t4;
  return n3.hasZ && t4.hasZ ? f3(n3, r4, i3, o5) && f3(n3, r4, e3, o5) && f3(n3, u4, e3, o5) && f3(n3, u4, i3, o5) && f3(n3, r4, i3, c5) && f3(n3, r4, e3, c5) && f3(n3, u4, e3, c5) && f3(n3, u4, i3, c5) : f3(n3, r4, i3) && f3(n3, r4, e3) && f3(n3, u4, e3) && f3(n3, u4, i3);
}
function u2(n3, t4) {
  return f3(n3, t4[0], t4[1]);
}
function e2(n3, t4) {
  return f3(n3, t4[0], t4[1], t4[2]);
}
function f3(n3, t4, r4, i3) {
  return t4 >= n3.xmin && t4 <= n3.xmax && r4 >= n3.ymin && r4 <= n3.ymax && (null == i3 || !n3.hasZ || i3 >= n3.zmin && i3 <= n3.zmax);
}
function c3(n3, r4) {
  return t3[1] = r4.y, t3[0] = r4.x, m3(n3, t3);
}
function m3(n3, t4) {
  return s4(n3.rings, t4);
}
function s4(n3, t4) {
  if (!n3)
    return false;
  if (x3(n3))
    return a2(false, n3, t4);
  let r4 = false;
  for (let i3 = 0, o5 = n3.length; i3 < o5; i3++)
    r4 = a2(r4, n3[i3], t4);
  return r4;
}
function x3(n3) {
  return !Array.isArray(n3[0][0]);
}
function a2(n3, t4, r4) {
  const [i3, o5] = r4;
  let u4 = n3, e3 = 0;
  for (let f6 = 0, c5 = t4.length; f6 < c5; f6++) {
    e3++, e3 === c5 && (e3 = 0);
    const [n4, r5] = t4[f6], [m5, s6] = t4[e3];
    (r5 < o5 && s6 >= o5 || s6 < o5 && r5 >= o5) && n4 + (o5 - r5) / (s6 - r5) * (m5 - n4) < i3 && (u4 = !u4);
  }
  return u4;
}

// node_modules/@arcgis/core/geometry/support/intersectsBase.js
function i2(t4, e3) {
  return r3(t4, e3);
}
function o4(n3, t4) {
  const e3 = n3.hasZ && t4.hasZ;
  let r4, i3, o5;
  if (n3.xmin <= t4.xmin) {
    if (r4 = t4.xmin, n3.xmax < r4)
      return false;
  } else if (r4 = n3.xmin, t4.xmax < r4)
    return false;
  if (n3.ymin <= t4.ymin) {
    if (i3 = t4.ymin, n3.ymax < i3)
      return false;
  } else if (i3 = n3.ymin, t4.ymax < i3)
    return false;
  if (e3 && t4.hasZ) {
    if (n3.zmin <= t4.zmin) {
      if (o5 = t4.zmin, n3.zmax < o5)
        return false;
    } else if (o5 = n3.zmin, t4.zmax < o5)
      return false;
  }
  return true;
}
function f4(n3, t4) {
  const { points: i3, hasZ: o5 } = t4, f6 = o5 ? e2 : u2;
  for (const e3 of i3)
    if (f6(n3, e3))
      return true;
  return false;
}
var s5 = [0, 0];
var u3 = [0, 0];
var c4 = [0, 0];
var m4 = [0, 0];
var l3 = [s5, u3, c4, m4];
var a3 = [[c4, s5], [s5, u3], [u3, m4], [m4, c4]];
function x4(n3, t4) {
  return y4(n3, t4.rings);
}
function y4(n3, r4) {
  s5[0] = n3.xmin, s5[1] = n3.ymax, u3[0] = n3.xmax, u3[1] = n3.ymax, c4[0] = n3.xmin, c4[1] = n3.ymin, m4[0] = n3.xmax, m4[1] = n3.ymin;
  for (const e3 of l3)
    if (s4(r4, e3))
      return true;
  for (const t4 of r4) {
    if (!t4.length)
      continue;
    let r5 = t4[0];
    if (u2(n3, r5))
      return true;
    for (let i3 = 1; i3 < t4.length; i3++) {
      const o5 = t4[i3];
      if (u2(n3, o5) || z(r5, o5, a3))
        return true;
      r5 = o5;
    }
  }
  return false;
}
function h2(n3, t4) {
  s5[0] = n3.xmin, s5[1] = n3.ymax, u3[0] = n3.xmax, u3[1] = n3.ymax, c4[0] = n3.xmin, c4[1] = n3.ymin, m4[0] = n3.xmax, m4[1] = n3.ymin;
  const r4 = t4.paths;
  for (const i3 of r4) {
    if (!r4.length)
      continue;
    let t5 = i3[0];
    if (u2(n3, t5))
      return true;
    for (let r5 = 1; r5 < i3.length; r5++) {
      const o5 = i3[r5];
      if (u2(n3, o5) || z(t5, o5, a3))
        return true;
      t5 = o5;
    }
  }
  return false;
}
var g3 = [0, 0];
function p3(n3) {
  for (let t4 = 0; t4 < n3.length; t4++) {
    const e3 = n3[t4];
    for (let i3 = 0; i3 < e3.length - 1; i3++) {
      const r5 = e3[i3], o5 = e3[i3 + 1];
      for (let e4 = t4 + 1; e4 < n3.length; e4++)
        for (let t5 = 0; t5 < n3[e4].length - 1; t5++) {
          const i4 = n3[e4][t5], f6 = n3[e4][t5 + 1];
          if (G2(r5, o5, i4, f6, g3) && !(g3[0] === r5[0] && g3[1] === r5[1] || g3[0] === i4[0] && g3[1] === i4[1] || g3[0] === o5[0] && g3[1] === o5[1] || g3[0] === f6[0] && g3[1] === f6[1]))
            return true;
        }
    }
    const r4 = e3.length;
    if (!(r4 <= 4))
      for (let n4 = 0; n4 < r4 - 3; n4++) {
        let t5 = r4 - 1;
        0 === n4 && (t5 = r4 - 2);
        const i3 = e3[n4], o5 = e3[n4 + 1];
        for (let r5 = n4 + 2; r5 < t5; r5++) {
          const n5 = e3[r5], t6 = e3[r5 + 1];
          if (G2(i3, o5, n5, t6, g3) && !(g3[0] === i3[0] && g3[1] === i3[1] || g3[0] === n5[0] && g3[1] === n5[1] || g3[0] === o5[0] && g3[1] === o5[1] || g3[0] === t6[0] && g3[1] === t6[1]))
            return true;
        }
      }
  }
  return false;
}
function z(n3, t4, e3) {
  for (let r4 = 0; r4 < e3.length; r4++)
    if (G2(n3, t4, e3[r4][0], e3[r4][1]))
      return true;
  return false;
}
function G2(n3, t4, e3, r4, i3) {
  const [o5, f6] = n3, [s6, u4] = t4, [c5, m5] = e3, [l4, a4] = r4, x5 = l4 - c5, y5 = o5 - c5, h3 = s6 - o5, g4 = a4 - m5, p4 = f6 - m5, z3 = u4 - f6, G3 = g4 * h3 - x5 * z3;
  if (0 === G3)
    return false;
  const Z2 = (x5 * p4 - g4 * y5) / G3, P = (h3 * p4 - z3 * y5) / G3;
  return Z2 >= 0 && Z2 <= 1 && P >= 0 && P <= 1 && (i3 && (i3[0] = o5 + Z2 * (s6 - o5), i3[1] = f6 + Z2 * (u4 - f6)), true);
}
function Z(n3) {
  switch (n3) {
    case "esriGeometryEnvelope":
    case "extent":
      return o4;
    case "esriGeometryMultipoint":
    case "multipoint":
      return f4;
    case "esriGeometryPoint":
    case "point":
      return i2;
    case "esriGeometryPolygon":
    case "polygon":
      return x4;
    case "esriGeometryPolyline":
    case "polyline":
      return h2;
  }
}

// node_modules/@arcgis/core/geometry/Extent.js
var f5;
function d2(t4) {
  return t4 && ("esri.geometry.SpatialReference" === t4.declaredClass || null != t4.wkid);
}
function z2(t4, i3, e3) {
  return null == i3 ? e3 : null == e3 ? i3 : t4(i3, e3);
}
var M2 = f5 = class extends p {
  constructor(...t4) {
    super(...t4), this.type = "extent", this.xmin = 0, this.ymin = 0, this.mmin = void 0, this.zmin = void 0, this.xmax = 0, this.ymax = 0, this.mmax = void 0, this.zmax = void 0;
  }
  normalizeCtorArgs(t4, i3, e3, s6, n3) {
    return d2(t4) ? { spatialReference: t4, xmin: 0, ymin: 0, xmax: 0, ymax: 0 } : "object" == typeof t4 ? (t4.spatialReference = null == t4.spatialReference ? k2.WGS84 : t4.spatialReference, t4) : { xmin: t4, ymin: i3, xmax: e3, ymax: s6, spatialReference: n3 != null ? n3 : k2.WGS84 };
  }
  static fromBounds(t4, i3) {
    return new f5({ xmin: t4[0], ymin: t4[1], xmax: t4[2], ymax: t4[3], spatialReference: i3 });
  }
  static fromPoint(t4) {
    return new f5({ xmin: t4.x, ymin: t4.y, zmin: t4.z, xmax: t4.x, ymax: t4.y, zmax: t4.z, spatialReference: t4.spatialReference });
  }
  get cache() {
    return this.commitProperty("xmin"), this.commitProperty("ymin"), this.commitProperty("zmin"), this.commitProperty("mmin"), this.commitProperty("xmax"), this.commitProperty("ymax"), this.commitProperty("zmax"), this.commitProperty("mmax"), this.commitProperty("spatialReference"), {};
  }
  get center() {
    const t4 = new w({ x: 0.5 * (this.xmin + this.xmax), y: 0.5 * (this.ymin + this.ymax), spatialReference: this.spatialReference });
    return this.hasZ && (t4.z = 0.5 * (this.zmin + this.zmax)), this.hasM && (t4.m = 0.5 * (this.mmin + this.mmax)), t4;
  }
  get extent() {
    return this.clone();
  }
  get hasM() {
    return null != this.mmin && null != this.mmax;
  }
  get hasZ() {
    return null != this.zmin && null != this.zmax;
  }
  get height() {
    return Math.abs(this.ymax - this.ymin);
  }
  get width() {
    return Math.abs(this.xmax - this.xmin);
  }
  centerAt(t4) {
    const i3 = this.center;
    return null != t4.z && this.hasZ ? this.offset(t4.x - i3.x, t4.y - i3.y, t4.z - i3.z) : this.offset(t4.x - i3.x, t4.y - i3.y);
  }
  clone() {
    const t4 = new f5();
    return t4.xmin = this.xmin, t4.ymin = this.ymin, t4.xmax = this.xmax, t4.ymax = this.ymax, t4.spatialReference = this.spatialReference, null != this.zmin && (t4.zmin = this.zmin, t4.zmax = this.zmax), null != this.mmin && (t4.mmin = this.mmin, t4.mmax = this.mmax), t4;
  }
  contains(t4) {
    if (!t4)
      return false;
    const i3 = this.spatialReference, e3 = t4.spatialReference;
    return i3 && e3 && !i3.equals(e3) && g(i3, e3) && (t4 = i3.isWebMercator ? R2(t4) : j(t4, true)), "point" === t4.type ? r3(this, t4) : "extent" === t4.type && o3(this, t4);
  }
  equals(t4) {
    if (this === t4)
      return true;
    if (t(t4))
      return false;
    const e3 = this.spatialReference, s6 = t4.spatialReference;
    return e3 && s6 && !e3.equals(s6) && g(e3, s6) && (t4 = e3.isWebMercator ? R2(t4) : j(t4, true)), this.xmin === t4.xmin && this.ymin === t4.ymin && this.zmin === t4.zmin && this.mmin === t4.mmin && this.xmax === t4.xmax && this.ymax === t4.ymax && this.zmax === t4.zmax && this.mmax === t4.mmax;
  }
  expand(t4) {
    const i3 = 0.5 * (1 - t4), e3 = this.width * i3, s6 = this.height * i3;
    if (this.xmin += e3, this.ymin += s6, this.xmax -= e3, this.ymax -= s6, this.hasZ) {
      const t5 = (this.zmax - this.zmin) * i3;
      this.zmin += t5, this.zmax -= t5;
    }
    if (this.hasM) {
      const t5 = (this.mmax - this.mmin) * i3;
      this.mmin += t5, this.mmax -= t5;
    }
    return this;
  }
  intersects(t4) {
    if (t(t4))
      return false;
    "mesh" === t4.type && (t4 = t4.extent);
    const e3 = this.spatialReference, s6 = t4.spatialReference;
    e3 && s6 && !E(e3, s6) && g(e3, s6) && (t4 = e3.isWebMercator ? R2(t4) : j(t4, true));
    return Z(t4.type)(this, t4);
  }
  normalize() {
    const t4 = this._normalize(false, true);
    return Array.isArray(t4) ? t4 : [t4];
  }
  offset(t4, i3, e3) {
    return this.xmin += t4, this.ymin += i3, this.xmax += t4, this.ymax += i3, null != e3 && (this.zmin += e3, this.zmax += e3), this;
  }
  shiftCentralMeridian() {
    return this._normalize(true);
  }
  union(t4) {
    return this === t4 || (this.xmin = Math.min(this.xmin, t4.xmin), this.ymin = Math.min(this.ymin, t4.ymin), this.xmax = Math.max(this.xmax, t4.xmax), this.ymax = Math.max(this.ymax, t4.ymax), (this.hasZ || t4.hasZ) && (this.zmin = z2(Math.min, this.zmin, t4.zmin), this.zmax = z2(Math.max, this.zmax, t4.zmax)), (this.hasM || t4.hasM) && (this.mmin = z2(Math.min, this.mmin, t4.mmin), this.mmax = z2(Math.max, this.mmax, t4.mmax))), this;
  }
  intersection(t4) {
    return this === t4 ? this : t(t4) || !this.intersects(t4) ? null : (this.xmin = Math.max(this.xmin, t4.xmin), this.ymin = Math.max(this.ymin, t4.ymin), this.xmax = Math.min(this.xmax, t4.xmax), this.ymax = Math.min(this.ymax, t4.ymax), (this.hasZ || t4.hasZ) && (this.zmin = z2(Math.max, this.zmin, t4.zmin), this.zmax = z2(Math.min, this.zmax, t4.zmax)), (this.hasM || t4.hasM) && (this.mmin = z2(Math.max, this.mmin, t4.mmin), this.mmax = z2(Math.min, this.mmax, t4.mmax)), this);
  }
  toJSON(t4) {
    return this.write({}, t4);
  }
  _shiftCM(t4 = R(this.spatialReference)) {
    var _a;
    if (!t4 || !this.spatialReference)
      return this;
    const i3 = this.spatialReference, s6 = this._getCM(t4);
    if (s6) {
      const n3 = i3.isWebMercator ? j(s6) : s6;
      this.xmin -= s6.x, this.xmax -= s6.x, i3.isWebMercator || (n3.x = this._normalizeX(n3.x, t4).x), this.spatialReference = new k2(n((_a = i3.isWGS84 ? t4.altTemplate : null) != null ? _a : t4.wkTemplate, { Central_Meridian: n3.x }));
    }
    return this;
  }
  _getCM(t4) {
    let i3 = null;
    const [e3, s6] = t4.valid, n3 = this.xmin, m5 = this.xmax;
    return n3 >= e3 && n3 <= s6 && (m5 >= e3 && m5 <= s6) || (i3 = this.center), i3;
  }
  _normalize(t4, i3, e3) {
    const s6 = this.spatialReference;
    if (!s6)
      return this;
    const n3 = e3 != null ? e3 : R(s6);
    if (null == n3)
      return this;
    const m5 = this._getParts(n3).map((t5) => t5.extent);
    if (m5.length < 2)
      return m5[0] || this;
    if (m5.length > 2)
      return t4 ? this._shiftCM(n3) : this.set({ xmin: n3.valid[0], xmax: n3.valid[1] });
    if (t4)
      return this._shiftCM(n3);
    if (i3)
      return m5;
    let r4 = true, a4 = true;
    return m5.forEach((t5) => {
      t5.hasZ || (r4 = false), t5.hasM || (a4 = false);
    }), { rings: m5.map((t5) => {
      const i4 = [[t5.xmin, t5.ymin], [t5.xmin, t5.ymax], [t5.xmax, t5.ymax], [t5.xmax, t5.ymin], [t5.xmin, t5.ymin]];
      if (r4) {
        const e4 = (t5.zmax - t5.zmin) / 2;
        for (let t6 = 0; t6 < i4.length; t6++)
          i4[t6].push(e4);
      }
      if (a4) {
        const e4 = (t5.mmax - t5.mmin) / 2;
        for (let t6 = 0; t6 < i4.length; t6++)
          i4[t6].push(e4);
      }
      return i4;
    }), hasZ: r4, hasM: a4, spatialReference: s6 };
  }
  _getParts(t4) {
    let i3 = this.cache._parts;
    if (!i3) {
      i3 = [];
      const { ymin: e4, ymax: s7, spatialReference: n3 } = this, m5 = this.width, r4 = this.xmin, a4 = this.xmax;
      let h3;
      t4 = t4 || R(n3);
      const [o5, x5] = t4.valid;
      h3 = this._normalizeX(this.xmin, t4);
      const l4 = h3.x, c5 = h3.frameId;
      h3 = this._normalizeX(this.xmax, t4);
      const y5 = h3.x, u4 = h3.frameId, d3 = l4 === y5 && m5 > 0;
      if (m5 > 2 * x5) {
        const t5 = new f5(r4 < a4 ? l4 : y5, e4, x5, s7, n3), m6 = new f5(o5, e4, r4 < a4 ? y5 : l4, s7, n3), h4 = new f5(0, e4, x5, s7, n3), p4 = new f5(o5, e4, 0, s7, n3), d4 = [], z3 = [];
        t5.contains(h4) && d4.push(c5), t5.contains(p4) && z3.push(c5), m6.contains(h4) && d4.push(u4), m6.contains(p4) && z3.push(u4);
        for (let i4 = c5 + 1; i4 < u4; i4++)
          d4.push(i4), z3.push(i4);
        i3.push({ extent: t5, frameIds: [c5] }, { extent: m6, frameIds: [u4] }, { extent: h4, frameIds: d4 }, { extent: p4, frameIds: z3 });
      } else
        l4 > y5 || d3 ? i3.push({ extent: new f5(l4, e4, x5, s7, n3), frameIds: [c5] }, { extent: new f5(o5, e4, y5, s7, n3), frameIds: [u4] }) : i3.push({ extent: new f5(l4, e4, y5, s7, n3), frameIds: [c5] });
      this.cache._parts = i3;
    }
    const e3 = this.hasZ, s6 = this.hasM;
    if (e3 || s6) {
      const t5 = {};
      e3 && (t5.zmin = this.zmin, t5.zmax = this.zmax), s6 && (t5.mmin = this.mmin, t5.mmax = this.mmax);
      for (let e4 = 0; e4 < i3.length; e4++)
        i3[e4].extent.set(t5);
    }
    return i3;
  }
  _normalizeX(t4, i3) {
    const [e3, s6] = i3.valid, n3 = 2 * s6;
    let m5, r4 = 0;
    return t4 > s6 ? (m5 = Math.ceil(Math.abs(t4 - s6) / n3), t4 -= m5 * n3, r4 = m5) : t4 < e3 && (m5 = Math.ceil(Math.abs(t4 - e3) / n3), t4 += m5 * n3, r4 = -m5), { x: t4, frameId: r4 };
  }
};
e([y2({ readOnly: true })], M2.prototype, "cache", null), e([y2({ readOnly: true })], M2.prototype, "center", null), e([y2({ readOnly: true })], M2.prototype, "extent", null), e([y2({ readOnly: true, json: { write: { enabled: false, overridePolicy: null } } })], M2.prototype, "hasM", null), e([y2({ readOnly: true, json: { write: { enabled: false, overridePolicy: null } } })], M2.prototype, "hasZ", null), e([y2({ readOnly: true })], M2.prototype, "height", null), e([y2({ readOnly: true })], M2.prototype, "width", null), e([y2({ type: Number, json: { type: [Number, String], write: { enabled: true, allowNull: true } } })], M2.prototype, "xmin", void 0), e([y2({ type: Number, json: { write: true } })], M2.prototype, "ymin", void 0), e([y2({ type: Number, json: { origins: { "web-scene": { write: false } }, write: { overridePolicy() {
  return { enabled: this.hasM };
} } } })], M2.prototype, "mmin", void 0), e([y2({ type: Number, json: { origins: { "web-scene": { write: false } }, write: { overridePolicy() {
  return { enabled: this.hasZ };
} } } })], M2.prototype, "zmin", void 0), e([y2({ type: Number, json: { write: true } })], M2.prototype, "xmax", void 0), e([y2({ type: Number, json: { write: true } })], M2.prototype, "ymax", void 0), e([y2({ type: Number, json: { origins: { "web-scene": { write: false } }, write: { overridePolicy() {
  return { enabled: this.hasM };
} } } })], M2.prototype, "mmax", void 0), e([y2({ type: Number, json: { origins: { "web-scene": { write: false } }, write: { overridePolicy() {
  return { enabled: this.hasZ };
} } } })], M2.prototype, "zmax", void 0), M2 = f5 = e([n2("esri.geometry.Extent")], M2), M2.prototype.toJSON.isDefaultToJSON = true;
var w2 = M2;

export {
  p,
  f,
  c2 as c,
  g,
  M,
  y3 as y,
  d,
  R2 as R,
  j,
  w,
  r3 as r,
  i,
  c3 as c2,
  s4 as s,
  o4 as o,
  p3 as p2,
  G2 as G,
  Z,
  w2
};
//# sourceMappingURL=chunk-UWG37XSU.js.map
