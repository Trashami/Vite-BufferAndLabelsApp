import {
  E,
  l,
  l2,
  t as t2,
  x
} from "./chunk-MU26VSON.js";
import "./chunk-5HIF32ZE.js";
import {
  n as n2
} from "./chunk-57QYUXCA.js";
import "./chunk-J42Y5N2P.js";
import "./chunk-DWAZ7HI7.js";
import "./chunk-POI555WS.js";
import "./chunk-JHLU6RPN.js";
import "./chunk-EPMXCACW.js";
import "./chunk-UCPKJYXN.js";
import "./chunk-KFLNKWNF.js";
import {
  p
} from "./chunk-JI7GUM5H.js";
import "./chunk-KUO7OCMN.js";
import "./chunk-KG5RWWIW.js";
import "./chunk-27YO3FKC.js";
import {
  p as p2
} from "./chunk-XBFCIW4K.js";
import "./chunk-6TBB7UXB.js";
import "./chunk-UO3LS2M5.js";
import {
  S
} from "./chunk-EQNT4A7P.js";
import "./chunk-R24MO4IV.js";
import "./chunk-YQBYWPBD.js";
import "./chunk-QISOH77W.js";
import "./chunk-XO5VJRK4.js";
import "./chunk-MATM5L52.js";
import "./chunk-4OM3EX6P.js";
import "./chunk-3OFVLRSL.js";
import "./chunk-UWKVAZQ6.js";
import "./chunk-4HL6BBWO.js";
import "./chunk-I4YZGF7W.js";
import "./chunk-7DLBSBVE.js";
import "./chunk-4XFEPZ26.js";
import "./chunk-FERTI5PU.js";
import "./chunk-VWCRJ6R6.js";
import "./chunk-MKNNZ33G.js";
import "./chunk-JQUWFKNU.js";
import "./chunk-UVQQJ3R6.js";
import "./chunk-TFHLTN6F.js";
import "./chunk-UDYHZLTE.js";
import "./chunk-4JNOVZUK.js";
import "./chunk-JEA4MMTV.js";
import "./chunk-RG3AHHRL.js";
import "./chunk-SQSR6K2M.js";
import "./chunk-75RMBUYZ.js";
import "./chunk-TJ2I6XQT.js";
import "./chunk-EDHROVWI.js";
import "./chunk-34YPGGJT.js";
import "./chunk-A4HIS5ZJ.js";
import "./chunk-OFQYIOO7.js";
import {
  a,
  m
} from "./chunk-DVGM5RQS.js";
import "./chunk-FWRLW4G5.js";
import "./chunk-E52E6T7N.js";
import "./chunk-N43PI2UO.js";
import "./chunk-QWNKYSI4.js";
import "./chunk-ZPYDYUP5.js";
import "./chunk-REIQNAQW.js";
import "./chunk-X2S4RQJ4.js";
import "./chunk-DER356EU.js";
import "./chunk-NRP45AHD.js";
import "./chunk-6M2AHKYV.js";
import "./chunk-SZIJNKCV.js";
import "./chunk-6O43OEU5.js";
import "./chunk-J2K7ZDSV.js";
import "./chunk-2UML3WQZ.js";
import "./chunk-UDND2Z3V.js";
import "./chunk-JUVQV3R3.js";
import "./chunk-RAX2HD42.js";
import "./chunk-ZYRIJWLX.js";
import "./chunk-C5H57NTD.js";
import "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import "./chunk-YWAQYJRC.js";
import "./chunk-B356PXLT.js";
import "./chunk-EHPBHJYZ.js";
import "./chunk-3MNMDUQZ.js";
import "./chunk-UWG37XSU.js";
import {
  k2 as k
} from "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import "./chunk-HLM6QCL2.js";
import "./chunk-RXYULINL.js";
import "./chunk-5NXILPDI.js";
import "./chunk-THVR7IAM.js";
import "./chunk-ZWJJTUFL.js";
import "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import "./chunk-KAN4HXCG.js";
import "./chunk-4FEGON7M.js";
import "./chunk-VWYWOOPX.js";
import "./chunk-M5VHU5LK.js";
import "./chunk-7QMMKGW4.js";
import {
  e as e2,
  n2 as n
} from "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import {
  f as f2,
  j
} from "./chunk-MJXQTGI2.js";
import "./chunk-LIZHLHNA.js";
import "./chunk-BTUHYGXO.js";
import "./chunk-UA3YPL2R.js";
import "./chunk-HVKDYDPP.js";
import "./chunk-6QC7MLLS.js";
import {
  e,
  f,
  o,
  r,
  t
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/views/2d/layers/features/support/ResourceManagerProxy.js
var t3 = class {
  constructor(e3) {
    this._remoteClient = e3, this._resourceMap = /* @__PURE__ */ new Map(), this._inFlightResourceMap = /* @__PURE__ */ new Map(), this.geometryEngine = null;
  }
  destroy() {
  }
  async fetchResource(t4, r2) {
    const s = this._resourceMap, i = s.get(t4);
    if (i)
      return i;
    let n3 = this._inFlightResourceMap.get(t4);
    if (n3)
      return n3;
    try {
      n3 = this._remoteClient.invoke("tileRenderer.fetchResource", { url: t4 }, { ...r2 }), this._inFlightResourceMap.set(t4, n3), n3.then((e3) => (this._inFlightResourceMap.delete(t4), s.set(t4, e3), e3));
    } catch (o2) {
      return j(o2) ? null : { width: 0, height: 0 };
    }
    return n3;
  }
  getResource(e3) {
    var _a;
    return (_a = this._resourceMap.get(e3)) != null ? _a : null;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processors/SymbolProcessor.js
function I(e3, t4) {
  return (!e3.minScale || e3.minScale >= t4) && (!e3.maxScale || e3.maxScale <= t4);
}
function M(e3) {
  const t4 = e3.message, r2 = { message: { data: {}, tileKey: t4.tileKey, tileKeyOrigin: t4.tileKeyOrigin, version: t4.version }, transferList: new Array() };
  for (const a2 in t4.data) {
    const e4 = t4.data[a2];
    if (r2.message.data[a2] = null, r(e4)) {
      const t5 = e4.stride, i = e4.indices.slice(0), o2 = e4.vertices.slice(0), n3 = e4.records.slice(0), l3 = { stride: t5, indices: i, vertices: o2, records: n3, metrics: o(e4.metrics, (e5) => e5.slice(0)) };
      r2.transferList.push(i, o2, n3), r2.message.data[a2] = l3;
    }
  }
  return r2;
}
var v = class extends p {
  constructor() {
    super(...arguments), this.type = "symbol", this._matchers = { feature: null, aggregate: null }, this._bufferData = /* @__PURE__ */ new Map(), this._bufferIds = /* @__PURE__ */ new Map();
  }
  initialize() {
    this.handles.add([this.tileStore.on("update", this.onTileUpdate.bind(this))]), this._resourceManagerProxy = new t3(this.remoteClient);
  }
  destroy() {
    this._resourceManagerProxy.destroy();
  }
  get supportsTileUpdates() {
    return true;
  }
  forEachBufferId(e3) {
    this._bufferIds.forEach((t4) => {
      t4.forEach(e3);
    });
  }
  async update(e3, t4) {
    const s = t4.schema.processors[0];
    if ("symbol" !== s.type)
      return;
    const r2 = m(this._schema, s);
    (a(r2, "mesh") || a(r2, "target")) && (e3.mesh = true, e3.why.mesh.push("Symbology changed"), this._schema = s, this._factory = this._createFactory(s), this._factory.update(s, this.tileStore.tileScheme.tileInfo));
  }
  onTileMessage(e3, t4, s, r2) {
    return f2(r2), this._onTileData(e3, t4, s, r2);
  }
  onTileClear(e3) {
    const t4 = { clear: true };
    return this._bufferData.delete(e3.key.id), this._bufferIds.delete(e3.key.id), this.remoteClient.invoke("tileRenderer.onTileData", { tileKey: e3.id, data: t4 });
  }
  onTileError(e3, t4, s) {
    const r2 = s.signal, i = { tileKey: e3.id, error: t4 };
    return this.remoteClient.invoke("tileRenderer.onTileError", i, { signal: r2 });
  }
  onTileUpdate(e3) {
    for (const t4 of e3.removed)
      this._bufferData.has(t4.key.id) && this._bufferData.delete(t4.key.id), this._bufferIds.has(t4.key.id) && this._bufferIds.delete(t4.key.id);
    for (const t4 of e3.added)
      this._bufferData.forEach((e4) => {
        for (const s of e4)
          s.message.tileKey === t4.id && this._updateTileMesh("append", t4, M(s), [], false, false, null);
      });
  }
  _addBufferData(e3, t4) {
    this._bufferData.has(e3) || this._bufferData.set(e3, []), this._bufferData.get(e3).push(M(t4));
  }
  _createFactory(e3) {
    const { geometryType: t4, objectIdField: r2, fields: i } = this.service, a2 = (e4, t5) => this.remoteClient.invoke("tileRenderer.getMaterialItems", e4, t5), o2 = { geometryType: t4, fields: i, spatialReference: k.fromJSON(this.spatialReference) }, n3 = new x(a2, this.tileStore.tileScheme.tileInfo), { matcher: l3, aggregateMatcher: c } = e3.mesh;
    return this._store = n3, this._matchers.feature = l2(l3, n3, o2, this._resourceManagerProxy), this._matchers.aggregate = o(c, (e4) => l2(e4, n3, o2, this._resourceManagerProxy)), new l(t4, r2, n3);
  }
  async _onTileData(e3, t4, s, a2) {
    f2(a2);
    const { type: o2, addOrUpdate: l3, remove: c, clear: d, end: h } = t4, f3 = !!this._schema.mesh.sortKey;
    if (!l3) {
      const t5 = { type: o2, addOrUpdate: null, remove: c, clear: d, end: h, sort: f3 };
      return this.remoteClient.invoke("tileRenderer.onTileData", { tileKey: e3.id, data: t5 }, a2);
    }
    const m2 = this._processFeatures(e3, l3, s, a2, t4.status.version);
    try {
      const s2 = await m2;
      if (t(s2)) {
        const t5 = { type: o2, addOrUpdate: null, remove: c, clear: d, end: h, sort: f3 };
        return this.remoteClient.invoke("tileRenderer.onTileData", { tileKey: e3.id, data: t5 }, a2);
      }
      const n3 = [];
      for (const t5 of s2) {
        let s3 = false;
        const r2 = t5.message.bufferIds, a3 = e3.key.id, o3 = t5.message.tileKey;
        if (a3 !== o3 && r(r2)) {
          if (!this.tileStore.get(o3)) {
            this._addBufferData(a3, t5), n3.push(t5);
            continue;
          }
          let e4 = this._bufferIds.get(o3);
          e4 || (e4 = /* @__PURE__ */ new Set(), this._bufferIds.set(o3, e4));
          const i = Array.from(r2);
          for (const t6 of i) {
            if (e4.has(t6)) {
              s3 = true;
              break;
            }
            e4.add(t6);
          }
        }
        s3 || (this._addBufferData(a3, t5), n3.push(t5));
      }
      await Promise.all(n3.map((s3) => {
        const r2 = e3.key.id === s3.message.tileKey, i = r2 ? t4.remove : [], n4 = r2 && t4.end;
        return this._updateTileMesh(o2, e3, s3, i, n4, t4.clear, a2.signal);
      }));
    } catch (u) {
      this._handleError(e3, u, a2);
    }
  }
  async _updateTileMesh(e3, t4, r2, i, a2, l3, c) {
    const d = e3, h = r2.message.tileKey, f3 = !!this._schema.mesh.sortKey;
    h !== t4.key.id && (a2 = false);
    const m2 = o(r2, (e4) => e4.message), u = o(r2, (e4) => e4.transferList) || [], g = { type: d, addOrUpdate: m2, remove: i, clear: l3, end: a2, sort: f3 }, p3 = { transferList: e(u) || [], signal: c };
    return f2(p3), this.remoteClient.invoke("tileRenderer.onTileData", { tileKey: h, data: g }, p3);
  }
  async _processFeatures(e3, t4, s, i, a2) {
    if (t(t4) || !t4.hasFeatures)
      return null;
    const o2 = { transform: e3.transform, hasZ: false, hasM: false }, l3 = this._factory, c = { viewingMode: "", scale: e3.scale }, d = await this._matchers.feature, h = await this._matchers.aggregate;
    f2(i);
    const f3 = this._getLabelInfos(e3, t4);
    return await l3.analyze(t4.getCursor(), this._resourceManagerProxy, d, h, o2, c), f2(i), this._writeFeatureSet(e3, t4, o2, f3, l3, s, a2);
  }
  _writeFeatureSet(e3, t4, s, r2, a2, o2, n3) {
    const l3 = t4.getSize(), c = this._schema.mesh.matcher.symbologyType, d = new E(e3.key.id, { features: l3, records: l3, metrics: 0 }, c, o2, c !== S.HEATMAP, n3), h = { viewingMode: "", scale: e3.scale }, f3 = t4.getCursor();
    for (; f3.next(); )
      try {
        const t5 = f3.getDisplayId(), o3 = r(r2) ? r2.get(t5) : null;
        a2.writeCursor(d, f3, s, h, e3.level, o3, this._resourceManagerProxy);
      } catch (p3) {
      }
    const m2 = e3.tileInfoView.tileInfo.isWrappable;
    return d.serialize(m2);
  }
  _handleError(e3, t4, s) {
    if (!j(t4)) {
      const r2 = { tileKey: e3.id, error: t4.message };
      return this.remoteClient.invoke("tileRenderer.onTileError", r2, { signal: s.signal });
    }
  }
  _getLabelingSchemaForScale(e3) {
    const t4 = this._schema.mesh.labels;
    if (t(t4))
      return null;
    if ("subtype" === t4.type) {
      const s2 = { type: "subtype", classes: {} };
      let r2 = false;
      for (const i in t4.classes) {
        const a2 = t4.classes[i].filter((t5) => I(t5, e3.scale));
        r2 = r2 || !!a2.length, s2.classes[i] = a2;
      }
      return r2 ? s2 : null;
    }
    const s = t4.classes.filter((t5) => I(t5, e3.scale));
    return s.length ? { type: "simple", classes: s } : null;
  }
  _getLabels(e3, t4) {
    var _a;
    if ("subtype" === t4.type) {
      const s = this.service.subtypeField, r2 = f(s, "Expected to find subtype Field"), i = e3.readAttribute(r2);
      return null == i ? [] : (_a = t4.classes[i]) != null ? _a : [];
    }
    return t4.classes;
  }
  _getLabelInfos(e3, s) {
    const i = this._getLabelingSchemaForScale(e3);
    if (t(i))
      return null;
    const a2 = /* @__PURE__ */ new Map(), o2 = s.getCursor();
    for (; o2.next(); ) {
      const e4 = o2.getDisplayId(), s2 = [], r2 = p2(e4), n3 = r2 && 1 !== o2.readAttribute("cluster_count") ? "aggregate" : "feature", l3 = this._getLabels(o2, i);
      for (const i2 of l3) {
        if (i2.target !== n3)
          continue;
        const a3 = o2.getStorage(), l4 = r2 && "feature" === n3 ? a3.getComputedStringAtIndex(o2.readAttribute("referenceId"), i2.fieldIndex) : a3.getComputedStringAtIndex(e4, i2.fieldIndex);
        if (!l4)
          continue;
        const c = n2(l4.toString()), d = c[0], h = c[1];
        this._store.getMosaicItem(i2.symbol, t2(d)).then((e5) => {
          s2[i2.index] = { glyphs: e5.glyphMosaicItems, rtl: h, index: i2.index };
        });
      }
      a2.set(e4, s2);
    }
    return a2;
  }
};
v = e2([n("esri.views.2d.layers.features.processors.SymbolProcessor")], v);
var T = v;
export {
  T as default
};
//# sourceMappingURL=SymbolProcessor-NIN3VA66.js.map
