import {
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/layers/graphics/OptimizedFeature.js
var s = class {
  constructor(t3 = null, s2 = {}, e2, o2) {
    this.geometry = t3, this.attributes = s2, this.centroid = e2, this.objectId = o2, this.displayId = 0, this.geohashX = 0, this.geohashY = 0;
  }
  weakClone() {
    const t3 = new s(this.geometry, this.attributes, this.centroid, this.objectId);
    return t3.displayId = this.displayId, t3.geohashX = this.geohashX, t3.geohashY = this.geohashY, t3;
  }
};
function e(s2) {
  return !(t(s2.geometry) || !s2.geometry.coords || !s2.geometry.coords.length);
}
var o = class extends s {
};

// node_modules/@arcgis/core/layers/graphics/OptimizedGeometry.js
var t2 = class {
  constructor(t3 = [], e2 = [], s2 = false) {
    this.lengths = t3 != null ? t3 : [], this.coords = e2 != null ? e2 : [], this.hasIndeterminateRingOrder = s2;
  }
  static fromRect(e2) {
    const [s2, h, n, r] = e2, i = n - s2, o2 = r - h;
    return new t2([5], [s2, h, i, 0, 0, o2, -i, 0, 0, -o2]);
  }
  get isPoint() {
    return 0 === this.lengths.length;
  }
  get maxLength() {
    return Math.max(...this.lengths);
  }
  get size() {
    return this.lengths.reduce((t3, e2) => t3 + e2);
  }
  forEachVertex(t3) {
    let e2 = 0;
    this.lengths.length || t3(this.coords[0], this.coords[1]);
    for (let s2 = 0; s2 < this.lengths.length; s2++) {
      const h = this.lengths[s2];
      for (let s3 = 0; s3 < h; s3++) {
        t3(this.coords[2 * (s3 + e2)], this.coords[2 * (s3 + e2) + 1]);
      }
      e2 += h;
    }
  }
  clone(e2) {
    return e2 ? (e2.set(this.coords), new t2(this.lengths.slice(), e2, this.hasIndeterminateRingOrder)) : new t2(this.lengths.slice(), this.coords.slice(), this.hasIndeterminateRingOrder);
  }
};

export {
  s,
  e,
  o,
  t2 as t
};
//# sourceMappingURL=chunk-34YPGGJT.js.map
