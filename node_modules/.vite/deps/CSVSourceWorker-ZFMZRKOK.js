import {
  u
} from "./chunk-UFNJIQA6.js";
import "./chunk-Z5PNFOTJ.js";
import {
  Y
} from "./chunk-EQTVTD33.js";
import "./chunk-3XRZHFYO.js";
import "./chunk-IOZMLQTF.js";
import "./chunk-P5Y67HOZ.js";
import {
  i,
  o
} from "./chunk-WKJPACEU.js";
import "./chunk-OP2HNSVZ.js";
import {
  a
} from "./chunk-6UMNMSQC.js";
import "./chunk-O5HVKKEP.js";
import "./chunk-IPJF6OUC.js";
import "./chunk-NWERINOI.js";
import {
  f
} from "./chunk-OEFH2SLX.js";
import "./chunk-K3WMIXIE.js";
import "./chunk-I4YZGF7W.js";
import "./chunk-65ZBTSJX.js";
import {
  t as t2
} from "./chunk-FZSI6IGI.js";
import "./chunk-36RXM3AP.js";
import "./chunk-IIAN3QNN.js";
import "./chunk-TJ2I6XQT.js";
import "./chunk-EDHROVWI.js";
import {
  s as s3,
  t
} from "./chunk-34YPGGJT.js";
import "./chunk-TWJNUVV2.js";
import "./chunk-NCXAKZRR.js";
import "./chunk-DUCSW4OU.js";
import "./chunk-WVDA5Z37.js";
import "./chunk-LT5KLTS5.js";
import "./chunk-SERWCSJG.js";
import "./chunk-RW4M3CI3.js";
import {
  ln
} from "./chunk-FFVIDMFN.js";
import {
  r
} from "./chunk-7Q5M7ANT.js";
import "./chunk-A4HIS5ZJ.js";
import "./chunk-W62B63EU.js";
import "./chunk-N43PI2UO.js";
import {
  j as j3
} from "./chunk-HUQX7WZO.js";
import "./chunk-ZWUEORSX.js";
import "./chunk-ZPYDYUP5.js";
import "./chunk-CZBRZ6SU.js";
import "./chunk-RT3T2K4S.js";
import "./chunk-WJCI2CGX.js";
import "./chunk-XMZAPOBR.js";
import {
  M
} from "./chunk-376OPXM4.js";
import "./chunk-DER356EU.js";
import "./chunk-IWQ7452U.js";
import "./chunk-NAN5J6QS.js";
import "./chunk-6M2AHKYV.js";
import "./chunk-JUVQV3R3.js";
import "./chunk-RAX2HD42.js";
import "./chunk-ZYRIJWLX.js";
import "./chunk-C5H57NTD.js";
import "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import "./chunk-YWAQYJRC.js";
import "./chunk-B356PXLT.js";
import "./chunk-EHPBHJYZ.js";
import "./chunk-3MNMDUQZ.js";
import {
  y
} from "./chunk-UWG37XSU.js";
import {
  E,
  c,
  k,
  k2
} from "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import "./chunk-HLM6QCL2.js";
import "./chunk-RXYULINL.js";
import "./chunk-5NXILPDI.js";
import "./chunk-THVR7IAM.js";
import {
  U
} from "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import {
  Ut,
  j as j2
} from "./chunk-KAN4HXCG.js";
import "./chunk-4FEGON7M.js";
import "./chunk-VWYWOOPX.js";
import "./chunk-M5VHU5LK.js";
import "./chunk-7QMMKGW4.js";
import "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import {
  j
} from "./chunk-MJXQTGI2.js";
import {
  s as s2
} from "./chunk-LIZHLHNA.js";
import "./chunk-BTUHYGXO.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";
import "./chunk-HVKDYDPP.js";
import "./chunk-6QC7MLLS.js";
import "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/layers/graphics/sources/csv/csv.js
var t3 = /^\s*"([\S\s]*)"\s*$/;
var n = /""/g;
var i2 = "\n";
var r2 = [",", " ", ";", "|", "	"];
function* l(e, t4, n2) {
  let i3 = 0;
  for (; i3 <= e.length; ) {
    const r3 = e.indexOf(t4, i3), l2 = e.substring(i3, r3 > -1 ? r3 : void 0);
    i3 += l2.length + t4.length, n2 && !l2.trim() || (yield l2);
  }
}
function o2(e) {
  const t4 = e.includes("\r\n") ? "\r\n" : i2;
  return l(e, t4, true);
}
function u2(e, t4) {
  return l(e, t4, false);
}
function s4(e, t4, n2) {
  var _a;
  e = e.trim(), t4 = t4 == null ? void 0 : t4.trim();
  const i3 = [], l2 = Array.from(/* @__PURE__ */ new Set([n2 == null ? void 0 : n2.delimiter, ...r2])).filter((e2) => null != e2);
  for (const r3 of l2) {
    const n3 = f2(e, r3).length, l3 = (_a = f2(t4, r3).length) != null ? _a : n3;
    n3 > 1 && i3.push({ weight: Math.min(n3, l3), delimiter: r3 });
  }
  const o3 = i3.sort(({ weight: e2 }, { weight: t5 }) => t5 - e2).map(({ delimiter: e2 }) => e2);
  for (const r3 of o3) {
    const t5 = g(a2(e, r3).names, n2 == null ? void 0 : n2.longitudeField, n2 == null ? void 0 : n2.latitudeField);
    if (t5.longitudeFieldName && t5.latitudeFieldName)
      return { delimiter: r3, locationInfo: t5 };
  }
  return { delimiter: o3[0], locationInfo: null };
}
function* c2(e, r3, l2, s5 = () => /* @__PURE__ */ Object.create(null)) {
  const c3 = o2(e);
  c3.next();
  let a3 = "", f3 = "", g2 = 0, m2 = s5(), p2 = 0;
  e:
    for (const o3 of c3) {
      const e2 = u2(o3, l2);
      for (const i3 of e2)
        if (a3 += f3 + i3, f3 = "", g2 += d(i3), g2 % 2 == 0) {
          if (g2 > 0) {
            const e3 = t3.exec(a3);
            if (!e3) {
              m2 = s5(), p2 = 0, a3 = "", g2 = 0;
              continue e;
            }
            m2[r3[p2]] = e3[1].replace(n, '"'), p2++;
          } else
            m2[r3[p2]] = a3, p2++;
          a3 = "", g2 = 0;
        } else
          f3 = l2;
      0 === g2 ? (yield m2, m2 = s5(), p2 = 0) : f3 = i2;
    }
}
function a2(e, t4) {
  const n2 = f2(e, t4).filter((e2) => null != e2), i3 = n2.map((e2) => $(e2));
  for (let r3 = i3.length - 1; r3 >= 0; r3--)
    i3[r3] || (i3.splice(r3, 1), n2.splice(r3, 1));
  return { names: i3, aliases: n2 };
}
function f2(e, i3) {
  if (!(e == null ? void 0 : e.length))
    return [];
  const r3 = [];
  let l2 = "", o3 = "", s5 = 0;
  const c3 = u2(e, i3);
  for (const u3 of c3)
    if (l2 += o3 + u3, o3 = "", s5 += d(u3), s5 % 2 == 0) {
      if (s5 > 0) {
        const e2 = t3.exec(l2);
        e2 && r3.push(e2[1].replace(n, '"'));
      } else
        r3.push(l2);
      l2 = "", s5 = 0;
    } else
      o3 = i3;
  return r3;
}
function d(e) {
  let t4 = 0, n2 = 0;
  for (n2 = e.indexOf('"', n2); n2 >= 0; )
    t4++, n2 = e.indexOf('"', n2 + 1);
  return t4;
}
function g(e, t4, n2) {
  var _a, _b;
  t4 = (_a = $(t4)) == null ? void 0 : _a.toLowerCase(), n2 = (_b = $(n2)) == null ? void 0 : _b.toLowerCase();
  const i3 = e.map((e2) => e2.toLowerCase()), r3 = t4 ? e[i3.indexOf(t4)] : null, l2 = n2 ? e[i3.indexOf(n2)] : null;
  return { longitudeFieldName: r3 || e[i3.indexOf(F.find((e2) => i3.includes(e2)))], latitudeFieldName: l2 || e[i3.indexOf(y2.find((e2) => i3.includes(e2)))] };
}
function m(e, t4, n2, i3, r3) {
  const l2 = [], o3 = c2(e, n2, t4), u3 = [];
  for (const s5 of o3) {
    if (10 === u3.length)
      break;
    u3.push(s5);
  }
  for (let s5 = 0; s5 < n2.length; s5++) {
    const e2 = n2[s5], t5 = i3[s5];
    if (e2 === r3.longitudeFieldName || e2 === r3.latitudeFieldName)
      l2.push({ name: e2, type: "esriFieldTypeDouble", alias: t5 });
    else {
      let n3, i4;
      switch (p(u3.map((t6) => t6[e2]))) {
        case "integer":
          n3 = "esriFieldTypeInteger";
          break;
        case "double":
          n3 = "esriFieldTypeDouble";
          break;
        case "date":
          n3 = "esriFieldTypeDate", i4 = 36;
          break;
        default:
          n3 = "esriFieldTypeString", i4 = 255;
      }
      l2.push({ name: e2, type: n3, alias: t5, length: i4 });
    }
  }
  return l2;
}
function p(e) {
  if (!e.length)
    return "string";
  const t4 = /[^+-.,0-9]/;
  return e.map((e2) => {
    let n2 = false;
    if ("" !== e2) {
      if (t4.test(e2))
        n2 = true;
      else {
        let t5 = h(e2);
        if (!isNaN(t5))
          return /[.,]/.test(e2) || !Number.isInteger(t5) || t5 > 214783647 || t5 < -214783648 ? "double" : "integer";
        if (e2.includes("E")) {
          if (t5 = Number(e2), !isNaN(t5))
            return "double";
          if (e2.includes(",")) {
            if (e2 = e2.replace(",", "."), t5 = Number(e2), !isNaN(t5))
              return "double";
            n2 = true;
          } else
            n2 = true;
        } else
          n2 = true;
      }
      if (n2) {
        if (!/^[-]?\d*[.,]?\d*$/.test(e2)) {
          return b(new Date(e2), e2) ? "date" : "string";
        }
        return "string";
      }
      return "string";
    }
  }).reduce((e2, t5) => void 0 === e2 ? t5 : void 0 === t5 ? e2 : e2 === t5 ? t5 : "string" === e2 || "string" === t5 ? "string" : "double" === e2 || "double" === t5 ? "double" : void 0);
}
function b(e, t4) {
  if (!e || "[object Date]" !== Object.prototype.toString.call(e) || isNaN(e.getTime()))
    return false;
  let n2 = true;
  if (!x && /\d+\W*$/.test(t4)) {
    const e2 = t4.match(/[a-zA-Z]{2,}/);
    if (e2) {
      let t5 = false, i3 = 0;
      for (; !t5 && i3 <= e2.length; )
        t5 = !N.test(e2[i3]), i3++;
      n2 = !t5;
    }
  }
  return n2;
}
var h = function() {
  const t4 = a(), n2 = new RegExp("^" + t4.regexp + "$"), i3 = new RegExp("[" + t4.group + "\\s\\xa0]", "g"), r3 = t4.factor;
  return (e) => {
    const l2 = n2.exec(e);
    if (t4.factor = r3, !l2)
      return NaN;
    let o3 = l2[1];
    if (!l2[1]) {
      if (!l2[2])
        return NaN;
      o3 = l2[2], t4.factor *= -1;
    }
    return o3 = o3.replace(i3, "").replace(t4.decimal, "."), +o3 * t4.factor;
  };
}();
var N = /^((jan(uary)?)|(feb(ruary)?)|(mar(ch)?)|(apr(il)?)|(may)|(jun(e)?)|(jul(y)?)|(aug(ust)?)|(sep(tember)?)|(oct(ober)?)|(nov(ember)?)|(dec(ember)?)|(am)|(pm)|(gmt)|(utc))$/i;
var x = Number.isNaN(new Date("technology 10").getTime());
var y2 = ["lat", "latitude", "latitude83", "latdecdeg", "lat_dd", "y", "ycenter", "point_y"];
var F = ["lon", "lng", "long", "longitude", "longitude83", "longdecdeg", "long_dd", "x", "xcenter", "point_x"];
var w = /^([0-9])/;
var _ = /[^A-Za-z0-9_\u0080-\uffff]/g;
var O = /_{2,}/g;
var j4 = /^_/;
var T = /_$/;
function $(e) {
  return e ? e.trim().replace(_, "_").replace(O, "_").replace(j4, "").replace(T, "").replace(w, "F$1") : null;
}

// node_modules/@arcgis/core/layers/graphics/sources/support/CSVSourceWorker.js
var C = o("esriGeometryPoint");
var v = ["csv"];
var O2 = [0, 0];
var D = class {
  constructor(e, t4) {
    this.x = e, this.y = t4;
  }
};
var k3 = class {
  constructor() {
    this._queryEngine = null, this._snapshotFeatures = async (e) => {
      const t4 = await this._fetch(e);
      return this._createFeatures(t4);
    };
  }
  destroy() {
    var _a;
    (_a = this._queryEngine) == null ? void 0 : _a.destroy(), this._queryEngine = null;
  }
  async load(e, t4 = {}) {
    var _a;
    this._loadOptions = e;
    const [i3] = await Promise.all([this._fetch(t4.signal), this._checkProjection((_a = e == null ? void 0 : e.parsingOptions) == null ? void 0 : _a.spatialReference)]), n2 = P(i3, e);
    this._locationInfo = n2.locationInfo, this._delimiter = n2.delimiter, this._queryEngine = this._createQueryEngine(n2);
    const r3 = await this._createFeatures(i3);
    if (this._queryEngine.featureStore.addMany(r3), n2.layerDefinition.extent = this._queryEngine.fullExtent, n2.layerDefinition.timeInfo) {
      const { start: e2, end: t5 } = this._queryEngine.timeExtent;
      n2.layerDefinition.timeInfo.timeExtent = [e2, t5];
    }
    return n2;
  }
  async applyEdits() {
    throw new s2("csv-layer:editing-not-supported", "applyEdits() is not supported on CSVLayer");
  }
  async queryFeatures(e = {}, t4 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQuery(e, t4.signal);
  }
  async queryFeatureCount(e = {}, t4 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForCount(e, t4.signal);
  }
  async queryObjectIds(e = {}, t4 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForIds(e, t4.signal);
  }
  async queryExtent(e = {}, t4 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForExtent(e, t4.signal);
  }
  async querySnapping(e, t4 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForSnapping(e, t4.signal);
  }
  async refresh(e) {
    var _a;
    return this._loadOptions.customParameters = e, (_a = this._snapshotTask) == null ? void 0 : _a.abort(), this._snapshotTask = j3(this._snapshotFeatures), this._snapshotTask.promise.then((e2) => {
      this._queryEngine.featureStore.clear(), e2 && this._queryEngine.featureStore.addMany(e2);
    }, (e2) => {
      this._queryEngine.featureStore.clear(), j(e2) || s.getLogger("esri.layers.CSVLayer").error(new s2("csv-layer:refresh", "An error occurred during refresh", { error: e2 }));
    }), await this._waitSnapshotComplete(), { extent: this._queryEngine.fullExtent, timeExtent: this._queryEngine.timeExtent };
  }
  async _waitSnapshotComplete() {
    if (this._snapshotTask && !this._snapshotTask.finished) {
      try {
        await this._snapshotTask.promise;
      } catch {
      }
      return this._waitSnapshotComplete();
    }
  }
  async _fetch(t4) {
    const { url: n2, customParameters: r3 } = this._loadOptions;
    if (!n2)
      throw new s2("csv-layer:invalid-source", "url not defined");
    const o3 = j2(n2);
    return (await U(o3.path, { query: { ...o3.query, ...r3 }, responseType: "text", signal: t4 })).data;
  }
  _createQueryEngine(e) {
    const { objectIdField: t4, fields: i3, extent: n2, timeInfo: r3 } = e.layerDefinition, s5 = new u({ geometryType: "esriGeometryPoint", hasM: false, hasZ: false });
    return new Y({ fields: i3, geometryType: "esriGeometryPoint", hasM: false, hasZ: false, timeInfo: r3, objectIdField: t4, spatialReference: n2.spatialReference || { wkid: 4326 }, cacheSpatialQueries: true, featureStore: s5 });
  }
  async _createFeatures(e) {
    const { latitudeFieldName: t4, longitudeFieldName: i3 } = this._locationInfo, { objectIdField: n2, fieldsIndex: r3, spatialReference: s5 } = this._queryEngine;
    let o3 = [];
    const u3 = [], y3 = r3.fields.filter((e2) => e2.name !== n2).map((e2) => e2.name);
    let h2 = 0;
    const g2 = {};
    for (const a3 of r3.fields)
      if ("esriFieldTypeOID" !== a3.type && "esriFieldTypeGlobalID" !== a3.type) {
        const e2 = M(a3);
        void 0 !== e2 && (g2[a3.name] = e2);
      }
    const w2 = c2(e, y3, this._delimiter, i(g2, n2));
    for (const a3 of w2) {
      const e2 = this._parseCoordinateValue(a3[t4]), s6 = this._parseCoordinateValue(a3[i3]);
      if (null != s6 && null != e2 && !isNaN(e2) && !isNaN(s6)) {
        a3[t4] = e2, a3[i3] = s6;
        for (const e3 in a3)
          if (e3 !== t4 && e3 !== i3) {
            if (r3.isDateField(e3)) {
              const t5 = new Date(a3[e3]);
              a3[e3] = b(t5, a3[e3]) ? t5.getTime() : null;
            } else if (r3.isNumericField(e3)) {
              const t5 = h(a3[e3]);
              isNaN(t5) ? a3[e3] = null : a3[e3] = t5;
            }
          }
        a3[n2] = h2, h2++, o3.push(new D(s6, e2)), u3.push(a3);
      }
    }
    if (!E({ wkid: 4326 }, s5))
      if (k(s5))
        for (const a3 of o3)
          [a3.x, a3.y] = y(a3.x, a3.y, O2);
      else
        o3 = ln(t2, o3, k2.WGS84, s5, null, null);
    const E2 = [];
    for (let a3 = 0; a3 < o3.length; a3++) {
      const { x: e2, y: t5 } = o3[a3], i4 = u3[a3];
      i4[n2] = a3 + 1, E2.push(new s3(new t([], [e2, t5]), i4, null, i4[n2]));
    }
    return E2;
  }
  _parseCoordinateValue(e) {
    if (null == e || "" === e)
      return null;
    let t4 = h(e);
    return (isNaN(t4) || Math.abs(t4) > 181) && (t4 = parseFloat(e)), t4;
  }
  async _checkProjection(e) {
    try {
      await f(c, e);
    } catch {
      throw new s2("csv-layer:projection-not-supported", "Projection not supported");
    }
  }
};
function P(e, t4) {
  var _a, _b, _c;
  const n2 = t4.parsingOptions || {}, r3 = { delimiter: n2.delimiter, layerDefinition: null, locationInfo: { latitudeFieldName: n2.latitudeField, longitudeFieldName: n2.longitudeField } }, s5 = r3.layerDefinition = { name: Ut(t4.url, v) || "csv", drawingInfo: C, geometryType: "esriGeometryPoint", objectIdField: null, fields: [], timeInfo: n2.timeInfo, extent: { xmin: Number.POSITIVE_INFINITY, ymin: Number.POSITIVE_INFINITY, xmax: Number.NEGATIVE_INFINITY, ymax: Number.NEGATIVE_INFINITY, spatialReference: n2.spatialReference || { wkid: 102100 } } }, a3 = o2(e), l2 = (_a = a3.next().value) == null ? void 0 : _a.trim(), c3 = (_b = a3.next().value) == null ? void 0 : _b.trim();
  if (!l2)
    throw new s2("csv-layer:empty-csv", "CSV is empty", { csv: e });
  const { delimiter: m2, locationInfo: u3 } = s4(l2, c3, n2);
  if (!m2)
    throw new s2("csv-layer:invalid-delimiter", "Unable to detect the delimiter from CSV", { firstLine: l2, secondLine: c3, parsingOptions: n2 });
  if (!u3)
    throw new s2("csv-layer:location-fields-not-found", "Unable to identify latitude and longitude fields from the CSV file", { firstLine: l2, secondLine: c3, parsingOptions: n2 });
  r3.locationInfo = u3, r3.delimiter = m2;
  const { names: d2, aliases: p2 } = a2(l2, m2), f3 = m(e, r3.delimiter, d2, p2, r3.locationInfo);
  if ((_c = n2.fields) == null ? void 0 : _c.length) {
    const e2 = new r(n2.fields);
    for (const t5 of f3) {
      const i3 = e2.get(t5.name);
      i3 && Object.assign(t5, i3);
    }
  }
  if (!f3.some((e2) => "esriFieldTypeOID" === e2.type && (s5.objectIdField = e2.name, true))) {
    const e2 = { name: "__OBJECTID", alias: "__OBJECTID", type: "esriFieldTypeOID", editable: false, nullable: false };
    s5.objectIdField = e2.name, f3.unshift(e2);
  }
  s5.fields = f3;
  const y3 = new r(s5.fields);
  if (r3.locationInfo && (r3.locationInfo.latitudeFieldName = y3.get(r3.locationInfo.latitudeFieldName).name, r3.locationInfo.longitudeFieldName = y3.get(r3.locationInfo.longitudeFieldName).name), s5.timeInfo) {
    const e2 = s5.timeInfo;
    if (e2.startTimeField) {
      const t5 = y3.get(e2.startTimeField);
      t5 ? (e2.startTimeField = t5.name, t5.type = "esriFieldTypeDate") : e2.startTimeField = null;
    }
    if (e2.endTimeField) {
      const t5 = y3.get(e2.endTimeField);
      t5 ? (e2.endTimeField = t5.name, t5.type = "esriFieldTypeDate") : e2.endTimeField = null;
    }
    if (e2.trackIdField) {
      const t5 = y3.get(e2.trackIdField);
      e2.trackIdField = t5 ? t5.name : null;
    }
    e2.startTimeField || e2.endTimeField || (s5.timeInfo = null);
  }
  return r3;
}
export {
  k3 as default
};
//# sourceMappingURL=CSVSourceWorker-ZFMZRKOK.js.map
