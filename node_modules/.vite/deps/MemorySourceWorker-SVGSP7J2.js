import {
  a as a2,
  f as f2,
  g as g2,
  m,
  w
} from "./chunk-NE5VVZO2.js";
import {
  u
} from "./chunk-UFNJIQA6.js";
import "./chunk-Z5PNFOTJ.js";
import {
  Y
} from "./chunk-EQTVTD33.js";
import "./chunk-3XRZHFYO.js";
import "./chunk-IOZMLQTF.js";
import "./chunk-P5Y67HOZ.js";
import {
  n,
  t as t2
} from "./chunk-V4I7Q273.js";
import {
  a,
  i as i2,
  o
} from "./chunk-WKJPACEU.js";
import "./chunk-OP2HNSVZ.js";
import "./chunk-O5HVKKEP.js";
import "./chunk-IPJF6OUC.js";
import "./chunk-NWERINOI.js";
import {
  f,
  g
} from "./chunk-OEFH2SLX.js";
import "./chunk-K3WMIXIE.js";
import "./chunk-I4YZGF7W.js";
import "./chunk-65ZBTSJX.js";
import "./chunk-FZSI6IGI.js";
import "./chunk-36RXM3AP.js";
import "./chunk-IIAN3QNN.js";
import {
  X,
  ot,
  tt
} from "./chunk-TJ2I6XQT.js";
import "./chunk-EDHROVWI.js";
import "./chunk-34YPGGJT.js";
import "./chunk-TWJNUVV2.js";
import "./chunk-NCXAKZRR.js";
import "./chunk-DUCSW4OU.js";
import "./chunk-WVDA5Z37.js";
import "./chunk-LT5KLTS5.js";
import "./chunk-SERWCSJG.js";
import "./chunk-RW4M3CI3.js";
import "./chunk-FFVIDMFN.js";
import {
  r as r2
} from "./chunk-7Q5M7ANT.js";
import "./chunk-A4HIS5ZJ.js";
import {
  i
} from "./chunk-BUVDI6S7.js";
import "./chunk-W62B63EU.js";
import "./chunk-N43PI2UO.js";
import "./chunk-ZWUEORSX.js";
import "./chunk-ZPYDYUP5.js";
import "./chunk-CZBRZ6SU.js";
import "./chunk-RT3T2K4S.js";
import "./chunk-WJCI2CGX.js";
import "./chunk-XMZAPOBR.js";
import {
  M
} from "./chunk-376OPXM4.js";
import "./chunk-DER356EU.js";
import "./chunk-IWQ7452U.js";
import "./chunk-NAN5J6QS.js";
import "./chunk-6M2AHKYV.js";
import "./chunk-JUVQV3R3.js";
import "./chunk-RAX2HD42.js";
import "./chunk-ZYRIJWLX.js";
import "./chunk-C5H57NTD.js";
import "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import "./chunk-YWAQYJRC.js";
import "./chunk-B356PXLT.js";
import {
  c as c2,
  s as s2
} from "./chunk-EHPBHJYZ.js";
import "./chunk-3MNMDUQZ.js";
import "./chunk-UWG37XSU.js";
import {
  c
} from "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import "./chunk-HLM6QCL2.js";
import "./chunk-RXYULINL.js";
import "./chunk-5NXILPDI.js";
import "./chunk-THVR7IAM.js";
import "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import "./chunk-KAN4HXCG.js";
import "./chunk-VWYWOOPX.js";
import "./chunk-M5VHU5LK.js";
import "./chunk-7QMMKGW4.js";
import "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import "./chunk-MJXQTGI2.js";
import {
  s
} from "./chunk-LIZHLHNA.js";
import "./chunk-BTUHYGXO.js";
import "./chunk-UA3YPL2R.js";
import "./chunk-HVKDYDPP.js";
import "./chunk-6QC7MLLS.js";
import {
  r,
  t
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/layers/graphics/sources/support/MemorySourceWorker.js
var R = c;
var q = { xmin: -180, ymin: -90, xmax: 180, ymax: 90, spatialReference: c };
var D = { hasAttachments: false, capabilities: "query, editing, create, delete, update", useStandardizedQueries: true, supportsCoordinatesQuantization: true, supportsReturningQueryGeometry: true, advancedQueryCapabilities: { supportsQueryAttachments: false, supportsStatistics: true, supportsPercentileStatistics: true, supportsReturningGeometryCentroid: true, supportsQueryWithDistance: true, supportsDistinct: true, supportsReturningQueryExtent: true, supportsReturningGeometryProperties: false, supportsHavingClause: true, supportsOrderBy: true, supportsPagination: true, supportsQueryWithResultType: false, supportsSqlExpression: true, supportsDisjointSpatialRel: true } };
function O(e) {
  return s2(e) ? null != e.z : !!e.hasZ;
}
function w2(e) {
  return s2(e) ? null != e.m : !!e.hasM;
}
var S = class {
  constructor() {
    this._queryEngine = null, this._nextObjectId = null;
  }
  destroy() {
    this._queryEngine && this._queryEngine && this._queryEngine.destroy(), this._queryEngine = this._fieldsIndex = this._createDefaultAttributes = null;
  }
  async load(t3) {
    const i3 = [], { features: s3 } = t3, r3 = this._inferLayerProperties(s3, t3.fields), n2 = t3.fields || [], a3 = null != t3.hasM ? t3.hasM : r3.hasM, o2 = null != t3.hasZ ? t3.hasZ : r3.hasZ, l = !t3.spatialReference && !r3.spatialReference, y = l ? R : t3.spatialReference || r3.spatialReference, I = l ? q : null, b = t3.geometryType || r3.geometryType, F = !b;
    let j = t3.objectIdField || r3.objectIdField, _ = t3.timeInfo;
    if (!F && (l && i3.push({ name: "feature-layer:spatial-reference-not-found", message: "Spatial reference not provided or found in features. Defaults to WGS84" }), !b))
      throw new s("feature-layer:missing-property", "geometryType not set and couldn't be inferred from the provided features");
    if (!j)
      throw new s("feature-layer:missing-property", "objectIdField not set and couldn't be found in the provided fields");
    if (r3.objectIdField && j !== r3.objectIdField && (i3.push({ name: "feature-layer:duplicated-oid-field", message: `Provided objectIdField "${j}" doesn't match the field name "${r3.objectIdField}", found in the provided fields` }), j = r3.objectIdField), j && !r3.objectIdField) {
      let e = null;
      n2.some((t4) => t4.name === j && (e = t4, true)) ? (e.type = "esriFieldTypeOID", e.editable = false, e.nullable = false) : n2.unshift({ alias: j, name: j, type: "esriFieldTypeOID", editable: false, nullable: false });
    }
    for (const u2 of n2) {
      if (null == u2.name && (u2.name = u2.alias), null == u2.alias && (u2.alias = u2.name), !u2.name)
        throw new s("feature-layer:invalid-field-name", "field name is missing", { field: u2 });
      if (u2.name === j && (u2.type = "esriFieldTypeOID"), !i.jsonValues.includes(u2.type))
        throw new s("feature-layer:invalid-field-type", `invalid type for field "${u2.name}"`, { field: u2 });
    }
    const O2 = {};
    for (const e of n2)
      if ("esriFieldTypeOID" !== e.type && "esriFieldTypeGlobalID" !== e.type) {
        const t4 = M(e);
        void 0 !== t4 && (O2[e.name] = t4);
      }
    if (this._fieldsIndex = new r2(n2), this._createDefaultAttributes = i2(O2, j), _) {
      if (_.startTimeField) {
        const e = this._fieldsIndex.get(_.startTimeField);
        e ? (_.startTimeField = e.name, e.type = "esriFieldTypeDate") : _.startTimeField = null;
      }
      if (_.endTimeField) {
        const e = this._fieldsIndex.get(_.endTimeField);
        e ? (_.endTimeField = e.name, e.type = "esriFieldTypeDate") : _.endTimeField = null;
      }
      if (_.trackIdField) {
        const e = this._fieldsIndex.get(_.trackIdField);
        e ? _.trackIdField = e.name : (_.trackIdField = null, i3.push({ name: "feature-layer:invalid-timeInfo-trackIdField", message: "trackIdField is missing", details: { timeInfo: _ } }));
      }
      _.startTimeField || _.endTimeField || (i3.push({ name: "feature-layer:invalid-timeInfo", message: "startTimeField and endTimeField are missing or invalid", details: { timeInfo: _ } }), _ = null);
    }
    const w3 = { warnings: i3, featureErrors: [], layerDefinition: { ...D, drawingInfo: o(b), templates: a(O2), extent: I, geometryType: b, objectIdField: j, fields: n2, hasZ: !!o2, hasM: !!a3, timeInfo: _ }, assignedObjectIds: {} };
    if (this._queryEngine = new Y({ fields: n2, geometryType: b, hasM: a3, hasZ: o2, objectIdField: j, spatialReference: y, featureStore: new u({ geometryType: b, hasM: a3, hasZ: o2 }), timeInfo: _, cacheSpatialQueries: true }), !s3 || !s3.length)
      return this._nextObjectId = t2, w3;
    const S2 = n(j, s3);
    return this._nextObjectId = S2 + 1, await f(s3, y), this._loadInitialFeatures(w3, s3);
  }
  async applyEdits(e) {
    const { spatialReference: t3, geometryType: i3 } = this._queryEngine;
    return await Promise.all([w(t3, i3), f(e.adds, t3), f(e.updates, t3)]), this._applyEdits(e);
  }
  queryFeatures(e, t3 = {}) {
    return this._queryEngine.executeQuery(e, t3.signal);
  }
  queryFeatureCount(e, t3 = {}) {
    return this._queryEngine.executeQueryForCount(e, t3.signal);
  }
  queryObjectIds(e, t3 = {}) {
    return this._queryEngine.executeQueryForIds(e, t3.signal);
  }
  queryExtent(e, t3 = {}) {
    return this._queryEngine.executeQueryForExtent(e, t3.signal);
  }
  querySnapping(e, t3 = {}) {
    return this._queryEngine.executeQueryForSnapping(e, t3.signal);
  }
  _inferLayerProperties(e, i3) {
    let r3, n2, a3 = null, o2 = null, l = null;
    for (const u2 of e) {
      const e2 = u2.geometry;
      if (!t(e2) && (a3 || (a3 = c2(e2)), o2 || (o2 = e2.spatialReference), null == r3 && (r3 = O(e2)), null == n2 && (n2 = w2(e2)), a3 && o2 && null != r3 && null != n2))
        break;
    }
    if (i3 && i3.length) {
      let e2 = null;
      i3.some((t3) => {
        const i4 = "esriFieldTypeOID" === t3.type, s3 = !t3.type && t3.name && "objectid" === t3.name.toLowerCase();
        return e2 = t3, i4 || s3;
      }) && (l = e2.name);
    }
    return { geometryType: a3, spatialReference: o2, objectIdField: l, hasM: n2, hasZ: r3 };
  }
  _loadInitialFeatures(e, t3) {
    const { geometryType: r3, hasM: n2, hasZ: o2, objectIdField: l, spatialReference: u2, featureStore: d } = this._queryEngine, p = [];
    for (const a3 of t3) {
      if (null != a3.uid && (e.assignedObjectIds[a3.uid] = -1), a3.geometry && r3 !== c2(a3.geometry)) {
        e.featureErrors.push(a2("Incorrect geometry type."));
        continue;
      }
      const t4 = this._createDefaultAttributes(), n3 = m(this._fieldsIndex, t4, a3.attributes, true, e.warnings);
      n3 ? e.featureErrors.push(n3) : (this._assignObjectId(t4, a3.attributes, true), a3.attributes = t4, null != a3.uid && (e.assignedObjectIds[a3.uid] = a3.attributes[l]), r(a3.geometry) && (a3.geometry = g(a3.geometry, a3.geometry.spatialReference, u2)), p.push(a3));
    }
    if (d.addMany(tt([], p, r3, o2, n2, l)), e.layerDefinition.extent = this._queryEngine.fullExtent, e.layerDefinition.timeInfo) {
      const { start: t4, end: i3 } = this._queryEngine.timeExtent;
      e.layerDefinition.timeInfo.timeExtent = [t4, i3];
    }
    return e;
  }
  _applyEdits(e) {
    const { adds: t3, updates: i3, deletes: s3 } = e, r3 = { addResults: [], deleteResults: [], updateResults: [], uidToObjectId: {} };
    if (t3 && t3.length && this._applyAddEdits(r3, t3), i3 && i3.length && this._applyUpdateEdits(r3, i3), s3 && s3.length) {
      for (const e2 of s3)
        r3.deleteResults.push(f2(e2));
      this._queryEngine.featureStore.removeManyById(s3);
    }
    return { fullExtent: this._queryEngine.fullExtent, featureEditResults: r3 };
  }
  _applyAddEdits(e, t3) {
    var _a;
    const { addResults: r3 } = e, { geometryType: n2, hasM: o2, hasZ: l, objectIdField: u2, spatialReference: d, featureStore: p } = this._queryEngine, f3 = [];
    for (const a3 of t3) {
      if (a3.geometry && n2 !== c2(a3.geometry)) {
        r3.push(a2("Incorrect geometry type."));
        continue;
      }
      const t4 = this._createDefaultAttributes(), o3 = m(this._fieldsIndex, t4, a3.attributes);
      if (o3)
        r3.push(o3);
      else {
        if (this._assignObjectId(t4, a3.attributes), a3.attributes = t4, null != a3.uid) {
          const t5 = a3.attributes[u2];
          e.uidToObjectId[a3.uid] = t5;
        }
        if (r(a3.geometry)) {
          const e2 = (_a = a3.geometry.spatialReference) != null ? _a : d;
          a3.geometry = g(g2(a3.geometry, e2), e2, d);
        }
        f3.push(a3), r3.push(f2(a3.attributes[u2]));
      }
    }
    p.addMany(tt([], f3, n2, l, o2, u2));
  }
  _applyUpdateEdits({ updateResults: e }, t3) {
    var _a;
    const { geometryType: r3, hasM: n2, hasZ: a3, objectIdField: u2, spatialReference: d, featureStore: p } = this._queryEngine;
    for (const f3 of t3) {
      const { attributes: t4, geometry: c3 } = f3, m2 = t4 && t4[u2];
      if (null == m2) {
        e.push(a2(`Identifier field ${u2} missing`));
        continue;
      }
      if (!p.has(m2)) {
        e.push(a2(`Feature with object id ${m2} missing`));
        continue;
      }
      const h = ot(p.getFeature(m2), r3, a3, n2);
      if (r(c3)) {
        if (r3 !== c2(c3)) {
          e.push(a2("Incorrect geometry type."));
          continue;
        }
        const t5 = (_a = c3.spatialReference) != null ? _a : d;
        h.geometry = g(g2(c3, t5), t5, d);
      }
      if (t4) {
        const i3 = m(this._fieldsIndex, h.attributes, t4);
        if (i3) {
          e.push(i3);
          continue;
        }
      }
      p.add(X(h, r3, a3, n2, u2)), e.push(f2(m2));
    }
  }
  _assignObjectId(e, t3, i3 = false) {
    const s3 = this._queryEngine.objectIdField;
    i3 && t3 && isFinite(t3[s3]) ? e[s3] = t3[s3] : e[s3] = this._nextObjectId++;
  }
};
export {
  S as default
};
//# sourceMappingURL=MemorySourceWorker-SVGSP7J2.js.map
