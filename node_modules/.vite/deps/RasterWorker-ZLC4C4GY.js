import {
  i,
  l
} from "./chunk-DL3FP7BG.js";
import {
  $,
  M,
  T as T3
} from "./chunk-DQCR5QA4.js";
import {
  S,
  T as T2,
  p
} from "./chunk-6VAE3YKY.js";
import {
  d,
  f2 as f,
  m
} from "./chunk-OYDVEVDU.js";
import {
  D,
  T,
  W,
  g,
  j
} from "./chunk-OAXPH6DL.js";
import "./chunk-UAJ2SDPQ.js";
import {
  s2 as s
} from "./chunk-FFVIDMFN.js";
import "./chunk-W62B63EU.js";
import "./chunk-ZWUEORSX.js";
import "./chunk-ZPYDYUP5.js";
import "./chunk-RT3T2K4S.js";
import "./chunk-WJCI2CGX.js";
import "./chunk-NAN5J6QS.js";
import "./chunk-6M2AHKYV.js";
import "./chunk-JUVQV3R3.js";
import "./chunk-RAX2HD42.js";
import "./chunk-ZYRIJWLX.js";
import "./chunk-C5H57NTD.js";
import "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import "./chunk-YWAQYJRC.js";
import "./chunk-B356PXLT.js";
import "./chunk-EHPBHJYZ.js";
import "./chunk-3MNMDUQZ.js";
import {
  w2 as w
} from "./chunk-UWG37XSU.js";
import "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import "./chunk-HLM6QCL2.js";
import "./chunk-RXYULINL.js";
import "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import "./chunk-KAN4HXCG.js";
import "./chunk-VWYWOOPX.js";
import "./chunk-M5VHU5LK.js";
import "./chunk-7QMMKGW4.js";
import "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import "./chunk-MJXQTGI2.js";
import "./chunk-LIZHLHNA.js";
import "./chunk-BTUHYGXO.js";
import "./chunk-UA3YPL2R.js";
import "./chunk-HVKDYDPP.js";
import "./chunk-6QC7MLLS.js";
import {
  e,
  r
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/layers/support/RasterWorker.js
var N = class {
  convertVectorFieldData(e2) {
    const t = g.fromJSON(e2.pixelBlock), o = d(t, e2.type);
    return Promise.resolve(r(o) && o.toJSON());
  }
  async decode(r2) {
    const e2 = await S(r2.data, r2.options);
    return e2 && e2.toJSON();
  }
  symbolize(e2) {
    e2.pixelBlock = g.fromJSON(e2.pixelBlock), e2.extent = e2.extent ? w.fromJSON(e2.extent) : null;
    const t = this.symbolizer.symbolize(e2);
    return Promise.resolve(r(t) && t.toJSON());
  }
  async updateSymbolizer(r2) {
    var _a;
    this.symbolizer = T2.fromJSON(r2.symbolizerJSON), r2.histograms && "rasterStretch" === ((_a = this.symbolizer) == null ? void 0 : _a.rendererJSON.type) && (this.symbolizer.rendererJSON.histograms = r2.histograms);
  }
  async updateRasterFunction(r2) {
    this.rasterFunction = l(r2.rasterFunctionJSON);
  }
  async process(e2) {
    const t = this.rasterFunction.process({ extent: w.fromJSON(e2.extent), primaryPixelBlocks: e2.primaryPixelBlocks.map((e3) => r(e3) ? g.fromJSON(e3) : null), primaryRasterIds: e2.primaryRasterIds });
    return r(t) ? t.toJSON() : null;
  }
  stretch(e2) {
    const t = this.symbolizer.simpleStretch(g.fromJSON(e2.srcPixelBlock), e2.stretchParams);
    return Promise.resolve(r(t) && t.toJSON());
  }
  estimateStatisticsHistograms(r2) {
    const e2 = p(g.fromJSON(r2.srcPixelBlock));
    return Promise.resolve(e2);
  }
  split(r2) {
    const e2 = W(g.fromJSON(r2.srcPixelBlock), r2.tileSize, r2.maximumPyramidLevel);
    return e2 && e2.forEach((r3, t) => {
      e2.set(t, r3 == null ? void 0 : r3.toJSON());
    }), Promise.resolve(e2);
  }
  async mosaicAndTransform(r2) {
    const t = r2.srcPixelBlocks.map((r3) => r3 ? new g(r3) : null), o = T(t, r2.srcMosaicSize, { blockWidths: r2.blockWidths, alignmentInfo: r2.alignmentInfo, clipOffset: r2.clipOffset, clipSize: r2.clipSize });
    let i2, l2 = o;
    return r2.coefs && (l2 = D(o, r2.destDimension, r2.coefs, r2.sampleSpacing, r2.interpolation)), r2.projectDirections && r2.gcsGrid && (i2 = j(r2.destDimension, r2.gcsGrid), l2 = e(m(l2, r2.isUV ? "vector-uv" : "vector-magdir", i2))), { pixelBlock: l2 == null ? void 0 : l2.toJSON(), localNorthDirections: i2 };
  }
  async createFlowMesh(r2, e2) {
    const t = { data: new Float32Array(r2.flowData.buffer), mask: new Uint8Array(r2.flowData.maskBuffer), width: r2.flowData.width, height: r2.flowData.height }, { vertexData: s2, indexData: o } = await f(r2.meshType, r2.simulationSettings, t, e2.signal);
    return { result: { vertexBuffer: s2.buffer, indexBuffer: o.buffer }, transferList: [s2.buffer, o.buffer] };
  }
  async getProjectionOffsetGrid(r2) {
    const e2 = w.fromJSON(r2.projectedExtent), s2 = w.fromJSON(r2.srcBufferExtent);
    let o = null;
    r2.datumTransformationSteps && (o = new s({ steps: r2.datumTransformationSteps })), (r2.includeGCSGrid || M(e2.spatialReference, s2.spatialReference, o)) && await T3();
    const i2 = r2.rasterTransform ? i(r2.rasterTransform) : null;
    return $({ ...r2, projectedExtent: e2, srcBufferExtent: s2, datumTransformation: o, rasterTransform: i2 });
  }
};
export {
  N as default
};
//# sourceMappingURL=RasterWorker-ZLC4C4GY.js.map
