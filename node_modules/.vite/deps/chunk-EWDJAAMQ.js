import {
  a,
  g,
  x
} from "./chunk-4M35HEAB.js";
import {
  L as L2,
  M,
  O as O3,
  R,
  V,
  h as h2,
  j,
  k,
  v as v2
} from "./chunk-AQS2GDHU.js";
import {
  e2 as e5,
  r as r3,
  t as t3
} from "./chunk-C6HDWDWX.js";
import {
  T,
  i as i2
} from "./chunk-67RD6CZ4.js";
import {
  v
} from "./chunk-NGFMX3UT.js";
import {
  e as e3
} from "./chunk-XFDO4CMR.js";
import {
  e as e4,
  o
} from "./chunk-IVLBGTXL.js";
import {
  e as e2
} from "./chunk-GHN7C53L.js";
import {
  g as g2
} from "./chunk-ZNRXLY4R.js";
import {
  Zn,
  xn
} from "./chunk-FFVIDMFN.js";
import {
  B,
  C,
  P,
  h,
  i,
  u
} from "./chunk-RT3T2K4S.js";
import {
  $,
  E2 as E,
  L,
  O as O2
} from "./chunk-WJCI2CGX.js";
import {
  F,
  O
} from "./chunk-3LR5O4WA.js";
import {
  n,
  r as r2,
  t as t2
} from "./chunk-D4V6J5BT.js";
import {
  w
} from "./chunk-UWG37XSU.js";
import {
  l
} from "./chunk-7QMMKGW4.js";
import {
  e,
  n2,
  y
} from "./chunk-OOLCFNXJ.js";
import {
  r,
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/geometry/support/MeshTransform.js
var T2;
var q = T2 = class extends l {
  constructor(r5) {
    super(r5), this.origin = n(), this.translation = n(), this.rotation = a(), this.scale = r2(1, 1, 1), this.geographic = true;
  }
  get localMatrix() {
    const r5 = e4();
    return v(B2, g(this.rotation), x(this.rotation)), P(r5, B2, this.translation, this.scale), r5;
  }
  get localMatrixInverse() {
    return h(e4(), this.localMatrix);
  }
  applyLocal(r5, o2) {
    return O(o2, r5, this.localMatrix);
  }
  applyLocalInverse(r5, o2) {
    return O(o2, r5, this.localMatrixInverse);
  }
  project(r5, o2) {
    const t4 = new Float64Array(r5.length), s = T.fromTypedArray(t4), e6 = T.fromTypedArray(r5);
    if (this.geographic) {
      const r6 = O2(o2), i4 = e4();
      return Zn(o2, this.origin, i4, r6), u(i4, i4, this.localMatrix), t3(s, e6, i4), xn(t4, r6, 0, t4, o2, 0, t4.length / 3), t4;
    }
    const { localMatrix: i3, origin: a2 } = this;
    C(i3, o) ? e5(s, e6) : t3(s, e6, i3);
    for (let n3 = 0; n3 < t4.length; n3 += 3)
      t4[n3 + 0] += a2[0], t4[n3 + 1] += a2[1], t4[n3 + 2] += a2[2];
    return t4;
  }
  getOriginPoint(r5) {
    const [o2, t4, s] = this.origin;
    return new w({ x: o2, y: t4, z: s, spatialReference: r5 });
  }
  equals(r5) {
    return r(r5) && this.geographic === r5.geographic && F(this.origin, r5.origin) && B(this.localMatrix, r5.localMatrix);
  }
  clone() {
    const r5 = { origin: t2(this.origin), translation: t2(this.translation), rotation: a(this.rotation), scale: t2(this.scale), geographic: this.geographic };
    return new T2(r5);
  }
};
e([y({ type: [Number], nonNullable: true, json: { write: true } })], q.prototype, "origin", void 0), e([y({ type: [Number], nonNullable: true, json: { write: true } })], q.prototype, "translation", void 0), e([y({ type: [Number], nonNullable: true, json: { write: true } })], q.prototype, "rotation", void 0), e([y({ type: [Number], nonNullable: true, json: { write: true } })], q.prototype, "scale", void 0), e([y({ type: Boolean, nonNullable: true, json: { write: true } })], q.prototype, "geographic", void 0), e([y()], q.prototype, "localMatrix", null), e([y()], q.prototype, "localMatrixInverse", null), q = T2 = e([n2("esri.geometry.support.MeshTransform")], q);
var B2 = e3();
var L3 = q;

// node_modules/@arcgis/core/geometry/support/meshUtils/geographicUtils.js
function r4(r5, e6) {
  var _a;
  return r5.isGeographic || r5.isWebMercator && ((_a = e6 == null ? void 0 : e6.geographic) != null ? _a : true);
}

// node_modules/@arcgis/core/geometry/support/meshUtils/georeference.js
function x2(n3, r5, t4) {
  return r4(r5.spatialReference, t4) ? B3(n3, r5, t4) : P2(n3, r5, t4);
}
function k2(t4, o2, e6) {
  const { position: a2, normal: i3, tangent: l2 } = t4;
  if (t(o2))
    return { position: a2, normal: i3, tangent: l2 };
  const s = o2.localMatrix;
  return x2({ position: R(a2, new Float64Array(a2.length), s), normal: r(i3) ? v2(i3, new Float32Array(i3.length), s) : null, tangent: r(l2) ? V(l2, new Float32Array(l2.length), s) : null }, o2.getOriginPoint(e6), { geographic: o2.geographic });
}
function _(n3, r5, t4) {
  var _a;
  if (t4 == null ? void 0 : t4.useTransform) {
    const { position: o2, normal: e6, tangent: a2 } = n3;
    return { vertexAttributes: { position: o2, normal: e6, tangent: a2 }, transform: new L3({ origin: [r5.x, r5.y, (_a = r5.z) != null ? _a : 0], geographic: r4(r5.spatialReference, t4) }) };
  }
  return { vertexAttributes: x2(n3, r5, t4), transform: null };
}
function b(n3, r5, t4) {
  return r4(r5.spatialReference, t4) ? G(n3, r5, t4) : Y(n3, r5, t4);
}
function M2(r5, t4, o2, e6) {
  if (t(t4))
    return b(r5, o2, e6);
  const a2 = k2(r5, t4, o2.spatialReference);
  return o2.equals(t4.getOriginPoint(o2.spatialReference)) ? Y(a2, o2, e6) : r4(o2.spatialReference, e6) ? G(a2, o2, e6) : Y(a2, o2, e6);
}
function P2(n3, r5, t4) {
  const o2 = new Float64Array(n3.position.length), e6 = n3.position, a2 = r5.x, i3 = r5.y, l2 = r5.z || 0, { horizontal: s, vertical: f } = C2(t4 ? t4.unit : null, r5.spatialReference);
  for (let c = 0; c < e6.length; c += 3)
    o2[c + 0] = e6[c + 0] * s + a2, o2[c + 1] = e6[c + 1] * s + i3, o2[c + 2] = e6[c + 2] * f + l2;
  return { position: o2, normal: n3.normal, tangent: n3.tangent };
}
function B3(n3, r5, t4) {
  const o2 = r5.spatialReference, e6 = O4(r5, t4, D), a2 = new Float64Array(n3.position.length), i3 = L4(n3.position, e6, o2, a2), l2 = g2(I, e6);
  return { position: i3, normal: N(i3, a2, n3.normal, l2, o2), tangent: S(i3, a2, n3.tangent, l2, o2) };
}
function L4(n3, r5, t4, o2) {
  t3(T.fromTypedArray(o2), T.fromTypedArray(n3), r5);
  const e6 = new Float64Array(n3.length);
  return O3(o2, e6, t4);
}
function N(r5, t4, o2, e6, a2) {
  if (t(o2))
    return null;
  const i3 = new Float32Array(o2.length);
  return r3(i2.fromTypedArray(i3), i2.fromTypedArray(o2), e6), h2(i3, r5, t4, a2, i3), i3;
}
function S(r5, t4, o2, e6, a2) {
  if (t(o2))
    return null;
  const i3 = new Float32Array(o2.length);
  r3(i2.fromTypedArray(i3, 4 * Float32Array.BYTES_PER_ELEMENT), i2.fromTypedArray(o2, 4 * Float32Array.BYTES_PER_ELEMENT), e6);
  for (let n3 = 3; n3 < i3.length; n3 += 4)
    i3[n3] = o2[n3];
  return L2(i3, r5, t4, a2, i3), i3;
}
function Y(n3, r5, t4) {
  const o2 = new Float64Array(n3.position.length), e6 = n3.position, a2 = r5.x, i3 = r5.y, l2 = r5.z || 0, { horizontal: s, vertical: f } = C2(t4 ? t4.unit : null, r5.spatialReference);
  for (let c = 0; c < e6.length; c += 3)
    o2[c + 0] = (e6[c + 0] - a2) / s, o2[c + 1] = (e6[c + 1] - i3) / s, o2[c + 2] = (e6[c + 2] - l2) / f;
  return { position: o2, normal: n3.normal, tangent: n3.tangent };
}
function G(n3, r5, t4) {
  const o2 = r5.spatialReference;
  O4(r5, t4, D);
  const e6 = h(H, D), a2 = new Float64Array(n3.position.length), l2 = U(n3.position, o2, e6, a2), s = g2(I, e6);
  return { position: l2, normal: q2(n3.normal, n3.position, a2, o2, s), tangent: V2(n3.tangent, n3.position, a2, o2, s) };
}
function O4(n3, r5, t4) {
  Zn(n3.spatialReference, [n3.x, n3.y, n3.z || 0], t4, O2(n3.spatialReference));
  const { horizontal: o2, vertical: e6 } = C2(r5 ? r5.unit : null, n3.spatialReference);
  return i(t4, t4, [o2, o2, e6]), t4;
}
function U(n3, r5, t4, o2) {
  const e6 = M(n3, r5, o2), a2 = T.fromTypedArray(e6), i3 = new Float64Array(e6.length), l2 = T.fromTypedArray(i3);
  return t3(l2, a2, t4), i3;
}
function q2(r5, t4, o2, e6, a2) {
  if (t(r5))
    return null;
  const i3 = j(r5, t4, o2, e6, new Float32Array(r5.length)), l2 = i2.fromTypedArray(i3);
  return r3(l2, l2, a2), i3;
}
function V2(r5, t4, o2, e6, a2) {
  if (t(r5))
    return null;
  const i3 = k(r5, t4, o2, e6, new Float32Array(r5.length)), l2 = i2.fromTypedArray(i3, 4 * Float32Array.BYTES_PER_ELEMENT);
  return r3(l2, l2, a2), i3;
}
function C2(r5, a2) {
  if (t(r5))
    return J;
  const i3 = a2.isGeographic ? 1 : $(a2), l2 = a2.isGeographic ? 1 : L(a2), s = E(1, r5, "meters");
  return { horizontal: s * i3, vertical: s * l2 };
}
var D = e4();
var H = e4();
var I = e2();
var J = { horizontal: 1, vertical: 1 };

export {
  L3 as L,
  r4 as r,
  x2 as x,
  k2 as k,
  _,
  b,
  M2 as M
};
//# sourceMappingURL=chunk-EWDJAAMQ.js.map
