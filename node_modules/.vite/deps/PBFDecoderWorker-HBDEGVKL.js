import {
  N,
  j
} from "./chunk-IJUE2JUP.js";
import "./chunk-I4YZGF7W.js";
import "./chunk-OJ2HHY2O.js";
import {
  t as t2
} from "./chunk-HKYKZCGY.js";
import "./chunk-5MBCFCGH.js";
import {
  pt,
  rt
} from "./chunk-TJ2I6XQT.js";
import "./chunk-EDHROVWI.js";
import "./chunk-34YPGGJT.js";
import {
  y
} from "./chunk-GLGOVVCK.js";
import "./chunk-BUVDI6S7.js";
import {
  n
} from "./chunk-O6VYMEIX.js";
import {
  o
} from "./chunk-ZWUEORSX.js";
import "./chunk-WJCI2CGX.js";
import "./chunk-XMZAPOBR.js";
import "./chunk-NAN5J6QS.js";
import "./chunk-6M2AHKYV.js";
import "./chunk-C5H57NTD.js";
import "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import "./chunk-B356PXLT.js";
import "./chunk-EHPBHJYZ.js";
import "./chunk-3MNMDUQZ.js";
import "./chunk-UWG37XSU.js";
import {
  k2 as k
} from "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import "./chunk-HLM6QCL2.js";
import "./chunk-RXYULINL.js";
import "./chunk-VWYWOOPX.js";
import "./chunk-M5VHU5LK.js";
import "./chunk-7QMMKGW4.js";
import {
  e4 as e
} from "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import "./chunk-MJXQTGI2.js";
import "./chunk-LIZHLHNA.js";
import "./chunk-BTUHYGXO.js";
import "./chunk-UA3YPL2R.js";
import "./chunk-HVKDYDPP.js";
import "./chunk-6QC7MLLS.js";
import {
  t
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/rest/query/operations/pbfDehydratedFeatureSet.js
function u(t4, e2) {
  return e2;
}
function p(t4, e2, r, s2) {
  switch (r) {
    case 0:
      return m(t4, e2 + s2, 0);
    case 1:
      return "lowerLeft" === t4.originPosition ? m(t4, e2 + s2, 1) : y2(t4, e2 + s2, 1);
  }
}
function c(t4, e2, r, s2) {
  return 2 === r ? m(t4, e2, 2) : p(t4, e2, r, s2);
}
function d(t4, e2, r, s2) {
  return 2 === r ? m(t4, e2, 3) : p(t4, e2, r, s2);
}
function f(t4, e2, r, s2) {
  return 3 === r ? m(t4, e2, 3) : c(t4, e2, r, s2);
}
function m({ translate: t4, scale: e2 }, r, s2) {
  return t4[s2] + r * e2[s2];
}
function y2({ translate: t4, scale: e2 }, r, s2) {
  return t4[s2] - r * e2[s2];
}
var _ = class {
  constructor(t4) {
    this._options = t4, this.geometryTypes = ["point", "multipoint", "polyline", "polygon"], this._previousCoordinate = [0, 0], this._transform = null, this._applyTransform = u, this._lengths = [], this._currentLengthIndex = 0, this._toAddInCurrentPath = 0, this._vertexDimension = 0, this._coordinateBuffer = null, this._coordinateBufferPtr = 0, this._attributesConstructor = class {
    };
  }
  createFeatureResult() {
    return new N();
  }
  finishFeatureResult(t4) {
    if (this._options.applyTransform && (t4.transform = null), this._attributesConstructor = class {
    }, this._coordinateBuffer = null, this._lengths.length = 0, !t4.hasZ)
      return;
    const r = o(t4.geometryType, this._options.sourceSpatialReference, t4.spatialReference);
    if (!t(r))
      for (const e2 of t4.features)
        r(e2.geometry);
  }
  createSpatialReference() {
    return new k();
  }
  addField(t4, e2) {
    t4.fields.push(y.fromJSON(e2));
    const r = t4.fields.map((t5) => t5.name);
    this._attributesConstructor = function() {
      for (const t5 of r)
        this[t5] = null;
    };
  }
  addFeature(t4, e2) {
    const r = this._options.maxStringAttributeLength ? this._options.maxStringAttributeLength : 0;
    if (r > 0)
      for (const s2 in e2.attributes) {
        const t5 = e2.attributes[s2];
        "string" == typeof t5 && t5.length > r && (e2.attributes[s2] = "");
      }
    t4.features.push(e2);
  }
  addQueryGeometry(t4, e2) {
    const { queryGeometry: r, queryGeometryType: s2 } = e2, o2 = pt(r.clone(), r, false, false, this._transform), i = rt(o2, s2, false, false);
    let n2 = null;
    switch (s2) {
      case "esriGeometryPoint":
        n2 = "point";
        break;
      case "esriGeometryPolygon":
        n2 = "polygon";
        break;
      case "esriGeometryPolyline":
        n2 = "polyline";
        break;
      case "esriGeometryMultipoint":
        n2 = "multipoint";
    }
    i.type = n2, t4.queryGeometryType = s2, t4.queryGeometry = i;
  }
  prepareFeatures(e2) {
    switch (this._transform = e2.transform, this._options.applyTransform && e2.transform && (this._applyTransform = this._deriveApplyTransform(e2)), this._vertexDimension = 2, e2.hasZ && this._vertexDimension++, e2.hasM && this._vertexDimension++, e2.geometryType) {
      case "point":
        this.addCoordinate = (t4, e3, r) => this.addCoordinatePoint(t4, e3, r), this.createGeometry = (t4) => this.createPointGeometry(t4);
        break;
      case "polygon":
        this.addCoordinate = (t4, e3, r) => this._addCoordinatePolygon(t4, e3, r), this.createGeometry = (t4) => this._createPolygonGeometry(t4);
        break;
      case "polyline":
        this.addCoordinate = (t4, e3, r) => this._addCoordinatePolyline(t4, e3, r), this.createGeometry = (t4) => this._createPolylineGeometry(t4);
        break;
      case "multipoint":
        this.addCoordinate = (t4, e3, r) => this._addCoordinateMultipoint(t4, e3, r), this.createGeometry = (t4) => this._createMultipointGeometry(t4);
        break;
      case "mesh":
      case "extent":
        break;
      default:
        n(e2.geometryType);
    }
  }
  createFeature() {
    return this._lengths.length = 0, this._currentLengthIndex = 0, this._previousCoordinate[0] = 0, this._previousCoordinate[1] = 0, new j(e(), null, new this._attributesConstructor());
  }
  allocateCoordinates() {
    const t4 = this._lengths.reduce((t5, e2) => t5 + e2, 0);
    this._coordinateBuffer = new Float64Array(t4 * this._vertexDimension), this._coordinateBufferPtr = 0;
  }
  addLength(t4, e2, r) {
    0 === this._lengths.length && (this._toAddInCurrentPath = e2), this._lengths.push(e2);
  }
  createPointGeometry(t4) {
    const e2 = { type: "point", x: 0, y: 0, spatialReference: t4.spatialReference, hasZ: !!t4.hasZ, hasM: !!t4.hasM };
    return e2.hasZ && (e2.z = 0), e2.hasM && (e2.m = 0), e2;
  }
  addCoordinatePoint(t4, e2, r) {
    switch (e2 = this._applyTransform(this._transform, e2, r, 0), r) {
      case 0:
        t4.x = e2;
        break;
      case 1:
        t4.y = e2;
        break;
      case 2:
        t4.hasZ ? t4.z = e2 : t4.m = e2;
        break;
      case 3:
        t4.m = e2;
    }
  }
  _transformPathLikeValue(t4, e2) {
    let r = 0;
    return e2 <= 1 && (r = this._previousCoordinate[e2], this._previousCoordinate[e2] += t4), this._applyTransform(this._transform, t4, e2, r);
  }
  _addCoordinatePolyline(t4, e2, r) {
    this._dehydratedAddPointsCoordinate(t4.paths, e2, r);
  }
  _addCoordinatePolygon(t4, e2, r) {
    this._dehydratedAddPointsCoordinate(t4.rings, e2, r);
  }
  _addCoordinateMultipoint(t4, e2, r) {
    0 === r && t4.points.push([]);
    const s2 = this._transformPathLikeValue(e2, r);
    t4.points[t4.points.length - 1].push(s2);
  }
  _createPolygonGeometry(t4) {
    return { type: "polygon", rings: [[]], spatialReference: t4.spatialReference, hasZ: !!t4.hasZ, hasM: !!t4.hasM };
  }
  _createPolylineGeometry(t4) {
    return { type: "polyline", paths: [[]], spatialReference: t4.spatialReference, hasZ: !!t4.hasZ, hasM: !!t4.hasM };
  }
  _createMultipointGeometry(t4) {
    return { type: "multipoint", points: [], spatialReference: t4.spatialReference, hasZ: !!t4.hasZ, hasM: !!t4.hasM };
  }
  _dehydratedAddPointsCoordinate(t4, e2, r) {
    0 === r && 0 == this._toAddInCurrentPath-- && (t4.push([]), this._toAddInCurrentPath = this._lengths[++this._currentLengthIndex] - 1, this._previousCoordinate[0] = 0, this._previousCoordinate[1] = 0);
    const s2 = this._transformPathLikeValue(e2, r), o2 = t4[t4.length - 1];
    0 === r && o2.push(new Float64Array(this._coordinateBuffer.buffer, this._coordinateBufferPtr * Float64Array.BYTES_PER_ELEMENT, this._vertexDimension)), this._coordinateBuffer[this._coordinateBufferPtr++] = s2;
  }
  _deriveApplyTransform(t4) {
    const { hasZ: e2, hasM: r } = t4;
    return e2 && r ? f : e2 ? c : r ? d : p;
  }
};

// node_modules/@arcgis/core/views/3d/support/PBFDecoderWorker.js
var t3 = class {
  _parseFeatureQuery(t4) {
    const s2 = t2(t4.buffer, new _(t4.options)), o2 = { ...s2, spatialReference: s2.spatialReference.toJSON(), fields: s2.fields ? s2.fields.map((e2) => e2.toJSON()) : void 0 };
    return Promise.resolve(o2);
  }
};
function s() {
  return new t3();
}
export {
  s as default
};
//# sourceMappingURL=PBFDecoderWorker-HBDEGVKL.js.map
