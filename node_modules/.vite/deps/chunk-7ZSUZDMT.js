import {
  w
} from "./chunk-QB3YZMAB.js";
import {
  e as e6,
  r as r3
} from "./chunk-HNRPDSCT.js";
import {
  a,
  t as t3
} from "./chunk-D2XA6Z6P.js";
import {
  R
} from "./chunk-FCIHN4UG.js";
import {
  n as n4
} from "./chunk-A22ACVMF.js";
import {
  O as O2
} from "./chunk-RUM3DXFX.js";
import {
  n as n3,
  u as u4
} from "./chunk-5ZAWCTS6.js";
import {
  I,
  O
} from "./chunk-3OFVLRSL.js";
import {
  c,
  i,
  u as u3,
  x
} from "./chunk-67RD6CZ4.js";
import {
  S
} from "./chunk-NGFMX3UT.js";
import {
  e as e3
} from "./chunk-XFDO4CMR.js";
import {
  e as e4
} from "./chunk-IVLBGTXL.js";
import {
  e as e2
} from "./chunk-GHN7C53L.js";
import {
  y
} from "./chunk-ZNRXLY4R.js";
import {
  e as e5
} from "./chunk-EGV5SNBD.js";
import {
  G,
  h,
  n as n2,
  o as o2,
  u as u2
} from "./chunk-RT3T2K4S.js";
import {
  A,
  E,
  U,
  e,
  g,
  o,
  p,
  u
} from "./chunk-3LR5O4WA.js";
import {
  n,
  r as r2,
  t as t2
} from "./chunk-D4V6J5BT.js";
import {
  l
} from "./chunk-OOLCFNXJ.js";
import {
  r,
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/BoundingInfo.js
var a2 = class {
  constructor(i4, s2, a4, c4) {
    this.primitiveIndices = i4, this._numIndexPerPrimitive = s2, this.indices = a4, this.position = c4, this.center = n(), this._children = void 0, e5(i4.length >= 1), e5(a4.length % this._numIndexPerPrimitive == 0), e5(a4.length >= i4.length * this._numIndexPerPrimitive), e5(3 === c4.size || 4 === c4.size);
    const { data: o4, size: d4 } = c4, l5 = i4.length;
    let M2 = d4 * a4[this._numIndexPerPrimitive * i4[0]];
    b.clear(), b.push(M2), this.bbMin = r2(o4[M2], o4[M2 + 1], o4[M2 + 2]), this.bbMax = t2(this.bbMin);
    for (let t4 = 0; t4 < l5; ++t4) {
      const s3 = this._numIndexPerPrimitive * i4[t4];
      for (let i5 = 0; i5 < this._numIndexPerPrimitive; ++i5) {
        M2 = d4 * a4[s3 + i5], b.push(M2);
        let t5 = o4[M2];
        this.bbMin[0] = Math.min(t5, this.bbMin[0]), this.bbMax[0] = Math.max(t5, this.bbMax[0]), t5 = o4[M2 + 1], this.bbMin[1] = Math.min(t5, this.bbMin[1]), this.bbMax[1] = Math.max(t5, this.bbMax[1]), t5 = o4[M2 + 2], this.bbMin[2] = Math.min(t5, this.bbMin[2]), this.bbMax[2] = Math.max(t5, this.bbMax[2]);
      }
    }
    A(this.center, this.bbMin, this.bbMax, 0.5), this.radius = 0.5 * Math.max(Math.max(this.bbMax[0] - this.bbMin[0], this.bbMax[1] - this.bbMin[1]), this.bbMax[2] - this.bbMin[2]);
    let m3 = this.radius * this.radius;
    for (let t4 = 0; t4 < b.length; ++t4) {
      M2 = b.getItemAt(t4);
      const i5 = o4[M2] - this.center[0], s3 = o4[M2 + 1] - this.center[1], e8 = o4[M2 + 2] - this.center[2], n5 = i5 * i5 + s3 * s3 + e8 * e8;
      if (n5 <= m3)
        continue;
      const r4 = Math.sqrt(n5), h3 = 0.5 * (r4 - this.radius);
      this.radius = this.radius + h3, m3 = this.radius * this.radius;
      const a5 = h3 / r4;
      this.center[0] += i5 * a5, this.center[1] += s3 * a5, this.center[2] += e8 * a5;
    }
    b.clear();
  }
  getCenter() {
    return this.center;
  }
  getBSRadius() {
    return this.radius;
  }
  getBBMin() {
    return this.bbMin;
  }
  getBBMax() {
    return this.bbMax;
  }
  getChildren() {
    if (this._children)
      return this._children;
    if (p(this.bbMin, this.bbMax) > 1) {
      const i4 = A(n(), this.bbMin, this.bbMax, 0.5), s2 = this.primitiveIndices.length, n5 = new Uint8Array(s2), r4 = new Array(8);
      for (let t4 = 0; t4 < 8; ++t4)
        r4[t4] = 0;
      const { data: h3, size: b3 } = this.position;
      for (let t4 = 0; t4 < s2; ++t4) {
        let s3 = 0;
        const e8 = this._numIndexPerPrimitive * this.primitiveIndices[t4];
        let a4 = b3 * this.indices[e8], c5 = h3[a4], o5 = h3[a4 + 1], d4 = h3[a4 + 2];
        for (let i5 = 1; i5 < this._numIndexPerPrimitive; ++i5) {
          a4 = b3 * this.indices[e8 + i5];
          const t5 = h3[a4], s4 = h3[a4 + 1], n6 = h3[a4 + 2];
          t5 < c5 && (c5 = t5), s4 < o5 && (o5 = s4), n6 < d4 && (d4 = n6);
        }
        c5 < i4[0] && (s3 |= 1), o5 < i4[1] && (s3 |= 2), d4 < i4[2] && (s3 |= 4), n5[t4] = s3, ++r4[s3];
      }
      let c4 = 0;
      for (let t4 = 0; t4 < 8; ++t4)
        r4[t4] > 0 && ++c4;
      if (c4 < 2)
        return;
      const o4 = new Array(8);
      for (let t4 = 0; t4 < 8; ++t4)
        o4[t4] = r4[t4] > 0 ? new Uint32Array(r4[t4]) : void 0;
      for (let t4 = 0; t4 < 8; ++t4)
        r4[t4] = 0;
      for (let t4 = 0; t4 < s2; ++t4) {
        const i5 = n5[t4];
        o4[i5][r4[i5]++] = this.primitiveIndices[t4];
      }
      this._children = new Array(8);
      for (let t4 = 0; t4 < 8; ++t4)
        void 0 !== o4[t4] && (this._children[t4] = new a2(o4[t4], this._numIndexPerPrimitive, this.indices, this.position));
    }
    return this._children;
  }
  static prune() {
    b.prune();
  }
};
var b = new l({ deallocator: null });

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/geometryDataUtils.js
function c2(o4, r4, c4) {
  if (!o4 || !r4)
    return false;
  const { size: a4, data: f3 } = o4;
  o(c4, 0, 0, 0), o(g2, 0, 0, 0);
  let m3 = 0, h3 = 0;
  for (let p2 = 0; p2 < r4.length - 2; p2 += 3) {
    const o5 = r4[p2 + 0] * a4, j = r4[p2 + 1] * a4, d4 = r4[p2 + 2] * a4;
    o(i2, f3[o5 + 0], f3[o5 + 1], f3[o5 + 2]), o(u5, f3[j + 0], f3[j + 1], f3[j + 2]), o(l2, f3[d4 + 0], f3[d4 + 1], f3[d4 + 2]);
    const z2 = w(i2, u5, l2);
    z2 ? (u(i2, i2, u5), u(i2, i2, l2), g(i2, i2, 1 / 3 * z2), u(c4, c4, i2), m3 += z2) : (u(g2, g2, i2), u(g2, g2, u5), u(g2, g2, l2), h3 += 3);
  }
  return (0 !== h3 || 0 !== m3) && (0 !== m3 ? (g(c4, c4, 1 / m3), true) : 0 !== h3 && (g(c4, g2, 1 / h3), true));
}
function a3(n5, o4, r4) {
  if (!n5 || !o4)
    return false;
  const { size: s2, data: c4 } = n5;
  o(r4, 0, 0, 0);
  let a4 = -1, f3 = 0;
  for (let t4 = 0; t4 < o4.length; t4++) {
    const n6 = o4[t4] * s2;
    a4 !== n6 && (r4[0] += c4[n6 + 0], r4[1] += c4[n6 + 1], r4[2] += c4[n6 + 2], f3++), a4 = n6;
  }
  return f3 > 1 && g(r4, r4, 1 / f3), f3 > 0;
}
function f(r4, s2, c4, a4) {
  if (!r4)
    return false;
  const { size: f3, data: l5 } = r4;
  o(a4, 0, 0, 0), o(g2, 0, 0, 0);
  let m3 = 0, h3 = 0;
  const p2 = s2 ? s2.length - 1 : l5.length / f3 - 1, j = p2 + (c4 ? 2 : 0);
  for (let t4 = 0; t4 < j; t4 += 2) {
    const r5 = t4 < p2 ? t4 : p2, c5 = t4 < p2 ? t4 + 1 : 0, j2 = (s2 ? s2[r5] : r5) * f3, d4 = (s2 ? s2[c5] : c5) * f3;
    i2[0] = l5[j2 + 0], i2[1] = l5[j2 + 1], i2[2] = l5[j2 + 2], u5[0] = l5[d4 + 0], u5[1] = l5[d4 + 1], u5[2] = l5[d4 + 2], g(i2, u(i2, i2, u5), 0.5);
    const z2 = U(i2, u5);
    z2 > 0 ? (u(a4, a4, g(i2, i2, z2)), m3 += z2) : (u(g2, g2, i2), h3++);
  }
  return 0 !== m3 ? (g(a4, a4, 1 / m3), true) : 0 !== h3 && (g(a4, g2, 1 / h3), true);
}
var i2 = n();
var u5 = n();
var l2 = n();
var g2 = n();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Geometry.js
var d = class extends r3 {
  constructor(t4, i4 = [], n5 = a.Triangle, r4 = null, o4 = -1) {
    super(), this._primitiveType = n5, this.objectAndLayerIdColor = r4, this.edgeIndicesLength = o4, this.type = e6.Geometry, this._vertexAttributes = /* @__PURE__ */ new Map(), this._indices = /* @__PURE__ */ new Map(), this._boundingInfo = null;
    for (const [e8, s2] of t4)
      s2 && this._vertexAttributes.set(e8, { ...s2 });
    if (null == i4 || 0 === i4.length) {
      const t5 = l3(this._vertexAttributes), e8 = u4(t5);
      this.edgeIndicesLength = this.edgeIndicesLength < 0 ? t5 : this.edgeIndicesLength;
      for (const i5 of this._vertexAttributes.keys())
        this._indices.set(i5, e8);
    } else
      for (const [e8, s2] of i4)
        s2 && (this._indices.set(e8, n3(s2)), e8 === O2.POSITION && (this.edgeIndicesLength = this.edgeIndicesLength < 0 ? this._indices.get(e8).length : this.edgeIndicesLength));
  }
  cloneShallow() {
    const t4 = new d([], void 0, this._primitiveType, this.objectAndLayerIdColor, void 0), { _vertexAttributes: e8, _indices: i4 } = t4;
    return this._vertexAttributes.forEach((t5, i5) => e8.set(i5, t5)), this._indices.forEach((t5, e9) => i4.set(e9, t5)), t4.screenToWorldRatio = this.screenToWorldRatio, t4._boundingInfo = this._boundingInfo, t4;
  }
  get vertexAttributes() {
    return this._vertexAttributes;
  }
  getMutableAttribute(t4) {
    const e8 = this._vertexAttributes.get(t4);
    return e8 && !e8.exclusive && (e8.data = Array.from(e8.data), e8.exclusive = true), e8;
  }
  get indices() {
    return this._indices;
  }
  get indexCount() {
    const t4 = this._indices.values().next().value;
    return t4 ? t4.length : 0;
  }
  get primitiveType() {
    return this._primitiveType;
  }
  get faceCount() {
    return this.indexCount / 3;
  }
  get boundingInfo() {
    return t(this._boundingInfo) && (this._boundingInfo = this._calculateBoundingInfo()), this._boundingInfo;
  }
  computeAttachmentOrigin(t4) {
    return this.primitiveType === a.Triangle ? this._computeAttachmentOriginTriangles(t4) : this._computeAttachmentOriginPoints(t4);
  }
  _computeAttachmentOriginTriangles(t4) {
    const e8 = this.indices.get(O2.POSITION), i4 = this.vertexAttributes.get(O2.POSITION);
    return c2(i4, e8, t4);
  }
  _computeAttachmentOriginPoints(t4) {
    const e8 = this.indices.get(O2.POSITION), i4 = this.vertexAttributes.get(O2.POSITION);
    return a3(i4, e8, t4);
  }
  invalidateBoundingInfo() {
    this._boundingInfo = null;
  }
  _calculateBoundingInfo() {
    const t4 = this.indices.get(O2.POSITION);
    if (!t4 || 0 === t4.length)
      return null;
    const n5 = this.primitiveType === a.Triangle ? 3 : 1;
    e5(t4.length % n5 == 0, "Indexing error: " + t4.length + " not divisible by " + n5);
    const s2 = u4(t4.length / n5), r4 = this.vertexAttributes.get(O2.POSITION);
    return r4 ? new a2(s2, n5, t4, r4) : null;
  }
};
function l3(t4) {
  const e8 = t4.values().next().value;
  return null == e8 ? 0 : e8.data.length / e8.size;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/RenderSlot.js
var E2;
!function(E3) {
  E3[E3.INTEGRATED_MESH = 0] = "INTEGRATED_MESH", E3[E3.OPAQUE_TERRAIN = 1] = "OPAQUE_TERRAIN", E3[E3.OPAQUE_MATERIAL = 2] = "OPAQUE_MATERIAL", E3[E3.TRANSPARENT_MATERIAL = 3] = "TRANSPARENT_MATERIAL", E3[E3.TRANSPARENT_TERRAIN = 4] = "TRANSPARENT_TERRAIN", E3[E3.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL = 5] = "TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL", E3[E3.OCCLUDED_TERRAIN = 6] = "OCCLUDED_TERRAIN", E3[E3.OCCLUDER_MATERIAL = 7] = "OCCLUDER_MATERIAL", E3[E3.TRANSPARENT_OCCLUDER_MATERIAL = 8] = "TRANSPARENT_OCCLUDER_MATERIAL", E3[E3.OCCLUSION_PIXELS = 9] = "OCCLUSION_PIXELS", E3[E3.POSTPROCESSING_ENVIRONMENT_OPAQUE = 10] = "POSTPROCESSING_ENVIRONMENT_OPAQUE", E3[E3.POSTPROCESSING_ENVIRONMENT_TRANSPARENT = 11] = "POSTPROCESSING_ENVIRONMENT_TRANSPARENT", E3[E3.LASERLINES = 12] = "LASERLINES", E3[E3.LASERLINES_CONTRAST_CONTROL = 13] = "LASERLINES_CONTRAST_CONTROL", E3[E3.HUD_MATERIAL = 14] = "HUD_MATERIAL", E3[E3.LABEL_MATERIAL = 15] = "LABEL_MATERIAL", E3[E3.LINE_CALLOUTS = 16] = "LINE_CALLOUTS", E3[E3.LINE_CALLOUTS_HUD_DEPTH = 17] = "LINE_CALLOUTS_HUD_DEPTH", E3[E3.DRAPED_MATERIAL = 18] = "DRAPED_MATERIAL", E3[E3.DRAPED_WATER = 19] = "DRAPED_WATER", E3[E3.VOXEL = 20] = "VOXEL", E3[E3.MAX_SLOTS = 21] = "MAX_SLOTS";
}(E2 || (E2 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/verticalOffsetUtils.js
var u6 = class {
  constructor() {
    this._transform = e4(), this._transformInverse = new M({ value: this._transform }, h, e4), this._transformInverseTranspose = new M(this._transformInverse, o2, e4), this._transformTranspose = new M({ value: this._transform }, o2, e4), this._transformInverseRotation = new M({ value: this._transform }, y, e2);
  }
  _invalidateLazyTransforms() {
    this._transformInverse.invalidate(), this._transformInverseTranspose.invalidate(), this._transformTranspose.invalidate(), this._transformInverseRotation.invalidate();
  }
  get transform() {
    return this._transform;
  }
  get inverse() {
    return this._transformInverse.value;
  }
  get inverseTranspose() {
    return this._transformInverseTranspose.value;
  }
  get inverseRotation() {
    return this._transformInverseRotation.value;
  }
  get transpose() {
    return this._transformTranspose.value;
  }
  setTransformMatrix(t4) {
    n2(this._transform, t4);
  }
  multiplyTransform(t4) {
    u2(this._transform, this._transform, t4);
  }
  set(t4) {
    n2(this._transform, t4), this._invalidateLazyTransforms();
  }
  setAndInvalidateLazyTransforms(t4, s2) {
    this.setTransformMatrix(t4), this.multiplyTransform(s2), this._invalidateLazyTransforms();
  }
};
var M = class {
  constructor(t4, s2, e8) {
    this._original = t4, this._update = s2, this._dirty = true, this._transform = e8();
  }
  invalidate() {
    this._dirty = true;
  }
  get value() {
    return this._dirty && (this._update(this._transform, this._original.value), this._dirty = false), this._transform;
  }
};
var v = class {
  constructor(t4 = 0) {
    this.offset = t4, this.tmpVertex = n();
  }
  applyToVertex(t4, s2, e8) {
    const i4 = t4 + this.localOrigin[0], r4 = s2 + this.localOrigin[1], a4 = e8 + this.localOrigin[2], o4 = this.offset / Math.sqrt(i4 * i4 + r4 * r4 + a4 * a4);
    return this.tmpVertex[0] = t4 + i4 * o4, this.tmpVertex[1] = s2 + r4 * o4, this.tmpVertex[2] = e8 + a4 * o4, this.tmpVertex;
  }
  applyToAabb(t4) {
    for (let r4 = 0; r4 < 3; ++r4)
      O3[r4] = t4[0 + r4] + this.localOrigin[r4], z[r4] = t4[3 + r4] + this.localOrigin[r4], T[r4] = O3[r4];
    const s2 = this.applyToVertex(O3[0], O3[1], O3[2]);
    for (let r4 = 0; r4 < 3; ++r4)
      t4[r4] = s2[r4], t4[r4 + 3] = s2[r4];
    const e8 = (s3) => {
      const e9 = this.applyToVertex(s3[0], s3[1], s3[2]);
      for (let i5 = 0; i5 < 3; ++i5)
        t4[i5 + 0] = Math.min(t4[i5 + 0], e9[i5]), t4[i5 + 3] = Math.max(t4[i5 + 3], e9[i5]);
    };
    for (let r4 = 1; r4 < 8; ++r4) {
      for (let t5 = 0; t5 < 3; ++t5)
        T[t5] = 0 == (r4 & 1 << t5) ? O3[t5] : z[t5];
      e8(T);
    }
    let i4 = 0;
    for (let r4 = 0; r4 < 3; ++r4) {
      O3[r4] * z[r4] < 0 && (i4 |= 1 << r4);
    }
    if (0 !== i4 && 7 !== i4) {
      for (let r4 = 0; r4 < 8; ++r4)
        if (0 == (i4 & r4)) {
          for (let t5 = 0; t5 < 3; ++t5)
            i4[t5] ? T[t5] = 0 : T[t5] = 0 != (r4 & 1 << t5) ? O3[t5] : z[t5];
          e8(T);
        }
    }
    for (let r4 = 0; r4 < 3; ++r4)
      t4[r4 + 0] -= this.localOrigin[r4], t4[r4 + 3] -= this.localOrigin[r4];
    return t4;
  }
};
var O3 = n();
var z = n();
var T = n();
var g3 = class {
  constructor(t4 = 0) {
    this.componentLocalOriginLength = 0, this._tmpVertex = n(), this._mbs = R(), this._obb = { center: n(), halfSize: n4(), quaternion: null }, this._totalOffset = 0, this._offset = 0, this._resetOffset(t4);
  }
  _resetOffset(t4) {
    this._offset = t4, this._totalOffset = t4;
  }
  set offset(t4) {
    this._resetOffset(t4);
  }
  get offset() {
    return this._offset;
  }
  set componentOffset(t4) {
    this._totalOffset = this._offset + t4;
  }
  set localOrigin(t4) {
    this.componentLocalOriginLength = Math.sqrt(t4[0] * t4[0] + t4[1] * t4[1] + t4[2] * t4[2]);
  }
  applyToVertex(t4, s2, e8) {
    const i4 = t4, r4 = s2, a4 = e8 + this.componentLocalOriginLength, o4 = this._totalOffset / Math.sqrt(i4 * i4 + r4 * r4 + a4 * a4);
    return this._tmpVertex[0] = t4 + i4 * o4, this._tmpVertex[1] = s2 + r4 * o4, this._tmpVertex[2] = e8 + a4 * o4, this._tmpVertex;
  }
  applyToAabb(t4) {
    const s2 = t4[0], e8 = t4[1], i4 = t4[2] + this.componentLocalOriginLength, r4 = t4[3], a4 = t4[4], o4 = t4[5] + this.componentLocalOriginLength, h3 = s2 * r4 < 0 ? 0 : Math.min(Math.abs(s2), Math.abs(r4)), n5 = e8 * a4 < 0 ? 0 : Math.min(Math.abs(e8), Math.abs(a4)), f3 = i4 * o4 < 0 ? 0 : Math.min(Math.abs(i4), Math.abs(o4)), l5 = Math.sqrt(h3 * h3 + n5 * n5 + f3 * f3);
    if (l5 < this._totalOffset)
      return t4[0] -= s2 < 0 ? this._totalOffset : 0, t4[1] -= e8 < 0 ? this._totalOffset : 0, t4[2] -= i4 < 0 ? this._totalOffset : 0, t4[3] += r4 > 0 ? this._totalOffset : 0, t4[4] += a4 > 0 ? this._totalOffset : 0, t4[5] += o4 > 0 ? this._totalOffset : 0, t4;
    const m3 = Math.max(Math.abs(s2), Math.abs(r4)), _ = Math.max(Math.abs(e8), Math.abs(a4)), b3 = Math.max(Math.abs(i4), Math.abs(o4)), c4 = Math.sqrt(m3 * m3 + _ * _ + b3 * b3), p2 = this._totalOffset / c4, u8 = this._totalOffset / l5;
    return t4[0] += s2 * (s2 > 0 ? p2 : u8), t4[1] += e8 * (e8 > 0 ? p2 : u8), t4[2] += i4 * (i4 > 0 ? p2 : u8), t4[3] += r4 * (r4 < 0 ? p2 : u8), t4[4] += a4 * (a4 < 0 ? p2 : u8), t4[5] += o4 * (o4 < 0 ? p2 : u8), t4;
  }
  applyToMbs(t4) {
    const s2 = Math.sqrt(t4[0] * t4[0] + t4[1] * t4[1] + t4[2] * t4[2]), e8 = this._totalOffset / s2;
    return this._mbs[0] = t4[0] + t4[0] * e8, this._mbs[1] = t4[1] + t4[1] * e8, this._mbs[2] = t4[2] + t4[2] * e8, this._mbs[3] = t4[3] + t4[3] * this._totalOffset / s2, this._mbs;
  }
  applyToObb(t4) {
    const s2 = t4.center, e8 = this._totalOffset / Math.sqrt(s2[0] * s2[0] + s2[1] * s2[1] + s2[2] * s2[2]);
    this._obb.center[0] = s2[0] + s2[0] * e8, this._obb.center[1] = s2[1] + s2[1] * e8, this._obb.center[2] = s2[2] + s2[2] * e8, E(this._obb.halfSize, t4.halfSize, t4.quaternion), u(this._obb.halfSize, this._obb.halfSize, t4.center);
    const i4 = this._totalOffset / Math.sqrt(this._obb.halfSize[0] * this._obb.halfSize[0] + this._obb.halfSize[1] * this._obb.halfSize[1] + this._obb.halfSize[2] * this._obb.halfSize[2]);
    return this._obb.halfSize[0] += this._obb.halfSize[0] * i4, this._obb.halfSize[1] += this._obb.halfSize[1] * i4, this._obb.halfSize[2] += this._obb.halfSize[2] * i4, e(this._obb.halfSize, this._obb.halfSize, t4.center), S(I2, t4.quaternion), E(this._obb.halfSize, this._obb.halfSize, I2), this._obb.halfSize[0] *= this._obb.halfSize[0] < 0 ? -1 : 1, this._obb.halfSize[1] *= this._obb.halfSize[1] < 0 ? -1 : 1, this._obb.halfSize[2] *= this._obb.halfSize[2] < 0 ? -1 : 1, this._obb.quaternion = t4.quaternion, this._obb;
  }
};
var x2 = class {
  constructor(t4 = 0) {
    this.offset = t4, this.sphere = R(), this.tmpVertex = n();
  }
  applyToVertex(t4, s2, e8) {
    const i4 = this.objectTransform.transform;
    let r4 = i4[0] * t4 + i4[4] * s2 + i4[8] * e8 + i4[12], a4 = i4[1] * t4 + i4[5] * s2 + i4[9] * e8 + i4[13], o4 = i4[2] * t4 + i4[6] * s2 + i4[10] * e8 + i4[14];
    const h3 = this.offset / Math.sqrt(r4 * r4 + a4 * a4 + o4 * o4);
    r4 += r4 * h3, a4 += a4 * h3, o4 += o4 * h3;
    const n5 = this.objectTransform.inverse;
    return this.tmpVertex[0] = n5[0] * r4 + n5[4] * a4 + n5[8] * o4 + n5[12], this.tmpVertex[1] = n5[1] * r4 + n5[5] * a4 + n5[9] * o4 + n5[13], this.tmpVertex[2] = n5[2] * r4 + n5[6] * a4 + n5[10] * o4 + n5[14], this.tmpVertex;
  }
  applyToMinMax(t4, s2) {
    const e8 = this.offset / Math.sqrt(t4[0] * t4[0] + t4[1] * t4[1] + t4[2] * t4[2]);
    t4[0] += t4[0] * e8, t4[1] += t4[1] * e8, t4[2] += t4[2] * e8;
    const i4 = this.offset / Math.sqrt(s2[0] * s2[0] + s2[1] * s2[1] + s2[2] * s2[2]);
    s2[0] += s2[0] * i4, s2[1] += s2[1] * i4, s2[2] += s2[2] * i4;
  }
  applyToAabb(t4) {
    const s2 = this.offset / Math.sqrt(t4[0] * t4[0] + t4[1] * t4[1] + t4[2] * t4[2]);
    t4[0] += t4[0] * s2, t4[1] += t4[1] * s2, t4[2] += t4[2] * s2;
    const e8 = this.offset / Math.sqrt(t4[3] * t4[3] + t4[4] * t4[4] + t4[5] * t4[5]);
    return t4[3] += t4[3] * e8, t4[4] += t4[4] * e8, t4[5] += t4[5] * e8, t4;
  }
  applyToBoundingSphere(t4) {
    const s2 = Math.sqrt(t4[0] * t4[0] + t4[1] * t4[1] + t4[2] * t4[2]), e8 = this.offset / s2;
    return this.sphere[0] = t4[0] + t4[0] * e8, this.sphere[1] = t4[1] + t4[1] * e8, this.sphere[2] = t4[2] + t4[2] * e8, this.sphere[3] = t4[3] + t4[3] * this.offset / s2, this.sphere;
  }
};
var S2 = new x2();
function y2(s2) {
  return r(s2) ? (S2.offset = s2, S2) : null;
}
var q = new g3();
var d2 = new v();
var I2 = e3();

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/internal/bufferWriterUtils.js
function c3(e8, t4, f3, o4) {
  const r4 = f3.typedBuffer, n5 = f3.typedBufferStride, s2 = e8.length;
  o4 *= n5;
  for (let i4 = 0; i4 < s2; ++i4) {
    const f4 = 2 * e8[i4];
    r4[o4] = t4[f4], r4[o4 + 1] = t4[f4 + 1], o4 += n5;
  }
}
function d3(e8, t4, f3, o4, r4) {
  const n5 = f3.typedBuffer, s2 = f3.typedBufferStride, i4 = e8.length;
  if (o4 *= s2, null == r4 || 1 === r4)
    for (let l5 = 0; l5 < i4; ++l5) {
      const f4 = 3 * e8[l5];
      n5[o4] = t4[f4], n5[o4 + 1] = t4[f4 + 1], n5[o4 + 2] = t4[f4 + 2], o4 += s2;
    }
  else
    for (let l5 = 0; l5 < i4; ++l5) {
      const f4 = 3 * e8[l5];
      for (let e9 = 0; e9 < r4; ++e9)
        n5[o4] = t4[f4], n5[o4 + 1] = t4[f4 + 1], n5[o4 + 2] = t4[f4 + 2], o4 += s2;
    }
}
function u7(e8, t4, f3, o4, r4 = 1) {
  const n5 = f3.typedBuffer, s2 = f3.typedBufferStride, i4 = e8.length;
  if (o4 *= s2, 1 === r4)
    for (let l5 = 0; l5 < i4; ++l5) {
      const f4 = 4 * e8[l5];
      n5[o4] = t4[f4], n5[o4 + 1] = t4[f4 + 1], n5[o4 + 2] = t4[f4 + 2], n5[o4 + 3] = t4[f4 + 3], o4 += s2;
    }
  else
    for (let l5 = 0; l5 < i4; ++l5) {
      const f4 = 4 * e8[l5];
      for (let e9 = 0; e9 < r4; ++e9)
        n5[o4] = t4[f4], n5[o4 + 1] = t4[f4 + 1], n5[o4 + 2] = t4[f4 + 2], n5[o4 + 3] = t4[f4 + 3], o4 += s2;
    }
}
function y3(e8, t4, f3, o4, r4, n5 = 1) {
  if (!f3)
    return void d3(e8, t4, o4, r4, n5);
  const s2 = o4.typedBuffer, i4 = o4.typedBufferStride, l5 = e8.length, c4 = f3[0], u8 = f3[1], a4 = f3[2], p2 = f3[4], y4 = f3[5], B2 = f3[6], g5 = f3[8], h3 = f3[9], b3 = f3[10], m3 = f3[12], O4 = f3[13], z2 = f3[14];
  r4 *= i4;
  let A2 = 0, L = 0, j = 0;
  const I3 = S3(f3) ? (e9) => {
    A2 = t4[e9] + m3, L = t4[e9 + 1] + O4, j = t4[e9 + 2] + z2;
  } : (e9) => {
    const f4 = t4[e9], o5 = t4[e9 + 1], r5 = t4[e9 + 2];
    A2 = c4 * f4 + p2 * o5 + g5 * r5 + m3, L = u8 * f4 + y4 * o5 + h3 * r5 + O4, j = a4 * f4 + B2 * o5 + b3 * r5 + z2;
  };
  if (1 === n5)
    for (let d4 = 0; d4 < l5; ++d4)
      I3(3 * e8[d4]), s2[r4] = A2, s2[r4 + 1] = L, s2[r4 + 2] = j, r4 += i4;
  else
    for (let d4 = 0; d4 < l5; ++d4) {
      I3(3 * e8[d4]);
      for (let e9 = 0; e9 < n5; ++e9)
        s2[r4] = A2, s2[r4 + 1] = L, s2[r4 + 2] = j, r4 += i4;
    }
}
function B(e8, f3, o4, r4, n5, s2 = 1) {
  if (!o4)
    return void d3(e8, f3, r4, n5, s2);
  const i4 = o4, l5 = r4.typedBuffer, c4 = r4.typedBufferStride, u8 = e8.length, a4 = i4[0], p2 = i4[1], y4 = i4[2], B2 = i4[4], g5 = i4[5], h3 = i4[6], b3 = i4[8], m3 = i4[9], O4 = i4[10], z2 = !G(i4), A2 = 1e-6, L = 1 - A2;
  n5 *= c4;
  let j = 0, I3 = 0, k = 0;
  const C = S3(i4) ? (e9) => {
    j = f3[e9], I3 = f3[e9 + 1], k = f3[e9 + 2];
  } : (e9) => {
    const t4 = f3[e9], o5 = f3[e9 + 1], r5 = f3[e9 + 2];
    j = a4 * t4 + B2 * o5 + b3 * r5, I3 = p2 * t4 + g5 * o5 + m3 * r5, k = y4 * t4 + h3 * o5 + O4 * r5;
  };
  if (1 === s2)
    if (z2)
      for (let t4 = 0; t4 < u8; ++t4) {
        C(3 * e8[t4]);
        const f4 = j * j + I3 * I3 + k * k;
        if (f4 < L && f4 > A2) {
          const e9 = 1 / Math.sqrt(f4);
          l5[n5] = j * e9, l5[n5 + 1] = I3 * e9, l5[n5 + 2] = k * e9;
        } else
          l5[n5] = j, l5[n5 + 1] = I3, l5[n5 + 2] = k;
        n5 += c4;
      }
    else
      for (let t4 = 0; t4 < u8; ++t4)
        C(3 * e8[t4]), l5[n5] = j, l5[n5 + 1] = I3, l5[n5 + 2] = k, n5 += c4;
  else
    for (let t4 = 0; t4 < u8; ++t4) {
      if (C(3 * e8[t4]), z2) {
        const e9 = j * j + I3 * I3 + k * k;
        if (e9 < L && e9 > A2) {
          const t5 = 1 / Math.sqrt(e9);
          j *= t5, I3 *= t5, k *= t5;
        }
      }
      for (let e9 = 0; e9 < s2; ++e9)
        l5[n5] = j, l5[n5 + 1] = I3, l5[n5 + 2] = k, n5 += c4;
    }
}
function g4(e8, f3, o4, r4, n5, s2 = 1) {
  if (!o4)
    return void u7(e8, f3, r4, n5, s2);
  const i4 = o4, l5 = r4.typedBuffer, c4 = r4.typedBufferStride, d4 = e8.length, a4 = i4[0], p2 = i4[1], y4 = i4[2], B2 = i4[4], g5 = i4[5], h3 = i4[6], b3 = i4[8], m3 = i4[9], S4 = i4[10], O4 = !G(i4), z2 = 1e-6, A2 = 1 - z2;
  if (n5 *= c4, 1 === s2)
    for (let t4 = 0; t4 < d4; ++t4) {
      const o5 = 4 * e8[t4], r5 = f3[o5], s3 = f3[o5 + 1], i5 = f3[o5 + 2], d5 = f3[o5 + 3];
      let u8 = a4 * r5 + B2 * s3 + b3 * i5, L = p2 * r5 + g5 * s3 + m3 * i5, j = y4 * r5 + h3 * s3 + S4 * i5;
      if (O4) {
        const e9 = u8 * u8 + L * L + j * j;
        if (e9 < A2 && e9 > z2) {
          const t5 = 1 / Math.sqrt(e9);
          u8 *= t5, L *= t5, j *= t5;
        }
      }
      l5[n5] = u8, l5[n5 + 1] = L, l5[n5 + 2] = j, l5[n5 + 3] = d5, n5 += c4;
    }
  else
    for (let t4 = 0; t4 < d4; ++t4) {
      const o5 = 4 * e8[t4], r5 = f3[o5], i5 = f3[o5 + 1], d5 = f3[o5 + 2], u8 = f3[o5 + 3];
      let L = a4 * r5 + B2 * i5 + b3 * d5, j = p2 * r5 + g5 * i5 + m3 * d5, I3 = y4 * r5 + h3 * i5 + S4 * d5;
      if (O4) {
        const e9 = L * L + j * j + I3 * I3;
        if (e9 < A2 && e9 > z2) {
          const t5 = 1 / Math.sqrt(e9);
          L *= t5, j *= t5, I3 *= t5;
        }
      }
      for (let e9 = 0; e9 < s2; ++e9)
        l5[n5] = L, l5[n5 + 1] = j, l5[n5 + 2] = I3, l5[n5 + 3] = u8, n5 += c4;
    }
}
function h2(e8, t4, f3, o4, r4, n5 = 1) {
  const s2 = o4.typedBuffer, i4 = o4.typedBufferStride, l5 = e8.length;
  if (r4 *= i4, f3 !== t4.length || 4 !== f3)
    if (1 !== n5)
      if (4 !== f3)
        for (let c4 = 0; c4 < l5; ++c4) {
          const f4 = 3 * e8[c4];
          for (let e9 = 0; e9 < n5; ++e9)
            s2[r4] = t4[f4], s2[r4 + 1] = t4[f4 + 1], s2[r4 + 2] = t4[f4 + 2], s2[r4 + 3] = 255, r4 += i4;
        }
      else
        for (let c4 = 0; c4 < l5; ++c4) {
          const f4 = 4 * e8[c4];
          for (let e9 = 0; e9 < n5; ++e9)
            s2[r4] = t4[f4], s2[r4 + 1] = t4[f4 + 1], s2[r4 + 2] = t4[f4 + 2], s2[r4 + 3] = t4[f4 + 3], r4 += i4;
        }
    else {
      if (4 === f3) {
        for (let f4 = 0; f4 < l5; ++f4) {
          const o5 = 4 * e8[f4];
          s2[r4] = t4[o5], s2[r4 + 1] = t4[o5 + 1], s2[r4 + 2] = t4[o5 + 2], s2[r4 + 3] = t4[o5 + 3], r4 += i4;
        }
        return;
      }
      for (let f4 = 0; f4 < l5; ++f4) {
        const o5 = 3 * e8[f4];
        s2[r4] = t4[o5], s2[r4 + 1] = t4[o5 + 1], s2[r4 + 2] = t4[o5 + 2], s2[r4 + 3] = 255, r4 += i4;
      }
    }
  else {
    s2[r4] = t4[0], s2[r4 + 1] = t4[1], s2[r4 + 2] = t4[2], s2[r4 + 3] = t4[3];
    const e9 = new Uint32Array(o4.typedBuffer.buffer, o4.start), f4 = i4 / 4, c4 = e9[r4 /= 4];
    r4 += f4;
    const d4 = l5 * n5;
    for (let t5 = 1; t5 < d4; ++t5)
      e9[r4] = c4, r4 += f4;
  }
}
function b2(e8, t4, f3, o4, r4 = 1) {
  const n5 = t4.typedBuffer, s2 = t4.typedBufferStride;
  if (o4 *= s2, 1 === r4)
    for (let i4 = 0; i4 < f3; ++i4)
      n5[o4] = e8[0], n5[o4 + 1] = e8[1], n5[o4 + 2] = e8[2], n5[o4 + 3] = e8[3], o4 += s2;
  else
    for (let i4 = 0; i4 < f3; ++i4)
      for (let t5 = 0; t5 < r4; ++t5)
        n5[o4] = e8[0], n5[o4 + 1] = e8[1], n5[o4 + 2] = e8[2], n5[o4 + 3] = e8[3], o4 += s2;
}
function m(t4, l5, d4, u8, a4, p2) {
  for (const m3 of l5.fieldNames) {
    const l6 = t4.vertexAttributes.get(m3), S4 = t4.indices.get(m3);
    if (l6 && S4)
      switch (m3) {
        case O2.POSITION: {
          e5(3 === l6.size);
          const e8 = a4.getField(m3, i);
          e8 && y3(S4, l6.data, d4, e8, p2);
          break;
        }
        case O2.NORMAL: {
          e5(3 === l6.size);
          const e8 = a4.getField(m3, i);
          e8 && B(S4, l6.data, u8, e8, p2);
          break;
        }
        case O2.UV0: {
          e5(2 === l6.size);
          const e8 = a4.getField(m3, u3);
          e8 && c3(S4, l6.data, e8, p2);
          break;
        }
        case O2.COLOR: {
          e5(3 === l6.size || 4 === l6.size);
          const e8 = a4.getField(m3, x);
          e8 && h2(S4, l6.data, l6.size, e8, p2);
          break;
        }
        case O2.SYMBOLCOLOR: {
          e5(3 === l6.size || 4 === l6.size);
          const e8 = a4.getField(m3, x);
          e8 && h2(S4, l6.data, l6.size, e8, p2);
          break;
        }
        case O2.TANGENT: {
          e5(4 === l6.size);
          const e8 = a4.getField(m3, c);
          e8 && g4(S4, l6.data, u8, e8, p2);
          break;
        }
      }
    else if (m3 === O2.OBJECTANDLAYERIDCOLOR && r(t4.objectAndLayerIdColor) && 4 === t4.objectAndLayerIdColor.length) {
      const e8 = t4.indices.get(O2.POSITION);
      if (e8) {
        const f3 = e8.length, r4 = a4.getField(m3, x);
        b2(t4.objectAndLayerIdColor, r4, f3, p2);
      }
    }
  }
}
function S3(e8) {
  return 1 === e8[0] && 0 === e8[1] && 0 === e8[2] && 0 === e8[4] && 1 === e8[5] && 0 === e8[6] && 0 === e8[8] && 0 === e8[9] && 1 === e8[10];
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/StencilUtils.js
var i3 = { func: I.LESS };
var s = { func: I.ALWAYS };
var e7 = { mask: 255 };
var l4 = { mask: 0 };
var f2 = { function: { func: I.ALWAYS, ref: t3.OutlineVisualElementMask, mask: t3.OutlineVisualElementMask }, operation: { fail: O.KEEP, zFail: O.KEEP, zPass: O.ZERO } };
var o3 = { function: { func: I.ALWAYS, ref: t3.OutlineVisualElementMask, mask: t3.OutlineVisualElementMask }, operation: { fail: O.KEEP, zFail: O.KEEP, zPass: O.REPLACE } };
var P = { function: { func: I.EQUAL, ref: t3.OutlineVisualElementMask, mask: t3.OutlineVisualElementMask }, operation: { fail: O.KEEP, zFail: O.KEEP, zPass: O.KEEP } };
var m2 = { function: { func: I.NOTEQUAL, ref: t3.OutlineVisualElementMask, mask: t3.OutlineVisualElementMask }, operation: { fail: O.KEEP, zFail: O.KEEP, zPass: O.KEEP } };

export {
  c2 as c,
  a3 as a,
  f,
  d,
  E2 as E,
  u6 as u,
  y2 as y,
  u7 as u2,
  y3 as y2,
  B,
  h2 as h,
  b2 as b,
  m,
  i3 as i,
  s,
  e7 as e,
  l4 as l,
  f2,
  o3 as o,
  P,
  m2
};
//# sourceMappingURL=chunk-7ZSUZDMT.js.map
