import {
  o as o2
} from "./chunk-DBT4KOKX.js";
import {
  _,
  c as c2,
  i,
  n as n4,
  r as r3
} from "./chunk-JHLU6RPN.js";
import "./chunk-EPMXCACW.js";
import {
  C
} from "./chunk-UCPKJYXN.js";
import {
  t as t5
} from "./chunk-KFLNKWNF.js";
import {
  T,
  l as l2,
  m as m2,
  t as t2
} from "./chunk-2XVZ2CO6.js";
import {
  I,
  L
} from "./chunk-L553EHL3.js";
import {
  a,
  l,
  m,
  n as n2,
  o,
  p as p2,
  u
} from "./chunk-2GP5D74I.js";
import {
  s,
  t as t4
} from "./chunk-R24MO4IV.js";
import {
  P,
  a as a2,
  b,
  f,
  h,
  n as n3,
  r as r2,
  t as t3
} from "./chunk-YQBYWPBD.js";
import "./chunk-QISOH77W.js";
import "./chunk-XO5VJRK4.js";
import "./chunk-4OM3EX6P.js";
import "./chunk-3OFVLRSL.js";
import {
  x
} from "./chunk-UWKVAZQ6.js";
import "./chunk-5FHRTN6L.js";
import {
  n
} from "./chunk-5MBCFCGH.js";
import "./chunk-UAJ2SDPQ.js";
import "./chunk-ZPYDYUP5.js";
import "./chunk-RAX2HD42.js";
import "./chunk-ZYRIJWLX.js";
import "./chunk-C5H57NTD.js";
import "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import "./chunk-KAN4HXCG.js";
import {
  t
} from "./chunk-U2XHEJM7.js";
import {
  j,
  p
} from "./chunk-MJXQTGI2.js";
import "./chunk-LIZHLHNA.js";
import "./chunk-BTUHYGXO.js";
import "./chunk-UA3YPL2R.js";
import {
  c
} from "./chunk-HVKDYDPP.js";
import "./chunk-6QC7MLLS.js";
import {
  r
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/ScriptUtils.js
function e(e3) {
  return 746 === e3 || 747 === e3 || !(e3 < 4352) && (e3 >= 12704 && e3 <= 12735 || (e3 >= 12544 && e3 <= 12591 || (e3 >= 65072 && e3 <= 65103 && !(e3 >= 65097 && e3 <= 65103) || (e3 >= 63744 && e3 <= 64255 || (e3 >= 13056 && e3 <= 13311 || (e3 >= 11904 && e3 <= 12031 || (e3 >= 12736 && e3 <= 12783 || (e3 >= 12288 && e3 <= 12351 && !(e3 >= 12296 && e3 <= 12305 || e3 >= 12308 && e3 <= 12319 || 12336 === e3) || (e3 >= 13312 && e3 <= 19903 || (e3 >= 19968 && e3 <= 40959 || (e3 >= 12800 && e3 <= 13055 || (e3 >= 12592 && e3 <= 12687 || (e3 >= 43360 && e3 <= 43391 || (e3 >= 55216 && e3 <= 55295 || (e3 >= 4352 && e3 <= 4607 || (e3 >= 44032 && e3 <= 55215 || (e3 >= 12352 && e3 <= 12447 || (e3 >= 12272 && e3 <= 12287 || (e3 >= 12688 && e3 <= 12703 || (e3 >= 12032 && e3 <= 12255 || (e3 >= 12784 && e3 <= 12799 || (e3 >= 12448 && e3 <= 12543 && 12540 !== e3 || (e3 >= 65280 && e3 <= 65519 && !(65288 === e3 || 65289 === e3 || 65293 === e3 || e3 >= 65306 && e3 <= 65310 || 65339 === e3 || 65341 === e3 || 65343 === e3 || e3 >= 65371 && e3 <= 65503 || 65507 === e3 || e3 >= 65512 && e3 <= 65519) || (e3 >= 65104 && e3 <= 65135 && !(e3 >= 65112 && e3 <= 65118 || e3 >= 65123 && e3 <= 65126) || (e3 >= 5120 && e3 <= 5759 || (e3 >= 6320 && e3 <= 6399 || (e3 >= 65040 && e3 <= 65055 || (e3 >= 19904 && e3 <= 19967 || (e3 >= 40960 && e3 <= 42127 || e3 >= 42128 && e3 <= 42191)))))))))))))))))))))))))))));
}
function c3(e3) {
  return !(e3 < 11904) && (e3 >= 12704 && e3 <= 12735 || (e3 >= 12544 && e3 <= 12591 || (e3 >= 65072 && e3 <= 65103 || (e3 >= 63744 && e3 <= 64255 || (e3 >= 13056 && e3 <= 13311 || (e3 >= 11904 && e3 <= 12031 || (e3 >= 12736 && e3 <= 12783 || (e3 >= 12288 && e3 <= 12351 || (e3 >= 13312 && e3 <= 19903 || (e3 >= 19968 && e3 <= 40959 || (e3 >= 12800 && e3 <= 13055 || (e3 >= 65280 && e3 <= 65519 || (e3 >= 12352 && e3 <= 12447 || (e3 >= 12272 && e3 <= 12287 || (e3 >= 12032 && e3 <= 12255 || (e3 >= 12784 && e3 <= 12799 || (e3 >= 12448 && e3 <= 12543 || (e3 >= 65040 && e3 <= 65055 || (e3 >= 42128 && e3 <= 42191 || e3 >= 40960 && e3 <= 42127)))))))))))))))))));
}
function s2(e3) {
  switch (e3) {
    case 10:
    case 32:
    case 38:
    case 40:
    case 41:
    case 43:
    case 45:
    case 47:
    case 173:
    case 183:
    case 8203:
    case 8208:
    case 8211:
    case 8231:
      return true;
  }
  return false;
}
function a3(e3) {
  switch (e3) {
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 32:
      return true;
  }
  return false;
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TextShaping.js
var c4 = 24;
var h2 = 17;
var a4 = class {
  constructor(t8, e3, i2, s6, o5, c5, h4) {
    this._glyphItems = t8, this._maxWidth = e3, this._lineHeight = i2, this._letterSpacing = s6, this._hAnchor = o5, this._vAnchor = c5, this._justify = h4;
  }
  getShaping(o5, c5, h4) {
    const a7 = this._letterSpacing, l4 = this._lineHeight, r8 = this._justify, n6 = this._maxWidth, m3 = [];
    let f3 = 0, p4 = 0;
    const g2 = o5.length;
    for (let t8 = 0; t8 < g2; t8++) {
      const e3 = o5.charCodeAt(t8), i2 = h4 && e(e3);
      let c6;
      for (const t9 of this._glyphItems)
        if (c6 = t9[e3], c6)
          break;
      m3.push({ codePoint: e3, x: f3, y: p4, vertical: i2, glyphMosaicItem: c6 }), c6 && (f3 += c6.metrics.advance + a7);
    }
    let y2 = f3;
    if (n6 > 0) {
      y2 = f3 / Math.max(1, Math.ceil(f3 / n6));
    }
    const d = o5.includes("\u200B"), x3 = [];
    for (let e3 = 0; e3 < g2 - 1; e3++) {
      const s6 = m3[e3].codePoint, o6 = c3(s6);
      if (s2(s6) || o6) {
        let t8 = 0;
        if (10 === s6)
          t8 -= 1e4;
        else if (o6 && d)
          t8 += 150;
        else {
          40 !== s6 && 65288 !== s6 || (t8 += 50);
          const i2 = m3[e3 + 1].codePoint;
          41 !== i2 && 65289 !== i2 || (t8 += 50);
        }
        x3.push(this._buildBreak(e3 + 1, m3[e3].x, y2, x3, t8, false));
      }
    }
    const M = this._optimalBreaks(this._buildBreak(g2, f3, y2, x3, 0, true));
    let u4 = 0;
    const _2 = c5 ? -l4 : l4;
    let I5 = 0;
    for (let t8 = 0; t8 < M.length; t8++) {
      const i2 = M[t8];
      let s6 = I5;
      for (; s6 < i2 && a3(m3[s6].codePoint); )
        m3[s6].glyphMosaicItem = null, ++s6;
      let o6 = i2 - 1;
      for (; o6 > s6 && a3(m3[o6].codePoint); )
        m3[o6].glyphMosaicItem = null, --o6;
      if (s6 <= o6) {
        const t9 = m3[s6].x;
        for (let i3 = s6; i3 <= o6; i3++)
          m3[i3].x -= t9, m3[i3].y = p4;
        let e3 = m3[o6].x;
        m3[o6].glyphMosaicItem && (e3 += m3[o6].glyphMosaicItem.metrics.advance), u4 = Math.max(e3, u4), r8 && this._applyJustification(m3, s6, o6);
      }
      I5 = i2, p4 += _2;
    }
    if (m3.length > 0) {
      const t8 = M.length - 1, e3 = (r8 - this._hAnchor) * u4;
      let i2 = (-this._vAnchor * (t8 + 1) + 0.5) * l4;
      c5 && t8 && (i2 += t8 * l4);
      for (const s6 of m3)
        s6.x += e3, s6.y += i2;
    }
    return m3.filter((t8) => t8.glyphMosaicItem);
  }
  static getTextBox(t8, e3) {
    if (!t8.length)
      return null;
    let i2 = 1 / 0, s6 = 1 / 0, o5 = 0, c5 = 0;
    for (const a7 of t8) {
      const t9 = a7.glyphMosaicItem.metrics.advance, l4 = a7.x, r8 = a7.y - h2, n6 = l4 + t9, m3 = r8 + e3;
      i2 = Math.min(i2, l4), o5 = Math.max(o5, n6), s6 = Math.min(s6, r8), c5 = Math.max(c5, m3);
    }
    return { x: i2, y: s6, width: o5 - i2, height: c5 - s6 };
  }
  static getBox(t8) {
    if (!t8.length)
      return null;
    let e3 = 1 / 0, i2 = 1 / 0, s6 = 0, o5 = 0;
    for (const c5 of t8) {
      const { height: t9, left: h4, top: a7, width: l4 } = c5.glyphMosaicItem.metrics, r8 = c5.x, n6 = c5.y - (t9 - Math.abs(a7)), m3 = r8 + l4 + h4, f3 = n6 + t9;
      e3 = Math.min(e3, r8), s6 = Math.max(s6, m3), i2 = Math.min(i2, n6), o5 = Math.max(o5, f3);
    }
    return { x: e3, y: i2, width: s6 - e3, height: o5 - i2 };
  }
  static addDecoration(t8, e3) {
    const i2 = t8.length;
    if (0 === i2)
      return;
    const s6 = 3;
    let c5 = t8[0].x + t8[0].glyphMosaicItem.metrics.left, h4 = t8[0].y;
    for (let l4 = 1; l4 < i2; l4++) {
      const i3 = t8[l4];
      if (i3.y !== h4) {
        const a8 = t8[l4 - 1].x + t8[l4 - 1].glyphMosaicItem.metrics.left + t8[l4 - 1].glyphMosaicItem.metrics.width;
        t8.push({ codePoint: 0, x: c5, y: h4 + e3 - s6, vertical: false, glyphMosaicItem: { sdf: true, rect: new t5(4, 0, 4, 8), metrics: { width: a8 - c5, height: 2 + 2 * s6, left: 0, top: 0, advance: 0 }, page: 0, code: 0 } }), h4 = i3.y, c5 = i3.x + i3.glyphMosaicItem.metrics.left;
      }
    }
    const a7 = t8[i2 - 1].x + t8[i2 - 1].glyphMosaicItem.metrics.left + t8[i2 - 1].glyphMosaicItem.metrics.width;
    t8.push({ codePoint: 0, x: c5, y: h4 + e3 - s6, vertical: false, glyphMosaicItem: { sdf: true, rect: new t5(4, 0, 4, 8), metrics: { width: a7 - c5, height: 2 + 2 * s6, left: 0, top: 0, advance: 0 }, page: 0, code: 0 } });
  }
  _breakScore(t8, e3, i2, s6) {
    const o5 = (t8 - e3) * (t8 - e3);
    return s6 ? t8 < e3 ? o5 / 2 : 2 * o5 : o5 + Math.abs(i2) * i2;
  }
  _buildBreak(t8, e3, i2, s6, o5, c5) {
    let h4 = null, a7 = this._breakScore(e3, i2, o5, c5);
    for (const l4 of s6) {
      const t9 = e3 - l4.x, s7 = this._breakScore(t9, i2, o5, c5) + l4.score;
      s7 <= a7 && (h4 = l4, a7 = s7);
    }
    return { index: t8, x: e3, score: a7, previousBreak: h4 };
  }
  _optimalBreaks(t8) {
    return t8 ? this._optimalBreaks(t8.previousBreak).concat(t8.index) : [];
  }
  _applyJustification(t8, e3, i2) {
    const s6 = t8[i2], o5 = s6.vertical ? c4 : s6.glyphMosaicItem ? s6.glyphMosaicItem.metrics.advance : 0, h4 = (s6.x + o5) * this._justify;
    for (let c5 = e3; c5 <= i2; c5++)
      t8[c5].x -= h4;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/Placement.js
var x2 = 4096;
var w = 8;
var p3 = 0.5;
var y = 2;
var T2 = class {
  constructor(e3, t8, i2 = 0, n6 = -1, s6 = p3) {
    this.x = e3, this.y = t8, this.angle = i2, this.segment = n6, this.minzoom = s6;
  }
};
var f2 = class {
  constructor(e3, t8, n6, s6, o5, a7 = p3, l4 = n3) {
    this.anchor = e3, this.labelAngle = t8, this.glyphAngle = n6, this.page = s6, this.alternateVerticalGlyph = o5, this.minzoom = a7, this.maxzoom = l4;
  }
};
var I2 = class {
  constructor(e3, t8, i2, n6, s6, o5, a7, l4, h4, r8, c5, g2) {
    this.tl = e3, this.tr = t8, this.bl = i2, this.br = n6, this.mosaicRect = s6, this.labelAngle = o5, this.minAngle = a7, this.maxAngle = l4, this.anchor = h4, this.minzoom = r8, this.maxzoom = c5, this.page = g2;
  }
};
var b2 = class {
  constructor(e3) {
    this.shapes = e3;
  }
};
var u2 = class {
  getIconPlacement(i2, n6, s6) {
    const o5 = new t4(i2.x, i2.y), a7 = s6.rotationAlignment === l.MAP, l4 = s6.keepUpright;
    let h4 = s6.rotate * f;
    a7 && (h4 += i2.angle);
    const g2 = new b2([]);
    return s6.allowOverlap && s6.ignorePlacement || !o2 || (g2.iconColliders = []), this._addIconPlacement(g2, o5, n6, s6, h4), a7 && l4 && this._addIconPlacement(g2, o5, n6, s6, h4 + t3), g2;
  }
  _addIconPlacement(e3, t8, n6, s6, o5) {
    const a7 = n6.pixelRatio, l4 = n6.width / a7, h4 = n6.height / a7, c5 = s6.offset;
    let x3 = c5[0], d = c5[1];
    switch (s6.anchor) {
      case m.CENTER:
        x3 -= l4 / 2, d -= h4 / 2;
        break;
      case m.LEFT:
        d -= h4 / 2;
        break;
      case m.RIGHT:
        x3 -= l4, d -= h4 / 2;
        break;
      case m.TOP:
        x3 -= l4 / 2;
        break;
      case m.BOTTOM:
        x3 -= l4 / 2, d -= h4;
        break;
      case m.TOP_LEFT:
        break;
      case m.BOTTOM_LEFT:
        d -= h4;
        break;
      case m.TOP_RIGHT:
        x3 -= l4;
        break;
      case m.BOTTOM_RIGHT:
        x3 -= l4, d -= h4;
    }
    const w3 = n6.rect, y2 = 2 / a7, T4 = x3 - y2, f3 = d - y2, b4 = T4 + w3.width / a7, u4 = f3 + w3.height / a7, P2 = new t4(T4, f3), O = new t4(b4, u4), _2 = new t4(T4, u4), k = new t4(b4, f3);
    if (0 !== o5) {
      const e4 = Math.cos(o5), t9 = Math.sin(o5);
      P2.rotate(e4, t9), O.rotate(e4, t9), _2.rotate(e4, t9), k.rotate(e4, t9);
    }
    const M = new I2(P2, k, _2, O, w3, o5, 0, 256, t8, p3, n3, 0);
    if (e3.shapes.push(M), (!s6.allowOverlap || !s6.ignorePlacement) && o2) {
      const n7 = s6.size, a8 = s6.padding, r8 = { xTile: t8.x, yTile: t8.y, dxPixels: x3 * n7 - a8, dyPixels: d * n7 - a8, hard: !s6.optional, partIndex: 0, width: l4 * n7 + 2 * a8, height: h4 * n7 + 2 * a8, angle: o5, minLod: p3, maxLod: n3 };
      e3.iconColliders.push(r8);
    }
  }
  getTextPlacement(n6, s6, o5, r8) {
    const x3 = new t4(n6.x, n6.y), d = r8.rotate * f, T4 = r8.rotationAlignment === l.MAP, u4 = r8.keepUpright, P2 = r8.padding;
    let O = p3;
    const _2 = !T4 ? 0 : n6.angle, k = n6.segment >= 0 && T4, M = r8.allowOverlap && r8.ignorePlacement ? null : [], E = [], G = 4, N = !k;
    let A2 = Number.POSITIVE_INFINITY, L2 = Number.NEGATIVE_INFINITY, z = A2, F = L2;
    const v = (k || T4) && u4, R = r8.size / c4;
    let B2 = false;
    for (const e3 of s6)
      if (e3.vertical) {
        B2 = true;
        break;
      }
    let H, V = 0, j2 = 0;
    if (!k && B2) {
      const e3 = a4.getTextBox(s6, r8.lineHeight * c4);
      switch (r8.anchor) {
        case m.LEFT:
          V = e3.height / 2, j2 = -e3.width / 2;
          break;
        case m.RIGHT:
          V = -e3.height / 2, j2 = e3.width / 2;
          break;
        case m.TOP:
          V = e3.height / 2, j2 = e3.width / 2;
          break;
        case m.BOTTOM:
          V = -e3.height / 2, j2 = -e3.width / 2;
          break;
        case m.TOP_LEFT:
          V = e3.height;
          break;
        case m.BOTTOM_LEFT:
          j2 = -e3.width;
          break;
        case m.TOP_RIGHT:
          j2 = e3.width;
          break;
        case m.BOTTOM_RIGHT:
          V = -e3.height;
      }
    }
    V += r8.offset[0] * c4, j2 += r8.offset[1] * c4;
    for (const e3 of s6) {
      const s7 = e3.glyphMosaicItem;
      if (!s7 || s7.rect.isEmpty)
        continue;
      const a7 = s7.rect, l4 = s7.metrics, c5 = s7.page;
      if (M && N) {
        if (void 0 !== H && H !== e3.y) {
          let e4, t8, s8, o6;
          B2 ? (e4 = -F + V, t8 = A2 + j2, s8 = F - z, o6 = L2 - A2) : (e4 = A2 + V, t8 = z + j2, s8 = L2 - A2, o6 = F - z);
          const a8 = { xTile: n6.x, yTile: n6.y, dxPixels: e4 * R - P2, dyPixels: t8 * R - P2, hard: !r8.optional, partIndex: 1, width: s8 * R + 2 * P2, height: o6 * R + 2 * P2, angle: d, minLod: p3, maxLod: n3 };
          M.push(a8), A2 = Number.POSITIVE_INFINITY, L2 = Number.NEGATIVE_INFINITY, z = A2, F = L2;
        }
        H = e3.y;
      }
      const g2 = [];
      if (k) {
        const t8 = 0.5 * s7.metrics.width, i2 = (e3.x + l4.left - G + t8) * R * w;
        if (O = this._placeGlyph(n6, O, i2, o5, n6.segment, 1, e3.vertical, c5, g2), u4 && (O = this._placeGlyph(n6, O, i2, o5, n6.segment, -1, e3.vertical, c5, g2)), O >= y)
          break;
      } else
        g2.push(new f2(x3, _2, _2, c5, false)), T4 && u4 && g2.push(new f2(x3, _2 + t3, _2 + t3, c5, false));
      const b4 = e3.x + l4.left, C3 = e3.y - h2 - l4.top, S = b4 + l4.width, Y = C3 + l4.height;
      let q, U, D, J, K, Q, W, X;
      if (!k && B2)
        if (e3.vertical) {
          const e4 = (b4 + S) / 2 - l4.height / 2, t8 = (C3 + Y) / 2 + l4.width / 2;
          q = new t4(-t8 - G + V, e4 - G + j2), U = new t4(q.x + a7.width, q.y + a7.height), D = new t4(q.x, U.y), J = new t4(U.x, q.y);
        } else
          q = new t4(-C3 + G + V, b4 - G + j2), U = new t4(q.x - a7.height, q.y + a7.width), D = new t4(U.x, q.y), J = new t4(q.x, U.y);
      else
        q = new t4(b4 - G + V, C3 - G + j2), U = new t4(q.x + a7.width, q.y + a7.height), D = new t4(q.x, U.y), J = new t4(U.x, q.y);
      for (const t8 of g2) {
        let i2, s8, o6, h4;
        if (t8.alternateVerticalGlyph) {
          if (!K) {
            const e4 = (C3 + Y) / 2 + j2;
            K = new t4((b4 + S) / 2 + V - l4.height / 2 - G, e4 + l4.width / 2 + G), Q = new t4(K.x + a7.height, K.y - a7.width), W = new t4(Q.x, K.y), X = new t4(K.x, Q.y);
          }
          i2 = K, s8 = W, o6 = X, h4 = Q;
        } else
          i2 = q, s8 = D, o6 = J, h4 = U;
        const c6 = C3, g3 = Y, x4 = t8.glyphAngle + d;
        if (0 !== x4) {
          const e4 = Math.cos(x4), t9 = Math.sin(x4);
          i2 = i2.clone(), s8 = s8.clone(), o6 = o6.clone(), h4 = h4.clone(), i2.rotate(e4, t9), h4.rotate(e4, t9), s8.rotate(e4, t9), o6.rotate(e4, t9);
        }
        let w3 = 0, p4 = 256;
        if (k && B2 ? e3.vertical ? t8.alternateVerticalGlyph ? (w3 = 32, p4 = 96) : (w3 = 224, p4 = 32) : (w3 = 224, p4 = 96) : (w3 = 192, p4 = 64), E.push(new I2(i2, o6, s8, h4, a7, t8.labelAngle, w3, p4, t8.anchor, t8.minzoom, t8.maxzoom, t8.page)), M && (!v || this._legible(t8.labelAngle))) {
          if (N)
            b4 < A2 && (A2 = b4), c6 < z && (z = c6), S > L2 && (L2 = S), g3 > F && (F = g3);
          else if (t8.minzoom < y) {
            const e4 = { xTile: n6.x, yTile: n6.y, dxPixels: (b4 + V) * R - P2, dyPixels: (c6 + V) * R - P2, hard: !r8.optional, partIndex: 1, width: (S - b4) * R + 2 * P2, height: (g3 - c6) * R + 2 * P2, angle: x4, minLod: t8.minzoom, maxLod: t8.maxzoom };
            M.push(e4);
          }
        }
      }
    }
    if (O >= y)
      return null;
    if (M && N) {
      let e3, t8, s7, o6;
      B2 ? (e3 = -F + V, t8 = A2 + j2, s7 = F - z, o6 = L2 - A2) : (e3 = A2 + V, t8 = z + j2, s7 = L2 - A2, o6 = F - z);
      const a7 = { xTile: n6.x, yTile: n6.y, dxPixels: e3 * R - P2, dyPixels: t8 * R - P2, hard: !r8.optional, partIndex: 1, width: s7 * R + 2 * P2, height: o6 * R + 2 * P2, angle: d, minLod: p3, maxLod: n3 };
      M.push(a7);
    }
    const C2 = new b2(E);
    return M && M.length > 0 && (C2.textColliders = M), C2;
  }
  _legible(e3) {
    const t8 = h(e3);
    return t8 < 65 || t8 >= 193;
  }
  _placeGlyph(e3, n6, a7, l4, h4, r8, c5, g2, x3) {
    let d = r8;
    const w3 = d < 0 ? a2(e3.angle + t3, r2) : e3.angle;
    let p4 = 0;
    a7 < 0 && (d *= -1, a7 *= -1, p4 = t3), d > 0 && ++h4;
    let y2 = new t4(e3.x, e3.y), T4 = l4[h4], I5 = n3;
    if (l4.length <= h4)
      return I5;
    for (; ; ) {
      const e4 = T4.x - y2.x, t8 = T4.y - y2.y, i2 = Math.sqrt(e4 * e4 + t8 * t8), r9 = Math.max(a7 / i2, n6), m3 = e4 / i2, b4 = t8 / i2, u4 = a2(Math.atan2(b4, m3) + p4, r2);
      if (x3.push(new f2(y2, w3, u4, g2, false, r9, I5)), c5 && x3.push(new f2(y2, w3, u4, g2, true, r9, I5)), r9 <= n6)
        return r9;
      y2 = T4.clone();
      do {
        if (h4 += d, l4.length <= h4 || h4 < 0)
          return r9;
        T4 = l4[h4];
      } while (y2.isEqual(T4));
      let P2 = T4.x - y2.x, O = T4.y - y2.y;
      const _2 = Math.sqrt(P2 * P2 + O * O);
      P2 *= i2 / _2, O *= i2 / _2, y2.x -= P2, y2.y -= O, I5 = r9;
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/Feature.js
var t6;
!function(e3) {
  e3[e3.moveTo = 1] = "moveTo", e3[e3.lineTo = 2] = "lineTo", e3[e3.close = 7] = "close";
}(t6 || (t6 = {}));
var s3 = class {
  constructor(e3, t8) {
    this.values = {}, this._geometry = void 0, this._pbfGeometry = null;
    const s6 = t8.keys, o5 = t8.values, r8 = e3.asUnsafe();
    for (; r8.next(); )
      switch (r8.tag()) {
        case 1:
          this.id = r8.getUInt64();
          break;
        case 2: {
          const e4 = r8.getMessage().asUnsafe(), t9 = this.values;
          for (; !e4.empty(); ) {
            const r9 = e4.getUInt32(), a7 = e4.getUInt32();
            t9[s6[r9]] = o5[a7];
          }
          e4.release();
          break;
        }
        case 3:
          this.type = r8.getUInt32();
          break;
        case 4:
          this._pbfGeometry = r8.getMessage();
          break;
        default:
          r8.skip();
      }
  }
  getGeometry(s6) {
    if (void 0 !== this._geometry)
      return this._geometry;
    if (!this._pbfGeometry)
      return null;
    const o5 = this._pbfGeometry.asUnsafe();
    let r8, a7;
    this._pbfGeometry = null, s6 ? s6.reset(this.type) : r8 = [];
    let n6, i2 = t6.moveTo, l4 = 0, c5 = 0, h4 = 0;
    for (; !o5.empty(); ) {
      if (0 === l4) {
        const e3 = o5.getUInt32();
        i2 = 7 & e3, l4 = e3 >> 3;
      }
      switch (l4--, i2) {
        case t6.moveTo:
          c5 += o5.getSInt32(), h4 += o5.getSInt32(), s6 ? s6.moveTo(c5, h4) : r8 && (a7 && r8.push(a7), a7 = [], a7.push(new t4(c5, h4)));
          break;
        case t6.lineTo:
          c5 += o5.getSInt32(), h4 += o5.getSInt32(), s6 ? s6.lineTo(c5, h4) : a7 && a7.push(new t4(c5, h4));
          break;
        case t6.close:
          s6 ? s6.close() : a7 && !a7[0].equals(c5, h4) && a7.push(a7[0].clone());
          break;
        default:
          throw o5.release(), new Error("Invalid path operation");
      }
    }
    return s6 ? n6 = s6.result() : r8 && (a7 && r8.push(a7), n6 = r8), o5.release(), this._geometry = n6, n6;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/IndexMemoryBuffer.js
var r4 = class extends t2 {
  constructor() {
    super(12);
  }
  add(s6, r8, t8) {
    const e3 = this.array;
    e3.push(s6), e3.push(r8), e3.push(t8);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/SourceLayerData.js
var e2 = class {
  constructor(t8) {
    this.extent = 4096, this.keys = [], this.values = [], this._pbfLayer = t8.clone();
    const s6 = t8.asUnsafe();
    for (; s6.next(); )
      switch (s6.tag()) {
        case 1:
          this.name = s6.getString();
          break;
        case 3:
          this.keys.push(s6.getString());
          break;
        case 4:
          this.values.push(s6.processMessage(e2._parseValue));
          break;
        case 5:
          this.extent = s6.getUInt32();
          break;
        default:
          s6.skip();
      }
  }
  getData() {
    return this._pbfLayer;
  }
  static _parseValue(e3) {
    for (; e3.next(); )
      switch (e3.tag()) {
        case 1:
          return e3.getString();
        case 2:
          return e3.getFloat();
        case 3:
          return e3.getDouble();
        case 4:
          return e3.getInt64();
        case 5:
          return e3.getUInt64();
        case 6:
          return e3.getSInt64();
        case 7:
          return e3.getBool();
        default:
          e3.skip();
      }
    return null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/VertexMemoryBuffer.js
var o3 = class extends t2 {
  constructor(t8) {
    super(t8);
  }
  add(t8, o5, r8, u4, h4, a7, n6, d, e3, p4, i2, c5) {
    const M = this.array;
    let l4 = t2.i1616to32(t8, o5);
    M.push(l4);
    const m3 = 31;
    l4 = t2.i8888to32(Math.round(m3 * r8), Math.round(m3 * u4), Math.round(m3 * h4), Math.round(m3 * a7)), M.push(l4), l4 = t2.i8888to32(Math.round(m3 * n6), Math.round(m3 * d), Math.round(m3 * e3), Math.round(m3 * p4)), M.push(l4), l4 = t2.i1616to32(i2, 0), M.push(l4), c5 && M.push(...c5);
  }
};
var r5 = class extends t2 {
  constructor(t8) {
    super(t8);
  }
  add(t8, o5, r8) {
    const u4 = this.array;
    u4.push(t2.i1616to32(t8, o5)), r8 && u4.push(...r8);
  }
};
var u3 = class extends t2 {
  constructor(t8) {
    super(t8);
  }
  add(t8, o5, r8, u4, h4, a7, n6) {
    const d = this.array, e3 = this.index;
    let p4 = t2.i1616to32(t8, o5);
    d.push(p4);
    const i2 = 15;
    return p4 = t2.i8888to32(Math.round(i2 * r8), Math.round(i2 * u4), h4, a7), d.push(p4), n6 && d.push(...n6), e3;
  }
};
var h3 = class extends t2 {
  constructor(t8) {
    super(t8);
  }
  add(o5, r8, u4, h4, a7, n6, d, e3, p4, i2, c5, M) {
    const l4 = this.array;
    let m3 = t2.i1616to32(o5, r8);
    l4.push(m3), m3 = t2.i1616to32(Math.round(8 * u4), Math.round(8 * h4)), l4.push(m3), m3 = t2.i8888to32(a7 / 4, n6 / 4, e3, p4), l4.push(m3), m3 = t2.i8888to32(0, h(d), 10 * i2, Math.min(10 * c5, 255)), l4.push(m3), M && l4.push(...M);
  }
};
var a5 = class extends t2 {
  constructor(t8) {
    super(t8);
  }
  add(t8, o5, r8, u4, h4) {
    const a7 = this.array, n6 = t2.i1616to32(2 * t8 + r8, 2 * o5 + u4);
    a7.push(n6), h4 && a7.push(...h4);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/buckets/BaseBucket.js
var t7 = class {
  constructor(t8, e3, s6) {
    this.layerExtent = 4096, this._features = [], this.layer = t8, this.zoom = e3, this._spriteInfo = s6, this._filter = t8.getFeatureFilter();
  }
  pushFeature(t8) {
    this._filter && !this._filter.filter(t8, this.zoom) || this._features.push(t8);
  }
  hasFeatures() {
    return this._features.length > 0;
  }
  getResources(t8, e3, s6) {
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/buckets/CircleBucket.js
var r6 = class extends t7 {
  constructor(t8, r8, i2, c5, s6) {
    super(t8, r8, i2), this.type = I.CIRCLE, this._circleVertexBuffer = c5, this._circleIndexBuffer = s6;
  }
  get circleIndexStart() {
    return this._circleIndexStart;
  }
  get circleIndexCount() {
    return this._circleIndexCount;
  }
  processFeatures(e3) {
    const t8 = this._circleVertexBuffer, r8 = this._circleIndexBuffer;
    this._circleIndexStart = 3 * r8.index, this._circleIndexCount = 0;
    const i2 = this.layer, c5 = this.zoom;
    e3 && e3.setExtent(this.layerExtent);
    for (const s6 of this._features) {
      const n6 = s6.getGeometry(e3);
      if (!n6)
        continue;
      const l4 = i2.circleMaterial.encodeAttributes(s6, c5, i2);
      for (const e4 of n6)
        if (e4)
          for (const i3 of e4) {
            const e5 = t8.index;
            t8.add(i3.x, i3.y, 0, 0, l4), t8.add(i3.x, i3.y, 0, 1, l4), t8.add(i3.x, i3.y, 1, 0, l4), t8.add(i3.x, i3.y, 1, 1, l4), r8.add(e5 + 0, e5 + 1, e5 + 2), r8.add(e5 + 1, e5 + 2, e5 + 3), this._circleIndexCount += 6;
          }
    }
  }
  serialize() {
    let e3 = 6;
    e3 += this.layerUIDs.length, e3 += this._circleVertexBuffer.array.length, e3 += this._circleIndexBuffer.array.length;
    const t8 = new Uint32Array(e3), r8 = new Int32Array(t8.buffer);
    let i2 = 0;
    t8[i2++] = this.type, t8[i2++] = this.layerUIDs.length;
    for (let c5 = 0; c5 < this.layerUIDs.length; c5++)
      t8[i2++] = this.layerUIDs[c5];
    t8[i2++] = this._circleIndexStart, t8[i2++] = this._circleIndexCount, t8[i2++] = this._circleVertexBuffer.array.length;
    for (let c5 = 0; c5 < this._circleVertexBuffer.array.length; c5++)
      r8[i2++] = this._circleVertexBuffer.array[c5];
    t8[i2++] = this._circleIndexBuffer.array.length;
    for (let c5 = 0; c5 < this._circleIndexBuffer.array.length; c5++)
      t8[i2++] = this._circleIndexBuffer.array[c5];
    return t8.buffer;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/buckets/FillBucket.js
var s4 = class extends t7 {
  constructor(t8, e3, i2, l4, n6, s6, o5) {
    super(t8, e3, i2), this.type = I.FILL, this._patternMap = /* @__PURE__ */ new Map(), this._fillVertexBuffer = l4, this._fillIndexBuffer = n6, this._outlineVertexBuffer = s6, this._outlineIndexBuffer = o5;
  }
  get fillIndexStart() {
    return this._fillIndexStart;
  }
  get fillIndexCount() {
    return this._fillIndexCount;
  }
  get outlineIndexStart() {
    return this._outlineIndexStart;
  }
  get outlineIndexCount() {
    return this._outlineIndexCount;
  }
  getResources(t8, e3, i2) {
    const r8 = this.layer, l4 = this.zoom, n6 = r8.getPaintProperty("fill-pattern");
    if (n6)
      if (n6.isDataDriven)
        for (const s6 of this._features)
          e3(n6.getValue(l4, s6), true);
      else
        e3(n6.getValue(l4), true);
  }
  processFeatures(t8) {
    this._fillIndexStart = 3 * this._fillIndexBuffer.index, this._fillIndexCount = 0, this._outlineIndexStart = 3 * this._outlineIndexBuffer.index, this._outlineIndexCount = 0;
    const e3 = this.layer, i2 = this.zoom, { fillMaterial: r8, outlineMaterial: l4, hasDataDrivenFill: n6, hasDataDrivenOutline: s6 } = e3;
    t8 && t8.setExtent(this.layerExtent);
    const o5 = e3.getPaintProperty("fill-pattern"), a7 = o5 == null ? void 0 : o5.isDataDriven;
    let f3 = !o5 && e3.getPaintValue("fill-antialias", i2);
    if (e3.outlineUsesFillColor) {
      if (f3 && !e3.hasDataDrivenOpacity) {
        const t9 = e3.getPaintValue("fill-opacity", i2), r9 = e3.getPaintValue("fill-opacity", i2 + 1);
        t9 < 1 && r9 < 1 && (f3 = false);
      }
      if (f3 && !e3.hasDataDrivenColor) {
        const t9 = e3.getPaintValue("fill-color", i2), r9 = e3.getPaintValue("fill-color", i2 + 1);
        t9[3] < 1 && r9[3] < 1 && (f3 = false);
      }
    }
    const u4 = this._features, d = t8 == null ? void 0 : t8.validateTessellation;
    if (a7) {
      const n7 = [];
      for (const a8 of u4) {
        const u5 = o5.getValue(i2, a8), h4 = this._spriteInfo[u5];
        if (!h4 || !h4.rect)
          continue;
        const x3 = r8.encodeAttributes(a8, i2, e3, h4), c5 = f3 && s6 ? l4.encodeAttributes(a8, i2, e3) : [], _2 = a8.getGeometry(t8);
        n7.push({ ddFillAttributes: x3, ddOutlineAttributes: c5, page: h4.page, geometry: _2 }), n7.sort((t9, e4) => t9.page - e4.page);
        for (const { ddFillAttributes: t9, ddOutlineAttributes: i3, page: r9, geometry: l5 } of n7)
          this._processFeature(l5, f3, e3.outlineUsesFillColor, t9, i3, d, r9);
      }
    } else
      for (const h4 of u4) {
        const o6 = n6 ? r8.encodeAttributes(h4, i2, e3) : null, a8 = f3 && s6 ? l4.encodeAttributes(h4, i2, e3) : null, u5 = h4.getGeometry(t8);
        this._processFeature(u5, f3, e3.outlineUsesFillColor, o6, a8, d);
      }
  }
  serialize() {
    let t8 = 10;
    t8 += this.layerUIDs.length, t8 += this._fillVertexBuffer.array.length, t8 += this._fillIndexBuffer.array.length, t8 += this._outlineVertexBuffer.array.length, t8 += this._outlineIndexBuffer.array.length, t8 += 3 * this._patternMap.size + 1;
    const e3 = new Uint32Array(t8), i2 = new Int32Array(e3.buffer);
    let r8 = 0;
    e3[r8++] = this.type, e3[r8++] = this.layerUIDs.length;
    for (let s6 = 0; s6 < this.layerUIDs.length; s6++)
      e3[r8++] = this.layerUIDs[s6];
    e3[r8++] = this._fillIndexStart, e3[r8++] = this._fillIndexCount, e3[r8++] = this._outlineIndexStart, e3[r8++] = this._outlineIndexCount;
    const l4 = this._patternMap, n6 = l4.size;
    if (e3[r8++] = n6, n6 > 0)
      for (const [s6, [o5, a7]] of l4)
        e3[r8++] = s6, e3[r8++] = o5, e3[r8++] = a7;
    e3[r8++] = this._fillVertexBuffer.array.length;
    for (let s6 = 0; s6 < this._fillVertexBuffer.array.length; s6++)
      i2[r8++] = this._fillVertexBuffer.array[s6];
    e3[r8++] = this._fillIndexBuffer.array.length;
    for (let s6 = 0; s6 < this._fillIndexBuffer.array.length; s6++)
      e3[r8++] = this._fillIndexBuffer.array[s6];
    e3[r8++] = this._outlineVertexBuffer.array.length;
    for (let s6 = 0; s6 < this._outlineVertexBuffer.array.length; s6++)
      i2[r8++] = this._outlineVertexBuffer.array[s6];
    e3[r8++] = this._outlineIndexBuffer.array.length;
    for (let s6 = 0; s6 < this._outlineIndexBuffer.array.length; s6++)
      e3[r8++] = this._outlineIndexBuffer.array[s6];
    return e3.buffer;
  }
  _processFeature(t8, e3, i2, r8, l4, n6, o5) {
    if (!t8)
      return;
    const a7 = t8.length, f3 = !l4 || 0 === l4.length;
    if (e3 && (!i2 || f3))
      for (let s6 = 0; s6 < a7; s6++)
        this._processOutline(t8[s6], l4);
    const u4 = 32;
    let d;
    for (let h4 = 0; h4 < a7; h4++) {
      const e4 = s4._area(t8[h4]);
      e4 > u4 ? (void 0 !== d && this._processFill(t8, d, r8, n6, o5), d = [h4]) : e4 < -u4 && void 0 !== d && d.push(h4);
    }
    void 0 !== d && this._processFill(t8, d, r8, n6, o5);
  }
  _processOutline(t8, e3) {
    const i2 = this._outlineVertexBuffer, r8 = this._outlineIndexBuffer, l4 = r8.index;
    let s6, o5, a7;
    const f3 = new t4(0, 0), u4 = new t4(0, 0), d = new t4(0, 0);
    let h4 = -1, x3 = -1, c5 = -1, _2 = -1, y2 = -1, g2 = false;
    const p4 = 0;
    let I5 = t8.length;
    if (I5 < 2)
      return;
    const B2 = t8[p4];
    let m3 = t8[I5 - 1];
    for (; I5 && m3.isEqual(B2); )
      --I5, m3 = t8[I5 - 1];
    if (!(I5 - p4 < 2)) {
      for (let l5 = p4; l5 < I5; ++l5) {
        l5 === p4 ? (s6 = t8[I5 - 1], o5 = t8[p4], a7 = t8[p4 + 1], f3.assignSub(o5, s6), f3.normalize(), f3.rightPerpendicular()) : (s6 = o5, o5 = a7, a7 = l5 !== I5 - 1 ? t8[l5 + 1] : t8[p4], f3.assign(u4));
        const n6 = this._isClipEdge(s6, o5);
        -1 === _2 && (g2 = n6), u4.assignSub(a7, o5), u4.normalize(), u4.rightPerpendicular();
        const B3 = f3.x * u4.y - f3.y * u4.x;
        d.assignAdd(f3, u4), d.normalize();
        const m4 = -d.x * -f3.x + -d.y * -f3.y;
        let V = Math.abs(0 !== m4 ? 1 / m4 : 1);
        V > 8 && (V = 8), B3 >= 0 ? (c5 = i2.add(o5.x, o5.y, f3.x, f3.y, 0, 1, e3), -1 === _2 && (_2 = c5), h4 >= 0 && x3 >= 0 && c5 >= 0 && !n6 && r8.add(h4, x3, c5), x3 = i2.add(o5.x, o5.y, V * -d.x, V * -d.y, 0, -1, e3), -1 === y2 && (y2 = x3), h4 >= 0 && x3 >= 0 && c5 >= 0 && !n6 && r8.add(h4, x3, c5), h4 = x3, x3 = c5, c5 = i2.add(o5.x, o5.y, d.x, d.y, 0, 1, e3), h4 >= 0 && x3 >= 0 && c5 >= 0 && !n6 && r8.add(h4, x3, c5), x3 = i2.add(o5.x, o5.y, u4.x, u4.y, 0, 1, e3), h4 >= 0 && x3 >= 0 && c5 >= 0 && !n6 && r8.add(h4, x3, c5)) : (c5 = i2.add(o5.x, o5.y, V * d.x, V * d.y, 0, 1, e3), -1 === _2 && (_2 = c5), h4 >= 0 && x3 >= 0 && c5 >= 0 && !n6 && r8.add(h4, x3, c5), x3 = i2.add(o5.x, o5.y, -f3.x, -f3.y, 0, -1, e3), -1 === y2 && (y2 = x3), h4 >= 0 && x3 >= 0 && c5 >= 0 && !n6 && r8.add(h4, x3, c5), h4 = x3, x3 = c5, c5 = i2.add(o5.x, o5.y, -d.x, -d.y, 0, -1, e3), h4 >= 0 && x3 >= 0 && c5 >= 0 && !n6 && r8.add(h4, x3, c5), h4 = i2.add(o5.x, o5.y, -u4.x, -u4.y, 0, -1, e3), h4 >= 0 && x3 >= 0 && c5 >= 0 && !n6 && r8.add(h4, x3, c5));
      }
      h4 >= 0 && x3 >= 0 && _2 >= 0 && !g2 && r8.add(h4, x3, _2), h4 >= 0 && _2 >= 0 && y2 >= 0 && !g2 && r8.add(h4, y2, _2), this._outlineIndexCount += 3 * (r8.index - l4);
    }
  }
  _processFill(r8, l4, n6, s6, o5) {
    s6 = true;
    let a7;
    l4.length > 1 && (a7 = []);
    let f3 = 0;
    for (const t8 of l4)
      0 !== f3 && a7.push(f3), f3 += r8[t8].length;
    const u4 = 2 * f3, d = t.acquire();
    for (const t8 of l4) {
      const e3 = r8[t8], i2 = e3.length;
      for (let t9 = 0; t9 < i2; ++t9)
        d.push(e3[t9].x, e3[t9].y);
    }
    const h4 = x(d, a7, 2);
    if (s6 && x.deviation(d, a7, 2, h4) > 0) {
      const t8 = l4.map((t9) => r8[t9].length), { buffer: e3, vertexCount: s7 } = r3(d, t8);
      if (s7 > 0) {
        const t9 = this._fillVertexBuffer.index;
        for (let i2 = 0; i2 < s7; i2++)
          this._fillVertexBuffer.add(e3[2 * i2], e3[2 * i2 + 1], n6);
        for (let e4 = 0; e4 < s7; e4 += 3) {
          const i2 = t9 + e4;
          this._fillIndexBuffer.add(i2, i2 + 1, i2 + 2);
        }
        if (void 0 !== o5) {
          const t10 = this._patternMap, e4 = t10.get(o5);
          e4 ? e4[1] += s7 : t10.set(o5, [this._fillIndexStart + this._fillIndexCount, s7]);
        }
        this._fillIndexCount += s7;
      }
    } else {
      const t8 = h4.length;
      if (t8 > 0) {
        const e3 = this._fillVertexBuffer.index;
        let i2 = 0;
        for (; i2 < u4; )
          this._fillVertexBuffer.add(d[i2++], d[i2++], n6);
        let r9 = 0;
        for (; r9 < t8; )
          this._fillIndexBuffer.add(e3 + h4[r9++], e3 + h4[r9++], e3 + h4[r9++]);
        if (void 0 !== o5) {
          const e4 = this._patternMap, i3 = e4.get(o5);
          i3 ? i3[1] += t8 : e4.set(o5, [this._fillIndexStart + this._fillIndexCount, t8]);
        }
        this._fillIndexCount += t8;
      }
    }
    t.release(d);
  }
  _isClipEdge(t8, e3) {
    return t8.x === e3.x ? t8.x <= -64 || t8.x >= 4160 : t8.y === e3.y && (t8.y <= -64 || t8.y >= 4160);
  }
  static _area(t8) {
    let e3 = 0;
    const i2 = t8.length - 1;
    for (let r8 = 0; r8 < i2; r8++)
      e3 += (t8[r8].x - t8[r8 + 1].x) * (t8[r8].y + t8[r8 + 1].y);
    return e3 += (t8[i2].x - t8[0].x) * (t8[i2].y + t8[0].y), 0.5 * e3;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/buckets/LineBucket.js
var s5 = 65535;
var n5 = class extends t7 {
  constructor(t8, s6, n6, a7, o5) {
    super(t8, s6, n6), this.type = I.LINE, this._tessellationOptions = { pixelCoordRatio: 8, halfWidth: 0, offset: 0 }, this._patternMap = /* @__PURE__ */ new Map(), this.tessellationProperties = { _lineVertexBuffer: null, _lineIndexBuffer: null, _ddValues: null }, this.tessellationProperties._lineVertexBuffer = a7, this.tessellationProperties._lineIndexBuffer = o5, this._lineTessellator = new c2(r7(this.tessellationProperties), l3(this.tessellationProperties), t8.canUseThinTessellation);
  }
  get lineIndexStart() {
    return this._lineIndexStart;
  }
  get lineIndexCount() {
    return this._lineIndexCount;
  }
  getResources(e3, t8, i2) {
    const s6 = this.layer, n6 = this.zoom, r8 = s6.getPaintProperty("line-pattern"), l4 = s6.getPaintProperty("line-dasharray"), a7 = s6.getLayoutProperty("line-cap");
    if (!r8 && !l4)
      return;
    const o5 = (a7 == null ? void 0 : a7.getValue(n6)) || 0, u4 = a7 == null ? void 0 : a7.isDataDriven, f3 = r8 == null ? void 0 : r8.isDataDriven, h4 = l4 == null ? void 0 : l4.isDataDriven;
    if (f3 || h4)
      for (const p4 of this._features)
        t8(f3 ? r8.getValue(n6, p4) : this._getDashArrayKey(p4, n6, s6, l4, u4, a7, o5));
    else if (r8)
      t8(r8.getValue(n6));
    else if (l4) {
      const e4 = l4.getValue(n6);
      t8(s6.getDashKey(e4, o5));
    }
  }
  processFeatures(e3) {
    this._lineIndexStart = 3 * this.tessellationProperties._lineIndexBuffer.index, this._lineIndexCount = 0;
    const t8 = this.layer, i2 = this.zoom, s6 = this._features, n6 = this._tessellationOptions, { hasDataDrivenLine: r8, lineMaterial: l4 } = t8;
    e3 && e3.setExtent(this.layerExtent);
    const a7 = t8.getPaintProperty("line-pattern"), o5 = t8.getPaintProperty("line-dasharray"), u4 = a7 == null ? void 0 : a7.isDataDriven, f3 = o5 == null ? void 0 : o5.isDataDriven;
    let h4;
    h4 = t8.getLayoutProperty("line-cap");
    const p4 = (h4 == null ? void 0 : h4.isDataDriven) ? h4 : null, g2 = p4 ? null : t8.getLayoutValue("line-cap", i2), y2 = g2 || 0, d = !!p4;
    h4 = t8.getLayoutProperty("line-join");
    const c5 = (h4 == null ? void 0 : h4.isDataDriven) ? h4 : null, _2 = c5 ? null : t8.getLayoutValue("line-join", i2);
    h4 = t8.getLayoutProperty("line-miter-limit");
    const x3 = (h4 == null ? void 0 : h4.isDataDriven) ? h4 : null, V = x3 ? null : t8.getLayoutValue("line-miter-limit", i2);
    h4 = t8.getLayoutProperty("line-round-limit");
    const m3 = (h4 == null ? void 0 : h4.isDataDriven) ? h4 : null, D = m3 ? null : t8.getLayoutValue("line-round-limit", i2);
    h4 = t8.getPaintProperty("line-width");
    const P2 = (h4 == null ? void 0 : h4.isDataDriven) ? h4 : null, I5 = P2 ? null : t8.getPaintValue("line-width", i2);
    h4 = t8.getPaintProperty("line-offset");
    const L2 = (h4 == null ? void 0 : h4.isDataDriven) ? h4 : null, B2 = L2 ? null : t8.getPaintValue("line-offset", i2);
    if (u4 || f3) {
      const r9 = [];
      for (const n7 of s6) {
        const s7 = u4 ? a7.getValue(i2, n7) : this._getDashArrayKey(n7, i2, t8, o5, d, p4, y2), f4 = this._spriteInfo[s7];
        if (!f4 || !f4.rect)
          continue;
        const h5 = l4.encodeAttributes(n7, i2, t8, f4), v = n7.getGeometry(e3);
        r9.push({ ddAttributes: h5, page: f4.page, cap: p4 ? p4.getValue(i2, n7) : g2, join: c5 ? c5.getValue(i2, n7) : _2, miterLimit: x3 ? x3.getValue(i2, n7) : V, roundLimit: m3 ? m3.getValue(i2, n7) : D, halfWidth: 0.5 * (P2 ? P2.getValue(i2, n7) : I5), offset: L2 ? L2.getValue(i2, n7) : B2, geometry: v });
      }
      r9.sort((e4, t9) => e4.page - t9.page), n6.textured = true;
      for (const { ddAttributes: e4, page: t9, cap: i3, join: s7, miterLimit: l5, roundLimit: a8, halfWidth: o6, offset: u5, geometry: f4 } of r9)
        n6.capType = i3, n6.joinType = s7, n6.miterLimit = l5, n6.roundLimit = a8, n6.halfWidth = o6, n6.offset = u5, this._processFeature(f4, e4, t9);
    } else {
      if (a7) {
        const e4 = a7.getValue(i2), t9 = this._spriteInfo[e4];
        if (!t9 || !t9.rect)
          return;
      }
      n6.textured = !(!a7 && !o5), n6.capType = g2, n6.joinType = _2, n6.miterLimit = V, n6.roundLimit = D, n6.halfWidth = 0.5 * I5, n6.offset = B2;
      for (const a8 of s6) {
        const s7 = r8 ? l4.encodeAttributes(a8, i2, t8) : null;
        p4 && (n6.capType = p4.getValue(i2, a8)), c5 && (n6.joinType = c5.getValue(i2, a8)), x3 && (n6.miterLimit = x3.getValue(i2, a8)), m3 && (n6.roundLimit = m3.getValue(i2, a8)), P2 && (n6.halfWidth = 0.5 * P2.getValue(i2, a8)), L2 && (n6.offset = L2.getValue(i2, a8));
        const o6 = a8.getGeometry(e3);
        this._processFeature(o6, s7);
      }
    }
  }
  serialize() {
    let e3 = 6;
    e3 += this.layerUIDs.length, e3 += this.tessellationProperties._lineVertexBuffer.array.length, e3 += this.tessellationProperties._lineIndexBuffer.array.length, e3 += 3 * this._patternMap.size + 1;
    const t8 = new Uint32Array(e3), i2 = new Int32Array(t8.buffer);
    let s6 = 0;
    t8[s6++] = this.type, t8[s6++] = this.layerUIDs.length;
    for (let l4 = 0; l4 < this.layerUIDs.length; l4++)
      t8[s6++] = this.layerUIDs[l4];
    t8[s6++] = this._lineIndexStart, t8[s6++] = this._lineIndexCount;
    const n6 = this._patternMap, r8 = n6.size;
    if (t8[s6++] = r8, r8 > 0)
      for (const [l4, [a7, o5]] of n6)
        t8[s6++] = l4, t8[s6++] = a7, t8[s6++] = o5;
    t8[s6++] = this.tessellationProperties._lineVertexBuffer.array.length;
    for (let l4 = 0; l4 < this.tessellationProperties._lineVertexBuffer.array.length; l4++)
      i2[s6++] = this.tessellationProperties._lineVertexBuffer.array[l4];
    t8[s6++] = this.tessellationProperties._lineIndexBuffer.array.length;
    for (let l4 = 0; l4 < this.tessellationProperties._lineIndexBuffer.array.length; l4++)
      t8[s6++] = this.tessellationProperties._lineIndexBuffer.array[l4];
    return t8.buffer;
  }
  _processFeature(e3, t8, i2) {
    if (!e3)
      return;
    const s6 = e3.length;
    for (let n6 = 0; n6 < s6; n6++)
      this._processGeometry(e3[n6], t8, i2);
  }
  _processGeometry(e3, t8, i2) {
    if (e3.length < 2)
      return;
    const n6 = 1e-3;
    let r8, l4, a7 = e3[0], o5 = 1;
    for (; o5 < e3.length; )
      r8 = e3[o5].x - a7.x, l4 = e3[o5].y - a7.y, r8 * r8 + l4 * l4 < n6 * n6 ? e3.splice(o5, 1) : (a7 = e3[o5], ++o5);
    if (e3.length < 2)
      return;
    const u4 = this.tessellationProperties._lineIndexBuffer, f3 = 3 * u4.index;
    this._tessellationOptions.initialDistance = 0, this._tessellationOptions.wrapDistance = s5, this.tessellationProperties._ddValues = t8, this._lineTessellator.tessellate(e3, this._tessellationOptions);
    const h4 = 3 * u4.index - f3;
    if (void 0 !== i2) {
      const e4 = this._patternMap, t9 = e4.get(i2);
      t9 ? t9[1] += h4 : e4.set(i2, [f3 + this._lineIndexCount, h4]);
    }
    this._lineIndexCount += h4;
  }
  _getDashArrayKey(e3, t8, i2, s6, n6, r8, l4) {
    const a7 = n6 ? r8.getValue(t8, e3) : l4, o5 = s6.getValue(t8, e3);
    return i2.getDashKey(o5, a7);
  }
};
var r7 = (e3) => (t8, i2, s6, n6, r8, l4, a7, o5, u4, f3, h4) => (e3._lineVertexBuffer.add(t8, i2, a7, o5, s6, n6, r8, l4, u4, f3, h4, e3._ddValues), e3._lineVertexBuffer.index - 1);
var l3 = (e3) => (t8, i2, s6) => {
  e3._lineIndexBuffer.add(t8, i2, s6);
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/buckets/SymbolBucket.js
var I3 = 10;
function b3(e3, t8) {
  return e3.iconMosaicItem && t8.iconMosaicItem ? e3.iconMosaicItem.page === t8.iconMosaicItem.page ? 0 : e3.iconMosaicItem.page - t8.iconMosaicItem.page : e3.iconMosaicItem && !t8.iconMosaicItem ? 1 : !e3.iconMosaicItem && t8.iconMosaicItem ? -1 : 0;
}
var A = class extends t7 {
  constructor(e3, t8, i2, s6, a7, o5, r8, l4) {
    super(e3, t8, l4.getSpriteItems()), this.type = I.SYMBOL, this._markerMap = /* @__PURE__ */ new Map(), this._glyphMap = /* @__PURE__ */ new Map(), this._glyphBufferDataStorage = /* @__PURE__ */ new Map(), this._isIconSDF = false, this._iconVertexBuffer = i2, this._iconIndexBuffer = s6, this._textVertexBuffer = a7, this._textIndexBuffer = o5, this._placementEngine = r8, this._workerTileHandler = l4;
  }
  get markerPageMap() {
    return this._markerMap;
  }
  get glyphsPageMap() {
    return this._glyphMap;
  }
  get symbolInstances() {
    return this._symbolInstances;
  }
  getResources(e3, n6, i2) {
    const s6 = this.layer, a7 = this.zoom;
    e3 && e3.setExtent(this.layerExtent);
    const o5 = s6.getLayoutProperty("icon-image"), r8 = s6.getLayoutProperty("text-field");
    let l4 = s6.getLayoutProperty("text-transform"), h4 = s6.getLayoutProperty("text-font");
    const x3 = [];
    let c5, g2, f3, y2;
    o5 && !o5.isDataDriven && (c5 = o5.getValue(a7)), r8 && !r8.isDataDriven && (g2 = r8.getValue(a7)), l4 && l4.isDataDriven || (f3 = s6.getLayoutValue("text-transform", a7), l4 = null), h4 && h4.isDataDriven || (y2 = s6.getLayoutValue("text-font", a7), h4 = null);
    for (const m3 of this._features) {
      const u4 = m3.getGeometry(e3);
      if (!u4 || 0 === u4.length)
        continue;
      let p4, _2;
      o5 && (p4 = o5.isDataDriven ? o5.getValue(a7, m3) : this._replaceKeys(c5, m3.values), p4 && n6(p4));
      let M = false;
      if (r8 && (_2 = r8.isDataDriven ? r8.getValue(a7, m3) : this._replaceKeys(g2, m3.values), _2)) {
        switch (_2 = _2.replace(/\\n/g, "\n"), l4 && (f3 = l4.getValue(a7, m3)), f3) {
          case o.LOWERCASE:
            _2 = _2.toLowerCase();
            break;
          case o.UPPERCASE:
            _2 = _2.toUpperCase();
        }
        if (A._bidiEngine.hasBidiChar(_2)) {
          let e5;
          e5 = "rtl" === A._bidiEngine.checkContextual(_2) ? "IDNNN" : "ICNNN", _2 = A._bidiEngine.bidiTransform(_2, e5, "VLYSN"), M = true;
        }
        const e4 = _2.length;
        if (e4 > 0) {
          h4 && (y2 = h4.getValue(a7, m3));
          for (const t8 of y2) {
            let n7 = i2[t8];
            n7 || (n7 = i2[t8] = /* @__PURE__ */ new Set());
            for (let t9 = 0; t9 < e4; t9++) {
              const e5 = _2.charCodeAt(t9);
              n7.add(e5);
            }
          }
        }
      }
      if (!p4 && !_2)
        continue;
      const P2 = s6.getLayoutValue("symbol-sort-key", a7, m3), I5 = { feature: m3, sprite: p4, label: _2, rtl: M, geometry: u4, hash: (_2 ? c(_2) : 0) ^ (p4 ? c(p4) : 0), priority: P2, textFont: y2 };
      x3.push(I5);
    }
    this._symbolFeatures = x3;
  }
  processFeatures(e3) {
    e3 && e3.setExtent(this.layerExtent);
    const t8 = this.layer, n6 = this.zoom, s6 = t8.getLayoutValue("symbol-placement", n6), a7 = s6 !== n2.POINT, c5 = t8.getLayoutValue("symbol-spacing", n6) * w, d = t8.getLayoutProperty("icon-image"), P2 = t8.getLayoutProperty("text-field"), I5 = d ? new T(t8, n6, a7) : null, L2 = P2 ? new m2(t8, n6, a7) : null, V = this._workerTileHandler;
    let T4;
    d && (T4 = V.getSpriteItems()), this._iconIndexStart = 3 * this._iconIndexBuffer.index, this._textIndexStart = 3 * this._textIndexBuffer.index, this._iconIndexCount = 0, this._textIndexCount = 0, this._markerMap.clear(), this._glyphMap.clear();
    const w3 = [];
    let B2 = 1;
    L2 && L2.size && (B2 = L2.size / c4);
    const C2 = L2 ? L2.maxAngle * f : 0, R = L2 ? L2.size * w : 0;
    for (const i2 of this._symbolFeatures) {
      let e4;
      I5 && T4 && i2.sprite && (e4 = T4[i2.sprite], e4 && e4.sdf && (this._isIconSDF = true));
      let t9;
      !!e4 && I5.update(n6, i2.feature);
      let d2 = 0;
      const p4 = i2.label;
      if (p4) {
        L2.update(n6, i2.feature);
        const e5 = a7 && L2.rotationAlignment === l.MAP ? L2.keepUpright : L2.writingMode && L2.writingMode.includes(p2.VERTICAL);
        let s7 = 0.5;
        switch (L2.anchor) {
          case m.TOP_LEFT:
          case m.LEFT:
          case m.BOTTOM_LEFT:
            s7 = 0;
            break;
          case m.TOP_RIGHT:
          case m.RIGHT:
          case m.BOTTOM_RIGHT:
            s7 = 1;
        }
        let r8 = 0.5;
        switch (L2.anchor) {
          case m.TOP_LEFT:
          case m.TOP:
          case m.TOP_RIGHT:
            r8 = 0;
            break;
          case m.BOTTOM_LEFT:
          case m.BOTTOM:
          case m.BOTTOM_RIGHT:
            r8 = 1;
        }
        let l4 = 0.5;
        switch (L2.justify) {
          case u.AUTO:
            l4 = s7;
            break;
          case u.LEFT:
            l4 = 0;
            break;
          case u.RIGHT:
            l4 = 1;
        }
        const c6 = L2.letterSpacing * c4, g2 = a7 ? 0 : L2.maxWidth * c4, _2 = L2.lineHeight * c4, M = i2.textFont.map((e6) => V.getGlyphItems(e6));
        if (t9 = new a4(M, g2, _2, c6, s7, r8, l4).getShaping(p4, i2.rtl, e5), t9 && t9.length > 0) {
          let e6 = 1e30, n7 = -1e30;
          for (const i3 of t9)
            e6 = Math.min(e6, i3.x), n7 = Math.max(n7, i3.x);
          d2 = (n7 - e6 + 2 * c4) * B2 * w;
        }
      }
      for (let n7 of i2.geometry) {
        const h4 = [];
        if (s6 === n2.LINE) {
          if (t9 && t9.length > 0 && L2 && L2.size) {
            const e5 = L2.size * w * (2 + Math.min(2, 4 * Math.abs(L2.offset[1])));
            n7 = A._smoothVertices(n7, e5);
          }
          A._pushAnchors(h4, n7, c5, d2);
        } else
          s6 === n2.LINE_CENTER ? A._pushCenterAnchor(h4, n7) : i2.feature.type === s.Polygon ? A._pushCentroid(h4, n7) : h4.push(new T2(n7[0].x, n7[0].y));
        for (const s7 of h4) {
          if (s7.x < 0 || s7.x > x2 || s7.y < 0 || s7.y > x2)
            continue;
          if (a7 && d2 > 0 && L2.rotationAlignment === l.MAP && !A._honorsTextMaxAngle(n7, s7, d2, C2, R))
            continue;
          const o5 = { shaping: t9, line: n7, iconMosaicItem: e4, anchor: s7, symbolFeature: i2, textColliders: [], iconColliders: [], textVertexRanges: [], iconVertexRanges: [] };
          w3.push(o5), this._processFeature(o5, I5, L2);
        }
      }
    }
    w3.sort(b3), this._addPlacedGlyphs(), this._symbolInstances = w3;
  }
  serialize() {
    let e3 = 11;
    e3 += this.layerUIDs.length, e3 += 3 * this.markerPageMap.size, e3 += 3 * this.glyphsPageMap.size, e3 += A._symbolsSerializationLength(this._symbolInstances), e3 += this._iconVertexBuffer.array.length, e3 += this._iconIndexBuffer.array.length, e3 += this._textVertexBuffer.array.length, e3 += this._textIndexBuffer.array.length;
    const t8 = new Uint32Array(e3), n6 = new Int32Array(t8.buffer), i2 = new Float32Array(t8.buffer);
    let s6 = 0;
    t8[s6++] = this.type, t8[s6++] = this.layerUIDs.length;
    for (let a7 = 0; a7 < this.layerUIDs.length; a7++)
      t8[s6++] = this.layerUIDs[a7];
    t8[s6++] = this._isIconSDF ? 1 : 0, t8[s6++] = this.markerPageMap.size;
    for (const [a7, [o5, r8]] of this.markerPageMap)
      t8[s6++] = a7, t8[s6++] = o5, t8[s6++] = r8;
    t8[s6++] = this.glyphsPageMap.size;
    for (const [a7, [o5, r8]] of this.glyphsPageMap)
      t8[s6++] = a7, t8[s6++] = o5, t8[s6++] = r8;
    t8[s6++] = this._iconVertexBuffer.index / 4, t8[s6++] = this._textVertexBuffer.index / 4, s6 = A.serializeSymbols(t8, n6, i2, s6, this._symbolInstances), t8[s6++] = this._iconVertexBuffer.array.length;
    for (let a7 = 0; a7 < this._iconVertexBuffer.array.length; a7++)
      n6[s6++] = this._iconVertexBuffer.array[a7];
    t8[s6++] = this._iconIndexBuffer.array.length;
    for (let a7 = 0; a7 < this._iconIndexBuffer.array.length; a7++)
      t8[s6++] = this._iconIndexBuffer.array[a7];
    t8[s6++] = this._textVertexBuffer.array.length;
    for (let a7 = 0; a7 < this._textVertexBuffer.array.length; a7++)
      n6[s6++] = this._textVertexBuffer.array[a7];
    t8[s6++] = this._textIndexBuffer.array.length;
    for (let a7 = 0; a7 < this._textIndexBuffer.array.length; a7++)
      t8[s6++] = this._textIndexBuffer.array[a7];
    return t8.buffer;
  }
  static _symbolsSerializationLength(e3) {
    let t8 = 0;
    t8 += 1;
    for (const n6 of e3 || []) {
      t8 += 4, t8 += 1;
      for (const e4 of n6.textColliders)
        t8 += I3;
      for (const e4 of n6.iconColliders)
        t8 += I3;
      t8 += 1, t8 += 2 * n6.textVertexRanges.length, t8 += 1, t8 += 2 * n6.iconVertexRanges.length;
    }
    return t8;
  }
  static serializeSymbols(e3, t8, n6, i2, s6) {
    s6 = s6 || [], t8[i2++] = s6.length;
    for (const a7 of s6) {
      t8[i2++] = a7.anchor.x, t8[i2++] = a7.anchor.y, t8[i2++] = a7.symbolFeature.hash, t8[i2++] = a7.symbolFeature.priority, t8[i2++] = a7.textColliders.length + a7.iconColliders.length;
      for (const e4 of a7.textColliders)
        t8[i2++] = e4.xTile, t8[i2++] = e4.yTile, t8[i2++] = e4.dxPixels, t8[i2++] = e4.dyPixels, t8[i2++] = e4.hard ? 1 : 0, t8[i2++] = e4.partIndex, n6[i2++] = e4.minLod, n6[i2++] = e4.maxLod, t8[i2++] = e4.width, t8[i2++] = e4.height;
      for (const e4 of a7.iconColliders)
        t8[i2++] = e4.xTile, t8[i2++] = e4.yTile, t8[i2++] = e4.dxPixels, t8[i2++] = e4.dyPixels, t8[i2++] = e4.hard ? 1 : 0, t8[i2++] = e4.partIndex, n6[i2++] = e4.minLod, n6[i2++] = e4.maxLod, t8[i2++] = e4.width, t8[i2++] = e4.height;
      t8[i2++] = a7.textVertexRanges.length;
      for (const [e4, n7] of a7.textVertexRanges)
        t8[i2++] = e4, t8[i2++] = n7;
      t8[i2++] = a7.iconVertexRanges.length;
      for (const [e4, n7] of a7.iconVertexRanges)
        t8[i2++] = e4, t8[i2++] = n7;
    }
    return i2;
  }
  _replaceKeys(e3, t8) {
    return e3.replace(/{([^{}]+)}/g, (e4, n6) => n6 in t8 ? t8[n6] : "");
  }
  _processFeature(e3, t8, n6) {
    const { line: i2, iconMosaicItem: a7, shaping: o5, anchor: r8 } = e3, l4 = this.zoom, h4 = this.layer, x3 = !!a7;
    let c5 = true;
    x3 && (c5 = t8.optional || !a7);
    const d = o5 && o5.length > 0;
    let g2, y2, m3 = true;
    if (d && (m3 = n6.optional), x3 && (g2 = this._placementEngine.getIconPlacement(r8, a7, t8)), (g2 || c5) && (d && (y2 = this._placementEngine.getTextPlacement(r8, o5, i2, n6)), y2 || m3)) {
      if (g2 && y2 || (m3 || c5 ? m3 || y2 ? c5 || g2 || (y2 = null) : g2 = null : (g2 = null, y2 = null)), y2) {
        const t9 = h4.hasDataDrivenText ? h4.textMaterial.encodeAttributes(e3.symbolFeature.feature, l4, h4) : null;
        if (this._storePlacedGlyphs(e3, y2.shapes, l4, n6.rotationAlignment, t9), y2.textColliders) {
          e3.textColliders = y2.textColliders;
          for (const e4 of y2.textColliders) {
            e4.minLod = Math.max(l4 + P(e4.minLod), 0), e4.maxLod = Math.min(l4 + P(e4.maxLod), 25);
            const t10 = e4.angle;
            if (t10) {
              const n7 = Math.cos(t10), i3 = Math.sin(t10), s6 = e4.dxPixels * n7 - e4.dyPixels * i3, a8 = e4.dxPixels * i3 + e4.dyPixels * n7, o6 = (e4.dxPixels + e4.width) * n7 - e4.dyPixels * i3, r9 = (e4.dxPixels + e4.width) * i3 + e4.dyPixels * n7, l5 = e4.dxPixels * n7 - (e4.dyPixels + e4.height) * i3, h5 = e4.dxPixels * i3 + (e4.dyPixels + e4.height) * n7, x4 = (e4.dxPixels + e4.width) * n7 - (e4.dyPixels + e4.height) * i3, c6 = (e4.dxPixels + e4.width) * i3 + (e4.dyPixels + e4.height) * n7, d2 = Math.min(s6, o6, l5, x4), g3 = Math.max(s6, o6, l5, x4), f3 = Math.min(a8, r9, h5, c6), y3 = Math.max(a8, r9, h5, c6);
              e4.dxPixels = d2, e4.dyPixels = f3, e4.width = g3 - d2, e4.height = y3 - f3;
            }
          }
        }
      }
      if (g2) {
        const n7 = h4.hasDataDrivenIcon ? h4.iconMaterial.encodeAttributes(e3.symbolFeature.feature, l4, h4) : null;
        if (this._addPlacedIcons(e3, g2.shapes, l4, a7.page, t8.rotationAlignment === l.VIEWPORT, n7), g2.iconColliders) {
          e3.iconColliders = g2.iconColliders;
          for (const e4 of g2.iconColliders) {
            e4.minLod = Math.max(l4 + P(e4.minLod), 0), e4.maxLod = Math.min(l4 + P(e4.maxLod), 25);
            const t9 = e4.angle;
            if (t9) {
              const n8 = Math.cos(t9), i3 = Math.sin(t9), s6 = e4.dxPixels * n8 - e4.dyPixels * i3, a8 = e4.dxPixels * i3 + e4.dyPixels * n8, o6 = (e4.dxPixels + e4.width) * n8 - e4.dyPixels * i3, r9 = (e4.dxPixels + e4.width) * i3 + e4.dyPixels * n8, l5 = e4.dxPixels * n8 - (e4.dyPixels + e4.height) * i3, h5 = e4.dxPixels * i3 + (e4.dyPixels + e4.height) * n8, x4 = (e4.dxPixels + e4.width) * n8 - (e4.dyPixels + e4.height) * i3, c6 = (e4.dxPixels + e4.width) * i3 + (e4.dyPixels + e4.height) * n8, d2 = Math.min(s6, o6, l5, x4), g3 = Math.max(s6, o6, l5, x4), f3 = Math.min(a8, r9, h5, c6), y3 = Math.max(a8, r9, h5, c6);
              e4.dxPixels = d2, e4.dyPixels = f3, e4.width = g3 - d2, e4.height = y3 - f3;
            }
          }
        }
      }
    }
  }
  _addPlacedIcons(e3, t8, n6, i2, a7, o5) {
    const r8 = Math.max(n6 - 1, 0), l4 = this._iconVertexBuffer, h4 = this._iconIndexBuffer, x3 = this._markerMap;
    for (const c5 of t8) {
      const t9 = a7 ? 0 : Math.max(n6 + P(c5.minzoom), r8), d = a7 ? 25 : Math.min(n6 + P(c5.maxzoom), 25);
      if (d <= t9)
        continue;
      const g2 = c5.tl, f3 = c5.tr, y2 = c5.bl, m3 = c5.br, u4 = c5.mosaicRect, p4 = c5.labelAngle, _2 = c5.minAngle, M = c5.maxAngle, P2 = c5.anchor, I5 = l4.index, b4 = u4.x, A2 = u4.y, L2 = b4 + u4.width, V = A2 + u4.height, T4 = l4.index;
      l4.add(P2.x, P2.y, g2.x, g2.y, b4, A2, p4, _2, M, t9, d, o5), l4.add(P2.x, P2.y, f3.x, f3.y, L2, A2, p4, _2, M, t9, d, o5), l4.add(P2.x, P2.y, y2.x, y2.y, b4, V, p4, _2, M, t9, d, o5), l4.add(P2.x, P2.y, m3.x, m3.y, L2, V, p4, _2, M, t9, d, o5), e3.iconVertexRanges.length > 0 && e3.iconVertexRanges[0][0] + e3.iconVertexRanges[0][1] === T4 ? e3.iconVertexRanges[0][1] += 4 : e3.iconVertexRanges.push([T4, 4]), h4.add(I5 + 0, I5 + 1, I5 + 2), h4.add(I5 + 1, I5 + 2, I5 + 3), x3.has(i2) ? x3.get(i2)[1] += 6 : x3.set(i2, [this._iconIndexStart + this._iconIndexCount, 6]), this._iconIndexCount += 6;
    }
  }
  _addPlacedGlyphs() {
    const e3 = this._textVertexBuffer, t8 = this._textIndexBuffer, n6 = this._glyphMap;
    for (const [i2, s6] of this._glyphBufferDataStorage)
      for (const a7 of s6) {
        const s7 = e3.index, o5 = a7.symbolInstance, r8 = a7.ddAttributes, l4 = e3.index;
        e3.add(a7.glyphAnchor[0], a7.glyphAnchor[1], a7.tl[0], a7.tl[1], a7.xmin, a7.ymin, a7.labelAngle, a7.minAngle, a7.maxAngle, a7.minLod, a7.maxLod, r8), e3.add(a7.glyphAnchor[0], a7.glyphAnchor[1], a7.tr[0], a7.tr[1], a7.xmax, a7.ymin, a7.labelAngle, a7.minAngle, a7.maxAngle, a7.minLod, a7.maxLod, r8), e3.add(a7.glyphAnchor[0], a7.glyphAnchor[1], a7.bl[0], a7.bl[1], a7.xmin, a7.ymax, a7.labelAngle, a7.minAngle, a7.maxAngle, a7.minLod, a7.maxLod, r8), e3.add(a7.glyphAnchor[0], a7.glyphAnchor[1], a7.br[0], a7.br[1], a7.xmax, a7.ymax, a7.labelAngle, a7.minAngle, a7.maxAngle, a7.minLod, a7.maxLod, r8), o5.textVertexRanges.length > 0 && o5.textVertexRanges[0][0] + o5.textVertexRanges[0][1] === l4 ? o5.textVertexRanges[0][1] += 4 : o5.textVertexRanges.push([l4, 4]), t8.add(s7 + 0, s7 + 1, s7 + 2), t8.add(s7 + 1, s7 + 2, s7 + 3), n6.has(i2) ? n6.get(i2)[1] += 6 : n6.set(i2, [this._textIndexStart + this._textIndexCount, 6]), this._textIndexCount += 6;
      }
    this._glyphBufferDataStorage.clear();
  }
  _storePlacedGlyphs(e3, t8, n6, i2, a7) {
    const o5 = Math.max(n6 - 1, 0), r8 = i2 === l.VIEWPORT;
    let l4, h4, x3, c5, d, g2, y2, m3, u4, p4, _2;
    for (const f3 of t8) {
      if (l4 = r8 ? 0 : Math.max(n6 + P(f3.minzoom), o5), h4 = r8 ? 25 : Math.min(n6 + P(f3.maxzoom), 25), h4 <= l4)
        continue;
      x3 = f3.tl, c5 = f3.tr, d = f3.bl, g2 = f3.br, y2 = f3.labelAngle, m3 = f3.minAngle, u4 = f3.maxAngle, p4 = f3.anchor, _2 = f3.mosaicRect, this._glyphBufferDataStorage.has(f3.page) || this._glyphBufferDataStorage.set(f3.page, []);
      this._glyphBufferDataStorage.get(f3.page).push({ glyphAnchor: [p4.x, p4.y], tl: [x3.x, x3.y], tr: [c5.x, c5.y], bl: [d.x, d.y], br: [g2.x, g2.y], xmin: _2.x, ymin: _2.y, xmax: _2.x + _2.width, ymax: _2.y + _2.height, labelAngle: y2, minAngle: m3, maxAngle: u4, minLod: l4, maxLod: h4, placementLod: o5, symbolInstance: e3, ddAttributes: a7 });
    }
  }
  static _pushAnchors(e3, t8, n6, i2) {
    n6 += i2;
    let s6 = 0;
    const o5 = t8.length - 1;
    for (let a7 = 0; a7 < o5; a7++)
      s6 += t4.distance(t8[a7], t8[a7 + 1]);
    let l4 = i2 || n6;
    if (l4 *= 0.5, s6 <= l4)
      return;
    const h4 = l4 / s6;
    let x3 = 0, c5 = -(n6 = s6 / Math.max(Math.round(s6 / n6), 1)) / 2;
    const d = t8.length - 1;
    for (let g2 = 0; g2 < d; g2++) {
      const i3 = t8[g2], s7 = t8[g2 + 1], o6 = s7.x - i3.x, l5 = s7.y - i3.y, d2 = Math.sqrt(o6 * o6 + l5 * l5);
      let f3;
      for (; c5 + n6 < x3 + d2; ) {
        c5 += n6;
        const t9 = (c5 - x3) / d2, y2 = b(i3.x, s7.x, t9), m3 = b(i3.y, s7.y, t9);
        void 0 === f3 && (f3 = Math.atan2(l5, o6)), e3.push(new T2(y2, m3, f3, g2, h4));
      }
      x3 += d2;
    }
  }
  static _pushCenterAnchor(e3, t8) {
    let n6 = 0;
    const i2 = t8.length - 1;
    for (let a7 = 0; a7 < i2; a7++)
      n6 += t4.distance(t8[a7], t8[a7 + 1]);
    const s6 = n6 / 2;
    let o5 = 0;
    const l4 = t8.length - 1;
    for (let h4 = 0; h4 < l4; h4++) {
      const n7 = t8[h4], i3 = t8[h4 + 1], l5 = i3.x - n7.x, x3 = i3.y - n7.y, c5 = Math.sqrt(l5 * l5 + x3 * x3);
      if (s6 < o5 + c5) {
        const t9 = (s6 - o5) / c5, d = b(n7.x, i3.x, t9), g2 = b(n7.y, i3.y, t9), f3 = Math.atan2(x3, l5);
        return void e3.push(new T2(d, g2, f3, h4, 0));
      }
      o5 += c5;
    }
  }
  static _deviation(e3, t8, n6) {
    const i2 = (t8.x - e3.x) * (n6.x - t8.x) + (t8.y - e3.y) * (n6.y - t8.y), s6 = (t8.x - e3.x) * (n6.y - t8.y) - (t8.y - e3.y) * (n6.x - t8.x);
    return Math.atan2(s6, i2);
  }
  static _honorsTextMaxAngle(e3, t8, n6, i2, s6) {
    let a7 = 0;
    const o5 = n6 / 2;
    let r8 = new t4(t8.x, t8.y), l4 = t8.segment + 1;
    for (; a7 > -o5; ) {
      if (--l4, l4 < 0)
        return false;
      a7 -= t4.distance(e3[l4], r8), r8 = e3[l4];
    }
    a7 += t4.distance(e3[l4], e3[l4 + 1]);
    const h4 = [];
    let x3 = 0;
    const c5 = e3.length;
    for (; a7 < o5; ) {
      const t9 = e3[l4];
      let n7, o6 = l4;
      do {
        if (++o6, o6 === c5)
          return false;
        n7 = e3[o6];
      } while (n7.isEqual(t9));
      let r9, d = o6;
      do {
        if (++d, d === c5)
          return false;
        r9 = e3[d];
      } while (r9.isEqual(n7));
      const g2 = this._deviation(t9, n7, r9);
      for (h4.push({ deviation: g2, distToAnchor: a7 }), x3 += g2; a7 - h4[0].distToAnchor > s6; )
        x3 -= h4.shift().deviation;
      if (Math.abs(x3) > i2)
        return false;
      a7 += t4.distance(n7, r9), l4 = o6;
    }
    return true;
  }
  static _smoothVertices(e3, t8) {
    if (t8 <= 0)
      return e3;
    let n6 = e3.length;
    if (n6 < 3)
      return e3;
    const i2 = [];
    let s6 = 0, a7 = 0;
    i2.push(0);
    for (let f3 = 1; f3 < n6; f3++) {
      const t9 = t4.distance(e3[f3], e3[f3 - 1]);
      t9 > 0 && (s6 += t9, i2.push(s6), a7++, a7 !== f3 && (e3[a7] = e3[f3]));
    }
    if (n6 = a7 + 1, n6 < 3)
      return e3;
    t8 = Math.min(t8, 0.2 * s6);
    const o5 = e3[0].x, r8 = e3[0].y, l4 = e3[n6 - 1].x, h4 = e3[n6 - 1].y, x3 = t4.sub(e3[0], e3[1]);
    x3.normalize(), e3[0].x += t8 * x3.x, e3[0].y += t8 * x3.y, x3.assignSub(e3[n6 - 1], e3[n6 - 2]), x3.normalize(), e3[n6 - 1].x += t8 * x3.x, e3[n6 - 1].y += t8 * x3.y, i2[0] -= t8, i2[n6 - 1] += t8;
    const c5 = [];
    c5.push(new t4(o5, r8));
    const d = 1e-6, g2 = 0.5 * t8;
    for (let f3 = 1; f3 < n6 - 1; f3++) {
      let s7 = 0, a8 = 0, o6 = 0;
      for (let n7 = f3 - 1; n7 >= 0; n7--) {
        const r9 = g2 + i2[n7 + 1] - i2[f3];
        if (r9 < 0)
          break;
        const l5 = i2[n7 + 1] - i2[n7], h5 = i2[f3] - i2[n7] < g2 ? 1 : r9 / l5;
        if (h5 < d)
          break;
        const x4 = h5 * h5, c6 = h5 * r9 - 0.5 * x4 * l5, y2 = h5 * l5 / t8, m3 = e3[n7 + 1], u4 = e3[n7].x - m3.x, p4 = e3[n7].y - m3.y;
        s7 += y2 / c6 * (m3.x * h5 * r9 + 0.5 * x4 * (r9 * u4 - l5 * m3.x) - x4 * h5 * l5 * u4 / 3), a8 += y2 / c6 * (m3.y * h5 * r9 + 0.5 * x4 * (r9 * p4 - l5 * m3.y) - x4 * h5 * l5 * p4 / 3), o6 += y2;
      }
      for (let r9 = f3 + 1; r9 < n6; r9++) {
        const n7 = g2 - i2[r9 - 1] + i2[f3];
        if (n7 < 0)
          break;
        const l5 = i2[r9] - i2[r9 - 1], h5 = i2[r9] - i2[f3] < g2 ? 1 : n7 / l5;
        if (h5 < d)
          break;
        const x4 = h5 * h5, c6 = h5 * n7 - 0.5 * x4 * l5, y2 = h5 * l5 / t8, m3 = e3[r9 - 1], u4 = e3[r9].x - m3.x, p4 = e3[r9].y - m3.y;
        s7 += y2 / c6 * (m3.x * h5 * n7 + 0.5 * x4 * (n7 * u4 - l5 * m3.x) - x4 * h5 * l5 * u4 / 3), a8 += y2 / c6 * (m3.y * h5 * n7 + 0.5 * x4 * (n7 * p4 - l5 * m3.y) - x4 * h5 * l5 * p4 / 3), o6 += y2;
      }
      c5.push(new t4(s7 / o6, a8 / o6));
    }
    return c5.push(new t4(l4, h4)), e3[0].x = o5, e3[0].y = r8, e3[n6 - 1].x = l4, e3[n6 - 1].y = h4, c5;
  }
  static _pushCentroid(e3, t8) {
    const n6 = 0, i2 = 0, s6 = 4096, a7 = 4096, o5 = t8.length - 1;
    let l4 = 0, h4 = 0, x3 = 0, c5 = t8[0].x, d = t8[0].y;
    c5 > s6 && (c5 = s6), c5 < n6 && (c5 = n6), d > a7 && (d = a7), d < i2 && (d = i2);
    for (let r8 = 1; r8 < o5; r8++) {
      let e4 = t8[r8].x, o6 = t8[r8].y, g2 = t8[r8 + 1].x, f3 = t8[r8 + 1].y;
      e4 > s6 && (e4 = s6), e4 < n6 && (e4 = n6), o6 > a7 && (o6 = a7), o6 < i2 && (o6 = i2), g2 > s6 && (g2 = s6), g2 < n6 && (g2 = n6), f3 > a7 && (f3 = a7), f3 < i2 && (f3 = i2);
      const y2 = (e4 - c5) * (f3 - d) - (g2 - c5) * (o6 - d);
      l4 += y2 * (c5 + e4 + g2), h4 += y2 * (d + o6 + f3), x3 += y2;
    }
    l4 /= 3 * x3, h4 /= 3 * x3, isNaN(l4) || isNaN(h4) || e3.push(new T2(l4, h4));
  }
};
A._bidiEngine = new C();

// node_modules/@arcgis/core/views/2d/tiling/enums.js
var I4;
!function(I5) {
  I5[I5.INITIALIZED = 0] = "INITIALIZED", I5[I5.NO_DATA = 1] = "NO_DATA", I5[I5.READY = 2] = "READY", I5[I5.MODIFIED = 3] = "MODIFIED", I5[I5.INVALID = 4] = "INVALID";
}(I4 || (I4 = {}));

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileParser.js
var T3 = 8;
var g = 14;
var w2 = 5;
var B = class {
  constructor(t8, r8, s6, i2, o5) {
    if (this._pbfTiles = {}, this._tileClippers = {}, this._client = s6, this._tile = r8, o5) {
      this._styleLayerUIDs = /* @__PURE__ */ new Set();
      for (const e3 of o5)
        this._styleLayerUIDs.add(e3);
    }
    this._styleRepository = i2, this._layers = this._styleRepository.layers;
    const [n6, c5, l4] = r8.tileKey.split("/").map(parseFloat);
    this._level = n6;
    const a7 = T3 + Math.max((this._level - g) * w2, 0);
    for (const u4 of Object.keys(t8)) {
      const r9 = t8[u4];
      this._pbfTiles[u4] = new n(new Uint8Array(r9.protobuff), new DataView(r9.protobuff));
      if (r9.refKey) {
        const [e3] = r9.refKey.split("/").map(parseFloat), t9 = n6 - e3;
        if (t9 > 0) {
          const e4 = (1 << t9) - 1, r10 = c5 & e4, s7 = l4 & e4;
          this._tileClippers[u4] = new n4(t9, r10, s7, 8, a7);
        }
      }
      this._tileClippers[u4] || (this._tileClippers[u4] = new _());
    }
  }
  _canParseStyleLayer(e3) {
    return !this._styleLayerUIDs || this._styleLayerUIDs.has(e3);
  }
  async parse(e3) {
    const t8 = i(), s6 = this._initialize(e3), { returnedBuckets: i2 } = s6;
    this._processLayers(s6), this._linkReferences(s6), this._filterFeatures(s6);
    const o5 = [], n6 = /* @__PURE__ */ new Set(), c5 = (e4, t9) => {
      n6.has(e4) || (o5.push({ name: e4, repeat: t9 }), n6.add(e4));
    }, l4 = {};
    for (const r8 of i2)
      r8.getResources(r8.tileClipper, c5, l4);
    if (this._tile.status === I4.INVALID)
      return [];
    const a7 = this._fetchResources(o5, l4, e3);
    return Promise.all([...a7, t8]).then(() => this._processFeatures(s6.returnedBuckets));
  }
  _initialize(e3) {
    return { signal: e3 && e3.signal, sourceNameToTileData: this._parseTileData(this._pbfTiles), layers: this._layers, zoom: this._level, sourceNameToTileClipper: this._tileClippers, sourceNameToUniqueSourceLayerBuckets: {}, sourceNameToUniqueSourceLayers: {}, returnedBuckets: [], layerIdToBucket: {}, referencerUIDToReferencedId: /* @__PURE__ */ new Map() };
  }
  _processLayers(e3) {
    const { sourceNameToTileData: t8, layers: r8, zoom: s6, sourceNameToTileClipper: i2, sourceNameToUniqueSourceLayerBuckets: o5, sourceNameToUniqueSourceLayers: n6, returnedBuckets: c5, layerIdToBucket: l4, referencerUIDToReferencedId: a7 } = e3;
    for (let u4 = r8.length - 1; u4 >= 0; u4--) {
      const e4 = r8[u4];
      if (!this._canParseStyleLayer(e4.uid) || e4.minzoom && s6 < Math.floor(e4.minzoom) || e4.maxzoom && s6 >= e4.maxzoom || e4.type === a.BACKGROUND)
        continue;
      if (!t8[e4.source] || !i2[e4.source])
        continue;
      const f3 = t8[e4.source], p4 = i2[e4.source], h4 = e4.sourceLayer, m3 = f3[h4];
      if (m3) {
        let t9 = n6[e4.source];
        if (t9 || (t9 = n6[e4.source] = /* @__PURE__ */ new Set()), t9.add(e4.sourceLayer), e4.refLayerId)
          a7.set(e4.uid, e4.refLayerId);
        else {
          const t10 = this._createBucket(e4);
          if (t10) {
            t10.layerUIDs = [e4.uid], t10.layerExtent = m3.extent, t10.tileClipper = p4;
            let r9 = o5[e4.source];
            r9 || (r9 = o5[e4.source] = {});
            let s7 = r9[h4];
            s7 || (s7 = r9[h4] = []), s7.push(t10), c5.push(t10), l4[e4.id] = t10;
          }
        }
      }
    }
  }
  _linkReferences(e3) {
    const { layerIdToBucket: t8, referencerUIDToReferencedId: r8 } = e3;
    r8.forEach((e4, r9) => {
      t8[e4] && t8[e4].layerUIDs.push(r9);
    });
  }
  _filterFeatures(e3) {
    const { signal: r8, sourceNameToTileData: i2, sourceNameToUniqueSourceLayerBuckets: o5, sourceNameToUniqueSourceLayers: n6 } = e3, c5 = 10 * this._level, l4 = 10 * (this._level + 1), a7 = [], u4 = [];
    for (const t8 of Object.keys(n6)) {
      n6[t8].forEach((e4) => {
        a7.push(e4), u4.push(t8);
      });
    }
    for (let f3 = 0; f3 < a7.length; f3++) {
      const e4 = u4[f3], n7 = a7[f3];
      if (!i2[e4] || !o5[e4])
        continue;
      const p4 = i2[e4][n7], h4 = o5[e4][n7];
      if (!h4 || 0 === h4.length)
        continue;
      if (p(r8))
        return;
      const m3 = p4.getData();
      for (; m3.nextTag(2); ) {
        const e5 = m3.getMessage(), t8 = new s3(e5, p4);
        e5.release();
        const r9 = t8.values;
        if (r9) {
          const e6 = r9._minzoom;
          if (e6 && e6 >= l4)
            continue;
          const t9 = r9._maxzoom;
          if (t9 && t9 <= c5)
            continue;
        }
        for (const s6 of h4)
          s6.pushFeature(t8);
      }
    }
  }
  _fetchResources(e3, t8, r8) {
    const s6 = [], i2 = this._tile.getWorkerTileHandler();
    let o5, n6;
    e3.length > 0 && (o5 = i2.fetchSprites(e3, this._client, r8), s6.push(o5));
    for (const c5 in t8) {
      const e4 = t8[c5];
      e4.size > 0 && (n6 = i2.fetchGlyphs(this._tile.tileKey, c5, e4, this._client, r8), s6.push(n6));
    }
    return s6;
  }
  _processFeatures(e3) {
    const t8 = e3.filter((e4) => e4.hasFeatures() || this._canParseStyleLayer(e4.layer.uid));
    for (const r8 of t8)
      r8.processFeatures(r8.tileClipper);
    return t8;
  }
  _parseTileData(e3) {
    const t8 = {};
    for (const r8 of Object.keys(e3)) {
      const s6 = e3[r8], i2 = {};
      for (; s6.next(); )
        switch (s6.tag()) {
          case 3: {
            const e4 = s6.getMessage(), t9 = new e2(e4);
            e4.release(), i2[t9.name] = t9;
            break;
          }
          default:
            s6.skip();
        }
      t8[r8] = i2;
    }
    return t8;
  }
  _createBucket(e3) {
    switch (e3.type) {
      case a.BACKGROUND:
        return null;
      case a.FILL:
        return this._createFillBucket(e3);
      case a.LINE:
        return this._createLineBucket(e3);
      case a.CIRCLE:
        return this._createCircleBucket(e3);
      case a.SYMBOL:
        return this._createSymbolBucket(e3);
    }
  }
  _createFillBucket(e3) {
    return new s4(e3, this._level, this._tile.getWorkerTileHandler().getSpriteItems(), new r5(e3.fillMaterial.getStride()), new r4(), new u3(e3.outlineMaterial.getStride()), new r4());
  }
  _createLineBucket(e3) {
    return new n5(e3, this._level, this._tile.getWorkerTileHandler().getSpriteItems(), new o3(e3.lineMaterial.getStride()), new r4());
  }
  _createCircleBucket(e3) {
    return new r6(e3, this._level, this._tile.getWorkerTileHandler().getSpriteItems(), new a5(e3.circleMaterial.getStride()), new r4());
  }
  _createSymbolBucket(e3) {
    const t8 = this._tile;
    return new A(e3, this._level, new h3(e3.iconMaterial.getStride()), new r4(), new h3(e3.textMaterial.getStride()), new r4(), t8.placementEngine, t8.getWorkerTileHandler());
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/WorkerTile.js
var a6 = class {
  constructor(t8, e3, r8, a7) {
    this.status = I4.INITIALIZED, this.placementEngine = new u2(), this.tileKey = t8, this.refKeys = e3, this._workerTileHandler = r8, this._styleRepository = a7;
  }
  release() {
    this.tileKey = "", this.refKeys = null, this.status = I4.INITIALIZED, this._workerTileHandler = null;
  }
  async parse(s6, r8) {
    const a7 = r8 && r8.signal;
    if (r(a7)) {
      const t8 = () => {
        a7.removeEventListener("abort", t8), this.status = I4.INVALID;
      };
      a7.addEventListener("abort", t8);
    }
    let n6;
    const l4 = { bucketsWithData: [], emptyBuckets: null };
    try {
      n6 = await this._parse(s6, r8);
    } catch (y2) {
      if (j(y2))
        throw y2;
      return { result: l4, transferList: [] };
    }
    this.status = I4.READY;
    const o5 = l4.bucketsWithData, u4 = [];
    for (const t8 of n6)
      if (t8.hasFeatures()) {
        const e3 = t8.serialize();
        o5.push(e3);
      } else
        u4.push(t8.layer.uid);
    const h4 = [...o5];
    let c5 = null;
    return u4.length > 0 && (c5 = Uint32Array.from(u4), h4.push(c5.buffer)), l4.emptyBuckets = c5, { result: l4, transferList: h4 };
  }
  setObsolete() {
    this.status = I4.INVALID;
  }
  getLayers() {
    return this._workerTileHandler.getLayers();
  }
  getWorkerTileHandler() {
    return this._workerTileHandler;
  }
  async _parse(t8, e3) {
    const s6 = t8.sourceName2DataAndRefKey;
    if (0 === Object.keys(s6).length)
      return [];
    this.status = I4.MODIFIED;
    return new B(s6, this, e3.client, this._styleRepository, t8.styleLayerUIDs).parse(e3);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/WorkerTileHandler.js
var o4 = class {
  constructor() {
    this._spriteInfo = {}, this._glyphInfo = {};
  }
  reset() {
    return this._spriteInfo = {}, this._glyphInfo = {}, Promise.resolve();
  }
  getLayers() {
    var _a;
    return (_a = this._styleRepository) == null ? void 0 : _a.layers;
  }
  async createTileAndParse(t8, r8) {
    const { key: o5 } = t8, i2 = {};
    for (const e3 of Object.keys(t8.sourceName2DataAndRefKey)) {
      const s6 = t8.sourceName2DataAndRefKey[e3];
      i2[e3] = s6.refKey;
    }
    const n6 = new a6(o5, i2, this, this._styleRepository);
    try {
      return await n6.parse(t8, r8);
    } catch (l4) {
      if (n6.setObsolete(), n6.release(), !j(l4))
        throw l4;
      return null;
    }
  }
  updateStyle(e3) {
    if (!e3 || 0 === e3.length || !this._styleRepository)
      return;
    const s6 = this._styleRepository;
    for (const r8 of e3) {
      const e4 = r8.type, o5 = r8.data;
      switch (e4) {
        case L.PAINTER_CHANGED:
          s6.setPaintProperties(o5.layer, o5.paint);
          break;
        case L.LAYOUT_CHANGED:
          s6.setLayoutProperties(o5.layer, o5.layout);
          break;
        case L.LAYER_REMOVED:
          s6.deleteStyleLayer(o5.layer);
          break;
        case L.LAYER_CHANGED:
          s6.setStyleLayer(o5.layer, o5.index);
          break;
        case L.SPRITES_CHANGED:
          this._spriteInfo = {};
      }
    }
  }
  setStyle(e3) {
    this._styleRepository = new l2(e3), this._spriteInfo = {}, this._glyphInfo = {};
  }
  fetchSprites(e3, t8, s6) {
    const r8 = [], o5 = this._spriteInfo;
    for (const i2 of e3) {
      void 0 === o5[i2.name] && r8.push(i2);
    }
    return 0 === r8.length ? Promise.resolve() : t8.invoke("getSprites", r8, { signal: s6 && s6.signal }).then((e4) => {
      for (const t9 in e4) {
        const s7 = e4[t9];
        o5[t9] = s7;
      }
    });
  }
  getSpriteItems() {
    return this._spriteInfo;
  }
  fetchGlyphs(e3, t8, s6, r8, o5) {
    const i2 = [];
    let n6 = this._glyphInfo[t8];
    return n6 ? s6.forEach((e4) => {
      n6[e4] || i2.push(e4);
    }) : (n6 = this._glyphInfo[t8] = [], s6.forEach((e4) => i2.push(e4))), 0 === i2.length ? Promise.resolve() : r8.invoke("getGlyphs", { tileID: e3, font: t8, codePoints: i2 }, o5).then((e4) => {
      for (let t9 = 0; t9 < e4.length; t9++)
        e4[t9] && (n6[t9] = e4[t9]);
    });
  }
  getGlyphItems(e3) {
    return this._glyphInfo[e3];
  }
};
export {
  o4 as default
};
//# sourceMappingURL=WorkerTileHandler-7YBVJQER.js.map
