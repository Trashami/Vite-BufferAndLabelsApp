import {
  a as a5,
  c as c2,
  u as u3
} from "./chunk-TMILTRNC.js";
import {
  e as e6
} from "./chunk-FGBXDVCJ.js";
import {
  s
} from "./chunk-OPS2DUBP.js";
import {
  c,
  i as i3,
  t as t2
} from "./chunk-PNLWREZJ.js";
import {
  a as a3
} from "./chunk-372DRRBO.js";
import {
  e2 as e4,
  o3 as o4,
  o4 as o5
} from "./chunk-HNRPDSCT.js";
import {
  d
} from "./chunk-GDICPMRK.js";
import {
  e as e5
} from "./chunk-JPRTIOCM.js";
import {
  o as o3,
  t
} from "./chunk-RNRS2JL4.js";
import {
  h
} from "./chunk-SBPLVEUA.js";
import {
  u as u2
} from "./chunk-3IISYLTT.js";
import {
  o as o2
} from "./chunk-MYQCUAHK.js";
import {
  e
} from "./chunk-C6PUUIY2.js";
import {
  a as a4
} from "./chunk-TGHV3HKU.js";
import {
  a as a2
} from "./chunk-HT2GXPWH.js";
import {
  e as e2,
  e2 as e3,
  f,
  i as i2,
  u
} from "./chunk-BQL7VXQR.js";
import {
  o as o6
} from "./chunk-735C75BI.js";
import {
  n as n2,
  o
} from "./chunk-ZLTZ3KAT.js";
import {
  O
} from "./chunk-RUM3DXFX.js";
import {
  a,
  r as r2
} from "./chunk-75RMBUYZ.js";
import {
  i,
  n
} from "./chunk-ZEEU5HOK.js";
import {
  l
} from "./chunk-NDQ5FHGV.js";
import {
  r
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/hud/HUDOcclusionPass.glsl.js
function p(p2, l2) {
  const { vertex: d2, fragment: c3 } = p2;
  l2.hasMultipassGeometry && d2.include(a5), l2.hasMultipassTerrain && p2.varyings.add("depth", "float"), d2.code.add(n2`
  void main(void) {
    vec4 posProjCenter;
    if (dot(position, position) > 0.0) {
      // Render single point to center of the pixel to avoid subpixel
      // filtering to affect the marker color
      ProjectHUDAux projectAux;
      vec4 posProj = projectPositionHUD(projectAux);
      posProjCenter = alignToPixelCenter(posProj, viewport.zw);

      ${l2.hasMultipassGeometry ? n2`
        // Don't draw vertices behind geometry
        if(geometryDepthTest(.5 + .5 * posProjCenter.xy / posProjCenter.w, projectAux.posView.z)){
          posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
        }` : ""}

      ${l2.hasMultipassTerrain ? "depth = projectAux.posView.z;" : ""}
      vec3 vpos = projectAux.posModel;
      if (rejectBySlice(vpos)) {
        // Project out of clip space
        posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
      }

    } else {
      // Project out of clip space
      posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
    }

    gl_Position = posProjCenter;
    gl_PointSize = 1.0;
  }
  `), l2.hasMultipassTerrain && c3.include(a4), l2.hasMultipassTerrain && c3.uniforms.add([...u("terrainDepthTexture", (e7, r3) => r3.multipassTerrain.linearDepthTexture, l2.hasWebGL2Context ? e3.None : e3.InvSize), new e2("nearFar", (e7, r3) => r3.camera.nearFar)]), c3.include(a2), c3.code.add(n2`
  void main() {
    gl_FragColor = vec4(1, 1, 1, 1);
    ${l2.hasMultipassTerrain ? n2`
          vec2 uv = gl_FragCoord.xy;

          // Read the rgba data from the texture linear depth
          vec4 terrainDepthData = ${i2(l2, "terrainDepthTexture", "uv")};

          float terrainDepth = linearDepthFromFloat(rgba2float(terrainDepthData), nearFar);

          // If HUD vertex is behind terrain and the terrain depth is not the initialize value (e.g. we are not looking at the sky)
          // Mark the HUD vertex as occluded by transparent terrain
          if(depth < terrainDepth && terrainDepthData != vec4(0,0,0,1)){
            gl_FragColor.g = 0.5;
          }` : ""}
  }
  `);
}

// node_modules/@arcgis/core/chunks/HUDMaterial.glsl.js
function B(r3) {
  const l2 = new o(), B2 = r3.signedDistanceFieldEnabled;
  if (l2.include(c2), l2.include(u3, r3), l2.include(u2, r3), r3.occlusionPass)
    return l2.include(p, r3), l2;
  const { vertex: T2, fragment: V2 } = l2;
  l2.include(c), V2.include(a2), V2.include(e5), l2.include(s, r3), l2.include(d, r3), l2.varyings.add("vcolor", "vec4"), l2.varyings.add("vtc", "vec2"), l2.varyings.add("vsize", "vec2"), r3.binaryHighlightOcclusionEnabled && l2.varyings.add("voccluded", "float"), T2.uniforms.add([new e("viewport", (e7, o7) => o7.camera.fullViewport), new e2("screenOffset", (e7, r4) => r2(U, 2 * e7.screenOffset[0] * r4.camera.pixelRatio, 2 * e7.screenOffset[1] * r4.camera.pixelRatio)), new e2("anchorPosition", (e7) => H(e7)), new e("materialColor", (e7) => e7.color), new o6("pixelRatio", (e7, o7) => o7.camera.pixelRatio)]), B2 && (T2.uniforms.add(new e("outlineColor", (e7) => e7.outlineColor)), V2.uniforms.add([new e("outlineColor", (e7) => _(e7) ? e7.outlineColor : l), new o6("outlineSize", (e7) => _(e7) ? e7.outlineSize : 0)])), r3.hasScreenSizePerspective && (t2(T2), i3(T2)), (r3.debugDrawLabelBorder || r3.binaryHighlightOcclusionEnabled) && l2.varyings.add("debugBorderCoords", "vec4"), l2.attributes.add(O.UV0, "vec2"), l2.attributes.add(O.COLOR, "vec4"), l2.attributes.add(O.SIZE, "vec2"), l2.attributes.add(O.AUXPOS2, "vec4"), T2.code.add(n2`
    void main(void) {
      ProjectHUDAux projectAux;
      vec4 posProj = projectPositionHUD(projectAux);
      forwardObjectAndLayerIdColor();

      if (rejectBySlice(projectAux.posModel)) {
        // Project outside of clip plane
        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
        return;
      }
      vec2 inputSize;
      ${r3.hasScreenSizePerspective ? n2`
      inputSize = screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);
      vec2 screenOffsetScaled = screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);
         ` : n2`
      inputSize = size;
      vec2 screenOffsetScaled = screenOffset;`}

      ${r3.vvSize ? "inputSize *= vvScale(auxpos2).xx;" : ""}

      vec2 combinedSize = inputSize * pixelRatio;
      vec4 quadOffset = vec4(0.0);

      ${r3.occlusionTestEnabled || r3.binaryHighlightOcclusionEnabled ? "bool visible = testVisibilityHUD(posProj);" : ""}

      ${r3.binaryHighlightOcclusionEnabled ? "voccluded = visible ? 0.0 : 1.0;" : ""}
    `);
  const E = n2`vec2 uv01 = floor(uv0);
vec2 uv = uv0 - uv01;
quadOffset.xy = ((uv01 - anchorPosition) * 2.0 * combinedSize + screenOffsetScaled) / viewport.zw * posProj.w;`, M = r3.pixelSnappingEnabled ? B2 ? n2`posProj = alignToPixelOrigin(posProj, viewport.zw) + quadOffset;` : n2`posProj += quadOffset;
if (inputSize.x == size.x) {
posProj = alignToPixelOrigin(posProj, viewport.zw);
}` : n2`posProj += quadOffset;`;
  r3.vvColor && T2.uniforms.add([new e4("vvColorColors", (e7) => e7.vvColorColors, o5), new o4("vvColorValues", (e7) => e7.vvColorValues, o5)]), T2.uniforms.add(new e2("textureCoordinateScaleFactor", (o7) => r(o7.texture) && r(o7.texture.descriptor.textureCoordinateScaleFactor) ? o7.texture.descriptor.textureCoordinateScaleFactor : i)), T2.code.add(n2`
    ${r3.occlusionTestEnabled ? "if (visible) {" : ""}
    ${E}
    ${r3.vvColor ? "vcolor = vvGetColor(auxpos2, vvColorValues, vvColorColors) * materialColor;" : "vcolor = color / 255.0 * materialColor;"}

    bool alphaDiscard = vcolor.a < ${n2.float(t)};
    ${B2 ? `alphaDiscard = alphaDiscard && outlineColor.a < ${n2.float(t)};` : ""}
    if (alphaDiscard) {
      // "early discard" if both symbol color (= fill) and outline color (if applicable) are transparent
      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
      return;
    } else {
      ${M}
      gl_Position = posProj;
    }

    vtc = uv * textureCoordinateScaleFactor;

    ${r3.debugDrawLabelBorder ? "debugBorderCoords = vec4(uv01, 1.5 / combinedSize);" : ""}
    vsize = inputSize;
    ${r3.occlusionTestEnabled ? n2`} else { vtc = vec2(0.0);
      ${r3.debugDrawLabelBorder ? "debugBorderCoords = vec4(0.5, 0.5, 1.5 / combinedSize);}" : "}"}` : ""}
  }
  `), V2.uniforms.add(new f("tex", (e7) => e7.texture));
  const R = r3.debugDrawLabelBorder ? n2`(isBorder > 0.0 ? 0.0 : ${n2.float(o3)})` : n2.float(o3), I = n2`
    ${r3.debugDrawLabelBorder ? n2`
      float isBorder = float(any(lessThan(debugBorderCoords.xy, debugBorderCoords.zw)) || any(greaterThan(debugBorderCoords.xy, 1.0 - debugBorderCoords.zw)));` : ""}

    ${B2 ? n2`
      vec4 fillPixelColor = vcolor;

      // Attempt to sample texel centers to avoid that thin cross outlines
      // disappear with large symbol sizes.
      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/7058#issuecomment-603041
      const float txSize = ${n2.float(e6)};
      const float texelSize = 1.0 / txSize;
      // Calculate how much we have to add/subtract to/from each texel to reach the size of an onscreen pixel
      vec2 scaleFactor = (vsize - txSize) * texelSize;
      vec2 samplePos = vtc + (vec2(1.0, -1.0) * texelSize) * scaleFactor;

      // Get distance and map it into [-0.5, 0.5]
      float d = rgba2float(texture2D(tex, samplePos)) - 0.5;

      // Distance in output units (i.e. pixels)
      float dist = d * vsize.x;

      // Create smooth transition from the icon into its outline
      float fillAlphaFactor = clamp(0.5 - dist, 0.0, 1.0);
      fillPixelColor.a *= fillAlphaFactor;

      if (outlineSize > 0.25) {
        vec4 outlinePixelColor = outlineColor;
        float clampedOutlineSize = min(outlineSize, 0.5*vsize.x);

        // Create smooth transition around outline
        float outlineAlphaFactor = clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);
        outlinePixelColor.a *= outlineAlphaFactor;

        if (
          outlineAlphaFactor + fillAlphaFactor < ${R} ||
          fillPixelColor.a + outlinePixelColor.a < ${n2.float(t)}
        ) {
          discard;
        }

        // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)
        float compositeAlpha = outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);
        vec3 compositeColor = vec3(outlinePixelColor) * outlinePixelColor.a +
          vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);

        gl_FragColor = vec4(compositeColor, compositeAlpha);
      } else {
        if (fillAlphaFactor < ${R}) {
          discard;
        }

        gl_FragColor = premultiplyAlpha(fillPixelColor);
      }

      // visualize SDF:
      // gl_FragColor = vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);
      ` : n2`
          vec4 texColor = texture2D(tex, vtc, -0.5);
          if (texColor.a < ${R}) {
            discard;
          }
          gl_FragColor = texColor * premultiplyAlpha(vcolor);
          `}

    // Draw debug border with transparency, so that original texels along border are still partially visible
    ${r3.debugDrawLabelBorder ? n2`gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder * 0.5);` : ""}
  `;
  return r3.output === h.Alpha && V2.code.add(n2`
      void main() {
        ${I}
        gl_FragColor = vec4(gl_FragColor.a);
      }
      `), r3.output === h.ObjectAndLayerIdColor && V2.code.add(n2`
      void main() {
        ${I}
        outputObjectAndLayerIdColor();
      }
      `), r3.output === h.Color && V2.code.add(n2`
    void main() {
      ${I}
      ${r3.transparencyPassType === o2.FrontFace ? "gl_FragColor.rgb /= gl_FragColor.a;" : ""}
    }
    `), r3.output === h.Highlight && (l2.include(a3, r3), V2.code.add(n2`
    void main() {
      ${I}
      ${r3.binaryHighlightOcclusionEnabled ? n2`
          if (voccluded == 1.0) {
            gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);
          } else {
            gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
          }` : "outputHighlight();"}
    }
    `)), l2;
}
function _(e7) {
  return e7.outlineColor[3] > 0 && e7.outlineSize > 0;
}
function H(e7, o7 = U) {
  return e7.textureIsSignedDistanceField ? T(e7.anchorPosition, e7.distanceFieldBoundingBox, o7) : a(o7, e7.anchorPosition), o7;
}
function T(r3, i4, l2) {
  r(i4) ? r2(l2, r3[0] * (i4[2] - i4[0]) + i4[0], r3[1] * (i4[3] - i4[1]) + i4[1]) : r2(l2, 0, 0);
}
var U = n();
var V = Object.freeze(Object.defineProperty({ __proto__: null, build: B, calculateAnchorPosForRendering: H }, Symbol.toStringTag, { value: "Module" }));

export {
  B,
  H,
  V
};
//# sourceMappingURL=chunk-7UVYS6N7.js.map
