import {
  o as o2
} from "./chunk-4NNECS4K.js";
import "./chunk-UWKVAZQ6.js";
import "./chunk-XP6I2GEX.js";
import {
  g as g5,
  p as p3
} from "./chunk-2FEM2LL2.js";
import "./chunk-L3EXV6PG.js";
import {
  L as L2,
  _ as _2,
  b,
  r as r3,
  x as x3
} from "./chunk-EWDJAAMQ.js";
import {
  a as a2,
  g as g4,
  k,
  v as v2,
  x as x2
} from "./chunk-4M35HEAB.js";
import {
  L as L3,
  M,
  O as O3,
  h,
  j,
  k as k2
} from "./chunk-AQS2GDHU.js";
import "./chunk-C6HDWDWX.js";
import "./chunk-67RD6CZ4.js";
import "./chunk-NGFMX3UT.js";
import "./chunk-XFDO4CMR.js";
import {
  e as e4
} from "./chunk-IVLBGTXL.js";
import {
  e as e3
} from "./chunk-GHN7C53L.js";
import "./chunk-6FXLJAMI.js";
import {
  a as a3
} from "./chunk-ZNRXLY4R.js";
import "./chunk-75RMBUYZ.js";
import {
  Zn,
  gn
} from "./chunk-FFVIDMFN.js";
import {
  x
} from "./chunk-UK3I5WXR.js";
import "./chunk-GLGOVVCK.js";
import "./chunk-BUVDI6S7.js";
import "./chunk-ZWUEORSX.js";
import "./chunk-ZPYDYUP5.js";
import {
  g as g2
} from "./chunk-RT3T2K4S.js";
import {
  O as O2
} from "./chunk-WJCI2CGX.js";
import {
  a
} from "./chunk-REIQNAQW.js";
import {
  g as g3
} from "./chunk-J6LQZWZI.js";
import "./chunk-OD3FDQCI.js";
import "./chunk-J2PJNRU7.js";
import "./chunk-56SPM3WK.js";
import "./chunk-XMZAPOBR.js";
import "./chunk-BLJKKR5D.js";
import "./chunk-ZGNCYHMZ.js";
import "./chunk-X2S4RQJ4.js";
import "./chunk-FUPLN7UM.js";
import "./chunk-376OPXM4.js";
import "./chunk-DER356EU.js";
import "./chunk-MZIWIEIR.js";
import "./chunk-TQEOEDAZ.js";
import "./chunk-SHFHZMHO.js";
import "./chunk-NRP45AHD.js";
import "./chunk-IWQ7452U.js";
import "./chunk-NAN5J6QS.js";
import "./chunk-B4DKBAM3.js";
import "./chunk-6M2AHKYV.js";
import "./chunk-SZIJNKCV.js";
import {
  m as m2
} from "./chunk-6O43OEU5.js";
import "./chunk-J2K7ZDSV.js";
import "./chunk-2UML3WQZ.js";
import "./chunk-KXVMEIWT.js";
import "./chunk-UDND2Z3V.js";
import "./chunk-23Y3DIC6.js";
import "./chunk-JUVQV3R3.js";
import "./chunk-RAX2HD42.js";
import "./chunk-ZYRIJWLX.js";
import "./chunk-C5H57NTD.js";
import {
  O,
  S,
  e,
  g,
  o,
  u,
  z
} from "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import {
  f,
  n,
  r as r2
} from "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import "./chunk-YWAQYJRC.js";
import "./chunk-B356PXLT.js";
import "./chunk-EHPBHJYZ.js";
import {
  v2 as v
} from "./chunk-3MNMDUQZ.js";
import {
  p as p2,
  w,
  w2
} from "./chunk-UWG37XSU.js";
import "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import "./chunk-HLM6QCL2.js";
import "./chunk-RXYULINL.js";
import {
  l
} from "./chunk-5NXILPDI.js";
import "./chunk-THVR7IAM.js";
import {
  m
} from "./chunk-ZWJJTUFL.js";
import "./chunk-XQN7F674.js";
import "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import {
  Ot,
  _
} from "./chunk-KAN4HXCG.js";
import "./chunk-4FEGON7M.js";
import "./chunk-VWYWOOPX.js";
import "./chunk-M5VHU5LK.js";
import "./chunk-CXFRNDG4.js";
import "./chunk-7QMMKGW4.js";
import {
  e as e2,
  n2,
  y
} from "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import {
  L,
  f as f2,
  p,
  y as y2
} from "./chunk-MJXQTGI2.js";
import {
  s as s2
} from "./chunk-LIZHLHNA.js";
import "./chunk-BTUHYGXO.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";
import "./chunk-HVKDYDPP.js";
import "./chunk-6QC7MLLS.js";
import {
  r,
  t
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/geometry/support/meshUtils/centerAt.js
var a4 = s.getLogger("esri.geometry.support.meshUtils.centerAt");
function c(e5, r4, i) {
  var _a;
  if (!e5.vertexAttributes || !e5.vertexAttributes.position)
    return;
  const n3 = (_a = i == null ? void 0 : i.origin) != null ? _a : e5.origin;
  if (r(e5.transform))
    null != (i == null ? void 0 : i.geographic) && i.geographic !== e5.transform.geographic && a4.warn(`Specifying the 'geographic' parameter (${i.geographic}) different from the Mesh transform setting (${e5.transform.geographic}) is not supported`), f3(e5.transform, r4, n3);
  else {
    r3(e5.spatialReference, i) ? p4(e5, r4, n3) : g6(e5, r4, n3);
  }
}
function f3(e5, t2, r4) {
  const i = t2.x - r4.x, o3 = t2.y - r4.y, n3 = t2.hasZ && r4.hasZ ? t2.z - r4.z : 0, s3 = e5.origin;
  e5.origin = [s3[0] + i, s3[1] + o3, s3[2] + n3];
}
function p4(e5, t2, r4) {
  const i = b(e5.vertexAttributes, r4, { geographic: true }), { position: o3, normal: a5, tangent: c4 } = x3(i, t2, { geographic: true });
  e5.vertexAttributes.position = o3, e5.vertexAttributes.normal = a5, e5.vertexAttributes.tangent = c4, e5.vertexAttributesChanged();
}
function g6(e5, t2, r4) {
  const o3 = h2, n3 = l2;
  if (gn(t2, n3, e5.spatialReference)) {
    if (!gn(r4, o3, e5.spatialReference)) {
      const t3 = e5.origin;
      o3[0] = t3.x, o3[1] = t3.y, o3[2] = t3.z, a4.error(`Failed to project specified origin (wkid:${r4.spatialReference.wkid}) to mesh spatial reference (wkid:${e5.spatialReference.wkid}).`);
    }
    m3(e5.vertexAttributes.position, n3, o3), e5.vertexAttributesChanged();
  } else
    a4.error(`Failed to project centerAt location (wkid:${t2.spatialReference.wkid}) to mesh spatial reference (wkid:${e5.spatialReference.wkid})`);
}
function m3(e5, t2, r4) {
  if (e5)
    for (let i = 0; i < e5.length; i += 3)
      for (let o3 = 0; o3 < 3; o3++)
        e5[i + o3] += t2[o3] - r4[o3];
}
var l2 = n();
var h2 = n();

// node_modules/@arcgis/core/geometry/support/meshUtils/loadExternal.js
async function u2(e5, s3, o3) {
  const { loadGLTFMesh: n3 } = await y2(import("./loadGLTFMesh-IDQA3VKJ.js"), o3), a5 = await m4(s3, o3), i = n3(new w({ x: 0, y: 0, z: 0, spatialReference: e5.spatialReference }), a5.url, { resolveFile: f4(a5), useTransform: true, signal: r(o3) ? o3.signal : null });
  i.then(() => a5.dispose(), () => a5.dispose());
  const { vertexAttributes: l5, components: u4 } = await i;
  e5.vertexAttributes = l5, e5.components = u4;
}
function f4(e5) {
  const t2 = Ot(e5.url);
  return (s3) => {
    var _a;
    const r4 = _(s3, t2, t2), o3 = r4 ? r4.replace(/^ *\.\//, "") : null;
    return (_a = o3 ? e5.files.get(o3) : null) != null ? _a : s3;
  };
}
async function m4(e5, t2) {
  return e5 instanceof Blob ? y3.fromBlob(e5) : "string" == typeof e5 ? new y3(e5) : Array.isArray(e5) ? p5(e5, t2) : w3(e5, t2);
}
async function p5(t2, r4) {
  const i = /* @__PURE__ */ new Map();
  let l5 = null;
  const c4 = await L(t2.map(async (e5) => ({ name: e5.name, source: await m4(e5 instanceof Blob ? e5 : e5.source, r4) }))), u4 = [];
  for (const e5 of c4)
    e5 && (p(r4) ? e5.source.dispose() : u4.push(e5));
  f2(r4);
  for (const { name: e5, source: o3 } of u4)
    (t(l5) || /\.(gltf|glb)/i.test(e5)) && (l5 = o3.url), i.set(e5, o3.url), o3.files && o3.files.forEach((e6, t3) => i.set(t3, e6));
  if (t(l5))
    throw new s2("mesh-load-external:missing-files", "Missing files to load external mesh source");
  return new y3(l5, () => u4.forEach(({ source: e5 }) => e5.dispose()), i);
}
async function w3(e5, t2) {
  const { default: s3 } = await y2(import("./request-2G4EFZ2V.js"), t2), o3 = "string" == typeof e5.multipart[0] ? await Promise.all(e5.multipart.map(async (e6) => (await s3(e6, { responseType: "array-buffer" })).data)) : e5.multipart;
  return y3.fromBlob(new Blob(o3));
}
var y3 = class {
  constructor(e5, t2 = () => {
  }, s3 = /* @__PURE__ */ new Map()) {
    this.url = e5, this.dispose = t2, this.files = s3;
  }
  static fromBlob(e5) {
    const t2 = URL.createObjectURL(e5);
    return new y3(t2, () => URL.revokeObjectURL(t2));
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/offset.js
function x4(e5, o3, i) {
  if (e5.vertexAttributes && e5.vertexAttributes.position)
    if (r(e5.transform))
      null != (i == null ? void 0 : i.geographic) && i.geographic !== e5.transform.geographic && s.getLogger("esri.geometry.support.meshUtils.offset").warn(`Specifying the 'geographic' parameter (${i.geographic}) different from the Mesh transform setting (${e5.transform.geographic}) is not supported`), A(e5.transform, o3);
    else {
      r3(e5.spatialReference, i) ? v3(e5, o3) : b2(e5, o3);
    }
}
function A(t2, r4) {
  const e5 = t2.origin;
  t2.origin = u(n(), e5, r4);
}
function v3(t2, o3) {
  const i = t2.spatialReference, n3 = t2.vertexAttributes.position, a5 = t2.vertexAttributes.normal, c4 = t2.vertexAttributes.tangent, x7 = new Float64Array(n3.length), A4 = r(a5) ? new Float32Array(a5.length) : null, v6 = r(c4) ? new Float32Array(c4.length) : null, b4 = t2.extent.center, F2 = d;
  Zn(i, [b4.x, b4.y, b4.z], k3, O2(i)), a3(w4, k3), S(F2, o3, w4), M(n3, i, x7), r(a5) && r(A4) && j(a5, n3, x7, i, A4), r(c4) && r(v6) && k2(c4, n3, x7, i, v6), y4(x7, F2), O3(x7, n3, i), r(a5) && r(A4) && h(A4, n3, x7, i, a5), r(c4) && r(v6) && L3(v6, n3, x7, i, c4), t2.vertexAttributesChanged();
}
function b2(t2, r4) {
  y4(t2.vertexAttributes.position, r4), t2.vertexAttributesChanged();
}
function y4(t2, r4) {
  if (t2)
    for (let e5 = 0; e5 < t2.length; e5 += 3)
      for (let o3 = 0; o3 < 3; o3++)
        t2[e5 + o3] += r4[o3];
}
var d = n();
var k3 = e4();
var w4 = e3();

// node_modules/@arcgis/core/geometry/support/meshUtils/primitives.js
function c2() {
  const { faceDescriptions: t2, faceVertexOffsets: e5, uvScales: n3 } = d2, r4 = 4 * t2.length, o3 = new Float64Array(3 * r4), s3 = new Float32Array(3 * r4), a5 = new Float32Array(2 * r4), i = new Uint32Array(2 * t2.length * 3);
  let c4 = 0, l5 = 0, f7 = 0, u4 = 0;
  for (let h4 = 0; h4 < t2.length; h4++) {
    const r5 = t2[h4], p8 = c4 / 3;
    for (const t3 of e5)
      i[u4++] = p8 + t3;
    const m7 = r5.corners;
    for (let t3 = 0; t3 < 4; t3++) {
      const e6 = m7[t3];
      let i2 = 0;
      a5[f7++] = 0.25 * n3[t3][0] + r5.uvOrigin[0], a5[f7++] = r5.uvOrigin[1] - 0.25 * n3[t3][1];
      for (let t4 = 0; t4 < 3; t4++)
        0 !== r5.axis[t4] ? (o3[c4++] = 0.5 * r5.axis[t4], s3[l5++] = r5.axis[t4]) : (o3[c4++] = 0.5 * e6[i2++], s3[l5++] = 0);
    }
  }
  return { position: o3, normal: s3, uv: a5, faces: i };
}
function l3(e5, n3) {
  const r4 = e5.components[0], o3 = r4.faces, a5 = M2[n3], i = 6 * a5, c4 = new Array(6), l5 = new Array(o3.length - 6);
  let f7 = 0, u4 = 0;
  for (let t2 = 0; t2 < o3.length; t2++)
    t2 >= i && t2 < i + 6 ? c4[f7++] = o3[t2] : l5[u4++] = o3[t2];
  if (r(e5.vertexAttributes.uv)) {
    const t2 = new Float32Array(e5.vertexAttributes.uv), n4 = 4 * a5 * 2, r5 = [0, 1, 1, 1, 1, 0, 0, 0];
    for (let e6 = 0; e6 < r5.length; e6++)
      t2[n4 + e6] = r5[e6];
    e5.vertexAttributes.uv = t2;
  }
  return e5.components = [new g5({ faces: c4, material: r4.material }), new g5({ faces: l5 })], e5;
}
function f5(t2 = 0) {
  const e5 = Math.round(8 * 2 ** t2), n3 = 2 * e5, r4 = (e5 - 1) * (n3 + 1) + 2 * n3, o3 = new Float64Array(3 * r4), s3 = new Float32Array(3 * r4), a5 = new Float32Array(2 * r4), i = new Uint32Array(3 * ((e5 - 1) * n3 * 2));
  let c4 = 0, l5 = 0, f7 = 0, u4 = 0;
  for (let h4 = 0; h4 <= e5; h4++) {
    const t3 = h4 / e5 * Math.PI + 0.5 * Math.PI, r5 = Math.cos(t3), p8 = Math.sin(t3);
    F[2] = p8;
    const m7 = 0 === h4 || h4 === e5, w7 = m7 ? n3 - 1 : n3;
    for (let v6 = 0; v6 <= w7; v6++) {
      const t4 = v6 / w7 * 2 * Math.PI;
      F[0] = -Math.sin(t4) * r5, F[1] = Math.cos(t4) * r5;
      for (let e6 = 0; e6 < 3; e6++)
        o3[c4] = 0.5 * F[e6], s3[c4] = F[e6], ++c4;
      a5[l5++] = (v6 + (m7 ? 0.5 : 0)) / n3, a5[l5++] = h4 / e5, 0 !== h4 && v6 !== n3 && (h4 !== e5 && (i[f7++] = u4, i[f7++] = u4 + 1, i[f7++] = u4 - n3), 1 !== h4 && (i[f7++] = u4, i[f7++] = u4 - n3, i[f7++] = u4 - n3 - 1)), u4++;
    }
  }
  return { position: o3, normal: s3, uv: a5, faces: i };
}
function u3(t2 = 0) {
  const e5 = 5, n3 = Math.round(16 * 2 ** t2), r4 = (e5 - 1) * (n3 + 1) + 2 * n3, o3 = new Float64Array(3 * r4), s3 = new Float32Array(3 * r4), a5 = new Float32Array(2 * r4), i = new Uint32Array(3 * (4 * n3));
  let c4 = 0, l5 = 0, f7 = 0, u4 = 0, h4 = 0;
  for (let p8 = 0; p8 <= e5; p8++) {
    const t3 = 0 === p8 || p8 === e5, r5 = p8 <= 1 || p8 >= e5 - 1, m7 = 2 === p8 || 4 === p8, w7 = t3 ? n3 - 1 : n3;
    for (let v6 = 0; v6 <= w7; v6++) {
      const g9 = v6 / w7 * 2 * Math.PI, A4 = t3 ? 0 : 0.5;
      F[0] = A4 * Math.sin(g9), F[1] = A4 * -Math.cos(g9), F[2] = p8 <= 2 ? 0.5 : -0.5;
      for (let t4 = 0; t4 < 3; t4++)
        o3[c4++] = F[t4], s3[l5++] = r5 ? 2 === t4 ? p8 <= 1 ? 1 : -1 : 0 : 2 === t4 ? 0 : F[t4] / A4;
      a5[f7++] = (v6 + (t3 ? 0.5 : 0)) / n3, a5[f7++] = p8 <= 1 ? 1 * p8 / 3 : p8 <= 3 ? 1 * (p8 - 2) / 3 + 1 / 3 : 1 * (p8 - 4) / 3 + 2 / 3, m7 || 0 === p8 || v6 === n3 || (p8 !== e5 && (i[u4++] = h4, i[u4++] = h4 + 1, i[u4++] = h4 - n3), 1 !== p8 && (i[u4++] = h4, i[u4++] = h4 - n3, i[u4++] = h4 - n3 - 1)), h4++;
    }
  }
  return { position: o3, normal: s3, uv: a5, faces: i };
}
function h3(t2, e5) {
  const n3 = "number" == typeof e5 ? e5 : null != e5 ? e5.width : 1, r4 = "number" == typeof e5 ? e5 : null != e5 ? e5.height : 1;
  switch (t2) {
    case "up":
    case "down":
      return { width: n3, depth: r4 };
    case "north":
    case "south":
      return { width: n3, height: r4 };
    case "east":
    case "west":
      return { depth: n3, height: r4 };
  }
}
function p6(t2) {
  const e5 = g7.facingAxisOrderSwap[t2], n3 = g7.position, r4 = g7.normal, o3 = new Float64Array(n3.length), s3 = new Float32Array(r4.length);
  let a5 = 0;
  for (let i = 0; i < 4; i++) {
    const t3 = a5;
    for (let i2 = 0; i2 < 3; i2++) {
      const c4 = e5[i2], l5 = Math.abs(c4) - 1, f7 = c4 >= 0 ? 1 : -1;
      o3[a5] = n3[t3 + l5] * f7, s3[a5] = r4[t3 + l5] * f7, a5++;
    }
  }
  return { position: o3, normal: s3, uv: new Float32Array(g7.uv), faces: new Uint32Array(g7.faces), isPlane: true };
}
var m5 = 1;
var w5 = 2;
var v4 = 3;
var g7 = { position: [-0.5, -0.5, 0, 0.5, -0.5, 0, 0.5, 0.5, 0, -0.5, 0.5, 0], normal: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], uv: [0, 1, 1, 1, 1, 0, 0, 0], faces: [0, 1, 2, 0, 2, 3], facingAxisOrderSwap: { east: [v4, m5, w5], west: [-v4, -m5, w5], north: [-m5, v4, w5], south: [m5, -v4, w5], up: [m5, w5, v4], down: [m5, -w5, -v4] } };
function A2(t2, e5, n3) {
  t2.isPlane || y5(t2), x5(t2, n3 == null ? void 0 : n3.size);
  const { vertexAttributes: r4, transform: o3 } = _2(t2, e5, n3);
  return { vertexAttributes: new p3({ ...r4, uv: t2.uv }), transform: o3, components: [new g5({ faces: t2.faces, material: n3 && n3.material || null })], spatialReference: e5.spatialReference };
}
function y5(t2) {
  for (let e5 = 0; e5 < t2.position.length; e5 += 3)
    t2.position[e5 + 2] += 0.5;
}
function x5(t2, e5) {
  if (null == e5)
    return;
  const o3 = "number" == typeof e5 ? [e5, e5, e5] : [null != e5.width ? e5.width : 1, null != e5.depth ? e5.depth : 1, null != e5.height ? e5.height : 1];
  O4[0] = o3[0], O4[4] = o3[1], O4[8] = o3[2];
  for (let r4 = 0; r4 < t2.position.length; r4 += 3) {
    for (let e6 = 0; e6 < 3; e6++)
      F[e6] = t2.position[r4 + e6];
    S(F, F, O4);
    for (let e6 = 0; e6 < 3; e6++)
      t2.position[r4 + e6] = F[e6];
  }
  if (o3[0] !== o3[1] || o3[1] !== o3[2]) {
    O4[0] = 1 / o3[0], O4[4] = 1 / o3[1], O4[8] = 1 / o3[2];
    for (let e6 = 0; e6 < t2.normal.length; e6 += 3) {
      for (let n3 = 0; n3 < 3; n3++)
        F[n3] = t2.normal[e6 + n3];
      S(F, F, O4), z(F, F);
      for (let n3 = 0; n3 < 3; n3++)
        t2.normal[e6 + n3] = F[n3];
    }
  }
}
var d2 = { faceDescriptions: [{ axis: [0, -1, 0], uvOrigin: [0, 0.625], corners: [[-1, -1], [1, -1], [1, 1], [-1, 1]] }, { axis: [1, 0, 0], uvOrigin: [0.25, 0.625], corners: [[-1, -1], [1, -1], [1, 1], [-1, 1]] }, { axis: [0, 1, 0], uvOrigin: [0.5, 0.625], corners: [[1, -1], [-1, -1], [-1, 1], [1, 1]] }, { axis: [-1, 0, 0], uvOrigin: [0.75, 0.625], corners: [[1, -1], [-1, -1], [-1, 1], [1, 1]] }, { axis: [0, 0, 1], uvOrigin: [0, 0.375], corners: [[-1, -1], [1, -1], [1, 1], [-1, 1]] }, { axis: [0, 0, -1], uvOrigin: [0, 0.875], corners: [[-1, 1], [1, 1], [1, -1], [-1, -1]] }], uvScales: [[0, 0], [1, 0], [1, 1], [0, 1]], faceVertexOffsets: [0, 1, 2, 0, 2, 3] };
var M2 = { south: 0, east: 1, north: 2, west: 3, up: 4, down: 5 };
var F = n();
var O4 = e3();

// node_modules/@arcgis/core/geometry/support/meshUtils/rotate.js
var $ = s.getLogger("esri.geometry.support.meshUtils.rotate");
function z2(t2, r4, o3) {
  var _a, _b;
  if (!t2.vertexAttributes || !t2.vertexAttributes.position || 0 === r4[3])
    return;
  const i = t2.spatialReference;
  if (r(t2.transform)) {
    null != (o3 == null ? void 0 : o3.geographic) && o3.geographic !== t2.transform.geographic && $.warn(`Specifying the 'geographic' parameter (${o3.geographic}) different from the Mesh transform setting (${t2.transform.geographic}) is not supported`);
    const e5 = (_a = o3 == null ? void 0 : o3.origin) != null ? _a : t2.transform.getOriginPoint(i);
    C(t2.transform, r4, e5);
  } else {
    const e5 = (_b = o3 == null ? void 0 : o3.origin) != null ? _b : t2.origin;
    r3(t2.spatialReference, o3) ? I(t2, r4, e5) : U(t2, r4, e5);
  }
}
function C(t2, e5, r4) {
  const o3 = o(E, r4.x, r4.y, r4.z), i = e(E, o3, t2.origin);
  t2.applyLocalInverse(i, M3), t2.rotation = v2(t2.rotation, e5, a2()), t2.applyLocalInverse(i, i), e(i, i, M3), t2.translation = u(n(), t2.translation, i);
}
function I(t2, r4, i) {
  const n3 = t2.spatialReference, s3 = O2(n3), a5 = Z;
  gn(i, a5, s3) || gn(t2.origin, a5, s3);
  const c4 = t2.vertexAttributes.position, f7 = t2.vertexAttributes.normal, m7 = t2.vertexAttributes.tangent, g9 = new Float64Array(c4.length), l5 = r(f7) ? new Float32Array(f7.length) : null, v6 = r(m7) ? new Float32Array(m7.length) : null;
  Zn(s3, a5, P, s3), a3(S2, P);
  const x7 = O5;
  S(g4(O5), g4(r4), S2), x7[3] = r4[3], M(c4, n3, g9), r(f7) && r(l5) && j(f7, c4, g9, n3, l5), r(m7) && r(v6) && k2(m7, c4, g9, n3, v6), D(g9, x7, 3, a5), O3(g9, c4, n3), r(f7) && r(l5) && (D(l5, x7, 3), h(l5, c4, g9, n3, f7)), r(m7) && r(v6) && (D(v6, x7, 4), L3(v6, c4, g9, n3, m7)), t2.vertexAttributesChanged();
}
function U(t2, e5, r4) {
  const o3 = Z;
  if (!gn(r4, o3, t2.spatialReference)) {
    const e6 = t2.origin;
    o3[0] = e6.x, o3[1] = e6.y, o3[2] = e6.z, $.error(`Failed to project specified origin (wkid:${r4.spatialReference.wkid}) to mesh spatial reference (wkid:${t2.spatialReference.wkid}).`);
  }
  D(t2.vertexAttributes.position, e5, 3, o3), D(t2.vertexAttributes.normal, e5, 3), D(t2.vertexAttributes.tangent, e5, 4), t2.vertexAttributesChanged();
}
function D(t2, e5, o3, i = f) {
  if (!t(t2)) {
    g2(P, x2(e5), g4(e5));
    for (let e6 = 0; e6 < t2.length; e6 += o3) {
      for (let r4 = 0; r4 < 3; r4++)
        E[r4] = t2[e6 + r4] - i[r4];
      O(E, E, P);
      for (let r4 = 0; r4 < 3; r4++)
        t2[e6 + r4] = E[r4] + i[r4];
    }
  }
}
var E = n();
var M3 = n();
var O5 = a2();
var P = e4();
var S2 = e3();
var Z = n();

// node_modules/@arcgis/core/geometry/support/meshUtils/scale.js
var v5 = s.getLogger("esri.geometry.support.meshUtils.scale");
function d3(e5, r4, o3) {
  var _a;
  if (!e5.vertexAttributes || !e5.vertexAttributes.position)
    return;
  const i = e5.spatialReference;
  if (r(e5.transform)) {
    null != (o3 == null ? void 0 : o3.geographic) && o3.geographic !== e5.transform.geographic && v5.warn(`Specifying the 'geographic' parameter (${o3.geographic}) different from the Mesh transform setting (${e5.transform.geographic}) is not supported`);
    const t2 = (_a = o3 == null ? void 0 : o3.origin) != null ? _a : e5.transform.getOriginPoint(i);
    x6(e5.transform, r4, t2);
  } else {
    const t2 = r3(e5.spatialReference, o3), i2 = o3 && o3.origin || e5.origin;
    t2 ? A3(e5, r4, i2) : b3(e5, r4, i2);
  }
}
function x6(e5, t2, a5) {
  const c4 = o(w6, a5.x, a5.y, a5.z), p8 = e(w6, c4, e5.origin);
  e5.applyLocalInverse(p8, k4);
  const f7 = g(n(), e5.scale, t2);
  e5.scale = f7, e5.applyLocalInverse(p8, p8), e(p8, p8, k4), e5.translation = u(n(), e5.translation, p8);
}
function A3(e5, r4, o3) {
  const i = e5.spatialReference, n3 = O2(i), s3 = R;
  gn(o3, s3, n3) || gn(e5.origin, s3, n3);
  const a5 = e5.vertexAttributes.position, f7 = e5.vertexAttributes.normal, v6 = e5.vertexAttributes.tangent, d4 = new Float64Array(a5.length), x7 = r(f7) ? new Float32Array(f7.length) : null, A4 = r(v6) ? new Float32Array(v6.length) : null;
  M(a5, i, d4), r(f7) && r(x7) && j(f7, a5, d4, i, x7), r(v6) && r(A4) && k2(v6, a5, d4, i, A4), y6(d4, r4, s3), O3(d4, a5, i), r(f7) && r(x7) && h(x7, a5, d4, i, f7), r(v6) && r(A4) && L3(A4, a5, d4, i, v6), e5.vertexAttributesChanged();
}
function b3(e5, t2, r4) {
  const o3 = R;
  if (!gn(r4, o3, e5.spatialReference)) {
    const t3 = e5.origin;
    o3[0] = t3.x, o3[1] = t3.y, o3[2] = t3.z, v5.error(`Failed to project specified origin (wkid:${r4.spatialReference.wkid}) to mesh spatial reference (wkid:${e5.spatialReference.wkid}).`);
  }
  y6(e5.vertexAttributes.position, t2, o3), e5.vertexAttributesChanged();
}
function y6(e5, t2, r4 = f) {
  if (e5)
    for (let o3 = 0; o3 < e5.length; o3 += 3) {
      for (let t3 = 0; t3 < 3; t3++)
        w6[t3] = e5[o3 + t3] - r4[t3];
      g(w6, w6, t2);
      for (let t3 = 0; t3 < 3; t3++)
        e5[o3 + t3] = w6[t3] + r4[t3];
    }
}
var w6 = n();
var k4 = n();
var R = n();

// node_modules/@arcgis/core/geometry/Mesh.js
var G;
var I2 = "esri.geometry.Mesh";
var B = G = class extends a(m2.LoadableMixin(m(p2))) {
  constructor(e5) {
    super(e5), this.components = null, this.transform = null, this.external = null, this.hasZ = true, this.hasM = false, this.vertexAttributes = new p3(), this.type = "mesh";
  }
  initialize() {
    (t(this.external) || this.vertexAttributes.position.length) && (this.loadStatus = "loaded"), this.when(() => {
      this.handles.add(l(() => {
        var _a;
        return { vertexAttributes: this.vertexAttributes, components: (_a = this.components) == null ? void 0 : _a.map((e5) => e5.clone()) };
      }, () => this._set("external", null), { once: true, sync: true }));
    });
  }
  get hasExtent() {
    return !this.loaded && r(this.external) && r(this.external.extent) || this.loaded && this.vertexAttributes.position.length > 0 && (!this.components || this.components.length > 0);
  }
  get _boundingInfo() {
    const e5 = this.vertexAttributes.position, t2 = this.spatialReference;
    if (0 === e5.length || this.components && 0 === this.components.length)
      return { extent: new w2({ xmin: 0, ymin: 0, zmin: 0, xmax: 0, ymax: 0, zmax: 0, spatialReference: t2 }), center: new w({ x: 0, y: 0, z: 0, spatialReference: t2 }) };
    const r4 = r(this.transform) ? this.transform.project(e5, t2) : e5;
    let o3 = 1 / 0, n3 = 1 / 0, s3 = 1 / 0, a5 = -1 / 0, l5 = -1 / 0, c4 = -1 / 0, p8 = 0, m7 = 0, h4 = 0;
    const f7 = r4.length, d4 = 1 / (f7 / 3);
    let x7 = 0;
    for (; x7 < f7; ) {
      const e6 = r4[x7++], t3 = r4[x7++], i = r4[x7++];
      o3 = Math.min(o3, e6), n3 = Math.min(n3, t3), s3 = Math.min(s3, i), a5 = Math.max(a5, e6), l5 = Math.max(l5, t3), c4 = Math.max(c4, i), p8 += d4 * e6, m7 += d4 * t3, h4 += d4 * i;
    }
    return { extent: new w2({ xmin: o3, ymin: n3, zmin: s3, xmax: a5, ymax: l5, zmax: c4, spatialReference: t2 }), center: new w({ x: p8, y: m7, z: h4, spatialReference: t2 }) };
  }
  get anchor() {
    if (r(this.transform))
      return this.transform.getOriginPoint(this.spatialReference);
    const e5 = this._boundingInfo;
    return new w({ x: e5.center.x, y: e5.center.y, z: e5.extent.zmin, spatialReference: this.spatialReference });
  }
  get origin() {
    return r(this.transform) ? this.transform.getOriginPoint(this.spatialReference) : this._boundingInfo.center;
  }
  get extent() {
    return !this.loaded && r(this.external) && r(this.external.extent) ? this.external.extent.clone() : this._boundingInfo.extent;
  }
  addComponent(e5) {
    this.loaded ? (this.components || (this.components = []), this.components.push(g5.from(e5)), this.notifyChange("components")) : s.getLogger(this.declaredClass).error("addComponent()", "Mesh must be loaded before applying operations");
  }
  removeComponent(e5) {
    if (this.loaded) {
      if (this.components) {
        const t2 = this.components.indexOf(e5);
        if (-1 !== t2)
          return this.components.splice(t2, 1), void this.notifyChange("components");
      }
      s.getLogger(this.declaredClass).error("removeComponent()", "Provided component is not part of the list of components");
    } else
      s.getLogger(this.declaredClass).error("removeComponent()", "Mesh must be loaded before applying operations");
  }
  rotate(e5, t2, r4, o3) {
    return k(k5.x, e5, D2), k(k5.y, t2, W), k(k5.z, r4, Z2), v2(D2, W, D2), v2(D2, Z2, D2), z2(this, D2, o3), this;
  }
  offset(e5, t2, r4, o3) {
    return this.loaded ? (H[0] = e5, H[1] = t2, H[2] = r4, x4(this, H, o3), this) : (s.getLogger(this.declaredClass).error("offset()", "Mesh must be loaded before applying operations"), this);
  }
  scale(e5, t2) {
    return this.loaded ? (d3(this, e5, t2), this) : (s.getLogger(this.declaredClass).error("scale()", "Mesh must be loaded before applying operations"), this);
  }
  centerAt(e5, t2) {
    return this.loaded ? (c(this, e5, t2), this) : (s.getLogger(this.declaredClass).error("centerAt()", "Mesh must be loaded before applying operations"), this);
  }
  load(e5) {
    return r(this.external) && this.addResolvingPromise(u2(this, this.external.source, e5)), Promise.resolve(this);
  }
  updateExternalSource(e5) {
    this._set("external", e5);
  }
  clone() {
    let e5 = null;
    if (this.components) {
      const t3 = /* @__PURE__ */ new Map(), r4 = /* @__PURE__ */ new Map();
      e5 = this.components.map((e6) => e6.cloneWithDeduplication(t3, r4));
    }
    const t2 = { components: e5, spatialReference: this.spatialReference, vertexAttributes: this.vertexAttributes.clone(), transform: r(this.transform) ? this.transform.clone() : null, external: r(this.external) ? { source: this.external.source, extent: r(this.external.extent) ? this.external.extent.clone() : null } : null };
    return new G(t2);
  }
  vertexAttributesChanged() {
    this.notifyChange("vertexAttributes");
  }
  async toBinaryGLTF(e5) {
    const t2 = import("./gltfexport-IY26QB6H.js"), r4 = this.load(), o3 = await Promise.all([t2, r4]), { toBinaryGLTF: n3 } = o3[0];
    return n3(this, e5);
  }
  static createBox(e5, t2) {
    if (!(e5 instanceof w))
      return s.getLogger(I2).error(".createBox()", "expected location to be a Point instance"), null;
    const r4 = new G(A2(c2(), e5, t2));
    return t2 && t2.imageFace && "all" !== t2.imageFace ? l3(r4, t2.imageFace) : r4;
  }
  static createSphere(e5, t2) {
    return e5 instanceof w ? new G(A2(f5(t2 && t2.densificationFactor || 0), e5, t2)) : (s.getLogger(I2).error(".createSphere()", "expected location to be a Point instance"), null);
  }
  static createCylinder(e5, t2) {
    return e5 instanceof w ? new G(A2(u3(t2 && t2.densificationFactor || 0), e5, t2)) : (s.getLogger(I2).error(".createCylinder()", "expected location to be a Point instance"), null);
  }
  static createPlane(e5, t2) {
    var _a;
    if (!(e5 instanceof w))
      return s.getLogger(I2).error(".createPlane()", "expected location to be a Point instance"), null;
    const r4 = (_a = t2 == null ? void 0 : t2.facing) != null ? _a : "up", o3 = h3(r4, t2 == null ? void 0 : t2.size);
    return new G(A2(p6(r4), e5, { ...t2, size: o3 }));
  }
  static createFromPolygon(e5, t2) {
    var _a;
    if (!(e5 instanceof v))
      return s.getLogger(I2).error(".createFromPolygon()", "expected polygon to be a Polygon instance"), null;
    const r4 = o2(e5);
    return new G({ vertexAttributes: new p3({ position: r4.position }), components: [new g5({ faces: r4.faces, shading: "flat", material: (_a = t2 == null ? void 0 : t2.material) != null ? _a : null })], spatialReference: e5.spatialReference });
  }
  static async createFromGLTF(e5, r4, o3) {
    if (!(e5 instanceof w))
      throw s.getLogger(I2).error(".createfromGLTF()", "expected location to be a Point instance"), new s2("invalid-input", "Expected location to be a Point instance");
    const { loadGLTFMesh: s3 } = await y2(import("./loadGLTFMesh-IDQA3VKJ.js"), o3);
    return new G(await s3(e5, r4, o3));
  }
  static createWithExternalSource(e5, t2, r4) {
    var _a, _b, _c, _d;
    const o3 = (_a = r4 == null ? void 0 : r4.extent) != null ? _a : null, n3 = (_c = (_b = r4 == null ? void 0 : r4.transform) == null ? void 0 : _b.clone()) != null ? _c : new L2();
    n3.origin = [e5.x, e5.y, (_d = e5.z) != null ? _d : 0];
    const s3 = e5.spatialReference;
    return new G({ external: { source: t2, extent: o3 }, transform: n3, spatialReference: s3 });
  }
  static createIncomplete(e5, r4) {
    var _a, _b, _c;
    const o3 = (_b = (_a = r4 == null ? void 0 : r4.transform) == null ? void 0 : _a.clone()) != null ? _b : new L2();
    o3.origin = [e5.x, e5.y, (_c = e5.z) != null ? _c : 0];
    const n3 = e5.spatialReference, s3 = new G({ transform: o3, spatialReference: n3 });
    return s3.addResolvingPromise(Promise.reject(new s2("mesh-incomplete", "Mesh resources are not complete"))), s3;
  }
};
e2([y({ type: [g5], json: { write: true } })], B.prototype, "components", void 0), e2([y({ type: L2, json: { write: true } })], B.prototype, "transform", void 0), e2([y({ constructOnly: true })], B.prototype, "external", void 0), e2([y({ readOnly: true })], B.prototype, "hasExtent", null), e2([y({ readOnly: true })], B.prototype, "_boundingInfo", null), e2([y({ readOnly: true })], B.prototype, "anchor", null), e2([y({ readOnly: true })], B.prototype, "origin", null), e2([y({ readOnly: true, json: { read: false } })], B.prototype, "extent", null), e2([y({ readOnly: true, json: { read: false, write: true, default: true } })], B.prototype, "hasZ", void 0), e2([y({ readOnly: true, json: { read: false, write: true, default: false } })], B.prototype, "hasM", void 0), e2([y({ type: p3, nonNullable: true, json: { write: true } })], B.prototype, "vertexAttributes", void 0), B = G = e2([n2(I2)], B);
var k5 = { x: r2(1, 0, 0), y: r2(0, 1, 0), z: r2(0, 0, 1) };
var D2 = a2();
var W = a2();
var Z2 = a2();
var H = n();
var N = B;

// node_modules/@arcgis/core/rest/support/meshFeatureSet.js
function l4(o3, s3, n3) {
  const a5 = n3.features;
  n3.features = [], delete n3.geometryType;
  const i = x.fromJSON(n3);
  if (i.geometryType = "mesh", !n3.assetMaps)
    return i;
  const l5 = E2(s3, n3.assetMaps), m7 = i.spatialReference, p8 = n3.globalIdFieldName, g9 = t(o3.outFields) || !o3.outFields.length ? () => ({}) : c3(o3.outFields.includes("*") ? null : new Set(o3.outFields));
  for (const e5 of a5) {
    const o4 = f6(e5, p8, m7, s3, l5);
    r(o4) && i.features.push(new g3({ geometry: o4, attributes: g9(e5) }));
  }
  return i;
}
function c3(t2) {
  return ({ attributes: e5 }) => {
    if (!e5)
      return {};
    if (!t2)
      return e5;
    for (const r4 in e5)
      t2.has(r4) || delete e5[r4];
    return e5;
  };
}
function f6(t2, e5, r4, n3, a5) {
  const i = t2.attributes[e5], u4 = a5.get(i);
  if (null == u4 || u4.status === g8.FAILED || null == u4.url)
    return null;
  const l5 = m6(t2, r4, n3), c4 = w2.fromJSON(t2.geometry);
  c4.spatialReference = r4;
  const f7 = p7(t2.attributes, n3, u4.geographic);
  return u4.status === g8.PENDING ? N.createIncomplete(l5, { extent: c4, transform: f7 }) : N.createWithExternalSource(l5, [{ name: u4.name, source: u4.url }], { extent: c4, transform: f7 });
}
function m6({ attributes: t2 }, e5, { transformFieldRoles: r4 }) {
  return new w({ x: t2[r4.originX], y: t2[r4.originY], z: t2[r4.originZ], spatialReference: e5 });
}
function p7(t2, { transformFieldRoles: e5 }, r4) {
  return new L2({ translation: [t2[e5.translationX], t2[e5.translationY], t2[e5.translationZ]], rotation: k([t2[e5.rotationX], t2[e5.rotationY], t2[e5.rotationZ]], t2[e5.rotationDeg]), scale: [t2[e5.scaleX], t2[e5.scaleY], t2[e5.scaleZ]], geographic: r4 });
}
var g8;
function E2(t2, e5) {
  const r4 = /* @__PURE__ */ new Map();
  for (const o3 of e5) {
    const t3 = o3.parentGlobalId;
    if (null == t3)
      continue;
    const e6 = o3.assetName, s3 = o3.assetURL, n3 = o3.conversionStatus;
    let a5 = r4.get(t3);
    if (null != a5)
      throw new Error("multiple asset parts not expected.");
    switch (a5 = { name: e6, status: g8.FAILED, url: s3, geographic: D3(o3.flags).projectVertices }, r4.set(t3, a5), n3) {
      case "COMPLETED":
      case "SUBMITTED":
        a5.status = g8.COMPLETED;
        break;
      case "INPROGRESS":
        a5.status = g8.PENDING;
        break;
      default:
        a5.status = g8.FAILED;
    }
  }
  return r4;
}
function D3(t2) {
  return { projectVertices: t2.includes("PROJECT_VERTICES") };
}
!function(t2) {
  t2[t2.FAILED = 0] = "FAILED", t2[t2.PENDING = 1] = "PENDING", t2[t2.COMPLETED = 2] = "COMPLETED";
}(g8 || (g8 = {}));
export {
  l4 as meshFeatureSetFromJSON
};
//# sourceMappingURL=meshFeatureSet-27B4YK23.js.map
