import {
  e as e2
} from "./chunk-XFDO4CMR.js";
import {
  e
} from "./chunk-GHN7C53L.js";
import {
  P,
  Y,
  _,
  z
} from "./chunk-3LR5O4WA.js";
import {
  D,
  E,
  a as a2,
  j,
  l,
  q,
  r as r2,
  s,
  v,
  x,
  y
} from "./chunk-GDVNKPJ7.js";
import {
  n,
  r
} from "./chunk-D4V6J5BT.js";
import {
  a,
  n as n2
} from "./chunk-OSHI574D.js";

// node_modules/@arcgis/core/chunks/quat.js
function b(t) {
  return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t;
}
function v2(t, s2, a3) {
  a3 *= 0.5;
  const n3 = Math.sin(a3);
  return t[0] = n3 * s2[0], t[1] = n3 * s2[1], t[2] = n3 * s2[2], t[3] = Math.cos(a3), t;
}
function x2(t, s2) {
  const a3 = 2 * Math.acos(s2[3]), n3 = Math.sin(a3 / 2);
  return n3 > a() ? (t[0] = s2[0] / n3, t[1] = s2[1] / n3, t[2] = s2[2] / n3) : (t[0] = 1, t[1] = 0, t[2] = 0), a3;
}
function y2(t, s2, a3) {
  const n3 = s2[0], o = s2[1], r3 = s2[2], e3 = s2[3], c = a3[0], u = a3[1], i = a3[2], h = a3[3];
  return t[0] = n3 * h + e3 * c + o * i - r3 * u, t[1] = o * h + e3 * u + r3 * c - n3 * i, t[2] = r3 * h + e3 * i + n3 * u - o * c, t[3] = e3 * h - n3 * c - o * u - r3 * i, t;
}
function A(t, s2, a3) {
  a3 *= 0.5;
  const n3 = s2[0], o = s2[1], r3 = s2[2], e3 = s2[3], c = Math.sin(a3), u = Math.cos(a3);
  return t[0] = n3 * u + e3 * c, t[1] = o * u + r3 * c, t[2] = r3 * u - o * c, t[3] = e3 * u - n3 * c, t;
}
function I(t, s2, a3) {
  a3 *= 0.5;
  const n3 = s2[0], o = s2[1], r3 = s2[2], e3 = s2[3], c = Math.sin(a3), u = Math.cos(a3);
  return t[0] = n3 * u - r3 * c, t[1] = o * u + e3 * c, t[2] = r3 * u + n3 * c, t[3] = e3 * u - o * c, t;
}
function _2(t, s2, a3) {
  a3 *= 0.5;
  const n3 = s2[0], o = s2[1], r3 = s2[2], e3 = s2[3], c = Math.sin(a3), u = Math.cos(a3);
  return t[0] = n3 * u + o * c, t[1] = o * u - n3 * c, t[2] = r3 * u + e3 * c, t[3] = e3 * u - r3 * c, t;
}
function z2(t, s2) {
  const a3 = s2[0], n3 = s2[1], o = s2[2];
  return t[0] = a3, t[1] = n3, t[2] = o, t[3] = Math.sqrt(Math.abs(1 - a3 * a3 - n3 * n3 - o * o)), t;
}
function E2(t, s2, a3, n3) {
  const r3 = s2[0], e3 = s2[1], c = s2[2], u = s2[3];
  let i, h, M, f, l2, m = a3[0], p = a3[1], q2 = a3[2], g = a3[3];
  return h = r3 * m + e3 * p + c * q2 + u * g, h < 0 && (h = -h, m = -m, p = -p, q2 = -q2, g = -g), 1 - h > a() ? (i = Math.acos(h), M = Math.sin(i), f = Math.sin((1 - n3) * i) / M, l2 = Math.sin(n3 * i) / M) : (f = 1 - n3, l2 = n3), t[0] = f * r3 + l2 * m, t[1] = f * e3 + l2 * p, t[2] = f * c + l2 * q2, t[3] = f * u + l2 * g, t;
}
function L(t) {
  const s2 = n2, a3 = s2(), n3 = s2(), o = s2(), e3 = Math.sqrt(1 - a3), c = Math.sqrt(a3);
  return t[0] = e3 * Math.sin(2 * Math.PI * n3), t[1] = e3 * Math.cos(2 * Math.PI * n3), t[2] = c * Math.sin(2 * Math.PI * o), t[3] = c * Math.cos(2 * Math.PI * o), t;
}
function O(t, s2) {
  const a3 = s2[0], n3 = s2[1], o = s2[2], r3 = s2[3], e3 = a3 * a3 + n3 * n3 + o * o + r3 * r3, c = e3 ? 1 / e3 : 0;
  return t[0] = -a3 * c, t[1] = -n3 * c, t[2] = -o * c, t[3] = r3 * c, t;
}
function S(t, s2) {
  return t[0] = -s2[0], t[1] = -s2[1], t[2] = -s2[2], t[3] = s2[3], t;
}
function T(t, s2) {
  const a3 = s2[0] + s2[4] + s2[8];
  let n3;
  if (a3 > 0)
    n3 = Math.sqrt(a3 + 1), t[3] = 0.5 * n3, n3 = 0.5 / n3, t[0] = (s2[5] - s2[7]) * n3, t[1] = (s2[6] - s2[2]) * n3, t[2] = (s2[1] - s2[3]) * n3;
  else {
    let a4 = 0;
    s2[4] > s2[0] && (a4 = 1), s2[8] > s2[3 * a4 + a4] && (a4 = 2);
    const o = (a4 + 1) % 3, r3 = (a4 + 2) % 3;
    n3 = Math.sqrt(s2[3 * a4 + a4] - s2[3 * o + o] - s2[3 * r3 + r3] + 1), t[a4] = 0.5 * n3, n3 = 0.5 / n3, t[3] = (s2[3 * o + r3] - s2[3 * r3 + o]) * n3, t[o] = (s2[3 * o + a4] + s2[3 * a4 + o]) * n3, t[r3] = (s2[3 * r3 + a4] + s2[3 * a4 + r3]) * n3;
  }
  return t;
}
function k(t, s2, a3, n3) {
  const o = 0.5 * Math.PI / 180;
  s2 *= o, a3 *= o, n3 *= o;
  const r3 = Math.sin(s2), e3 = Math.cos(s2), c = Math.sin(a3), u = Math.cos(a3), i = Math.sin(n3), h = Math.cos(n3);
  return t[0] = r3 * u * h - e3 * c * i, t[1] = e3 * c * h + r3 * u * i, t[2] = e3 * u * i - r3 * c * h, t[3] = e3 * u * h + r3 * c * i, t;
}
function w(t) {
  return "quat(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")";
}
var B = a2;
var C = r2;
var D2 = s;
var F = y2;
var G = l;
var R = y;
var W = j;
var X = x;
var Y2 = X;
var Z = q;
var H = Z;
var J = v;
var K = D;
var N = E;
function Q(t, s2, a3) {
  const n3 = P(s2, a3);
  return n3 < -0.999999 ? (_(U, V, s2), Y(U) < 1e-6 && _(U, $, s2), z(U, U), v2(t, U, Math.PI), t) : n3 > 0.999999 ? (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t) : (_(U, s2, a3), t[0] = U[0], t[1] = U[1], t[2] = U[2], t[3] = 1 + n3, J(t, t));
}
var U = n();
var V = r(1, 0, 0);
var $ = r(0, 1, 0);
function tt(t, s2, a3, n3, o, r3) {
  return E2(st, s2, o, r3), E2(at, a3, n3, r3), E2(t, st, at, 2 * r3 * (1 - r3)), t;
}
var st = e2();
var at = e2();
function nt(t, s2, a3, n3) {
  const o = ot;
  return o[0] = a3[0], o[3] = a3[1], o[6] = a3[2], o[1] = n3[0], o[4] = n3[1], o[7] = n3[2], o[2] = -s2[0], o[5] = -s2[1], o[8] = -s2[2], J(t, T(t, o));
}
var ot = e();
var rt = Object.freeze(Object.defineProperty({ __proto__: null, identity: b, setAxisAngle: v2, getAxisAngle: x2, multiply: y2, rotateX: A, rotateY: I, rotateZ: _2, calculateW: z2, slerp: E2, random: L, invert: O, conjugate: S, fromMat3: T, fromEuler: k, str: w, copy: B, set: C, add: D2, mul: F, scale: G, dot: R, lerp: W, length: X, len: Y2, squaredLength: Z, sqrLen: H, normalize: J, exactEquals: K, equals: N, rotationTo: Q, sqlerp: tt, setAxes: nt }, Symbol.toStringTag, { value: "Module" }));

export {
  v2 as v,
  x2 as x,
  y2 as y,
  O,
  S,
  k,
  K,
  Q
};
//# sourceMappingURL=chunk-NGFMX3UT.js.map
