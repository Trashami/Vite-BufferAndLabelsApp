import {
  v as v2
} from "./chunk-IJUE2JUP.js";
import {
  g
} from "./chunk-J6LQZWZI.js";
import {
  v
} from "./chunk-EHPBHJYZ.js";
import {
  k2 as k
} from "./chunk-LNZAOBFW.js";
import {
  y as y2
} from "./chunk-HVKDYDPP.js";
import {
  A,
  l,
  y
} from "./chunk-6QC7MLLS.js";
import {
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/layers/graphics/hydratedFeatures.js
function l2(e) {
  return "declaredClass" in e;
}
function u(e) {
  return "declaredClass" in e;
}
function c(e) {
  return "declaredClass" in e;
}
function f(r, n) {
  if (!r)
    return null;
  if (c(r))
    return r;
  const s = new g({ layer: n, sourceLayer: n });
  return s.visible = r.visible, s.symbol = y2(r.symbol), s.attributes = y2(r.attributes), s.geometry = p(r.geometry), s;
}
function p(e) {
  return t(e) ? null : l2(e) ? e : v(h(e));
}
function h(e) {
  const { wkid: t2, wkt: r, latestWkid: n } = e.spatialReference, s = { wkid: t2, wkt: r, latestWkid: n };
  switch (e.type) {
    case "point": {
      const { x: t3, y: r2, z: n2, m: a } = e;
      return { x: t3, y: r2, z: n2, m: a, spatialReference: s };
    }
    case "polygon": {
      const { rings: t3, hasZ: r2, hasM: n2 } = e;
      return { rings: y3(t3), hasZ: r2, hasM: n2, spatialReference: s };
    }
    case "polyline": {
      const { paths: t3, hasZ: r2, hasM: n2 } = e;
      return { paths: y3(t3), hasZ: r2, hasM: n2, spatialReference: s };
    }
    case "extent": {
      const { xmin: t3, xmax: r2, ymin: n2, ymax: a, zmin: i, zmax: o, mmin: m, mmax: l3, hasZ: u2, hasM: c2 } = e;
      return { xmin: t3, xmax: r2, ymin: n2, ymax: a, zmin: i, zmax: o, mmin: m, mmax: l3, hasZ: u2, hasM: c2, spatialReference: s };
    }
    case "multipoint": {
      const { points: t3, hasZ: r2, hasM: n2 } = e;
      return { points: M(t3) ? d(t3) : t3, hasZ: r2, hasM: n2, spatialReference: s };
    }
    default:
      return;
  }
}
function y3(e) {
  return x(e) ? e.map((e2) => d(e2)) : e;
}
function d(e) {
  return e.map((e2) => l(e2));
}
function x(e) {
  for (const t2 of e)
    if (0 !== t2.length)
      return M(t2);
  return false;
}
function M(e) {
  return e.length && (y(e[0]) || A(e[0]));
}
function k2(e, t2) {
  if (!e)
    return null;
  let r;
  if (u(e)) {
    if (null == t2)
      return e.clone();
    if (u(t2))
      return t2.copy(e);
  }
  return null != t2 ? (r = t2, r.x = e.x, r.y = e.y, r.spatialReference = e.spatialReference, e.hasZ ? (r.z = e.z, r.hasZ = e.hasZ) : (r.z = null, r.hasZ = false), e.hasM ? (r.m = e.m, r.hasM = true) : (r.m = null, r.hasM = false)) : (r = v2(e.x, e.y, e.z, e.spatialReference), e.hasM && (r.m = e.m, r.hasM = true)), r;
}
function Z(e) {
  const { wkid: t2, wkt: r, latestWkid: n } = e, s = { wkid: t2, wkt: r, latestWkid: n };
  return k.fromJSON(s);
}

export {
  l2 as l,
  f,
  p,
  k2 as k,
  Z
};
//# sourceMappingURL=chunk-FS3REKZ4.js.map
