import {
  o as o2
} from "./chunk-DWAZ7HI7.js";
import {
  c
} from "./chunk-7QNA4ADD.js";
import {
  E
} from "./chunk-MATM5L52.js";
import {
  e
} from "./chunk-C6PUUIY2.js";
import {
  a as a2
} from "./chunk-HT2GXPWH.js";
import {
  e2,
  r as r3,
  u
} from "./chunk-BQL7VXQR.js";
import {
  o
} from "./chunk-735C75BI.js";
import {
  n as n2,
  t as t2
} from "./chunk-ZLTZ3KAT.js";
import {
  D,
  G,
  P
} from "./chunk-3OFVLRSL.js";
import {
  l,
  n
} from "./chunk-NDQ5FHGV.js";
import {
  r as r2
} from "./chunk-GDVNKPJ7.js";
import {
  a,
  r,
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/StippleTextureRepository.js
var u2 = class {
  constructor(t4) {
    this._rctx = t4, this._cache = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._cache.forEach((t4) => a(t4.stippleTexture)), this._cache.clear();
  }
  _acquire(t4) {
    if (t(t4))
      return null;
    const e4 = this._patternId(t4), o3 = this._cache.get(e4);
    if (o3)
      return o3.refCount++, o3;
    const { encodedData: n3, paddedPixels: u4 } = p(t4), l3 = new h(new E(this._rctx, { width: u4, height: 1, internalFormat: P.RGBA, pixelFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, wrapMode: D.CLAMP_TO_EDGE }, n3));
    return this._cache.set(e4, l3), l3;
  }
  release(t4) {
    if (t(t4))
      return;
    const e4 = this._patternId(t4), n3 = this._cache.get(e4);
    n3 && (n3.refCount--, 0 === n3.refCount && (r(n3.stippleTexture) && n3.stippleTexture.dispose(), this._cache.delete(e4)));
  }
  swap(t4, e4) {
    const r4 = this._acquire(e4);
    return this.release(t4), r4;
  }
  _patternId(t4) {
    return `${t4.pattern.join(",")}-r${t4.pixelRatio}`;
  }
};
var h = class extends t2 {
  constructor(t4) {
    super(), this.stippleTexture = t4, this.refCount = 1;
  }
};
function p(e4) {
  const r4 = l2(e4), o3 = 1 / e4.pixelRatio, n3 = f(e4), s = d(e4), i = (Math.floor(0.5 * (s - 1)) + 0.5) * o3, c2 = [];
  let a3 = 1;
  for (const t4 of r4) {
    for (let e5 = 0; e5 < t4; e5++) {
      const r5 = a3 * (Math.min(e5, t4 - 1 - e5) + 0.5) * o3 / i * 0.5 + 0.5;
      c2.push(r5);
    }
    a3 = -a3;
  }
  const u4 = Math.round(r4[0] / 2), h3 = [...c2.slice(u4), ...c2.slice(0, u4)], p2 = n3 + m, _ = new Uint8Array(4 * p2);
  let x2 = 4;
  for (const l3 of h3)
    o2(l3, _, x2), x2 += 4;
  return _.copyWithin(0, x2 - 4, x2), _.copyWithin(x2, 4, 8), { encodedData: _, paddedPixels: p2 };
}
function l2(t4) {
  return t4.pattern.map((e4) => Math.round(e4 * t4.pixelRatio));
}
function f(t4) {
  if (t(t4))
    return 1;
  const e4 = l2(t4);
  return Math.floor(e4.reduce((t5, e5) => t5 + e5));
}
function d(t4) {
  return l2(t4).reduce((t5, e4) => Math.max(t5, e4));
}
var m = 2;

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/ensureColor4.js
function t3(c2) {
  return t(c2) ? l : 4 === c2.length ? c2 : r2(e3, c2[0], c2[1], c2[2], 1);
}
var e3 = n();

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/LineStipple.glsl.js
function u3(e4, t4) {
  e4.constants.add("stippleAlphaColorDiscard", "float", 1e-3), e4.constants.add("stippleAlphaHighlightDiscard", "float", 0.5), t4.stippleEnabled ? m2(e4, t4) : S(e4);
}
function m2(e4, d2) {
  const c2 = !(d2.draped && d2.stipplePreferContinuous), { vertex: u4, fragment: m3 } = e4;
  m3.include(a2), d2.draped || (c(u4, d2), u4.uniforms.add(new o("worldToScreenPerDistanceRatio", (e5, t4) => 1 / t4.camera.perScreenPixelRatio)), u4.code.add(n2`float computeWorldToScreenRatio(vec3 segmentCenter) {
float segmentDistanceToCamera = length(segmentCenter - cameraPosition);
return worldToScreenPerDistanceRatio / segmentDistanceToCamera;
}`)), e4.varyings.add("vStippleDistance", "float"), d2.stippleRequiresClamp && e4.varyings.add("vStippleDistanceLimits", "vec2"), d2.stippleRequiresStretchMeasure && e4.varyings.add("vStipplePatternStretch", "float"), u4.code.add(n2`
    float discretizeWorldToScreenRatio(float worldToScreenRatio) {
      float step = ${x};

      float discreteWorldToScreenRatio = log(worldToScreenRatio);
      discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;
      discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);
      return discreteWorldToScreenRatio;
    }
  `), u4.code.add(n2`vec2 computeStippleDistanceLimits(float startPseudoScreen, float segmentLengthPseudoScreen, float segmentLengthScreen, float patternLength) {`), u4.code.add(n2`
    if (segmentLengthPseudoScreen >= ${c2 ? "patternLength" : "1e4"}) {
  `), u4.uniforms.add(new o("pixelRatio", (e5, t4) => t4.camera.pixelRatio)), u4.code.add(n2`
        // Round the screen length to get an integer number of pattern repetitions (minimum 1).
        float repetitions = segmentLengthScreen / (patternLength * pixelRatio);
        float flooredRepetitions = max(1.0, floor(repetitions + 0.5));
        float segmentLengthScreenRounded = flooredRepetitions * patternLength;

        ${d2.stippleRequiresStretchMeasure ? n2`
              float stretch = repetitions / flooredRepetitions;

              // We need to impose a lower bound on the stretch factor to prevent the dots from merging together when there is only 1 repetition.
              // 0.75 is the lowest possible stretch value for flooredRepetitions > 1, so it makes sense as lower bound.
              vStipplePatternStretch = max(0.75, stretch);` : ""}

        return vec2(0.0, segmentLengthScreenRounded);
      }
      return vec2(startPseudoScreen, startPseudoScreen + segmentLengthPseudoScreen);
    }
  `), m3.constants.add("stippleTexturePadding", "float", m);
  const S2 = d2.hasWebGL2Context ? e2.None : e2.Size;
  m3.uniforms.add(u("stipplePatternTexture", (e5) => e5.stippleTexture, S2)), m3.uniforms.add([new o("stipplePatternSDFNormalizer", (e5) => h2(e5.stipplePattern)), new o("stipplePatternPixelSizeInv", (e5) => 1 / g(e5))]), m3.code.add(n2`
    float padStippleTexture(float u) {
      float paddedTextureSize = ${r3(d2, "stipplePatternTexture")}.x;
      float unpaddedTextureSize = paddedTextureSize - stippleTexturePadding;

      return (u * unpaddedTextureSize + stippleTexturePadding * 0.5) / paddedTextureSize;
    }
  `), m3.code.add(n2`
    float getStippleSDF(out bool isClamped) {
      ${d2.stippleRequiresClamp ? n2`
          float stippleDistanceClamped = clamp(vStippleDistance, vStippleDistanceLimits.x, vStippleDistanceLimits.y);
          vec2 aaCorrectedLimits = vStippleDistanceLimits + vec2(1.0, -1.0) / gl_FragCoord.w;
          isClamped = vStippleDistance < aaCorrectedLimits.x || vStippleDistance > aaCorrectedLimits.y;` : n2`
          float stippleDistanceClamped = vStippleDistance;
          isClamped = false;`}

      float u = stippleDistanceClamped * gl_FragCoord.w * stipplePatternPixelSizeInv;
      ${d2.stippleScaleWithLineWidth ? n2`u *= vLineSizeInv;` : ""}
      u = padStippleTexture(fract(u));

      float encodedSDF = rgba2float(texture2D(stipplePatternTexture, vec2(u, 0.5)));
      float sdf = (encodedSDF * 2.0 - 1.0) * stipplePatternSDFNormalizer;

      ${d2.stippleRequiresStretchMeasure ? n2`return (sdf - 0.5) * vStipplePatternStretch + 0.5;` : n2`return sdf;`}
    }

    float getStippleSDF() {
      bool ignored;
      return getStippleSDF(ignored);
    }

    float getStippleAlpha() {
      bool isClamped;
      float stippleSDF = getStippleSDF(isClamped);

      float antiAliasedResult = ${d2.stippleScaleWithLineWidth ? n2`clamp(stippleSDF * vLineWidth + 0.5, 0.0, 1.0);` : n2`clamp(stippleSDF + 0.5, 0.0, 1.0);`}

      return isClamped ? floor(antiAliasedResult + 0.5) : antiAliasedResult;
    }
  `), d2.stippleOffColorEnabled ? (m3.uniforms.add(new e("stippleOffColor", (e5) => t3(e5.stippleOffColor))), m3.code.add(n2`#define discardByStippleAlpha(stippleAlpha, threshold) {}
#define blendStipple(color, stippleAlpha) mix(color, stippleOffColor, stippleAlpha)`)) : m3.code.add(n2`#define discardByStippleAlpha(stippleAlpha, threshold) if (stippleAlpha < threshold) { discard; }
#define blendStipple(color, stippleAlpha) vec4(color.rgb, color.a * stippleAlpha)`);
}
function S(e4) {
  e4.fragment.code.add(n2`float getStippleAlpha() { return 1.0; }
#define discardByStippleAlpha(_stippleAlpha_, _threshold_) {}
#define blendStipple(color, _stippleAlpha_) color`);
}
function h2(t4) {
  return r(t4) ? (Math.floor(0.5 * (d(t4) - 1)) + 0.5) / t4.pixelRatio : 1;
}
function g(t4) {
  const i = t4.stipplePattern;
  return r(i) ? f(t4.stipplePattern) / i.pixelRatio : 1;
}
var x = n2.float(0.4);

export {
  u2 as u,
  u3 as u2,
  g
};
//# sourceMappingURL=chunk-5OCDKMG5.js.map
