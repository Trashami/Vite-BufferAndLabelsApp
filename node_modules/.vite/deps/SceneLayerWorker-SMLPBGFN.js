import "./chunk-FCIHN4UG.js";
import "./chunk-XFDO4CMR.js";
import "./chunk-IVLBGTXL.js";
import "./chunk-GHN7C53L.js";
import "./chunk-OJ2HHY2O.js";
import "./chunk-ZEEU5HOK.js";
import "./chunk-NDQ5FHGV.js";
import {
  a
} from "./chunk-ZPYDYUP5.js";
import "./chunk-RT3T2K4S.js";
import "./chunk-C5H57NTD.js";
import "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import "./chunk-KAN4HXCG.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-MJXQTGI2.js";
import "./chunk-LIZHLHNA.js";
import "./chunk-UA3YPL2R.js";
import "./chunk-HVKDYDPP.js";
import {
  t2 as t
} from "./chunk-6QC7MLLS.js";
import {
  r
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/libs/i3s/enums.js
var n;
var e;
!function(n4) {
  n4[n4.None = 0] = "None", n4[n4.Int16 = 1] = "Int16", n4[n4.Int32 = 2] = "Int32";
}(n || (n = {})), function(n4) {
  n4[n4.Replace = 0] = "Replace", n4[n4.Outside = 1] = "Outside", n4[n4.Inside = 2] = "Inside", n4[n4.Finished = 3] = "Finished";
}(e || (e = {}));

// node_modules/@arcgis/core/libs/i3s/I3SModule.js
function e2() {
  return n2 || (n2 = new Promise((t2) => import("./i3s-RDOQ3DKH.js").then((t3) => t3.i).then(({ default: e3 }) => {
    const n4 = e3({ locateFile: i, onRuntimeInitialized: () => t2(n4) });
    delete n4.then;
  })).catch((t2) => {
    throw t2;
  })), n2;
}
function i(e3) {
  return a(`esri/libs/i3s/${e3}`);
}
var n2;

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SNode.js
var n3;
var o;
var s;
var a2;
var c;
!function(e3) {
  e3[e3.Unmodified = 0] = "Unmodified", e3[e3.Culled = 1] = "Culled", e3[e3.NotChecked = 2] = "NotChecked";
}(n3 || (n3 = {})), function(e3) {
  e3[e3.Unmodified = 0] = "Unmodified", e3[e3.PotentiallyModified = 1] = "PotentiallyModified", e3[e3.Culled = 2] = "Culled", e3[e3.Unknown = 3] = "Unknown", e3[e3.NotChecked = 4] = "NotChecked";
}(o || (o = {}));
!function(e3) {
  e3[e3.Unknown = 0] = "Unknown", e3[e3.Uncached = 1] = "Uncached", e3[e3.Cached = 2] = "Cached";
}(s || (s = {})), function(e3) {
  e3[e3.None = 0] = "None", e3[e3.MaxScreenThreshold = 1] = "MaxScreenThreshold", e3[e3.ScreenSpaceRelative = 2] = "ScreenSpaceRelative", e3[e3.RemovedFeatureDiameter = 3] = "RemovedFeatureDiameter", e3[e3.DistanceRangeFromDefaultCamera = 4] = "DistanceRangeFromDefaultCamera";
}(a2 || (a2 = {})), function(e3) {
  e3[e3.Hole = 0] = "Hole", e3[e3.Leaf = 1] = "Leaf";
}(c || (c = {}));

// node_modules/@arcgis/core/views/3d/layers/SceneLayerWorker.js
async function s2(e3) {
  await g();
  const t2 = [e3.geometryBuffer];
  return { result: m(e3, t2), transferList: t2 };
}
async function f(e3) {
  var _a;
  await g();
  const r2 = [e3.geometryBuffer], { geometryBuffer: n4 } = e3, o2 = n4.byteLength, s3 = y._malloc(o2), f2 = new Uint8Array(y.HEAPU8.buffer, s3, o2);
  f2.set(new Uint8Array(n4));
  const i3 = y.dracoDecompressPointCloudData(s3, f2.byteLength);
  if (y._free(s3), i3.error.length > 0)
    throw `i3s.wasm: ${i3.error}`;
  const a4 = ((_a = i3.featureIds) == null ? void 0 : _a.length) > 0 ? t(i3.featureIds) : null, u2 = t(i3.positions);
  return a4 && r2.push(a4.buffer), r2.push(u2.buffer), { result: { positions: u2, featureIds: a4 }, transferList: r2 };
}
async function i2(e3) {
  await g(), E2(e3);
  const t2 = { buffer: e3.buffer };
  return { result: t2, transferList: [t2.buffer] };
}
async function a3(e3) {
  await g(), b(e3);
}
async function u(e3) {
  await g(), y.setLegacySchema(e3.context, e3.jsonSchema);
}
function l(e3) {
  h(e3);
}
var c2;
var y;
function b(e3) {
  const t2 = e3.modifications, r2 = y._malloc(8 * t2.length), n4 = new Float64Array(y.HEAPU8.buffer, r2, t2.length);
  for (let o2 = 0; o2 < t2.length; ++o2)
    n4[o2] = t2[o2];
  y.setModifications(e3.context, r2, t2.length, e3.isGeodetic), y._free(r2);
}
function m(n4, o2) {
  if (!y)
    return null;
  const { context: s3, localOrigin: f2, globalTrafo: i3, mbs: a4, obb: u2, elevationOffset: l2, geometryBuffer: c3, geometryDescriptor: b2, indexToVertexProjector: m2, vertexToRenderProjector: d2 } = n4, E3 = y._malloc(c3.byteLength), h2 = 33, g2 = y._malloc(h2 * Float64Array.BYTES_PER_ELEMENT), w2 = new Uint8Array(y.HEAPU8.buffer, E3, c3.byteLength);
  w2.set(new Uint8Array(c3));
  const A = new Float64Array(y.HEAPU8.buffer, g2, h2);
  p(A, f2);
  let _ = A.byteOffset + 3 * A.BYTES_PER_ELEMENT, L = new Float64Array(A.buffer, _);
  p(L, i3), _ += 16 * A.BYTES_PER_ELEMENT, L = new Float64Array(A.buffer, _), p(L, a4), _ += 4 * A.BYTES_PER_ELEMENT, r(u2) && (L = new Float64Array(A.buffer, _), p(L, u2.center), _ += 3 * A.BYTES_PER_ELEMENT, L = new Float64Array(A.buffer, _), p(L, u2.halfSize), _ += 3 * A.BYTES_PER_ELEMENT, L = new Float64Array(A.buffer, _), p(L, u2.quaternion));
  const I = b2, T = { isDraco: false, isLegacy: false, color: n4.layouts.some((e3) => e3.some((e4) => "color" === e4.name)), normal: n4.needNormals && n4.layouts.some((e3) => e3.some((e4) => "normalCompressed" === e4.name)), uv0: n4.layouts.some((e3) => e3.some((e4) => "uv0" === e4.name)), uvRegion: n4.layouts.some((e3) => e3.some((e4) => "uvRegion" === e4.name)), featureIndex: I.featureIndex }, P = y.process(s3, !!n4.obb, E3, w2.byteLength, I, T, g2, l2, m2, d2, n4.normalReferenceFrame);
  if (y._free(g2), y._free(E3), P.error.length > 0)
    throw `i3s.wasm: ${P.error}`;
  if (P.discarded)
    return null;
  const U = P.componentOffsets.length > 0 ? t(P.componentOffsets) : null, B = P.featureIds.length > 0 ? t(P.featureIds) : null, F = t(P.interleavedVertedData).buffer, M = P.indicesType === n.Int16 ? t(new Uint16Array(P.indices.buffer, P.indices.byteOffset, P.indices.byteLength / 2)) : t(new Uint32Array(P.indices.buffer, P.indices.byteOffset, P.indices.byteLength / 4)), S = t(P.positions), x = P.positionIndicesType === n.Int16 ? t(new Uint16Array(P.positionIndices.buffer, P.positionIndices.byteOffset, P.positionIndices.byteLength / 2)) : t(new Uint32Array(P.positionIndices.buffer, P.positionIndices.byteOffset, P.positionIndices.byteLength / 4)), O = { layout: n4.layouts[0], interleavedVertexData: F, indices: M, hasColors: P.hasColors, hasModifications: P.hasModifications, positionData: { data: S, indices: x } };
  return B && o2.push(B.buffer), U && o2.push(U.buffer), o2.push(F), o2.push(M.buffer), o2.push(S.buffer), o2.push(x.buffer), { componentOffsets: U, featureIds: B, transformedGeometry: O, obb: P.obb };
}
function d(e3) {
  return 0 === e3 ? o.Unmodified : 1 === e3 ? o.PotentiallyModified : 2 === e3 ? o.Culled : o.Unknown;
}
function E2(e3) {
  const { context: t2, buffer: r2 } = e3, n4 = y._malloc(r2.byteLength), o2 = r2.byteLength / Float64Array.BYTES_PER_ELEMENT, s3 = new Float64Array(y.HEAPU8.buffer, n4, o2), f2 = new Float64Array(r2);
  s3.set(f2), y.filterOBBs(t2, n4, o2), f2.set(s3), y._free(n4);
}
function h(e3) {
  y && y.destroy(e3);
}
function p(e3, t2) {
  for (let r2 = 0; r2 < t2.length; ++r2)
    e3[r2] = t2[r2];
}
function g() {
  return y ? Promise.resolve() : (c2 || (c2 = e2().then((e3) => {
    y = e3, c2 = null;
  })), c2);
}
var w = { transform: m, destroy: h };
export {
  l as destroyContext,
  f as dracoDecompressPointCloudData,
  i2 as filterObbsForModifications,
  E2 as filterObbsForModificationsSync,
  g as initialize,
  d as interpretObbModificationResults,
  s2 as process,
  u as setLegacySchema,
  a3 as setModifications,
  b as setModificationsSync,
  w as test
};
//# sourceMappingURL=SceneLayerWorker-SMLPBGFN.js.map
