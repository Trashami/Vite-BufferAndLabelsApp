import {
  p as p2,
  s
} from "./chunk-6UMNMSQC.js";
import {
  y
} from "./chunk-GLGOVVCK.js";
import {
  h,
  m2 as m,
  u,
  v2 as v
} from "./chunk-3MNMDUQZ.js";
import {
  p,
  w,
  w2
} from "./chunk-UWG37XSU.js";
import {
  l
} from "./chunk-4FEGON7M.js";
import {
  C
} from "./chunk-MJXQTGI2.js";
import {
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/arcade/executionError.js
var e;
!function(e3) {
  e3.AsyncNotEnabled = "AsyncNotEnabled", e3.ModulesNotSupported = "ModulesNotSupported", e3.CircularModules = "CircularModules", e3.NeverReach = "NeverReach", e3.UnsupportedHashType = "UnsupportedHashType", e3.InvalidParameter = "InvalidParameter", e3.UnexpectedToken = "UnexpectedToken", e3.Unrecognised = "Unrecognised", e3.UnrecognisedType = "UnrecognisedType", e3.MaximumCallDepth = "MaximumCallDepth", e3.BooleanConditionRequired = "BooleanConditionRequired", e3.TypeNotAllowedInFeature = "TypeNotAllowedInFeature", e3.KeyMustBeString = "KeyMustBeString", e3.WrongNumberOfParameters = "WrongNumberOfParameters", e3.CallNonFunction = "CallNonFunction", e3.NoFunctionInTemplateLiteral = "NoFunctionInTemplateLiteral", e3.NoFunctionInDictionary = "NoFunctionInDictionary", e3.NoFunctionInArray = "NoFunctionInArray", e3.AssignModuleFunction = "AssignModuleFunction", e3.LogicExpressionOrAnd = "LogicExpressionOrAnd", e3.LogicalExpressionOnlyBoolean = "LogicalExpressionOnlyBoolean", e3.FuncionNotFound = "FunctionNotFound", e3.InvalidMemberAccessKey = "InvalidMemberAccessKey", e3.UnsupportedUnaryOperator = "UnsupportUnaryOperator", e3.InvalidIdentifier = "InvalidIdentifier", e3.MemberOfNull = "MemberOfNull", e3.UnsupportedOperator = "UnsupportedOperator", e3.Cancelled = "Cancelled", e3.ModuleAccessorMustBeString = "ModuleAccessorMustBeString", e3.ModuleExportNotFound = "ModuleExportNotFound", e3.Immutable = "Immutable", e3.OutOfBounds = "OutOfBounds", e3.IllegalResult = "IllegalResult", e3.FieldNotFound = "FieldNotFound", e3.PortalRequired = "PortalRequired", e3.LogicError = "LogicError", e3.ArrayAccessorMustBeNumber = "ArrayAccessMustBeNumber", e3.KeyAccessorMustBeString = "KeyAccessorMustBeString", e3.WrongSpatialReference = "WrongSpatialReference";
}(e || (e = {}));
var r = { [e.TypeNotAllowedInFeature]: "Feature attributes only support dates, numbers, strings, guids.", [e.LogicError]: "Logic error - {reason}", [e.NeverReach]: "Encountered unreachable logic", [e.AsyncNotEnabled]: "Async Arcade must be enabled for this script", [e.ModuleAccessorMustBeString]: "Module accessor must be a string", [e.ModuleExportNotFound]: "Module has no export with provided identifier", [e.ModulesNotSupported]: "Current profile does not support modules", [e.ArrayAccessorMustBeNumber]: "Array accessor must be a number", [e.FuncionNotFound]: "Function not found", [e.FieldNotFound]: "Key not found - {key}", [e.CircularModules]: "Circular module dependencies are not allowed", [e.Cancelled]: "Execution cancelled", [e.UnsupportedHashType]: "Type not supported in hash function", [e.IllegalResult]: "Value is not a supported return type", [e.PortalRequired]: "Portal is required", [e.InvalidParameter]: "Invalid parameter", [e.WrongNumberOfParameters]: "Call with wrong number of parameters", [e.Unrecognised]: "Unrecognised code structure", [e.UnrecognisedType]: "Unrecognised type", [e.WrongSpatialReference]: "Cannot work with geometry in this spatial reference. It is different to the execution spatial reference", [e.BooleanConditionRequired]: "Conditions must use booleans", [e.NoFunctionInDictionary]: "Dictionaries cannot contain functions.", [e.NoFunctionInArray]: "Arrays cannot contain functions.", [e.NoFunctionInTemplateLiteral]: "Template Literals do not expect functions by value.", [e.KeyAccessorMustBeString]: "Accessor must be a string", [e.KeyMustBeString]: "Object keys must be a string", [e.Immutable]: "Object is immutable", [e.InvalidParameter]: "Invalid parameter", [e.UnexpectedToken]: "Unexpected token", [e.MemberOfNull]: "Cannot access property of null object", [e.MaximumCallDepth]: "Exceeded maximum function depth", [e.OutOfBounds]: "Out of bounds", [e.InvalidIdentifier]: "Identifier not recognised", [e.FuncionNotFound]: "Function not found", [e.CallNonFunction]: "Expression is not a function", [e.InvalidMemberAccessKey]: "Cannot access value using a key of this type", [e.AssignModuleFunction]: "Cannot assign function to module variable", [e.UnsupportedUnaryOperator]: "Unsupported unary operator", [e.UnsupportedOperator]: "Unsupported operator", [e.LogicalExpressionOnlyBoolean]: "Logical expressions must be boolean", [e.LogicExpressionOrAnd]: "Logical expression can only be combined with || or &&" };
var o = class extends Error {
  constructor(...e3) {
    super(...e3);
  }
};
var n = class extends o {
  constructor(e3, r3) {
    super(a(r3) + e3.message, { cause: e3 }), this.loc = null, Error.captureStackTrace && Error.captureStackTrace(this, n), r3 && r3.loc && (this.loc = r3.loc);
  }
};
var t2 = class extends Error {
  constructor(e3, o3, n5, s6) {
    super("Execution error - " + a(n5) + i(r[o3], s6)), this.loc = null, this.declaredRootClass = "esri.arcade.arcadeexecutionerror", Error.captureStackTrace && Error.captureStackTrace(this, t2), n5 && n5.loc && (this.loc = n5.loc);
  }
};
function a(e3) {
  var _a, _b;
  return e3 && e3.loc ? `Line : ${(_a = e3.loc.start) == null ? void 0 : _a.line}, ${(_b = e3.loc.start) == null ? void 0 : _b.column}: ` : "";
}
var s2 = class extends Error {
  constructor(e3, o3, n5, t5) {
    super("Compilation error - " + a(n5) + i(r[o3], t5)), this.loc = null, this.declaredRootClass = "esri.arcade.arcadecompilationerror", Error.captureStackTrace && Error.captureStackTrace(this, s2), n5 && n5.loc && (this.loc = n5.loc);
  }
};
var c = class extends Error {
  constructor() {
    super("Uncompilable code structures"), this.declaredRootClass = "esri.arcade.arcadeuncompilableerror", Error.captureStackTrace && Error.captureStackTrace(this, c);
  }
};
function i(e3, r3) {
  try {
    if (!r3)
      return e3;
    for (const o3 in r3) {
      let n5 = r3[o3];
      n5 || (n5 = ""), e3 = e3.replace("{" + o3 + "}", r3[o3]);
    }
  } catch (o3) {
  }
  return e3;
}
function u2(e3, r3, o3) {
  return "esri.arcade.arcadeexecutionerror" === o3.declaredRootClass || "esri.arcade.arcadecompilationerror" === o3.declaredRootClass ? null === o3.loc && r3 && r3.loc ? new n(o3, { cause: o3 }) : o3 : ("esri.arcade.featureset.support.featureseterror" === o3.declaredRootClass || o3.declaredRootClass, r3 && r3.loc ? new n(o3, { cause: o3 }) : o3);
}
var l2;
!function(e3) {
  e3.UnrecognisedUri = "UnrecognisedUri", e3.UnsupportedUriProtocol = "UnsupportedUriProtocol";
}(l2 || (l2 = {}));
var d = { [l2.UnrecognisedUri]: "Unrecognised uri - {uri}", [l2.UnsupportedUriProtocol]: "Unrecognised uri protocol" };
var p3 = class extends Error {
  constructor(e3, r3) {
    super(i(d[e3], r3)), this.declaredRootClass = "esri.arcade.arcademoduleerror", Error.captureStackTrace && Error.captureStackTrace(this, p3);
  }
};

// node_modules/@arcgis/core/arcade/ImmutableArray.js
var t3 = class {
  constructor(t5 = []) {
    this._elements = t5;
  }
  length() {
    return this._elements.length;
  }
  get(t5) {
    return this._elements[t5];
  }
  toArray() {
    const t5 = [];
    for (let e3 = 0; e3 < this.length(); e3++)
      t5.push(this.get(e3));
    return t5;
  }
};

// node_modules/@arcgis/core/arcade/FunctionWrapper.js
var r2 = class {
  constructor() {
  }
};
function n2(t5, n5, e3) {
  if (t5 instanceof r2 && !(t5 instanceof s3)) {
    const r3 = new s3();
    return r3.fn = t5, r3.parameterEvaluator = e3, r3.context = n5, r3;
  }
  return t5;
}
var e2 = class extends r2 {
  constructor(t5) {
    super(), this.fn = t5;
  }
  createFunction(t5) {
    return (...r3) => this.fn(t5, { preparsed: true, arguments: r3 });
  }
  call(t5, r3) {
    return this.fn(t5, r3);
  }
  marshalledCall(e3, a2, l5, c3) {
    return c3(e3, a2, (a3, o3, i4) => {
      i4 = i4.map((t5) => t5 instanceof r2 && !(t5 instanceof s3) ? n2(t5, e3, c3) : t5);
      const u3 = this.call(l5, { args: i4 });
      return C(u3) ? u3.then((t5) => n2(t5, l5, c3)) : u3;
    });
  }
};
var s3 = class extends r2 {
  constructor() {
    super(...arguments), this.fn = null, this.context = null;
  }
  createFunction(t5) {
    return this.fn.createFunction(this.context);
  }
  call(t5, r3) {
    return this.fn.marshalledCall(t5, r3, this.context, this.parameterEvaluator);
  }
  marshalledCall(t5, r3, n5) {
    return this.fn.marshalledCall(t5, r3, this.context, this.parameterEvaluator);
  }
};

// node_modules/@arcgis/core/arcade/featureset/support/shared.js
var t4;
var i2;
function n3(e3) {
  return y.fromJSON(e3.toJSON());
}
function o2(e3) {
  return e3.toJSON ? e3.toJSON() : e3;
}
function l3(e3) {
  return "string" == typeof e3 || e3 instanceof String;
}
function y2(e3) {
  return "number" == typeof e3;
}
function p4(e3) {
  return e3 instanceof Date;
}
function c2(e3, r3) {
  return e3 === r3 || !(!p4(e3) || !p4(r3)) && e3.getTime() === r3.getTime();
}
function m2(e3) {
  if (null == e3)
    return null;
  if ("number" == typeof e3)
    return e3;
  switch (e3.toLowerCase()) {
    case "meters":
    case "meter":
      return 109404;
    case "miles":
    case "mile":
      return 109439;
    case "kilometers":
    case "kilometer":
    case "km":
      return 109414;
  }
  return null;
}
function f(r3) {
  if (null == r3)
    return null;
  switch (r3.type) {
    case "polygon":
    case "multipoint":
    case "polyline":
      return r3.extent;
    case "point":
      return new w2({ xmin: r3.x, ymin: r3.y, xmax: r3.x, ymax: r3.y, spatialReference: r3.spatialReference });
    case "extent":
      return r3;
  }
  return null;
}
function d2(e3) {
  if (null == e3)
    return null;
  if ("number" == typeof e3)
    return e3;
  if ("number" == typeof e3)
    return e3;
  switch (e3.toLowerCase()) {
    case "meters":
    case "meter":
      return 9001;
    case "miles":
    case "mile":
      return 9093;
    case "kilometers":
    case "kilometer":
    case "km":
      return 9036;
  }
  return null;
}
!function(e3) {
  e3[e3.Standardised = 0] = "Standardised", e3[e3.StandardisedNoInterval = 1] = "StandardisedNoInterval", e3[e3.SqlServer = 2] = "SqlServer", e3[e3.Oracle = 3] = "Oracle", e3[e3.Postgres = 4] = "Postgres", e3[e3.PGDB = 5] = "PGDB", e3[e3.FILEGDB = 6] = "FILEGDB", e3[e3.NotEvaluated = 7] = "NotEvaluated";
}(t4 || (t4 = {})), function(e3) {
  e3[e3.InFeatureSet = 0] = "InFeatureSet", e3[e3.NotInFeatureSet = 1] = "NotInFeatureSet", e3[e3.Unknown = 2] = "Unknown";
}(i2 || (i2 = {}));
var F = 1e3;
var S = { point: "point", polygon: "polygon", polyline: "polyline", multipoint: "multipoint", extent: "extent", esriGeometryPoint: "point", esriGeometryPolygon: "polygon", esriGeometryPolyline: "polyline", esriGeometryMultipoint: "multipoint", esriGeometryEnvelope: "extent", envelope: "extent" };
var v2 = { point: "esriGeometryPoint", polygon: "esriGeometryPolygon", polyline: "esriGeometryPolyline", multipoint: "esriGeometryMultipoint", extent: "esriGeometryEnvelope", esriGeometryPoint: "esriGeometryPoint", esriGeometryPolygon: "esriGeometryPolygon", esriGeometryPolyline: "esriGeometryPolyline", esriGeometryMultipoint: "esriGeometryMultipoint", esriGeometryEnvelope: "esriGeometryEnvelope", envelope: "esriGeometryEnvelope" };
var P = { "small-integer": "esriFieldTypeSmallInteger", integer: "esriFieldTypeInteger", long: "esriFieldTypeLong", single: "esriFieldTypeSingle", double: "esriFieldTypeDouble", string: "esriFieldTypeString", date: "esriFieldTypeDate", oid: "esriFieldTypeOID", geometry: "esriFieldTypeGeometry", blob: "esriFieldTypeBlob", raster: "esriFieldTypeRaster", guid: "esriFieldTypeGUID", "global-id": "esriFieldTypeGlobalID", xml: "eesriFieldTypeXML", esriFieldTypeSmallInteger: "esriFieldTypeSmallInteger", esriFieldTypeInteger: "esriFieldTypeInteger", esriFieldTypeLong: "esriFieldTypeLong", esriFieldTypeSingle: "esriFieldTypeSingle", esriFieldTypeDouble: "esriFieldTypeDouble", esriFieldTypeString: "esriFieldTypeString", esriFieldTypeDate: "esriFieldTypeDate", esriFieldTypeOID: "esriFieldTypeOID", esriFieldTypeGeometry: "esriFieldTypeGeometry", esriFieldTypeBlob: "esriFieldTypeBlob", esriFieldTypeRaster: "esriFieldTypeRaster", esriFieldTypeGUID: "esriFieldTypeGUID", esriFieldTypeGlobalID: "esriFieldTypeGlobalID", esriFieldTypeXML: "eesriFieldTypeXML" };
function b(e3) {
  return void 0 === e3 ? "" : e3 = (e3 = (e3 = e3.replace(/\/featureserver\/[0-9]*/i, "/FeatureServer")).replace(/\/mapserver\/[0-9]*/i, "/MapServer")).split("?")[0];
}
function D(e3, r3) {
  r3 || (r3 = {}), "function" == typeof r3 && (r3 = { cmp: r3 });
  const t5 = "boolean" == typeof r3.cycles && r3.cycles, i4 = r3.cmp && (n5 = r3.cmp, function(e4) {
    return function(r4, t6) {
      const i5 = { key: r4, value: e4[r4] }, o4 = { key: t6, value: e4[t6] };
      return n5(i5, o4);
    };
  });
  var n5;
  const o3 = [];
  return function e4(r4) {
    if (r4 && r4.toJSON && "function" == typeof r4.toJSON && (r4 = r4.toJSON()), void 0 === r4)
      return;
    if ("number" == typeof r4)
      return isFinite(r4) ? "" + r4 : "null";
    if ("object" != typeof r4)
      return JSON.stringify(r4);
    let n6, l5;
    if (Array.isArray(r4)) {
      for (l5 = "[", n6 = 0; n6 < r4.length; n6++)
        n6 && (l5 += ","), l5 += e4(r4[n6]) || "null";
      return l5 + "]";
    }
    if (null === r4)
      return "null";
    if (o3.includes(r4)) {
      if (t5)
        return JSON.stringify("__cycle__");
      throw new TypeError("Converting circular structure to JSON");
    }
    const s6 = o3.push(r4) - 1, y3 = Object.keys(r4).sort(i4 && i4(r4));
    for (l5 = "", n6 = 0; n6 < y3.length; n6++) {
      const t6 = y3[n6], i5 = e4(r4[t6]);
      i5 && (l5 && (l5 += ","), l5 += JSON.stringify(t6) + ":" + i5);
    }
    return o3.splice(s6, 1), "{" + l5 + "}";
  }(e3);
}

// node_modules/@arcgis/core/arcade/ArcadeModule.js
var s4 = class {
  constructor(s6) {
    this.source = s6;
  }
};

// node_modules/@arcgis/core/arcade/ImmutablePointArray.js
var i3 = class extends t3 {
  constructor(t5, s6, i4, e3, h3, a2) {
    super(t5), this._lazyPt = [], this._hasZ = false, this._hasM = false, this._spRef = s6, this._hasZ = i4, this._hasM = e3, this._cacheId = h3, this._partId = a2;
  }
  get(t5) {
    if (void 0 === this._lazyPt[t5]) {
      const i4 = this._elements[t5];
      if (void 0 === i4)
        return;
      const e3 = this._hasZ, h3 = this._hasM;
      let a2 = null;
      a2 = e3 && !h3 ? new w(i4[0], i4[1], i4[2], void 0, this._spRef) : h3 && !e3 ? new w(i4[0], i4[1], void 0, i4[2], this._spRef) : e3 && h3 ? new w(i4[0], i4[1], i4[2], i4[3], this._spRef) : new w(i4[0], i4[1], this._spRef), a2.cache._arcadeCacheId = this._cacheId.toString() + "-" + this._partId.toString() + "-" + t5.toString(), this._lazyPt[t5] = a2;
    }
    return this._lazyPt[t5];
  }
  equalityTest(t5) {
    return t5 === this || null !== t5 && (t5 instanceof i3 != false && t5.getUniqueHash() === this.getUniqueHash());
  }
  getUniqueHash() {
    return this._cacheId.toString() + "-" + this._partId.toString();
  }
};

// node_modules/@arcgis/core/arcade/ImmutablePathArray.js
var h2 = class extends t3 {
  constructor(t5, s6, h3, i4, e3) {
    super(t5), this._lazyPath = [], this._hasZ = false, this._hasM = false, this._hasZ = h3, this._hasM = i4, this._spRef = s6, this._cacheId = e3;
  }
  get(t5) {
    if (void 0 === this._lazyPath[t5]) {
      const h3 = this._elements[t5];
      if (void 0 === h3)
        return;
      this._lazyPath[t5] = new i3(h3, this._spRef, this._hasZ, this._hasM, this._cacheId, t5);
    }
    return this._lazyPath[t5];
  }
  equalityTest(t5) {
    return t5 === this || null !== t5 && (t5 instanceof h2 != false && t5.getUniqueHash() === this.getUniqueHash());
  }
  getUniqueHash() {
    return this._cacheId.toString();
  }
};

// node_modules/luxon/src/errors.js
var LuxonError = class extends Error {
};
var InvalidDateTimeError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid DateTime: ${reason.toMessage()}`);
  }
};
var InvalidIntervalError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid Interval: ${reason.toMessage()}`);
  }
};
var InvalidDurationError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid Duration: ${reason.toMessage()}`);
  }
};
var ConflictingSpecificationError = class extends LuxonError {
};
var InvalidUnitError = class extends LuxonError {
  constructor(unit) {
    super(`Invalid unit ${unit}`);
  }
};
var InvalidArgumentError = class extends LuxonError {
};
var ZoneIsAbstractError = class extends LuxonError {
  constructor() {
    super("Zone is an abstract class");
  }
};

// node_modules/luxon/src/impl/formats.js
var n4 = "numeric";
var s5 = "short";
var l4 = "long";
var DATE_SHORT = {
  year: n4,
  month: n4,
  day: n4
};
var DATE_MED = {
  year: n4,
  month: s5,
  day: n4
};
var DATE_MED_WITH_WEEKDAY = {
  year: n4,
  month: s5,
  day: n4,
  weekday: s5
};
var DATE_FULL = {
  year: n4,
  month: l4,
  day: n4
};
var DATE_HUGE = {
  year: n4,
  month: l4,
  day: n4,
  weekday: l4
};
var TIME_SIMPLE = {
  hour: n4,
  minute: n4
};
var TIME_WITH_SECONDS = {
  hour: n4,
  minute: n4,
  second: n4
};
var TIME_WITH_SHORT_OFFSET = {
  hour: n4,
  minute: n4,
  second: n4,
  timeZoneName: s5
};
var TIME_WITH_LONG_OFFSET = {
  hour: n4,
  minute: n4,
  second: n4,
  timeZoneName: l4
};
var TIME_24_SIMPLE = {
  hour: n4,
  minute: n4,
  hourCycle: "h23"
};
var TIME_24_WITH_SECONDS = {
  hour: n4,
  minute: n4,
  second: n4,
  hourCycle: "h23"
};
var TIME_24_WITH_SHORT_OFFSET = {
  hour: n4,
  minute: n4,
  second: n4,
  hourCycle: "h23",
  timeZoneName: s5
};
var TIME_24_WITH_LONG_OFFSET = {
  hour: n4,
  minute: n4,
  second: n4,
  hourCycle: "h23",
  timeZoneName: l4
};
var DATETIME_SHORT = {
  year: n4,
  month: n4,
  day: n4,
  hour: n4,
  minute: n4
};
var DATETIME_SHORT_WITH_SECONDS = {
  year: n4,
  month: n4,
  day: n4,
  hour: n4,
  minute: n4,
  second: n4
};
var DATETIME_MED = {
  year: n4,
  month: s5,
  day: n4,
  hour: n4,
  minute: n4
};
var DATETIME_MED_WITH_SECONDS = {
  year: n4,
  month: s5,
  day: n4,
  hour: n4,
  minute: n4,
  second: n4
};
var DATETIME_MED_WITH_WEEKDAY = {
  year: n4,
  month: s5,
  day: n4,
  weekday: s5,
  hour: n4,
  minute: n4
};
var DATETIME_FULL = {
  year: n4,
  month: l4,
  day: n4,
  hour: n4,
  minute: n4,
  timeZoneName: s5
};
var DATETIME_FULL_WITH_SECONDS = {
  year: n4,
  month: l4,
  day: n4,
  hour: n4,
  minute: n4,
  second: n4,
  timeZoneName: s5
};
var DATETIME_HUGE = {
  year: n4,
  month: l4,
  day: n4,
  weekday: l4,
  hour: n4,
  minute: n4,
  timeZoneName: l4
};
var DATETIME_HUGE_WITH_SECONDS = {
  year: n4,
  month: l4,
  day: n4,
  weekday: l4,
  hour: n4,
  minute: n4,
  second: n4,
  timeZoneName: l4
};

// node_modules/luxon/src/impl/util.js
function isUndefined(o3) {
  return typeof o3 === "undefined";
}
function isNumber(o3) {
  return typeof o3 === "number";
}
function isInteger(o3) {
  return typeof o3 === "number" && o3 % 1 === 0;
}
function isString(o3) {
  return typeof o3 === "string";
}
function isDate(o3) {
  return Object.prototype.toString.call(o3) === "[object Date]";
}
function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e3) {
    return false;
  }
}
function maybeArray(thing) {
  return Array.isArray(thing) ? thing : [thing];
}
function bestBy(arr, by, compare) {
  if (arr.length === 0) {
    return void 0;
  }
  return arr.reduce((best, next) => {
    const pair = [by(next), next];
    if (!best) {
      return pair;
    } else if (compare(best[0], pair[0]) === best[0]) {
      return best;
    } else {
      return pair;
    }
  }, null)[1];
}
function pick(obj, keys) {
  return keys.reduce((a2, k2) => {
    a2[k2] = obj[k2];
    return a2;
  }, {});
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function integerBetween(thing, bottom, top) {
  return isInteger(thing) && thing >= bottom && thing <= top;
}
function floorMod(x, n5) {
  return x - n5 * Math.floor(x / n5);
}
function padStart(input, n5 = 2) {
  const isNeg = input < 0;
  let padded;
  if (isNeg) {
    padded = "-" + ("" + -input).padStart(n5, "0");
  } else {
    padded = ("" + input).padStart(n5, "0");
  }
  return padded;
}
function parseInteger(string) {
  if (isUndefined(string) || string === null || string === "") {
    return void 0;
  } else {
    return parseInt(string, 10);
  }
}
function parseFloating(string) {
  if (isUndefined(string) || string === null || string === "") {
    return void 0;
  } else {
    return parseFloat(string);
  }
}
function parseMillis(fraction) {
  if (isUndefined(fraction) || fraction === null || fraction === "") {
    return void 0;
  } else {
    const f2 = parseFloat("0." + fraction) * 1e3;
    return Math.floor(f2);
  }
}
function roundTo(number, digits, towardZero = false) {
  const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
  return rounder(number * factor) / factor;
}
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
function daysInMonth(year, month) {
  const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
  if (modMonth === 2) {
    return isLeapYear(modYear) ? 29 : 28;
  } else {
    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
  }
}
function objToLocalTS(obj) {
  let d3 = Date.UTC(
    obj.year,
    obj.month - 1,
    obj.day,
    obj.hour,
    obj.minute,
    obj.second,
    obj.millisecond
  );
  if (obj.year < 100 && obj.year >= 0) {
    d3 = new Date(d3);
    d3.setUTCFullYear(d3.getUTCFullYear() - 1900);
  }
  return +d3;
}
function weeksInWeekYear(weekYear) {
  const p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7, last = weekYear - 1, p22 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
  return p1 === 4 || p22 === 3 ? 53 : 52;
}
function untruncateYear(year) {
  if (year > 99) {
    return year;
  } else
    return year > 60 ? 1900 + year : 2e3 + year;
}
function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
  const date = new Date(ts), intlOpts = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  if (timeZone) {
    intlOpts.timeZone = timeZone;
  }
  const modified = { timeZoneName: offsetFormat, ...intlOpts };
  const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find((m3) => m3.type.toLowerCase() === "timezonename");
  return parsed ? parsed.value : null;
}
function signedOffset(offHourStr, offMinuteStr) {
  let offHour = parseInt(offHourStr, 10);
  if (Number.isNaN(offHour)) {
    offHour = 0;
  }
  const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
  return offHour * 60 + offMinSigned;
}
function asNumber(value) {
  const numericValue = Number(value);
  if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
    throw new InvalidArgumentError(`Invalid unit value ${value}`);
  return numericValue;
}
function normalizeObject(obj, normalizer) {
  const normalized = {};
  for (const u3 in obj) {
    if (hasOwnProperty(obj, u3)) {
      const v4 = obj[u3];
      if (v4 === void 0 || v4 === null)
        continue;
      normalized[normalizer(u3)] = asNumber(v4);
    }
  }
  return normalized;
}
function formatOffset(offset2, format) {
  const hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign = offset2 >= 0 ? "+" : "-";
  switch (format) {
    case "short":
      return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
    case "narrow":
      return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
    case "techie":
      return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
    default:
      throw new RangeError(`Value format ${format} is out of range for property format`);
  }
}
function timeObject(obj) {
  return pick(obj, ["hour", "minute", "second", "millisecond"]);
}
var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;

// node_modules/luxon/src/impl/english.js
var monthsLong = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
var monthsShort = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function months(length) {
  switch (length) {
    case "narrow":
      return [...monthsNarrow];
    case "short":
      return [...monthsShort];
    case "long":
      return [...monthsLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
var weekdaysLong = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
];
var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
function weekdays(length) {
  switch (length) {
    case "narrow":
      return [...weekdaysNarrow];
    case "short":
      return [...weekdaysShort];
    case "long":
      return [...weekdaysLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
var meridiems = ["AM", "PM"];
var erasLong = ["Before Christ", "Anno Domini"];
var erasShort = ["BC", "AD"];
var erasNarrow = ["B", "A"];
function eras(length) {
  switch (length) {
    case "narrow":
      return [...erasNarrow];
    case "short":
      return [...erasShort];
    case "long":
      return [...erasLong];
    default:
      return null;
  }
}
function meridiemForDateTime(dt) {
  return meridiems[dt.hour < 12 ? 0 : 1];
}
function weekdayForDateTime(dt, length) {
  return weekdays(length)[dt.weekday - 1];
}
function monthForDateTime(dt, length) {
  return months(length)[dt.month - 1];
}
function eraForDateTime(dt, length) {
  return eras(length)[dt.year < 0 ? 0 : 1];
}
function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
  const units = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  };
  const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
  if (numeric === "auto" && lastable) {
    const isDay = unit === "days";
    switch (count) {
      case 1:
        return isDay ? "tomorrow" : `next ${units[unit][0]}`;
      case -1:
        return isDay ? "yesterday" : `last ${units[unit][0]}`;
      case 0:
        return isDay ? "today" : `this ${units[unit][0]}`;
      default:
    }
  }
  const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
}

// node_modules/luxon/src/impl/formatter.js
function stringifyTokens(splits, tokenToString) {
  let s6 = "";
  for (const token of splits) {
    if (token.literal) {
      s6 += token.val;
    } else {
      s6 += tokenToString(token.val);
    }
  }
  return s6;
}
var macroTokenToFormatOpts = {
  D: DATE_SHORT,
  DD: DATE_MED,
  DDD: DATE_FULL,
  DDDD: DATE_HUGE,
  t: TIME_SIMPLE,
  tt: TIME_WITH_SECONDS,
  ttt: TIME_WITH_SHORT_OFFSET,
  tttt: TIME_WITH_LONG_OFFSET,
  T: TIME_24_SIMPLE,
  TT: TIME_24_WITH_SECONDS,
  TTT: TIME_24_WITH_SHORT_OFFSET,
  TTTT: TIME_24_WITH_LONG_OFFSET,
  f: DATETIME_SHORT,
  ff: DATETIME_MED,
  fff: DATETIME_FULL,
  ffff: DATETIME_HUGE,
  F: DATETIME_SHORT_WITH_SECONDS,
  FF: DATETIME_MED_WITH_SECONDS,
  FFF: DATETIME_FULL_WITH_SECONDS,
  FFFF: DATETIME_HUGE_WITH_SECONDS
};
var Formatter = class {
  static create(locale, opts = {}) {
    return new Formatter(locale, opts);
  }
  static parseFormat(fmt) {
    let current = null, currentFull = "", bracketed = false;
    const splits = [];
    for (let i4 = 0; i4 < fmt.length; i4++) {
      const c3 = fmt.charAt(i4);
      if (c3 === "'") {
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed, val: currentFull });
        }
        current = null;
        currentFull = "";
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c3;
      } else if (c3 === current) {
        currentFull += c3;
      } else {
        if (currentFull.length > 0) {
          splits.push({ literal: false, val: currentFull });
        }
        currentFull = c3;
        current = c3;
      }
    }
    if (currentFull.length > 0) {
      splits.push({ literal: bracketed, val: currentFull });
    }
    return splits;
  }
  static macroTokenToFormatOpts(token) {
    return macroTokenToFormatOpts[token];
  }
  constructor(locale, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale;
    this.systemLoc = null;
  }
  formatWithSystemDefault(dt, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }
    const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.format();
  }
  formatDateTime(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.format();
  }
  formatDateTimeParts(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.formatToParts();
  }
  resolvedOptions(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.resolvedOptions();
  }
  num(n5, p5 = 0) {
    if (this.opts.forceSimple) {
      return padStart(n5, p5);
    }
    const opts = { ...this.opts };
    if (p5 > 0) {
      opts.padTo = p5;
    }
    return this.loc.numberFormatter(opts).format(n5);
  }
  formatDateTimeFromString(dt, fmt) {
    const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset2 = (opts) => {
      if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
        return "Z";
      }
      return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
    }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string(standalone ? { month: length } : { month: length, day: "numeric" }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string(
      standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" },
      "weekday"
    ), maybeMacro = (token) => {
      const formatOpts = Formatter.macroTokenToFormatOpts(token);
      if (formatOpts) {
        return this.formatWithSystemDefault(dt, formatOpts);
      } else {
        return token;
      }
    }, era = (length) => knownEnglish ? eraForDateTime(dt, length) : string({ era: length }, "era"), tokenToString = (token) => {
      switch (token) {
        case "S":
          return this.num(dt.millisecond);
        case "u":
        case "SSS":
          return this.num(dt.millisecond, 3);
        case "s":
          return this.num(dt.second);
        case "ss":
          return this.num(dt.second, 2);
        case "uu":
          return this.num(Math.floor(dt.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(dt.millisecond / 100));
        case "m":
          return this.num(dt.minute);
        case "mm":
          return this.num(dt.minute, 2);
        case "h":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
        case "hh":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
        case "H":
          return this.num(dt.hour);
        case "HH":
          return this.num(dt.hour, 2);
        case "Z":
          return formatOffset2({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return formatOffset2({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
        case "z":
          return dt.zoneName;
        case "a":
          return meridiem();
        case "d":
          return useDateTimeFormatter ? string({ day: "numeric" }, "day") : this.num(dt.day);
        case "dd":
          return useDateTimeFormatter ? string({ day: "2-digit" }, "day") : this.num(dt.day, 2);
        case "c":
          return this.num(dt.weekday);
        case "ccc":
          return weekday("short", true);
        case "cccc":
          return weekday("long", true);
        case "ccccc":
          return weekday("narrow", true);
        case "E":
          return this.num(dt.weekday);
        case "EEE":
          return weekday("short", false);
        case "EEEE":
          return weekday("long", false);
        case "EEEEE":
          return weekday("narrow", false);
        case "L":
          return useDateTimeFormatter ? string({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
        case "LL":
          return useDateTimeFormatter ? string({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
        case "LLL":
          return month("short", true);
        case "LLLL":
          return month("long", true);
        case "LLLLL":
          return month("narrow", true);
        case "M":
          return useDateTimeFormatter ? string({ month: "numeric" }, "month") : this.num(dt.month);
        case "MM":
          return useDateTimeFormatter ? string({ month: "2-digit" }, "month") : this.num(dt.month, 2);
        case "MMM":
          return month("short", false);
        case "MMMM":
          return month("long", false);
        case "MMMMM":
          return month("narrow", false);
        case "y":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year);
        case "yy":
          return useDateTimeFormatter ? string({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
        case "yyyy":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 4);
        case "yyyyyy":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 6);
        case "G":
          return era("short");
        case "GG":
          return era("long");
        case "GGGGG":
          return era("narrow");
        case "kk":
          return this.num(dt.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(dt.weekYear, 4);
        case "W":
          return this.num(dt.weekNumber);
        case "WW":
          return this.num(dt.weekNumber, 2);
        case "o":
          return this.num(dt.ordinal);
        case "ooo":
          return this.num(dt.ordinal, 3);
        case "q":
          return this.num(dt.quarter);
        case "qq":
          return this.num(dt.quarter, 2);
        case "X":
          return this.num(Math.floor(dt.ts / 1e3));
        case "x":
          return this.num(dt.ts);
        default:
          return maybeMacro(token);
      }
    };
    return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
  }
  formatDurationFromString(dur, fmt) {
    const tokenToField = (token) => {
      switch (token[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, tokenToString = (lildur) => (token) => {
      const mapped = tokenToField(token);
      if (mapped) {
        return this.num(lildur.get(mapped), token.length);
      } else {
        return token;
      }
    }, tokens = Formatter.parseFormat(fmt), realTokens = tokens.reduce(
      (found, { literal, val }) => literal ? found : found.concat(val),
      []
    ), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t5) => t5));
    return stringifyTokens(tokens, tokenToString(collapsed));
  }
};

// node_modules/luxon/src/impl/invalid.js
var Invalid = class {
  constructor(reason, explanation) {
    this.reason = reason;
    this.explanation = explanation;
  }
  toMessage() {
    if (this.explanation) {
      return `${this.reason}: ${this.explanation}`;
    } else {
      return this.reason;
    }
  }
};

// node_modules/luxon/src/zone.js
var Zone = class {
  get type() {
    throw new ZoneIsAbstractError();
  }
  get name() {
    throw new ZoneIsAbstractError();
  }
  get ianaName() {
    return this.name;
  }
  get isUniversal() {
    throw new ZoneIsAbstractError();
  }
  offsetName(ts, opts) {
    throw new ZoneIsAbstractError();
  }
  formatOffset(ts, format) {
    throw new ZoneIsAbstractError();
  }
  offset(ts) {
    throw new ZoneIsAbstractError();
  }
  equals(otherZone) {
    throw new ZoneIsAbstractError();
  }
  get isValid() {
    throw new ZoneIsAbstractError();
  }
};

// node_modules/luxon/src/zones/systemZone.js
var singleton = null;
var SystemZone = class extends Zone {
  static get instance() {
    if (singleton === null) {
      singleton = new SystemZone();
    }
    return singleton;
  }
  get type() {
    return "system";
  }
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  get isUniversal() {
    return false;
  }
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale);
  }
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  offset(ts) {
    return -new Date(ts).getTimezoneOffset();
  }
  equals(otherZone) {
    return otherZone.type === "system";
  }
  get isValid() {
    return true;
  }
};

// node_modules/luxon/src/zones/IANAZone.js
var dtfCache = {};
function makeDTF(zone) {
  if (!dtfCache[zone]) {
    dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: zone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      era: "short"
    });
  }
  return dtfCache[zone];
}
var typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function hackyOffset(dtf, date) {
  const formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
}
function partsOffset(dtf, date) {
  const formatted = dtf.formatToParts(date);
  const filled = [];
  for (let i4 = 0; i4 < formatted.length; i4++) {
    const { type, value } = formatted[i4];
    const pos = typeToPos[type];
    if (type === "era") {
      filled[pos] = value;
    } else if (!isUndefined(pos)) {
      filled[pos] = parseInt(value, 10);
    }
  }
  return filled;
}
var ianaZoneCache = {};
var IANAZone = class extends Zone {
  static create(name) {
    if (!ianaZoneCache[name]) {
      ianaZoneCache[name] = new IANAZone(name);
    }
    return ianaZoneCache[name];
  }
  static resetCache() {
    ianaZoneCache = {};
    dtfCache = {};
  }
  static isValidSpecifier(s6) {
    return this.isValidZone(s6);
  }
  static isValidZone(zone) {
    if (!zone) {
      return false;
    }
    try {
      new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
      return true;
    } catch (e3) {
      return false;
    }
  }
  constructor(name) {
    super();
    this.zoneName = name;
    this.valid = IANAZone.isValidZone(name);
  }
  get type() {
    return "iana";
  }
  get name() {
    return this.zoneName;
  }
  get isUniversal() {
    return false;
  }
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale, this.name);
  }
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  offset(ts) {
    const date = new Date(ts);
    if (isNaN(date))
      return NaN;
    const dtf = makeDTF(this.name);
    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
    if (adOrBc === "BC") {
      year = -Math.abs(year) + 1;
    }
    const adjustedHour = hour === 24 ? 0 : hour;
    const asUTC = objToLocalTS({
      year,
      month,
      day,
      hour: adjustedHour,
      minute,
      second,
      millisecond: 0
    });
    let asTS = +date;
    const over = asTS % 1e3;
    asTS -= over >= 0 ? over : 1e3 + over;
    return (asUTC - asTS) / (60 * 1e3);
  }
  equals(otherZone) {
    return otherZone.type === "iana" && otherZone.name === this.name;
  }
  get isValid() {
    return this.valid;
  }
};

// node_modules/luxon/src/zones/fixedOffsetZone.js
var singleton2 = null;
var FixedOffsetZone = class extends Zone {
  static get utcInstance() {
    if (singleton2 === null) {
      singleton2 = new FixedOffsetZone(0);
    }
    return singleton2;
  }
  static instance(offset2) {
    return offset2 === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset2);
  }
  static parseSpecifier(s6) {
    if (s6) {
      const r3 = s6.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (r3) {
        return new FixedOffsetZone(signedOffset(r3[1], r3[2]));
      }
    }
    return null;
  }
  constructor(offset2) {
    super();
    this.fixed = offset2;
  }
  get type() {
    return "fixed";
  }
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
  }
  get ianaName() {
    if (this.fixed === 0) {
      return "Etc/UTC";
    } else {
      return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
    }
  }
  offsetName() {
    return this.name;
  }
  formatOffset(ts, format) {
    return formatOffset(this.fixed, format);
  }
  get isUniversal() {
    return true;
  }
  offset() {
    return this.fixed;
  }
  equals(otherZone) {
    return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
  }
  get isValid() {
    return true;
  }
};

// node_modules/luxon/src/zones/invalidZone.js
var InvalidZone = class extends Zone {
  constructor(zoneName) {
    super();
    this.zoneName = zoneName;
  }
  get type() {
    return "invalid";
  }
  get name() {
    return this.zoneName;
  }
  get isUniversal() {
    return false;
  }
  offsetName() {
    return null;
  }
  formatOffset() {
    return "";
  }
  offset() {
    return NaN;
  }
  equals() {
    return false;
  }
  get isValid() {
    return false;
  }
};

// node_modules/luxon/src/impl/zoneUtil.js
function normalizeZone(input, defaultZone2) {
  let offset2;
  if (isUndefined(input) || input === null) {
    return defaultZone2;
  } else if (input instanceof Zone) {
    return input;
  } else if (isString(input)) {
    const lowered = input.toLowerCase();
    if (lowered === "default")
      return defaultZone2;
    else if (lowered === "local" || lowered === "system")
      return SystemZone.instance;
    else if (lowered === "utc" || lowered === "gmt")
      return FixedOffsetZone.utcInstance;
    else
      return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
  } else if (isNumber(input)) {
    return FixedOffsetZone.instance(input);
  } else if (typeof input === "object" && input.offset && typeof input.offset === "number") {
    return input;
  } else {
    return new InvalidZone(input);
  }
}

// node_modules/luxon/src/settings.js
var now = () => Date.now();
var defaultZone = "system";
var defaultLocale = null;
var defaultNumberingSystem = null;
var defaultOutputCalendar = null;
var throwOnInvalid;
var Settings = class {
  static get now() {
    return now;
  }
  static set now(n5) {
    now = n5;
  }
  static set defaultZone(zone) {
    defaultZone = zone;
  }
  static get defaultZone() {
    return normalizeZone(defaultZone, SystemZone.instance);
  }
  static get defaultLocale() {
    return defaultLocale;
  }
  static set defaultLocale(locale) {
    defaultLocale = locale;
  }
  static get defaultNumberingSystem() {
    return defaultNumberingSystem;
  }
  static set defaultNumberingSystem(numberingSystem) {
    defaultNumberingSystem = numberingSystem;
  }
  static get defaultOutputCalendar() {
    return defaultOutputCalendar;
  }
  static set defaultOutputCalendar(outputCalendar) {
    defaultOutputCalendar = outputCalendar;
  }
  static get throwOnInvalid() {
    return throwOnInvalid;
  }
  static set throwOnInvalid(t5) {
    throwOnInvalid = t5;
  }
  static resetCaches() {
    Locale.resetCache();
    IANAZone.resetCache();
  }
};

// node_modules/luxon/src/impl/locale.js
var intlLFCache = {};
function getCachedLF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlLFCache[key];
  if (!dtf) {
    dtf = new Intl.ListFormat(locString, opts);
    intlLFCache[key] = dtf;
  }
  return dtf;
}
var intlDTCache = {};
function getCachedDTF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlDTCache[key];
  if (!dtf) {
    dtf = new Intl.DateTimeFormat(locString, opts);
    intlDTCache[key] = dtf;
  }
  return dtf;
}
var intlNumCache = {};
function getCachedINF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let inf = intlNumCache[key];
  if (!inf) {
    inf = new Intl.NumberFormat(locString, opts);
    intlNumCache[key] = inf;
  }
  return inf;
}
var intlRelCache = {};
function getCachedRTF(locString, opts = {}) {
  const { base, ...cacheKeyOpts } = opts;
  const key = JSON.stringify([locString, cacheKeyOpts]);
  let inf = intlRelCache[key];
  if (!inf) {
    inf = new Intl.RelativeTimeFormat(locString, opts);
    intlRelCache[key] = inf;
  }
  return inf;
}
var sysLocaleCache = null;
function systemLocale() {
  if (sysLocaleCache) {
    return sysLocaleCache;
  } else {
    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
    return sysLocaleCache;
  }
}
function parseLocaleString(localeStr) {
  const uIndex = localeStr.indexOf("-u-");
  if (uIndex === -1) {
    return [localeStr];
  } else {
    let options;
    const smaller = localeStr.substring(0, uIndex);
    try {
      options = getCachedDTF(localeStr).resolvedOptions();
    } catch (e3) {
      options = getCachedDTF(smaller).resolvedOptions();
    }
    const { numberingSystem, calendar } = options;
    return [smaller, numberingSystem, calendar];
  }
}
function intlConfigString(localeStr, numberingSystem, outputCalendar) {
  if (outputCalendar || numberingSystem) {
    localeStr += "-u";
    if (outputCalendar) {
      localeStr += `-ca-${outputCalendar}`;
    }
    if (numberingSystem) {
      localeStr += `-nu-${numberingSystem}`;
    }
    return localeStr;
  } else {
    return localeStr;
  }
}
function mapMonths(f2) {
  const ms = [];
  for (let i4 = 1; i4 <= 12; i4++) {
    const dt = DateTime.utc(2016, i4, 1);
    ms.push(f2(dt));
  }
  return ms;
}
function mapWeekdays(f2) {
  const ms = [];
  for (let i4 = 1; i4 <= 7; i4++) {
    const dt = DateTime.utc(2016, 11, 13 + i4);
    ms.push(f2(dt));
  }
  return ms;
}
function listStuff(loc, length, defaultOK, englishFn, intlFn) {
  const mode = loc.listingMode(defaultOK);
  if (mode === "error") {
    return null;
  } else if (mode === "en") {
    return englishFn(length);
  } else {
    return intlFn(length);
  }
}
function supportsFastNumbers(loc) {
  if (loc.numberingSystem && loc.numberingSystem !== "latn") {
    return false;
  } else {
    return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
  }
}
var PolyNumberFormatter = class {
  constructor(intl, forceSimple, opts) {
    this.padTo = opts.padTo || 0;
    this.floor = opts.floor || false;
    const { padTo, floor, ...otherOpts } = opts;
    if (!forceSimple || Object.keys(otherOpts).length > 0) {
      const intlOpts = { useGrouping: false, ...opts };
      if (opts.padTo > 0)
        intlOpts.minimumIntegerDigits = opts.padTo;
      this.inf = getCachedINF(intl, intlOpts);
    }
  }
  format(i4) {
    if (this.inf) {
      const fixed = this.floor ? Math.floor(i4) : i4;
      return this.inf.format(fixed);
    } else {
      const fixed = this.floor ? Math.floor(i4) : roundTo(i4, 3);
      return padStart(fixed, this.padTo);
    }
  }
};
var PolyDateFormatter = class {
  constructor(dt, intl, opts) {
    this.opts = opts;
    let z2;
    if (dt.zone.isUniversal) {
      const gmtOffset = -1 * (dt.offset / 60);
      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
        z2 = offsetZ;
        this.dt = dt;
      } else {
        z2 = "UTC";
        if (opts.timeZoneName) {
          this.dt = dt;
        } else {
          this.dt = dt.offset === 0 ? dt : DateTime.fromMillis(dt.ts + dt.offset * 60 * 1e3);
        }
      }
    } else if (dt.zone.type === "system") {
      this.dt = dt;
    } else {
      this.dt = dt;
      z2 = dt.zone.name;
    }
    const intlOpts = { ...this.opts };
    if (z2) {
      intlOpts.timeZone = z2;
    }
    this.dtf = getCachedDTF(intl, intlOpts);
  }
  format() {
    return this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    return this.dtf.formatToParts(this.dt.toJSDate());
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
};
var PolyRelFormatter = class {
  constructor(intl, isEnglish, opts) {
    this.opts = { style: "long", ...opts };
    if (!isEnglish && hasRelative()) {
      this.rtf = getCachedRTF(intl, opts);
    }
  }
  format(count, unit) {
    if (this.rtf) {
      return this.rtf.format(count, unit);
    } else {
      return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
    }
  }
  formatToParts(count, unit) {
    if (this.rtf) {
      return this.rtf.formatToParts(count, unit);
    } else {
      return [];
    }
  }
};
var Locale = class {
  static fromOpts(opts) {
    return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
  }
  static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {
    const specifiedLocale = locale || Settings.defaultLocale;
    const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
    return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
  }
  static resetCache() {
    sysLocaleCache = null;
    intlDTCache = {};
    intlNumCache = {};
    intlRelCache = {};
  }
  static fromObject({ locale, numberingSystem, outputCalendar } = {}) {
    return Locale.create(locale, numberingSystem, outputCalendar);
  }
  constructor(locale, numbering, outputCalendar, specifiedLocale) {
    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
    this.locale = parsedLocale;
    this.numberingSystem = numbering || parsedNumberingSystem || null;
    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
    this.weekdaysCache = { format: {}, standalone: {} };
    this.monthsCache = { format: {}, standalone: {} };
    this.meridiemCache = null;
    this.eraCache = {};
    this.specifiedLocale = specifiedLocale;
    this.fastNumbersCached = null;
  }
  get fastNumbers() {
    if (this.fastNumbersCached == null) {
      this.fastNumbersCached = supportsFastNumbers(this);
    }
    return this.fastNumbersCached;
  }
  listingMode() {
    const isActuallyEn = this.isEnglish();
    const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return isActuallyEn && hasNoWeirdness ? "en" : "intl";
  }
  clone(alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return Locale.create(
        alts.locale || this.specifiedLocale,
        alts.numberingSystem || this.numberingSystem,
        alts.outputCalendar || this.outputCalendar,
        alts.defaultToEN || false
      );
    }
  }
  redefaultToEN(alts = {}) {
    return this.clone({ ...alts, defaultToEN: true });
  }
  redefaultToSystem(alts = {}) {
    return this.clone({ ...alts, defaultToEN: false });
  }
  months(length, format = false, defaultOK = true) {
    return listStuff(this, length, defaultOK, months, () => {
      const intl = format ? { month: length, day: "numeric" } : { month: length }, formatStr = format ? "format" : "standalone";
      if (!this.monthsCache[formatStr][length]) {
        this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, "month"));
      }
      return this.monthsCache[formatStr][length];
    });
  }
  weekdays(length, format = false, defaultOK = true) {
    return listStuff(this, length, defaultOK, weekdays, () => {
      const intl = format ? { weekday: length, year: "numeric", month: "long", day: "numeric" } : { weekday: length }, formatStr = format ? "format" : "standalone";
      if (!this.weekdaysCache[formatStr][length]) {
        this.weekdaysCache[formatStr][length] = mapWeekdays(
          (dt) => this.extract(dt, intl, "weekday")
        );
      }
      return this.weekdaysCache[formatStr][length];
    });
  }
  meridiems(defaultOK = true) {
    return listStuff(
      this,
      void 0,
      defaultOK,
      () => meridiems,
      () => {
        if (!this.meridiemCache) {
          const intl = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(
            (dt) => this.extract(dt, intl, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(length, defaultOK = true) {
    return listStuff(this, length, defaultOK, eras, () => {
      const intl = { era: length };
      if (!this.eraCache[length]) {
        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(
          (dt) => this.extract(dt, intl, "era")
        );
      }
      return this.eraCache[length];
    });
  }
  extract(dt, intlOpts, field) {
    const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m3) => m3.type.toLowerCase() === field);
    return matching ? matching.value : null;
  }
  numberFormatter(opts = {}) {
    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
  }
  dtFormatter(dt, intlOpts = {}) {
    return new PolyDateFormatter(dt, this.intl, intlOpts);
  }
  relFormatter(opts = {}) {
    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
  }
  listFormatter(opts = {}) {
    return getCachedLF(this.intl, opts);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  equals(other) {
    return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
  }
};

// node_modules/luxon/src/impl/regexParser.js
function combineRegexes(...regexes) {
  const full = regexes.reduce((f2, r3) => f2 + r3.source, "");
  return RegExp(`^${full}$`);
}
function combineExtractors(...extractors) {
  return (m3) => extractors.reduce(
    ([mergedVals, mergedZone, cursor], ex) => {
      const [val, zone, next] = ex(m3, cursor);
      return [{ ...mergedVals, ...val }, zone || mergedZone, next];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function parse(s6, ...patterns) {
  if (s6 == null) {
    return [null, null];
  }
  for (const [regex, extractor] of patterns) {
    const m3 = regex.exec(s6);
    if (m3) {
      return extractor(m3);
    }
  }
  return [null, null];
}
function simpleParse(...keys) {
  return (match2, cursor) => {
    const ret = {};
    let i4;
    for (i4 = 0; i4 < keys.length; i4++) {
      ret[keys[i4]] = parseInteger(match2[cursor + i4]);
    }
    return [ret, null, cursor + i4];
  };
}
var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
var isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
var extractISOOrdinalData = simpleParse("year", "ordinal");
var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
var sqlTimeRegex = RegExp(
  `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
);
var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
function int(match2, pos, fallback) {
  const m3 = match2[pos];
  return isUndefined(m3) ? fallback : parseInteger(m3);
}
function extractISOYmd(match2, cursor) {
  const item = {
    year: int(match2, cursor),
    month: int(match2, cursor + 1, 1),
    day: int(match2, cursor + 2, 1)
  };
  return [item, null, cursor + 3];
}
function extractISOTime(match2, cursor) {
  const item = {
    hours: int(match2, cursor, 0),
    minutes: int(match2, cursor + 1, 0),
    seconds: int(match2, cursor + 2, 0),
    milliseconds: parseMillis(match2[cursor + 3])
  };
  return [item, null, cursor + 4];
}
function extractISOOffset(match2, cursor) {
  const local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
  return [{}, zone, cursor + 3];
}
function extractIANAZone(match2, cursor) {
  const zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
  return [{}, zone, cursor + 1];
}
var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function extractISODuration(match2) {
  const [s6, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match2;
  const hasNegativePrefix = s6[0] === "-";
  const negativeSeconds = secondStr && secondStr[0] === "-";
  const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
  return [
    {
      years: maybeNegate(parseFloating(yearStr)),
      months: maybeNegate(parseFloating(monthStr)),
      weeks: maybeNegate(parseFloating(weekStr)),
      days: maybeNegate(parseFloating(dayStr)),
      hours: maybeNegate(parseFloating(hourStr)),
      minutes: maybeNegate(parseFloating(minuteStr)),
      seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
      milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
    }
  ];
}
var obsOffsets = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  const result = {
    year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
    month: monthsShort.indexOf(monthStr) + 1,
    day: parseInteger(dayStr),
    hour: parseInteger(hourStr),
    minute: parseInteger(minuteStr)
  };
  if (secondStr)
    result.second = parseInteger(secondStr);
  if (weekdayStr) {
    result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
  }
  return result;
}
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function extractRFC2822(match2) {
  const [
    ,
    weekdayStr,
    dayStr,
    monthStr,
    yearStr,
    hourStr,
    minuteStr,
    secondStr,
    obsOffset,
    milOffset,
    offHourStr,
    offMinuteStr
  ] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  let offset2;
  if (obsOffset) {
    offset2 = obsOffsets[obsOffset];
  } else if (milOffset) {
    offset2 = 0;
  } else {
    offset2 = signedOffset(offHourStr, offMinuteStr);
  }
  return [result, new FixedOffsetZone(offset2)];
}
function preprocessRFC2822(s6) {
  return s6.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function extractRFC1123Or850(match2) {
  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
function extractASCII(match2) {
  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
var extractISOYmdTimeAndOffset = combineExtractors(
  extractISOYmd,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOWeekTimeAndOffset = combineExtractors(
  extractISOWeekData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOOrdinalDateAndTime = combineExtractors(
  extractISOOrdinalData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOTimeAndOffset = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseISODate(s6) {
  return parse(
    s6,
    [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
    [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
    [isoTimeCombinedRegex, extractISOTimeAndOffset]
  );
}
function parseRFC2822Date(s6) {
  return parse(preprocessRFC2822(s6), [rfc2822, extractRFC2822]);
}
function parseHTTPDate(s6) {
  return parse(
    s6,
    [rfc1123, extractRFC1123Or850],
    [rfc850, extractRFC1123Or850],
    [ascii, extractASCII]
  );
}
function parseISODuration(s6) {
  return parse(s6, [isoDuration, extractISODuration]);
}
var extractISOTimeOnly = combineExtractors(extractISOTime);
function parseISOTimeOnly(s6) {
  return parse(s6, [isoTimeOnly, extractISOTimeOnly]);
}
var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
var extractISOTimeOffsetAndIANAZone = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseSQL(s6) {
  return parse(
    s6,
    [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
  );
}

// node_modules/luxon/src/duration.js
var INVALID = "Invalid Duration";
var lowOrderMatrix = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
};
var casualMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
};
var daysInYearAccurate = 146097 / 400;
var daysInMonthAccurate = 146097 / 4800;
var accurateMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: daysInYearAccurate / 7,
    days: daysInYearAccurate,
    hours: daysInYearAccurate * 24,
    minutes: daysInYearAccurate * 24 * 60,
    seconds: daysInYearAccurate * 24 * 60 * 60,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: daysInYearAccurate / 28,
    days: daysInYearAccurate / 4,
    hours: daysInYearAccurate * 24 / 4,
    minutes: daysInYearAccurate * 24 * 60 / 4,
    seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: daysInMonthAccurate / 7,
    days: daysInMonthAccurate,
    hours: daysInMonthAccurate * 24,
    minutes: daysInMonthAccurate * 24 * 60,
    seconds: daysInMonthAccurate * 24 * 60 * 60,
    milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
};
var orderedUnits = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
];
var reverseUnits = orderedUnits.slice(0).reverse();
function clone(dur, alts, clear = false) {
  const conf = {
    values: clear ? alts.values : { ...dur.values, ...alts.values || {} },
    loc: dur.loc.clone(alts.loc),
    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
    matrix: alts.matrix || dur.matrix
  };
  return new Duration(conf);
}
function antiTrunc(n5) {
  return n5 < 0 ? Math.floor(n5) : Math.ceil(n5);
}
function convert(matrix, fromMap, fromUnit, toMap, toUnit) {
  const conv = matrix[toUnit][fromUnit], raw = fromMap[fromUnit] / conv, sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]), added = !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1 ? antiTrunc(raw) : Math.trunc(raw);
  toMap[toUnit] += added;
  fromMap[fromUnit] -= added * conv;
}
function normalizeValues(matrix, vals) {
  reverseUnits.reduce((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        convert(matrix, vals, previous, vals, current);
      }
      return current;
    } else {
      return previous;
    }
  }, null);
}
var Duration = class {
  constructor(config) {
    const accurate = config.conversionAccuracy === "longterm" || false;
    let matrix = accurate ? accurateMatrix : casualMatrix;
    if (config.matrix) {
      matrix = config.matrix;
    }
    this.values = config.values;
    this.loc = config.loc || Locale.create();
    this.conversionAccuracy = accurate ? "longterm" : "casual";
    this.invalid = config.invalid || null;
    this.matrix = matrix;
    this.isLuxonDuration = true;
  }
  static fromMillis(count, opts) {
    return Duration.fromObject({ milliseconds: count }, opts);
  }
  static fromObject(obj, opts = {}) {
    if (obj == null || typeof obj !== "object") {
      throw new InvalidArgumentError(
        `Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`
      );
    }
    return new Duration({
      values: normalizeObject(obj, Duration.normalizeUnit),
      loc: Locale.fromObject(opts),
      conversionAccuracy: opts.conversionAccuracy,
      matrix: opts.matrix
    });
  }
  static fromDurationLike(durationLike) {
    if (isNumber(durationLike)) {
      return Duration.fromMillis(durationLike);
    } else if (Duration.isDuration(durationLike)) {
      return durationLike;
    } else if (typeof durationLike === "object") {
      return Duration.fromObject(durationLike);
    } else {
      throw new InvalidArgumentError(
        `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
      );
    }
  }
  static fromISO(text, opts) {
    const [parsed] = parseISODuration(text);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }
  static fromISOTime(text, opts) {
    const [parsed] = parseISOTimeOnly(text);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(invalid);
    } else {
      return new Duration({ invalid });
    }
  }
  static normalizeUnit(unit) {
    const normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[unit ? unit.toLowerCase() : unit];
    if (!normalized)
      throw new InvalidUnitError(unit);
    return normalized;
  }
  static isDuration(o3) {
    return o3 && o3.isLuxonDuration || false;
  }
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  toFormat(fmt, opts = {}) {
    const fmtOpts = {
      ...opts,
      floor: opts.round !== false && opts.floor !== false
    };
    return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID;
  }
  toHuman(opts = {}) {
    const l5 = orderedUnits.map((unit) => {
      const val = this.values[unit];
      if (isUndefined(val)) {
        return null;
      }
      return this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit.slice(0, -1) }).format(val);
    }).filter((n5) => n5);
    return this.loc.listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts }).format(l5);
  }
  toObject() {
    if (!this.isValid)
      return {};
    return { ...this.values };
  }
  toISO() {
    if (!this.isValid)
      return null;
    let s6 = "P";
    if (this.years !== 0)
      s6 += this.years + "Y";
    if (this.months !== 0 || this.quarters !== 0)
      s6 += this.months + this.quarters * 3 + "M";
    if (this.weeks !== 0)
      s6 += this.weeks + "W";
    if (this.days !== 0)
      s6 += this.days + "D";
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
      s6 += "T";
    if (this.hours !== 0)
      s6 += this.hours + "H";
    if (this.minutes !== 0)
      s6 += this.minutes + "M";
    if (this.seconds !== 0 || this.milliseconds !== 0)
      s6 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
    if (s6 === "P")
      s6 += "T0S";
    return s6;
  }
  toISOTime(opts = {}) {
    if (!this.isValid)
      return null;
    const millis = this.toMillis();
    if (millis < 0 || millis >= 864e5)
      return null;
    opts = {
      suppressMilliseconds: false,
      suppressSeconds: false,
      includePrefix: false,
      format: "extended",
      ...opts
    };
    const value = this.shiftTo("hours", "minutes", "seconds", "milliseconds");
    let fmt = opts.format === "basic" ? "hhmm" : "hh:mm";
    if (!opts.suppressSeconds || value.seconds !== 0 || value.milliseconds !== 0) {
      fmt += opts.format === "basic" ? "ss" : ":ss";
      if (!opts.suppressMilliseconds || value.milliseconds !== 0) {
        fmt += ".SSS";
      }
    }
    let str = value.toFormat(fmt);
    if (opts.includePrefix) {
      str = "T" + str;
    }
    return str;
  }
  toJSON() {
    return this.toISO();
  }
  toString() {
    return this.toISO();
  }
  toMillis() {
    return this.as("milliseconds");
  }
  valueOf() {
    return this.toMillis();
  }
  plus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration), result = {};
    for (const k2 of orderedUnits) {
      if (hasOwnProperty(dur.values, k2) || hasOwnProperty(this.values, k2)) {
        result[k2] = dur.get(k2) + this.get(k2);
      }
    }
    return clone(this, { values: result }, true);
  }
  minus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration);
    return this.plus(dur.negate());
  }
  mapUnits(fn) {
    if (!this.isValid)
      return this;
    const result = {};
    for (const k2 of Object.keys(this.values)) {
      result[k2] = asNumber(fn(this.values[k2], k2));
    }
    return clone(this, { values: result }, true);
  }
  get(unit) {
    return this[Duration.normalizeUnit(unit)];
  }
  set(values) {
    if (!this.isValid)
      return this;
    const mixed = { ...this.values, ...normalizeObject(values, Duration.normalizeUnit) };
    return clone(this, { values: mixed });
  }
  reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem });
    const opts = { loc, matrix, conversionAccuracy };
    return clone(this, opts);
  }
  as(unit) {
    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
  }
  normalize() {
    if (!this.isValid)
      return this;
    const vals = this.toObject();
    normalizeValues(this.matrix, vals);
    return clone(this, { values: vals }, true);
  }
  shiftTo(...units) {
    if (!this.isValid)
      return this;
    if (units.length === 0) {
      return this;
    }
    units = units.map((u3) => Duration.normalizeUnit(u3));
    const built = {}, accumulated = {}, vals = this.toObject();
    let lastUnit;
    for (const k2 of orderedUnits) {
      if (units.indexOf(k2) >= 0) {
        lastUnit = k2;
        let own = 0;
        for (const ak in accumulated) {
          own += this.matrix[ak][k2] * accumulated[ak];
          accumulated[ak] = 0;
        }
        if (isNumber(vals[k2])) {
          own += vals[k2];
        }
        const i4 = Math.trunc(own);
        built[k2] = i4;
        accumulated[k2] = (own * 1e3 - i4 * 1e3) / 1e3;
        for (const down in vals) {
          if (orderedUnits.indexOf(down) > orderedUnits.indexOf(k2)) {
            convert(this.matrix, vals, down, built, k2);
          }
        }
      } else if (isNumber(vals[k2])) {
        accumulated[k2] = vals[k2];
      }
    }
    for (const key in accumulated) {
      if (accumulated[key] !== 0) {
        built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
      }
    }
    return clone(this, { values: built }, true).normalize();
  }
  negate() {
    if (!this.isValid)
      return this;
    const negated = {};
    for (const k2 of Object.keys(this.values)) {
      negated[k2] = this.values[k2] === 0 ? 0 : -this.values[k2];
    }
    return clone(this, { values: negated }, true);
  }
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  get isValid() {
    return this.invalid === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    if (!this.loc.equals(other.loc)) {
      return false;
    }
    function eq(v1, v22) {
      if (v1 === void 0 || v1 === 0)
        return v22 === void 0 || v22 === 0;
      return v1 === v22;
    }
    for (const u3 of orderedUnits) {
      if (!eq(this.values[u3], other.values[u3])) {
        return false;
      }
    }
    return true;
  }
};

// node_modules/luxon/src/interval.js
var INVALID2 = "Invalid Interval";
function validateStartEnd(start, end) {
  if (!start || !start.isValid) {
    return Interval.invalid("missing or invalid start");
  } else if (!end || !end.isValid) {
    return Interval.invalid("missing or invalid end");
  } else if (end < start) {
    return Interval.invalid(
      "end before start",
      `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`
    );
  } else {
    return null;
  }
}
var Interval = class {
  constructor(config) {
    this.s = config.start;
    this.e = config.end;
    this.invalid = config.invalid || null;
    this.isLuxonInterval = true;
  }
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidIntervalError(invalid);
    } else {
      return new Interval({ invalid });
    }
  }
  static fromDateTimes(start, end) {
    const builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
    const validateError = validateStartEnd(builtStart, builtEnd);
    if (validateError == null) {
      return new Interval({
        start: builtStart,
        end: builtEnd
      });
    } else {
      return validateError;
    }
  }
  static after(start, duration) {
    const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start);
    return Interval.fromDateTimes(dt, dt.plus(dur));
  }
  static before(end, duration) {
    const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end);
    return Interval.fromDateTimes(dt.minus(dur), dt);
  }
  static fromISO(text, opts) {
    const [s6, e3] = (text || "").split("/", 2);
    if (s6 && e3) {
      let start, startIsValid;
      try {
        start = DateTime.fromISO(s6, opts);
        startIsValid = start.isValid;
      } catch (e4) {
        startIsValid = false;
      }
      let end, endIsValid;
      try {
        end = DateTime.fromISO(e3, opts);
        endIsValid = end.isValid;
      } catch (e4) {
        endIsValid = false;
      }
      if (startIsValid && endIsValid) {
        return Interval.fromDateTimes(start, end);
      }
      if (startIsValid) {
        const dur = Duration.fromISO(e3, opts);
        if (dur.isValid) {
          return Interval.after(start, dur);
        }
      } else if (endIsValid) {
        const dur = Duration.fromISO(s6, opts);
        if (dur.isValid) {
          return Interval.before(end, dur);
        }
      }
    }
    return Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
  }
  static isInterval(o3) {
    return o3 && o3.isLuxonInterval || false;
  }
  get start() {
    return this.isValid ? this.s : null;
  }
  get end() {
    return this.isValid ? this.e : null;
  }
  get isValid() {
    return this.invalidReason === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  length(unit = "milliseconds") {
    return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
  }
  count(unit = "milliseconds") {
    if (!this.isValid)
      return NaN;
    const start = this.start.startOf(unit), end = this.end.startOf(unit);
    return Math.floor(end.diff(start, unit).get(unit)) + 1;
  }
  hasSame(unit) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
  }
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  isAfter(dateTime) {
    if (!this.isValid)
      return false;
    return this.s > dateTime;
  }
  isBefore(dateTime) {
    if (!this.isValid)
      return false;
    return this.e <= dateTime;
  }
  contains(dateTime) {
    if (!this.isValid)
      return false;
    return this.s <= dateTime && this.e > dateTime;
  }
  set({ start, end } = {}) {
    if (!this.isValid)
      return this;
    return Interval.fromDateTimes(start || this.s, end || this.e);
  }
  splitAt(...dateTimes) {
    if (!this.isValid)
      return [];
    const sorted = dateTimes.map(friendlyDateTime).filter((d3) => this.contains(d3)).sort(), results = [];
    let { s: s6 } = this, i4 = 0;
    while (s6 < this.e) {
      const added = sorted[i4] || this.e, next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s6, next));
      s6 = next;
      i4 += 1;
    }
    return results;
  }
  splitBy(duration) {
    const dur = Duration.fromDurationLike(duration);
    if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
      return [];
    }
    let { s: s6 } = this, idx = 1, next;
    const results = [];
    while (s6 < this.e) {
      const added = this.start.plus(dur.mapUnits((x) => x * idx));
      next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s6, next));
      s6 = next;
      idx += 1;
    }
    return results;
  }
  divideEqually(numberOfParts) {
    if (!this.isValid)
      return [];
    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
  }
  overlaps(other) {
    return this.e > other.s && this.s < other.e;
  }
  abutsStart(other) {
    if (!this.isValid)
      return false;
    return +this.e === +other.s;
  }
  abutsEnd(other) {
    if (!this.isValid)
      return false;
    return +other.e === +this.s;
  }
  engulfs(other) {
    if (!this.isValid)
      return false;
    return this.s <= other.s && this.e >= other.e;
  }
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    return this.s.equals(other.s) && this.e.equals(other.e);
  }
  intersection(other) {
    if (!this.isValid)
      return this;
    const s6 = this.s > other.s ? this.s : other.s, e3 = this.e < other.e ? this.e : other.e;
    if (s6 >= e3) {
      return null;
    } else {
      return Interval.fromDateTimes(s6, e3);
    }
  }
  union(other) {
    if (!this.isValid)
      return this;
    const s6 = this.s < other.s ? this.s : other.s, e3 = this.e > other.e ? this.e : other.e;
    return Interval.fromDateTimes(s6, e3);
  }
  static merge(intervals) {
    const [found, final] = intervals.sort((a2, b2) => a2.s - b2.s).reduce(
      ([sofar, current], item) => {
        if (!current) {
          return [sofar, item];
        } else if (current.overlaps(item) || current.abutsStart(item)) {
          return [sofar, current.union(item)];
        } else {
          return [sofar.concat([current]), item];
        }
      },
      [[], null]
    );
    if (final) {
      found.push(final);
    }
    return found;
  }
  static xor(intervals) {
    let start = null, currentCount = 0;
    const results = [], ends = intervals.map((i4) => [
      { time: i4.s, type: "s" },
      { time: i4.e, type: "e" }
    ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a2, b2) => a2.time - b2.time);
    for (const i4 of arr) {
      currentCount += i4.type === "s" ? 1 : -1;
      if (currentCount === 1) {
        start = i4.time;
      } else {
        if (start && +start !== +i4.time) {
          results.push(Interval.fromDateTimes(start, i4.time));
        }
        start = null;
      }
    }
    return Interval.merge(results);
  }
  difference(...intervals) {
    return Interval.xor([this].concat(intervals)).map((i4) => this.intersection(i4)).filter((i4) => i4 && !i4.isEmpty());
  }
  toString() {
    if (!this.isValid)
      return INVALID2;
    return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
  }
  toISO(opts) {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
  }
  toISODate() {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toISODate()}/${this.e.toISODate()}`;
  }
  toISOTime(opts) {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
  }
  toFormat(dateFormat, { separator = " \u2013 " } = {}) {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
  }
  toDuration(unit, opts) {
    if (!this.isValid) {
      return Duration.invalid(this.invalidReason);
    }
    return this.e.diff(this.s, unit, opts);
  }
  mapEndpoints(mapFn) {
    return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
  }
};

// node_modules/luxon/src/info.js
var Info = class {
  static hasDST(zone = Settings.defaultZone) {
    const proto = DateTime.now().setZone(zone).set({ month: 12 });
    return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
  }
  static isValidIANAZone(zone) {
    return IANAZone.isValidZone(zone);
  }
  static normalizeZone(input) {
    return normalizeZone(input, Settings.defaultZone);
  }
  static months(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
  }
  static monthsFormat(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
  }
  static weekdays(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
  }
  static weekdaysFormat(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
  }
  static meridiems({ locale = null } = {}) {
    return Locale.create(locale).meridiems();
  }
  static eras(length = "short", { locale = null } = {}) {
    return Locale.create(locale, null, "gregory").eras(length);
  }
  static features() {
    return { relative: hasRelative() };
  }
};

// node_modules/luxon/src/impl/diff.js
function dayDiff(earlier, later) {
  const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
  return Math.floor(Duration.fromMillis(ms).as("days"));
}
function highOrderDiffs(cursor, later, units) {
  const differs = [
    ["years", (a2, b2) => b2.year - a2.year],
    ["quarters", (a2, b2) => b2.quarter - a2.quarter + (b2.year - a2.year) * 4],
    ["months", (a2, b2) => b2.month - a2.month + (b2.year - a2.year) * 12],
    [
      "weeks",
      (a2, b2) => {
        const days = dayDiff(a2, b2);
        return (days - days % 7) / 7;
      }
    ],
    ["days", dayDiff]
  ];
  const results = {};
  let lowestOrder, highWater;
  for (const [unit, differ] of differs) {
    if (units.indexOf(unit) >= 0) {
      lowestOrder = unit;
      let delta = differ(cursor, later);
      highWater = cursor.plus({ [unit]: delta });
      if (highWater > later) {
        cursor = cursor.plus({ [unit]: delta - 1 });
        delta -= 1;
      } else {
        cursor = highWater;
      }
      results[unit] = delta;
    }
  }
  return [cursor, results, highWater, lowestOrder];
}
function diff_default(earlier, later, units, opts) {
  let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
  const remainingMillis = later - cursor;
  const lowerOrderUnits = units.filter(
    (u3) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u3) >= 0
  );
  if (lowerOrderUnits.length === 0) {
    if (highWater < later) {
      highWater = cursor.plus({ [lowestOrder]: 1 });
    }
    if (highWater !== cursor) {
      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
    }
  }
  const duration = Duration.fromObject(results, opts);
  if (lowerOrderUnits.length > 0) {
    return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
  } else {
    return duration;
  }
}

// node_modules/luxon/src/impl/digits.js
var numberingSystems = {
  arab: "[\u0660-\u0669]",
  arabext: "[\u06F0-\u06F9]",
  bali: "[\u1B50-\u1B59]",
  beng: "[\u09E6-\u09EF]",
  deva: "[\u0966-\u096F]",
  fullwide: "[\uFF10-\uFF19]",
  gujr: "[\u0AE6-\u0AEF]",
  hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
  khmr: "[\u17E0-\u17E9]",
  knda: "[\u0CE6-\u0CEF]",
  laoo: "[\u0ED0-\u0ED9]",
  limb: "[\u1946-\u194F]",
  mlym: "[\u0D66-\u0D6F]",
  mong: "[\u1810-\u1819]",
  mymr: "[\u1040-\u1049]",
  orya: "[\u0B66-\u0B6F]",
  tamldec: "[\u0BE6-\u0BEF]",
  telu: "[\u0C66-\u0C6F]",
  thai: "[\u0E50-\u0E59]",
  tibt: "[\u0F20-\u0F29]",
  latn: "\\d"
};
var numberingSystemsUTF16 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
};
var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
function parseDigits(str) {
  let value = parseInt(str, 10);
  if (isNaN(value)) {
    value = "";
    for (let i4 = 0; i4 < str.length; i4++) {
      const code = str.charCodeAt(i4);
      if (str[i4].search(numberingSystems.hanidec) !== -1) {
        value += hanidecChars.indexOf(str[i4]);
      } else {
        for (const key in numberingSystemsUTF16) {
          const [min, max] = numberingSystemsUTF16[key];
          if (code >= min && code <= max) {
            value += code - min;
          }
        }
      }
    }
    return parseInt(value, 10);
  } else {
    return value;
  }
}
function digitRegex({ numberingSystem }, append = "") {
  return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append}`);
}

// node_modules/luxon/src/impl/tokenParser.js
var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
function intUnit(regex, post = (i4) => i4) {
  return { regex, deser: ([s6]) => post(parseDigits(s6)) };
}
var NBSP = String.fromCharCode(160);
var spaceOrNBSP = `[ ${NBSP}]`;
var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
function fixListRegex(s6) {
  return s6.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
}
function stripInsensitivities(s6) {
  return s6.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
}
function oneOf(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join("|")),
      deser: ([s6]) => strings.findIndex((i4) => stripInsensitivities(s6) === stripInsensitivities(i4)) + startIndex
    };
  }
}
function offset(regex, groups) {
  return { regex, deser: ([, h3, m3]) => signedOffset(h3, m3), groups };
}
function simple(regex) {
  return { regex, deser: ([s6]) => s6 };
}
function escapeToken(value) {
  return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function unitForToken(token, loc) {
  const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = (t5) => ({ regex: RegExp(escapeToken(t5.val)), deser: ([s6]) => s6, literal: true }), unitate = (t5) => {
    if (token.literal) {
      return literal(t5);
    }
    switch (t5.val) {
      case "G":
        return oneOf(loc.eras("short", false), 0);
      case "GG":
        return oneOf(loc.eras("long", false), 0);
      case "y":
        return intUnit(oneToSix);
      case "yy":
        return intUnit(twoToFour, untruncateYear);
      case "yyyy":
        return intUnit(four);
      case "yyyyy":
        return intUnit(fourToSix);
      case "yyyyyy":
        return intUnit(six);
      case "M":
        return intUnit(oneOrTwo);
      case "MM":
        return intUnit(two);
      case "MMM":
        return oneOf(loc.months("short", true, false), 1);
      case "MMMM":
        return oneOf(loc.months("long", true, false), 1);
      case "L":
        return intUnit(oneOrTwo);
      case "LL":
        return intUnit(two);
      case "LLL":
        return oneOf(loc.months("short", false, false), 1);
      case "LLLL":
        return oneOf(loc.months("long", false, false), 1);
      case "d":
        return intUnit(oneOrTwo);
      case "dd":
        return intUnit(two);
      case "o":
        return intUnit(oneToThree);
      case "ooo":
        return intUnit(three);
      case "HH":
        return intUnit(two);
      case "H":
        return intUnit(oneOrTwo);
      case "hh":
        return intUnit(two);
      case "h":
        return intUnit(oneOrTwo);
      case "mm":
        return intUnit(two);
      case "m":
        return intUnit(oneOrTwo);
      case "q":
        return intUnit(oneOrTwo);
      case "qq":
        return intUnit(two);
      case "s":
        return intUnit(oneOrTwo);
      case "ss":
        return intUnit(two);
      case "S":
        return intUnit(oneToThree);
      case "SSS":
        return intUnit(three);
      case "u":
        return simple(oneToNine);
      case "uu":
        return simple(oneOrTwo);
      case "uuu":
        return intUnit(one);
      case "a":
        return oneOf(loc.meridiems(), 0);
      case "kkkk":
        return intUnit(four);
      case "kk":
        return intUnit(twoToFour, untruncateYear);
      case "W":
        return intUnit(oneOrTwo);
      case "WW":
        return intUnit(two);
      case "E":
      case "c":
        return intUnit(one);
      case "EEE":
        return oneOf(loc.weekdays("short", false, false), 1);
      case "EEEE":
        return oneOf(loc.weekdays("long", false, false), 1);
      case "ccc":
        return oneOf(loc.weekdays("short", true, false), 1);
      case "cccc":
        return oneOf(loc.weekdays("long", true, false), 1);
      case "Z":
      case "ZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
      case "ZZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
      case "z":
        return simple(/[a-z_+-/]{1,256}?/i);
      default:
        return literal(t5);
    }
  };
  const unit = unitate(token) || {
    invalidReason: MISSING_FTP
  };
  unit.token = token;
  return unit;
}
var partTypeStyleToTokenVal = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour: {
    numeric: "h",
    "2-digit": "hh"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function tokenForPart(part, locale, formatOpts) {
  const { type, value } = part;
  if (type === "literal") {
    return {
      literal: true,
      val: value
    };
  }
  const style = formatOpts[type];
  let val = partTypeStyleToTokenVal[type];
  if (typeof val === "object") {
    val = val[style];
  }
  if (val) {
    return {
      literal: false,
      val
    };
  }
  return void 0;
}
function buildRegex(units) {
  const re2 = units.map((u3) => u3.regex).reduce((f2, r3) => `${f2}(${r3.source})`, "");
  return [`^${re2}$`, units];
}
function match(input, regex, handlers) {
  const matches = input.match(regex);
  if (matches) {
    const all = {};
    let matchIndex = 1;
    for (const i4 in handlers) {
      if (hasOwnProperty(handlers, i4)) {
        const h3 = handlers[i4], groups = h3.groups ? h3.groups + 1 : 1;
        if (!h3.literal && h3.token) {
          all[h3.token.val[0]] = h3.deser(matches.slice(matchIndex, matchIndex + groups));
        }
        matchIndex += groups;
      }
    }
    return [matches, all];
  } else {
    return [matches, {}];
  }
}
function dateTimeFromMatches(matches) {
  const toField = (token) => {
    switch (token) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let zone = null;
  let specificOffset;
  if (!isUndefined(matches.z)) {
    zone = IANAZone.create(matches.z);
  }
  if (!isUndefined(matches.Z)) {
    if (!zone) {
      zone = new FixedOffsetZone(matches.Z);
    }
    specificOffset = matches.Z;
  }
  if (!isUndefined(matches.q)) {
    matches.M = (matches.q - 1) * 3 + 1;
  }
  if (!isUndefined(matches.h)) {
    if (matches.h < 12 && matches.a === 1) {
      matches.h += 12;
    } else if (matches.h === 12 && matches.a === 0) {
      matches.h = 0;
    }
  }
  if (matches.G === 0 && matches.y) {
    matches.y = -matches.y;
  }
  if (!isUndefined(matches.u)) {
    matches.S = parseMillis(matches.u);
  }
  const vals = Object.keys(matches).reduce((r3, k2) => {
    const f2 = toField(k2);
    if (f2) {
      r3[f2] = matches[k2];
    }
    return r3;
  }, {});
  return [vals, zone, specificOffset];
}
var dummyDateTimeCache = null;
function getDummyDateTime() {
  if (!dummyDateTimeCache) {
    dummyDateTimeCache = DateTime.fromMillis(1555555555555);
  }
  return dummyDateTimeCache;
}
function maybeExpandMacroToken(token, locale) {
  if (token.literal) {
    return token;
  }
  const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
  const tokens = formatOptsToTokens(formatOpts, locale);
  if (tokens == null || tokens.includes(void 0)) {
    return token;
  }
  return tokens;
}
function expandMacroTokens(tokens, locale) {
  return Array.prototype.concat(...tokens.map((t5) => maybeExpandMacroToken(t5, locale)));
}
function explainFromTokens(locale, input, format) {
  const tokens = expandMacroTokens(Formatter.parseFormat(format), locale), units = tokens.map((t5) => unitForToken(t5, locale)), disqualifyingUnit = units.find((t5) => t5.invalidReason);
  if (disqualifyingUnit) {
    return { input, tokens, invalidReason: disqualifyingUnit.invalidReason };
  } else {
    const [regexString, handlers] = buildRegex(units), regex = RegExp(regexString, "i"), [rawMatches, matches] = match(input, regex, handlers), [result, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, void 0];
    if (hasOwnProperty(matches, "a") && hasOwnProperty(matches, "H")) {
      throw new ConflictingSpecificationError(
        "Can't include meridiem when specifying 24-hour format"
      );
    }
    return { input, tokens, regex, rawMatches, matches, result, zone, specificOffset };
  }
}
function parseFromTokens(locale, input, format) {
  const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input, format);
  return [result, zone, specificOffset, invalidReason];
}
function formatOptsToTokens(formatOpts, locale) {
  if (!formatOpts) {
    return null;
  }
  const formatter = Formatter.create(locale, formatOpts);
  const parts = formatter.formatDateTimeParts(getDummyDateTime());
  return parts.map((p5) => tokenForPart(p5, locale, formatOpts));
}

// node_modules/luxon/src/impl/conversions.js
var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function unitOutOfRange(unit, value) {
  return new Invalid(
    "unit out of range",
    `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`
  );
}
function dayOfWeek(year, month, day) {
  const d3 = new Date(Date.UTC(year, month - 1, day));
  if (year < 100 && year >= 0) {
    d3.setUTCFullYear(d3.getUTCFullYear() - 1900);
  }
  const js = d3.getUTCDay();
  return js === 0 ? 7 : js;
}
function computeOrdinal(year, month, day) {
  return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
}
function uncomputeOrdinal(year, ordinal) {
  const table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i4) => i4 < ordinal), day = ordinal - table[month0];
  return { month: month0 + 1, day };
}
function gregorianToWeek(gregObj) {
  const { year, month, day } = gregObj, ordinal = computeOrdinal(year, month, day), weekday = dayOfWeek(year, month, day);
  let weekNumber = Math.floor((ordinal - weekday + 10) / 7), weekYear;
  if (weekNumber < 1) {
    weekYear = year - 1;
    weekNumber = weeksInWeekYear(weekYear);
  } else if (weekNumber > weeksInWeekYear(year)) {
    weekYear = year + 1;
    weekNumber = 1;
  } else {
    weekYear = year;
  }
  return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };
}
function weekToGregorian(weekData) {
  const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = dayOfWeek(weekYear, 1, 4), yearInDays = daysInYear(weekYear);
  let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3, year;
  if (ordinal < 1) {
    year = weekYear - 1;
    ordinal += daysInYear(year);
  } else if (ordinal > yearInDays) {
    year = weekYear + 1;
    ordinal -= daysInYear(weekYear);
  } else {
    year = weekYear;
  }
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(weekData) };
}
function gregorianToOrdinal(gregData) {
  const { year, month, day } = gregData;
  const ordinal = computeOrdinal(year, month, day);
  return { year, ordinal, ...timeObject(gregData) };
}
function ordinalToGregorian(ordinalData) {
  const { year, ordinal } = ordinalData;
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(ordinalData) };
}
function hasInvalidWeekData(obj) {
  const validYear = isInteger(obj.weekYear), validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)), validWeekday = integerBetween(obj.weekday, 1, 7);
  if (!validYear) {
    return unitOutOfRange("weekYear", obj.weekYear);
  } else if (!validWeek) {
    return unitOutOfRange("week", obj.week);
  } else if (!validWeekday) {
    return unitOutOfRange("weekday", obj.weekday);
  } else
    return false;
}
function hasInvalidOrdinalData(obj) {
  const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validOrdinal) {
    return unitOutOfRange("ordinal", obj.ordinal);
  } else
    return false;
}
function hasInvalidGregorianData(obj) {
  const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validMonth) {
    return unitOutOfRange("month", obj.month);
  } else if (!validDay) {
    return unitOutOfRange("day", obj.day);
  } else
    return false;
}
function hasInvalidTimeData(obj) {
  const { hour, minute, second, millisecond } = obj;
  const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
  if (!validHour) {
    return unitOutOfRange("hour", hour);
  } else if (!validMinute) {
    return unitOutOfRange("minute", minute);
  } else if (!validSecond) {
    return unitOutOfRange("second", second);
  } else if (!validMillisecond) {
    return unitOutOfRange("millisecond", millisecond);
  } else
    return false;
}

// node_modules/luxon/src/datetime.js
var INVALID3 = "Invalid DateTime";
var MAX_DATE = 864e13;
function unsupportedZone(zone) {
  return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
}
function possiblyCachedWeekData(dt) {
  if (dt.weekData === null) {
    dt.weekData = gregorianToWeek(dt.c);
  }
  return dt.weekData;
}
function clone2(inst, alts) {
  const current = {
    ts: inst.ts,
    zone: inst.zone,
    c: inst.c,
    o: inst.o,
    loc: inst.loc,
    invalid: inst.invalid
  };
  return new DateTime({ ...current, ...alts, old: current });
}
function fixOffset(localTS, o3, tz) {
  let utcGuess = localTS - o3 * 60 * 1e3;
  const o22 = tz.offset(utcGuess);
  if (o3 === o22) {
    return [utcGuess, o3];
  }
  utcGuess -= (o22 - o3) * 60 * 1e3;
  const o32 = tz.offset(utcGuess);
  if (o22 === o32) {
    return [utcGuess, o22];
  }
  return [localTS - Math.min(o22, o32) * 60 * 1e3, Math.max(o22, o32)];
}
function tsToObj(ts, offset2) {
  ts += offset2 * 60 * 1e3;
  const d3 = new Date(ts);
  return {
    year: d3.getUTCFullYear(),
    month: d3.getUTCMonth() + 1,
    day: d3.getUTCDate(),
    hour: d3.getUTCHours(),
    minute: d3.getUTCMinutes(),
    second: d3.getUTCSeconds(),
    millisecond: d3.getUTCMilliseconds()
  };
}
function objToTS(obj, offset2, zone) {
  return fixOffset(objToLocalTS(obj), offset2, zone);
}
function adjustTime(inst, dur) {
  const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c3 = {
    ...inst.c,
    year,
    month,
    day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
  }, millisToAdd = Duration.fromObject({
    years: dur.years - Math.trunc(dur.years),
    quarters: dur.quarters - Math.trunc(dur.quarters),
    months: dur.months - Math.trunc(dur.months),
    weeks: dur.weeks - Math.trunc(dur.weeks),
    days: dur.days - Math.trunc(dur.days),
    hours: dur.hours,
    minutes: dur.minutes,
    seconds: dur.seconds,
    milliseconds: dur.milliseconds
  }).as("milliseconds"), localTS = objToLocalTS(c3);
  let [ts, o3] = fixOffset(localTS, oPre, inst.zone);
  if (millisToAdd !== 0) {
    ts += millisToAdd;
    o3 = inst.zone.offset(ts);
  }
  return { ts, o: o3 };
}
function parseDataToDateTime(parsed, parsedZone, opts, format, text, specificOffset) {
  const { setZone, zone } = opts;
  if (parsed && Object.keys(parsed).length !== 0) {
    const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, {
      ...opts,
      zone: interpretationZone,
      specificOffset
    });
    return setZone ? inst : inst.setZone(zone);
  } else {
    return DateTime.invalid(
      new Invalid("unparsable", `the input "${text}" can't be parsed as ${format}`)
    );
  }
}
function toTechFormat(dt, format, allowZ = true) {
  return dt.isValid ? Formatter.create(Locale.create("en-US"), {
    allowZ,
    forceSimple: true
  }).formatDateTimeFromString(dt, format) : null;
}
function toISODate(o3, extended) {
  const longFormat = o3.c.year > 9999 || o3.c.year < 0;
  let c3 = "";
  if (longFormat && o3.c.year >= 0)
    c3 += "+";
  c3 += padStart(o3.c.year, longFormat ? 6 : 4);
  if (extended) {
    c3 += "-";
    c3 += padStart(o3.c.month);
    c3 += "-";
    c3 += padStart(o3.c.day);
  } else {
    c3 += padStart(o3.c.month);
    c3 += padStart(o3.c.day);
  }
  return c3;
}
function toISOTime(o3, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
  let c3 = padStart(o3.c.hour);
  if (extended) {
    c3 += ":";
    c3 += padStart(o3.c.minute);
    if (o3.c.second !== 0 || !suppressSeconds) {
      c3 += ":";
    }
  } else {
    c3 += padStart(o3.c.minute);
  }
  if (o3.c.second !== 0 || !suppressSeconds) {
    c3 += padStart(o3.c.second);
    if (o3.c.millisecond !== 0 || !suppressMilliseconds) {
      c3 += ".";
      c3 += padStart(o3.c.millisecond, 3);
    }
  }
  if (includeOffset) {
    if (o3.isOffsetFixed && o3.offset === 0 && !extendedZone) {
      c3 += "Z";
    } else if (o3.o < 0) {
      c3 += "-";
      c3 += padStart(Math.trunc(-o3.o / 60));
      c3 += ":";
      c3 += padStart(Math.trunc(-o3.o % 60));
    } else {
      c3 += "+";
      c3 += padStart(Math.trunc(o3.o / 60));
      c3 += ":";
      c3 += padStart(Math.trunc(o3.o % 60));
    }
  }
  if (extendedZone) {
    c3 += "[" + o3.zone.ianaName + "]";
  }
  return c3;
}
var defaultUnitValues = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var defaultWeekUnitValues = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var defaultOrdinalUnitValues = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var orderedUnits2 = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
var orderedWeekUnits = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
];
var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function normalizeUnit(unit) {
  const normalized = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[unit.toLowerCase()];
  if (!normalized)
    throw new InvalidUnitError(unit);
  return normalized;
}
function quickDT(obj, opts) {
  const zone = normalizeZone(opts.zone, Settings.defaultZone), loc = Locale.fromObject(opts), tsNow = Settings.now();
  let ts, o3;
  if (!isUndefined(obj.year)) {
    for (const u3 of orderedUnits2) {
      if (isUndefined(obj[u3])) {
        obj[u3] = defaultUnitValues[u3];
      }
    }
    const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const offsetProvis = zone.offset(tsNow);
    [ts, o3] = objToTS(obj, offsetProvis, zone);
  } else {
    ts = tsNow;
  }
  return new DateTime({ ts, zone, loc, o: o3 });
}
function diffRelative(start, end, opts) {
  const round = isUndefined(opts.round) ? true : opts.round, format = (c3, unit) => {
    c3 = roundTo(c3, round || opts.calendary ? 0 : 2, true);
    const formatter = end.loc.clone(opts).relFormatter(opts);
    return formatter.format(c3, unit);
  }, differ = (unit) => {
    if (opts.calendary) {
      if (!end.hasSame(start, unit)) {
        return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
      } else
        return 0;
    } else {
      return end.diff(start, unit).get(unit);
    }
  };
  if (opts.unit) {
    return format(differ(opts.unit), opts.unit);
  }
  for (const unit of opts.units) {
    const count = differ(unit);
    if (Math.abs(count) >= 1) {
      return format(count, unit);
    }
  }
  return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
}
function lastOpts(argList) {
  let opts = {}, args;
  if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
    opts = argList[argList.length - 1];
    args = Array.from(argList).slice(0, argList.length - 1);
  } else {
    args = Array.from(argList);
  }
  return [opts, args];
}
var DateTime = class {
  constructor(config) {
    const zone = config.zone || Settings.defaultZone;
    let invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
    this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
    let c3 = null, o3 = null;
    if (!invalid) {
      const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
      if (unchanged) {
        [c3, o3] = [config.old.c, config.old.o];
      } else {
        const ot = zone.offset(this.ts);
        c3 = tsToObj(this.ts, ot);
        invalid = Number.isNaN(c3.year) ? new Invalid("invalid input") : null;
        c3 = invalid ? null : c3;
        o3 = invalid ? null : ot;
      }
    }
    this._zone = zone;
    this.loc = config.loc || Locale.create();
    this.invalid = invalid;
    this.weekData = null;
    this.c = c3;
    this.o = o3;
    this.isLuxonDateTime = true;
  }
  static now() {
    return new DateTime({});
  }
  static local() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  static utc() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    opts.zone = FixedOffsetZone.utcInstance;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  static fromJSDate(date, options = {}) {
    const ts = isDate(date) ? date.valueOf() : NaN;
    if (Number.isNaN(ts)) {
      return DateTime.invalid("invalid input");
    }
    const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    return new DateTime({
      ts,
      zone: zoneToUse,
      loc: Locale.fromObject(options)
    });
  }
  static fromMillis(milliseconds, options = {}) {
    if (!isNumber(milliseconds)) {
      throw new InvalidArgumentError(
        `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
      );
    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
      return DateTime.invalid("Timestamp out of range");
    } else {
      return new DateTime({
        ts: milliseconds,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  static fromSeconds(seconds, options = {}) {
    if (!isNumber(seconds)) {
      throw new InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new DateTime({
        ts: seconds * 1e3,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  static fromObject(obj, opts = {}) {
    obj = obj || {};
    const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    const tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), normalized = normalizeObject(obj, normalizeUnit), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber, loc = Locale.fromObject(opts);
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
    let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
    if (useWeekData) {
      units = orderedWeekUnits;
      defaultValues = defaultWeekUnitValues;
      objNow = gregorianToWeek(objNow);
    } else if (containsOrdinal) {
      units = orderedOrdinalUnits;
      defaultValues = defaultOrdinalUnitValues;
      objNow = gregorianToOrdinal(objNow);
    } else {
      units = orderedUnits2;
      defaultValues = defaultUnitValues;
    }
    let foundFirst = false;
    for (const u3 of units) {
      const v4 = normalized[u3];
      if (!isUndefined(v4)) {
        foundFirst = true;
      } else if (foundFirst) {
        normalized[u3] = defaultValues[u3];
      } else {
        normalized[u3] = objNow[u3];
      }
    }
    const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const gregorian = useWeekData ? weekToGregorian(normalized) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new DateTime({
      ts: tsFinal,
      zone: zoneToUse,
      o: offsetFinal,
      loc
    });
    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
      return DateTime.invalid(
        "mismatched weekday",
        `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
      );
    }
    return inst;
  }
  static fromISO(text, opts = {}) {
    const [vals, parsedZone] = parseISODate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
  }
  static fromRFC2822(text, opts = {}) {
    const [vals, parsedZone] = parseRFC2822Date(text);
    return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
  }
  static fromHTTP(text, opts = {}) {
    const [vals, parsedZone] = parseHTTPDate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
  }
  static fromFormat(text, fmt, opts = {}) {
    if (isUndefined(text) || isUndefined(fmt)) {
      throw new InvalidArgumentError("fromFormat requires an input string and a format");
    }
    const { locale = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text, fmt);
    if (invalid) {
      return DateTime.invalid(invalid);
    } else {
      return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
    }
  }
  static fromString(text, fmt, opts = {}) {
    return DateTime.fromFormat(text, fmt, opts);
  }
  static fromSQL(text, opts = {}) {
    const [vals, parsedZone] = parseSQL(text);
    return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
  }
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDateTimeError(invalid);
    } else {
      return new DateTime({ invalid });
    }
  }
  static isDateTime(o3) {
    return o3 && o3.isLuxonDateTime || false;
  }
  static parseFormatForOpts(formatOpts, localeOpts = {}) {
    const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
    return !tokenList ? null : tokenList.map((t5) => t5 ? t5.val : null).join("");
  }
  static expandFormat(fmt, localeOpts = {}) {
    const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
    return expanded.map((t5) => t5.val).join("");
  }
  get(unit) {
    return this[unit];
  }
  get isValid() {
    return this.invalid === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  get zone() {
    return this._zone;
  }
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  get weekYear() {
    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
  }
  get weekNumber() {
    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
  }
  get weekday() {
    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
  }
  get ordinal() {
    return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
  }
  get monthShort() {
    return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  get monthLong() {
    return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  get weekdayShort() {
    return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  get weekdayLong() {
    return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  get offsetNameShort() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "short",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  get offsetNameLong() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "long",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  get isInDST() {
    if (this.isOffsetFixed) {
      return false;
    } else {
      return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
    }
  }
  get isInLeapYear() {
    return isLeapYear(this.year);
  }
  get daysInMonth() {
    return daysInMonth(this.year, this.month);
  }
  get daysInYear() {
    return this.isValid ? daysInYear(this.year) : NaN;
  }
  get weeksInWeekYear() {
    return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
  }
  resolvedLocaleOptions(opts = {}) {
    const { locale, numberingSystem, calendar } = Formatter.create(
      this.loc.clone(opts),
      opts
    ).resolvedOptions(this);
    return { locale, numberingSystem, outputCalendar: calendar };
  }
  toUTC(offset2 = 0, opts = {}) {
    return this.setZone(FixedOffsetZone.instance(offset2), opts);
  }
  toLocal() {
    return this.setZone(Settings.defaultZone);
  }
  setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
    zone = normalizeZone(zone, Settings.defaultZone);
    if (zone.equals(this.zone)) {
      return this;
    } else if (!zone.isValid) {
      return DateTime.invalid(unsupportedZone(zone));
    } else {
      let newTS = this.ts;
      if (keepLocalTime || keepCalendarTime) {
        const offsetGuess = zone.offset(this.ts);
        const asObj = this.toObject();
        [newTS] = objToTS(asObj, offsetGuess, zone);
      }
      return clone2(this, { ts: newTS, zone });
    }
  }
  reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
    return clone2(this, { loc });
  }
  setLocale(locale) {
    return this.reconfigure({ locale });
  }
  set(values) {
    if (!this.isValid)
      return this;
    const normalized = normalizeObject(values, normalizeUnit), settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    let mixed;
    if (settingWeekStuff) {
      mixed = weekToGregorian({ ...gregorianToWeek(this.c), ...normalized });
    } else if (!isUndefined(normalized.ordinal)) {
      mixed = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...normalized });
    } else {
      mixed = { ...this.toObject(), ...normalized };
      if (isUndefined(normalized.day)) {
        mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
      }
    }
    const [ts, o3] = objToTS(mixed, this.o, this.zone);
    return clone2(this, { ts, o: o3 });
  }
  plus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration);
    return clone2(this, adjustTime(this, dur));
  }
  minus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration).negate();
    return clone2(this, adjustTime(this, dur));
  }
  startOf(unit) {
    if (!this.isValid)
      return this;
    const o3 = {}, normalizedUnit = Duration.normalizeUnit(unit);
    switch (normalizedUnit) {
      case "years":
        o3.month = 1;
      case "quarters":
      case "months":
        o3.day = 1;
      case "weeks":
      case "days":
        o3.hour = 0;
      case "hours":
        o3.minute = 0;
      case "minutes":
        o3.second = 0;
      case "seconds":
        o3.millisecond = 0;
        break;
      case "milliseconds":
        break;
    }
    if (normalizedUnit === "weeks") {
      o3.weekday = 1;
    }
    if (normalizedUnit === "quarters") {
      const q2 = Math.ceil(this.month / 3);
      o3.month = (q2 - 1) * 3 + 1;
    }
    return this.set(o3);
  }
  endOf(unit) {
    return this.isValid ? this.plus({ [unit]: 1 }).startOf(unit).minus(1) : this;
  }
  toFormat(fmt, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID3;
  }
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID3;
  }
  toLocaleParts(opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
  }
  toISO({
    format = "extended",
    suppressSeconds = false,
    suppressMilliseconds = false,
    includeOffset = true,
    extendedZone = false
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    const ext = format === "extended";
    let c3 = toISODate(this, ext);
    c3 += "T";
    c3 += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
    return c3;
  }
  toISODate({ format = "extended" } = {}) {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, format === "extended");
  }
  toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }
  toISOTime({
    suppressMilliseconds = false,
    suppressSeconds = false,
    includeOffset = true,
    includePrefix = false,
    extendedZone = false,
    format = "extended"
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    let c3 = includePrefix ? "T" : "";
    return c3 + toISOTime(
      this,
      format === "extended",
      suppressSeconds,
      suppressMilliseconds,
      includeOffset,
      extendedZone
    );
  }
  toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }
  toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  toSQLDate() {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, true);
  }
  toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
    let fmt = "HH:mm:ss.SSS";
    if (includeZone || includeOffset) {
      if (includeOffsetSpace) {
        fmt += " ";
      }
      if (includeZone) {
        fmt += "z";
      } else if (includeOffset) {
        fmt += "ZZ";
      }
    }
    return toTechFormat(this, fmt, true);
  }
  toSQL(opts = {}) {
    if (!this.isValid) {
      return null;
    }
    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
  }
  toString() {
    return this.isValid ? this.toISO() : INVALID3;
  }
  valueOf() {
    return this.toMillis();
  }
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  toJSON() {
    return this.toISO();
  }
  toBSON() {
    return this.toJSDate();
  }
  toObject(opts = {}) {
    if (!this.isValid)
      return {};
    const base = { ...this.c };
    if (opts.includeConfig) {
      base.outputCalendar = this.outputCalendar;
      base.numberingSystem = this.loc.numberingSystem;
      base.locale = this.loc.locale;
    }
    return base;
  }
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  diff(otherDateTime, unit = "milliseconds", opts = {}) {
    if (!this.isValid || !otherDateTime.isValid) {
      return Duration.invalid("created by diffing an invalid DateTime");
    }
    const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };
    const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff_default(earlier, later, units, durOpts);
    return otherIsLater ? diffed.negate() : diffed;
  }
  diffNow(unit = "milliseconds", opts = {}) {
    return this.diff(DateTime.now(), unit, opts);
  }
  until(otherDateTime) {
    return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
  }
  hasSame(otherDateTime, unit) {
    if (!this.isValid)
      return false;
    const inputMs = otherDateTime.valueOf();
    const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
    return adjustedToZone.startOf(unit) <= inputMs && inputMs <= adjustedToZone.endOf(unit);
  }
  equals(other) {
    return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
  }
  toRelative(options = {}) {
    if (!this.isValid)
      return null;
    const base = options.base || DateTime.fromObject({}, { zone: this.zone }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
    let units = ["years", "months", "days", "hours", "minutes", "seconds"];
    let unit = options.unit;
    if (Array.isArray(options.unit)) {
      units = options.unit;
      unit = void 0;
    }
    return diffRelative(base, this.plus(padding), {
      ...options,
      numeric: "always",
      units,
      unit
    });
  }
  toRelativeCalendar(options = {}) {
    if (!this.isValid)
      return null;
    return diffRelative(options.base || DateTime.fromObject({}, { zone: this.zone }), this, {
      ...options,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: true
    });
  }
  static min(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i4) => i4.valueOf(), Math.min);
  }
  static max(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i4) => i4.valueOf(), Math.max);
  }
  static fromFormatExplain(text, fmt, options = {}) {
    const { locale = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    });
    return explainFromTokens(localeToUse, text, fmt);
  }
  static fromStringExplain(text, fmt, options = {}) {
    return DateTime.fromFormatExplain(text, fmt, options);
  }
  static get DATE_SHORT() {
    return DATE_SHORT;
  }
  static get DATE_MED() {
    return DATE_MED;
  }
  static get DATE_MED_WITH_WEEKDAY() {
    return DATE_MED_WITH_WEEKDAY;
  }
  static get DATE_FULL() {
    return DATE_FULL;
  }
  static get DATE_HUGE() {
    return DATE_HUGE;
  }
  static get TIME_SIMPLE() {
    return TIME_SIMPLE;
  }
  static get TIME_WITH_SECONDS() {
    return TIME_WITH_SECONDS;
  }
  static get TIME_WITH_SHORT_OFFSET() {
    return TIME_WITH_SHORT_OFFSET;
  }
  static get TIME_WITH_LONG_OFFSET() {
    return TIME_WITH_LONG_OFFSET;
  }
  static get TIME_24_SIMPLE() {
    return TIME_24_SIMPLE;
  }
  static get TIME_24_WITH_SECONDS() {
    return TIME_24_WITH_SECONDS;
  }
  static get TIME_24_WITH_SHORT_OFFSET() {
    return TIME_24_WITH_SHORT_OFFSET;
  }
  static get TIME_24_WITH_LONG_OFFSET() {
    return TIME_24_WITH_LONG_OFFSET;
  }
  static get DATETIME_SHORT() {
    return DATETIME_SHORT;
  }
  static get DATETIME_SHORT_WITH_SECONDS() {
    return DATETIME_SHORT_WITH_SECONDS;
  }
  static get DATETIME_MED() {
    return DATETIME_MED;
  }
  static get DATETIME_MED_WITH_SECONDS() {
    return DATETIME_MED_WITH_SECONDS;
  }
  static get DATETIME_MED_WITH_WEEKDAY() {
    return DATETIME_MED_WITH_WEEKDAY;
  }
  static get DATETIME_FULL() {
    return DATETIME_FULL;
  }
  static get DATETIME_FULL_WITH_SECONDS() {
    return DATETIME_FULL_WITH_SECONDS;
  }
  static get DATETIME_HUGE() {
    return DATETIME_HUGE;
  }
  static get DATETIME_HUGE_WITH_SECONDS() {
    return DATETIME_HUGE_WITH_SECONDS;
  }
};
function friendlyDateTime(dateTimeish) {
  if (DateTime.isDateTime(dateTimeish)) {
    return dateTimeish;
  } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
    return DateTime.fromJSDate(dateTimeish);
  } else if (dateTimeish && typeof dateTimeish === "object") {
    return DateTime.fromObject(dateTimeish);
  } else {
    throw new InvalidArgumentError(
      `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
    );
  }
}

// node_modules/@arcgis/core/chunks/languageUtils.js
var T = class {
  constructor(e3) {
    this.value = e3;
  }
};
var M = class {
  constructor(e3) {
    this.value = e3;
  }
};
var N = M;
var D2 = T;
var k = { type: "VOID" };
var j = { type: "BREAK" };
var A = { type: "CONTINUE" };
function R(e3, t5, n5) {
  return "" === t5 || null == t5 || t5 === n5 || t5 === n5 ? e3 : e3 = e3.split(t5).join(n5);
}
function F2(t5) {
  return t5 instanceof r2;
}
function C2(e3) {
  return e3 instanceof s4;
}
function I(e3) {
  return !!w3(e3) || (!!Z(e3) || (!!z(e3) || (!!_(e3) || (null === e3 || (e3 === k || "number" == typeof e3)))));
}
function v3(e3, t5) {
  return void 0 === e3 ? t5 : e3;
}
function O(e3) {
  return null == e3 ? "" : Y(e3) || E(e3) ? "Array" : z(e3) ? "Date" : w3(e3) ? "String" : _(e3) ? "Boolean" : Z(e3) ? "Number" : "esri.arcade.Attachment" === (e3 == null ? void 0 : e3.declaredClass) ? "Attachment" : "esri.arcade.Portal" === (e3 == null ? void 0 : e3.declaredClass) ? "Portal" : "esri.arcade.Dictionary" === (e3 == null ? void 0 : e3.declaredClass) ? "Dictionary" : e3 instanceof s4 ? "Module" : J(e3) ? "Feature" : e3 instanceof w ? "Point" : e3 instanceof v ? "Polygon" : e3 instanceof m ? "Polyline" : e3 instanceof u ? "Multipoint" : e3 instanceof w2 ? "Extent" : F2(e3) ? "Function" : P2(e3) ? "FeatureSet" : G(e3) ? "FeatureSetCollection" : e3 === k ? "" : "number" == typeof e3 && isNaN(e3) ? "Number" : "Unrecognised Type";
}
function w3(e3) {
  return "string" == typeof e3 || e3 instanceof String;
}
function _(e3) {
  return "boolean" == typeof e3;
}
function Z(e3) {
  return "number" == typeof e3;
}
function L(e3) {
  return "number" == typeof e3 && isFinite(e3) && Math.floor(e3) === e3;
}
function Y(e3) {
  return e3 instanceof Array;
}
function J(e3) {
  return "esri.arcade.Feature" === (e3 == null ? void 0 : e3.arcadeDeclaredClass);
}
function P2(e3) {
  return true === (e3 && e3.declaredRootClass && "esri.arcade.featureset.support.FeatureSet" === e3.declaredRootClass);
}
function G(e3) {
  return true === (e3 && e3.declaredRootClass && "esri.arcade.featureSetCollection" === e3.declaredRootClass);
}
function E(e3) {
  return e3 instanceof t3;
}
function z(e3) {
  return e3 instanceof Date;
}
function V(e3, t5, n5, r3, a2) {
  if (e3.length < t5 || e3.length > n5)
    throw new t2(r3, e.WrongNumberOfParameters, a2);
}
function H(e3) {
  return e3 < 0 ? -Math.round(-e3) : Math.round(e3);
}
function U() {
  let e3 = Date.now();
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (t5) => {
    const n5 = (e3 + 16 * Math.random()) % 16 | 0;
    return e3 = Math.floor(e3 / 16), ("x" === t5 ? n5 : 3 & n5 | 8).toString(16);
  });
}
function q(e3, t5) {
  return isNaN(e3) || null == t5 || "" === t5 ? e3.toString() : (t5 = R(t5, "\u2030", ""), t5 = R(t5, "\xA4", ""), s(e3, { pattern: t5 }));
}
function B(e3, t5) {
  const n5 = DateTime.fromJSDate(e3);
  return null == t5 || "" === t5 ? n5.toISO({ suppressMilliseconds: true }) : n5.toFormat(W(t5), { locale: l(), numberingSystem: "latn" });
}
function W(e3) {
  e3 = e3.replace(/LTS|LT|LL?L?L?|l{1,4}/g, "[$&]");
  let t5 = "";
  const n5 = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
  for (const r3 of e3.match(n5))
    switch (r3) {
      case "D":
        t5 += "d";
        break;
      case "DD":
        t5 += "dd";
        break;
      case "DDD":
        t5 += "o";
        break;
      case "d":
        t5 += "c";
        break;
      case "ddd":
        t5 += "ccc";
        break;
      case "dddd":
        t5 += "cccc";
        break;
      case "M":
        t5 += "L";
        break;
      case "MM":
        t5 += "LL";
        break;
      case "MMM":
        t5 += "LLL";
        break;
      case "MMMM":
        t5 += "LLLL";
        break;
      case "YY":
        t5 += "yy";
        break;
      case "Y":
      case "YYYY":
        t5 += "yyyy";
        break;
      case "Q":
        t5 += "q";
        break;
      case "Z":
        t5 += "ZZ";
        break;
      case "ZZ":
        t5 += "ZZZ";
        break;
      case "S":
        t5 += "'S'";
        break;
      case "SS":
        t5 += "'SS'";
        break;
      case "SSS":
        t5 += "u";
        break;
      case "A":
      case "a":
        t5 += "a";
        break;
      case "m":
      case "mm":
      case "h":
      case "hh":
      case "H":
      case "HH":
      case "s":
      case "ss":
      case "X":
      case "x":
        t5 += r3;
        break;
      default:
        r3.length >= 2 && "[" === r3.slice(0, 1) && "]" === r3.slice(-1) ? t5 += `'${r3.slice(1, -1)}'` : t5 += `'${r3}'`;
    }
  return t5;
}
function $(e3, t5, n5) {
  switch (n5) {
    case ">":
      return e3 > t5;
    case "<":
      return e3 < t5;
    case ">=":
      return e3 >= t5;
    case "<=":
      return e3 <= t5;
  }
  return false;
}
function Q(e3, t5, n5) {
  if (null === e3) {
    if (null === t5 || t5 === k)
      return $(null, null, n5);
    if (Z(t5))
      return $(0, t5, n5);
    if (w3(t5))
      return $(0, re(t5), n5);
    if (_(t5))
      return $(0, re(t5), n5);
    if (z(t5))
      return $(0, t5.getTime(), n5);
  }
  if (e3 === k) {
    if (null === t5 || t5 === k)
      return $(null, null, n5);
    if (Z(t5))
      return $(0, t5, n5);
    if (w3(t5))
      return $(0, re(t5), n5);
    if (_(t5))
      return $(0, re(t5), n5);
    if (z(t5))
      return $(0, t5.getTime(), n5);
  } else if (Z(e3)) {
    if (Z(t5))
      return $(e3, t5, n5);
    if (_(t5))
      return $(e3, re(t5), n5);
    if (null === t5 || t5 === k)
      return $(e3, 0, n5);
    if (w3(t5))
      return $(e3, re(t5), n5);
    if (z(t5))
      return $(e3, t5.getTime(), n5);
  } else if (w3(e3)) {
    if (w3(t5))
      return $(K(e3), K(t5), n5);
    if (z(t5))
      return $(re(e3), t5.getTime(), n5);
    if (Z(t5))
      return $(re(e3), t5, n5);
    if (null === t5 || t5 === k)
      return $(re(e3), 0, n5);
    if (_(t5))
      return $(re(e3), re(t5), n5);
  } else if (z(e3)) {
    if (z(t5))
      return $(e3, t5, n5);
    if (null === t5 || t5 === k)
      return $(e3.getTime(), 0, n5);
    if (Z(t5))
      return $(e3.getTime(), t5, n5);
    if (_(t5))
      return $(e3.getTime(), re(t5), n5);
    if (w3(t5))
      return $(e3.getTime(), re(t5), n5);
  } else if (_(e3)) {
    if (_(t5))
      return $(e3, t5, n5);
    if (Z(t5))
      return $(re(e3), re(t5), n5);
    if (z(t5))
      return $(re(e3), t5.getTime(), n5);
    if (null === t5 || t5 === k)
      return $(re(e3), 0, n5);
    if (w3(t5))
      return $(re(e3), re(t5), n5);
  }
  return !!X(e3, t5) && ("<=" === n5 || ">=" === n5);
}
function X(e3, t5) {
  if (e3 === t5)
    return true;
  if (null === e3 && t5 === k || null === t5 && e3 === k)
    return true;
  if (z(e3) && z(t5))
    return e3.getTime() === t5.getTime();
  if (e3 instanceof h2)
    return e3.equalityTest(t5);
  if (e3 instanceof i3)
    return e3.equalityTest(t5);
  if (e3 instanceof w && t5 instanceof w) {
    const n5 = e3.cache._arcadeCacheId, r3 = t5.cache._arcadeCacheId;
    if (null != n5)
      return n5 === r3;
  }
  if (void 0 !== e3 && void 0 !== t5 && null !== e3 && null !== t5 && "object" == typeof e3 && "object" == typeof t5) {
    if (e3._arcadeCacheId === t5._arcadeCacheId && void 0 !== e3._arcadeCacheId && null !== e3._arcadeCacheId)
      return true;
    if (e3._underlyingGraphic === t5._underlyingGraphic && void 0 !== e3._underlyingGraphic && null !== e3._underlyingGraphic)
      return true;
  }
  return false;
}
function K(e3, n5) {
  if (w3(e3))
    return e3;
  if (null === e3)
    return "";
  if (Z(e3))
    return q(e3, n5);
  if (_(e3))
    return e3.toString();
  if (z(e3))
    return B(e3, n5);
  if (e3 instanceof p)
    return JSON.stringify(e3.toJSON());
  if (Y(e3)) {
    const t5 = [];
    for (let n6 = 0; n6 < e3.length; n6++)
      t5[n6] = ne(e3[n6]);
    return "[" + t5.join(",") + "]";
  }
  if (e3 instanceof t3) {
    const t5 = [];
    for (let n6 = 0; n6 < e3.length(); n6++)
      t5[n6] = ne(e3.get(n6));
    return "[" + t5.join(",") + "]";
  }
  return null !== e3 && "object" == typeof e3 && void 0 !== e3.castToText ? e3.castToText() : F2(e3) ? "object, Function" : e3 === k ? "" : C2(e3) ? "object, Module" : "";
}
function ee(e3) {
  const n5 = [];
  if (!Y(e3))
    return null;
  if (e3 instanceof t3) {
    for (let t5 = 0; t5 < e3.length(); t5++)
      n5[t5] = re(e3.get(t5));
    return n5;
  }
  for (let t5 = 0; t5 < e3.length; t5++)
    n5[t5] = re(e3[t5]);
  return n5;
}
function te(e3, n5, r3 = false) {
  if (w3(e3))
    return e3;
  if (null === e3)
    return "";
  if (Z(e3))
    return q(e3, n5);
  if (_(e3))
    return e3.toString();
  if (z(e3))
    return B(e3, n5);
  if (e3 instanceof p)
    return e3 instanceof w2 ? '{"xmin":' + e3.xmin.toString() + ',"ymin":' + e3.ymin.toString() + "," + (e3.hasZ ? '"zmin":' + e3.zmin.toString() + "," : "") + (e3.hasM ? '"mmin":' + e3.mmin.toString() + "," : "") + '"xmax":' + e3.xmax.toString() + ',"ymax":' + e3.ymax.toString() + "," + (e3.hasZ ? '"zmax":' + e3.zmax.toString() + "," : "") + (e3.hasM ? '"mmax":' + e3.mmax.toString() + "," : "") + '"spatialReference":' + ye(e3.spatialReference) + "}" : ye(e3.toJSON(), (e4, t5) => e4.key === t5.key ? 0 : "spatialReference" === e4.key ? 1 : "spatialReference" === t5.key || e4.key < t5.key ? -1 : e4.key > t5.key ? 1 : 0);
  if (Y(e3)) {
    const t5 = [];
    for (let n6 = 0; n6 < e3.length; n6++)
      t5[n6] = ne(e3[n6], r3);
    return "[" + t5.join(",") + "]";
  }
  if (e3 instanceof t3) {
    const t5 = [];
    for (let n6 = 0; n6 < e3.length(); n6++)
      t5[n6] = ne(e3.get(n6), r3);
    return "[" + t5.join(",") + "]";
  }
  return null !== e3 && "object" == typeof e3 && void 0 !== e3.castToText ? e3.castToText(r3) : F2(e3) ? "object, Function" : e3 === k ? "" : C2(e3) ? "object, Module" : "";
}
function ne(e3, n5 = false) {
  if (null === e3)
    return "null";
  if (_(e3) || Z(e3) || w3(e3))
    return JSON.stringify(e3);
  if (e3 instanceof p)
    return te(e3, null, n5);
  if (e3 instanceof t3)
    return te(e3, null, n5);
  if (e3 instanceof Array)
    return te(e3, null, n5);
  if (e3 instanceof Date)
    return n5 ? JSON.stringify(e3.getTime()) : JSON.stringify(B(e3, ""));
  if (null !== e3 && "object" == typeof e3) {
    if (void 0 !== e3.castToText)
      return e3.castToText(n5);
  } else if (e3 === k)
    return "null";
  return "null";
}
function re(e3, t5) {
  return Z(e3) ? e3 : null === e3 || "" === e3 ? 0 : z(e3) ? NaN : _(e3) ? e3 ? 1 : 0 : Y(e3) || "" === e3 || void 0 === e3 ? NaN : void 0 !== t5 && w3(e3) ? (t5 = R(t5, "\u2030", ""), t5 = R(t5, "\xA4", ""), p2(e3, { pattern: t5 })) : e3 === k ? 0 : Number(e3);
}
function ae(e3) {
  if (z(e3))
    return e3;
  if (w3(e3)) {
    const t5 = oe(e3);
    if (t5)
      return t5.toJSDate();
  }
  return null;
}
function ie(e3) {
  return z(e3) ? DateTime.fromJSDate(e3) : w3(e3) ? oe(e3) : null;
}
function oe(e3) {
  const t5 = / (\d\d)/;
  let n5 = DateTime.fromISO(e3);
  return n5.isValid || t5.test(e3) && (e3 = e3.replace(t5, "T$1"), n5 = DateTime.fromISO(e3), n5.isValid) ? n5 : null;
}
function le(e3) {
  return _(e3) ? e3 : w3(e3) ? "true" === (e3 = e3.toLowerCase()) : !!Z(e3) && (0 !== e3 && !isNaN(e3));
}
function se(e3, t5) {
  return t(e3) ? null : (null !== e3.spatialReference && void 0 !== e3.spatialReference || (e3.spatialReference = t5), e3);
}
function ue(e3) {
  if (null === e3)
    return null;
  if (e3 instanceof w)
    return "NaN" === e3.x || null === e3.x || isNaN(e3.x) ? null : e3;
  if (e3 instanceof v) {
    if (0 === e3.rings.length)
      return null;
    for (const t5 of e3.rings)
      if (t5.length > 0)
        return e3;
    return null;
  }
  if (e3 instanceof m) {
    if (0 === e3.paths.length)
      return null;
    for (const t5 of e3.paths)
      if (t5.length > 0)
        return e3;
    return null;
  }
  return e3 instanceof u ? 0 === e3.points.length ? null : e3 : e3 instanceof w2 ? "NaN" === e3.xmin || null === e3.xmin || isNaN(e3.xmin) ? null : e3 : null;
}
function fe(e3, t5) {
  if (!e3)
    return t5;
  if (!e3.domain)
    return t5;
  let n5 = null;
  if ("string" === e3.field.type || "esriFieldTypeString" === e3.field.type)
    t5 = K(t5);
  else {
    if (null == t5)
      return null;
    if ("" === t5)
      return t5;
    t5 = re(t5);
  }
  for (let r3 = 0; r3 < e3.domain.codedValues.length; r3++) {
    const a2 = e3.domain.codedValues[r3];
    a2.code === t5 && (n5 = a2);
  }
  return null === n5 ? t5 : n5.name;
}
function ce(e3, t5) {
  if (!e3)
    return t5;
  if (!e3.domain)
    return t5;
  let n5 = null;
  t5 = K(t5);
  for (let r3 = 0; r3 < e3.domain.codedValues.length; r3++) {
    const a2 = e3.domain.codedValues[r3];
    a2.name === t5 && (n5 = a2);
  }
  return null === n5 ? t5 : n5.code;
}
function me(e3, t5, n5 = null, r3 = null) {
  if (!t5)
    return null;
  if (!t5.fields)
    return null;
  let a2, i4, o3 = null;
  for (let l5 = 0; l5 < t5.fields.length; l5++) {
    const n6 = t5.fields[l5];
    n6.name.toLowerCase() === e3.toString().toLowerCase() && (o3 = n6);
  }
  if (null === o3)
    throw new t2(null, e.FieldNotFound, null, { key: e3 });
  return null === r3 && n5 && t5.typeIdField && (r3 = n5.hasField(t5.typeIdField) ? n5.field(t5.typeIdField) : null), null != r3 && t5.types.some((e4) => e4.id === r3 && (a2 = e4.domains && e4.domains[o3.name], a2 && "inherited" === a2.type && (a2 = de(o3.name, t5), i4 = true), true)), i4 || a2 || (a2 = de(e3, t5)), { field: o3, domain: a2 };
}
function de(e3, t5) {
  let n5;
  return t5.fields.some((t6) => (t6.name.toLowerCase() === e3.toLowerCase() && (n5 = t6.domain), !!n5)), n5;
}
function ye(e3, t5) {
  t5 || (t5 = {}), "function" == typeof t5 && (t5 = { cmp: t5 });
  const n5 = "boolean" == typeof t5.cycles && t5.cycles, r3 = t5.cmp && (a2 = t5.cmp, function(e4) {
    return function(t6, n6) {
      const r4 = { key: t6, value: e4[t6] }, i5 = { key: n6, value: e4[n6] };
      return a2(r4, i5);
    };
  });
  var a2;
  const i4 = [];
  return function e4(t6) {
    if (t6 && t6.toJSON && "function" == typeof t6.toJSON && (t6 = t6.toJSON()), void 0 === t6)
      return;
    if ("number" == typeof t6)
      return isFinite(t6) ? "" + t6 : "null";
    if ("object" != typeof t6)
      return JSON.stringify(t6);
    let a3, o3;
    if (Array.isArray(t6)) {
      for (o3 = "[", a3 = 0; a3 < t6.length; a3++)
        a3 && (o3 += ","), o3 += e4(t6[a3]) || "null";
      return o3 + "]";
    }
    if (null === t6)
      return "null";
    if (i4.includes(t6)) {
      if (n5)
        return JSON.stringify("__cycle__");
      throw new TypeError("Converting circular structure to JSON");
    }
    const l5 = i4.push(t6) - 1, s6 = Object.keys(t6).sort(r3 && r3(t6));
    for (o3 = "", a3 = 0; a3 < s6.length; a3++) {
      const n6 = s6[a3], r4 = e4(t6[n6]);
      r4 && (o3 && (o3 += ","), o3 += JSON.stringify(n6) + ":" + r4);
    }
    return i4.splice(l5, 1), "{" + o3 + "}";
  }(e3);
}
function pe(e3) {
  if (null === e3)
    return null;
  const t5 = [];
  for (const n5 of e3)
    n5 && n5.arcadeDeclaredClass && "esri.arcade.Feature" === n5.arcadeDeclaredClass ? t5.push(n5.geometry()) : t5.push(n5);
  return t5;
}
function ge(e3, t5) {
  if (!(t5 instanceof w))
    throw new t2(null, e.InvalidParameter, null);
  e3.push(t5.hasZ ? t5.hasM ? [t5.x, t5.y, t5.z, t5.m] : [t5.x, t5.y, t5.z] : [t5.x, t5.y]);
}
function he(e3, t5) {
  if (Y(e3) || E(e3)) {
    let n5 = false, a2 = false, i4 = [], o3 = t5;
    if (Y(e3)) {
      for (const t6 of e3)
        ge(i4, t6);
      i4.length > 0 && (o3 = e3[0].spatialReference, n5 = e3[0].hasZ, a2 = e3[0].hasM);
    } else if (e3 instanceof i3)
      i4 = e3._elements, i4.length > 0 && (n5 = e3._hasZ, a2 = e3._hasM, o3 = e3.get(0).spatialReference);
    else {
      if (!E(e3))
        throw new t2(null, e.InvalidParameter, null);
      for (const t6 of e3.toArray())
        ge(i4, t6);
      i4.length > 0 && (o3 = e3.get(0).spatialReference, n5 = true === e3.get(0).hasZ, a2 = true === e3.get(0).hasM);
    }
    if (0 === i4.length)
      return null;
    return h(i4, a2, n5) || (i4 = i4.slice(0).reverse()), new v({ rings: [i4], spatialReference: o3, hasZ: n5, hasM: a2 });
  }
  return e3;
}
function Se(e3, t5) {
  if (Y(e3) || E(e3)) {
    let n5 = false, a2 = false, i4 = [], o3 = t5;
    if (Y(e3)) {
      for (const t6 of e3)
        ge(i4, t6);
      i4.length > 0 && (o3 = e3[0].spatialReference, n5 = true === e3[0].hasZ, a2 = true === e3[0].hasM);
    } else if (e3 instanceof i3)
      i4 = e3._elements, i4.length > 0 && (n5 = e3._hasZ, a2 = e3._hasM, o3 = e3.get(0).spatialReference);
    else if (E(e3)) {
      for (const t6 of e3.toArray())
        ge(i4, t6);
      i4.length > 0 && (o3 = e3.get(0).spatialReference, n5 = true === e3.get(0).hasZ, a2 = true === e3.get(0).hasM);
    }
    return 0 === i4.length ? null : new m({ paths: [i4], spatialReference: o3, hasZ: n5, hasM: a2 });
  }
  return e3;
}
function be(e3, t5) {
  if (Y(e3) || E(e3)) {
    let n5 = false, a2 = false, i4 = [], l5 = t5;
    if (Y(e3)) {
      for (const t6 of e3)
        ge(i4, t6);
      i4.length > 0 && (l5 = e3[0].spatialReference, n5 = true === e3[0].hasZ, a2 = true === e3[0].hasM);
    } else if (e3 instanceof i3)
      i4 = e3._elements, i4.length > 0 && (n5 = e3._hasZ, a2 = e3._hasM, l5 = e3.get(0).spatialReference);
    else if (E(e3)) {
      for (const t6 of e3.toArray())
        ge(i4, t6);
      i4.length > 0 && (l5 = e3.get(0).spatialReference, n5 = true === e3.get(0).hasZ, a2 = true === e3.get(0).hasM);
    }
    return 0 === i4.length ? null : new u({ points: i4, spatialReference: l5, hasZ: n5, hasM: a2 });
  }
  return e3;
}
function xe(e3, n5 = false) {
  const r3 = [];
  if (null === e3)
    return r3;
  if (true === Y(e3)) {
    for (let t5 = 0; t5 < e3.length; t5++) {
      const a2 = K(e3[t5]);
      "" === a2 && true !== n5 || r3.push(a2);
    }
    return r3;
  }
  if (e3 instanceof t3) {
    for (let t5 = 0; t5 < e3.length(); t5++) {
      const a2 = K(e3.get(t5));
      "" === a2 && true !== n5 || r3.push(a2);
    }
    return r3;
  }
  if (I(e3)) {
    const t5 = K(e3);
    return "" === t5 && true !== n5 || r3.push(t5), r3;
  }
  return [];
}
var Te = 0;
function Me(e3) {
  return Te++, Te % 100 == 0 ? (Te = 0, new Promise((t5) => {
    setTimeout(() => {
      t5(e3);
    }, 0);
  })) : e3;
}
function Ne(e3, t5, n5) {
  switch (n5) {
    case "&":
      return e3 & t5;
    case "|":
      return e3 | t5;
    case "^":
      return e3 ^ t5;
    case "<<":
      return e3 << t5;
    case ">>":
      return e3 >> t5;
    case ">>>":
      return e3 >>> t5;
  }
}
function De(e3, n5 = null) {
  return null == e3 ? null : _(e3) || Z(e3) || w3(e3) ? e3 : e3 instanceof p ? true === (n5 == null ? void 0 : n5.keepGeometryType) ? e3 : e3.toJSON() : e3 instanceof t3 ? e3.toArray().map((e4) => De(e4, n5)) : e3 instanceof Array ? e3.map((e4) => De(e4, n5)) : e3 instanceof Date ? e3 : null !== e3 && "object" == typeof e3 && void 0 !== e3.castAsJson ? e3.castAsJson(n5) : null;
}
async function ke(e3, t5, n5, r3, a2) {
  const i4 = await je(e3, t5, n5);
  a2[r3] = i4;
}
async function je(e3, n5 = null, r3 = null) {
  if (e3 instanceof t3 && (e3 = e3.toArray()), null == e3)
    return null;
  if (I(e3) || e3 instanceof p || e3 instanceof Date)
    return De(e3, r3);
  if (e3 instanceof Array) {
    const t5 = [], a2 = [];
    for (const o3 of e3)
      null === o3 || I(o3) || o3 instanceof p || o3 instanceof Date ? a2.push(De(o3, r3)) : (a2.push(null), t5.push(ke(o3, n5, r3, a2.length - 1, a2)));
    return t5.length > 0 && await Promise.all(t5), a2;
  }
  return null !== e3 && "object" == typeof e3 && void 0 !== e3.castAsJsonAsync ? e3.castAsJsonAsync(n5, r3) : null;
}
function Ae(e3, t5, n5) {
  const r3 = e3.fullSchema();
  if (null === r3)
    return null;
  if (!r3.fields)
    return null;
  return me(t5, r3, e3, n5);
}
function Re(e3) {
  const t5 = e3.fullSchema();
  return null === t5 ? null : t5.fields && t5.typeIdField ? { subtypeField: t5.typeIdField, subtypes: t5.types ? t5.types.map((e4) => ({ name: e4.name, code: e4.id })) : [] } : null;
}
function Fe(e3, t5, n5, r3) {
  const a2 = e3.fullSchema();
  if (null === a2)
    return null;
  if (!a2.fields)
    return null;
  const i4 = me(t5, a2, e3, r3);
  if (void 0 === n5)
    try {
      n5 = e3.field(t5);
    } catch (o3) {
      return null;
    }
  return fe(i4, n5);
}
function Ce(e3, t5, n5, r3) {
  const a2 = e3.fullSchema();
  if (null === a2)
    return null;
  if (!a2.fields)
    return null;
  if (void 0 === n5) {
    try {
      n5 = e3.field(t5);
    } catch (i4) {
      return null;
    }
    return n5;
  }
  return ce(me(t5, a2, e3, r3), n5);
}
function Ie(e3) {
  const t5 = e3.fullSchema();
  if (null === t5)
    return null;
  if (!t5.fields)
    return null;
  const n5 = [];
  for (const r3 of t5.fields)
    n5.push(o2(r3));
  return { objectIdField: t5.objectIdField, globalIdField: t5.globalIdField, geometryType: void 0 === v2[t5.geometryType] ? "" : v2[t5.geometryType], fields: n5 };
}
var ve = Object.freeze(Object.defineProperty({ __proto__: null, ReturnResultE: T, ImplicitResultE: M, ImplicitResult: N, ReturnResult: D2, voidOperation: k, breakResult: j, continueResult: A, multiReplace: R, isFunctionParameter: F2, isModule: C2, isSimpleType: I, defaultUndefined: v3, getType: O, isString: w3, isBoolean: _, isNumber: Z, isInteger: L, isArray: Y, isFeature: J, isFeatureSet: P2, isFeatureSetCollection: G, isImmutableArray: E, isDate: z, pcCheck: V, absRound: H, generateUUID: U, formatNumber: q, formatDate: B, standardiseDateFormat: W, greaterThanLessThan: Q, equalityTest: X, toString: K, toNumberArray: ee, toStringExplicit: te, toNumber: re, toDate: ae, toDateTime: ie, toBoolean: le, fixSpatialReference: se, fixNullGeometry: ue, getDomainValue: fe, getDomainCode: ce, getDomain: me, stableStringify: ye, autoCastFeatureToGeometry: pe, autoCastArrayOfPointsToPolygon: he, autoCastArrayOfPointsToPolyline: Se, autoCastArrayOfPointsToMultiPoint: be, toStringArray: xe, tick: Me, binaryOperator: Ne, castAsJson: De, castAsJsonAsync: je, featureFullDomain: Ae, featureSubtypes: Re, featureDomainValueLookup: Fe, featureDomainCodeLookup: Ce, featureSchema: Ie }, Symbol.toStringTag, { value: "Module" }));

export {
  e,
  t2 as t,
  s2 as s,
  c,
  i,
  u2 as u,
  l2 as l,
  p3 as p,
  t3 as t2,
  r2 as r,
  n2 as n,
  e2,
  s3 as s2,
  i3 as i2,
  h2 as h,
  DateTime,
  t4 as t3,
  i2 as i3,
  n3 as n2,
  o2 as o,
  l3 as l2,
  y2 as y,
  c2,
  m2 as m,
  f,
  d2 as d,
  F,
  S,
  v2 as v,
  P,
  b,
  D,
  s4 as s3,
  N,
  D2,
  k,
  j,
  A,
  R,
  F2,
  I,
  v3 as v2,
  O,
  w3 as w,
  _,
  Z,
  L,
  Y,
  J,
  P2,
  G,
  E,
  z,
  V,
  H,
  U,
  W,
  Q,
  X,
  K,
  ee,
  te,
  re,
  ae,
  ie,
  le,
  se,
  ue,
  fe,
  ce,
  me,
  pe,
  he,
  Se,
  be,
  xe,
  Me,
  Ne,
  De,
  je,
  Ae,
  Re,
  Fe,
  Ce,
  Ie,
  ve
};
//# sourceMappingURL=chunk-GDBM63TX.js.map
