import {
  g,
  r as r2
} from "./chunk-OAXPH6DL.js";
import {
  m
} from "./chunk-C5H57NTD.js";
import {
  w2 as w
} from "./chunk-UWG37XSU.js";
import {
  R
} from "./chunk-LNZAOBFW.js";
import {
  s as s2
} from "./chunk-M5VHU5LK.js";
import {
  f
} from "./chunk-MJXQTGI2.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";
import {
  has
} from "./chunk-HVKDYDPP.js";
import {
  t as t2
} from "./chunk-6QC7MLLS.js";
import {
  e,
  r,
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/layers/support/rasterFunctions/vectorFieldUtils.js
var s3 = /* @__PURE__ */ new Map();
s3.set("meter-per-second", 1), s3.set("kilometer-per-hour", 0.277778), s3.set("knots", 0.514444), s3.set("feet-per-second", 0.3048), s3.set("mile-per-hour", 0.44704);
var a = 180 / Math.PI;
var h = 5;
var c = new s2({ esriMetersPerSecond: "meter-per-second", esriKilometersPerHour: "kilometer-per-hour", esriKnots: "knots", esriFeetPerSecond: "feet-per-second", esriMilesPerHour: "mile-per-hour" });
function l(t3, e2) {
  return s3.get(t3) / s3.get(e2) || 1;
}
function u(t3) {
  return (450 - t3) % 360;
}
function f2(t3, e2 = "geographic") {
  const [n, r3] = t3, o = Math.sqrt(n * n + r3 * r3);
  let i = Math.atan2(r3, n) * a;
  return i = (360 + i) % 360, "geographic" === e2 && (i = u(i)), [o, i];
}
function p(t3, e2 = "geographic") {
  let n = t3[1];
  "geographic" === e2 && (n = u(n)), n %= 360;
  const r3 = t3[0];
  return [r3 * Math.cos(n / a), r3 * Math.sin(n / a)];
}
function m2(t3, r3, o, s5 = "geographic") {
  if (!r2(t3) || t(o))
    return t3;
  const a2 = "vector-magdir" === r3 ? t3.clone() : e(d(t3, r3)), h3 = a2.pixels[1];
  for (let e2 = 0; e2 < h3.length; e2++)
    h3[e2] = "geographic" === s5 ? (h3[e2] + o[e2] + 270) % 360 : (h3[e2] + 360 - o[e2]) % 360;
  return "vector-magdir" === r3 ? a2 : d(a2, "vector-magdir");
}
function d(t3, e2, n = "geographic", r3 = 1) {
  if (!r2(t3))
    return t3;
  const { pixels: s5, width: a2, height: h3 } = t3, c3 = a2 * h3, l2 = s5[0], u3 = s5[1], m4 = t3.pixelType.startsWith("f") ? t3.pixelType : "f32", d3 = g.createEmptyBand(m4, c3), g4 = g.createEmptyBand(m4, c3);
  let x3 = 0;
  for (let o = 0; o < h3; o++)
    for (let t4 = 0; t4 < a2; t4++)
      "vector-uv" === e2 ? ([d3[x3], g4[x3]] = f2([l2[x3], u3[x3]], n), d3[x3] *= r3) : ([d3[x3], g4[x3]] = p([l2[x3], u3[x3]], n), d3[x3] *= r3, g4[x3] *= r3), x3++;
  const M3 = new g({ pixelType: m4, width: t3.width, height: t3.height, mask: t3.mask, validPixelCount: t3.validPixelCount, maskIsAlpha: t3.maskIsAlpha, pixels: [d3, g4] });
  return M3.updateStatistics(), M3;
}
function g2(t3, e2, n = 1) {
  if (1 === n || !r2(t3))
    return t3;
  const r3 = t3.clone(), { pixels: o, width: s5, height: a2 } = r3, h3 = o[0], c3 = o[1];
  let l2 = 0;
  for (let i = 0; i < a2; i++)
    for (let t4 = 0; t4 < s5; t4++)
      "vector-uv" === e2 ? (h3[l2] *= n, c3[l2] *= n) : h3[l2] *= n, l2++;
  return r3.updateStatistics(), r3;
}
function x(t3, n, r3, o, i) {
  if (t(i) || !i.spatialReference.equals(t3.spatialReference))
    return { extent: t3, width: Math.round(n / o), height: Math.round(r3 / o), resolution: t3.width / n };
  const s5 = i.xmin, a2 = i.ymax, h3 = (t3.xmax - t3.xmin) / n * o, c3 = (t3.ymax - t3.ymin) / r3 * o, l2 = (h3 + c3) / 2;
  return t3.xmin = s5 + Math.floor((t3.xmin - s5) / h3) * h3, t3.xmax = s5 + Math.ceil((t3.xmax - s5) / h3) * h3, t3.ymin = a2 + Math.floor((t3.ymin - a2) / c3) * c3, t3.ymax = a2 + Math.ceil((t3.ymax - a2) / c3) * c3, { extent: t3, width: Math.round(t3.width / h3), height: Math.round(t3.height / c3), resolution: l2 };
}
var M = k(0, 0, 0);
function k(t3 = 0, e2 = 0, n = Math.PI, r3 = true) {
  r3 && (n = (2 * Math.PI - n) % (2 * Math.PI));
  const o = r3 ? -1 : 1, i = 13 * o, s5 = -7 * o, a2 = -2 * o, h3 = -16 * o, c3 = 21.75, [l2, u3] = y(0, e2 + i, n, c3), [f4, p3] = y(t3 - 5.5, e2 + s5, n, c3), [m4, d3] = y(t3 + 5.5, e2 + s5, n, c3), [g4, x3] = y(t3 - 1.5, e2 + a2, n, c3), [M3, k2] = y(t3 + 1.5, e2 + a2, n, c3), [w4, P2] = y(t3 - 1.5, e2 + h3, n, c3), [b2, v2] = y(t3 + 1.5, e2 + h3, n, c3);
  return [l2, u3, f4, p3, g4, x3, M3, k2, m4, d3, w4, P2, b2, v2];
}
function w2(t3 = 0, e2 = Math.PI, n = true) {
  n && (e2 = (2 * Math.PI - e2) % (2 * Math.PI));
  const r3 = 10, o = n ? -1 : 1, i = 5 * o, s5 = 20 * o, a2 = 25 * o, c3 = 45, l2 = 0, u3 = 0, f4 = 2, p3 = 0, m4 = f4 * o, d3 = n ? 1 : -1, g4 = r3 / 2 * d3;
  let [x3, M3] = [l2 + g4, u3 - s5], [k2, w4] = [x3 + f4 * d3, M3], [P2, b2] = [k2 - p3 * d3, w4 + m4], [v2, I2] = [l2 - g4, u3 - a2], [A2, _2] = [v2 + p3 * d3, I2 - m4], U2 = Math.ceil(t3 / h), S2 = Math.floor(U2 / 10);
  U2 -= 8 * S2;
  const D2 = [], F2 = [];
  for (let h3 = 0; h3 < U2 / 2; h3++, S2--) {
    S2 <= 0 && U2 % 2 == 1 && h3 === (U2 - 1) / 2 && (v2 = l2, A2 = v2 + p3 * d3, I2 = (I2 + M3) / 2, _2 = I2 - m4);
    const [t4, n2] = y(v2, I2, e2, c3);
    if (S2 > 0) {
      const [r4, o2] = y(k2, I2, e2, c3), [i2, s6] = y(x3, M3, e2, c3);
      D2.push(r4), D2.push(o2), D2.push(t4), D2.push(n2), D2.push(i2), D2.push(s6);
    } else {
      const [r4, o2] = y(k2, w4, e2, c3), [i2, s6] = y(P2, b2, e2, c3), [a3, h4] = y(A2, _2, e2, c3);
      F2.push(t4), F2.push(n2), F2.push(a3), F2.push(h4), F2.push(i2), F2.push(s6), F2.push(r4), F2.push(o2);
    }
    I2 += i, M3 += i, w4 += i, b2 += i, _2 += i;
  }
  const [j2, N] = y(l2 + g4, u3 + s5, e2, c3), J = (r3 / 2 + f4) * d3, [O, q] = y(l2 + J, u3 + s5, e2, c3), [B, E] = y(l2 + g4, u3 - a2, e2, c3), [T, C] = y(l2 + J, u3 - a2, e2, c3);
  return { pennants: D2, barbs: F2, shaft: [j2, N, O, q, B, E, T, C] };
}
function y(t3, e2, n, r3 = 1) {
  const o = Math.sqrt(t3 * t3 + e2 * e2) / r3, i = (2 * Math.PI + Math.atan2(e2, t3)) % (2 * Math.PI);
  return [o, (2 * Math.PI + i - n) % (2 * Math.PI)];
}
var P = [0, 1, 3, 6, 10, 16, 21, 27, 33, 40, 47, 55, 63];
var b = [0, 0.5, 1, 1.5, 2];
var v = [0, 0.25, 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4];
function I(t3, e2, n, r3) {
  const o = l(r3 || "knots", n);
  let i;
  for (i = 1; i < e2.length; i++)
    if (i === e2.length - 1) {
      if (t3 < e2[i] * o)
        break;
    } else if (t3 <= e2[i] * o)
      break;
  return Math.min(i - 1, e2.length - 2);
}
function A(t3, e2, n, r3, o) {
  let i = 0;
  switch (e2) {
    case "beaufort_kn":
      i = I(t3, P, "knots", n);
      break;
    case "beaufort_km":
      i = I(t3, P, "kilometer-per-hour", n);
      break;
    case "beaufort_ft":
      i = I(t3, P, "feet-per-second", n);
      break;
    case "beaufort_m":
      i = I(t3, P, "meter-per-second", n);
      break;
    case "classified_arrow":
      i = I(t3, o != null ? o : [], r3, n);
      break;
    case "ocean_current_m":
      i = I(t3, b, "meter-per-second", n);
      break;
    case "ocean_current_kn":
      i = I(t3, v, "knots", n);
  }
  return i;
}
function _(t3, e2) {
  const { style: n, inputUnit: o, outputUnit: i, breakValues: s5 } = e2, a2 = c.fromJSON(o), h3 = c.fromJSON(i), l2 = 7 * 6, u3 = 15;
  let f4 = 0, p3 = 0;
  const { width: m4, height: d3, mask: g4 } = t3, x3 = t3.pixels[0], w4 = t3.pixels[1], y3 = r(g4) ? g4.filter((t4) => t4 > 0).length : m4 * d3, P2 = new Float32Array(y3 * l2), b2 = new Uint32Array(u3 * y3), v2 = e2.invertDirection ? k(0, 0, 0, false) : M;
  for (let r3 = 0; r3 < d3; r3++)
    for (let t4 = 0; t4 < m4; t4++) {
      const e3 = r3 * m4 + t4;
      if (!g4 || g4[r3 * m4 + t4]) {
        const o2 = (w4[e3] + 360) % 360 / 180 * Math.PI, i2 = A(x3[e3], n, a2, h3, s5);
        for (let n2 = 0; n2 < v2.length; n2 += 2)
          P2[f4++] = (t4 + 0.5) / m4, P2[f4++] = (r3 + 0.5) / d3, P2[f4++] = v2[n2], P2[f4++] = v2[n2 + 1] + o2, P2[f4++] = i2, P2[f4++] = x3[e3];
        const c3 = 7 * (f4 / l2 - 1);
        b2[p3++] = c3, b2[p3++] = c3 + 1, b2[p3++] = c3 + 2, b2[p3++] = c3 + 0, b2[p3++] = c3 + 4, b2[p3++] = c3 + 3, b2[p3++] = c3 + 0, b2[p3++] = c3 + 2, b2[p3++] = c3 + 3, b2[p3++] = c3 + 2, b2[p3++] = c3 + 5, b2[p3++] = c3 + 3, b2[p3++] = c3 + 5, b2[p3++] = c3 + 6, b2[p3++] = c3 + 3;
      }
    }
  return { vertexData: P2, indexData: b2 };
}
var U = [];
function S(t3, e2) {
  if (0 === U.length)
    for (let h3 = 0; h3 < 30; h3++)
      U.push(w2(5 * h3, 0, !e2.invertDirection));
  const n = l(c.fromJSON(e2.inputUnit), "knots"), { width: r3, height: o, mask: i } = t3, s5 = t3.pixels[0], a2 = t3.pixels[1], u3 = 6, f4 = [], p3 = [];
  let m4 = 0, d3 = 0;
  for (let c3 = 0; c3 < o; c3++)
    for (let t4 = 0; t4 < r3; t4++) {
      const e3 = c3 * r3 + t4, l2 = s5[e3] * n;
      if ((!i || i[c3 * r3 + t4]) && l2 >= h) {
        const n2 = (a2[e3] + 360) % 360 / 180 * Math.PI, { pennants: i2, barbs: s6, shaft: h3 } = U[Math.min(Math.floor(l2 / 5), 29)];
        if (i2.length + s6.length === 0)
          continue;
        let g4 = f4.length / u3;
        const x3 = (t4 + 0.5) / r3, M3 = (c3 + 0.5) / o;
        for (let t5 = 0; t5 < i2.length; t5 += 2)
          f4[m4++] = x3, f4[m4++] = M3, f4[m4++] = i2[t5], f4[m4++] = i2[t5 + 1] + n2, f4[m4++] = 0, f4[m4++] = l2;
        for (let t5 = 0; t5 < s6.length; t5 += 2)
          f4[m4++] = x3, f4[m4++] = M3, f4[m4++] = s6[t5], f4[m4++] = s6[t5 + 1] + n2, f4[m4++] = 0, f4[m4++] = l2;
        for (let t5 = 0; t5 < h3.length; t5 += 2)
          f4[m4++] = x3, f4[m4++] = M3, f4[m4++] = h3[t5], f4[m4++] = h3[t5 + 1] + n2, f4[m4++] = 0, f4[m4++] = l2;
        for (let t5 = 0; t5 < i2.length / 6; t5++)
          p3[d3++] = g4, p3[d3++] = g4 + 1, p3[d3++] = g4 + 2, g4 += 3;
        for (let t5 = 0; t5 < s6.length / 8; t5++)
          p3[d3++] = g4, p3[d3++] = g4 + 1, p3[d3++] = g4 + 2, p3[d3++] = g4 + 1, p3[d3++] = g4 + 2, p3[d3++] = g4 + 3, g4 += 4;
        p3[d3++] = g4 + 0, p3[d3++] = g4 + 1, p3[d3++] = g4 + 2, p3[d3++] = g4 + 1, p3[d3++] = g4 + 3, p3[d3++] = g4 + 2, g4 += 4;
      }
    }
  return { vertexData: new Float32Array(f4), indexData: new Uint32Array(p3) };
}
function D(t3, e2) {
  const n = 4 * 6;
  let r3 = 0, o = 0;
  const { width: i, height: s5, mask: a2 } = t3, u3 = t3.pixels[0], f4 = [], p3 = [], m4 = l(c.fromJSON(e2.inputUnit), "knots"), d3 = "wind_speed" === e2.style ? h : Number.MAX_VALUE;
  for (let h3 = 0; h3 < s5; h3++)
    for (let t4 = 0; t4 < i; t4++) {
      const e3 = u3[h3 * i + t4] * m4;
      if ((!a2 || a2[h3 * i + t4]) && e3 < d3) {
        for (let n2 = 0; n2 < 4; n2++)
          f4[r3++] = (t4 + 0.5) / i, f4[r3++] = (h3 + 0.5) / s5, f4[r3++] = n2 < 2 ? -0.5 : 0.5, f4[r3++] = n2 % 2 == 0 ? -0.5 : 0.5, f4[r3++] = 0, f4[r3++] = e3;
        const a3 = 4 * (r3 / n - 1);
        p3[o++] = a3, p3[o++] = a3 + 1, p3[o++] = a3 + 2, p3[o++] = a3 + 1, p3[o++] = a3 + 2, p3[o++] = a3 + 3;
      }
    }
  return { vertexData: new Float32Array(f4), indexData: new Uint32Array(p3) };
}
function F(t3, e2) {
  return "simple_scalar" === e2.style ? D(t3, e2) : "wind_speed" === e2.style ? S(t3, e2) : _(t3, e2);
}
function j(t3, e2, n, r3 = [0, 0], i = 0.5) {
  const { width: s5, height: a2, mask: h3 } = t3, [c3, l2] = t3.pixels, [u3, m4] = r3, d3 = Math.round((s5 - u3) / n), g4 = Math.round((a2 - m4) / n), x3 = d3 * g4, M3 = new Float32Array(x3), k2 = new Float32Array(x3), w4 = new Uint8Array(x3), y3 = "vector-uv" === e2;
  for (let o = 0; o < g4; o++)
    for (let t4 = 0; t4 < d3; t4++) {
      let e3 = 0;
      const r4 = o * d3 + t4, g5 = Math.max(0, o * n + m4), x4 = Math.max(0, t4 * n + u3), P3 = Math.min(a2, g5 + n), b2 = Math.min(s5, x4 + n);
      for (let t5 = g5; t5 < P3; t5++)
        for (let n2 = x4; n2 < b2; n2++) {
          const o2 = t5 * s5 + n2;
          if (!h3 || h3[o2]) {
            e3++;
            const t6 = y3 ? [c3[o2], l2[o2]] : [c3[o2], (360 + l2[o2]) % 360], [n3, i2] = y3 ? t6 : p(t6);
            M3[r4] += n3, k2[r4] += i2;
          }
        }
      if (e3 >= (P3 - g5) * (b2 - x4) * (1 - i)) {
        w4[r4] = 1;
        const [t5, n2] = f2([M3[r4] / e3, k2[r4] / e3]);
        M3[r4] = t5, k2[r4] = n2;
      } else
        w4[r4] = 0, M3[r4] = 0, k2[r4] = 0;
    }
  const P2 = new g({ width: d3, height: g4, pixels: [M3, k2], mask: w4 });
  return P2.updateStatistics(), P2;
}

// node_modules/@arcgis/core/views/2d/engine/flow/dataUtils.js
var s4 = s.getLogger("esri.views.2d.engine.flow.dataUtils");
var c2 = 10;
async function f3(t3, e2, n, r3) {
  const i = performance.now(), l2 = u2(e2, n), a2 = performance.now(), f4 = m3(e2, l2, n.width, n.height), h3 = performance.now(), d3 = w3(f4, true), y3 = performance.now(), x3 = "Streamlines" === t3 ? p2(d3, c2) : g3(d3), M3 = performance.now();
  return has("esri-2d-profiler") && (s4.info("I.1", "_createFlowFieldFromData (ms)", Math.round(a2 - i)), s4.info("I.2", "_getStreamlines (ms)", Math.round(h3 - a2)), s4.info("I.3", "createAnimatedLinesData (ms)", Math.round(y3 - h3)), s4.info("I.4", "create{Streamlines|Particles}Mesh (ms)", Math.round(M3 - y3)), s4.info("I.5", "createFlowMesh (ms)", Math.round(M3 - i)), s4.info("I.6", "Mesh size (bytes)", x3.vertexData.buffer.byteLength + x3.indexData.buffer.byteLength)), await Promise.resolve(), f(r3), x3;
}
function u2(t3, e2) {
  const n = d2(e2.data, e2.width, e2.height, t3.smoothing);
  if (t3.interpolate) {
    return (t4, r3) => {
      const o = Math.floor(t4), i = Math.floor(r3);
      if (o < 0 || o >= e2.width)
        return [0, 0];
      if (i < 0 || i >= e2.height)
        return [0, 0];
      const l2 = t4 - o, a2 = r3 - i, s5 = o, c3 = i, f4 = o < e2.width - 1 ? o + 1 : o, u3 = i < e2.height - 1 ? i + 1 : i, h3 = n[2 * (c3 * e2.width + s5)], m4 = n[2 * (c3 * e2.width + f4)], d3 = n[2 * (u3 * e2.width + s5)], w4 = n[2 * (u3 * e2.width + f4)], p3 = n[2 * (c3 * e2.width + s5) + 1], g4 = n[2 * (c3 * e2.width + f4) + 1];
      return [(h3 * (1 - a2) + d3 * a2) * (1 - l2) + (m4 * (1 - a2) + w4 * a2) * l2, (p3 * (1 - a2) + n[2 * (u3 * e2.width + s5) + 1] * a2) * (1 - l2) + (g4 * (1 - a2) + n[2 * (u3 * e2.width + f4) + 1] * a2) * l2];
    };
  }
  return (t4, r3) => {
    const o = Math.round(t4), i = Math.round(r3);
    return o < 0 || o >= e2.width || i < 0 || i >= e2.height ? [0, 0] : [n[2 * (i * e2.width + o) + 0], n[2 * (i * e2.width + o) + 1]];
  };
}
function h2(t3, e2, n, r3, o, i, l2, a2, s5) {
  const c3 = [];
  let f4 = n, u3 = r3, h3 = 0, [m4, d3] = e2(f4, u3);
  m4 *= t3.velocityScale, d3 *= t3.velocityScale;
  const w4 = Math.sqrt(m4 * m4 + d3 * d3);
  let p3, g4;
  c3.push({ x: f4, y: u3, t: h3, speed: w4 });
  for (let y3 = 0; y3 < t3.verticesPerLine; y3++) {
    let [n2, r4] = e2(f4, u3);
    n2 *= t3.velocityScale, r4 *= t3.velocityScale;
    const m5 = Math.sqrt(n2 * n2 + r4 * r4);
    if (m5 < t3.minSpeedThreshold)
      return c3;
    const d4 = n2 / m5, w5 = r4 / m5;
    f4 += d4 * t3.segmentLength, u3 += w5 * t3.segmentLength;
    if (h3 += t3.segmentLength / m5, Math.acos(d4 * p3 + w5 * g4) > t3.maxTurnAngle)
      return c3;
    if (t3.collisions) {
      const t4 = Math.round(f4 * s5), e3 = Math.round(u3 * s5);
      if (t4 < 0 || t4 > l2 - 1 || e3 < 0 || e3 > a2 - 1)
        return c3;
      const n3 = i[e3 * l2 + t4];
      if (-1 !== n3 && n3 !== o)
        return c3;
      i[e3 * l2 + t4] = o;
    }
    c3.push({ x: f4, y: u3, t: h3, speed: m5 }), p3 = d4, g4 = w5;
  }
  return c3;
}
function m3(t3, e2, n, r3) {
  const o = [], l2 = new t2(), a2 = 1 / Math.max(t3.lineCollisionWidth, 1), s5 = Math.round(n * a2), c3 = Math.round(r3 * a2), f4 = new Int32Array(s5 * c3);
  for (let i = 0; i < f4.length; i++)
    f4[i] = -1;
  const u3 = [];
  for (let i = 0; i < r3; i += t3.lineSpacing)
    for (let e3 = 0; e3 < n; e3 += t3.lineSpacing)
      u3.push({ x: e3, y: i, sort: l2.getFloat() });
  u3.sort((t4, e3) => t4.sort - e3.sort);
  for (const { x: i, y: m4 } of u3)
    if (l2.getFloat() < t3.density) {
      const n2 = h2(t3, e2, i, m4, o.length, f4, s5, c3, a2);
      if (n2.length < 2)
        continue;
      o.push(n2);
    }
  return o;
}
function d2(t3, e2, n, r3) {
  if (0 === r3)
    return t3;
  const o = Math.round(3 * r3), i = new Array(2 * o + 1);
  let l2 = 0;
  for (let c3 = -o; c3 <= o; c3++) {
    const t4 = Math.exp(-c3 * c3 / (r3 * r3));
    i[c3 + o] = t4, l2 += t4;
  }
  for (let c3 = -o; c3 <= o; c3++)
    i[c3 + o] /= l2;
  const a2 = new Float32Array(t3.length);
  for (let c3 = 0; c3 < n; c3++)
    for (let n2 = 0; n2 < e2; n2++) {
      let r4 = 0, l3 = 0;
      for (let a3 = -o; a3 <= o; a3++) {
        if (n2 + a3 < 0 || n2 + a3 >= e2)
          continue;
        const s6 = i[a3 + o];
        r4 += s6 * t3[2 * (c3 * e2 + (n2 + a3)) + 0], l3 += s6 * t3[2 * (c3 * e2 + (n2 + a3)) + 1];
      }
      a2[2 * (c3 * e2 + n2) + 0] = r4, a2[2 * (c3 * e2 + n2) + 1] = l3;
    }
  const s5 = new Float32Array(t3.length);
  for (let c3 = 0; c3 < e2; c3++)
    for (let t4 = 0; t4 < n; t4++) {
      let r4 = 0, l3 = 0;
      for (let s6 = -o; s6 <= o; s6++) {
        if (t4 + s6 < 0 || t4 + s6 >= n)
          continue;
        const f4 = i[s6 + o];
        r4 += f4 * a2[2 * ((t4 + s6) * e2 + c3) + 0], l3 += f4 * a2[2 * ((t4 + s6) * e2 + c3) + 1];
      }
      s5[2 * (t4 * e2 + c3) + 0] = r4, s5[2 * (t4 * e2 + c3) + 1] = l3;
    }
  return s5;
}
function w3(t3, e2) {
  const n = new t2(), r3 = t3.reduce((t4, e3) => t4 + e3.length, 0), o = new Float32Array(4 * r3), l2 = new Array(t3.length);
  let a2 = 0, s5 = 0;
  for (const i of t3) {
    const t4 = a2;
    for (const e3 of i)
      o[4 * a2 + 0] = e3.x, o[4 * a2 + 1] = e3.y, o[4 * a2 + 2] = e3.t, o[4 * a2 + 3] = e3.speed, a2++;
    l2[s5++] = { startVertex: t4, numberOfVertices: i.length, totalTime: i[i.length - 1].t, timeSeed: e2 ? n.getFloat() : 0 };
  }
  return { lineVertices: o, lineDescriptors: l2 };
}
function p2(t3, e2) {
  const n = 9, { lineVertices: r3, lineDescriptors: o } = t3;
  let i = 0, l2 = 0;
  for (const m4 of o) {
    i += 2 * m4.numberOfVertices;
    l2 += 6 * (m4.numberOfVertices - 1);
  }
  const a2 = new Float32Array(i * n), s5 = new Uint32Array(l2);
  let c3 = 0, f4 = 0;
  function u3() {
    s5[f4++] = c3 - 2, s5[f4++] = c3, s5[f4++] = c3 - 1, s5[f4++] = c3, s5[f4++] = c3 + 1, s5[f4++] = c3 - 1;
  }
  function h3(t4, e3, r4, o2, i2, l3, s6, f5) {
    const u4 = c3 * n;
    let h4 = 0;
    a2[u4 + h4++] = t4, a2[u4 + h4++] = e3, a2[u4 + h4++] = 1, a2[u4 + h4++] = r4, a2[u4 + h4++] = l3, a2[u4 + h4++] = s6, a2[u4 + h4++] = o2 / 2, a2[u4 + h4++] = i2 / 2, a2[u4 + h4++] = f5, c3++, a2[u4 + h4++] = t4, a2[u4 + h4++] = e3, a2[u4 + h4++] = -1, a2[u4 + h4++] = r4, a2[u4 + h4++] = l3, a2[u4 + h4++] = s6, a2[u4 + h4++] = -o2 / 2, a2[u4 + h4++] = -i2 / 2, a2[u4 + h4++] = f5, c3++;
  }
  for (const m4 of o) {
    const { totalTime: t4, timeSeed: n2 } = m4;
    let o2 = null, i2 = null, l3 = null, a3 = null, s6 = null, c4 = null;
    for (let f5 = 0; f5 < m4.numberOfVertices; f5++) {
      const d3 = r3[4 * (m4.startVertex + f5) + 0], w4 = r3[4 * (m4.startVertex + f5) + 1], p3 = r3[4 * (m4.startVertex + f5) + 2], g4 = r3[4 * (m4.startVertex + f5) + 3];
      let y3 = null, x3 = null, M3 = null, A2 = null;
      if (f5 > 0) {
        y3 = d3 - o2, x3 = w4 - i2;
        const r4 = Math.sqrt(y3 * y3 + x3 * x3);
        if (y3 /= r4, x3 /= r4, f5 > 1) {
          let t5 = y3 + s6, n3 = x3 + c4;
          const r5 = Math.sqrt(t5 * t5 + n3 * n3);
          t5 /= r5, n3 /= r5;
          const o3 = Math.min(1 / (t5 * y3 + n3 * x3), e2);
          t5 *= o3, n3 *= o3, M3 = -n3, A2 = t5;
        } else
          M3 = -x3, A2 = y3;
        null !== M3 && null !== A2 && (h3(o2, i2, l3, M3, A2, t4, n2, g4), u3());
      }
      o2 = d3, i2 = w4, l3 = p3, s6 = y3, c4 = x3, a3 = g4;
    }
    h3(o2, i2, l3, -c4, s6, t4, n2, a3);
  }
  return { vertexData: a2, indexData: s5 };
}
function g3(t3) {
  const e2 = 16, n = 1, r3 = 2, { lineVertices: o, lineDescriptors: i } = t3;
  let l2 = 0, a2 = 0;
  for (const j2 of i) {
    const t4 = j2.numberOfVertices - 1;
    l2 += 4 * t4 * 2, a2 += 6 * t4 * 2;
  }
  const s5 = new Float32Array(l2 * e2), c3 = new Uint32Array(a2);
  let f4, u3, h3, m4, d3, w4, p3, g4, y3, x3, M3, A2, I2, V, F2 = 0, D2 = 0;
  function b2() {
    c3[D2++] = F2 - 8, c3[D2++] = F2 - 7, c3[D2++] = F2 - 6, c3[D2++] = F2 - 7, c3[D2++] = F2 - 5, c3[D2++] = F2 - 6, c3[D2++] = F2 - 4, c3[D2++] = F2 - 3, c3[D2++] = F2 - 2, c3[D2++] = F2 - 3, c3[D2++] = F2 - 1, c3[D2++] = F2 - 2;
  }
  function v2(t4, o2, i2, l3, a3, c4, f5, u4, h4, m5, d4, w5, p4, g5) {
    const y4 = F2 * e2;
    let x4 = 0;
    for (const e3 of [n, r3])
      for (const n2 of [1, 2, 3, 4])
        s5[y4 + x4++] = t4, s5[y4 + x4++] = o2, s5[y4 + x4++] = i2, s5[y4 + x4++] = l3, s5[y4 + x4++] = f5, s5[y4 + x4++] = u4, s5[y4 + x4++] = h4, s5[y4 + x4++] = m5, s5[y4 + x4++] = e3, s5[y4 + x4++] = n2, s5[y4 + x4++] = p4, s5[y4 + x4++] = g5, s5[y4 + x4++] = a3 / 2, s5[y4 + x4++] = c4 / 2, s5[y4 + x4++] = d4 / 2, s5[y4 + x4++] = w5 / 2, F2++;
  }
  function S2(t4, e3) {
    let n2 = y3 + M3, r4 = x3 + A2;
    const o2 = Math.sqrt(n2 * n2 + r4 * r4);
    n2 /= o2, r4 /= o2;
    const i2 = y3 * n2 + x3 * r4;
    n2 /= i2, r4 /= i2;
    let l3 = M3 + I2, a3 = A2 + V;
    const s6 = Math.sqrt(l3 * l3 + a3 * a3);
    l3 /= s6, a3 /= s6;
    const c4 = M3 * l3 + A2 * a3;
    l3 /= c4, a3 /= c4, v2(f4, u3, h3, m4, -r4, n2, d3, w4, p3, g4, -a3, l3, t4, e3), b2();
  }
  function k2(t4, e3, n2, r4, o2, i2) {
    if (y3 = M3, x3 = A2, M3 = I2, A2 = V, null == y3 && null == x3 && (y3 = M3, x3 = A2), null != d3 && null != w4) {
      I2 = t4 - d3, V = e3 - w4;
      const n3 = Math.sqrt(I2 * I2 + V * V);
      I2 /= n3, V /= n3;
    }
    null != y3 && null != x3 && S2(o2, i2), f4 = d3, u3 = w4, h3 = p3, m4 = g4, d3 = t4, w4 = e3, p3 = n2, g4 = r4;
  }
  function L(t4, e3) {
    y3 = M3, x3 = A2, M3 = I2, A2 = V, null == y3 && null == x3 && (y3 = M3, x3 = A2), null != y3 && null != x3 && S2(t4, e3);
  }
  for (const j2 of i) {
    f4 = null, u3 = null, h3 = null, m4 = null, d3 = null, w4 = null, p3 = null, g4 = null, y3 = null, x3 = null, M3 = null, A2 = null, I2 = null, V = null;
    const { totalTime: t4, timeSeed: e3 } = j2;
    for (let n2 = 0; n2 < j2.numberOfVertices; n2++) {
      k2(o[4 * (j2.startVertex + n2) + 0], o[4 * (j2.startVertex + n2) + 1], o[4 * (j2.startVertex + n2) + 2], o[4 * (j2.startVertex + n2) + 3], t4, e3);
    }
    L(t4, e3);
  }
  return { vertexData: s5, indexData: c3 };
}
function y2(t3, n) {
  const r3 = n.pixels, { width: o, height: i } = n, l2 = new Float32Array(o * i * 2), a2 = n.mask || new Uint8Array(o * i * 2);
  if (n.mask || a2.fill(255), "vector-uv" === t3)
    for (let e2 = 0; e2 < o * i; e2++)
      l2[2 * e2 + 0] = r3[0][e2], l2[2 * e2 + 1] = -r3[1][e2];
  else if ("vector-magdir" === t3)
    for (let s5 = 0; s5 < o * i; s5++) {
      const t4 = r3[0][s5], n2 = m(r3[1][s5]), o2 = Math.cos(n2 - Math.PI / 2), i2 = Math.sin(n2 - Math.PI / 2);
      l2[2 * s5 + 0] = o2 * t4, l2[2 * s5 + 1] = i2 * t4;
    }
  return { data: l2, mask: a2, width: o, height: i };
}
async function x2(t3, e2, n, r3, o, i) {
  const c3 = performance.now(), f4 = R(e2.spatialReference);
  if (!f4) {
    const l2 = await M2(t3, e2, n, r3, o, i);
    return has("esri-2d-profiler") && s4.info("I.7", "loadImagery, early exit (ms)", Math.round(performance.now() - c3)), has("esri-2d-profiler") && s4.info("I.9", "Number of parts", 1), l2;
  }
  const [u3, h3] = f4.valid, m4 = h3 - u3, d3 = Math.ceil(e2.width / m4), w4 = e2.width / d3, p3 = Math.round(n / d3);
  let g4 = e2.xmin;
  const y3 = [], x3 = performance.now();
  for (let l2 = 0; l2 < d3; l2++) {
    const n2 = new w({ xmin: g4, xmax: g4 + w4, ymin: e2.ymin, ymax: e2.ymax, spatialReference: e2.spatialReference });
    y3.push(M2(t3, n2, p3, r3, o, i)), g4 += w4;
  }
  const A2 = await Promise.all(y3);
  has("esri-2d-profiler") && s4.info("I.8", "All calls to _fetchPart (ms)", Math.round(performance.now() - x3)), has("esri-2d-profiler") && s4.info("I.9", "Number of parts", A2.length);
  const I2 = { data: new Float32Array(n * r3 * 2), mask: new Uint8Array(n * r3), width: n, height: r3 };
  let V = 0;
  for (const l2 of A2) {
    for (let t4 = 0; t4 < l2.height; t4++)
      for (let e3 = 0; e3 < l2.width; e3++)
        V + e3 >= n || (I2.data[2 * (t4 * n + V + e3) + 0] = l2.data[2 * (t4 * l2.width + e3) + 0], I2.data[2 * (t4 * n + V + e3) + 1] = l2.data[2 * (t4 * l2.width + e3) + 1], I2.mask[t4 * n + V + e3] = l2.mask[t4 * l2.width + e3]);
    V += l2.width;
  }
  return has("esri-2d-profiler") && s4.info("I.10", "loadImagery, general exit (ms)", Math.round(performance.now() - c3)), I2;
}
async function M2(t3, e2, o, i, l2, a2) {
  const s5 = { requestProjectedLocalDirections: true, signal: a2 };
  if (r(l2) && (s5.timeExtent = l2), "imagery" === t3.type) {
    await t3.load({ signal: a2 });
    const r3 = t3.rasterInfo.dataType, l3 = await t3.fetchImage(e2, o, i, s5);
    return !l3 || t(l3.pixelData) || t(l3.pixelData.pixelBlock) ? { data: new Float32Array(o * i * 2), mask: new Uint8Array(o * i), width: o, height: i } : y2(r3, l3.pixelData.pixelBlock);
  }
  await t3.load({ signal: a2 });
  const c3 = t3.rasterInfo.dataType, f4 = await t3.fetchPixels(e2, o, i, s5);
  return !f4 || t(f4.pixelBlock) ? { data: new Float32Array(o * i * 2), mask: new Uint8Array(o * i), width: o, height: i } : y2(c3, f4.pixelBlock);
}

export {
  c,
  l,
  f2 as f,
  m2 as m,
  d,
  g2 as g,
  x,
  D,
  F,
  j,
  f3 as f2,
  x2
};
//# sourceMappingURL=chunk-OYDVEVDU.js.map
