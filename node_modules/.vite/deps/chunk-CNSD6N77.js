import {
  r
} from "./chunk-X7GQR2IY.js";
import {
  n as n3
} from "./chunk-S6WNSMC7.js";
import {
  e as e3
} from "./chunk-JPRTIOCM.js";
import {
  t
} from "./chunk-RNRS2JL4.js";
import {
  h
} from "./chunk-SBPLVEUA.js";
import {
  u
} from "./chunk-3IISYLTT.js";
import {
  c,
  d,
  v
} from "./chunk-7QNA4ADD.js";
import {
  e as e2
} from "./chunk-6ZCPLPAF.js";
import {
  o as o2
} from "./chunk-MYQCUAHK.js";
import {
  e
} from "./chunk-C6PUUIY2.js";
import {
  o as o3
} from "./chunk-735C75BI.js";
import {
  n as n2,
  o
} from "./chunk-ZLTZ3KAT.js";
import {
  O
} from "./chunk-RUM3DXFX.js";
import {
  n
} from "./chunk-NDQ5FHGV.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/ScreenSizeScaling.glsl.js
function o4(o5, n4) {
  if (!n4.screenSizeEnabled)
    return;
  const c2 = o5.vertex;
  c(c2, n4), c2.uniforms.add(new o3("perScreenPixelRatio", (e4, i) => i.camera.perScreenPixelRatio)), c2.uniforms.add(new o3("screenSizeScale", (e4) => e4.screenSizeScale)), c2.code.add(n2`float computeRenderPixelSizeAt( vec3 pWorld ){
vec3 viewForward = - vec3(view[0][2], view[1][2], view[2][2]);
float viewDirectionDistance = abs(dot(viewForward, pWorld - cameraPosition));
return viewDirectionDistance * perScreenPixelRatio;
}
vec3 screenSizeScaling(vec3 position, vec3 anchor){
return position * screenSizeScale * computeRenderPixelSizeAt(anchor) + anchor;
}`);
}

// node_modules/@arcgis/core/chunks/ShadedColorMaterial.glsl.js
function w(e4) {
  const w2 = new o(), b2 = e4.hasMultipassTerrain && (e4.output === h.Color || e4.output === h.Alpha);
  w2.include(r, e4), w2.include(o4, e4), w2.include(u, e4);
  const { vertex: h3, fragment: C } = w2;
  return C.include(e3), v(h3, e4), C.uniforms.add(new e("uColor", (e5) => e5.color)), w2.attributes.add(O.POSITION, "vec3"), w2.varyings.add("vWorldPosition", "vec3"), b2 && w2.varyings.add("depth", "float"), e4.screenSizeEnabled && w2.attributes.add(O.OFFSET, "vec3"), e4.shadingEnabled && (d(h3), w2.attributes.add(O.NORMAL, "vec3"), w2.varyings.add("vViewNormal", "vec3")), h3.code.add(n2`
    void main(void) {
      vWorldPosition = ${e4.screenSizeEnabled ? "screenSizeScaling(offset, position)" : "position"};
  `), e4.shadingEnabled && h3.code.add(n2`vec3 worldNormal = normal;
vViewNormal = (viewNormal * vec4(worldNormal, 1)).xyz;`), h3.code.add(n2`
    ${b2 ? "depth = (view * vec4(vWorldPosition, 1.0)).z;" : ""}
    gl_Position = transformPosition(proj, view, vWorldPosition);
  }
  `), b2 && w2.include(n3, e4), C.code.add(n2`
    void main() {
      discardBySlice(vWorldPosition);
      ${b2 ? "terrainDepthTest(gl_FragCoord, depth);" : ""}
    `), e4.shadingEnabled ? (C.uniforms.add(new e2("shadingDirection", (e5) => e5.shadingDirection)), C.uniforms.add(new e("shadedColor", (e5) => f(e5.shadingTint, e5.color))), C.code.add(n2`vec3 viewNormalNorm = normalize(vViewNormal);
float shadingFactor = 1.0 - clamp(-dot(viewNormalNorm, shadingDirection), 0.0, 1.0);
vec4 finalColor = mix(uColor, shadedColor, shadingFactor);`)) : C.code.add(n2`vec4 finalColor = uColor;`), C.code.add(n2`
      if (finalColor.a < ${n2.float(t)}) {
        discard;
      }
      ${e4.output === h.Alpha ? n2`gl_FragColor = vec4(finalColor.a);` : ""}

      ${e4.output === h.Color ? n2`gl_FragColor = highlightSlice(finalColor, vWorldPosition); ${e4.transparencyPassType === o2.Color ? "gl_FragColor = premultiplyAlpha(gl_FragColor);" : ""}` : ""}
    }
    `), w2;
}
function f(e4, o5) {
  const r2 = 1 - e4[3], i = e4[3] + o5[3] * r2;
  return 0 === i ? (b[3] = i, b) : (b[0] = (e4[0] * e4[3] + o5[0] * o5[3] * r2) / i, b[1] = (e4[1] * e4[3] + o5[1] * o5[3] * r2) / i, b[2] = (e4[2] * e4[3] + o5[2] * o5[3] * r2) / i, b[3] = o5[3], b);
}
var b = n();
var h2 = Object.freeze(Object.defineProperty({ __proto__: null, build: w }, Symbol.toStringTag, { value: "Module" }));

export {
  w,
  h2 as h
};
//# sourceMappingURL=chunk-CNSD6N77.js.map
