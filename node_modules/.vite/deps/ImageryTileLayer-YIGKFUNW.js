import {
  a as a3,
  d as d3,
  h,
  m as m5,
  x as x2
} from "./chunk-PHSKOWOP.js";
import {
  c as c6,
  f as f6,
  i as i3,
  l as l4,
  m as m6
} from "./chunk-DL3FP7BG.js";
import {
  $ as $2,
  C,
  J,
  Q,
  T as T4,
  U as U2,
  V as V2,
  j as j5,
  ne,
  oe
} from "./chunk-DQCR5QA4.js";
import {
  $,
  L,
  V,
  c as c4,
  i,
  j as j4,
  l as l3,
  m as m4,
  n as n5,
  o as o3,
  u,
  w as w4
} from "./chunk-OPGFTFHW.js";
import {
  c as c5,
  d as d2,
  f as f4,
  g as g2,
  i as i2,
  m as m3,
  p as p3,
  s as s3
} from "./chunk-367STH4F.js";
import {
  D as D2,
  G,
  N,
  O as O2,
  P,
  S as S2,
  T as T3,
  b as b3,
  g as g3,
  n2 as n4,
  n3 as n6,
  p as p4,
  r as r3,
  r2 as r4,
  u as u2
} from "./chunk-6VAE3YKY.js";
import {
  d,
  f as f3,
  f2 as f5,
  m as m2
} from "./chunk-OYDVEVDU.js";
import {
  D,
  T as T2,
  W,
  b as b2,
  g,
  j as j3
} from "./chunk-OAXPH6DL.js";
import {
  n as n3,
  z
} from "./chunk-7F2ZL2BI.js";
import "./chunk-65ZBTSJX.js";
import "./chunk-OJ2HHY2O.js";
import "./chunk-O7LTV6XN.js";
import "./chunk-4TWWY75O.js";
import "./chunk-SQSR6K2M.js";
import "./chunk-UAJ2SDPQ.js";
import "./chunk-TWJNUVV2.js";
import "./chunk-NCXAKZRR.js";
import "./chunk-DUCSW4OU.js";
import "./chunk-WVDA5Z37.js";
import {
  j as j2
} from "./chunk-OOOPZLJE.js";
import "./chunk-U2WD23Z5.js";
import "./chunk-FFVIDMFN.js";
import {
  a as a2
} from "./chunk-LPRQBCQL.js";
import "./chunk-QR4K7IDQ.js";
import {
  o as o2
} from "./chunk-7N45W3EA.js";
import {
  p as p2
} from "./chunk-MQVQXXLV.js";
import {
  v as v3
} from "./chunk-G3HEFWHV.js";
import {
  p
} from "./chunk-3GENFQBG.js";
import {
  c as c3
} from "./chunk-FX6IXM55.js";
import {
  O
} from "./chunk-QFFP6A5Q.js";
import {
  S
} from "./chunk-J5VTDQTQ.js";
import "./chunk-PDEVQZ7U.js";
import "./chunk-7XXQ7762.js";
import "./chunk-DVGM5RQS.js";
import "./chunk-R6OA44DQ.js";
import "./chunk-QTYVDCOW.js";
import {
  c as c2,
  f as f2
} from "./chunk-YGVY4EIZ.js";
import "./chunk-HSDU7DIL.js";
import "./chunk-FWRLW4G5.js";
import "./chunk-E52E6T7N.js";
import {
  x
} from "./chunk-UK3I5WXR.js";
import {
  y as y2
} from "./chunk-GLGOVVCK.js";
import "./chunk-BUVDI6S7.js";
import "./chunk-6Z6ZAVRA.js";
import "./chunk-PK4W65H4.js";
import "./chunk-W62B63EU.js";
import "./chunk-N43PI2UO.js";
import "./chunk-O6VYMEIX.js";
import "./chunk-HUQX7WZO.js";
import "./chunk-BYSA56OH.js";
import "./chunk-ZWUEORSX.js";
import "./chunk-US2IWMHE.js";
import "./chunk-ZL4T4NIV.js";
import "./chunk-NAKEKTIK.js";
import "./chunk-QWNKYSI4.js";
import "./chunk-FMJZBZWF.js";
import "./chunk-GOYVJTGW.js";
import "./chunk-ZPYDYUP5.js";
import {
  n as n2
} from "./chunk-TDV3ZXCQ.js";
import {
  t as t2
} from "./chunk-XJCUKRCO.js";
import {
  b
} from "./chunk-SOEQPPQP.js";
import "./chunk-22F6X66Z.js";
import "./chunk-AIDV7EKX.js";
import "./chunk-FZQZIM7U.js";
import "./chunk-YM6PUX7G.js";
import "./chunk-QEYOWTXD.js";
import "./chunk-CZBRZ6SU.js";
import "./chunk-KDO6J2FO.js";
import "./chunk-RT3T2K4S.js";
import "./chunk-WJCI2CGX.js";
import "./chunk-REIQNAQW.js";
import "./chunk-J6LQZWZI.js";
import "./chunk-OD3FDQCI.js";
import "./chunk-J2PJNRU7.js";
import "./chunk-56SPM3WK.js";
import "./chunk-XMZAPOBR.js";
import "./chunk-BLJKKR5D.js";
import "./chunk-ZGNCYHMZ.js";
import "./chunk-X2S4RQJ4.js";
import {
  k as k2
} from "./chunk-FUPLN7UM.js";
import "./chunk-376OPXM4.js";
import "./chunk-DER356EU.js";
import "./chunk-MZIWIEIR.js";
import "./chunk-TQEOEDAZ.js";
import "./chunk-SHFHZMHO.js";
import "./chunk-NRP45AHD.js";
import "./chunk-IWQ7452U.js";
import {
  r as r2
} from "./chunk-NAN5J6QS.js";
import "./chunk-B4DKBAM3.js";
import "./chunk-6M2AHKYV.js";
import "./chunk-SZIJNKCV.js";
import "./chunk-6O43OEU5.js";
import "./chunk-J2K7ZDSV.js";
import "./chunk-2UML3WQZ.js";
import "./chunk-KXVMEIWT.js";
import "./chunk-UDND2Z3V.js";
import "./chunk-23Y3DIC6.js";
import "./chunk-JUVQV3R3.js";
import "./chunk-RAX2HD42.js";
import "./chunk-ZYRIJWLX.js";
import "./chunk-C5H57NTD.js";
import "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import "./chunk-YWAQYJRC.js";
import "./chunk-B356PXLT.js";
import "./chunk-EHPBHJYZ.js";
import "./chunk-3MNMDUQZ.js";
import {
  w as w2,
  w2 as w3
} from "./chunk-UWG37XSU.js";
import {
  R,
  k2 as k
} from "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import "./chunk-HLM6QCL2.js";
import {
  o
} from "./chunk-RXYULINL.js";
import {
  l as l2
} from "./chunk-5NXILPDI.js";
import "./chunk-THVR7IAM.js";
import {
  m
} from "./chunk-ZWJJTUFL.js";
import "./chunk-XQN7F674.js";
import {
  U
} from "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import {
  j
} from "./chunk-KAN4HXCG.js";
import "./chunk-4FEGON7M.js";
import "./chunk-VWYWOOPX.js";
import "./chunk-M5VHU5LK.js";
import "./chunk-CXFRNDG4.js";
import {
  l
} from "./chunk-7QMMKGW4.js";
import {
  e as e2,
  n2 as n,
  y
} from "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import {
  E,
  a,
  v as v2,
  w
} from "./chunk-MJXQTGI2.js";
import {
  s as s2
} from "./chunk-LIZHLHNA.js";
import {
  T,
  v
} from "./chunk-BTUHYGXO.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";
import {
  has
} from "./chunk-HVKDYDPP.js";
import "./chunk-6QC7MLLS.js";
import {
  c,
  e,
  f,
  r,
  t
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/layers/support/rasterDatasets/BaseRaster.js
var V3 = 8;
var $3 = class extends m(l) {
  constructor() {
    super(...arguments), this.rasterJobHandler = null, this.datasetName = null, this.datasetFormat = null, this.rasterInfo = null, this.ioConfig = { sampling: "closest" };
  }
  async init() {
    const t5 = T4();
    this.addResolvingPromise(t5), await this.when();
  }
  normalizeCtorArgs(t5) {
    return t5 && t5.ioConfig && (t5 = { ...t5, ioConfig: { resolution: null, bandIds: null, sampling: "closest", tileInfo: j2.create(), ...t5.ioConfig } }), t5;
  }
  get _isGlobalWrappableSource() {
    const { rasterInfo: t5 } = this, e4 = U2(t5.spatialReference);
    return r(e4) && t5.extent.width >= e4 / 2;
  }
  set url(t5) {
    this._set("url", S(t5, s.getLogger(this.declaredClass)));
  }
  async open(t5) {
    throw new s2("BaseRaster:open-not-implemented", "open() is not implemented");
  }
  async fetchTile(t5, e4, i5, o5 = {}) {
    const r6 = o5.tileInfo || this.rasterInfo.storageInfo.tileInfo, n10 = this.getTileExtentFromTileInfo(t5, e4, i5, r6);
    return this.fetchPixels(n10, r6.size[0], r6.size[1], o5);
  }
  async identify(t5, e4 = {}) {
    var _a, _b;
    t5 = v(w2, t5).clone().normalize();
    const { multidimensionalDefinition: i5, timeExtent: o5 } = e4, { hasMultidimensionalTranspose: r6, multidimensionalInfo: l6 } = this.rasterInfo;
    let { transposedVariableName: c10 } = e4;
    const m8 = r(l6) && r6 && (null != o5 || f4(i5));
    if (m8 && !c10) {
      c10 = r(i5) && i5.length > 0 ? (_a = i5[0].variableName) != null ? _a : void 0 : l6.variables[0].name, e4 = { ...e4, transposedVariableName: c10 };
    }
    e4 = this._getRequestOptionsWithSliceId(e4);
    const { spatialReference: f9, extent: u5 } = this.rasterInfo, { datumTransformation: p6 } = e4;
    let d6 = j5(t5, f9, p6);
    if (!u5.intersects(d6))
      return { location: d6, value: null };
    if (r(this.rasterInfo.transform)) {
      const t6 = this.rasterInfo.transform.inverseTransform(d6);
      if (!this.rasterInfo.nativeExtent.intersects(t6))
        return { location: t6, value: null };
      d6 = t6;
    }
    let x4 = 0;
    const g4 = r(c10) && r(l6) && this.rasterInfo.hasMultidimensionalTranspose;
    if (!g4) {
      if (e4.srcResolution) {
        x4 = oe(e4.srcResolution, this.rasterInfo, this.ioConfig.sampling).pyramidLevel;
      } else if (x4 = await this.computeBestPyramidLevelForLocation(t5, e4), null == x4)
        return { location: d6, value: null };
    }
    const y5 = this.identifyPixelLocation(d6, x4, null, g4);
    if (null === y5)
      return { location: d6, value: null };
    const { row: R3, col: w7, rowOffset: k3, colOffset: T5, blockWidth: B } = y5, P2 = c10 != null ? c10 : e(e4.sliceId), W2 = a3(this.url, P2), M = `${x4}/${R3}/${w7}`;
    let C2 = x2(W2, null, M);
    t(C2) && (C2 = this.fetchRawTile(x4, R3, w7, e4), h(W2, null, M, C2));
    const _ = await C2;
    if (t(_) || !((_b = _.pixels) == null ? void 0 : _b.length))
      return { location: d6, value: null };
    const j6 = k3 * B + T5;
    return this._processIdentifyResult(_, { srcLocation: d6, position: j6, pyramidLevel: x4, useTransposedTile: !!g4, requestSomeSlices: m8, identifyOptions: e4 });
  }
  async fetchPixels(t5, e4, i5, o5 = {}) {
    if (t5 = ne(t5), (o5 = this._getRequestOptionsWithSliceId(o5)).requestRawData)
      return this._fetchPixels(t5, e4, i5, o5);
    const r6 = U2(t5.spatialReference), n10 = Q(t5);
    if (t(r6) || 0 === n10 || 1 === n10 && this._isGlobalWrappableSource)
      return this._fetchPixels(t5, e4, i5, o5);
    if (n10 >= 3)
      return { extent: t5, pixelBlock: null };
    const s4 = [], { xmin: l6, xmax: c10 } = t5, m8 = Math.round(r6 / (c10 - l6) * e4), f9 = m8 - Math.round((r6 / 2 - l6) / (c10 - l6) * e4);
    let h3 = 0;
    const u5 = [];
    for (let a4 = 0; a4 <= n10; a4++) {
      const p7 = new w3({ xmin: 0 === a4 ? l6 : -r6 / 2, xmax: a4 === n10 ? c10 - r6 * a4 : r6 / 2, ymin: t5.ymin, ymax: t5.ymax, spatialReference: t5.spatialReference }), d7 = 0 === a4 ? m8 - f9 : a4 === n10 ? e4 - h3 : m8;
      h3 += d7, u5.push(d7);
      const x5 = o5.disableWrapAround && a4 > 0 ? null : this._fetchPixels(p7, d7, i5, o5);
      s4.push(x5);
    }
    const p6 = (await Promise.all(s4)).map((t6) => t6 == null ? void 0 : t6.pixelBlock);
    let d6 = null;
    const x4 = { width: e4, height: i5 };
    if (this.rasterJobHandler) {
      d6 = (await this.rasterJobHandler.mosaicAndTransform({ srcPixelBlocks: p6, srcMosaicSize: x4, destDimension: null, coefs: null, sampleSpacing: null, interpolation: "nearest", alignmentInfo: null, blockWidths: u5 }, o5)).pixelBlock;
    } else
      d6 = T2(p6, x4, { blockWidths: u5 });
    return { extent: t5, srcExtent: J(t5, this.rasterInfo.spatialReference, o5.datumTransformation), pixelBlock: d6 };
  }
  async fetchRawPixels(t5, e4, i5, o5 = {}) {
    e4 = { x: Math.floor(e4.x), y: Math.floor(e4.y) };
    const r6 = await this._fetchRawTiles(t5, e4, i5, o5), { nativeExtent: s4, nativePixelSize: a4, storageInfo: l6 } = this.rasterInfo, c10 = 2 ** t5, m8 = a4.x * c10, f9 = a4.y * c10, h3 = new w3({ xmin: s4.xmin + m8 * e4.x, xmax: s4.xmin + m8 * (e4.x + i5.width - 1), ymin: s4.ymax - f9 * (e4.y + i5.height - 1), ymax: s4.ymax - f9 * e4.y, spatialReference: s4.spatialReference });
    if (!r6)
      return { extent: h3, srcExtent: h3, pixelBlock: null };
    const { pixelBlocks: u5, mosaicSize: p6 } = r6;
    if (1 === u5.length && r(u5[0]) && u5[0].width === i5.width && u5[0].height === i5.height)
      return { extent: h3, srcExtent: h3, pixelBlock: r6.pixelBlocks[0] };
    const d6 = t5 > 0 ? l6.pyramidBlockWidth : l6.blockWidth, x4 = t5 > 0 ? l6.pyramidBlockHeight : l6.blockHeight, g4 = { x: e4.x % d6, y: e4.y % x4 };
    let y5;
    if (this.rasterJobHandler) {
      y5 = (await this.rasterJobHandler.mosaicAndTransform({ srcPixelBlocks: u5, srcMosaicSize: p6, destDimension: i5, clipOffset: g4, clipSize: i5, coefs: null, sampleSpacing: null, interpolation: o5.interpolation, alignmentInfo: null, blockWidths: null }, o5)).pixelBlock;
    } else
      y5 = T2(u5, p6, { clipOffset: g4, clipSize: i5 });
    return { extent: h3, srcExtent: h3, pixelBlock: y5 };
  }
  fetchRawTile(t5, e4, o5, r6) {
    throw new s2("BaseRaster:read-not-implemented", "fetchRawTile() is not implemented");
  }
  computeExtent(t5) {
    return J(this.rasterInfo.extent, t5);
  }
  decodePixelBlock(t5, e4) {
    return !this.rasterJobHandler || e4.useCanvas ? S2(t5, e4) : this.rasterJobHandler.decode({ data: t5, options: e4 });
  }
  async request(t5, i5, o5 = 0) {
    var _a;
    const { customFetchParameters: r6 } = this.ioConfig, { range: n10, query: s4, headers: a4 } = i5;
    o5 = (_a = o5 != null ? o5 : i5.retryCount) != null ? _a : this.ioConfig.retryCount;
    const l6 = n10 ? { Range: `bytes=${n10.from}-${n10.to}` } : null;
    try {
      return await U(t5, { ...i5, query: { ...s4, ...r6 }, headers: { ...a4, ...l6 } });
    } catch (c10) {
      if (o5 > 0)
        return o5--, this.request(t5, i5, o5);
      throw c10;
    }
  }
  getSliceIndex(t5) {
    const { multidimensionalInfo: e4 } = this.rasterInfo;
    return t(e4) || t(t5) || 0 === t5.length ? null : g2(t5, e4);
  }
  getTileExtentFromTileInfo(t5, e4, i5, o5) {
    const r6 = f(o5.lodAt(t5));
    return this.getTileExtent({ x: r6.resolution, y: r6.resolution }, e4, i5, o5.origin, o5.spatialReference, o5.size);
  }
  updateTileInfo() {
    const { storageInfo: t5, spatialReference: e4, extent: i5, pixelSize: o5 } = this.rasterInfo;
    if (!t5.tileInfo) {
      const r6 = [], n10 = t5.maximumPyramidLevel || 0;
      let s4 = Math.max(o5.x, o5.y), a4 = 1 / 0.0254 * 96 * s4;
      for (let t6 = 0; t6 <= n10; t6++)
        r6.push({ level: n10 - t6, resolution: s4, scale: a4 }), s4 *= 2, a4 *= 2;
      const l6 = new w2({ x: i5.xmin, y: i5.ymax, spatialReference: e4 });
      t5.tileInfo = new j2({ origin: l6, size: [t5.blockWidth, t5.blockHeight], spatialReference: e4, lods: r6 }), t5.isVirtualTileInfo = true;
    }
  }
  createRemoteDatasetStorageInfo(t5, e4 = 512, i5 = 512, o5) {
    const { width: r6, height: n10, nativeExtent: s4, pixelSize: a4, spatialReference: l6 } = t5, c10 = new w2({ x: s4.xmin, y: s4.ymax, spatialReference: l6 });
    null == o5 && (o5 = Math.max(0, Math.round(Math.log(Math.max(r6, n10)) / Math.LN2 - 8)));
    const m8 = this.computeBlockBoundary(s4, 512, 512, { x: s4.xmin, y: s4.ymax }, [a4], o5);
    t5.storageInfo = new n4({ blockWidth: e4, blockHeight: i5, pyramidBlockWidth: e4, pyramidBlockHeight: i5, origin: c10, firstPyramidLevel: 1, maximumPyramidLevel: o5, blockBoundary: m8 });
  }
  async computeBestPyramidLevelForLocation(t5, e4 = {}) {
    return 0;
  }
  computeBlockBoundary(t5, e4, i5, o5, r6, n10 = 0, s4 = 2) {
    if (1 === r6.length && n10 > 0) {
      r6 = [...r6];
      let { x: t6, y: e5 } = r6[0];
      for (let i6 = 0; i6 < n10; i6++)
        t6 *= s4, e5 *= s4, r6.push({ x: t6, y: e5 });
    }
    const a4 = [], { x: l6, y: c10 } = o5;
    for (let m8 = 0; m8 < r6.length; m8++) {
      const { x: o6, y: n11 } = r6[m8];
      a4.push({ minCol: Math.floor((t5.xmin - l6 + 0.1 * o6) / e4 / o6), maxCol: Math.floor((t5.xmax - l6 - 0.1 * o6) / e4 / o6), minRow: Math.floor((c10 - t5.ymax + 0.1 * n11) / i5 / n11), maxRow: Math.floor((c10 - t5.ymin - 0.1 * n11) / i5 / n11) });
    }
    return a4;
  }
  getPyramidPixelSize(t5) {
    const { nativePixelSize: e4 } = this.rasterInfo, { pyramidResolutions: i5, pyramidScalingFactor: o5 } = this.rasterInfo.storageInfo;
    if (0 === t5)
      return e4;
    if (r(i5) && i5.length)
      return i5[t5 - 1];
    const r6 = o5 ** t5;
    return { x: e4.x * r6, y: e4.y * r6 };
  }
  identifyPixelLocation(t5, e4, i5, o5) {
    const { spatialReference: r6, nativeExtent: s4, storageInfo: a4 } = this.rasterInfo, { maximumPyramidLevel: l6, origin: c10, transposeInfo: m8 } = a4, f9 = o5 && r(m8) ? m8.tileSize[0] : a4.blockWidth, h3 = o5 && r(m8) ? m8.tileSize[1] : a4.blockHeight, u5 = j5(t5, r6, i5);
    if (!s4.intersects(u5))
      return null;
    if (e4 < 0 || e4 > l6)
      return null;
    const p6 = this.getPyramidPixelSize(e4), { x: d6, y: x4 } = p6, g4 = (c10.y - u5.y) / x4 / h3, y5 = (u5.x - c10.x) / d6 / f9, I4 = Math.min(h3 - 1, Math.floor((g4 - Math.floor(g4)) * h3)), R3 = Math.min(f9 - 1, Math.floor((y5 - Math.floor(y5)) * f9));
    return { pyramidLevel: e4, row: Math.floor(g4), col: Math.floor(y5), rowOffset: I4, colOffset: R3, blockWidth: f9, srcLocation: u5 };
  }
  getTileExtent(t5, e4, i5, o5, r6, n10) {
    const [s4, a4] = n10, l6 = o5.x + i5 * s4 * t5.x, c10 = l6 + s4 * t5.x, m8 = o5.y - e4 * a4 * t5.y, f9 = m8 - a4 * t5.y;
    return new w3({ xmin: l6, xmax: c10, ymin: f9, ymax: m8, spatialReference: r6 });
  }
  getBlockWidthHeight(t5) {
    return { blockWidth: t5 > 0 ? this.rasterInfo.storageInfo.pyramidBlockWidth : this.rasterInfo.storageInfo.blockWidth, blockHeight: t5 > 0 ? this.rasterInfo.storageInfo.pyramidBlockHeight : this.rasterInfo.storageInfo.blockHeight };
  }
  isBlockOutside(t5, e4, i5) {
    const o5 = this.rasterInfo.storageInfo.blockBoundary[t5];
    return !o5 || o5.maxRow < e4 || o5.maxCol < i5 || o5.minRow > e4 || o5.minCol > i5;
  }
  async _fetchPixels(t5, e4, i5, o5 = {}) {
    let r6 = Q(t5);
    if (r6 >= 2)
      return { extent: t5, pixelBlock: null };
    const a4 = this._getSourceDataInfo(t5, e4, i5, o5), { pyramidLevel: l6, pyramidResolution: c10, srcResolution: m8, srcExtent: f9, srcWidth: h3, srcHeight: u5 } = a4;
    if (0 === h3 || 0 === u5)
      return { extent: t5, srcExtent: f9, pixelBlock: null };
    const p6 = e(this.rasterInfo.transform), d6 = "gcs-shift" === (p6 == null ? void 0 : p6.type), x4 = r(U2(t5.spatialReference));
    !d6 && x4 || (r6 = Q(a4.srcExtent, d6));
    const g4 = this.rasterInfo.storageInfo, y5 = { x: Math.floor((f9.xmin - g4.origin.x) / c10.x + 0.1), y: Math.floor((g4.origin.y - f9.ymax) / c10.y + 0.1) }, I4 = await this._fetchRawTiles(l6, y5, { width: h3, height: u5, wrapCount: r6 }, o5);
    if (!I4)
      return { extent: t5, srcExtent: f9, pixelBlock: null };
    const R3 = l6 > 0 ? g4.pyramidBlockWidth : g4.blockWidth, w7 = l6 > 0 ? g4.pyramidBlockHeight : g4.blockHeight, k3 = R3 === h3 && w7 === u5 && y5.x % R3 == 0 && y5.y % w7 == 0, b5 = new w2({ x: (t5.xmax - t5.xmin) / e4, y: (t5.ymax - t5.ymin) / i5, spatialReference: t5.spatialReference }), v5 = !t5.spatialReference.equals(this.rasterInfo.spatialReference), { datumTransformation: S4 } = o5;
    if (!v5 && k3 && 1 === I4.pixelBlocks.length && R3 === e4 && w7 === i5 && m8.x === b5.x && m8.y === b5.y)
      return { extent: t5, srcExtent: f9, pixelBlock: I4.pixelBlocks[0] };
    const T5 = x4 && r(U2(f9.spatialReference)), B = o5.requestProjectedLocalDirections && this.rasterInfo.dataType.startsWith("vector");
    B && !this.rasterJobHandler && await T4();
    const P2 = this.rasterJobHandler ? await this.rasterJobHandler.getProjectionOffsetGrid({ projectedExtent: t5, srcBufferExtent: I4.extent, pixelSize: b5.toJSON(), datumTransformation: S4, rasterTransform: p6, hasWrapAround: r6 > 0 || T5, isAdaptive: false !== this.ioConfig.optimizeProjectionAccuracy, includeGCSGrid: B }, o5) : $2({ projectedExtent: t5, srcBufferExtent: I4.extent, pixelSize: b5, datumTransformation: S4, rasterTransform: p6, hasWrapAround: r6 > 0 || T5, isAdaptive: false, includeGCSGrid: B });
    let H;
    const E3 = !o5.requestRawData, L2 = { rows: P2.spacing[0], cols: P2.spacing[1] }, z2 = e(this._getRasterTileAlignmentInfo(l6, I4.extent.xmin)), { pixelBlocks: F3, mosaicSize: O3, isPartiallyFilled: G2 } = I4;
    let J3 = null;
    if (this.rasterJobHandler) {
      const t6 = await this.rasterJobHandler.mosaicAndTransform({ srcPixelBlocks: F3, srcMosaicSize: O3, destDimension: E3 ? { width: e4, height: i5 } : null, coefs: E3 ? P2.coefficients : null, sampleSpacing: E3 ? L2 : null, projectDirections: B, gcsGrid: B ? P2.gcsGrid : null, isUV: "vector-uv" === this.rasterInfo.dataType, interpolation: o5.interpolation, alignmentInfo: z2, blockWidths: null }, o5);
      ({ pixelBlock: H, localNorthDirections: J3 } = t6);
    } else {
      const t6 = T2(F3, O3, { alignmentInfo: z2 });
      H = E3 ? D(t6, { width: e4, height: i5 }, P2.coefficients, L2, o5.interpolation) : t6, B && P2.gcsGrid && (J3 = j3({ width: e4, height: i5 }, P2.gcsGrid), H = m2(H, this.rasterInfo.dataType, J3));
    }
    return o5.requestRawData || B ? { srcExtent: f9, pixelBlock: H, transformGrid: P2, localNorthDirections: J3, extent: t5, isPartiallyFilled: G2 } : { srcExtent: f9, extent: t5, pixelBlock: H };
  }
  async _fetchRawTiles(t5, e4, i5, o5) {
    const { origin: r6, blockBoundary: s4 } = this.rasterInfo.storageInfo, { blockWidth: a4, blockHeight: l6 } = this.getBlockWidthHeight(t5);
    let { x: c10, y: m8 } = e4, { width: f9, height: h3, wrapCount: u5 } = i5;
    const p6 = this._getRasterTileAlignmentInfo(t5, 0);
    o5.buffer && (c10 -= o5.buffer.cols, m8 -= o5.buffer.rows, f9 += 2 * o5.buffer.cols, h3 += 2 * o5.buffer.rows);
    let d6 = 0, x4 = 0, g4 = 0;
    if (u5 && r(p6)) {
      ({ worldColumnCountFromOrigin: x4, originColumnOffset: g4, rightPadding: d6 } = p6);
      x4 * p6.blockWidth - d6 >= c10 + f9 && (d6 = 0);
    }
    const y5 = Math.floor(c10 / a4), I4 = Math.floor(m8 / l6), R3 = Math.floor((c10 + f9 + d6 - 1) / a4), w7 = Math.floor((m8 + h3 + d6 - 1) / l6), k3 = s4[t5];
    if (!k3)
      return null;
    const { minRow: b5, minCol: v5, maxCol: S4, maxRow: T5 } = k3;
    if (0 === u5 && (w7 < b5 || R3 < v5 || I4 > T5 || y5 > S4))
      return null;
    const B = new Array();
    let P2 = false;
    const W2 = null == this.ioConfig.allowPartialFill ? o5.allowPartialFill : this.ioConfig.allowPartialFill;
    for (let L2 = I4; L2 <= w7; L2++)
      for (let e5 = y5; e5 <= R3; e5++) {
        let i6 = e5;
        if (!o5.disableWrapAround && u5 && r(p6) && x4 <= e5 && (i6 = e5 - x4 - g4), L2 >= b5 && i6 >= v5 && T5 >= L2 && S4 >= i6) {
          const e6 = this._fetchRawTile(t5, L2, i6, o5);
          W2 ? B.push(new Promise((t6) => {
            e6.then((e7) => t6(e7)).catch(() => {
              P2 = true, t6(null);
            });
          })) : B.push(e6);
        } else
          B.push(Promise.resolve(null));
      }
    if (0 === B.length)
      return null;
    const M = await Promise.all(B), C2 = { height: (w7 - I4 + 1) * l6, width: (R3 - y5 + 1) * a4 }, { spatialReference: _ } = this.rasterInfo, j6 = this.getPyramidPixelSize(t5), { x: H, y: E3 } = j6;
    return { extent: new w3({ xmin: r6.x + y5 * a4 * H, xmax: r6.x + (R3 + 1) * a4 * H, ymin: r6.y - (w7 + 1) * l6 * E3, ymax: r6.y - I4 * l6 * E3, spatialReference: _ }), pixelBlocks: M, mosaicSize: C2, isPartiallyFilled: P2 };
  }
  _fetchRawTile(t5, e4, i5, o5) {
    const r6 = this.rasterInfo.storageInfo.blockBoundary[t5];
    if (!r6)
      return Promise.resolve(null);
    const { minRow: n10, minCol: s4, maxCol: l6, maxRow: c10 } = r6;
    if (e4 < n10 || i5 < s4 || e4 > c10 || i5 > l6)
      return Promise.resolve(null);
    const f9 = a3(this.url, o5.sliceId), h3 = `${t5}/${e4}/${i5}`;
    let u5 = x2(f9, o5.registryId, h3);
    if (t(u5)) {
      const r7 = new AbortController();
      u5 = this.fetchRawTile(t5, e4, i5, { ...o5, signal: r7.signal }), h(f9, o5.registryId, h3, u5, r7), u5.catch(() => d3(f9, o5.registryId, h3));
    }
    return o5.signal && v2(o5, () => {
      m5(f9, o5.registryId, h3);
    }), u5;
  }
  _computeMagDirValues(t5) {
    var _a;
    const { bandCount: e4, dataType: i5 } = this.rasterInfo;
    if (!(2 === e4 && "vector-magdir" === i5 || "vector-uv" === i5) || 2 !== (t5 == null ? void 0 : t5.length) || !((_a = t5[0]) == null ? void 0 : _a.length))
      return null;
    const o5 = t5[0].length;
    if ("vector-magdir" === i5) {
      const e5 = t5[1].map((t6) => (t6 + 360) % 360);
      return [t5[0], e5];
    }
    const [r6, n10] = t5, s4 = [], a4 = [];
    for (let l6 = 0; l6 < o5; l6++) {
      const [t6, e5] = f3([r6[l6], n10[l6]]);
      s4.push(t6), a4.push(e5);
    }
    return [s4, a4];
  }
  _getRasterTileAlignmentInfo(t5, e4) {
    return null == this._rasterTileAlighmentInfo && (this._rasterTileAlighmentInfo = V2(this.rasterInfo)), t(this._rasterTileAlighmentInfo.pyramidsInfo) ? null : { startX: e4, halfWorldWidth: this._rasterTileAlighmentInfo.halfWorldWidth, hasGCSSShiftTransform: this._rasterTileAlighmentInfo.hasGCSSShiftTransform, ...this._rasterTileAlighmentInfo.pyramidsInfo[t5] };
  }
  _getSourceDataInfo(t5, e4, i5, o5 = {}) {
    const r6 = { datumTransformation: o5.datumTransformation, pyramidLevel: 0, pyramidResolution: null, srcExtent: null, srcHeight: 0, srcResolution: null, srcWidth: 0 };
    o5.srcResolution && (r6.srcResolution = o5.srcResolution, this._updateSourceDataInfo(t5, r6));
    const n10 = this.rasterInfo.storageInfo.maximumPyramidLevel || 0, { srcWidth: s4, srcHeight: a4, pyramidLevel: l6 } = r6, c10 = s4 / e4, m8 = a4 / i5, f9 = l6 < n10 && c10 * m8 >= 16;
    if (f9 || l6 === n10 && (c10 > V3 || m8 > V3) || (0 === s4 || 0 === a4)) {
      const s5 = new w2({ x: (t5.xmax - t5.xmin) / e4, y: (t5.ymax - t5.ymin) / i5, spatialReference: t5.spatialReference });
      let a5 = C(s5, this.rasterInfo.spatialReference, t5, r6.datumTransformation);
      const h3 = !a5 || o5.srcResolution && a5.x + a5.y < o5.srcResolution.x + o5.srcResolution.y;
      if (f9 && o5.srcResolution && h3) {
        const t6 = Math.round(Math.log(Math.max(c10, m8)) / Math.LN2) - 1;
        if (n10 - l6 + 3 >= t6) {
          const e5 = 2 ** t6;
          a5 = { x: o5.srcResolution.x * e5, y: o5.srcResolution.y * e5 };
        }
      }
      a5 && (r6.srcResolution = a5, this._updateSourceDataInfo(t5, r6));
    }
    return (r6.srcWidth / e4 > V3 || r6.srcHeight / i5 > V3) && (r6.srcWidth = 0, r6.srcHeight = 0), r6;
  }
  _updateSourceDataInfo(t5, e4) {
    e4.srcWidth = 0, e4.srcHeight = 0;
    const i5 = this.rasterInfo.spatialReference, { srcResolution: o5, datumTransformation: r6 } = e4, { pyramidLevel: n10, pyramidResolution: a4, excessiveReading: l6 } = oe(o5, this.rasterInfo, this.ioConfig.sampling);
    if (l6)
      return;
    let c10 = e4.srcExtent || J(t5, i5, r6);
    if (null == c10)
      return;
    const m8 = e(this.rasterInfo.transform);
    m8 && (c10 = m8.inverseTransform(c10)), e4.srcExtent = c10;
    const f9 = Math.ceil((c10.xmax - c10.xmin) / a4.x - 0.1), h3 = Math.ceil((c10.ymax - c10.ymin) / a4.y - 0.1);
    e4.pyramidLevel = n10, e4.pyramidResolution = a4, e4.srcWidth = f9, e4.srcHeight = h3;
  }
  _getRequestOptionsWithSliceId(t5) {
    return r(this.rasterInfo.multidimensionalInfo) && null == t5.sliceId && (t5 = { ...t5, sliceId: this.getSliceIndex(t5.multidimensionalDefinition) }), t5;
  }
  _processIdentifyResult(t5, e4) {
    const { srcLocation: i5, position: o5, pyramidLevel: r6, useTransposedTile: n10 } = e4, l6 = t5.pixels[0].length / t5.width / t5.height;
    if (!(!t5.mask || t5.mask[o5]))
      return { location: i5, value: null };
    const { multidimensionalInfo: c10 } = this.rasterInfo;
    if (t(c10) || !n10) {
      const e5 = t5.pixels.map((t6) => t6[o5]), n11 = { location: i5, value: e5, pyramidLevel: r6 }, s4 = this._computeMagDirValues(e5.map((t6) => [t6]));
      return (s4 == null ? void 0 : s4.length) && (n11.magdirValue = s4.map((t6) => t6[0])), n11;
    }
    let m8 = t5.pixels.map((t6) => Array.prototype.slice.call(t6, o5 * l6, o5 * l6 + l6)), f9 = this._computeMagDirValues(m8);
    const { requestSomeSlices: h3, identifyOptions: u5 } = e4;
    let p6 = i2(c10, u5.transposedVariableName);
    if (h3) {
      const t6 = s3(p6, e(u5.multidimensionalDefinition), e(u5.timeExtent));
      m8 = m8.map((e5) => t6.map((t7) => e5[t7])), f9 = f9 == null ? void 0 : f9.map((e5) => t6.map((t7) => e5[t7])), p6 = t6.map((t7) => p6[t7]);
    }
    return { location: i5, value: null, dataSeries: p6.map((t6, e5) => {
      const i6 = { value: m8.map((t7) => t7[e5]), multidimensionalDefinition: t6.multidimensionalDefinition.map((t7) => new p3({ ...t7, isSlice: true })) };
      return (f9 == null ? void 0 : f9.length) && (i6.magdirValue = [f9[0][e5], f9[1][e5]]), i6;
    }), pyramidLevel: r6 };
  }
};
e2([y()], $3.prototype, "_rasterTileAlighmentInfo", void 0), e2([y({ readOnly: true })], $3.prototype, "_isGlobalWrappableSource", null), e2([y(f2)], $3.prototype, "url", null), e2([y({ type: String, json: { write: true } })], $3.prototype, "datasetName", void 0), e2([y({ type: String, json: { write: true } })], $3.prototype, "datasetFormat", void 0), e2([y()], $3.prototype, "rasterInfo", void 0), e2([y()], $3.prototype, "ioConfig", void 0), e2([y()], $3.prototype, "sourceJSON", void 0), $3 = e2([n("esri.layers.support.rasterDatasets.BaseRaster")], $3);
var U3 = $3;

// node_modules/@arcgis/core/layers/support/rasterDatasets/FunctionRaster.js
var n7 = class extends U3 {
  constructor() {
    super(...arguments), this.datasetFormat = "Function", this.tileType = "Raster", this.rasterFunction = null, this._primaryRasters = null;
  }
  async open(r6) {
    var _a;
    await this.init();
    const { rasterFunction: s4 } = this, { rasters: e4, rasterIds: o5 } = s4.getPrimaryRasters(), a4 = e4.map((t5) => t5.rasterInfo ? void 0 : t5.open(r6));
    await Promise.all(a4);
    const i5 = e4.map(({ rasterInfo: r7 }) => r7), n10 = s4.bind({ rasterInfos: i5, rasterIds: o5 });
    if (!n10.success)
      throw new s2("raster-function:open", `cannot bind the function: ${(_a = n10.error) != null ? _a : ""}`);
    await this.syncJobHandler(), this.set("sourceJSON", e4[0].sourceJSON), this.set("rasterInfo", s4.rasterInfo);
  }
  async syncJobHandler() {
    const { rasterFunction: r6 } = this;
    if (this._primaryRasters = r6.getPrimaryRasters(), this.rasterJobHandler)
      return this.rasterJobHandler.updateRasterFunction(r6);
  }
  async fetchPixels(r6, t5, o5, a4 = {}) {
    var _a, _b;
    const { rasters: i5, rasterIds: n10 } = this._primaryRasters, c10 = i5.map((s4) => s4.fetchPixels(r6, t5, o5, a4)), p6 = await Promise.all(c10), l6 = p6.map((r7) => r7.pixelBlock);
    if (l6.every((r7) => t(r7)))
      return p6[0];
    const m8 = (_b = (_a = p6.find((r7) => r(r7.pixelBlock))) == null ? void 0 : _a.extent) != null ? _b : r6, u5 = this.rasterJobHandler ? await this.rasterJobHandler.process({ extent: m8, primaryPixelBlocks: l6, primaryRasterIds: n10 }) : this.rasterFunction.process({ extent: m8, primaryPixelBlocks: l6, primaryRasterIds: n10 });
    return { ...p6[0], pixelBlock: u5 };
  }
};
e2([y({ type: String, json: { write: true } })], n7.prototype, "datasetFormat", void 0), e2([y()], n7.prototype, "tileType", void 0), e2([y()], n7.prototype, "rasterFunction", void 0), n7 = e2([n("esri.layers.support.rasterDatasets.FunctionRaster")], n7);
var c7 = n7;

// node_modules/@arcgis/core/layers/mixins/ImageryTileMixin.js
var w5 = s.getLogger("esri.layers.mixins.ImageryTileMixin");
var N2 = (s4) => {
  let N4 = class extends s4 {
    constructor() {
      super(...arguments), this._rasterJobHandler = { instance: null, refCount: 0, connectionPromise: null }, this.bandIds = null, this.copyright = null, this.interpolation = "nearest", this.multidimensionalDefinition = null, this.multidimensionalSubset = null, this.raster = null, this.rasterFunction = null, this.sourceJSON = null, this.symbolizer = null;
    }
    get fullExtent() {
      var _a;
      return (_a = this.rasterInfo) == null ? void 0 : _a.extent;
    }
    get rasterInfo() {
      var _a;
      return (_a = this.raster) == null ? void 0 : _a.rasterInfo;
    }
    get spatialReference() {
      var _a, _b;
      return (_b = (_a = this.rasterInfo) == null ? void 0 : _a.spatialReference) != null ? _b : k.WGS84;
    }
    get tileInfo() {
      var _a;
      return (_a = this.rasterInfo) == null ? void 0 : _a.storageInfo.tileInfo;
    }
    set url(e4) {
      this._set("url", S(e4, w5));
    }
    set renderer(e4) {
      this._set("renderer", e4), this.updateRenderer();
    }
    async convertVectorFieldData(e4, t5) {
      if (t(e4) || !this.rasterInfo)
        return null;
      const r6 = this._rasterJobHandler.instance, i5 = this.rasterInfo.dataType;
      return r6 ? r6.convertVectorFieldData({ pixelBlock: e4, dataType: i5 }, t5) : d(e4, i5);
    }
    async createFlowMesh(e4, t5) {
      const r6 = this._rasterJobHandler.instance;
      return r6 ? r6.createFlowMesh(e4, t5) : f5(e4.meshType, e4.simulationSettings, e4.flowData, r(t5.signal) ? t5.signal : new AbortController().signal);
    }
    normalizeRasterFetchOptions(e4) {
      var _a, _b, _c;
      const { multidimensionalInfo: t5 } = (_a = this.rasterInfo) != null ? _a : {};
      if (t(t5))
        return e4;
      let r6 = e4.multidimensionalDefinition || this.multidimensionalDefinition;
      !t(r6) && r6.length || (r6 = c5(this.raster.rasterInfo, { multidimensionalSubset: this.multidimensionalSubset }));
      const i5 = e4.timeExtent || this.timeExtent;
      if (r(r6) && r(i5) && (r(i5.start) || r(i5.end))) {
        r6 = r6.map((e5) => e5.clone());
        const s5 = (_c = (_b = t5.variables.find(({ name: e5 }) => e5 === r6[0].variableName)) == null ? void 0 : _b.dimensions) == null ? void 0 : _c.find(({ name: e5 }) => "StdTime" === e5), a4 = r6.find(({ dimensionName: e5 }) => "StdTime" === e5);
        if (!s5 || !a4)
          return { ...e4, multidimensionalDefinition: null };
        const { start: l6, end: m8 } = i5, u5 = t(l6) ? null : l6.getTime(), d6 = t(m8) ? null : m8.getTime(), h3 = u5 != null ? u5 : d6, c10 = d6 != null ? d6 : u5;
        if (r(s5.values)) {
          const e5 = s5.values.filter((e6) => {
            if (Array.isArray(e6)) {
              if (h3 === c10)
                return e6[0] <= h3 && e6[1] >= h3;
              const t6 = e6[0] <= h3 && e6[1] > h3 || e6[0] < c10 && e6[1] >= c10, r7 = e6[0] >= h3 && e6[1] <= c10 || e6[0] < h3 && e6[1] > c10;
              return t6 || r7;
            }
            return h3 === c10 ? e6 === h3 : e6 >= h3 && e6 <= c10;
          });
          if (e5.length) {
            const t6 = e5.sort((e6, t7) => {
              var _a2, _b2, _c2, _d;
              if (h3 === c10)
                return ((_a2 = e6[0]) != null ? _a2 : e6) - ((_b2 = t7[0]) != null ? _b2 : t7);
              return Math.abs(((_c2 = e6[1]) != null ? _c2 : e6) - c10) - Math.abs(((_d = t7[1]) != null ? _d : t7) - c10);
            })[0];
            a4.values = [t6];
          } else
            r6 = null;
        } else if (s5.hasRegularIntervals && s5.extent) {
          const [e5, t6] = s5.extent;
          h3 > t6 || c10 < e5 ? r6 = null : a4.values = h3 === c10 ? [h3] : [Math.max(e5, h3), Math.min(t6, c10)];
        }
      }
      return r(r6) && m3(r6, this.multidimensionalSubset) ? { ...e4, multidimensionalDefinition: null } : { ...e4, multidimensionalDefinition: r6 };
    }
    async updateRenderer() {
      const { loaded: e4, symbolizer: t5 } = this;
      if (!e4 || !t5)
        return;
      if (JSON.stringify(this._cachedRendererJson) === JSON.stringify(this.renderer))
        return;
      const r6 = this._rasterJobHandler.instance;
      r6 && (t5.rendererJSON = $(this.renderer.toJSON()), t5.bind(), await r6.updateSymbolizer(t5), this._cachedRendererJson = this.renderer.toJSON());
    }
    async applyRenderer(e4, t5) {
      var _a;
      const r6 = e4 && e4.pixelBlock;
      if (!(r(r6) && r6.pixels && r6.pixels.length > 0))
        return null;
      let i5;
      await this.updateRenderer();
      const s5 = this._rasterJobHandler.instance, n10 = (_a = this.bandIds) != null ? _a : [];
      return i5 = s5 ? await s5.symbolize({ ...e4, simpleStretchParams: t5, bandIds: n10 }) : this.symbolizer.symbolize({ ...e4, simpleStretchParams: t5, bandIds: n10 }), i5;
    }
    getTileUrl(e4, t5, r6) {
      var _a;
      return "RasterTileServer" === ((_a = this.raster) == null ? void 0 : _a.datasetFormat) ? `${this.url}/tile/${e4}/${t5}/${r6}` : "";
    }
    getCompatibleTileInfo(e4, t5, r6 = false) {
      if (!this.loaded || t(t5))
        return null;
      if (r6 && e4.equals(this.spatialReference))
        return this.tileInfo;
      const i5 = R(e4);
      return j2.create({ size: 256, spatialReference: e4, origin: i5 ? { x: i5.origin[0], y: i5.origin[1] } : { x: t5.xmin, y: t5.ymax } });
    }
    getCompatibleFullExtent(e4) {
      return this.loaded ? (this._compatibleFullExtent && this._compatibleFullExtent.spatialReference.equals(e4) || (this._compatibleFullExtent = this.raster.computeExtent(e4)), this._compatibleFullExtent) : null;
    }
    async fetchTile(e4, t5, i5, s5 = {}) {
      if (O3(this), s5.requestAsImageElement) {
        const n10 = this.getTileUrl(e4, t5, i5);
        return U(n10, { responseType: "image", query: { ...this.refreshParameters, ...this.raster.ioConfig.customFetchParameters }, signal: s5.signal }).then((e5) => e5.data);
      }
      if (r(this.rasterInfo.multidimensionalInfo) && (s5 = this.normalizeRasterFetchOptions(s5), t(s5.multidimensionalDefinition))) {
        const r6 = s5.tileInfo || this.rasterInfo.storageInfo.tileInfo;
        return { extent: this.raster.getTileExtentFromTileInfo(e4, t5, i5, r6), pixelBlock: null };
      }
      return await this._initJobHandler(), await this._updateRasterFunction(), "raster-shaded-relief" === this.renderer.type && (s5 = { ...s5, buffer: { cols: 1, rows: 1 } }), this.raster.fetchTile(e4, t5, i5, s5);
    }
    async fetchPixels(e4, t5, r6, i5 = {}) {
      return r(this.rasterInfo.multidimensionalInfo) && (i5 = this.normalizeRasterFetchOptions(i5), t(i5.multidimensionalDefinition)) ? { extent: e4, pixelBlock: null } : (await this._initJobHandler(), await this._updateRasterFunction(), this.raster.fetchPixels(e4, t5, r6, i5));
    }
    async identify(e4, t5 = {}) {
      if (O3(this), r(this.rasterInfo.multidimensionalInfo)) {
        if (!(this.rasterInfo.hasMultidimensionalTranspose && !!(f4(t5.multidimensionalDefinition) || t5.transposedVariableName || t5.timeExtent)) && (t5 = this.normalizeRasterFetchOptions(t5), t(t5.multidimensionalDefinition)))
          return { location: e4, value: null };
      }
      return this.raster.identify(e4, t5);
    }
    increaseRasterJobHandlerUsage() {
      this._rasterJobHandler.refCount++;
    }
    decreaseRasterJobHandlerUsage() {
      this._rasterJobHandler.refCount--, this._rasterJobHandler.refCount <= 0 && this._shutdownJobHandler();
    }
    hasStandardTime() {
      var _a, _b, _c;
      const e4 = (_a = this.rasterInfo) == null ? void 0 : _a.multidimensionalInfo;
      if (t(e4) || "standard-time" !== ((_b = this.rasterInfo) == null ? void 0 : _b.dataType))
        return false;
      const t5 = this.multidimensionalDefinition, r6 = (_c = t5 == null ? void 0 : t5[0]) == null ? void 0 : _c.variableName;
      return e4.variables.some((e5) => e5.name === r6 && (!(t5 == null ? void 0 : t5[0].dimensionName) || e5.dimensions.some((e6) => "StdTime" === e6.name)));
    }
    getStandardTimeValue(e4) {
      return new Date(24 * (e4 - 25569) * 3600 * 1e3).toString();
    }
    getMultidimensionalSubsetVariables(e4) {
      const t5 = e4 != null ? e4 : this.rasterInfo.multidimensionalInfo;
      return d2(this.multidimensionalSubset, t5);
    }
    _configDefaultSettings() {
      this._configDefaultInterpolation(), this.multidimensionalDefinition || (this.multidimensionalDefinition = c5(this.raster.rasterInfo, { multidimensionalSubset: this.multidimensionalSubset })), this._configDefaultRenderer();
    }
    _initJobHandler() {
      if (null != this._rasterJobHandler.connectionPromise)
        return this._rasterJobHandler.connectionPromise;
      const e4 = new n5();
      return this._rasterJobHandler.connectionPromise = e4.initialize().then(() => {
        O3(this), this._rasterJobHandler.instance = e4, this.raster.rasterJobHandler = e4, this.renderer && this.updateRenderer(), "Function" === this.raster.datasetFormat && this.raster.syncJobHandler();
      }).catch(() => {
      }), this._rasterJobHandler.connectionPromise;
    }
    _shutdownJobHandler() {
      this._rasterJobHandler.instance && this._rasterJobHandler.instance.destroy(), this._rasterJobHandler.instance = null, this._rasterJobHandler.connectionPromise = null, this._rasterJobHandler.refCount = 0, this._cachedRendererJson = null, this.raster && (this.raster.rasterJobHandler = null);
    }
    _configDefaultInterpolation() {
      var _a;
      if (null == this.interpolation) {
        O3(this);
        const e4 = V(this.rasterInfo, this.raster.tileType, (_a = this.sourceJSON) == null ? void 0 : _a.defaultResamplingMethod);
        this._set("interpolation", e4);
      }
    }
    _configDefaultRenderer() {
      var _a, _b, _c, _d, _e;
      O3(this);
      const e4 = this.raster.rasterInfo;
      if (this.bandIds || (this.bandIds = L(e4)), !this.renderer) {
        const t6 = j4(e4, { bandIds: this.bandIds, variableName: r(this.multidimensionalDefinition) ? (_a = this.multidimensionalDefinition[0]) == null ? void 0 : _a.variableName : null });
        "WCSServer" === this.raster.datasetFormat && "raster-stretch" === t6.type && (((_c = (_b = e4.statistics) == null ? void 0 : _b[0].max) != null ? _c : 0) > 1e24 || ((_e = (_d = e4.statistics) == null ? void 0 : _d[0].min) != null ? _e : 0) < -1e24) && (t6.dynamicRangeAdjustment = true, t6.statistics = null, "none" === t6.stretchType && (t6.stretchType = "min-max")), this.renderer = t6;
      }
      this.symbolizer ? (this.symbolizer.rendererJSON = $(this.renderer.toJSON()), this.symbolizer.rasterInfo = e4) : this.symbolizer = new T3({ rendererJSON: this.renderer.toJSON(), rasterInfo: e4 });
      const t5 = this.symbolizer.bind();
      t5.success || w5.warn("imagery-tile-mixin", t5.error || "The given renderer is not supported by the layer.");
    }
    async _updateRasterFunction() {
      var _a;
      if ("imagery-tile" !== this.type || JSON.stringify(this.rasterFunction) === JSON.stringify(this._cachedRasterFunctionJson))
        return;
      let e4 = this.raster;
      if ("Function" === (e4 == null ? void 0 : e4.datasetFormat)) {
        const t6 = e4.rasterFunction.getPrimaryRasters();
        e4 = t6.rasters[0];
      }
      const { rasterFunction: t5 } = this;
      if (t5) {
        const r6 = l4(t5.toJSON(), { raster: e4 }), i5 = new c7({ rasterFunction: r6 });
        i5.rasterJobHandler = this._rasterJobHandler.instance, await i5.open(), this._cachedRasterFunctionJson = (_a = this.rasterFunction) == null ? void 0 : _a.toJSON(), this.raster = i5;
      } else
        this.raster = e4;
    }
  };
  function O3(e4) {
    if (!e4.raster || !e4.rasterInfo)
      throw new s2("imagery-tile", "no raster");
  }
  return e2([y()], N4.prototype, "_cachedRendererJson", void 0), e2([y()], N4.prototype, "_cachedRasterFunctionJson", void 0), e2([y()], N4.prototype, "_compatibleFullExtent", void 0), e2([y()], N4.prototype, "_rasterJobHandler", void 0), e2([y()], N4.prototype, "bandIds", void 0), e2([y({ json: { origins: { service: { read: { source: "copyrightText" } } } } })], N4.prototype, "copyright", void 0), e2([y({ json: { read: false } })], N4.prototype, "fullExtent", null), e2([y()], N4.prototype, "interpolation", void 0), e2([y()], N4.prototype, "ioConfig", void 0), e2([y({ type: [p3] })], N4.prototype, "multidimensionalDefinition", void 0), e2([y({ type: c4, json: { write: true } })], N4.prototype, "multidimensionalSubset", void 0), e2([y()], N4.prototype, "raster", void 0), e2([y({ type: w4 })], N4.prototype, "rasterFunction", void 0), e2([y()], N4.prototype, "rasterInfo", null), e2([y()], N4.prototype, "sourceJSON", void 0), e2([y({ json: { read: false } })], N4.prototype, "spatialReference", null), e2([y({ json: { read: false } })], N4.prototype, "tileInfo", null), e2([y(f2)], N4.prototype, "url", null), e2([y({ types: l3 })], N4.prototype, "renderer", null), e2([y()], N4.prototype, "symbolizer", void 0), N4 = e2([n("esri.layers.ImageryTileMixin")], N4), N4;
};

// node_modules/@arcgis/core/layers/support/rasterDatasets/DBFParser.js
function t3(e4) {
  const t5 = e4.fields, r6 = e4.records, n10 = t5.some((e5) => "oid" === e5.name.toLowerCase()) ? "OBJECTID" : "OID", i5 = [{ name: n10, type: "esriFieldTypeOID", alias: "OID" }].concat(t5.map((e5) => ({ name: e5.name, type: "esriFieldType" + e5.typeName, alias: e5.name }))), s4 = i5.map((e5) => e5.name), a4 = [];
  let o5 = 0, l6 = 0;
  return r6.forEach((e5) => {
    const t6 = {};
    for (t6[n10] = o5++, l6 = 1; l6 < s4.length; l6++)
      t6[s4[l6]] = e5[l6 - 1];
    a4.push({ attributes: t6 });
  }), { displayFieldName: "", fields: i5, features: a4 };
}
var r5 = class {
  static get supportedVersions() {
    return [5];
  }
  static parse(r6) {
    const n10 = new DataView(r6), i5 = 3 & n10.getUint8(0);
    if (3 !== i5)
      return { header: { version: i5 }, recordSet: null };
    const s4 = n10.getUint32(4, true), a4 = n10.getUint16(8, true), o5 = n10.getUint16(10, true), l6 = { version: i5, recordCount: s4, headerByteCount: a4, recordByteCount: o5 };
    let p6 = 32;
    const g4 = [], u5 = [];
    let d6;
    if (3 === i5) {
      for (; 13 !== n10.getUint8(p6); )
        d6 = String.fromCharCode(n10.getUint8(p6 + 11)).trim(), g4.push({ name: r3(new Uint8Array(r6, p6, 11)), type: d6, typeName: ["String", "Date", "Double", "Boolean", "String", "Integer"][["C", "D", "F", "L", "M", "N"].indexOf(d6)], length: n10.getUint8(p6 + 16) }), p6 += 32;
      if (p6 += 1, g4.length > 0)
        for (; u5.length < s4 && r6.byteLength - p6 > o5; ) {
          const t5 = [];
          32 === n10.getUint8(p6) ? (p6 += 1, g4.forEach((n11) => {
            if ("C" === n11.type)
              t5.push(r3(new Uint8Array(r6, p6, n11.length)).trim());
            else if ("N" === n11.type)
              t5.push(parseInt(String.fromCharCode.apply(null, new Uint8Array(r6, p6, n11.length)).trim(), 10));
            else if ("F" === n11.type)
              t5.push(parseFloat(String.fromCharCode.apply(null, new Uint8Array(r6, p6, n11.length)).trim()));
            else if ("D" === n11.type) {
              const e4 = String.fromCharCode.apply(null, new Uint8Array(r6, p6, n11.length)).trim();
              t5.push(new Date(parseInt(e4.substring(0, 4), 10), parseInt(e4.substring(4, 6), 10) - 1, parseInt(e4.substring(6, 8), 10)));
            }
            p6 += n11.length;
          }), u5.push(t5)) : p6 += o5;
        }
    }
    return { header: l6, fields: g4, records: u5, recordSet: t3({ fields: g4, records: u5 }) };
  }
};

// node_modules/@arcgis/core/layers/support/rasterDatasets/CloudRaster.js
var y3 = /* @__PURE__ */ new Map();
y3.set("int16", "esriFieldTypeSmallInteger"), y3.set("int32", "esriFieldTypeInteger"), y3.set("int64", "esriFieldTypeInteger"), y3.set("float32", "esriFieldTypeSingle"), y3.set("float64", "esriFieldTypeDouble"), y3.set("text", "esriFieldTypeString");
var x3 = 8;
var S3 = class extends U3 {
  constructor() {
    super(...arguments), this.storageInfo = null, this.datasetFormat = "CRF";
  }
  async open(e4) {
    await this.init();
    const { data: r6 } = await this.request(this.url + "/conf.json", { signal: e4 == null ? void 0 : e4.signal });
    if (!this._validateHeader(r6))
      throw new s2("cloudraster:open", "Invalid or unsupported conf.json.");
    this.datasetName = this.url.slice(this.url.lastIndexOf("/") + 1);
    const { storageInfo: i5, rasterInfo: o5 } = this._parseHeader(r6);
    if ("thematic" === o5.dataType) {
      const e5 = await this._fetchAuxiliaryInformation();
      o5.attributeTable = e5;
    }
    this._set("storageInfo", i5), this._set("rasterInfo", o5), this.ioConfig.retryCount = this.ioConfig.retryCount || 0;
  }
  async fetchRawTile(e4, t5, r6, i5 = {}) {
    const { transposeInfo: o5 } = this.rasterInfo.storageInfo, { transposedVariableName: a4 } = i5, s4 = !(!o5 || !a4), n10 = s4 ? 0 : this.rasterInfo.storageInfo.maximumPyramidLevel - e4;
    if (n10 < 0)
      return null;
    const l6 = this._buildCacheFilePath(n10, t5, r6, i5.multidimensionalDefinition, a4), f9 = this._getIndexRecordFromBundle(t5, r6, s4), m8 = await this.request(l6, { range: { from: 0, to: this.storageInfo.headerSize - 1 }, responseType: "array-buffer", signal: i5.signal });
    if (!m8)
      return null;
    const c10 = new Uint8Array(m8.data), p6 = this._getTileEndAndContentType(c10, f9);
    if (0 === p6.recordSize)
      return null;
    const d6 = await this.request(l6, { range: { from: p6.position, to: p6.position + p6.recordSize }, responseType: "array-buffer", signal: i5.signal });
    if (!d6)
      return null;
    const [u5, h3] = this._getTileSize(s4);
    return this.decodePixelBlock(d6.data, { width: u5, height: h3, planes: null, pixelType: null, returnInterleaved: s4 });
  }
  _validateHeader(e4) {
    const t5 = ["origin", "extent", "geodataXform", "LODInfos", "blockWidth", "blockHeight", "bandCount", "pixelType", "pixelSizeX", "pixelSizeY", "format", "packetSize"];
    return e4 && "RasterInfo" === e4.type && !t5.some((t6) => !e4[t6]);
  }
  _parseHeader(e4) {
    var _a, _b;
    const t5 = ["u1", "u2", "u4", "u8", "s8", "u16", "s16", "u32", "s32", "f32", "f64"][e4.pixelType], { bandCount: r6, histograms: i5, colormap: o5, blockWidth: a4, blockHeight: f9, firstPyramidLevel: m8, maximumPyramidLevel: c10 } = e4, p6 = e4.statistics && e4.statistics.map((e5) => ({ min: e5.min, max: e5.max, avg: e5.mean, stddev: e5.standardDeviation, median: e5.median, mode: e5.mode })), d6 = e4.extent.spatialReference, y5 = (_a = e4.geodataXform) == null ? void 0 : _a.spatialReference, S4 = new k((d6 == null ? void 0 : d6.wkid) || (d6 == null ? void 0 : d6.wkt) ? d6 : y5);
    let I4 = new w3({ xmin: e4.extent.xmin, ymin: e4.extent.ymin, xmax: e4.extent.xmax, ymax: e4.extent.ymax, spatialReference: S4 });
    const w7 = new w2({ x: e4.pixelSizeX, y: e4.pixelSizeY, spatialReference: S4 }), _ = Math.round((I4.xmax - I4.xmin) / w7.x), v5 = Math.round((I4.ymax - I4.ymin) / w7.y), b5 = this._parseTransform(e4.geodataXform), z2 = b5 ? I4 : null;
    b5 && (I4 = b5.forwardTransform(I4), w7.x = (I4.xmax - I4.xmin) / _, w7.y = (I4.ymax - I4.ymin) / v5);
    const T5 = (_b = e4.properties) != null ? _b : {}, k3 = e4.format.toLowerCase().replace("cache/", ""), j6 = new w2(e4.origin.x, e4.origin.y, S4);
    let C2, R3, F3, P2;
    if (o5 && o5.colors)
      for (C2 = [], R3 = 0; R3 < o5.colors.length; R3++)
        F3 = o5.colors[R3], P2 = o5.values ? o5.values[R3] : R3, C2.push([P2, 255 & F3, F3 << 16 >>> 24, F3 << 8 >>> 24, F3 >>> 24]);
    const H = e4.LODInfos, D3 = [];
    for (R3 = 0; R3 < H.levels.length; R3++)
      D3.push({ level: H.levels[R3], resolution: H.resolutions[R3], scale: 96 / 0.0254 * H.resolutions[R3] });
    const L2 = new j2({ dpi: 96, lods: D3, format: k3, origin: j6, size: [a4, f9], spatialReference: S4 }), M = { recordSize: x3, packetSize: e4.packetSize, headerSize: e4.packetSize * e4.packetSize * x3 + 64 }, B = [{ maxCol: Math.ceil(_ / a4) - 1, maxRow: Math.ceil(v5 / f9) - 1, minCol: 0, minRow: 0 }];
    let O3 = 2;
    if (c10 > 0)
      for (R3 = 0; R3 < c10; R3++)
        B.push({ maxCol: Math.ceil(_ / O3 / a4) - 1, maxRow: Math.ceil(v5 / O3 / f9) - 1, minCol: 0, minRow: 0 }), O3 *= 2;
    const $4 = e4.mdInfo;
    let N4 = null;
    if ($4 && T5._yxs) {
      const e5 = T5._yxs;
      N4 = { packetSize: e5.PacketSize, tileSize: [e5.TileXSize, e5.TileYSize] };
    }
    return { storageInfo: M, rasterInfo: new u2({ width: _, height: v5, pixelType: t5, bandCount: r6, extent: I4, nativeExtent: z2, transform: b5, spatialReference: S4, pixelSize: w7, keyProperties: T5, statistics: p6, histograms: i5, multidimensionalInfo: $4, colormap: C2, storageInfo: new n4({ blockWidth: a4, blockHeight: f9, pyramidBlockWidth: a4, pyramidBlockHeight: f9, origin: j6, tileInfo: L2, transposeInfo: N4, firstPyramidLevel: m8, maximumPyramidLevel: c10, blockBoundary: B }) }) };
  }
  _parseTransform(e4) {
    var _a, _b;
    if (!f6(e4))
      throw new s2("cloudraster:open", "the data contains unsupported geodata transform types");
    const r6 = i3(e4);
    if ("identity" === r6.type)
      return null;
    if ("polynomial" !== r6.type || !((_a = r6.forwardCoefficients) == null ? void 0 : _a.length) || !((_b = r6.inverseCoefficients) == null ? void 0 : _b.length))
      throw new s2("cloudraster:open", "the data contains unsupported geodata transforms - both forward and inverse coefficients are required currently");
    return r6;
  }
  async _fetchAuxiliaryInformation(e4) {
    const t5 = this.request(this.url + "/conf.vat.json", { signal: e4 }).then((e5) => e5.data).catch(() => null), r6 = this.request(this.url + "/conf.vat.dbf", { responseType: "array-buffer", signal: e4 }).then((e5) => e5.data).catch(() => null), i5 = await Promise.all([t5, r6]);
    let o5;
    if (i5[0]) {
      let e5 = i5[0].fields;
      const t6 = i5[0].values;
      if (e5 && t6) {
        e5 = e5.map((e6) => ({ type: "OID" === e6.name ? "esriFieldTypeOID" : y3.get(e6.type), name: e6.name, alias: e6.alias || e6.name }));
        const r7 = t6.map((e6) => ({ attributes: e6 }));
        e5 && t6 && (o5 = { fields: e5, features: r7 });
      }
    }
    if (!o5 && i5[1]) {
      o5 = r5.parse(i5[1]).recordSet;
    }
    return x.fromJSON(o5);
  }
  _buildCacheFilePath(e4, t5, i5, o5, a4) {
    const s4 = this._getPackageSize(!!a4), n10 = Math.floor(t5 / s4) * s4, l6 = Math.floor(i5 / s4) * s4, f9 = "R" + this._toHexString4(n10) + "C" + this._toHexString4(l6);
    let m8 = "L";
    m8 += e4 >= 10 ? e4.toString() : "0" + e4.toString();
    const { multidimensionalInfo: c10 } = this.rasterInfo, p6 = o5 == null ? void 0 : o5[0];
    if (t(c10) || !p6)
      return `${this.url}/_alllayers/${m8}/${f9}.bundle`;
    let d6 = "_yxs";
    if (!a4) {
      d6 = c10.variables.find((e6) => e6.name === p6.variableName).dimensions[0].values.indexOf(p6.values[0]).toString(16);
      const e5 = 4 - d6.length;
      for (let t6 = 0; t6 < e5; t6++)
        d6 = "0" + d6;
      d6 = "S" + d6;
    }
    const u5 = this._getVariableFolderName(a4 || p6.variableName);
    return `${this.url}/_alllayers/${u5}/${d6}/${m8}/${f9}.bundle`;
  }
  _getPackageSize(e4 = false) {
    var _a;
    const { transposeInfo: t5 } = this.rasterInfo.storageInfo;
    return e4 && r(t5) ? (_a = t5.packetSize) != null ? _a : 0 : this.storageInfo.packetSize;
  }
  _getTileSize(e4 = false) {
    const { storageInfo: t5 } = this.rasterInfo, { transposeInfo: r6 } = t5;
    return e4 && r(r6) ? r6.tileSize : t5.tileInfo.size;
  }
  _getVariableFolderName(e4) {
    return "" === (e4 = e4.trim()) ? "_v" : e4.replace(/[\{|\}\-]/g, "_").replace("\\*", "_v");
  }
  _getIndexRecordFromBundle(e4, t5, r6 = false) {
    const i5 = this._getPackageSize(r6), o5 = i5 * (e4 % i5) + t5 % i5;
    if (o5 < 0)
      throw "Invalid level / row / col";
    return 20 + o5 * this.storageInfo.recordSize + 44;
  }
  _getTileEndAndContentType(e4, t5) {
    const r6 = e4.subarray(t5, t5 + 8);
    let i5, o5 = 0;
    for (i5 = 0; i5 < 5; i5++)
      o5 |= (255 & r6[i5]) << 8 * i5;
    const a4 = 1099511627775 & o5;
    for (o5 = 0, i5 = 5; i5 < 8; i5++)
      o5 |= (255 & r6[i5]) << 8 * (i5 - 5);
    return { position: a4, recordSize: 1099511627775 & o5 };
  }
  _toHexString4(e4) {
    let t5 = e4.toString(16);
    if (4 !== t5.length) {
      let e5 = 4 - t5.length;
      for (; e5-- > 0; )
        t5 = "0" + t5;
    }
    return t5;
  }
};
e2([y({ readOnly: true })], S3.prototype, "storageInfo", void 0), e2([y({ type: String, json: { write: true } })], S3.prototype, "datasetFormat", void 0), S3 = e2([n("esri.layers.support.rasterDatasets.CloudRaster")], S3);
var I = S3;

// node_modules/@arcgis/core/layers/support/rasterDatasets/InMemoryRaster.js
var h2 = class extends U3 {
  constructor() {
    super(...arguments), this.datasetFormat = "MEMORY", this.data = null;
  }
  async open(t5) {
    var _a, _b;
    await this.init();
    const e4 = this.data, { pixelBlock: s4, statistics: r6, histograms: i5, name: o5, keyProperties: m8, nativeExtent: n10, transform: l6 } = this.data, { width: h3, height: f9, pixelType: d6 } = s4, u5 = (_a = e4.extent) != null ? _a : new w3({ xmin: -0.5, ymin: 0.5, xmax: h3 - 0.5, ymax: f9 - 0.5, spatialReference: new k({ wkid: 3857 }) }), y5 = (_b = e4.isPseudoSpatialReference) != null ? _b : !e4.extent, x4 = { x: u5.width / h3, y: u5.height / f9 }, g4 = new u2({ width: h3, height: f9, pixelType: d6, extent: u5, nativeExtent: n10, transform: l6, pixelSize: x4, spatialReference: u5.spatialReference, bandCount: 3, keyProperties: m8 || {}, statistics: r6, isPseudoSpatialReference: y5, histograms: i5 });
    this.createRemoteDatasetStorageInfo(g4, 512, 512), this._set("rasterInfo", g4), this.updateTileInfo(), await this._buildInMemoryRaster(s4, { width: 512, height: 512 }, t5), this.datasetName = o5, this.url = "/InMemory/" + o5;
  }
  fetchRawTile(t5, e4, s4, r6 = {}) {
    const i5 = this._pixelBlockTiles.get(`${t5}/${e4}/${s4}`);
    return Promise.resolve(i5);
  }
  async _buildInMemoryRaster(t5, i5, o5) {
    var _a, _b;
    const a4 = this.rasterInfo.storageInfo.maximumPyramidLevel, m8 = this.rasterJobHandler ? this.rasterJobHandler.split({ pixelBlock: t5, tileSize: i5, maximumPyramidLevel: a4 }, o5) : Promise.resolve(W(t5, i5, a4)), p6 = r(this.rasterInfo.statistics), c10 = r(this.rasterInfo.histograms), h3 = p6 ? Promise.resolve({ statistics: null, histograms: null }) : this.rasterJobHandler ? this.rasterJobHandler.estimateStatisticsHistograms({ pixelBlock: t5 }, o5) : Promise.resolve(p4(t5)), f9 = await E([m8, h3]);
    if (!f9[0].value && f9[1].value)
      throw new s2("inmemory-raster:open", "failed to build in memory raster");
    this._pixelBlockTiles = f9[0].value, p6 || (this.rasterInfo.statistics = (_a = f9[1].value) == null ? void 0 : _a.statistics), c10 || (this.rasterInfo.histograms = (_b = f9[1].value) == null ? void 0 : _b.histograms);
  }
};
e2([y({ type: String, json: { write: true } })], h2.prototype, "datasetFormat", void 0), e2([y()], h2.prototype, "data", void 0), h2 = e2([n("esri.layers.support.rasterDatasets.InMemoryRaster")], h2);
var f7 = h2;

// node_modules/@arcgis/core/layers/support/rasterDatasets/xmlUtilities.js
function n8(e4, t5) {
  if (!e4 || !t5)
    return [];
  let l6 = t5;
  t5.includes("/") ? (l6 = t5.slice(0, t5.indexOf("/")), t5 = t5.slice(t5.indexOf("/") + 1)) : t5 = "";
  const r6 = [];
  if (t5) {
    const u6 = n8(e4, l6);
    for (let e5 = 0; e5 < u6.length; e5++) {
      n8(u6[e5], t5).forEach((n10) => r6.push(n10));
    }
    return r6;
  }
  const u5 = e4.getElementsByTagNameNS("*", l6);
  if (!u5 || 0 === u5.length)
    return [];
  for (let n10 = 0; n10 < u5.length; n10++)
    r6.push(u5[n10] || u5.item[n10]);
  return r6;
}
function e3(t5, l6) {
  if (!t5 || !l6)
    return null;
  let r6 = l6;
  l6.includes("/") ? (r6 = l6.slice(0, l6.indexOf("/")), l6 = l6.slice(l6.indexOf("/") + 1)) : l6 = "";
  const u5 = n8(t5, r6);
  return u5.length > 0 ? l6 ? e3(u5[0], l6) : u5[0] : null;
}
function t4(n10, t5 = null) {
  const l6 = t5 ? e3(n10, t5) : n10;
  let r6;
  return l6 ? (r6 = l6.textContent || l6.nodeValue, r6 ? r6.trim() : null) : null;
}
function l5(e4, t5) {
  const l6 = n8(e4, t5), r6 = [];
  let u5;
  for (let n10 = 0; n10 < l6.length; n10++)
    u5 = l6[n10].textContent || l6[n10].nodeValue, u5 && (u5 = u5.trim(), "" !== u5 && r6.push(u5));
  return r6;
}
function u3(n10, e4) {
  return l5(n10, e4).map((n11) => Number(n11));
}
function o4(n10, e4) {
  const l6 = t4(n10, e4);
  return Number(l6);
}
function i4(n10, e4) {
  var _a;
  const t5 = (_a = n10 == null ? void 0 : n10.nodeName) == null ? void 0 : _a.toLowerCase(), l6 = e4.toLowerCase();
  return t5.slice(t5.lastIndexOf(":") + 1) === l6;
}

// node_modules/@arcgis/core/layers/support/rasterDatasets/pamParser.js
function f8(e4, t5) {
  if (!e4 || !t5)
    return null;
  const n10 = [];
  for (let r6 = 0; r6 < e4.length; r6++)
    n10.push(e4[r6]), n10.push(t5[r6]);
  return n10;
}
function u4(e4) {
  var _a;
  const t5 = e3(e4, "GeodataXform"), r6 = m7(o4(t5, "SpatialReference/WKID") || t4(t5, "SpatialReference/WKT"));
  if ("typens:PolynomialXform" !== t5.getAttribute("xsi:type"))
    return { spatialReference: r6, transform: null };
  const o5 = (_a = o4(t5, "PolynomialOrder")) != null ? _a : 1, u5 = u3(t5, "CoeffX/Double"), c10 = u3(t5, "CoeffY/Double"), d6 = u3(t5, "InverseCoeffX/Double"), p6 = u3(t5, "InverseCoeffY/Double"), S4 = f8(u5, c10), C2 = f8(d6, p6);
  return { spatialReference: r6, transform: S4 && C2 && S4.length && C2.length ? new m6({ spatialReference: r6, polynomialOrder: o5, forwardCoefficients: S4, inverseCoefficients: C2 }) : null };
}
function c8(e4) {
  var _a;
  const t5 = o4(e4, "NoDataValue"), i5 = e3(e4, "Histograms/HistItem"), l6 = o4(i5, "HistMin"), o5 = o4(i5, "HistMax"), f9 = o4(i5, "BucketCount"), u5 = (_a = t4(i5, "HistCounts")) == null ? void 0 : _a.split("|").map((e5) => Number(e5));
  let c10, m8, d6, p6;
  n8(e4, "Metadata/MDI").forEach((e5) => {
    var _a2;
    const t6 = Number((_a2 = e5.textContent) != null ? _a2 : e5.nodeValue);
    switch (e5.getAttribute("key").toUpperCase()) {
      case "STATISTICS_MINIMUM":
        c10 = t6;
        break;
      case "STATISTICS_MAXIMUM":
        m8 = t6;
        break;
      case "STATISTICS_MEAN":
        d6 = t6;
        break;
      case "STATISTICS_STDDEV":
        p6 = t6;
    }
  });
  const S4 = o4(e4, "Metadata/SourceBandIndex");
  return { noDataValue: t5, histogram: (u5 == null ? void 0 : u5.length) && null != l6 && null != o5 ? { min: l6, max: o5, size: f9 || u5.length, counts: u5 } : null, sourceBandIndex: S4, statistics: null != c10 && null != m8 ? { min: c10, max: m8, avg: d6, stddev: p6 } : null };
}
function m7(e4) {
  if (!e4)
    return null;
  let t5 = Number(e4);
  if (!isNaN(t5) && 0 !== t5)
    return new k({ wkid: t5 });
  if ((e4 = String(e4)).startsWith("COMPD_CS")) {
    if (!e4.includes("VERTCS") || !e4.includes("GEOGCS") && !e4.startsWith("PROJCS"))
      return null;
    const n10 = e4.indexOf("VERTCS"), r6 = e4.indexOf("PROJCS"), s4 = r6 > -1 ? r6 : e4.indexOf("GEOGCS");
    if (-1 === s4)
      return null;
    const a4 = e4.slice(s4, e4.lastIndexOf("]", n10) + 1).trim(), i5 = e4.slice(n10, e4.lastIndexOf("]")).trim();
    t5 = d4(a4);
    const l6 = new k(t5 ? { wkid: t5 } : { wkt: a4 }), f9 = d4(i5);
    return f9 && (l6.vcsWkid = f9), l6;
  }
  return e4.startsWith("GEOGCS") || e4.startsWith("PROJCS") ? (t5 = d4(e4), new k(0 !== t5 ? { wkid: t5 } : { wkt: e4 })) : null;
}
function d4(e4) {
  var _a;
  const t5 = e4.replace(/\]/g, "[").replace(/\"/g, "").split("[").map((e5) => e5.trim()).filter((e5) => "" !== e5), n10 = t5[t5.length - 1].split(","), r6 = (_a = n10[0]) == null ? void 0 : _a.toLowerCase();
  if (("epsg" === r6 || "esri" === r6) && e4.endsWith('"]]')) {
    const e5 = Number(n10[1]);
    if (!isNaN(e5) && 0 !== e5)
      return e5;
  }
  return 0;
}
function p5(s4) {
  var _a;
  if ("pamdataset" !== ((_a = s4 == null ? void 0 : s4.documentElement.tagName) == null ? void 0 : _a.toLowerCase()))
    return {};
  const a4 = { spatialReference: null, transform: null, metadata: {}, rasterBands: [], statistics: null, histograms: null };
  s4.documentElement.childNodes.forEach((e4) => {
    if (1 === e4.nodeType) {
      if (i4(e4, "SRS")) {
        if (!a4.spatialReference) {
          const t5 = t4(e4);
          a4.spatialReference = m7(t5);
        }
      } else if (i4(e4, "Metadata"))
        if ("xml:ESRI" === e4.getAttribute("domain")) {
          const { spatialReference: t5, transform: n10 } = u4(e4);
          a4.transform = n10, a4.spatialReference || (a4.spatialReference = t5);
        } else {
          n8(e4, "MDI").forEach((e5) => a4.metadata[e5.getAttribute("key")] = t4(e5));
        }
      else if (i4(e4, "PAMRasterBand")) {
        const t5 = c8(e4);
        null != t5.sourceBandIndex && null == a4.rasterBands[t5.sourceBandIndex] ? a4.rasterBands[t5.sourceBandIndex] = t5 : a4.rasterBands.push(t5);
      }
    }
  });
  const i5 = a4.rasterBands;
  if (i5.length) {
    const t5 = !!i5[0].statistics;
    a4.statistics = t5 ? i5.map((e4) => e4.statistics).filter(r) : null;
    const n10 = !!i5[0].histogram;
    a4.histograms = n10 ? i5.map((e4) => e4.histogram).filter(r) : null;
  }
  return a4;
}

// node_modules/@arcgis/core/layers/support/rasterDatasets/ImageAuxRaster.js
var d5 = class extends U3 {
  async open(t5) {
    await this.init();
    const s4 = await this._fetchData(t5);
    let { spatialReference: e4, statistics: r6, histograms: a4, transform: o5 } = await this._fetchAuxiliaryData(t5);
    const i5 = !e4;
    i5 && (e4 = new k({ wkid: 3857 })), (a4 == null ? void 0 : a4.length) && null == r6 && (r6 = g3(a4));
    const { width: n10, height: l6 } = s4;
    let p6 = new w3({ xmin: -0.5, ymin: 0.5 - l6, xmax: n10 - 0.5, ymax: 0.5, spatialReference: e4 });
    const f9 = o5 ? o5.forwardTransform(p6) : p6;
    let d6 = true;
    if (o5) {
      const t6 = o5.forwardCoefficients;
      d6 = t6 && 0 === t6[1] && 0 === t6[2], d6 && (o5 = null, p6 = f9);
    }
    const y5 = new f7({ data: { extent: f9, nativeExtent: p6, transform: o5, pixelBlock: s4, statistics: r6, histograms: a4, keyProperties: { DateType: "Processed" }, isPseudoSpatialReference: i5 } });
    await y5.open(), y5.data = null, this._set("rasterInfo", y5.rasterInfo), this._inMemoryRaster = y5;
  }
  fetchRawTile(t5, s4, e4, r6 = {}) {
    return this._inMemoryRaster.fetchRawTile(t5, s4, e4, r6);
  }
  async _fetchData(t5) {
    const { data: e4 } = await this.request(this.url, { responseType: "array-buffer", signal: t5 == null ? void 0 : t5.signal }), r6 = P(e4).toUpperCase();
    if ("JPG" !== r6 && "PNG" !== r6 && "GIF" !== r6 && "BMP" !== r6)
      throw new s2("image-aux-raster:open", "the data is not a supported format");
    this._set("datasetFormat", r6);
    const a4 = r6.toLowerCase(), o5 = "gif" === a4 || "bmp" === a4 || !has("ios");
    return await this.decodePixelBlock(e4, { format: a4, useCanvas: o5, hasNoZlibMask: true });
  }
  async _fetchAuxiliaryData(t5) {
    var _a, _b;
    const s4 = e(t5 == null ? void 0 : t5.signal), o5 = (_a = this.ioConfig.skipExtensions) != null ? _a : [], i5 = o5.includes("aux.xml") ? null : this.request(this.url + ".aux.xml", { responseType: "xml", signal: s4 }), n10 = this.datasetFormat, m8 = "JPG" === n10 ? "jgw" : "PNG" === n10 ? "pgw" : "BMP" === n10 ? "bpw" : null, p6 = m8 && o5.includes(m8) ? null : this.request(this.url.slice(0, this.url.lastIndexOf(".")) + "." + m8, { responseType: "text", signal: s4 }), c10 = await E([i5, p6]);
    if (s4 == null ? void 0 : s4.aborted)
      throw a();
    const u5 = p5((_b = c10[0].value) == null ? void 0 : _b.data);
    if (!u5.transform) {
      const t6 = c10[1].value ? c10[1].value.data.split("\n").slice(0, 6).map((t7) => Number(t7)) : null;
      u5.transform = 6 === (t6 == null ? void 0 : t6.length) ? new m6({ forwardCoefficients: [t6[4], t6[5], t6[0], -t6[1], t6[2], -t6[3]] }) : null;
    }
    return u5;
  }
};
e2([y({ type: String, json: { write: true } })], d5.prototype, "datasetFormat", void 0), d5 = e2([n("esri.layers.support.rasterDatasets.ImageAuxRaster")], d5);
var y4 = d5;

// node_modules/@arcgis/core/layers/support/rasterDatasets/ImageServerRaster.js
var I2 = class extends U3 {
  constructor() {
    super(...arguments), this._levelOffset = 0, this._tilemapCache = null, this._slices = null, this.datasetFormat = "RasterTileServer", this.tileType = null;
  }
  async open(e4) {
    var _a, _b, _c, _d;
    await this.init();
    const r6 = e4 && e4.signal, a4 = this.sourceJSON ? { data: this.sourceJSON } : await this.request(this.url, { query: { f: "json" }, signal: r6 });
    a4.ssl && (this.url = this.url.replace(/^http:/i, "https:"));
    const o5 = a4.data;
    if (this.sourceJSON = o5, !o5)
      throw new s2("imageserverraster:open", "cannot initialize tiled image service, missing service info");
    if (!o5.tileInfo)
      throw new s2("imageserverraster:open", "use ImageryLayer to open non-tiled image services");
    this._fixScaleInServiceInfo();
    const n10 = ["jpg", "jpeg", "png", "png8", "png24", "png32", "mixed"];
    this.tileType = o5.cacheType, null == this.tileType && (n10.includes(o5.tileInfo.format.toLowerCase()) ? this.tileType = "Map" : "lerc" === o5.tileInfo.format.toLowerCase() ? this.tileType = "Elevation" : this.tileType = "Raster"), this.datasetName = (_b = (_a = o5.name) == null ? void 0 : _a.slice(o5.name.indexOf("/") + 1)) != null ? _b : "";
    const c10 = await this._fetchRasterInfo({ signal: r6 });
    if (t(c10))
      throw new s2("image-server-raster:open", "cannot initialize image service");
    const u5 = "Map" === this.tileType ? n3(o5.tileInfo, o5) : j2.fromJSON(o5.tileInfo);
    c(u5);
    const [y5, d6] = this._computeMinMaxLOD(c10, u5), { extent: x4, pixelSize: g4 } = c10, v5 = 0.5 / c10.width * g4.x, S4 = Math.max(g4.x, g4.y), { lods: I4 } = u5;
    ("Map" !== this.tileType && 0 !== o5.maxScale || Math.abs(g4.x - g4.y) > v5 || !I4.some((e5) => Math.abs(e5.resolution - S4) < v5)) && (g4.x = g4.y = y5.resolution, c10.width = Math.ceil((x4.xmax - x4.xmin) / g4.x - 0.1), c10.height = Math.ceil((x4.ymax - x4.ymin) / g4.y - 0.1));
    const w7 = y5.level - d6.level, [j6, T5] = u5.size, b5 = [];
    I4.forEach((e5) => {
      e5.level >= d6.level && e5.level <= y5.level && b5.push({ x: e5.resolution, y: e5.resolution });
    }), b5.sort((e5, t5) => e5.x - t5.x);
    const _ = this.computeBlockBoundary(x4, j6, T5, u5.origin, b5, w7), M = b5.length > 1 ? b5.slice(1) : null;
    let R3;
    if (o5.transposeInfo && (R3 = { tileSize: [o5.transposeInfo.rows, o5.transposeInfo.cols], packetSize: (_d = (_c = c10.keyProperties) == null ? void 0 : _c._yxs.PacketSize) != null ? _d : 0 }), c10.storageInfo = new n4({ blockWidth: u5.size[0], blockHeight: u5.size[1], pyramidBlockWidth: u5.size[0], pyramidBlockHeight: u5.size[1], pyramidResolutions: M, compression: u5.format, origin: u5.origin, firstPyramidLevel: 1, maximumPyramidLevel: w7, tileInfo: u5, transposeInfo: R3, blockBoundary: _ }), this._fixGCSShift(c10), this._set("rasterInfo", c10), o5.capabilities.toLowerCase().includes("tilemap")) {
      const e5 = { tileInfo: c10.storageInfo.tileInfo, parsedUrl: j(this.url), url: this.url, tileServers: [], type: "tile" };
      this._tilemapCache = new z({ layer: e5 });
    }
  }
  async fetchRawTile(e4, t5, i5, s4 = {}) {
    const { storageInfo: a4, extent: l6 } = this.rasterInfo, { transposeInfo: o5 } = a4, n10 = r(o5) && !!s4.transposedVariableName;
    if (this._slices && !n10 && null == s4.sliceId)
      return null;
    const c10 = n10 ? 0 : a4.maximumPyramidLevel - e4 + this._levelOffset, m8 = `${this.url}/tile/${c10}/${t5}/${i5}`, h3 = this._slices ? n10 ? { variable: s4.transposedVariableName } : { sliceId: s4.sliceId || 0 } : null, { data: f9 } = await this.request(m8, { query: h3, responseType: "array-buffer", signal: s4.signal });
    if (!f9)
      return null;
    const p6 = n10 ? o5.tileSize : a4.tileInfo.size, u5 = await this.decodePixelBlock(f9, { width: p6[0], height: p6[1], planes: null, pixelType: null, isPoint: "Elevation" === this.tileType, returnInterleaved: n10 }), d6 = a4.blockBoundary[e4];
    if ("jpg" !== a4.compression || i5 > d6.minCol && i5 < d6.maxCol && t5 > d6.minRow && t5 < d6.maxRow)
      return u5;
    const { origin: x4, blockWidth: g4, blockHeight: v5 } = a4, { x: S4, y: I4 } = this.getPyramidPixelSize(e4), w7 = Math.round((l6.xmin - x4.x) / S4) % g4, j6 = Math.round((l6.xmax - x4.x) / S4) % g4 || g4, T5 = Math.round((x4.y - l6.ymax) / I4) % v5, b5 = Math.round((x4.y - l6.ymin) / I4) % v5 || v5, _ = i5 === d6.minCol ? w7 : 0, M = t5 === d6.minRow ? T5 : 0, R3 = i5 === d6.maxCol ? j6 : g4, z2 = t5 === d6.maxRow ? b5 : v5;
    return b2(u5, { x: _, y: M }, { width: R3 - _, height: z2 - M }), u5;
  }
  getSliceIndex(e4) {
    if (!this._slices || t(e4) || 0 === e4.length)
      return null;
    const t5 = e4;
    for (let i5 = 0; i5 < this._slices.length; i5++) {
      const e5 = this._slices[i5].multidimensionalDefinition;
      if (e5.length === t5.length && !e5.some((e6) => {
        const i6 = t5.find((t6) => e6.variableName === t6.variableName && t6.dimensionName === e6.dimensionName);
        if (!i6)
          return true;
        return (Array.isArray(e6.values[0]) ? `${e6.values[0][0]}-${e6.values[0][1]}` : e6.values[0]) !== (Array.isArray(i6.values[0]) ? `${i6.values[0][0]}-${i6.values[0][1]}` : i6.values[0]);
      }))
        return i5;
    }
    return null;
  }
  async fetchVariableStatisticsHistograms(e4, t5) {
    const i5 = this.request(this.url + "/statistics", { query: { variable: e4, f: "json" }, signal: t5 }).then((e5) => {
      var _a;
      return (_a = e5.data) == null ? void 0 : _a.statistics;
    }), s4 = this.request(this.url + "/histograms", { query: { variable: e4, f: "json" }, signal: t5 }).then((e5) => {
      var _a;
      return (_a = e5.data) == null ? void 0 : _a.histograms;
    }), r6 = await Promise.all([i5, s4]);
    return r6[0] && r6[0].forEach((e5) => {
      e5.avg = e5.mean, e5.stddev = e5.standardDeviation;
    }), { statistics: r6[0] || null, histograms: r6[1] || null };
  }
  async computeBestPyramidLevelForLocation(e4, t5 = {}) {
    if (!this._tilemapCache)
      return 0;
    let i5 = this.identifyPixelLocation(e4, 0, e(t5.datumTransformation));
    if (null === i5)
      return null;
    let s4 = 0;
    const { maximumPyramidLevel: r6 } = this.rasterInfo.storageInfo;
    let l6 = r6 - s4 + this._levelOffset;
    const o5 = i5.srcLocation;
    for (; l6 >= 0; ) {
      try {
        if ("available" === await this._tilemapCache.fetchAvailability(l6, i5.row, i5.col, t5))
          break;
      } catch {
      }
      if (l6--, s4++, i5 = this.identifyPixelLocation(o5, s4, e(t5.datumTransformation)), null === i5)
        return null;
    }
    return -1 === l6 || null == i5 ? null : s4;
  }
  async _fetchRasterInfo(e4) {
    const t5 = this.sourceJSON;
    if ("Map" === this.tileType) {
      const e5 = t5.fullExtent || t5.extent, i6 = Math.ceil((e5.xmax - e5.xmin) / t5.pixelSizeX - 0.1), s5 = Math.ceil((e5.ymax - e5.ymin) / t5.pixelSizeY - 0.1), r7 = k.fromJSON(t5.spatialReference || e5.spatialReference), a5 = new w2({ x: t5.pixelSizeX, y: t5.pixelSizeY, spatialReference: r7 });
      return new u2({ width: i6, height: s5, bandCount: 3, extent: w3.fromJSON(e5), spatialReference: r7, pixelSize: a5, pixelType: "u8", statistics: null, keyProperties: { DataType: "processed" } });
    }
    const { signal: i5 } = e4, s4 = m4(this.url, this.sourceJSON, { signal: i5, query: this.ioConfig.customFetchParameters }), r6 = t5.hasMultidimensions ? this.request(`${this.url}/slices`, { query: { f: "json" }, signal: i5 }).then((e5) => e5.data && e5.data.slices).catch(() => null) : null, a4 = await Promise.all([s4, r6]);
    return this._slices = a4[1], a4[0];
  }
  _fixScaleInServiceInfo() {
    const { sourceJSON: e4 } = this;
    e4.minScale && e4.minScale < 0 && (e4.minScale = 0), e4.maxScale && e4.maxScale < 0 && (e4.maxScale = 0);
  }
  _fixGCSShift(e4) {
    const { extent: t5, spatialReference: i5 } = e4;
    t5.xmin > -1 && t5.xmax > 181 && (i5 == null ? void 0 : i5.wkid) && i5.isGeographic && (e4.nativeExtent = e4.extent, e4.transform = new c6(), e4.extent = e4.transform.forwardTransform(t5));
  }
  _computeMinMaxLOD(e4, t5) {
    var _a, _b, _c;
    const { pixelSize: i5 } = e4, s4 = 0.5 / e4.width * i5.x, { lods: r6 } = t5, a4 = t5.lodAt(Math.max.apply(null, r6.map((e5) => e5.level))), l6 = t5.lodAt(Math.min.apply(null, r6.map((e5) => e5.level))), { tileType: o5 } = this;
    if ("Map" === o5)
      return this._levelOffset = r6[0].level, [a4, l6];
    if ("Raster" === o5) {
      return [(_a = r6.find((e5) => e5.resolution === i5.x)) != null ? _a : a4, l6];
    }
    const { minScale: n10, maxScale: c10 } = this.sourceJSON;
    let m8 = a4;
    c10 > 0 && (m8 = r6.find((e5) => Math.abs(e5.scale - c10) < s4), m8 || (m8 = (_b = r6.filter((e5) => e5.scale > c10).sort((e5, t6) => e5.scale > t6.scale ? 1 : -1)[0]) != null ? _b : a4));
    let h3 = l6;
    return n10 > 0 && (h3 = (_c = r6.find((e5) => Math.abs(e5.scale - n10) < s4)) != null ? _c : l6, this._levelOffset = h3.level - l6.level), [m8, h3];
  }
};
e2([y({ type: String, json: { write: true } })], I2.prototype, "datasetFormat", void 0), e2([y()], I2.prototype, "tileType", void 0), I2 = e2([n("esri.layers.support.rasterDatasets.ImageServerRaster")], I2);
var w6 = I2;

// node_modules/@arcgis/core/layers/support/rasterDatasets/MRFRaster.js
var I3 = /* @__PURE__ */ new Map();
I3.set("Int8", "s8"), I3.set("UInt8", "u8"), I3.set("Int16", "s16"), I3.set("UInt16", "u16"), I3.set("Int32", "s32"), I3.set("UInt32", "u32"), I3.set("Float32", "f32"), I3.set("Float64", "f32"), I3.set("Double64", "f32");
var b4 = /* @__PURE__ */ new Map();
b4.set("none", { blobExtension: ".til", isOneSegment: true, decoderFormat: "bip" }), b4.set("lerc", { blobExtension: ".lrc", isOneSegment: false, decoderFormat: "lerc" }), b4.set("deflate", { blobExtension: ".pzp", isOneSegment: true, decoderFormat: "deflate" }), b4.set("jpeg", { blobExtension: ".pjg", isOneSegment: true, decoderFormat: "jpg" });
var A = class extends U3 {
  constructor() {
    super(...arguments), this._files = null, this._storageIndex = null, this.datasetFormat = "MRF";
  }
  async open(t5) {
    var _a, _b;
    await this.init(), this.datasetName = this.url.slice(this.url.lastIndexOf("/") + 1);
    const e4 = t5 ? e(t5.signal) : null, o5 = await this.request(this.url, { responseType: "xml", signal: e4 }), { rasterInfo: i5, files: a4 } = this._parseHeader(o5.data);
    if (-1 === ((_a = this.ioConfig.skipExtensions) == null ? void 0 : _a.indexOf("aux.xml"))) {
      const e5 = await this._fetchAuxiliaryData(t5);
      null != e5 && (i5.statistics = (_b = e5.statistics) != null ? _b : i5.statistics, i5.histograms = e5.histograms, e5.histograms && t(i5.statistics) && (i5.statistics = g3(e5.histograms)));
    }
    this._set("rasterInfo", i5), this._files = a4;
    const n10 = await this.request(a4.index, { responseType: "array-buffer", signal: e4 });
    this._storageIndex = this._parseIndex(n10.data);
    const { blockWidth: l6, blockHeight: f9 } = this.rasterInfo.storageInfo, c10 = this.rasterInfo.storageInfo.pyramidScalingFactor, { width: m8, height: p6 } = this.rasterInfo, h3 = [], u5 = this._getBandSegmentCount();
    let g4 = 0, y5 = -1;
    for (; g4 < this._storageIndex.length; ) {
      y5++;
      const t6 = Math.ceil(m8 / l6 / c10 ** y5) - 1, e5 = Math.ceil(p6 / f9 / c10 ** y5) - 1;
      g4 += (t6 + 1) * (e5 + 1) * u5 * 4, h3.push({ maxRow: e5, maxCol: t6, minCol: 0, minRow: 0 });
    }
    this.rasterInfo.storageInfo.blockBoundary = h3, y5 > 0 && (this.rasterInfo.storageInfo.firstPyramidLevel = 1, this.rasterInfo.storageInfo.maximumPyramidLevel = y5), this.updateTileInfo();
  }
  async fetchRawTile(t5, e4, r6, s4 = {}) {
    const { blockWidth: i5, blockHeight: a4, blockBoundary: l6 } = this.rasterInfo.storageInfo, f9 = l6[t5];
    if (!f9 || f9.maxRow < e4 || f9.maxCol < r6 || f9.minRow > e4 || f9.minCol > r6)
      return null;
    const { bandCount: c10, pixelType: m8 } = this.rasterInfo, { ranges: p6, actualTileWidth: h3, actualTileHeight: u5 } = this._getTileLocation(t5, e4, r6);
    if (!p6 || 0 === p6.length)
      return null;
    if (0 === p6[0].from && 0 === p6[0].to) {
      const t6 = new Uint8Array(i5 * a4);
      return new g({ width: i5, height: a4, pixels: null, mask: t6, validPixelCount: 0 });
    }
    const { bandIds: g4 } = this.ioConfig, d6 = this._getBandSegmentCount(), y5 = [];
    let x4 = 0;
    for (x4 = 0; x4 < d6; x4++)
      (!g4 || g4.indexOf[x4] > -1) && y5.push(this.request(this._files.data, { range: { from: p6[x4].from, to: p6[x4].to }, responseType: "array-buffer", signal: s4.signal }));
    const w7 = await Promise.all(y5), I4 = w7.map((t6) => t6.data.byteLength).reduce((t6, e5) => t6 + e5), A2 = new Uint8Array(I4);
    let F3 = 0;
    for (x4 = 0; x4 < d6; x4++)
      A2.set(new Uint8Array(w7[x4].data), F3), F3 += w7[x4].data.byteLength;
    const _ = b4.get(this.rasterInfo.storageInfo.compression).decoderFormat, R3 = await this.decodePixelBlock(A2.buffer, { width: i5, height: a4, format: _, planes: (g4 == null ? void 0 : g4.length) || c10, pixelType: m8 });
    if (r(this.rasterInfo.noDataValue) && "lerc" !== _ && !R3.mask) {
      const t6 = this.rasterInfo.noDataValue[0];
      if (null != t6) {
        const e5 = R3.width * R3.height, r7 = new Uint8Array(e5);
        if (Math.abs(t6) > 1e24)
          for (x4 = 0; x4 < e5; x4++)
            Math.abs((R3.pixels[0][x4] - t6) / t6) > 1e-6 && (r7[x4] = 1);
        else
          for (x4 = 0; x4 < e5; x4++)
            R3.pixels[0][x4] !== t6 && (r7[x4] = 1);
        R3.mask = r7;
      }
    }
    let S4 = 0, j6 = 0;
    if (h3 !== i5 || u5 !== a4) {
      let t6 = R3.mask;
      if (t6)
        for (x4 = 0; x4 < a4; x4++)
          if (j6 = x4 * i5, x4 < u5)
            for (S4 = h3; S4 < i5; S4++)
              t6[j6 + S4] = 0;
          else
            for (S4 = 0; S4 < i5; S4++)
              t6[j6 + S4] = 0;
      else
        for (t6 = new Uint8Array(i5 * a4), R3.mask = t6, x4 = 0; x4 < u5; x4++)
          for (j6 = x4 * i5, S4 = 0; S4 < h3; S4++)
            t6[j6 + S4] = 1;
    }
    return R3;
  }
  _parseIndex(t5) {
    if (t5.byteLength % 16 > 0)
      throw "invalid array buffer must be multiples of 16";
    let e4, r6, s4, o5, i5, a4;
    if (r4) {
      for (r6 = new Uint8Array(t5), o5 = new ArrayBuffer(t5.byteLength), s4 = new Uint8Array(o5), i5 = 0; i5 < t5.byteLength / 4; i5++)
        for (a4 = 0; a4 < 4; a4++)
          s4[4 * i5 + a4] = r6[4 * i5 + 3 - a4];
      e4 = new Uint32Array(o5);
    } else
      e4 = new Uint32Array(t5);
    return e4;
  }
  _getBandSegmentCount() {
    return b4.get(this.rasterInfo.storageInfo.compression).isOneSegment ? 1 : this.rasterInfo.bandCount;
  }
  _getTileLocation(t5, e4, r6) {
    const { blockWidth: s4, blockHeight: o5, pyramidScalingFactor: i5 } = this.rasterInfo.storageInfo, { width: a4, height: n10 } = this.rasterInfo, l6 = this._getBandSegmentCount();
    let f9, c10, m8, p6 = 0, h3 = 0;
    for (m8 = 0; m8 < t5; m8++)
      h3 = i5 ** m8, f9 = Math.ceil(a4 / s4 / h3), c10 = Math.ceil(n10 / o5 / h3), p6 += f9 * c10;
    h3 = i5 ** t5, f9 = Math.ceil(a4 / s4 / h3), c10 = Math.ceil(n10 / o5 / h3), p6 += e4 * f9 + r6, p6 *= 4 * l6;
    const u5 = this._storageIndex.subarray(p6, p6 + 4 * l6);
    let g4 = 0, d6 = 0;
    const y5 = [];
    for (let x4 = 0; x4 < l6; x4++)
      g4 = u5[4 * x4 + 0] * 2 ** 32 + u5[4 * x4 + 1], d6 = g4 + u5[4 * x4 + 2] * 2 ** 32 + u5[4 * x4 + 3], y5.push({ from: g4, to: d6 });
    return { ranges: y5, actualTileWidth: r6 < f9 - 1 ? s4 : Math.ceil(a4 / h3) - s4 * (f9 - 1), actualTileHeight: e4 < c10 - 1 ? o5 : Math.ceil(n10 / h3) - o5 * (c10 - 1) };
  }
  _parseHeader(t5) {
    var _a;
    const r6 = e3(t5, "MRF_META/Raster");
    if (!r6)
      throw new s2("mrf:open", "not a valid MRF format");
    const s4 = e3(r6, "Size"), o5 = parseInt(s4.getAttribute("x"), 10), i5 = parseInt(s4.getAttribute("y"), 10), a4 = parseInt(s4.getAttribute("c"), 10), n10 = (t4(r6, "Compression") || "none").toLowerCase();
    if (!b4.has(n10))
      throw new s2("mrf:open", "currently does not support compression " + n10);
    const c10 = t4(r6, "DataType") || "UInt8", p6 = I3.get(c10);
    if (null == p6)
      throw new s2("mrf:open", "currently does not support pixel type " + c10);
    const g4 = e3(r6, "PageSize"), d6 = parseInt(g4.getAttribute("x"), 10), A2 = parseInt(g4.getAttribute("y"), 10), F3 = e3(r6, "DataValues");
    let _, R3;
    F3 && (R3 = F3.getAttribute("NoData"), null != R3 && (_ = R3.trim().split(" ").map((t6) => parseFloat(t6))));
    if (e3(t5, "MRF_META/CachedSource"))
      throw new s2("mrf:open", "currently does not support MRF referencing other data files");
    const S4 = e3(t5, "MRF_META/GeoTags"), j6 = e3(S4, "BoundingBox");
    let k3, M = false;
    if (null != j6) {
      const t6 = parseFloat(j6.getAttribute("minx")), e4 = parseFloat(j6.getAttribute("miny")), r7 = parseFloat(j6.getAttribute("maxx")), s5 = parseFloat(j6.getAttribute("maxy")), o6 = t4(S4, "Projection") || "";
      let i6 = k.WGS84;
      if ("LOCAL_CS[]" !== o6)
        if (o6.toLowerCase().startsWith("epsg:")) {
          const t7 = Number(o6.slice(5));
          isNaN(t7) || 0 === t7 || (i6 = new k({ wkid: t7 }));
        } else
          i6 = (_a = m7(o6)) != null ? _a : k.WGS84;
      else
        M = true, i6 = new k({ wkid: 3857 });
      k3 = new w3(t6, e4, r7, s5), k3.spatialReference = i6;
    } else
      M = true, k3 = new w3({ xmin: -0.5, ymin: 0.5 - i5, xmax: o5 - 0.5, ymax: 0.5, spatialReference: new k({ wkid: 3857 }) });
    const T5 = e3(t5, "MRF_META/Rsets"), C2 = parseInt(T5 && T5.getAttribute("scale") || "2", 10), U4 = k3.spatialReference, B = new n4({ origin: new w2({ x: k3.xmin, y: k3.ymax, spatialReference: U4 }), blockWidth: d6, blockHeight: A2, pyramidBlockWidth: d6, pyramidBlockHeight: A2, compression: n10, pyramidScalingFactor: C2 }), L2 = new w2({ x: k3.width / o5, y: k3.height / i5, spatialReference: U4 }), E3 = new u2({ width: o5, height: i5, extent: k3, isPseudoSpatialReference: M, spatialReference: U4, bandCount: a4, pixelType: p6, pixelSize: L2, noDataValue: _, storageInfo: B }), P2 = t4(t5, "datafile"), O3 = t4(t5, "IndexFile");
    return { rasterInfo: E3, files: { mrf: this.url, index: O3 || this.url.replace(".mrf", ".idx"), data: P2 || this.url.replace(".mrf", b4.get(n10).blobExtension) } };
  }
  async _fetchAuxiliaryData(t5) {
    try {
      const { data: e4 } = await this.request(this.url + ".aux.xml", { responseType: "xml", signal: t5 == null ? void 0 : t5.signal });
      return p5(e4);
    } catch {
      return null;
    }
  }
};
e2([y()], A.prototype, "_files", void 0), e2([y()], A.prototype, "_storageIndex", void 0), e2([y({ type: String, json: { write: true } })], A.prototype, "datasetFormat", void 0), A = e2([n("esri.layers.support.rasterIO.MRFRaster")], A);
var F = A;

// node_modules/@arcgis/core/layers/support/rasterDatasets/TIFFRaster.js
var E2 = (e4, t5) => {
  var _a;
  return (_a = e4.get(t5)) == null ? void 0 : _a.values;
};
var F2 = (e4, t5) => {
  var _a, _b;
  return (_b = (_a = e4.get(t5)) == null ? void 0 : _a.values) == null ? void 0 : _b[0];
};
var R2 = class extends U3 {
  constructor() {
    super(...arguments), this._files = null, this._headerInfo = null, this._bufferSize = 1048576, this.datasetFormat = "TIFF";
  }
  async open(e4) {
    await this.init();
    const s4 = e4 ? e(e4.signal) : null, { data: a4 } = await this.request(this.url, { range: { from: 0, to: this._bufferSize }, responseType: "array-buffer", signal: s4 });
    if (!a4)
      throw new s2("tiffraster:open", "failed to open url " + this.url);
    this.datasetName = this.url.slice(this.url.lastIndexOf("/") + 1);
    const { littleEndian: n10, firstIFDPos: o5, isBigTiff: f9 } = N(a4), l6 = [];
    await this._readIFDs(l6, a4, n10, o5, 0, f9 ? 8 : 4, s4);
    const { imageInfo: u5, rasterInfo: p6 } = this._parseIFDs(l6);
    if (this._headerInfo = { littleEndian: n10, isBigTiff: f9, ifds: l6, ...u5 }, this._set("rasterInfo", p6), !u5.isSupported)
      throw new s2("tiffraster:open", "this tiff is not supported: " + u5.message);
    if (!u5.tileWidth)
      throw new s2("tiffraster:open", "none-tiled tiff is not optimized for access, convert to COG and retry.");
    const { skipExtensions: m8 = [] } = this.ioConfig;
    if (!m8.includes("aux.xml")) {
      const t5 = await this._fetchAuxiliaryMetaData(e4);
      null != t5 && this._processPAMInfo(t5, p6);
    }
    m8.includes("vat.dbf") || 1 !== p6.bandCount || "u8" !== p6.pixelType || (p6.attributeTable = await this._fetchAuxiliaryTable(e4), r(p6.attributeTable) && (p6.keyProperties.DataType = "thematic")), this.updateTileInfo();
  }
  async fetchRawTile(e4, t5, r6, i5 = {}) {
    var _a;
    if (!((_a = this._headerInfo) == null ? void 0 : _a.isSupported) || this.isBlockOutside(e4, t5, r6))
      return null;
    const s4 = this._getTileLocation(e4, t5, r6);
    if (!s4)
      return null;
    const { ranges: a4, actualTileWidth: n10, actualTileHeight: o5, ifd: f9 } = s4, l6 = a4.map((e5) => this.request(this.url, { range: e5, responseType: "array-buffer", signal: i5.signal })), u5 = await Promise.all(l6), p6 = u5.map((e5) => e5.data.byteLength).reduce((e5, t6) => e5 + t6), m8 = 1 === u5.length ? u5[0].data : new ArrayBuffer(p6), c10 = [0], h3 = [0];
    if (u5.length > 1) {
      const e5 = new Uint8Array(m8);
      for (let t6 = 0, r7 = 0; t6 < u5.length; t6++) {
        const i6 = u5[t6].data;
        e5.set(new Uint8Array(i6), r7), c10[t6] = r7, r7 += i6.byteLength, h3[t6] = i6.byteLength;
      }
    }
    const { blockWidth: d6, blockHeight: y5 } = this.getBlockWidthHeight(e4), g4 = await this.decodePixelBlock(m8, { format: "tiff", customOptions: { headerInfo: this._headerInfo, ifd: f9, offsets: c10, sizes: h3 }, width: d6, height: y5, planes: null, pixelType: null });
    let x4, T5, I4;
    if (n10 !== d6 || o5 !== y5) {
      let e5 = g4.mask;
      if (e5)
        for (x4 = 0; x4 < y5; x4++)
          if (I4 = x4 * d6, x4 < o5)
            for (T5 = n10; T5 < d6; T5++)
              e5[I4 + T5] = 0;
          else
            for (T5 = 0; T5 < d6; T5++)
              e5[I4 + T5] = 0;
      else
        for (e5 = new Uint8Array(d6 * y5), g4.mask = e5, x4 = 0; x4 < o5; x4++)
          for (I4 = x4 * d6, T5 = 0; T5 < n10; T5++)
            e5[I4 + T5] = 1;
    }
    return g4;
  }
  _parseIFDs(e4) {
    var _a, _b;
    const t5 = D2(e4), { width: r6, height: i5, tileWidth: s4, tileHeight: a4, planes: n10, pixelType: l6, compression: u5, firstPyramidLevel: m8, maximumPyramidLevel: c10, pyramidBlockWidth: d6, pyramidBlockHeight: y5, tileBoundary: g4, affine: x4, metadata: T5 } = t5, w7 = ((_a = t5.extent.spatialReference) == null ? void 0 : _a.wkt) || ((_b = t5.extent.spatialReference) == null ? void 0 : _b.wkid);
    let R3 = m7(w7), v5 = false;
    null == R3 && (v5 = true, R3 = new k({ wkid: 3857 }));
    const k3 = new w3({ ...t5.extent, spatialReference: R3 }), D3 = new w2(k3 ? { x: k3.xmin, y: k3.ymax, spatialReference: R3 } : { x: 0, y: 0 }), j6 = new n4({ blockWidth: s4, blockHeight: a4, pyramidBlockWidth: d6, pyramidBlockHeight: y5, compression: u5, origin: D3, firstPyramidLevel: m8, maximumPyramidLevel: c10, blockBoundary: g4 }), O3 = new w2({ x: (k3.xmax - k3.xmin) / r6, y: (k3.ymax - k3.ymin) / i5, spatialReference: R3 }), P2 = T5 ? { BandProperties: T5.bandProperties, DataType: T5.dataType } : {};
    let B = null;
    const L2 = F2(e4[0], "PHOTOMETRICINTERPRETATION"), A2 = E2(e4[0], "COLORMAP");
    if (3 === L2 && (A2 == null ? void 0 : A2.length) > 3 && A2.length % 3 == 0) {
      B = [];
      const e5 = A2.length / 3;
      for (let t6 = 0; t6 < e5; t6++)
        B.push([t6, A2[t6] >>> 8, A2[t6 + e5] >>> 8, A2[t6 + 2 * e5] >>> 8]);
    }
    const z2 = new u2({ width: r6, height: i5, bandCount: n10, pixelType: l6, pixelSize: O3, storageInfo: j6, spatialReference: R3, isPseudoSpatialReference: v5, keyProperties: P2, extent: k3, colormap: B, statistics: T5 ? T5.statistics : null });
    return (x4 == null ? void 0 : x4.length) && (z2.nativeExtent = new w3({ xmin: -0.5, ymin: 0.5 - i5, xmax: r6 - 0.5, ymax: 0.5, spatialReference: R3 }), z2.transform = new m6({ polynomialOrder: 1, forwardCoefficients: [x4[2] + x4[0] / 2, x4[5] - x4[3] / 2, x4[0], x4[3], -x4[1], -x4[4]] }), z2.extent = z2.transform.forwardTransform(z2.nativeExtent), z2.pixelSize = new w2({ x: (k3.xmax - k3.xmin) / r6, y: (k3.ymax - k3.ymin) / i5, spatialReference: R3 }), j6.origin.x = -0.5, j6.origin.y = 0.5), { imageInfo: t5, rasterInfo: z2 };
  }
  _processPAMInfo(e4, t5) {
    var _a;
    if (t5.statistics = (_a = e4.statistics) != null ? _a : t5.statistics, t5.histograms = e4.histograms, e4.histograms && t(t5.statistics) && (t5.statistics = g3(e4.histograms)), e4.transform && t(t5.transform)) {
      t5.transform = e4.transform, t5.nativeExtent = t5.extent;
      const r6 = t5.transform.forwardTransform(t5.nativeExtent);
      t5.pixelSize = new w2({ x: (r6.xmax - r6.xmin) / t5.width, y: (r6.ymax - r6.ymin) / t5.height, spatialReference: t5.spatialReference }), t5.extent = r6;
    }
    t5.spatialReference || (t5.spatialReference = e4.spatialReference);
  }
  async _readIFDs(e4, t5, r6, i5, s4, a4 = 4, n10) {
    if (!i5)
      return null;
    if (i5 >= t5.byteLength || i5 < 0) {
      t5 = (await this.request(this.url, { range: { from: i5 + s4, to: i5 + s4 + this._bufferSize }, responseType: "array-buffer", signal: n10 })).data, s4 = i5 + s4, i5 = 0;
    }
    const o5 = await this._readIFD(t5, r6, i5, s4, n6.TIFF_TAGS, a4, n10);
    if (e4.push(o5.ifd), !o5.nextIFD)
      return null;
    await this._readIFDs(e4, t5, r6, o5.nextIFD - s4, s4, a4, n10);
  }
  async _readIFD(e4, t5, r6, s4, a4 = n6.TIFF_TAGS, n10 = 4, o5) {
    var _a, _b;
    if (!e4)
      return null;
    const f9 = G(e4, t5, r6, s4, a4, n10);
    if (f9.success) {
      const r7 = [];
      if ((_a = f9.ifd) == null ? void 0 : _a.forEach((e5) => {
        e5.values || r7.push(e5);
      }), r7.length > 0) {
        const a5 = r7.map((e5) => e5.offlineOffsetSize).filter(r), n11 = Math.min.apply(null, a5.map((e5) => e5[0]));
        if (Math.min.apply(null, a5.map((e5) => e5[0] + e5[1])) - n11 <= this._bufferSize) {
          const { data: i5 } = await this.request(this.url, { range: { from: n11, to: n11 + this._bufferSize }, responseType: "array-buffer", signal: o5 });
          e4 = i5, s4 = n11, r7.forEach((r8) => b3(e4, t5, r8, s4));
        }
      }
      if ((_b = f9.ifd) == null ? void 0 : _b.has("GEOKEYDIRECTORY")) {
        const r8 = f9.ifd.get("GEOKEYDIRECTORY"), i5 = r8 == null ? void 0 : r8.values;
        if (i5 && i5.length > 4) {
          const a5 = i5[0] + "." + i5[1] + "." + i5[2], n11 = await this._readIFD(e4, t5, r8.valueOffset + 6 - s4, s4, n6.GEO_KEYS, 2, o5);
          r8.data = n11.ifd, r8.data && r8.data.set("GEOTIFFVersion", { id: 0, type: 2, valueCount: 1, valueOffset: null, values: [a5] });
        }
      }
      return f9;
    }
    if (f9.requiredBufferSize && f9.requiredBufferSize !== e4.byteLength) {
      const r7 = await this.request(this.url, { range: { from: s4, to: s4 + f9.requiredBufferSize + 4 }, responseType: "array-buffer", signal: o5 });
      return (e4 = r7.data).byteLength < f9.requiredBufferSize ? null : this._readIFD(e4, t5, 0, s4, n6.TIFF_TAGS, 4, o5);
    }
  }
  _getTileLocation(e4, t5, r6) {
    var _a;
    const { firstPyramidLevel: i5, blockBoundary: s4 } = this.rasterInfo.storageInfo, a4 = 0 === e4 ? 0 : e4 - (i5 - 1), n10 = (_a = this._headerInfo) == null ? void 0 : _a.ifds[a4];
    if (!n10)
      return null;
    const o5 = O2(n10, this._headerInfo), f9 = E2(n10, "TILEOFFSETS");
    if (void 0 === f9)
      return null;
    const l6 = E2(n10, "TILEBYTECOUNTS"), { minRow: u5, minCol: p6, maxRow: m8, maxCol: c10 } = s4[a4];
    if (t5 > m8 || r6 > c10 || t5 < u5 || r6 < p6)
      return null;
    const h3 = F2(n10, "IMAGEWIDTH"), d6 = F2(n10, "IMAGELENGTH"), y5 = F2(n10, "TILEWIDTH"), x4 = F2(n10, "TILELENGTH"), T5 = o5 ? this.rasterInfo.bandCount : 1, I4 = T5 * t5 * (c10 + 1) + r6, w7 = [{ from: f9[I4], to: f9[I4 + T5 - 1] + l6[I4 + T5 - 1] - 1 }];
    if (o5) {
      let e5 = true;
      for (let t6 = 0; t6 < T5; t6++)
        if (f9[I4 + t6] + l6[I4 + t6] !== f9[I4 + t6 + 1]) {
          e5 = false;
          break;
        }
      if (!e5)
        for (let t6 = 0; t6 < T5; t6++)
          w7[t6] = { from: f9[I4 + t6], to: f9[I4 + t6] + l6[I4 + t6] - 1 };
    }
    const b5 = f9[I4], _ = l6[I4];
    if (null == b5 || null == _)
      return null;
    return { ranges: w7, ifd: n10, actualTileWidth: r6 === c10 && h3 % y5 || y5, actualTileHeight: t5 === m8 && d6 % x4 || x4 };
  }
  async _fetchAuxiliaryMetaData(e4) {
    try {
      const { data: t5 } = await this.request(this.url + ".aux.xml", { responseType: "xml", signal: e4 == null ? void 0 : e4.signal });
      return p5(t5);
    } catch {
      return null;
    }
  }
  async _fetchAuxiliaryTable(e4) {
    try {
      const { data: t5 } = await this.request(this.url + ".vat.dbf", { responseType: "array-buffer", signal: e4 == null ? void 0 : e4.signal }), r6 = r5.parse(t5);
      return (r6 == null ? void 0 : r6.recordSet) ? x.fromJSON(r6.recordSet) : null;
    } catch {
      return null;
    }
  }
};
e2([y()], R2.prototype, "_files", void 0), e2([y()], R2.prototype, "_headerInfo", void 0), e2([y()], R2.prototype, "_bufferSize", void 0), e2([y({ type: String, json: { write: true } })], R2.prototype, "datasetFormat", void 0), R2 = e2([n("esri.layers.support.rasterDatasets.TIFFRaster")], R2);
var v4 = R2;

// node_modules/@arcgis/core/layers/support/rasterDatasets/RasterFactory.js
var c9 = /* @__PURE__ */ new Map();
c9.set("CRF", { desc: "Cloud Raster Format", constructor: I }), c9.set("MRF", { desc: "Meta Raster Format", constructor: F }), c9.set("TIFF", { desc: "GeoTIFF", constructor: v4 }), c9.set("RasterTileServer", { desc: "Raster Tile Server", constructor: w6 }), c9.set("JPG", { desc: "JPG Raster Format", constructor: y4 }), c9.set("PNG", { desc: "PNG Raster Format", constructor: y4 }), c9.set("GIF", { desc: "GIF Raster Format", constructor: y4 }), c9.set("BMP", { desc: "BMP Raster Format", constructor: y4 });
var n9 = class {
  static get supportedFormats() {
    const t5 = /* @__PURE__ */ new Set();
    return c9.forEach((e4, r6) => t5.add(r6)), t5;
  }
  static async open(e4) {
    const { url: r6, ioConfig: s4, sourceJSON: o5 } = e4;
    let a4 = e4.datasetFormat;
    null == a4 && r6.lastIndexOf(".") && (a4 = r6.slice(r6.lastIndexOf(".") + 1).toUpperCase()), "OVR" === a4 || "TIF" === a4 ? a4 = "TIFF" : "JPG" !== a4 && "JPEG" !== a4 && "JFIF" !== a4 || (a4 = "JPG"), r6.toLowerCase().includes("/imageserver") && !r6.toLowerCase().includes("/wcsserver") && (a4 = "RasterTileServer");
    const n10 = { url: r6, sourceJSON: o5, datasetFormat: a4, ioConfig: s4 != null ? s4 : { bandIds: null, sampling: null } };
    let l6, i5;
    if (a4 && this.supportedFormats.has(a4)) {
      if ("CRF" === a4 && !(s4 == null ? void 0 : s4.enableCRF))
        throw new s2("rasterfactory:open", `cannot open raster: ${r6}`);
      return l6 = c9.get(a4).constructor, i5 = new l6(n10), await i5.open({ signal: e4.signal }), i5;
    }
    if (a4)
      throw new s2("rasterfactory:open", "not a supported format " + a4);
    const u5 = Array.from(c9.keys());
    let F3 = 0;
    const m8 = () => (a4 = u5[F3++], a4 && ("CRF" !== a4 || (s4 == null ? void 0 : s4.enableCRF)) ? (l6 = c9.get(a4).constructor, i5 = new l6(n10), i5.open({ signal: e4.signal }).then(() => i5).catch(() => m8())) : null);
    return m8();
  }
  static register(t5, e4, r6) {
    c9.has(t5.toUpperCase()) || c9.set(t5.toUpperCase(), { desc: e4, constructor: r6 });
  }
};

// node_modules/@arcgis/core/layers/ImageryTileLayer.js
var N3 = class extends n2(t2(c3(v3(o2(N2(a2(p(O(b))))))))) {
  constructor(...e4) {
    super(...e4), this.bandIds = null, this.interpolation = null, this.legendEnabled = true, this.isReference = null, this.listMode = "show", this.sourceJSON = null, this.version = null, this.title = null, this.type = "imagery-tile", this.operationalLayerType = "ArcGISTiledImageServiceLayer", this.popupEnabled = true, this.popupTemplate = null, this.fields = null;
  }
  normalizeCtorArgs(e4, r6) {
    return "string" == typeof e4 ? { url: e4, ...r6 } : e4;
  }
  load(e4) {
    const r6 = r(e4) ? e4.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Image Service"] }, e4).catch(w).then(() => this._openRaster(r6))), Promise.resolve(this);
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  get rasterFields() {
    var _a;
    let e4 = [new y2({ name: "Raster.ServicePixelValue", alias: "Pixel Value", domain: null, editable: false, length: 50, type: "string" })];
    const { rasterInfo: r6 } = this, { attributeTable: t5 } = r6, o5 = r(t5) ? t5.fields : null, i5 = "Raster.";
    if (o5) {
      const r7 = o5.filter((e5) => "oid" !== e5.type && "value" !== e5.name.toLowerCase()).map((e5) => {
        const r8 = e5.clone();
        return r8.name = i5 + e5.name, r8;
      });
      e4 = e4.concat(r7);
    }
    const { dataType: s4, multidimensionalInfo: n10 } = r6;
    if (("vector-magdir" === s4 || "vector-uv" === s4) && r(n10)) {
      const r7 = (_a = n10.variables[0].unit) == null ? void 0 : _a.trim(), t6 = "Magnitude" + (r7 ? ` (${r7})` : "");
      e4.push(new y2({ name: "Raster.Magnitude", alias: t6, domain: null, editable: false, type: "double" })), e4.push(new y2({ name: "Raster.Direction", alias: "Direction (\xB0)", domain: null, editable: false, type: "double" }));
    }
    return e4;
  }
  set renderer(e4) {
    this._set("renderer", e4), this.updateRenderer();
  }
  readRenderer(e4, r6, o5) {
    const i5 = r6 && r6.layerDefinition && r6.layerDefinition.drawingInfo && r6.layerDefinition.drawingInfo.renderer, s4 = u(i5, o5) || void 0;
    if (null != s4)
      return s4;
  }
  createPopupTemplate(e4) {
    return p2({ fields: this.rasterFields, title: this.title }, e4);
  }
  write(e4, r6) {
    const { raster: t5 } = this;
    if (this.loaded ? "RasterTileServer" === t5.datasetFormat && ("Raster" === t5.tileType || "Map" === t5.tileType) : this.url && /\/ImageServer(\/|\/?$)/i.test(this.url))
      return super.write(e4, r6);
    if (r6 && r6.messages) {
      const e5 = `${r6.origin}/${r6.layerContainerType || "operational-layers"}`;
      r6.messages.push(new s2("layer:unsupported", `Layers (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${e5}'`, { layer: this }));
    }
    return null;
  }
  async _openRaster(e4) {
    if (this.raster)
      this.raster.rasterInfo || await this.raster.open(), this.url = this.raster.url;
    else {
      const r7 = await n9.open({ url: this.url, sourceJSON: this.sourceJSON, ioConfig: { sampling: "closest", ...this.ioConfig, customFetchParameters: this.customParameters }, signal: e4 });
      if (this.rasterFunction) {
        const e5 = l4(this.rasterFunction.toJSON(), { raster: r7 }), t5 = new c7({ rasterFunction: e5 });
        await t5.open(), this.raster = t5;
      } else
        this.raster = r7;
    }
    const { rasterInfo: r6 } = this.raster;
    if (!r6)
      throw new s2("imagery-tile-layer:load", "cannot load resources on " + this.url);
    if (this.sourceJSON = this.sourceJSON || this.raster.sourceJSON, null != this.sourceJSON) {
      const e5 = "Map" === this.raster.tileType && null != this.sourceJSON.minLOD && null != this.sourceJSON.maxLOD ? this.sourceJSON : { ...this.sourceJSON, minScale: 0, maxScale: 0 };
      this.read(e5, { origin: "service" });
    }
    null == this.title && (this.title = this.raster.datasetName), "Map" === this.raster.tileType && (this.popupEnabled = false), this._configDefaultSettings(), this.addHandles(l2(() => this.customParameters, (e5) => {
      this.raster.ioConfig.customFetchParameters = e5;
    }));
  }
};
e2([y({ type: [T], json: { write: { overridePolicy() {
  var _a;
  return { enabled: !this.loaded || "Raster" === this.raster.tileType || "0,1,2" !== ((_a = this.bandIds) == null ? void 0 : _a.join(",")) };
} } } })], N3.prototype, "bandIds", void 0), e2([y({ json: { write: { overridePolicy() {
  return { enabled: !this.loaded || "Raster" === this.raster.tileType || "bilinear" !== this.interpolation };
} } } }), r2(o3)], N3.prototype, "interpolation", void 0), e2([y({ json: { write: true } })], N3.prototype, "multidimensionalDefinition", void 0), e2([y(c2)], N3.prototype, "legendEnabled", void 0), e2([y({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], N3.prototype, "isReference", void 0), e2([y({ type: ["show", "hide"] })], N3.prototype, "listMode", void 0), e2([y({ json: { read: true, write: true } })], N3.prototype, "blendMode", void 0), e2([y()], N3.prototype, "sourceJSON", void 0), e2([y({ readOnly: true, json: { origins: { service: { read: { source: "currentVersion" } } } } })], N3.prototype, "version", void 0), e2([y()], N3.prototype, "title", void 0), e2([y({ readOnly: true, json: { read: false } })], N3.prototype, "type", void 0), e2([y({ type: ["ArcGISTiledImageServiceLayer"] })], N3.prototype, "operationalLayerType", void 0), e2([y({ type: Boolean, value: true, json: { read: { source: "disablePopup", reader: (e4, r6) => !r6.disablePopup }, write: { target: "disablePopup", overridePolicy() {
  return { enabled: !this.loaded || "Raster" === this.raster.tileType };
}, writer(e4, r6, t5) {
  r6[t5] = !e4;
} } } })], N3.prototype, "popupEnabled", void 0), e2([y({ type: k2, json: { read: { source: "popupInfo" }, write: { target: "popupInfo", overridePolicy() {
  return { enabled: !this.loaded || "Raster" === this.raster.tileType };
} } } })], N3.prototype, "popupTemplate", void 0), e2([y({ readOnly: true })], N3.prototype, "defaultPopupTemplate", null), e2([y({ readOnly: true, type: [y2] })], N3.prototype, "fields", void 0), e2([y({ readOnly: true, type: [y2] })], N3.prototype, "rasterFields", null), e2([y({ types: l3, json: { name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy() {
  var _a;
  const e4 = "raster-stretch" === ((_a = this.renderer) == null ? void 0 : _a.type) && "none" === this.renderer.stretchType && !this.renderer.useGamma;
  return { enabled: !this.loaded || "Raster" === this.raster.tileType || !e4 };
} }, origins: { "web-scene": { types: i, name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy: (e4) => ({ enabled: e4 && "vector-field" !== e4.type && "flow" !== e4.type }) } } } } })], N3.prototype, "renderer", null), e2([o("renderer")], N3.prototype, "readRenderer", null), N3 = e2([n("esri.layers.ImageryTileLayer")], N3);
var J2 = N3;
export {
  J2 as default
};
//# sourceMappingURL=ImageryTileLayer-YIGKFUNW.js.map
