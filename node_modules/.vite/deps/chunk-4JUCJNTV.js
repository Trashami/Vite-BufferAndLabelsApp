import {
  a
} from "./chunk-RLIH5RCN.js";
import {
  T,
  b,
  g,
  n,
  w
} from "./chunk-QVMWXE75.js";
import {
  s as s2
} from "./chunk-BWNO4YZY.js";
import {
  x
} from "./chunk-BYSA56OH.js";
import {
  s
} from "./chunk-LIZHLHNA.js";

// node_modules/@arcgis/core/portal/support/portalLayers.js
function i(e) {
  return !e.portalItem || e.portalItem instanceof x || (e = { ...e, portalItem: new x(e.portalItem) }), l(e.portalItem).then((r) => {
    const t = { portalItem: e.portalItem, ...r.properties };
    return new (0, r.constructor)(t);
  });
}
function l(e) {
  return e.load().then(y).then(m);
}
function y(r) {
  switch (r.type) {
    case "Map Service":
      return p(r);
    case "Feature Service":
      return L(r);
    case "Feature Collection":
      return d(r);
    case "Scene Service":
      return f(r);
    case "Image Service":
      return N(r);
    case "Stream Service":
      return S();
    case "Vector Tile Service":
      return I();
    case "GeoJson":
      return h();
    case "CSV":
      return g2();
    case "KML":
      return w2();
    case "WFS":
      return M();
    case "WMTS":
      return j();
    case "WMS":
      return T2();
    case "Feed":
      return v();
    default:
      return Promise.reject(new s("portal:unknown-item-type", "Unknown item type '${type}'", { type: r.type }));
  }
}
function m(e) {
  return (0, a[e.className])().then((r) => ({ constructor: r, properties: e.properties }));
}
function p(e) {
  return G(e).then((e2) => e2 ? { className: "TileLayer" } : { className: "MapImageLayer" });
}
function L(e) {
  return s2(e, "Oriented Imagery Layer") ? C(e) : P(e).then((e2) => {
    if ("object" == typeof e2) {
      const r = {};
      return null != e2.id && (r.layerId = e2.id), { className: e2.className || "FeatureLayer", properties: r };
    }
    return { className: "GroupLayer" };
  });
}
function f(e) {
  return P(e).then((r) => {
    if ("object" == typeof r) {
      const t = {};
      let a2;
      if (null != r.id ? (t.layerId = r.id, a2 = `${e.url}/layers/${r.id}`) : a2 = e.url, Array.isArray(e.typeKeywords) && e.typeKeywords.length > 0) {
        const r2 = { IntegratedMesh: "IntegratedMeshLayer", "3DObject": "SceneLayer", Point: "SceneLayer", PointCloud: "PointCloudLayer", Building: "BuildingSceneLayer" };
        for (const t2 of Object.keys(r2))
          if (e.typeKeywords.includes(t2))
            return { className: r2[t2] };
      }
      return n(a2).then((e2) => {
        let r2 = "SceneLayer";
        const a3 = { Point: "SceneLayer", "3DObject": "SceneLayer", IntegratedMesh: "IntegratedMeshLayer", PointCloud: "PointCloudLayer", Building: "BuildingSceneLayer" };
        return e2 && e2.layerType && a3[e2.layerType] && (r2 = a3[e2.layerType]), { className: r2, properties: t };
      });
    }
    return false === r ? n(e.url).then((e2) => "Voxel" === (e2 == null ? void 0 : e2.layerType) ? { className: "VoxelLayer" } : { className: "GroupLayer" }) : { className: "GroupLayer" };
  });
}
async function d(e) {
  await e.load();
  const r = s2(e, "Map Notes"), t = s2(e, "Markup");
  if (r || t)
    return { className: "MapNotesLayer" };
  if (s2(e, "Route Layer"))
    return { className: "RouteLayer" };
  const n2 = await e.fetchData();
  return 1 === w(n2) ? { className: "FeatureLayer" } : { className: "GroupLayer" };
}
async function N(e) {
  var _a, _b, _c, _d, _e;
  await e.load();
  const r = (_b = (_a = e.typeKeywords) == null ? void 0 : _a.map((e2) => e2.toLowerCase())) != null ? _b : [];
  if (r.includes("elevation 3d layer"))
    return { className: "ElevationLayer" };
  if (r.includes("tiled imagery"))
    return { className: "ImageryTileLayer" };
  const t = (_c = await e.fetchData()) == null ? void 0 : _c.layerType;
  if ("ArcGISTiledImageServiceLayer" === t)
    return { className: "ImageryTileLayer" };
  if ("ArcGISImageServiceLayer" === t)
    return { className: "ImageryLayer" };
  const a2 = await n(e.url), n2 = (_d = a2.cacheType) == null ? void 0 : _d.toLowerCase(), s3 = (_e = a2.capabilities) == null ? void 0 : _e.toLowerCase().includes("tilesonly");
  return "map" === n2 || s3 ? { className: "ImageryTileLayer" } : { className: "ImageryLayer" };
}
function S() {
  return { className: "StreamLayer" };
}
function I() {
  return { className: "VectorTileLayer" };
}
function h() {
  return { className: "GeoJSONLayer" };
}
function g2() {
  return { className: "CSVLayer" };
}
function w2() {
  return { className: "KMLLayer" };
}
function M() {
  return { className: "WFSLayer" };
}
function T2() {
  return { className: "WMSLayer" };
}
function j() {
  return { className: "WMTSLayer" };
}
function v() {
  return { className: "StreamLayer" };
}
function C(e) {
  return e.load().then(() => e.fetchData()).then((e2) => e2.coverage ? { className: "GroupLayer" } : { className: "OrientedImageryLayer", properties: e2 });
}
function G(e) {
  return n(e.url).then((e2) => e2.tileInfo);
}
function P(e) {
  return !e.url || e.url.match(/\/\d+$/) ? Promise.resolve({}) : e.load().then(() => e.fetchData()).then(async (r) => {
    if ("Feature Service" === e.type) {
      const t = F(await b(r, e.url));
      if ("object" == typeof t) {
        const e2 = T(r);
        t.className = e2.includes(t.id) ? "SubtypeGroupLayer" : "FeatureLayer";
      }
      return t;
    }
    return w(r) > 0 ? F(r) : n(e.url).then(F);
  });
}
function F(e) {
  return 1 === w(e) && { id: g(e) };
}

export {
  i,
  y
};
//# sourceMappingURL=chunk-4JUCJNTV.js.map
