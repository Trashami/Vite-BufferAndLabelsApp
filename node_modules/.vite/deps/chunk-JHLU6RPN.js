import {
  g
} from "./chunk-EPMXCACW.js";
import {
  s,
  t
} from "./chunk-R24MO4IV.js";
import {
  e,
  n
} from "./chunk-QISOH77W.js";
import {
  X,
  o
} from "./chunk-XO5VJRK4.js";
import {
  a
} from "./chunk-ZPYDYUP5.js";
import {
  has
} from "./chunk-HVKDYDPP.js";

// node_modules/@arcgis/core/geometry/libtess.js
var s2 = 128e3;
var n2 = null;
var e2 = null;
async function i() {
  return n2 || (n2 = o2()), n2;
}
async function o2() {
  const s4 = has("esri-csp-restrictions") ? await import("./libtess-asm-7OMJ4366.js").then((t2) => t2.l) : await import("./libtess-JMQZDHLS.js").then((t2) => t2.l);
  e2 = await s4.load({ locateFile: (s5) => a(`esri/core/libs/libtess/${s5}`) });
}
function r(t2, n5) {
  const i2 = Math.max(t2.length, s2);
  return e2.triangulate(t2, n5, i2);
}

// node_modules/@arcgis/core/views/2d/engine/webgl/TileClipper.js
var e3 = class {
  constructor(i2, t2, s4) {
    this.ratio = i2, this.x = t2, this.y = s4;
  }
};
var n3 = class {
  constructor(t2, s4, h2, e4 = 8, n5 = 8) {
    this._lines = [], this._starts = [], this.validateTessellation = true, this._pixelRatio = e4, this._pixelMargin = n5, this._tileSize = o * e4, this._dz = t2, this._yPos = s4, this._xPos = h2;
  }
  setPixelMargin(i2) {
    i2 !== this._pixelMargin && (this._pixelMargin = i2, this.setExtent(this._extent));
  }
  setExtent(i2) {
    this._extent = i2, this._finalRatio = this._tileSize / i2 * (1 << this._dz);
    let t2 = this._pixelRatio * this._pixelMargin;
    t2 /= this._finalRatio;
    const s4 = i2 >> this._dz;
    t2 > s4 && (t2 = s4), this._margin = t2, this._xmin = s4 * this._xPos - t2, this._ymin = s4 * this._yPos - t2, this._xmax = this._xmin + s4 + 2 * t2, this._ymax = this._ymin + s4 + 2 * t2;
  }
  reset(i2) {
    this._type = i2, this._lines = [], this._starts = [], this._line = null, this._start = 0;
  }
  moveTo(i2, s4) {
    this._pushLine(), this._prevIsIn = this._isIn(i2, s4), this._moveTo(i2, s4, this._prevIsIn), this._prevPt = new t(i2, s4), this._firstPt = new t(i2, s4), this._dist = 0;
  }
  lineTo(i2, s4) {
    const h2 = this._isIn(i2, s4), n5 = new t(i2, s4), _3 = t.distance(this._prevPt, n5);
    let l3, x3, a3, y2, o4, r3, m, p;
    if (h2)
      this._prevIsIn ? this._lineTo(i2, s4, true) : (l3 = this._prevPt, x3 = n5, a3 = this._intersect(x3, l3), this._start = this._dist + _3 * (1 - this._r), this._lineTo(a3.x, a3.y, true), this._lineTo(x3.x, x3.y, true));
    else if (this._prevIsIn)
      x3 = this._prevPt, l3 = n5, a3 = this._intersect(x3, l3), this._lineTo(a3.x, a3.y, true), this._lineTo(l3.x, l3.y, false);
    else {
      const i3 = this._prevPt, t2 = n5;
      if (i3.x <= this._xmin && t2.x <= this._xmin || i3.x >= this._xmax && t2.x >= this._xmax || i3.y <= this._ymin && t2.y <= this._ymin || i3.y >= this._ymax && t2.y >= this._ymax)
        this._lineTo(t2.x, t2.y, false);
      else {
        const s5 = [];
        if ((i3.x < this._xmin && t2.x > this._xmin || i3.x > this._xmin && t2.x < this._xmin) && (y2 = (this._xmin - i3.x) / (t2.x - i3.x), p = i3.y + y2 * (t2.y - i3.y), p <= this._ymin ? r3 = false : p >= this._ymax ? r3 = true : s5.push(new e3(y2, this._xmin, p))), (i3.x < this._xmax && t2.x > this._xmax || i3.x > this._xmax && t2.x < this._xmax) && (y2 = (this._xmax - i3.x) / (t2.x - i3.x), p = i3.y + y2 * (t2.y - i3.y), p <= this._ymin ? r3 = false : p >= this._ymax ? r3 = true : s5.push(new e3(y2, this._xmax, p))), (i3.y < this._ymin && t2.y > this._ymin || i3.y > this._ymin && t2.y < this._ymin) && (y2 = (this._ymin - i3.y) / (t2.y - i3.y), m = i3.x + y2 * (t2.x - i3.x), m <= this._xmin ? o4 = false : m >= this._xmax ? o4 = true : s5.push(new e3(y2, m, this._ymin))), (i3.y < this._ymax && t2.y > this._ymax || i3.y > this._ymax && t2.y < this._ymax) && (y2 = (this._ymax - i3.y) / (t2.y - i3.y), m = i3.x + y2 * (t2.x - i3.x), m <= this._xmin ? o4 = false : m >= this._xmax ? o4 = true : s5.push(new e3(y2, m, this._ymax))), 0 === s5.length)
          o4 ? r3 ? this._lineTo(this._xmax, this._ymax, true) : this._lineTo(this._xmax, this._ymin, true) : r3 ? this._lineTo(this._xmin, this._ymax, true) : this._lineTo(this._xmin, this._ymin, true);
        else if (s5.length > 1 && s5[0].ratio > s5[1].ratio)
          this._start = this._dist + _3 * s5[1].ratio, this._lineTo(s5[1].x, s5[1].y, true), this._lineTo(s5[0].x, s5[0].y, true);
        else {
          this._start = this._dist + _3 * s5[0].ratio;
          for (let i4 = 0; i4 < s5.length; i4++)
            this._lineTo(s5[i4].x, s5[i4].y, true);
        }
        this._lineTo(t2.x, t2.y, false);
      }
    }
    this._dist += _3, this._prevIsIn = h2, this._prevPt = n5;
  }
  close() {
    if (this._line.length > 2) {
      const i2 = this._firstPt, t2 = this._prevPt;
      i2.x === t2.x && i2.y === t2.y || this.lineTo(i2.x, i2.y);
      const s4 = this._line;
      let h2 = s4.length;
      for (; h2 >= 4 && (s4[0].x === s4[1].x && s4[0].x === s4[h2 - 2].x || s4[0].y === s4[1].y && s4[0].y === s4[h2 - 2].y); )
        s4.pop(), s4[0].x = s4[h2 - 2].x, s4[0].y = s4[h2 - 2].y, --h2;
    }
  }
  result(i2 = true) {
    return this._pushLine(), 0 === this._lines.length ? null : (this._type === s.Polygon && i2 && x.simplify(this._tileSize, this._margin * this._finalRatio, this._lines), this._lines);
  }
  resultWithStarts() {
    if (this._type !== s.LineString)
      throw new Error("Only valid for lines");
    this._pushLine();
    const i2 = this._lines, t2 = i2.length;
    if (0 === t2)
      return null;
    const h2 = [];
    for (let s4 = 0; s4 < t2; s4++)
      h2.push({ line: i2[s4], start: this._starts[s4] || 0 });
    return h2;
  }
  _isIn(i2, t2) {
    return i2 >= this._xmin && i2 <= this._xmax && t2 >= this._ymin && t2 <= this._ymax;
  }
  _intersect(i2, s4) {
    let h2, e4, n5;
    if (s4.x >= this._xmin && s4.x <= this._xmax)
      e4 = s4.y <= this._ymin ? this._ymin : this._ymax, n5 = (e4 - i2.y) / (s4.y - i2.y), h2 = i2.x + n5 * (s4.x - i2.x);
    else if (s4.y >= this._ymin && s4.y <= this._ymax)
      h2 = s4.x <= this._xmin ? this._xmin : this._xmax, n5 = (h2 - i2.x) / (s4.x - i2.x), e4 = i2.y + n5 * (s4.y - i2.y);
    else {
      e4 = s4.y <= this._ymin ? this._ymin : this._ymax, h2 = s4.x <= this._xmin ? this._xmin : this._xmax;
      const t2 = (h2 - i2.x) / (s4.x - i2.x), _3 = (e4 - i2.y) / (s4.y - i2.y);
      t2 < _3 ? (n5 = t2, e4 = i2.y + t2 * (s4.y - i2.y)) : (n5 = _3, h2 = i2.x + _3 * (s4.x - i2.x));
    }
    return this._r = n5, new t(h2, e4);
  }
  _pushLine() {
    this._line && (this._type === s.Point ? this._line.length > 0 && (this._lines.push(this._line), this._starts.push(this._start)) : this._type === s.LineString ? this._line.length > 1 && (this._lines.push(this._line), this._starts.push(this._start)) : this._type === s.Polygon && this._line.length > 3 && (this._lines.push(this._line), this._starts.push(this._start))), this._line = [], this._start = 0;
  }
  _moveTo(i2, h2, e4) {
    this._type !== s.Polygon ? e4 && (i2 = Math.round((i2 - (this._xmin + this._margin)) * this._finalRatio), h2 = Math.round((h2 - (this._ymin + this._margin)) * this._finalRatio), this._line.push(new t(i2, h2))) : (e4 || (i2 < this._xmin && (i2 = this._xmin), i2 > this._xmax && (i2 = this._xmax), h2 < this._ymin && (h2 = this._ymin), h2 > this._ymax && (h2 = this._ymax)), i2 = Math.round((i2 - (this._xmin + this._margin)) * this._finalRatio), h2 = Math.round((h2 - (this._ymin + this._margin)) * this._finalRatio), this._line.push(new t(i2, h2)), this._isH = false, this._isV = false);
  }
  _lineTo(i2, h2, e4) {
    let n5, _3;
    if (this._type !== s.Polygon)
      if (e4) {
        if (i2 = Math.round((i2 - (this._xmin + this._margin)) * this._finalRatio), h2 = Math.round((h2 - (this._ymin + this._margin)) * this._finalRatio), this._line.length > 0 && (n5 = this._line[this._line.length - 1], n5.equals(i2, h2)))
          return;
        this._line.push(new t(i2, h2));
      } else
        this._line && this._line.length > 0 && this._pushLine();
    else if (e4 || (i2 < this._xmin && (i2 = this._xmin), i2 > this._xmax && (i2 = this._xmax), h2 < this._ymin && (h2 = this._ymin), h2 > this._ymax && (h2 = this._ymax)), i2 = Math.round((i2 - (this._xmin + this._margin)) * this._finalRatio), h2 = Math.round((h2 - (this._ymin + this._margin)) * this._finalRatio), this._line && this._line.length > 0) {
      n5 = this._line[this._line.length - 1];
      const s4 = n5.x === i2, e5 = n5.y === h2;
      if (s4 && e5)
        return;
      this._isH && s4 || this._isV && e5 ? (n5.x = i2, n5.y = h2, _3 = this._line[this._line.length - 2], _3.x === i2 && _3.y === h2 ? (this._line.pop(), this._line.length <= 1 ? (this._isH = false, this._isV = false) : (_3 = this._line[this._line.length - 2], this._isH = _3.x === i2, this._isV = _3.y === h2)) : (this._isH = _3.x === i2, this._isV = _3.y === h2)) : (this._line.push(new t(i2, h2)), this._isH = s4, this._isV = e5);
    } else
      this._line.push(new t(i2, h2));
  }
};
var _ = class {
  setExtent(i2) {
    this._ratio = 4096 === i2 ? 1 : 4096 / i2;
  }
  get validateTessellation() {
    return this._ratio < 1;
  }
  reset(i2) {
    this._lines = [], this._line = null;
  }
  moveTo(i2, s4) {
    this._line && this._lines.push(this._line), this._line = [];
    const h2 = this._ratio;
    this._line.push(new t(i2 * h2, s4 * h2));
  }
  lineTo(i2, s4) {
    const h2 = this._ratio;
    this._line.push(new t(i2 * h2, s4 * h2));
  }
  close() {
    const i2 = this._line;
    i2 && !i2[0].isEqual(i2[i2.length - 1]) && i2.push(i2[0]);
  }
  result() {
    return this._line && this._lines.push(this._line), 0 === this._lines.length ? null : this._lines;
  }
};
var l;
!function(i2) {
  i2[i2.sideLeft = 0] = "sideLeft", i2[i2.sideRight = 1] = "sideRight", i2[i2.sideTop = 2] = "sideTop", i2[i2.sideBottom = 3] = "sideBottom";
}(l || (l = {}));
var x = class {
  static simplify(i2, t2, s4) {
    if (!s4)
      return;
    const h2 = -t2, e4 = i2 + t2, n5 = -t2, _3 = i2 + t2, a3 = [], y2 = [], o4 = s4.length;
    for (let x3 = 0; x3 < o4; ++x3) {
      const i3 = s4[x3];
      if (!i3 || i3.length < 2)
        continue;
      let t3, o5 = i3[0];
      const r4 = i3.length;
      for (let s5 = 1; s5 < r4; ++s5)
        t3 = i3[s5], o5.x === t3.x && (o5.x <= h2 && (o5.y > t3.y ? (a3.push(x3), a3.push(s5), a3.push(l.sideLeft), a3.push(-1)) : (y2.push(x3), y2.push(s5), y2.push(l.sideLeft), y2.push(-1))), o5.x >= e4 && (o5.y < t3.y ? (a3.push(x3), a3.push(s5), a3.push(l.sideRight), a3.push(-1)) : (y2.push(x3), y2.push(s5), y2.push(l.sideRight), y2.push(-1)))), o5.y === t3.y && (o5.y <= n5 && (o5.x < t3.x ? (a3.push(x3), a3.push(s5), a3.push(l.sideTop), a3.push(-1)) : (y2.push(x3), y2.push(s5), y2.push(l.sideTop), y2.push(-1))), o5.y >= _3 && (o5.x > t3.x ? (a3.push(x3), a3.push(s5), a3.push(l.sideBottom), a3.push(-1)) : (y2.push(x3), y2.push(s5), y2.push(l.sideBottom), y2.push(-1)))), o5 = t3;
    }
    if (0 === a3.length || 0 === y2.length)
      return;
    x.fillParent(s4, y2, a3), x.fillParent(s4, a3, y2);
    const r3 = [];
    x.calcDeltas(r3, y2, a3), x.calcDeltas(r3, a3, y2), x.addDeltas(r3, s4);
  }
  static fillParent(i2, t2, s4) {
    const e4 = s4.length, n5 = t2.length;
    for (let _3 = 0; _3 < n5; _3 += 4) {
      const n6 = t2[_3], x3 = t2[_3 + 1], a3 = t2[_3 + 2], y2 = i2[n6][x3 - 1], o4 = i2[n6][x3];
      let r3 = 8092, m = -1;
      for (let t3 = 0; t3 < e4; t3 += 4) {
        if (s4[t3 + 2] !== a3)
          continue;
        const e5 = s4[t3], n7 = s4[t3 + 1], _4 = i2[e5][n7 - 1], x4 = i2[e5][n7];
        switch (a3) {
          case l.sideLeft:
          case l.sideRight:
            if (g(y2.y, _4.y, x4.y) && g(o4.y, _4.y, x4.y)) {
              const i3 = Math.abs(x4.y - _4.y);
              i3 < r3 && (r3 = i3, m = t3);
            }
            break;
          case l.sideTop:
          case l.sideBottom:
            if (g(y2.x, _4.x, x4.x) && g(o4.x, _4.x, x4.x)) {
              const i3 = Math.abs(x4.x - _4.x);
              i3 < r3 && (r3 = i3, m = t3);
            }
        }
      }
      t2[_3 + 3] = m;
    }
  }
  static calcDeltas(i2, t2, s4) {
    const h2 = t2.length;
    for (let e4 = 0; e4 < h2; e4 += 4) {
      const h3 = [], n5 = x.calcDelta(e4, t2, s4, h3);
      i2.push(t2[e4]), i2.push(t2[e4 + 1]), i2.push(t2[e4 + 2]), i2.push(n5);
    }
  }
  static calcDelta(i2, t2, s4, h2) {
    const e4 = t2[i2 + 3];
    if (-1 === e4)
      return 0;
    const n5 = h2.length;
    return n5 > 1 && h2[n5 - 2] === e4 ? 0 : (h2.push(e4), x.calcDelta(e4, s4, t2, h2) + 1);
  }
  static addDeltas(i2, t2) {
    const s4 = i2.length;
    let h2 = 0;
    for (let e4 = 0; e4 < s4; e4 += 4) {
      const t3 = i2[e4 + 3];
      t3 > h2 && (h2 = t3);
    }
    for (let e4 = 0; e4 < s4; e4 += 4) {
      const s5 = t2[i2[e4]], n5 = i2[e4 + 1], _3 = h2 - i2[e4 + 3];
      switch (i2[e4 + 2]) {
        case l.sideLeft:
          s5[n5 - 1].x -= _3, s5[n5].x -= _3, 1 === n5 && (s5[s5.length - 1].x -= _3), n5 === s5.length - 1 && (s5[0].x -= _3);
          break;
        case l.sideRight:
          s5[n5 - 1].x += _3, s5[n5].x += _3, 1 === n5 && (s5[s5.length - 1].x += _3), n5 === s5.length - 1 && (s5[0].x += _3);
          break;
        case l.sideTop:
          s5[n5 - 1].y -= _3, s5[n5].y -= _3, 1 === n5 && (s5[s5.length - 1].y -= _3), n5 === s5.length - 1 && (s5[0].y -= _3);
          break;
        case l.sideBottom:
          s5[n5 - 1].y += _3, s5[n5].y += _3, 1 === n5 && (s5[s5.length - 1].y += _3), n5 === s5.length - 1 && (s5[0].y += _3);
      }
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/TurboLine.js
function x2(t2, e4) {
  return t2.x === e4.x && t2.y === e4.y;
}
function r2(t2) {
  if (!t2)
    return;
  const e4 = t2.length;
  if (e4 <= 1)
    return;
  let i2 = 0;
  for (let r3 = 1; r3 < e4; r3++)
    x2(t2[r3], t2[i2]) || ++i2 === r3 || (t2[i2] = t2[r3]);
  t2.length = i2 + 1;
}
function n4(t2, e4) {
  return t2.x = e4.y, t2.y = -e4.x, t2;
}
function s3(t2, e4) {
  return t2.x = -e4.y, t2.y = e4.x, t2;
}
function y(t2, e4) {
  return t2.x = e4.x, t2.y = e4.y, t2;
}
function o3(t2, e4) {
  return t2.x = -e4.x, t2.y = -e4.y, t2;
}
function h(t2) {
  return Math.sqrt(t2.x * t2.x + t2.y * t2.y);
}
function l2(t2, e4) {
  return t2.x * e4.y - t2.y * e4.x;
}
function _2(t2, e4) {
  return t2.x * e4.x + t2.y * e4.y;
}
function a2(t2, e4, i2, x3) {
  return t2.x = e4.x * i2 + e4.y * x3, t2.y = e4.x * x3 - e4.y * i2, t2;
}
var c = class {
  constructor(t2, e4, i2) {
    this._writeVertex = t2, this._writeTriangle = e4, this._canUseThinTessellation = i2, this._prevNormal = { x: void 0, y: void 0 }, this._nextNormal = { x: void 0, y: void 0 }, this._textureNormalLeft = { x: 0, y: 1 }, this._textureNormalRight = { x: 0, y: -1 }, this._textureNormal = { x: void 0, y: void 0 }, this._joinNormal = { x: void 0, y: void 0 }, this._inner = { x: void 0, y: void 0 }, this._outer = { x: void 0, y: void 0 }, this._roundStart = { x: void 0, y: void 0 }, this._roundEnd = { x: void 0, y: void 0 }, this._startBreak = { x: void 0, y: void 0 }, this._endBreak = { x: void 0, y: void 0 }, this._innerPrev = { x: void 0, y: void 0 }, this._innerNext = { x: void 0, y: void 0 }, this._bevelStart = { x: void 0, y: void 0 }, this._bevelEnd = { x: void 0, y: void 0 }, this._bevelMiddle = { x: void 0, y: void 0 };
  }
  tessellate(t2, e4) {
    r2(t2), this._canUseThinTessellation && e4.halfWidth < X && !e4.offset ? this._tessellateThin(t2, e4) : this._tessellate(t2, e4);
  }
  _tessellateThin(t2, e4) {
    if (t2.length < 2)
      return;
    const i2 = e4.wrapDistance || 65535;
    let x3 = e4.initialDistance || 0, r3 = false, n5 = t2[0].x, s4 = t2[0].y;
    const y2 = t2.length;
    for (let o4 = 1; o4 < y2; ++o4) {
      r3 && (r3 = false, x3 = 0);
      let e5 = t2[o4].x, y3 = t2[o4].y, h2 = e5 - n5, l3 = y3 - s4, _3 = Math.sqrt(h2 * h2 + l3 * l3);
      if (h2 /= _3, l3 /= _3, x3 + _3 > i2) {
        r3 = true;
        const t3 = (i2 - x3) / _3;
        _3 = i2 - x3, e5 = (1 - t3) * n5 + t3 * e5, y3 = (1 - t3) * s4 + t3 * y3, --o4;
      }
      const a3 = this._writeVertex(n5, s4, 0, 0, h2, l3, l3, -h2, 0, -1, x3), c2 = this._writeVertex(n5, s4, 0, 0, h2, l3, -l3, h2, 0, 1, x3);
      x3 += _3;
      const d = this._writeVertex(e5, y3, 0, 0, h2, l3, l3, -h2, 0, -1, x3), u = this._writeVertex(e5, y3, 0, 0, h2, l3, -l3, h2, 0, 1, x3);
      this._writeTriangle(a3, c2, d), this._writeTriangle(c2, d, u), n5 = e5, s4 = y3;
    }
  }
  _tessellate(i2, r3) {
    const c2 = i2[0], d = i2[i2.length - 1], u = x2(c2, d), v = u ? 3 : 2;
    if (i2.length < v)
      return;
    const f = r3.pixelCoordRatio, w = null != r3.capType ? r3.capType : e.BUTT, T = null != r3.joinType ? r3.joinType : n.MITER, g2 = null != r3.miterLimit ? Math.min(r3.miterLimit, 4) : 2, m = null != r3.roundLimit ? Math.min(r3.roundLimit, 1.05) : 1.05, V = null != r3.halfWidth ? r3.halfWidth : 2, N = !!r3.textured;
    let E, b, R, U = null;
    const k = this._prevNormal, p = this._nextNormal;
    let M = -1, B = -1;
    const L = this._joinNormal;
    let D, S;
    const j = this._textureNormalLeft, A = this._textureNormalRight, O = this._textureNormal;
    let I = -1, P = -1;
    const W = r3.wrapDistance || 65535;
    let q = r3.initialDistance || 0;
    const Q = this._writeVertex, X2 = this._writeTriangle, C = (t2, e4, i3, x3, r4, n5) => {
      const s4 = Q(b, R, D, S, i3, x3, t2, e4, r4, n5, q);
      return I >= 0 && P >= 0 && s4 >= 0 && X2(I, P, s4), I = P, P = s4, s4;
    };
    u && (E = i2[i2.length - 2], p.x = d.x - E.x, p.y = d.y - E.y, B = h(p), p.x /= B, p.y /= B);
    let z = false;
    for (let x3 = 0; x3 < i2.length; ++x3) {
      if (z && (z = false, q = 0), E && (k.x = -p.x, k.y = -p.y, M = B, q + M > W && (z = true)), z) {
        const t2 = (W - q) / M;
        M = W - q, E = { x: (1 - t2) * E.x + t2 * i2[x3].x, y: (1 - t2) * E.y + t2 * i2[x3].y }, --x3;
      } else
        E = i2[x3];
      b = E.x, R = E.y;
      const r4 = x3 <= 0 && !z, c3 = x3 === i2.length - 1;
      if (r4 || (q += M), U = c3 ? u ? i2[1] : null : i2[x3 + 1], U ? (p.x = U.x - b, p.y = U.y - R, B = h(p), p.x /= B, p.y /= B) : (p.x = void 0, p.y = void 0), !u) {
        if (r4) {
          s3(L, p), D = L.x, S = L.y, w === e.SQUARE && (C(-p.y - p.x, p.x - p.y, p.x, p.y, 0, -1), C(p.y - p.x, -p.x - p.y, p.x, p.y, 0, 1)), w === e.ROUND && (C(-p.y - p.x, p.x - p.y, p.x, p.y, -1, -1), C(p.y - p.x, -p.x - p.y, p.x, p.y, -1, 1)), w !== e.ROUND && w !== e.BUTT || (C(-p.y, p.x, p.x, p.y, 0, -1), C(p.y, -p.x, p.x, p.y, 0, 1));
          continue;
        }
        if (c3) {
          n4(L, k), D = L.x, S = L.y, w !== e.ROUND && w !== e.BUTT || (C(k.y, -k.x, -k.x, -k.y, 0, -1), C(-k.y, k.x, -k.x, -k.y, 0, 1)), w === e.SQUARE && (C(k.y - k.x, -k.x - k.y, -k.x, -k.y, 0, -1), C(-k.y - k.x, k.x - k.y, -k.x, -k.y, 0, 1)), w === e.ROUND && (C(k.y - k.x, -k.x - k.y, -k.x, -k.y, 1, -1), C(-k.y - k.x, k.x - k.y, -k.x, -k.y, 1, 1));
          continue;
        }
      }
      let d2, v2, Q2 = -l2(k, p);
      if (Math.abs(Q2) < 0.01)
        _2(k, p) > 0 ? (L.x = k.x, L.y = k.y, Q2 = 1, d2 = Number.MAX_VALUE, v2 = true) : (s3(L, p), Q2 = 1, d2 = 1, v2 = false);
      else {
        L.x = (k.x + p.x) / Q2, L.y = (k.y + p.y) / Q2, d2 = h(L);
        const t2 = (d2 - 1) * V * f;
        v2 = d2 > 4 || t2 > M && t2 > B;
      }
      D = L.x, S = L.y;
      let X3 = T;
      switch (T) {
        case n.BEVEL:
          d2 < 1.05 && (X3 = n.MITER);
          break;
        case n.ROUND:
          d2 < m && (X3 = n.MITER);
          break;
        case n.MITER:
          d2 > g2 && (X3 = n.BEVEL);
      }
      switch (X3) {
        case n.MITER:
          if (C(L.x, L.y, -k.x, -k.y, 0, -1), C(-L.x, -L.y, -k.x, -k.y, 0, 1), c3)
            break;
          if (N) {
            const t2 = z ? 0 : q;
            I = this._writeVertex(b, R, D, S, p.x, p.y, L.x, L.y, 0, -1, t2), P = this._writeVertex(b, R, D, S, p.x, p.y, -L.x, -L.y, 0, 1, t2);
          }
          break;
        case n.BEVEL: {
          const t2 = Q2 < 0;
          let e4, i3, x4, r5;
          if (t2) {
            const t3 = I;
            I = P, P = t3, e4 = j, i3 = A;
          } else
            e4 = A, i3 = j;
          if (v2)
            x4 = t2 ? s3(this._innerPrev, k) : n4(this._innerPrev, k), r5 = t2 ? n4(this._innerNext, p) : s3(this._innerNext, p);
          else {
            const e5 = t2 ? o3(this._inner, L) : y(this._inner, L);
            x4 = e5, r5 = e5;
          }
          const h2 = t2 ? n4(this._bevelStart, k) : s3(this._bevelStart, k);
          C(x4.x, x4.y, -k.x, -k.y, e4.x, e4.y);
          const l3 = C(h2.x, h2.y, -k.x, -k.y, i3.x, i3.y);
          if (c3)
            break;
          const _3 = t2 ? s3(this._bevelEnd, p) : n4(this._bevelEnd, p);
          if (v2) {
            const t3 = this._writeVertex(b, R, D, S, -k.x, -k.y, 0, 0, 0, 0, q);
            I = this._writeVertex(b, R, D, S, p.x, p.y, r5.x, r5.y, e4.x, e4.y, q), P = this._writeVertex(b, R, D, S, p.x, p.y, _3.x, _3.y, i3.x, i3.y, q), this._writeTriangle(l3, t3, P);
          } else {
            if (N) {
              const t3 = this._bevelMiddle;
              t3.x = (h2.x + _3.x) / 2, t3.y = (h2.y + _3.y) / 2, a2(O, t3, -k.x, -k.y), C(t3.x, t3.y, -k.x, -k.y, O.x, O.y), a2(O, t3, p.x, p.y), I = this._writeVertex(b, R, D, S, p.x, p.y, t3.x, t3.y, O.x, O.y, q), P = this._writeVertex(b, R, D, S, p.x, p.y, r5.x, r5.y, e4.x, e4.y, q);
            } else {
              const t3 = I;
              I = P, P = t3;
            }
            C(_3.x, _3.y, p.x, p.y, i3.x, i3.y);
          }
          if (t2) {
            const t3 = I;
            I = P, P = t3;
          }
          break;
        }
        case n.ROUND: {
          const t2 = Q2 < 0;
          let e4, i3;
          if (t2) {
            const t3 = I;
            I = P, P = t3, e4 = j, i3 = A;
          } else
            e4 = A, i3 = j;
          const x4 = t2 ? o3(this._inner, L) : y(this._inner, L);
          let r5, h2;
          v2 ? (r5 = t2 ? s3(this._innerPrev, k) : n4(this._innerPrev, k), h2 = t2 ? n4(this._innerNext, p) : s3(this._innerNext, p)) : (r5 = x4, h2 = x4);
          const l3 = t2 ? n4(this._roundStart, k) : s3(this._roundStart, k), u2 = t2 ? s3(this._roundEnd, p) : n4(this._roundEnd, p), f2 = C(r5.x, r5.y, -k.x, -k.y, e4.x, e4.y), w2 = C(l3.x, l3.y, -k.x, -k.y, i3.x, i3.y);
          if (c3)
            break;
          const T2 = this._writeVertex(b, R, D, S, -k.x, -k.y, 0, 0, 0, 0, q);
          v2 || this._writeTriangle(I, P, T2);
          const g3 = o3(this._outer, x4), m2 = this._writeVertex(b, R, D, S, p.x, p.y, u2.x, u2.y, i3.x, i3.y, q);
          let V2, E2;
          const U2 = d2 > 2;
          if (U2) {
            let e5;
            d2 !== Number.MAX_VALUE ? (g3.x /= d2, g3.y /= d2, e5 = _2(k, g3), e5 = (d2 * (e5 * e5 - 1) + 1) / e5) : e5 = -1, V2 = t2 ? n4(this._startBreak, k) : s3(this._startBreak, k), V2.x += k.x * e5, V2.y += k.y * e5, E2 = t2 ? s3(this._endBreak, p) : n4(this._endBreak, p), E2.x += p.x * e5, E2.y += p.y * e5;
          }
          a2(O, g3, -k.x, -k.y);
          const M2 = this._writeVertex(b, R, D, S, -k.x, -k.y, g3.x, g3.y, O.x, O.y, q);
          a2(O, g3, p.x, p.y);
          const B2 = N ? this._writeVertex(b, R, D, S, p.x, p.y, g3.x, g3.y, O.x, O.y, q) : M2, W2 = T2, X4 = N ? this._writeVertex(b, R, D, S, p.x, p.y, 0, 0, 0, 0, q) : T2;
          let z2 = -1, F = -1;
          if (U2 && (a2(O, V2, -k.x, -k.y), z2 = this._writeVertex(b, R, D, S, -k.x, -k.y, V2.x, V2.y, O.x, O.y, q), a2(O, E2, p.x, p.y), F = this._writeVertex(b, R, D, S, p.x, p.y, E2.x, E2.y, O.x, O.y, q)), N ? U2 ? (this._writeTriangle(W2, w2, z2), this._writeTriangle(W2, z2, M2), this._writeTriangle(X4, B2, F), this._writeTriangle(X4, F, m2)) : (this._writeTriangle(W2, w2, M2), this._writeTriangle(X4, B2, m2)) : U2 ? (this._writeTriangle(T2, w2, z2), this._writeTriangle(T2, z2, F), this._writeTriangle(T2, F, m2)) : (this._writeTriangle(T2, w2, M2), this._writeTriangle(T2, B2, m2)), v2 ? (I = this._writeVertex(b, R, D, S, p.x, p.y, h2.x, h2.y, e4.x, e4.y, q), P = m2) : (I = N ? this._writeVertex(b, R, D, S, p.x, p.y, h2.x, h2.y, e4.x, e4.y, q) : f2, this._writeTriangle(I, X4, m2), P = m2), t2) {
            const t3 = I;
            I = P, P = t3;
          }
          break;
        }
      }
    }
  }
};

export {
  i,
  r,
  n3 as n,
  _,
  c
};
//# sourceMappingURL=chunk-JHLU6RPN.js.map
