import {
  i as i2,
  o as o4,
  r as r8
} from "./chunk-6NRJP66X.js";
import {
  s as s3
} from "./chunk-YBAOLQVA.js";
import {
  k as k3
} from "./chunk-URFNTHOE.js";
import {
  S
} from "./chunk-QB3YZMAB.js";
import {
  A as A3,
  E as E2,
  J,
  R as R2,
  V,
  Y,
  _ as _2,
  j as j4,
  p2 as p,
  z as z2
} from "./chunk-ZX55SO5Y.js";
import {
  a as a3,
  f2 as f
} from "./chunk-FCIHN4UG.js";
import {
  x as x2
} from "./chunk-UWKVAZQ6.js";
import {
  o as o3,
  r as r7,
  s as s2
} from "./chunk-IMBIE27L.js";
import {
  w as w3
} from "./chunk-2NKIENHY.js";
import {
  b,
  j as j5,
  s
} from "./chunk-2J2YGTXG.js";
import {
  A as A2,
  L,
  a as a2,
  j as j3,
  k as k2,
  m as m3,
  o as o2,
  v as v3,
  w as w2
} from "./chunk-75RMBUYZ.js";
import {
  l
} from "./chunk-MFXTPFHI.js";
import {
  e as e4,
  n as n4,
  r as r6
} from "./chunk-ZEEU5HOK.js";
import {
  Wn,
  jn
} from "./chunk-FFVIDMFN.js";
import {
  e as e3,
  n as n3,
  r as r5
} from "./chunk-NDQ5FHGV.js";
import {
  se
} from "./chunk-WJCI2CGX.js";
import {
  m
} from "./chunk-C5H57NTD.js";
import {
  A,
  G,
  H,
  P,
  _,
  g,
  j,
  o,
  q,
  r as r3,
  u,
  v,
  x,
  z
} from "./chunk-3LR5O4WA.js";
import {
  E,
  a,
  j as j2
} from "./chunk-GDVNKPJ7.js";
import {
  e as e2,
  n,
  r as r2
} from "./chunk-D4V6J5BT.js";
import {
  m2,
  v2
} from "./chunk-3MNMDUQZ.js";
import {
  w
} from "./chunk-UWG37XSU.js";
import {
  R,
  k2 as k
} from "./chunk-LNZAOBFW.js";
import {
  n as n2
} from "./chunk-THVR7IAM.js";
import {
  r as r4
} from "./chunk-OOLCFNXJ.js";
import {
  C,
  i
} from "./chunk-6QC7MLLS.js";
import {
  e,
  r,
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/views/support/euclideanAreaMeasurementUtils.js
function h(t5, o5 = U()) {
  return y(t5, o5);
}
function j6(t5, o5 = U()) {
  return y(t5, o5, false);
}
function y(n5, h2, j8 = n5.hasZ) {
  const y2 = i2(n5.spatialReference), U2 = se(y2);
  if (t(U2))
    return null;
  const C3 = (t5, o5) => !(o5.length < 2) && (o(t5, o5[0], o5[1], j8 && o5[2] || 0), true);
  let R4 = 0;
  for (const t5 of n5.rings) {
    const o5 = t5.length;
    if (o5 < 3)
      continue;
    const { positionsWorldCoords: r12 } = h2;
    for (; r12.length < o5; )
      r12.push(n());
    const g3 = d, j9 = o(k4, 0, 0, 0), U3 = 1 / o5;
    for (let e8 = 0; e8 < o5; e8++) {
      if (!C3(g3, t5[e8]))
        return null;
      if (!jn(g3, n5.spatialReference, r12[e8], y2))
        return null;
      q(j9, j9, r12[e8], U3);
    }
    const W = j4(r12[0], r12[1], j9, E2());
    if (0 === v(Y(W)))
      continue;
    for (let t6 = 0; t6 < o5; t6++)
      J(W, j9, r12[t6], r12[t6]);
    const b2 = v4(r12);
    for (let t6 = 0; t6 < b2.length; t6 += 3)
      R4 += S(r12[b2[t6]], r12[b2[t6 + 1]], r12[b2[t6 + 2]]);
  }
  return o4(R4, U2);
}
var d = n();
var k4 = n();
function U() {
  return { positionsWorldCoords: [] };
}
function v4(t5) {
  return x2(C2(t5), [], 2);
}
function C2(t5) {
  const o5 = new Float64Array(2 * t5.length);
  for (let r12 = 0; r12 < t5.length; ++r12) {
    const n5 = t5[r12], e8 = 2 * r12;
    o5[e8 + 0] = n5[0], o5[e8 + 1] = n5[1];
  }
  return o5;
}

// node_modules/@arcgis/core/views/support/geodesicAreaMeasurementUtils.js
function m4(e8) {
  const { spatialReference: r12 } = e8;
  return r8(r12, i3, a4, u2, e8);
}
function i3(r12) {
  return o4(Math.abs(w3([r12], "square-meters")[0]), "square-meters");
}
function a4(t5) {
  try {
    return o4(Math.abs(k3(t5, "square-meters")), "square-meters");
  } catch (s5) {
    return null;
  }
}
function u2(r12) {
  const o5 = [];
  return Wn(r12, o5) ? o4(Math.abs(w3([{ type: "polygon", rings: o5, spatialReference: k.WGS84 }], "square-meters")[0]), "square-meters") : null;
}

// node_modules/@arcgis/core/views/support/automaticAreaMeasurementUtils.js
function i4(i7, u4, m5 = U()) {
  if ("on-the-ground" === u4) {
    const o5 = m4(i7);
    return r(o5) ? o5 : j6(i7, m5);
  }
  return h(i7, m5);
}
function u3(e8, r12 = U()) {
  return i4(e8, "on-the-ground", r12);
}

// node_modules/@arcgis/core/views/interactive/coordinateHelper.js
var R3;
!function(e8) {
  e8[e8.Z = 0] = "Z", e8[e8.M = 1] = "M";
}(R3 || (R3 = {}));
var x3 = class {
  constructor(e8) {
    this.spatialReference = e8;
  }
  createVector() {
    return this._tag(n4());
  }
  pointToVector(e8) {
    return this._tag(r6(e8.x, e8.y));
  }
  arrayToVector(e8) {
    return this._tag(r6(e8[0], e8[1]));
  }
  vectorToArray(e8) {
    return [e8[0], e8[1]];
  }
  pointToArray(e8) {
    return [e8.x, e8.y];
  }
  vectorToPoint(e8, t5 = new w()) {
    return t5.x = e8[0], t5.y = e8[1], t5.z = void 0, t5.m = void 0, t5.spatialReference = this.spatialReference, t5;
  }
  arrayToPoint(e8, t5 = new w()) {
    return t5.x = e8[0], t5.y = e8[1], t5.z = void 0, t5.m = void 0, t5.spatialReference = this.spatialReference, t5;
  }
  vectorToDehydratedPoint(e8, t5 = { x: void 0, y: void 0, z: void 0, m: void 0, hasZ: void 0, hasM: void 0, spatialReference: void 0, type: "point" }) {
    return t5.x = e8[0], t5.y = e8[1], t5.z = void 0, t5.m = void 0, t5.hasZ = false, t5.hasM = false, t5.spatialReference = this.spatialReference, t5;
  }
  lerp(t5, r12, a5, s5) {
    return A2(s5, t5, r12, a5);
  }
  addDelta(e8, t5, r12) {
    e8[0] += t5, e8[1] += r12;
  }
  distance(e8, r12) {
    return m3(e8, r12);
  }
  getZ(e8, t5) {
    return t5;
  }
  hasZ() {
    return false;
  }
  getM(e8, t5) {
    return t5;
  }
  hasM() {
    return false;
  }
  clone(e8) {
    return this._tag(e4(e8));
  }
  copy(e8, t5) {
    return a2(t5, e8);
  }
  fromXYZ(e8) {
    return this._tag(r6(e8[0], e8[1]));
  }
  toXYZ(e8, t5 = n()) {
    return o(t5, e8[0], e8[1], 0);
  }
  equals(e8, t5) {
    return k2(e8, t5);
  }
  _tag(e8) {
    return e8;
  }
};
var M = class {
  constructor(e8, t5) {
    this._valueType = e8, this.spatialReference = t5;
  }
  createVector() {
    return this._tag(n());
  }
  pointToVector(e8) {
    return this._tag(r2(e8.x, e8.y, this._valueType === R3.Z ? e8.z : e8.m));
  }
  arrayToVector(e8) {
    return this._tag(r2(e8[0], e8[1], e8[2] || 0));
  }
  vectorToArray(e8) {
    return [e8[0], e8[1], e8[2]];
  }
  pointToArray(e8) {
    return this._valueType === R3.Z ? [e8.x, e8.y, e8.z] : [e8.x, e8.y, e8.m];
  }
  vectorToPoint(e8, t5 = new w()) {
    return t5.x = e8[0], t5.y = e8[1], t5.z = this._valueType === R3.Z ? e8[2] : void 0, t5.m = this._valueType === R3.M ? e8[2] : void 0, t5.spatialReference = this.spatialReference, t5;
  }
  arrayToPoint(e8, t5 = new w()) {
    return t5.x = e8[0], t5.y = e8[1], t5.z = this._valueType === R3.Z ? e8[2] : void 0, t5.m = this._valueType === R3.M ? e8[2] : void 0, t5.spatialReference = this.spatialReference, t5;
  }
  vectorToDehydratedPoint(e8, t5 = { x: void 0, y: void 0, z: void 0, m: void 0, hasZ: void 0, hasM: void 0, spatialReference: void 0, type: "point" }) {
    const r12 = this._valueType === R3.Z, a5 = this._valueType === R3.M;
    return t5.x = e8[0], t5.y = e8[1], t5.z = r12 ? e8[2] : void 0, t5.m = a5 ? e8[2] : void 0, t5.hasZ = r12, t5.hasM = a5, t5.spatialReference = this.spatialReference, t5;
  }
  lerp(e8, t5, r12, a5) {
    return A(a5, e8, t5, r12);
  }
  addDelta(e8, t5, r12, a5) {
    e8[0] += t5, e8[1] += r12, this._valueType === R3.Z && (e8[2] += a5);
  }
  distance(e8, r12) {
    return this._valueType === R3.Z ? x(e8, r12) : m3(e8, r12);
  }
  getZ(e8, t5) {
    return this._valueType === R3.Z ? e8[2] : t5;
  }
  hasZ() {
    return this._valueType === R3.Z;
  }
  getM(e8, t5) {
    return this._valueType === R3.M ? e8[2] : t5;
  }
  hasM() {
    return this._valueType === R3.M;
  }
  clone(e8) {
    return this._tag(e2(e8));
  }
  copy(e8, t5) {
    return r3(t5, e8);
  }
  fromXYZ(e8, t5 = 0, r12 = 0) {
    return this._tag(r2(e8[0], e8[1], this._valueType === R3.Z ? e8.length > 2 ? e8[2] : t5 : r12));
  }
  toXYZ(e8, t5 = n()) {
    return o(t5, e8[0], e8[1], this._valueType === R3.Z ? e8[2] : 0);
  }
  equals(e8, t5) {
    return G(e8, t5);
  }
  _tag(e8) {
    return e8;
  }
};
var z3 = class {
  constructor(e8) {
    this.spatialReference = e8;
  }
  createVector() {
    return this._tag(n3());
  }
  pointToVector(e8) {
    return this._tag(r5(e8.x, e8.y, e8.z, e8.m));
  }
  arrayToVector(e8) {
    return this._tag(r5(e8[0], e8[1], e8[2] || 0, e8[3] || 0));
  }
  vectorToArray(e8) {
    return [e8[0], e8[1], e8[2], e8[3]];
  }
  pointToArray(e8) {
    return [e8.x, e8.y, e8.z, e8.m];
  }
  vectorToPoint(e8, t5 = new w()) {
    return t5.x = e8[0], t5.y = e8[1], t5.z = e8[2], t5.m = e8[3], t5.spatialReference = this.spatialReference, t5;
  }
  arrayToPoint(e8, t5 = new w()) {
    return t5.x = e8[0], t5.y = e8[1], t5.z = e8[2], t5.m = e8[3], t5.spatialReference = this.spatialReference, t5;
  }
  vectorToDehydratedPoint(e8, t5 = { x: void 0, y: void 0, z: void 0, m: void 0, hasZ: void 0, hasM: void 0, spatialReference: void 0, type: "point" }) {
    return t5.x = e8[0], t5.y = e8[1], t5.z = e8[2], t5.m = e8[3], t5.hasZ = true, t5.hasM = true, t5.spatialReference = this.spatialReference, t5;
  }
  lerp(e8, t5, r12, a5) {
    return j2(a5, e8, t5, r12);
  }
  addDelta(e8, t5, r12, a5) {
    e8[0] += t5, e8[1] += r12, e8[2] += a5;
  }
  distance(e8, t5) {
    return x(e8, t5);
  }
  getZ(e8) {
    return e8[2];
  }
  hasZ() {
    return true;
  }
  getM(e8) {
    return e8[3];
  }
  hasM() {
    return true;
  }
  clone(e8) {
    return this._tag(e3(e8));
  }
  copy(e8, t5) {
    return a(t5, e8);
  }
  fromXYZ(e8, t5 = 0, r12 = 0) {
    return this._tag(r5(e8[0], e8[1], e8.length > 2 ? e8[2] : t5, r12));
  }
  toXYZ(e8, t5 = n()) {
    return o(t5, e8[0], e8[1], e8[2]);
  }
  equals(e8, t5) {
    return E(e8, t5);
  }
  _tag(e8) {
    return e8;
  }
};
function w4(e8, t5, r12) {
  return e8 && t5 ? new z3(r12) : t5 ? new M(R3.M, r12) : e8 ? new M(R3.Z, r12) : new x3(r12);
}

// node_modules/@arcgis/core/views/interactive/editGeometry/unnormalizationHelper.js
function e5(o5, r12) {
  if (!r12.supported)
    return;
  let e8 = 1 / 0, p4 = -1 / 0;
  const n5 = r12.upperBoundX - r12.lowerBoundX;
  o5.forEach((o6) => {
    let u5 = o6.pos[0];
    for (; u5 < r12.lowerBoundX; )
      u5 += n5;
    for (; u5 > r12.upperBoundX; )
      u5 -= n5;
    e8 = Math.min(e8, u5), p4 = Math.max(p4, u5), o6.pos[0] = u5;
  });
  const u4 = p4 - e8;
  n5 - u4 < u4 && o5.forEach((o6) => {
    o6.pos[0] < 0 && (o6.pos[0] += n5);
  });
}
function p2(e8, p4) {
  const n5 = R(e8);
  return p4 === l.Global && n5 ? { supported: true, lowerBoundX: n5.valid[0], upperBoundX: n5.valid[1] } : { supported: false, lowerBoundX: null, upperBoundX: null };
}

// node_modules/@arcgis/core/views/interactive/editGeometry/EditGeometry.js
var c = class {
  constructor(e8) {
    this.component = e8, this.leftEdge = null, this.rightEdge = null, this.type = "vertex", this.index = null;
  }
  get pos() {
    return this._pos;
  }
  set pos(e8) {
    this._pos = e8, this.component.unnormalizeVertexPositions();
  }
};
var l2 = class {
  constructor(e8, t5, s5) {
    this.component = e8, this.leftVertex = t5, this.rightVertex = s5, this.type = "edge", t5.rightEdge = this, s5.leftEdge = this;
  }
};
var p3 = class {
  constructor(e8, t5) {
    this._spatialReference = e8, this._viewingMode = t5, this.vertices = [], this.edges = [];
  }
  unnormalizeVertexPositions() {
    this.vertices.length <= 1 || e5(this.vertices, p2(this._spatialReference, this._viewingMode));
  }
  updateVertexIndex(e8, t5) {
    if (0 === this.vertices.length)
      return;
    const s5 = this.vertices[0];
    let i7 = null, r12 = e8, o5 = t5;
    do {
      i7 = r12, i7.index = o5++, r12 = i7.rightEdge ? i7.rightEdge.rightVertex : null;
    } while (null != r12 && r12 !== s5);
    i7.leftEdge && i7 !== this.vertices[this.vertices.length - 1] && this.swapVertices(this.vertices.indexOf(i7), this.vertices.length - 1);
  }
  getFirstVertex() {
    return 0 === this.vertices.length ? null : this.vertices[0];
  }
  getLastVertex() {
    return 0 === this.vertices.length ? null : this.vertices[this.vertices.length - 1];
  }
  isClosed() {
    return this.vertices.length > 2 && null !== this.vertices[0].leftEdge;
  }
  swapVertices(e8, t5) {
    const s5 = this.vertices[e8];
    this.vertices[e8] = this.vertices[t5], this.vertices[t5] = s5;
  }
  iterateVertices(e8) {
    if (0 === this.vertices.length)
      return;
    const t5 = this.vertices[0];
    let i7 = t5;
    do {
      e8(i7, i7.index), i7 = r(i7.rightEdge) ? i7.rightEdge.rightVertex : null;
    } while (i7 !== t5 && null != i7);
  }
};
var g2 = class extends n2 {
  constructor(e8, t5) {
    super(), this.type = e8, this.coordinateHelper = t5, this._geometry = null, this._dirty = true, this.components = [];
  }
  get geometry() {
    if (this._dirty) {
      switch (this.type) {
        case "point":
          this._geometry = this._toPoint();
          break;
        case "polyline":
          this._geometry = this._toPolyline();
          break;
        case "polygon":
          this._geometry = this._toPolygon();
      }
      this._dirty = false;
    }
    return this._geometry;
  }
  get spatialReference() {
    return this.coordinateHelper.spatialReference;
  }
  notifyChanges(e8) {
    this._dirty = true, this.emit("change", e8);
  }
  _toPoint() {
    return 0 === this.components.length || 0 === this.components[0].vertices.length ? null : this.coordinateHelper.vectorToPoint(this.components[0].vertices[0].pos);
  }
  _toPolyline() {
    const e8 = [], t5 = this.coordinateHelper.vectorToArray;
    for (const s5 of this.components) {
      if (s5.vertices.length < 1)
        continue;
      const i7 = [];
      let r12 = s5.vertices.find((e9) => null == e9.leftEdge);
      const o5 = r12;
      do {
        i7.push(t5(r12.pos)), r12 = r12.rightEdge ? r12.rightEdge.rightVertex : null;
      } while (r12 && r12 !== o5);
      e8.push(i7);
    }
    return new m2({ paths: e8, spatialReference: this.spatialReference, hasZ: this.coordinateHelper.hasZ(), hasM: this.coordinateHelper.hasM() });
  }
  _toPolygon() {
    const e8 = [], t5 = this.coordinateHelper.vectorToArray;
    for (const i7 of this.components) {
      if (i7.vertices.length < 1)
        continue;
      const r12 = [], o5 = i7.vertices[0];
      let n5 = o5;
      const h2 = n5;
      do {
        r12.push(t5(n5.pos)), n5 = r(n5.rightEdge) ? n5.rightEdge.rightVertex : null;
      } while (n5 && n5 !== h2);
      i7.isClosed() && r12.push(t5(o5.pos)), e8.push(r12);
    }
    return new v2({ rings: e8, spatialReference: this.spatialReference, hasZ: this.coordinateHelper.hasZ(), hasM: this.coordinateHelper.hasM() });
  }
  static fromGeometry(t5, s5) {
    const i7 = t5.spatialReference, r12 = w4(t5.hasZ, t5.hasM, i7), n5 = new g2(t5.type, r12);
    switch (t5.type) {
      case "polygon": {
        const o5 = t5.rings;
        for (let t6 = 0; t6 < o5.length; ++t6) {
          const h2 = o5[t6], g3 = new p3(i7, s5), a5 = h2.length > 2 && i(h2[0], h2[h2.length - 1]), d3 = a5 ? h2.length - 1 : h2.length;
          for (let e8 = 0; e8 < d3; ++e8) {
            const t7 = r12.arrayToVector(h2[e8]), s6 = new c(g3);
            g3.vertices.push(s6), s6.pos = t7, s6.index = e8;
          }
          const u4 = g3.vertices.length - 1;
          for (let e8 = 0; e8 < u4; ++e8) {
            const t7 = g3.vertices[e8], s6 = g3.vertices[e8 + 1], i8 = new l2(g3, t7, s6);
            g3.edges.push(i8);
          }
          if (a5) {
            const e8 = new l2(g3, g3.vertices[g3.vertices.length - 1], g3.vertices[0]);
            g3.edges.push(e8);
          }
          n5.components.push(g3);
        }
        break;
      }
      case "polyline":
        for (const e8 of t5.paths) {
          const t6 = new p3(i7, s5), o5 = e8.length;
          for (let s6 = 0; s6 < o5; ++s6) {
            const i8 = r12.arrayToVector(e8[s6]), o6 = new c(t6);
            t6.vertices.push(o6), o6.pos = i8, o6.index = s6;
          }
          const h2 = t6.vertices.length - 1;
          for (let e9 = 0; e9 < h2; ++e9) {
            const s6 = t6.vertices[e9], i8 = t6.vertices[e9 + 1], r13 = new l2(t6, s6, i8);
            t6.edges.push(r13);
          }
          n5.components.push(t6);
        }
        break;
      case "point": {
        const e8 = new p3(i7, s5), o5 = new c(e8);
        o5.index = 0, o5.pos = r12.pointToVector(t5), e8.vertices.push(o5), n5.components.push(e8);
        break;
      }
    }
    return n5;
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/interfaces.js
var E3;
!function(E4) {
  E4[E4.NEW_STEP = 0] = "NEW_STEP", E4[E4.ACCUMULATE_STEPS = 1] = "ACCUMULATE_STEPS";
}(E3 || (E3 = {}));

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/AppendVertex.js
var d2 = class {
  constructor(e8, t5, i7) {
    this._editGeometry = e8, this._component = t5, this._pos = i7, this._addedVertex = null, this._originalEdge = null, this._left = null, this._right = null;
  }
  apply() {
    let d3 = "redo";
    t(this._addedVertex) && (d3 = "apply", this._addedVertex = new c(this._component));
    const h2 = this._component.getLastVertex();
    if (t(h2))
      this._component.vertices.push(this._addedVertex), this._addedVertex.pos = this._pos, this._addedVertex.index = 0;
    else {
      let i7 = null;
      h2.rightEdge && (this._originalEdge = h2.rightEdge, i7 = this._originalEdge.rightVertex, this._component.edges.splice(this._component.edges.indexOf(this._originalEdge), 1)), this._component.vertices.push(this._addedVertex), this._addedVertex.pos = this._pos, t(this._left) && (this._left = new l2(this._component, h2, this._addedVertex)), this._component.edges.push(this._left), h2.rightEdge = this._left, r(this._originalEdge) && r(i7) && (t(this._right) && (this._right = new l2(this._component, this._addedVertex, i7)), this._component.edges.push(this._right), i7.leftEdge = this._right), this._component.updateVertexIndex(this._addedVertex, h2.index + 1);
    }
    this._editGeometry.notifyChanges({ operation: d3, addedVertices: [this._addedVertex] });
  }
  undo() {
    t(this._addedVertex) || (this._component.vertices.splice(this._component.vertices.indexOf(this._addedVertex), 1), r(this._left) && (this._component.edges.splice(this._component.edges.indexOf(this._left), 1), this._left.leftVertex.rightEdge = null), r(this._right) && (this._component.edges.splice(this._component.edges.indexOf(this._right), 1), this._right.rightVertex.leftEdge = null), r(this._originalEdge) && (this._component.edges.push(this._originalEdge), this._originalEdge.leftVertex.rightEdge = this._originalEdge, this._originalEdge.rightVertex.leftEdge = this._originalEdge), r(this._left) ? this._component.updateVertexIndex(this._left.leftVertex, this._left.leftVertex.index) : this._component.updateVertexIndex(this._addedVertex, 0), this._editGeometry.notifyChanges({ operation: "undo", removedVertices: [this._addedVertex] }));
  }
  accumulate() {
    return false;
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/UpdateVertices.js
var t2 = class {
  constructor(t5, e8, i7) {
    this._editGeometry = t5, this._vertices = e8, this.operation = i7, this._undone = false;
  }
  apply() {
    this._vertices.forEach((t5) => this.operation.apply(t5)), this._editGeometry.components.forEach((t5) => t5.unnormalizeVertexPositions()), this._editGeometry.notifyChanges({ operation: this._undone ? "redo" : "apply", updatedVertices: this._vertices });
  }
  undo() {
    this._vertices.forEach((t5) => this.operation.undo(t5)), this._editGeometry.notifyChanges({ operation: "undo", updatedVertices: this._vertices }), this._undone = true;
  }
  canAccumulate(t5) {
    if (this._undone || t5._vertices.length !== this._vertices.length)
      return false;
    for (let e8 = 0; e8 < t5._vertices.length; ++e8)
      if (t5._vertices[e8] !== this._vertices[e8])
        return false;
    return this.operation.canAccumulate(t5.operation);
  }
  accumulate(e8) {
    return !!(e8 instanceof t2 && this.canAccumulate(e8)) && (this._vertices.forEach((t5) => this.operation.accumulate(t5, e8.operation)), this.operation.accumulateParams(e8.operation), this._editGeometry.components.forEach((t5) => t5.unnormalizeVertexPositions()), this._editGeometry.notifyChanges({ operation: "apply", updatedVertices: this._vertices }), true);
  }
};
var e6;
!function(t5) {
  t5[t5.CUMULATIVE = 0] = "CUMULATIVE", t5[t5.REPLACE = 1] = "REPLACE";
}(e6 || (e6 = {}));

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/RemoveVertices.js
var r9 = class {
  constructor(e8, t5, r12 = 0) {
    this._editGeometry = e8, this._vertices = t5, this._minNumberOfVertices = r12, this.removedVertices = null;
  }
  apply() {
    let t5 = "redo";
    if (null == this.removedVertices) {
      const r12 = this.removedVertices = [];
      this._vertices.forEach((t6) => {
        const i7 = this._removeVertex(t6);
        r(i7) && r12.push(i7);
      }), t5 = "apply";
    } else
      this.removedVertices.forEach((e8) => {
        this._removeVertex(e8.removedVertex);
      });
    this._editGeometry.notifyChanges({ operation: t5, removedVertices: this._vertices });
  }
  undo() {
    var _a;
    (_a = this.removedVertices) == null ? void 0 : _a.forEach((e8) => {
      this._undoRemoveVertex(e8);
    }), this._editGeometry.notifyChanges({ operation: "undo", addedVertices: this._vertices });
  }
  accumulate() {
    return false;
  }
  _removeVertex(e8) {
    const r12 = e8.component;
    if (r12.vertices.length <= this._minNumberOfVertices)
      return null;
    const i7 = { removedVertex: e8, createdEdge: null }, s5 = e8.leftEdge, d3 = e8.rightEdge;
    return r12.vertices.splice(r12.vertices.indexOf(e8), 1), s5 && (r12.edges.splice(r12.edges.indexOf(s5), 1), s5.leftVertex.rightEdge = null), d3 && (r12.edges.splice(r12.edges.indexOf(d3), 1), d3.rightVertex.leftEdge = null), 0 === e8.index && d3 && this._vertices.length > 0 && r12.swapVertices(r12.vertices.indexOf(d3.rightVertex), 0), s5 && d3 && (i7.createdEdge = new l2(r12, s5.leftVertex, d3.rightVertex), r12.edges.push(i7.createdEdge)), d3 && r12.updateVertexIndex(d3.rightVertex, d3.rightVertex.index - 1), i7;
  }
  _undoRemoveVertex(e8) {
    const t5 = e8.removedVertex, r12 = e8.removedVertex.component, i7 = t5.leftEdge, s5 = t5.rightEdge;
    e8.createdEdge && r12.edges.splice(r12.edges.indexOf(e8.createdEdge), 1), r12.vertices.push(t5), i7 && (r12.edges.push(i7), i7.leftVertex.rightEdge = i7), s5 && (r12.edges.push(s5), s5.rightVertex.leftEdge = s5), r12.updateVertexIndex(t5, t5.index);
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/SplitEdge.js
var r10 = class {
  constructor(e8, t5, i7) {
    this._editGeometry = e8, this._edge = t5, this._t = i7, this.createdVertex = null, this._left = null, this._right = null;
  }
  apply() {
    let r12 = "redo";
    const s5 = this._edge, d3 = s5.component, h2 = s5.leftVertex, g3 = s5.rightVertex;
    d3.edges.splice(d3.edges.indexOf(s5), 1), t(this.createdVertex) && (r12 = "apply", this.createdVertex = new c(s5.component)), d3.vertices.push(this.createdVertex), this.createdVertex.pos = this._editGeometry.coordinateHelper.lerp(s5.leftVertex.pos, s5.rightVertex.pos, this._t, this._editGeometry.coordinateHelper.createVector()), t(this._left) && (this._left = new l2(d3, h2, this.createdVertex)), this._left.leftVertex.leftEdge ? d3.edges.push(this._left) : d3.edges.unshift(this._left), h2.rightEdge = this._left, t(this._right) && (this._right = new l2(d3, this.createdVertex, g3)), d3.edges.push(this._right), g3.leftEdge = this._right, d3.updateVertexIndex(this.createdVertex, h2.index + 1), this._editGeometry.notifyChanges({ operation: r12, addedVertices: [this.createdVertex] });
  }
  undo() {
    if (t(this.createdVertex) || t(this._left) || t(this._right))
      return null;
    const t5 = this._edge, i7 = t5.component, r12 = this.createdVertex.leftEdge, s5 = this.createdVertex.rightEdge, d3 = r12 == null ? void 0 : r12.leftVertex, h2 = s5 == null ? void 0 : s5.rightVertex;
    i7.vertices.splice(i7.vertices.indexOf(this.createdVertex), 1), i7.edges.splice(i7.edges.indexOf(this._left), 1), i7.edges.splice(i7.edges.indexOf(this._right), 1), this._edge.leftVertex.leftEdge ? i7.edges.push(this._edge) : i7.edges.unshift(this._edge), d3 && (d3.rightEdge = t5), h2 && (h2.leftEdge = t5), d3 && i7.updateVertexIndex(d3, d3.index), this._editGeometry.notifyChanges({ operation: "undo", removedVertices: [this.createdVertex] });
  }
  accumulate() {
    return false;
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/SetVertexPosition.js
var i5 = class {
  constructor(t5, e8, i7) {
    this._editGeometry = t5, this._vertex = e8, this._pos = i7;
  }
  apply() {
    const e8 = t(this._originalPosition);
    e8 && (this._originalPosition = this._vertex.pos), this._apply(e8 ? "apply" : "redo");
  }
  undo() {
    this._vertex.pos = e(this._originalPosition), this._editGeometry.notifyChanges({ operation: "undo", updatedVertices: [this._vertex] });
  }
  accumulate(t5) {
    return t5 instanceof i5 && t5._vertex === this._vertex && (this._pos = t5._pos, this._apply("apply"), true);
  }
  _apply(t5) {
    this._vertex.pos = this._pos, this._editGeometry.components.forEach((t6) => t6.unnormalizeVertexPositions()), this._editGeometry.notifyChanges({ operation: t5, updatedVertices: [this._vertex] });
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/CloseComponent.js
var i6 = class {
  constructor(e8, t5) {
    this._editGeometry = e8, this._component = t5, this._createdEdge = null;
  }
  apply() {
    let e8 = "redo";
    if (t(this._createdEdge)) {
      e8 = "apply";
      const i7 = this._component.getFirstVertex(), o5 = this._component.getLastVertex();
      if (this._component.isClosed() || this._component.vertices.length < 3 || t(i7) || t(o5))
        return;
      this._createdEdge = new l2(this._component, o5, i7);
    }
    this._createdEdge.leftVertex.rightEdge = this._createdEdge, this._createdEdge.rightVertex.leftEdge = this._createdEdge, this._component.edges.push(this._createdEdge), this._editGeometry.notifyChanges({ operation: e8 });
  }
  undo() {
    t(this._createdEdge) || (C(this._component.edges, this._createdEdge), this._createdEdge.leftVertex.rightEdge = null, this._createdEdge.rightVertex.leftEdge = null, this._editGeometry.notifyChanges({ operation: "undo" }));
  }
  accumulate() {
    return false;
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/MoveVertex.js
var t3 = class {
  constructor(t5, s5, d3, h2) {
    this._helper = t5, this.dx = s5, this.dy = d3, this.dz = h2;
  }
  _move(t5, s5, d3, h2) {
    this._helper.addDelta(t5.pos, s5, d3, h2);
  }
  apply(t5) {
    this._move(t5, this.dx, this.dy, this.dz);
  }
  undo(t5) {
    this._move(t5, -this.dx, -this.dy, -this.dz);
  }
  canAccumulate(s5) {
    return s5 instanceof t3;
  }
  accumulate(t5, s5) {
    this._move(t5, s5.dx, s5.dy, s5.dz);
  }
  accumulateParams(t5) {
    this.dx += t5.dx, this.dy += t5.dy, this.dz += t5.dz;
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/OffsetEdgeVertex.js
var P2 = class {
  constructor(t5, i7, e8, s5 = 0, n5 = j7.IMMEDIATE) {
    this._helper = t5, this._planeType = i7, this._edge = e8, this.distance = s5, this._plane = p(), this._offsetPlane = p(), this._minDistance = -1 / 0, this._maxDistance = 1 / 0, this._selectedArrow = 1, n5 === j7.IMMEDIATE && this._initialize();
  }
  get plane() {
    return this._plane;
  }
  get requiresSplitEdgeLeft() {
    return !this._left.isOriginalDirection;
  }
  get requiresSplitEdgeRight() {
    return !this._right.isOriginalDirection;
  }
  get edgeDirection() {
    return this._edgeDirection;
  }
  _initialize() {
    this._initializeNeighbors(), this._initializePlane(), this._initializeDistanceConstraints();
  }
  _initializeNeighbors() {
    var _a, _b, _c, _d;
    const t5 = this._toXYZ(this._edge.leftVertex.pos), i7 = this._toXYZ((_b = (_a = this._edge.leftVertex.leftEdge) == null ? void 0 : _a.leftVertex) == null ? void 0 : _b.pos), e8 = this._toXYZ(this._edge.rightVertex.pos), s5 = this._toXYZ((_d = (_c = this._edge.rightVertex.rightEdge) == null ? void 0 : _c.rightVertex) == null ? void 0 : _d.pos);
    this._edgeDirection = H(n(), t5, e8), this._left = this._computeNeighbor(t5, i7, this._edgeDirection), this._right = this._computeNeighbor(e8, s5, this._edgeDirection);
  }
  _toXYZ(t5) {
    return r(t5) ? this._helper.toXYZ(t5) : null;
  }
  _pointToXYZ(t5) {
    return this._toXYZ(this._helper.pointToVector(t5));
  }
  _computeNeighbor(t5, i7, s5) {
    if (t(i7))
      return { start: t5, end: i7, direction: r2(-s5[1], s5[0], 0), isOriginalDirection: true };
    const n5 = H(n(), t5, i7), r12 = !this._passesBisectingAngleThreshold(n5, s5);
    return { start: t5, end: i7, direction: r12 ? this._bisectVectorsPerpendicular(s5, n5) : n5, isOriginalDirection: !r12 };
  }
  _passesBisectingAngleThreshold(t5, i7) {
    const e8 = Math.abs(a3(i7, t5));
    return e8 >= T && e8 <= Math.PI - T;
  }
  _bisectVectorsPerpendicular(t5, i7) {
    const e8 = P(t5, i7) < 0 ? t5 : j(n(), t5), s5 = Math.abs(P(e8, i7));
    if (!(s5 < Z || s5 > 1 - Z))
      return this._bisectDirection(e8, i7);
    const n5 = _(n(), e8, [0, 0, 1]);
    return z(n5, n5);
  }
  _bisectDirection(t5, i7) {
    const e8 = u(n(), t5, i7);
    return z(e8, e8);
  }
  _initializePlane() {
    const t5 = this._computeNormalDirection(this._left), i7 = this._computeNormalDirection(this._right);
    P(t5, i7) < 0 && j(i7, i7), _2(this._left.start, this._bisectDirection(t5, i7), this._plane);
  }
  _computeNormalDirection(t5) {
    const i7 = _(n(), t5.direction, this._edgeDirection);
    z(i7, i7);
    const e8 = _(n(), this._edgeDirection, i7);
    return this._planeType === A4.XY && (e8[2] = 0), z(e8, e8);
  }
  _initializeDistanceConstraints() {
    r(this._left.end) && !this.requiresSplitEdgeLeft && this._updateDistanceConstraint(R2(this._plane, this._left.end)), r(this._right.end) && !this.requiresSplitEdgeRight && this._updateDistanceConstraint(R2(this._plane, this._right.end)), this._updateIntersectDistanceConstraint(this._plane);
  }
  _updateDistanceConstraint(t5) {
    t5 <= 0 && (this._minDistance = Math.max(this._minDistance, t5)), t5 >= 0 && (this._maxDistance = Math.min(this._maxDistance, t5));
  }
  _updateIntersectDistanceConstraint(t5) {
    const i7 = Y(t5), e8 = this._edgeDirection, o5 = u(n(), this._left.start, this._left.direction), a5 = u(n(), this._right.start, this._right.direction), _3 = this._pointInBasis2D(n4(), i7, e8, this._left.start), c3 = this._pointInBasis2D(n4(), i7, e8, o5), l3 = this._pointInBasis2D(n4(), i7, e8, this._right.start), g3 = this._pointInBasis2D(n4(), i7, e8, a5), [f2] = j5({ start: c3, end: _3, type: b.LINE }, { start: g3, end: l3, type: b.LINE });
    if (!f2)
      return;
    const u4 = o2(n4(), _3, c3);
    v3(u4, u4);
    const D = o2(n4(), f2, c3), E4 = j3(u4, D), b2 = u(n(), o5, g(n(), this._left.direction, -E4)), I = R2(t5, b2);
    this._updateDistanceConstraint(I);
  }
  _pointInBasis2D(t5, i7, e8, s5) {
    return t5[0] = f(i7, s5), t5[1] = f(e8, s5), t5;
  }
  _offset(t5, e8) {
    Number.isFinite(this._minDistance) && (e8 = Math.max(this._minDistance, e8)), Number.isFinite(this._maxDistance) && (e8 = Math.min(this._maxDistance, e8)), A3(this._offsetPlane, this._plane), this._offsetPlane[3] -= e8;
    const s5 = (t6, e9, s6) => r(e9) && V(this._offsetPlane, t6, u(n(), t6, e9), s6), n5 = n();
    (t5 === this._edge.leftVertex ? s5(this._left.start, this._left.direction, n5) : s5(this._right.start, this._right.direction, n5)) && this._helper.copy(this._helper.fromXYZ(n5, void 0, this._helper.getM(t5.pos)), t5.pos);
  }
  selectArrowFromStartPoint(t5) {
    this._selectedArrow = z2(this.plane, this._pointToXYZ(t5)) ? 1 : -1;
  }
  get selectedArrow() {
    return this._selectedArrow;
  }
  signedDistanceToPoint(t5) {
    return R2(this.plane, this._pointToXYZ(t5));
  }
  apply(t5) {
    this._offset(t5, this.distance);
  }
  undo(t5) {
    this._offset(t5, 0);
  }
  canAccumulate(t5) {
    return t5 instanceof P2 && this._edge.leftVertex.index === t5._edge.leftVertex.index && this._edge.rightVertex.index === t5._edge.rightVertex.index && this._edge.component === t5._edge.component && this._maybeEqualsVec3(this._left.direction, t5._left.direction) && this._maybeEqualsVec3(this._right.direction, t5._right.direction) && G(Y(this._plane), Y(t5._plane));
  }
  accumulate(t5, i7) {
    const e8 = this._plane[3] - i7._plane[3] + i7.distance;
    this._offset(t5, e8);
  }
  accumulateParams(t5) {
    const i7 = t5.distance - t5._plane[3];
    this.distance = i7 + this._plane[3];
  }
  clone() {
    const t5 = new P2(this._helper, this._planeType, this._edge, this.distance, j7.DEFERRED);
    return A3(t5._plane, this._plane), A3(t5._offsetPlane, this._offsetPlane), t5._maxDistance = this._maxDistance, t5._minDistance = this._minDistance, t5._left = this._cloneNeighbor(this._left), t5._right = this._cloneNeighbor(this._right), t5._edgeDirection = r3(n(), this._edgeDirection), t5;
  }
  _maybeEqualsVec3(t5, s5) {
    return t(t5) && t(s5) || r(t5) && r(s5) && G(t5, s5);
  }
  _cloneNeighbor({ start: t5, end: e8, direction: s5, isOriginalDirection: n5 }) {
    return { start: r3(n(), t5), end: r(e8) ? r3(n(), e8) : null, direction: r3(n(), s5), isOriginalDirection: n5 };
  }
};
var T = m(15);
var Z = 1e-3;
var A4;
var j7;
!function(t5) {
  t5[t5.XYZ = 0] = "XYZ", t5[t5.XY = 1] = "XY";
}(A4 || (A4 = {})), function(t5) {
  t5[t5.IMMEDIATE = 0] = "IMMEDIATE", t5[t5.DEFERRED = 1] = "DEFERRED";
}(j7 || (j7 = {}));

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/RotateVertex.js
var s4 = class {
  constructor(t5, a5, s5 = e6.CUMULATIVE) {
    this.origin = t5, this.angle = a5, this._accumulationType = s5;
  }
  _rotate(t5, i7) {
    L(t5.pos, t5.pos, this.origin, i7);
  }
  apply(t5) {
    this._rotate(t5, this.angle);
  }
  undo(t5) {
    this._rotate(t5, -this.angle);
  }
  canAccumulate(a5) {
    return a5 instanceof s4 && i(this.origin, a5.origin);
  }
  accumulate(t5, a5) {
    const s5 = a5._accumulationType === e6.REPLACE;
    this._rotate(t5, s5 ? a5.angle - this.angle : a5.angle);
  }
  accumulateParams(t5) {
    const a5 = t5._accumulationType === e6.REPLACE;
    this.angle = a5 ? t5.angle : this.angle + t5.angle;
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/ScaleVertex.js
var c2 = class {
  constructor(t5, a5, c3, o5, r12 = e6.CUMULATIVE) {
    this.origin = t5, this.axis1 = a5, this.factor1 = c3, this.factor2 = o5, this._accumulationType = r12, this.axis2 = r6(a5[1], -a5[0]);
  }
  _scale(t5, s5, i7) {
    w2(t5.pos, t5.pos, this.origin, this.axis1, s5), w2(t5.pos, t5.pos, this.origin, this.axis2, i7);
  }
  apply(t5) {
    this._scale(t5, this.factor1, this.factor2);
  }
  undo(t5) {
    this._scale(t5, 1 / this.factor1, 1 / this.factor2);
  }
  canAccumulate(s5) {
    return s5 instanceof c2 && i(this.origin, s5.origin) && i(this.axis1, s5.axis1);
  }
  accumulate(t5, s5) {
    s5._accumulationType === e6.REPLACE ? this._scale(t5, s5.factor1 / this.factor1, s5.factor2 / this.factor2) : this._scale(t5, s5.factor1, s5.factor2);
  }
  accumulateParams(t5) {
    const s5 = t5._accumulationType === e6.REPLACE;
    this.factor1 = s5 ? t5.factor1 : this.factor1 * t5.factor1, this.factor2 = s5 ? t5.factor2 : this.factor2 * t5.factor2;
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/UndoGroup.js
var t4 = class {
  constructor() {
    this._operations = [], this._closed = false;
  }
  close() {
    this._closed = true;
  }
  apply() {
    for (const t5 of this._operations)
      t5.apply();
  }
  undo() {
    for (let t5 = this._operations.length - 1; t5 >= 0; t5--)
      this._operations[t5].undo();
  }
  accumulate(t5) {
    if (this._closed)
      return false;
    const o5 = this._operations.length ? this._operations[this._operations.length - 1] : null;
    return o5 && o5.accumulate(t5) || (this._operations.push(t5), t5.apply()), true;
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/EditGeometryOperations.js
var V2 = class extends n2 {
  constructor(e8) {
    super(), this.data = e8, this._undoStack = [], this._redoStack = [], this._listener = this.data.on("change", (e9) => {
      e9.addedVertices && this.emit("vertex-add", { type: "vertex-add", vertices: e9.addedVertices, operation: e9.operation }), e9.removedVertices && this.emit("vertex-remove", { type: "vertex-remove", vertices: e9.removedVertices, operation: e9.operation }), e9.updatedVertices && this.emit("vertex-update", { type: "vertex-update", vertices: e9.updatedVertices, operation: e9.operation });
    });
  }
  destroy() {
    this._listener.remove();
  }
  splitEdge(e8, t5) {
    return this._apply(new r10(this.data, e8, t5));
  }
  updateVertices(e8, t5, r12 = E3.ACCUMULATE_STEPS) {
    return this._apply(new t2(this.data, e8, t5), r12);
  }
  moveVertices(e8, t5, r12, s5, i7 = E3.ACCUMULATE_STEPS) {
    return this.updateVertices(e8, new t3(this.data.coordinateHelper, t5, r12, s5), i7);
  }
  scaleVertices(e8, t5, r12, s5, i7, a5 = E3.ACCUMULATE_STEPS, p4 = e6.CUMULATIVE) {
    return this.updateVertices(e8, new c2(t5, r12, s5, i7, p4), a5);
  }
  rotateVertices(e8, t5, r12, s5 = E3.ACCUMULATE_STEPS, i7 = e6.CUMULATIVE) {
    return this.updateVertices(e8, new s4(t5, r12, i7), s5);
  }
  removeVertices(e8) {
    return this._apply(new r9(this.data, e8, this._minNumVerticesPerType));
  }
  appendVertex(e8) {
    return 0 === this.data.components.length ? null : this._apply(new d2(this.data, this.data.components[0], e8));
  }
  setVertexPosition(e8, t5) {
    return this._apply(new i5(this.data, e8, t5));
  }
  offsetEdge(e8, t5, r12, s5 = E3.ACCUMULATE_STEPS) {
    return this.updateVertices([t5.leftVertex, t5.rightVertex], new P2(this.data.coordinateHelper, e8, t5, r12), s5);
  }
  closeComponent(e8) {
    return this.data.components.includes(e8) ? this._apply(new i6(this.data, e8)) : null;
  }
  canRemoveVertex() {
    return this.data.components[0].vertices.length > this._minNumVerticesPerType;
  }
  createUndoGroup() {
    const e8 = new t4();
    return this._apply(e8), { remove: () => e8.close() };
  }
  undo() {
    if (this._undoStack.length > 0) {
      const e8 = this._undoStack.pop();
      return e8.undo(), this._redoStack.push(e8), e8;
    }
    return null;
  }
  redo() {
    if (this._redoStack.length > 0) {
      const e8 = this._redoStack.pop();
      return e8.apply(), this._undoStack.push(e8), e8;
    }
    return null;
  }
  get canUndo() {
    return this._undoStack.length > 0;
  }
  get canRedo() {
    return this._redoStack.length > 0;
  }
  get lastOperation() {
    return this._undoStack.length > 0 ? this._undoStack[this._undoStack.length - 1] : null;
  }
  get _minNumVerticesPerType() {
    switch (this.data.type) {
      case "point":
        return 1;
      case "polyline":
        return 2;
      case "polygon":
        return 3;
      default:
        return 0;
    }
  }
  _apply(e8, r12 = E3.ACCUMULATE_STEPS) {
    return r12 !== E3.NEW_STEP && !t(this.lastOperation) && this.lastOperation.accumulate(e8) || (e8.apply(), this._undoStack.push(e8), this._redoStack = []), e8;
  }
  static fromGeometry(e8, t5) {
    return new V2(g2.fromGeometry(e8, t5));
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/SnappingContext.js
var e7 = class {
  constructor(e8) {
    this.vertexHandle = null, this.excludeFeature = null, this.visualizer = null, this.selfSnappingZ = null, this.editGeometryOperations = e8.editGeometryOperations, this.elevationInfo = e8.elevationInfo, this.pointer = e8.pointer, this.vertexHandle = e8.vertexHandle, this.excludeFeature = e8.excludeFeature, this.visualizer = e8.visualizer, this.selfSnappingZ = e8.selfSnappingZ;
  }
  get coordinateHelper() {
    return this.editGeometryOperations.data.coordinateHelper;
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/SnappingVisualizer.js
var r11 = class {
  draw(r12, a5) {
    const p4 = this._getUniqueHints(r12), h2 = [];
    for (const i7 of p4)
      i7 instanceof o3 && h2.push(this.visualizeIntersectionPoint(i7, a5)), i7 instanceof s && h2.push(this.visualizeLine(i7, a5)), i7 instanceof r7 && h2.push(this.visualizeParallelSign(i7, a5)), i7 instanceof s2 && h2.push(this.visualizeRightAngleQuad(i7, a5)), i7 instanceof s3 && h2.push(this.visualizePoint(i7, a5));
    return r4(h2);
  }
  _getUniqueHints(i7) {
    const n5 = [];
    for (const t5 of i7) {
      let i8 = true;
      for (const s5 of n5)
        if (t5.equals(s5)) {
          i8 = false;
          break;
        }
      i8 && n5.push(t5);
    }
    return n5;
  }
};

export {
  r11 as r,
  i4 as i,
  u3 as u,
  w4 as w,
  p3 as p,
  g2 as g,
  E3 as E,
  t2 as t,
  e6 as e,
  t3 as t2,
  P2 as P,
  A4 as A,
  s4 as s,
  c2 as c,
  V2 as V,
  e7 as e2
};
//# sourceMappingURL=chunk-6W5CPYUF.js.map
