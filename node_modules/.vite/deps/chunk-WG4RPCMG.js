import {
  r as r3
} from "./chunk-EHTPZ3ZP.js";
import {
  e as e2
} from "./chunk-K3TAVS2D.js";
import {
  h as h2,
  n as n2,
  p,
  u as u2
} from "./chunk-AGHOAN2O.js";
import {
  a2,
  v as v3
} from "./chunk-WEBU4A2Q.js";
import {
  a
} from "./chunk-372DRRBO.js";
import {
  r as r2
} from "./chunk-X7GQR2IY.js";
import {
  e2 as e4,
  o3 as o5,
  o4 as o6,
  v2
} from "./chunk-HNRPDSCT.js";
import {
  o as o4
} from "./chunk-ZSBQER52.js";
import {
  n as n3
} from "./chunk-S6WNSMC7.js";
import {
  e as e5
} from "./chunk-JPRTIOCM.js";
import {
  d,
  i2 as i,
  o as o3
} from "./chunk-AMNM3DGI.js";
import {
  h
} from "./chunk-SBPLVEUA.js";
import {
  u
} from "./chunk-3IISYLTT.js";
import {
  c,
  d as d2,
  v
} from "./chunk-7QNA4ADD.js";
import {
  e as e3
} from "./chunk-6ZCPLPAF.js";
import {
  o as o2
} from "./chunk-MYQCUAHK.js";
import {
  e
} from "./chunk-BQL7VXQR.js";
import {
  o as o7
} from "./chunk-735C75BI.js";
import {
  n,
  o
} from "./chunk-ZLTZ3KAT.js";
import {
  O
} from "./chunk-RUM3DXFX.js";
import {
  r
} from "./chunk-ZEEU5HOK.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/PathVertexPosition.glsl.js
var f = 8;
function n4(e6, c2) {
  e6.attributes.add(O.FEATUREVALUE, "vec4");
  const n5 = e6.vertex;
  n5.code.add(n`bool isCapVertex() {
return featureValue.w == 1.0;
}`), n5.uniforms.add(new e("size", (e7) => e7.size)), c2.vvSize ? (n5.uniforms.add(new e3("vvSizeMinSize", (e7) => e7.vvSizeMinSize)), n5.uniforms.add(new e3("vvSizeMaxSize", (e7) => e7.vvSizeMaxSize)), n5.uniforms.add(new e3("vvSizeOffset", (e7) => e7.vvSizeOffset)), n5.uniforms.add(new e3("vvSizeFactor", (e7) => e7.vvSizeFactor)), n5.code.add(n`vec2 getSize() {
return size * clamp(vvSizeOffset + featureValue.x * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).xz;
}`)) : n5.code.add(n`vec2 getSize(){
return size;
}`), c2.vvOpacity ? (n5.constants.add("vvOpacityNumber", "int", f), n5.uniforms.add([new o5("vvOpacityValues", (e7) => e7.vvOpacityValues, f), new o5("vvOpacityOpacities", (e7) => e7.vvOpacityOpacities, f)]), n5.code.add(n`vec4 applyOpacity(vec4 color) {
float value = featureValue.z;
if (value <= vvOpacityValues[0]) {
return vec4( color.xyz, vvOpacityOpacities[0]);
}
for (int i = 1; i < vvOpacityNumber; ++i) {
if (vvOpacityValues[i] >= value) {
float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);
return vec4( color.xyz, mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f));
}
}
return vec4( color.xyz, vvOpacityOpacities[vvOpacityNumber - 1]);
}`)) : n5.code.add(n`vec4 applyOpacity(vec4 color){
return color;
}`), c2.vvColor ? (n5.constants.add("vvColorNumber", "int", o6), n5.uniforms.add([new o5("vvColorValues", (e7) => e7.vvColorValues, o6), new e4("vvColorColors", (e7) => e7.vvColorColors, o6)]), n5.code.add(n`vec4 getColor() {
float value = featureValue.y;
if (value <= vvColorValues[0]) {
return applyOpacity(vvColorColors[0]);
}
for (int i = 1; i < vvColorNumber; ++i) {
if (vvColorValues[i] >= value) {
float f = (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);
return applyOpacity(mix(vvColorColors[i-1], vvColorColors[i], f));
}
}
return applyOpacity(vvColorColors[vvColorNumber - 1]);
}`)) : n5.code.add(n`vec4 getColor(){
return applyOpacity(vec4(1, 1, 1, 1));
}`), e6.include(o3), e6.attributes.add(O.PROFILERIGHT, "vec4"), e6.attributes.add(O.PROFILEUP, "vec4"), e6.attributes.add(O.PROFILEVERTEXANDNORMAL, "vec4"), n5.code.add(n`vec3 calculateVPos() {
vec2 size = getSize();
vec3 origin = position;
vec3 right = profileRight.xyz;
vec3 up = profileUp.xyz;
vec3 forward = cross(up, right);
vec2 profileVertex = profileVertexAndNormal.xy * size;
vec2 profileNormal = profileVertexAndNormal.zw;
float positionOffsetAlongProfilePlaneNormal = 0.0;
float normalOffsetAlongProfilePlaneNormal = 0.0;`), n5.code.add(n`if(!isCapVertex()) {
vec2 rotationRight = vec2(profileRight.w, profileUp.w);
float maxDistance = length(rotationRight);`), n5.code.add(n`rotationRight = maxDistance > 0.0 ? normalize(rotationRight) : vec2(0, 0);
float rx = dot(profileVertex, rotationRight);
if (abs(rx) > maxDistance) {
vec2 rotationUp = vec2(-rotationRight.y, rotationRight.x);
float ry = dot(profileVertex, rotationUp);
profileVertex = rotationRight * maxDistance * sign(rx) + rotationUp * ry;
}
}else{
positionOffsetAlongProfilePlaneNormal = profileRight.w * size[0];
normalOffsetAlongProfilePlaneNormal = profileUp.w;
}
vec3 offset = right * profileVertex.x + up * profileVertex.y + forward * positionOffsetAlongProfilePlaneNormal;
return origin + offset;
}`), n5.code.add(n`vec3 localNormal() {
vec3 right = profileRight.xyz;
vec3 up = profileUp.xyz;
vec3 forward = cross(up, right);
vec2 profileNormal = profileVertexAndNormal.zw;
vec3 normal = right * profileNormal.x + up * profileNormal.y;
if(isCapVertex()) {
normal += forward * profileUp.w;
}
return normal;
}`);
}
var p2 = class extends v2 {
  constructor() {
    super(...arguments), this.size = r(1, 1);
  }
};

// node_modules/@arcgis/core/chunks/Path.glsl.js
function F(F2) {
  const _2 = new o(), { vertex: M, fragment: O2 } = _2;
  switch (v(M, F2), _2.varyings.add("vpos", "vec3"), _2.include(n4, F2), F2.output !== h.Color && F2.output !== h.Alpha || (_2.include(r2, F2), _2.include(v3, F2), _2.include(d, F2), _2.varyings.add("vnormal", "vec3"), _2.varyings.add("vcolor", "vec4"), F2.hasMultipassTerrain && _2.varyings.add("depth", "float"), M.code.add(n`
      void main() {
        vpos = calculateVPos();
        vnormal = normalize(localNormal());

        ${F2.hasMultipassTerrain ? "depth = (view * vec4(vpos, 1.0)).z;" : ""}
        gl_Position = transformPosition(proj, view, vpos);

        ${F2.output === h.Color ? "forwardLinearDepth();" : ""}

        vcolor = getColor();
      }
    `)), _2.include(n3, F2), F2.output) {
    case h.Alpha:
      _2.include(u, F2), O2.uniforms.add(new o7("opacity", (e6) => e6.opacity)), O2.code.add(n`
      void main() {
        discardBySlice(vpos);
        ${F2.hasMultipassTerrain ? "terrainDepthTest(gl_FragCoord, depth);" : ""}
        float combinedOpacity = vcolor.a * opacity;
        gl_FragColor = vec4(combinedOpacity);
      }
    `);
      break;
    case h.Color:
      _2.include(u, F2), _2.include(p, F2), _2.include(n2, F2), _2.include(v3, F2), _2.include(e2, F2), c(O2, F2), h2(O2), u2(O2), O2.uniforms.add([M.uniforms.get("localOrigin"), new e3("ambient", (e6) => e6.ambient), new e3("diffuse", (e6) => e6.diffuse), new e3("specular", (e6) => e6.specular), new o7("opacity", (e6) => e6.opacity)]), O2.include(e5), a2(O2), O2.code.add(n`
        void main() {
          discardBySlice(vpos);
          ${F2.hasMultipassTerrain ? "terrainDepthTest(gl_FragCoord, depth);" : ""}

          shadingParams.viewDirection = normalize(vpos - cameraPosition);
          shadingParams.normalView = vnormal;
          vec3 normal = shadingNormal(shadingParams);
          float ssao = evaluateAmbientOcclusionInverse();

          float additionalAmbientScale = additionalDirectedAmbientLight(vpos + localOrigin);
          vec3 additionalLight = ssao * mainLightIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;
          ${F2.receiveShadows ? "float shadow = readShadowMap(vpos, linearDepth);" : F2.spherical ? "float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);" : "float shadow = 0.0;"}
          vec3 albedo = vcolor.rgb * max(ambient, diffuse); // combine the old material parameters into a single one
          float combinedOpacity = vcolor.a * opacity;
          albedo += 0.25 * specular; // don't completely ignore specular for now

          vec3 shadedColor = evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight);
          gl_FragColor = vec4(shadedColor, combinedOpacity);
          gl_FragColor = highlightSlice(gl_FragColor, vpos);
          ${F2.transparencyPassType === o2.Color ? "gl_FragColor = premultiplyAlpha(gl_FragColor);" : ""}
        }
      `);
      break;
    case h.Depth:
    case h.Shadow:
    case h.ShadowHighlight:
    case h.ShadowExludeHighlight:
      _2.include(r2, F2), i(_2), _2.varyings.add("depth", "float"), M.code.add(n`void main() {
vpos = calculateVPos();
gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);
}`), _2.include(u, F2), _2.include(o4, F2), O2.code.add(n`void main() {
discardBySlice(vpos);
outputDepth(depth);
}`);
      break;
    case h.Normal:
      _2.include(r2, F2), _2.include(r3, F2), d2(M), _2.varyings.add("vnormal", "vec3"), M.code.add(n`void main(void) {
vpos = calculateVPos();
vnormal = normalize((viewNormal * vec4(localNormal(), 1.0)).xyz);
gl_Position = transformPosition(proj, view, vpos);
}`), _2.include(u, F2), O2.code.add(n`void main() {
discardBySlice(vpos);
vec3 normal = normalize(vnormal);
if (gl_FrontFacing == false) normal = -normal;
gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);
}`);
      break;
    case h.Highlight:
      _2.include(r2, F2), _2.include(r3, F2), _2.varyings.add("vnormal", "vec3"), M.code.add(n`void main(void) {
vpos = calculateVPos();
gl_Position = transformPosition(proj, view, vpos);
}`), _2.include(u, F2), _2.include(a, F2), O2.code.add(n`void main() {
discardBySlice(vpos);
outputHighlight();
}`);
  }
  return _2;
}
var _ = Object.freeze(Object.defineProperty({ __proto__: null, build: F }, Symbol.toStringTag, { value: "Module" }));

export {
  p2 as p,
  F,
  _
};
//# sourceMappingURL=chunk-WG4RPCMG.js.map
