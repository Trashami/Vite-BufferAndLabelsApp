import {
  z
} from "./chunk-2NKIENHY.js";
import {
  E2 as E,
  Y,
  u
} from "./chunk-WJCI2CGX.js";
import {
  v2 as v
} from "./chunk-3MNMDUQZ.js";
import {
  R,
  j,
  w
} from "./chunk-UWG37XSU.js";
import {
  r
} from "./chunk-LNZAOBFW.js";
import {
  e,
  m,
  n2 as n,
  y
} from "./chunk-OOLCFNXJ.js";

// node_modules/@arcgis/core/views/interactive/sketch/SketchLabelOptions.js
var t = class extends m {
  constructor(o) {
    super(o), this.enabled = false;
  }
};
e([y({ type: Boolean, nonNullable: true })], t.prototype, "enabled", void 0), t = e([n("esri.views.interactive.sketch.SketchLabelOptions")], t);
var c = t;

// node_modules/@arcgis/core/geometry/Circle.js
var d;
var h = d = class extends v {
  constructor(...e2) {
    super(...e2), this.center = null, this.geodesic = false, this.numberOfPoints = 60, this.radius = 1e3, this.radiusUnit = "meters";
  }
  normalizeCtorArgs(e2, r2) {
    let t2;
    if (e2 && e2.center)
      t2 = e2;
    else {
      if (e2 && e2.rings)
        return super.normalizeCtorArgs(e2, r2);
      t2 = { center: e2 };
    }
    return { ...super.normalizeCtorArgs(), ...t2, ...r2 };
  }
  initialize() {
    var _a;
    const e2 = this.center, s = this.numberOfPoints;
    if (this.hasZ = (_a = e2 == null ? void 0 : e2.hasZ) != null ? _a : false, 0 !== this.rings.length || !e2)
      return;
    const i = E(this.radius, this.radiusUnit, "meters"), o = e2.spatialReference;
    let c2, a = "geographic";
    if (o.isWebMercator ? a = "webMercator" : (null != (o.wkid && r[o.wkid]) || o.wkt && 0 === o.wkt.indexOf("PROJCS")) && (a = "projected"), this.geodesic) {
      let r2;
      switch (a) {
        case "webMercator":
          r2 = j(e2);
          break;
        case "projected":
          console.error("Creating a geodesic circle requires the center to be specified in web mercator or geographic coordinate system");
          break;
        case "geographic":
          r2 = e2;
      }
      c2 = this._createGeodesicCircle(r2, i, s), "webMercator" === a && (c2 = R(c2));
    } else {
      let r2;
      "webMercator" === a || "projected" === a ? r2 = i / this._convert2Meters(1, e2.spatialReference) : "geographic" === a && (r2 = Y(i, "meters", u(e2.spatialReference).radius)), c2 = this._createPlanarCircle(e2, r2, s);
    }
    this.spatialReference = c2.spatialReference, this.addRing(c2.rings[0]);
  }
  clone() {
    const { center: e2, numberOfPoints: r2, radius: t2, radiusUnit: s, geodesic: i } = this;
    return new d({ center: e2 == null ? void 0 : e2.clone(), numberOfPoints: r2, radius: t2, radiusUnit: s, geodesic: i });
  }
  _createGeodesicCircle(e2, r2, t2) {
    let s = 0;
    const i = [];
    for (; s < 360; ) {
      const o = [0, 0], c2 = [e2.x, e2.y];
      z(o, c2, s, r2), this.hasZ && o.push(e2.z), i.push(o), s += 360 / t2;
    }
    return i.push(i[0]), new v(i);
  }
  _createPlanarCircle(e2, r2, t2) {
    const s = [], i = 2 * Math.PI / t2;
    for (let o = 0; o < t2; ++o) {
      const t3 = i * o, c2 = [e2.x + Math.cos(-t3) * r2, e2.y + Math.sin(-t3) * r2];
      this.hasZ && c2.push(e2.z), s.push(c2);
    }
    return s.push(s[0]), new v({ spatialReference: e2.spatialReference, rings: [s] });
  }
  _convert2Meters(e2, r2) {
    let t2;
    if (r2.wkid && null != r[r2.wkid])
      t2 = r.values[r[r2.wkid]];
    else {
      const e3 = r2.wkt, s = e3.lastIndexOf(",") + 1, i = e3.lastIndexOf("]]");
      t2 = parseFloat(e3.substring(s, i));
    }
    return e2 * t2;
  }
};
e([y({ type: w })], h.prototype, "center", void 0), e([y()], h.prototype, "geodesic", void 0), e([y()], h.prototype, "numberOfPoints", void 0), e([y()], h.prototype, "radius", void 0), e([y()], h.prototype, "radiusUnit", void 0), h = d = e([n("esri.geometry.Circle")], h);
var m2 = h;

export {
  m2 as m,
  c
};
//# sourceMappingURL=chunk-OFXOSNPT.js.map
