import {
  A,
  a,
  s
} from "./chunk-XMZAPOBR.js";
import {
  D,
  u,
  x
} from "./chunk-6M2AHKYV.js";
import {
  E
} from "./chunk-LNZAOBFW.js";
import {
  r,
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/layers/graphics/dehydratedFeatureComparison.js
function i(t3, r2) {
  return t3 === r2 || r(t3) && r(r2) && E(t3.spatialReference, r2.spatialReference) && t3.x === r2.x && t3.y === r2.y && t3.z === r2.z && t3.m === r2.m;
}

// node_modules/@arcgis/core/layers/graphics/dehydratedFeatures.js
var j = class {
  constructor(e3, t3, s2) {
    this.uid = e3, this.geometry = t3, this.attributes = s2, this.visible = true, this.objectId = null, this.centroid = null;
  }
};
function M(e3) {
  return r(e3.geometry);
}
var N = class {
  constructor() {
    this.exceededTransferLimit = false, this.features = [], this.fields = [], this.hasM = false, this.hasZ = false, this.geometryType = null, this.objectIdFieldName = null, this.globalIdFieldName = null, this.geometryProperties = null, this.geohashFieldName = null, this.spatialReference = null, this.transform = null;
  }
};
function v2(e3, t3, s2, r2) {
  return { x: e3, y: t3, z: s2, hasZ: null != s2, hasM: false, spatialReference: r2, type: "point" };
}
function w(e3) {
  if (t(e3))
    return 0;
  switch (e3.type) {
    case "point":
      return 1;
    case "polyline": {
      let t3 = 0;
      for (const s2 of e3.paths)
        t3 += s2.length;
      return t3;
    }
    case "polygon": {
      let t3 = 0;
      for (const s2 of e3.rings)
        t3 += s2.length;
      return t3;
    }
    case "multipoint":
      return e3.points.length;
    case "extent":
      return 2;
    case "mesh": {
      const t3 = e3.vertexAttributes && e3.vertexAttributes.position;
      return t3 ? t3.length / 3 : 0;
    }
    default:
      return;
  }
}
function T(e3, t3) {
  switch (A(t3), "mesh" === e3.type && (e3 = e3.extent), e3.type) {
    case "point":
      t3[0] = t3[3] = e3.x, t3[1] = t3[4] = e3.y, e3.hasZ && (t3[2] = t3[5] = e3.z);
      break;
    case "polyline":
      for (let s2 = 0; s2 < e3.paths.length; s2++)
        s(t3, e3.paths[s2], e3.hasZ);
      break;
    case "polygon":
      for (let s2 = 0; s2 < e3.rings.length; s2++)
        s(t3, e3.rings[s2], e3.hasZ);
      break;
    case "multipoint":
      s(t3, e3.points, e3.hasZ);
      break;
    case "extent":
      t3[0] = e3.xmin, t3[1] = e3.ymin, t3[3] = e3.xmax, t3[4] = e3.ymax, null != e3.zmin && (t3[2] = e3.zmin), null != e3.zmax && (t3[5] = e3.zmax);
  }
}
function J(e3, t3) {
  switch (D(t3), "mesh" === e3.type && (e3 = e3.extent), e3.type) {
    case "point":
      t3[0] = t3[2] = e3.x, t3[1] = t3[3] = e3.y;
      break;
    case "polyline":
      for (let s2 = 0; s2 < e3.paths.length; s2++)
        x(t3, e3.paths[s2]);
      break;
    case "polygon":
      for (let s2 = 0; s2 < e3.rings.length; s2++)
        x(t3, e3.rings[s2]);
      break;
    case "multipoint":
      x(t3, e3.points);
      break;
    case "extent":
      t3[0] = e3.xmin, t3[1] = e3.ymin, t3[2] = e3.xmax, t3[3] = e3.ymax;
  }
}
function O(e3, t3) {
  return null != e3.objectId ? e3.objectId : e3.attributes && t3 ? e3.attributes[t3] : null;
}
var P = a();
var U = u();

export {
  i,
  j,
  M,
  N,
  v2 as v,
  w,
  T,
  J,
  O
};
//# sourceMappingURL=chunk-IJUE2JUP.js.map
