import {
  a as a2,
  e as e2,
  i as i2
} from "./chunk-OFHPHLJU.js";
import {
  i as i3,
  m,
  o as o2
} from "./chunk-DPGI5XTT.js";
import {
  o as o3
} from "./chunk-MGP5J42F.js";
import "./chunk-QXJIQKLY.js";
import {
  n3
} from "./chunk-GRWIJKD6.js";
import "./chunk-WGK2FJEK.js";
import "./chunk-CNTOSDAN.js";
import {
  n as n4
} from "./chunk-EWYYYS2T.js";
import "./chunk-7N2Z7KNR.js";
import "./chunk-DBT4KOKX.js";
import "./chunk-EPMXCACW.js";
import "./chunk-KG5RWWIW.js";
import "./chunk-27YO3FKC.js";
import {
  f as f2
} from "./chunk-JMGHYNUW.js";
import "./chunk-SFYX532J.js";
import "./chunk-XBFCIW4K.js";
import {
  he
} from "./chunk-6TBB7UXB.js";
import "./chunk-UO3LS2M5.js";
import {
  E as E2,
  I
} from "./chunk-EQNT4A7P.js";
import {
  s as s2
} from "./chunk-AAL2O6PB.js";
import "./chunk-2GP5D74I.js";
import "./chunk-QISOH77W.js";
import "./chunk-XO5VJRK4.js";
import "./chunk-OAXPH6DL.js";
import {
  E2 as E,
  a
} from "./chunk-O4DPVR3F.js";
import "./chunk-MATM5L52.js";
import "./chunk-4OM3EX6P.js";
import {
  F
} from "./chunk-3OFVLRSL.js";
import "./chunk-UWKVAZQ6.js";
import "./chunk-FV3CMB37.js";
import "./chunk-GX2FDWTU.js";
import "./chunk-TFHLTN6F.js";
import "./chunk-UDYHZLTE.js";
import "./chunk-IQBIGNPU.js";
import "./chunk-4JNOVZUK.js";
import "./chunk-ZNRXLY4R.js";
import {
  n as n2
} from "./chunk-JEA4MMTV.js";
import "./chunk-RG3AHHRL.js";
import "./chunk-75RMBUYZ.js";
import "./chunk-TJ2I6XQT.js";
import "./chunk-EDHROVWI.js";
import "./chunk-34YPGGJT.js";
import "./chunk-ZEEU5HOK.js";
import "./chunk-INL7BDTP.js";
import "./chunk-NDQ5FHGV.js";
import "./chunk-QWNKYSI4.js";
import "./chunk-AIDV7EKX.js";
import "./chunk-FZQZIM7U.js";
import "./chunk-CZBRZ6SU.js";
import "./chunk-KDO6J2FO.js";
import "./chunk-RT3T2K4S.js";
import "./chunk-WJCI2CGX.js";
import "./chunk-REIQNAQW.js";
import "./chunk-NRP45AHD.js";
import {
  u
} from "./chunk-6M2AHKYV.js";
import "./chunk-RAX2HD42.js";
import "./chunk-ZYRIJWLX.js";
import "./chunk-C5H57NTD.js";
import "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import "./chunk-EHPBHJYZ.js";
import "./chunk-3MNMDUQZ.js";
import "./chunk-UWG37XSU.js";
import "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import "./chunk-HLM6QCL2.js";
import "./chunk-RXYULINL.js";
import "./chunk-5NXILPDI.js";
import "./chunk-THVR7IAM.js";
import "./chunk-VWYWOOPX.js";
import "./chunk-M5VHU5LK.js";
import "./chunk-7QMMKGW4.js";
import {
  e,
  n2 as n
} from "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import {
  D,
  j
} from "./chunk-MJXQTGI2.js";
import "./chunk-LIZHLHNA.js";
import "./chunk-BTUHYGXO.js";
import "./chunk-UA3YPL2R.js";
import {
  has
} from "./chunk-HVKDYDPP.js";
import "./chunk-6QC7MLLS.js";
import {
  f,
  i,
  o,
  r,
  s,
  t
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/collisions/MetricReader.js
var e3 = 6;
var r2 = 4294967296;
var o4 = class {
  constructor(t2) {
    this._savedCursor = null, this._savedOffset = null, this._head = t2, this._cursor = t2;
  }
  static from(t2) {
    const s3 = i4.from(new Float32Array(t2));
    return new o4(s3);
  }
  get id() {
    return this._cursor.id;
  }
  get baseZoom() {
    return this._cursor.baseZoom;
  }
  get anchorX() {
    return this._cursor.anchorX;
  }
  get anchorY() {
    return this._cursor.anchorY;
  }
  get directionX() {
    return this._cursor.directionX;
  }
  get directionY() {
    return this._cursor.directionY;
  }
  get size() {
    return this._cursor.size;
  }
  get materialKey() {
    return this._cursor.materialKey;
  }
  get boundsCount() {
    return this._cursor.boundsCount;
  }
  computedMinZoom() {
    return this._cursor.computedMinZoom();
  }
  setComputedMinZoom(t2) {
    return this._cursor.setComputedMinZoom(t2);
  }
  boundsComputedAnchorX(t2) {
    return this._cursor.boundsComputedAnchorX(t2);
  }
  boundsComputedAnchorY(t2) {
    return this._cursor.boundsComputedAnchorY(t2);
  }
  setBoundsComputedAnchorX(t2, s3) {
    return this._cursor.setBoundsComputedAnchorX(t2, s3);
  }
  setBoundsComputedAnchorY(t2, s3) {
    return this._cursor.setBoundsComputedAnchorY(t2, s3);
  }
  boundsX(t2) {
    return this._cursor.boundsX(t2);
  }
  boundsY(t2) {
    return this._cursor.boundsY(t2);
  }
  boundsWidth(t2) {
    return this._cursor.boundsWidth(t2);
  }
  boundsHeight(t2) {
    return this._cursor.boundsHeight(t2);
  }
  link(s3) {
    if (r(s3._head))
      return this._cursor.link(s3._head);
  }
  getCursor() {
    return this.copy();
  }
  copy() {
    var _a;
    const t2 = new o4((_a = this._head) == null ? void 0 : _a.copy());
    if (!t2._head)
      return t2;
    let s3 = t2._head, e4 = t2._head._link;
    for (; e4; )
      s3._link = e4.copy(), s3 = e4, e4 = s3._link;
    return t2;
  }
  peekId() {
    var _a;
    return (_a = this._cursor.peekId()) != null ? _a : this._cursor._link.peekId();
  }
  nextId() {
    const t2 = this.id;
    for (; t2 === this.id; )
      if (!this.next())
        return false;
    return true;
  }
  save() {
    this._savedCursor = this._cursor, this._savedOffset = this._cursor._offset;
  }
  restore() {
    this._savedCursor && (this._cursor = this._savedCursor), null != this._savedOffset && (this._cursor._offset = this._savedOffset);
  }
  next() {
    if (!this._cursor)
      return false;
    if (!this._cursor.next()) {
      if (!this._cursor._link)
        return false;
      this._cursor = this._cursor._link, this._cursor._offset = 0;
    }
    return true;
  }
  lookup(t2) {
    for (this._cursor = this._head; this._cursor && !this._cursor.lookup(t2); ) {
      if (!this._cursor._link)
        return false;
      this._cursor = this._cursor._link;
    }
    return !!this._cursor;
  }
  delete(s3) {
    let e4 = this._head, r4 = null;
    for (; e4; ) {
      if (e4.delete(s3))
        return e4.isEmpty() && r(r4) && (r4._link = e4._link), true;
      r4 = e4, e4 = e4._link;
    }
    return false;
  }
};
var i4 = class {
  constructor(t2) {
    this._offset = -1, this._link = null, this._count = 0, this._deletedCount = 0, this._offsets = { instance: null }, this._buffer = t2;
  }
  static from(t2) {
    return new i4(new Float32Array(t2));
  }
  isEmpty() {
    return this._deletedCount === this.count;
  }
  get count() {
    return this._count || (this._count = this._computeCount()), this._count;
  }
  get id() {
    return this._buffer[this._offset + 0];
  }
  set id(t2) {
    this._buffer[this._offset + 0] = t2;
  }
  get baseZoom() {
    return this._buffer[this._offset + 1];
  }
  get anchorX() {
    return this._buffer[this._offset + 2];
  }
  get anchorY() {
    return this._buffer[this._offset + 3];
  }
  get directionX() {
    return this._buffer[this._offset + 4];
  }
  get directionY() {
    return this._buffer[this._offset + 5];
  }
  get size() {
    return this._buffer[this._offset + 6];
  }
  get materialKey() {
    return this._buffer[this._offset + 7];
  }
  computedMinZoom() {
    return this._buffer[this._offset + 8];
  }
  setComputedMinZoom(t2) {
    this._buffer[this._offset + 8] = t2;
  }
  get boundsCount() {
    return this._buffer[this._offset + 9];
  }
  boundsComputedAnchorX(t2) {
    return this._buffer[this._offset + 10 + t2 * e3 + 0];
  }
  boundsComputedAnchorY(t2) {
    return this._buffer[this._offset + 10 + t2 * e3 + 1];
  }
  setBoundsComputedAnchorX(t2, s3) {
    this._buffer[this._offset + 10 + t2 * e3 + 0] = s3;
  }
  setBoundsComputedAnchorY(t2, s3) {
    this._buffer[this._offset + 10 + t2 * e3 + 1] = s3;
  }
  boundsX(t2) {
    return this._buffer[this._offset + 10 + t2 * e3 + 2];
  }
  boundsY(t2) {
    return this._buffer[this._offset + 10 + t2 * e3 + 3];
  }
  boundsWidth(t2) {
    return this._buffer[this._offset + 10 + t2 * e3 + 4];
  }
  boundsHeight(t2) {
    return this._buffer[this._offset + 10 + t2 * e3 + 5];
  }
  link(t2) {
    let s3 = this;
    for (; s3._link; )
      s3 = s3._link;
    s3._link = t2;
  }
  getCursor() {
    return this.copy();
  }
  copy() {
    const t2 = new i4(this._buffer);
    return t2._link = this._link, t2._offset = this._offset, t2._deletedCount = this._deletedCount, t2._offsets = this._offsets, t2._count = this._count, t2;
  }
  peekId() {
    const t2 = this._offset + 10 + this.boundsCount * e3 + 0;
    return t2 >= this._buffer.length ? 0 : this._buffer[t2];
  }
  next() {
    let t2 = 0;
    for (; this._offset < this._buffer.length && t2++ < 100 && (-1 === this._offset ? this._offset = 0 : this._offset += 10 + this.boundsCount * e3, this.id === r2); )
      ;
    return this.id !== r2 && this._offset < this._buffer.length;
  }
  delete(t2) {
    const s3 = this._offset, e4 = this.lookup(t2);
    if (e4)
      for (this.id = 4294967295, ++this._deletedCount; this.next() && this.id === t2; )
        this.id = 4294967295, ++this._deletedCount;
    return this._offset = s3, e4;
  }
  lookup(t2) {
    const e4 = this._offset;
    if (t(this._offsets.instance)) {
      this._offsets.instance = /* @__PURE__ */ new Map();
      const t3 = this.copy();
      t3._offset = -1;
      let s3 = 0;
      for (; t3.next(); )
        t3.id !== s3 && (this._offsets.instance.set(t3.id, t3._offset), s3 = t3.id);
    }
    return !!this._offsets.instance.has(t2) && (this._offset = this._offsets.instance.get(t2), this.id !== r2 || (this._offset = e4, false));
  }
  _computeCount() {
    const t2 = this._offset;
    let s3 = 0;
    for (this._offset = -1; this.next(); )
      s3++;
    return this._offset = t2, s3;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/FeatureDisplayList.js
var n5 = class {
  constructor(t2, e4, i5, n6, a6) {
    this.target = t2, this.geometryType = e4, this.materialKey = i5, this.indexFrom = n6, this.indexCount = a6;
  }
  get indexEnd() {
    return this.indexFrom + this.indexCount;
  }
  extend(t2) {
    this.indexCount += t2;
  }
};
var a3 = class {
  constructor(t2, e4) {
    this.geometryType = 0, this._target = t2, this.geometryType = e4;
  }
  static from(e4, i5, n6, d2) {
    const r4 = new a3(e4, i5);
    if (r(d2))
      for (const t2 of d2)
        n6.seekIndex(t2), r4.addRecord(n6);
    else
      for (; n6.next(); )
        r4.addRecord(n6);
    return r4;
  }
  addRecord(t2) {
    const a6 = this._target, d2 = this.geometryType, r4 = t2.materialKey;
    let s3 = t2.indexFrom, o5 = t2.indexCount;
    const h2 = t2.vertexFrom, x = t2.vertexCount;
    if (o5 || (s3 = h2, o5 = x), t(this._head)) {
      const t3 = new n5(a6, d2, r4, s3, o5);
      return void (this._head = new a2(t3));
    }
    let m2 = null, c3 = this._head;
    for (; c3; ) {
      if (s3 < c3.data.indexFrom)
        return this._insert(r4, s3, o5, m2, c3);
      m2 = c3, c3 = c3.next;
    }
    this._insert(r4, s3, o5, m2, null);
  }
  forEach(e4) {
    r(this._head) && this._head.forEach(e4);
  }
  *infos() {
    if (r(this._head))
      for (const t2 of this._head.values())
        yield t2;
  }
  _insert(a6, d2, r4, s3, o5) {
    if (t(s3) && t(o5)) {
      const t2 = new n5(this._target, this.geometryType, a6, d2, r4);
      this._head = new a2(t2);
    }
    return t(s3) && r(o5) ? this._insertAtHead(a6, d2, r4, o5) : r(s3) && t(o5) ? this._insertAtEnd(a6, d2, r4, s3) : r(s3) && r(o5) ? this._insertAtMiddle(a6, d2, r4, s3, o5) : void 0;
  }
  _insertAtHead(t2, e4, a6, d2) {
    const r4 = e4 + a6;
    if (t2 === d2.data.materialKey && r4 === d2.data.indexFrom)
      d2.data.indexFrom = e4, d2.data.indexCount += a6;
    else {
      const r5 = new n5(this._target, this.geometryType, t2, e4, a6);
      this._head = new a2(r5), this._head.next = d2;
    }
  }
  _insertAtEnd(t2, e4, a6, d2) {
    if (d2.data.materialKey === t2 && d2.data.indexEnd === e4)
      d2.data.indexCount += a6;
    else {
      const r4 = new n5(this._target, this.geometryType, t2, e4, a6), s3 = new a2(r4);
      d2.next = s3;
    }
  }
  _insertAtMiddle(t2, e4, a6, d2, r4) {
    const s3 = e4 + a6;
    if (d2.data.materialKey === t2 && d2.data.indexEnd === e4)
      d2.data.indexCount += a6, d2.data.materialKey === r4.data.materialKey && d2.data.indexEnd === r4.data.indexFrom && (d2.data.indexCount += r4.data.indexCount, d2.next = r4.next);
    else if (t2 === r4.data.materialKey && s3 === r4.data.indexFrom)
      r4.data.indexFrom = e4, r4.data.indexCount += a6;
    else {
      const s4 = new n5(this._target, this.geometryType, t2, e4, a6), o5 = new a2(s4);
      d2.next = o5, o5.next = r4;
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/Buffer.js
var a4 = 1.25;
var u2 = 32767;
var d = u2 << 16 | u2;
var f3 = class {
  constructor(t2, i5, e4, s3) {
    const h2 = i2.create(i5 * e4 * Uint32Array.BYTES_PER_ELEMENT, s3);
    this.size = i5, this.strideInt = e4, this.bufferType = t2, this.dirty = { start: 1 / 0, end: 0 }, this._gpu = null, this._cpu = h2, this.clear();
  }
  get elementSize() {
    return this._cpu.length / this.strideInt;
  }
  get invalidated() {
    return this.bufferSize && !this._gpu;
  }
  get invalidatedComputeBuffer() {
    return this.bufferSize && !this._gpuComputeTriangles;
  }
  invalidate() {
    this._invalidateTriangleBuffer(), o(this._gpu, (t2) => t2.dispose()), this._gpu = null;
  }
  _invalidateTriangleBuffer() {
    o(this._gpuComputeTriangles, (t2) => t2.dispose()), this._gpuComputeTriangles = null;
  }
  destroy() {
    o(this._gpu, (t2) => t2.dispose()), o(this._gpuComputeTriangles, (t2) => t2.dispose()), o(this._cpu, (t2) => t2.destroy()), o(this._cpu2, (t2) => t2.destroy());
  }
  clear() {
    this.dirty.start = 1 / 0, this.dirty.end = 0, this.freeList = new e2({ start: 0, end: this._cpu.length / this.strideInt }), this.fillPointer = 0;
  }
  ensure(t2) {
    if (this.maxAvailableSpace() >= t2)
      return;
    if (t2 * this.strideInt > this._cpu.length - this.fillPointer) {
      this.invalidate();
      const i5 = this._cpu.length / this.strideInt, e4 = Math.round((i5 + t2) * a4), r4 = e4 * this.strideInt;
      this._cpu.expand(r4 * Uint32Array.BYTES_PER_ELEMENT), this.freeList.free(i5, e4 - i5);
    }
  }
  set(t2, i5) {
    this._cpu.array[t2] !== i5 && (this._cpu.array[t2] = i5, this.dirty.start = Math.min(t2, this.dirty.start), this.dirty.end = Math.max(t2, this.dirty.end));
  }
  getGPUBuffer(t2, e4 = false) {
    if (!this.bufferSize)
      return null;
    if (e4) {
      if ("index" !== this.bufferType)
        throw new Error("Tired to get triangle buffer, but target is not an index buffer");
      return t(this._gpuComputeTriangles) && (this._gpuComputeTriangles = this._createComputeBuffer(t2)), this._gpuComputeTriangles;
    }
    return t(this._gpu) && (this._gpu = this._createBuffer(t2)), this._gpu;
  }
  getCPUBuffer() {
    if (!this._cpu2) {
      const t2 = this._cpu.slice();
      this._cpu2 = t2;
    }
    return this._cpu2.length !== this._cpu.length && this._cpu2.expand(this._cpu.length * this._cpu.array.BYTES_PER_ELEMENT), this._cpu2.set(this._cpu), this._cpu2;
  }
  get bufferSize() {
    return this._cpu.length / this.strideInt;
  }
  maxAvailableSpace() {
    return this.freeList.maxAvailableSpace();
  }
  insert(t2, i5, r4, s3) {
    const h2 = r4 * this.strideInt;
    if (!h2)
      return 0;
    const n6 = i5 * this.strideInt * Uint32Array.BYTES_PER_ELEMENT, a6 = new Uint32Array(t2, n6, h2), u6 = f(this.freeList.firstFit(r4), "First fit region must be defined") * this.strideInt, d2 = h2, f4 = u6 / this.strideInt - i5;
    if (0 !== s3)
      for (let e4 = 0; e4 < a6.length; e4++)
        a6[e4] += s3;
    return this._cpu.array.set(a6, u6), this.dirty.start = Math.min(this.dirty.start, u6), this.dirty.end = Math.max(this.dirty.end, u6 + d2), this.fillPointer = Math.max(this.fillPointer, u6 + d2), f4;
  }
  free(t2, i5, e4) {
    const r4 = t2 * this.strideInt, s3 = (t2 + i5) * this.strideInt;
    if (true === e4)
      for (let h2 = t2; h2 !== t2 + i5; h2++)
        this._cpu.array[h2 * this.strideInt] = d;
    this.dirty.start = Math.min(this.dirty.start, r4), this.dirty.end = Math.max(this.dirty.end, s3), this.freeList.free(t2, i5);
  }
  upload() {
    if (this.dirty.end) {
      if (this._invalidateTriangleBuffer(), t(this._gpu))
        return this.dirty.start = 1 / 0, void (this.dirty.end = 0);
      this._gpu.setSubData(this._cpu.array, this.dirty.start, this.dirty.start, this.dirty.end), this.dirty.start = 1 / 0, this.dirty.end = 0;
    }
  }
  _createBuffer(t2) {
    const i5 = F.DYNAMIC_DRAW;
    return "index" === this.bufferType ? E.createIndex(t2, i5, this._cpu.array) : E.createVertex(t2, i5, this._cpu.array);
  }
  _createComputeBuffer(t2) {
    const i5 = F.DYNAMIC_DRAW, e4 = new Uint32Array(this.fillPointer / 3);
    for (let r4 = 0; r4 < this.fillPointer; r4 += 3)
      e4[r4 / 3] = this._cpu.array[r4];
    return E.createIndex(t2, i5, e4);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/Geometry.js
var h = 0;
var u3 = 1;
var c = class {
  constructor(e4, t2) {
    this._vaos = /* @__PURE__ */ new Map(), this._indicesInvalid = false, this.geometryType = e4, this._stage = t2;
  }
  destroy() {
    for (const [t2, r4] of this._vaos)
      r(r4) && r4.dispose(false);
    this._indexBuffer = s(this._indexBuffer), this._vertexBuffer = s(this._vertexBuffer);
  }
  insert(e4, t2, i5) {
    if (!e4.records.byteLength)
      return;
    const s3 = e4.stride;
    if (this._vertexBuffer && this._indexBuffer) {
      const i6 = e4.indices.byteLength / 4, f4 = e4.vertices.byteLength / s3;
      this._indexBuffer.ensure(i6), this._vertexBuffer.ensure(f4);
      const { vertices: n6, indices: d2 } = e4, h2 = i3.from(e4.records), u6 = this._vertexBuffer.insert(n6, 0, n6.byteLength / s3, 0), c3 = this._indexBuffer.insert(d2, 0, d2.byteLength / 4, u6);
      if (h2.forEach((e5) => {
        e5.indexFrom += c3, e5.vertexFrom += u6;
      }), f(this._records, "Expected records to be defined").link(h2), t2)
        this._indicesInvalid = true;
      else if (this._displayList) {
        const e5 = h2.getCursor();
        for (; e5.next(); )
          this._displayList.addRecord(e5);
      }
    } else {
      const r4 = e4.indices.byteLength / 4, i6 = e4.vertices.byteLength / s3, f4 = s3 / Uint32Array.BYTES_PER_ELEMENT, d2 = this._stage.bufferPool;
      this._records = i3.from(e4.records), this._indexBuffer = new f3("index", r4, 1, d2), this._vertexBuffer = new f3("vertex", i6, f4, d2), this._indexBuffer.insert(e4.indices, 0, e4.indices.byteLength / 4, 0), this._vertexBuffer.insert(e4.vertices, 0, e4.vertices.byteLength / s3, 0), t2 && (this._indicesInvalid = true);
    }
  }
  remove(e4) {
    if (!t(this._records))
      for (const t2 of e4) {
        const e5 = this._records.getCursor();
        if (!e5.lookup(t2))
          continue;
        const r4 = e5.indexFrom, i5 = e5.vertexFrom;
        let s3 = e5.indexCount, f4 = e5.vertexCount;
        for (; e5.next() && e5.id === t2; )
          s3 += e5.indexCount, f4 += e5.vertexCount;
        this._indexBuffer.free(r4, s3), this._vertexBuffer.free(i5, f4, true), this._records.delete(t2);
      }
  }
  getVAO(e4, t2, r4, f4) {
    if (!this._vertexBuffer || !this._indexBuffer || t(this._records) || !this._vertexBuffer.bufferSize)
      return null;
    const n6 = f4 ? u3 : h;
    let o5 = this._vaos.get(n6);
    (this._vertexBuffer.invalidated || this._indexBuffer.invalidated || f4 && this._indexBuffer.invalidatedComputeBuffer) && (o(o5, (e5) => e5.dispose(false)), o5 = null), this._vertexBuffer.upload(), this._indexBuffer.upload();
    const c3 = this._indexBuffer.getGPUBuffer(e4, 1 === n6), _2 = this._vertexBuffer.getGPUBuffer(e4);
    return o5 || (o5 = new a(e4, r4, t2, { geometry: _2 }, c3), this._vaos.set(n6, o5)), o5;
  }
  forEachCommand(e4) {
    if (!t(this._records)) {
      if (this._sortIndices(this._records), !this._displayList) {
        const e5 = this._cursorIndexOrder;
        this._displayList = a3.from(this, this.geometryType, this._records.getCursor(), e5);
      }
      this._displayList.forEach(e4);
    }
  }
  _sortIndices(e4) {
    const t2 = !!this._indexBuffer.bufferSize;
    if (!this._indicesInvalid)
      return;
    this._indicesInvalid = false;
    let r4 = 0;
    const i5 = e4.getCursor(), s3 = [], f4 = [], n6 = [];
    for (; i5.next(); )
      f4.push(i5.index), n6.push(i5.sortKey), s3.push(i5.id);
    f4.sort((e5, t3) => {
      const r5 = n6[t3], i6 = n6[e5];
      return i6 === r5 ? s3[t3] - s3[e5] : r5 - i6;
    });
    const o5 = e4.getCursor(), d2 = t2 ? this._indexBuffer.getCPUBuffer() : this._vertexBuffer.getCPUBuffer();
    for (const h2 of f4) {
      if (!o5.seekIndex(h2))
        throw new Error("Expected to find index");
      if (t2) {
        const { indexFrom: e5, indexCount: t3 } = o5;
        o5.indexFrom = r4;
        for (let i6 = 0; i6 < t3; i6++)
          this._indexBuffer.set(r4++, d2.array[e5 + i6]);
      } else {
        const { vertexFrom: e5, vertexCount: t3 } = o5, i6 = this._vertexBuffer.strideInt, s4 = e5 * i6, f5 = s4 + t3 * i6;
        o5.vertexFrom = r4 / i6;
        for (let n7 = s4; n7 < f5; n7++)
          this._vertexBuffer.set(r4++, d2.array[n7]);
      }
    }
    this._cursorIndexOrder = f4, this._displayList = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/FeatureTile.js
var c2 = 50;
var u4 = 4;
var _ = 100;
var p = 0;
var l = class extends m {
  constructor(t2, r4, s3, a6, n6, h2) {
    super(t2, r4, s3, a6), this.instanceId = p++, this.patchCount = 0, this._renderState = { current: { geometry: /* @__PURE__ */ new Map(), metrics: null }, next: null, swap: false, swapFrames: 0, locked: false }, this._patches = new s2(_), this._bufferPatches = new s2(_), this._lastCommitTime = 0, this.transforms.labelMat2d = n2(), this._store = n6, this._requestLabelUpdate = h2;
  }
  destroy() {
    super.destroy(), this._renderState.current.geometry.forEach((e4) => e4.destroy()), r(this._renderState.next) && this._renderState.next.geometry.forEach((e4) => e4.destroy()), this._renderState.current = null, this._renderState.next = null;
  }
  get labelMetrics() {
    return this._renderState.current.metrics;
  }
  get hasData() {
    return !!this._renderState.current.geometry.size;
  }
  getGeometry(e4) {
    return this._renderState.current.geometry.get(e4);
  }
  patch(e4, t2) {
    this.patchCount++, e4.clear && this._patches.size >= c2 && this._dropPatches();
    const r4 = e4, s3 = r4.addOrUpdate && this.key.id !== r4.addOrUpdate.tileKeyOrigin;
    t2 && s3 ? this._bufferPatches.enqueue(r4) : (r4.sort = r4.sort && !t2, this._patches.enqueue(r4)), this.requestRender();
  }
  commit(e4) {
    if (this._lastCommitTime !== e4.time) {
      this._lastCommitTime = e4.time;
      for (let e5 = 0; e5 < u4; e5++)
        this._updateMesh(), this.isReady && this._updateBufferMesh();
      this._renderState.swap && (this._swapRenderStates(), this.requestRender());
    }
  }
  lock() {
    this._renderState.locked = true;
  }
  unlock() {
    this._renderState.locked = false, this._flushUpdates(), this._swap();
  }
  _swapRenderStates() {
    if (this._renderState.next) {
      if (this._renderState.locked)
        return this._renderState.swap = true, void this.requestRender();
      this._renderState.swap = true, this._swap();
    }
  }
  _swap() {
    this._renderState.swap && (this._renderState.swap = false, r(this._renderState.next) && (this._renderState.current.geometry.forEach((e4) => e4.destroy()), this._renderState.current = this._renderState.next, this._renderState.next = null, this._requestLabelUpdate()));
  }
  _flushUpdates() {
    let e4 = this._patches.maxSize;
    for (; this._patches.size && e4--; )
      this._updateMesh(), this._swap();
  }
  _updateBufferMesh() {
    const e4 = this._bufferPatches.peek();
    if (!r(e4) || !e4.clear || null === this._renderState.next)
      for (; this._bufferPatches.size; ) {
        const e5 = this._bufferPatches.dequeue();
        r(e5) && this._patchBuffer(e5);
      }
  }
  _updateMesh() {
    var _a, _b, _c, _d;
    const e4 = this._patches.dequeue();
    if (r(e4)) {
      if (has("esri-2d-update-debug")) {
        const t2 = e4, r4 = (_a = t2.addOrUpdate) == null ? void 0 : _a.tileKeyOrigin, s3 = this.key.id === r4 ? "SELF" : r4;
        let i5 = "";
        for (let e5 = 0; e5 < 5; e5++)
          i5 += ((_d = (_c = (_b = t2.addOrUpdate) == null ? void 0 : _b.data[e5]) == null ? void 0 : _c.records) == null ? void 0 : _d.byteLength) ? 1 : 0;
        console.debug(this.key.id, "FeatureTile:patch", `[clear: ${t2.clear} origin: ${s3}, end:${t2.end} data:${i5}]`);
      }
      true === e4.clear && (r(this._renderState.next) && (this._renderState.next.geometry.forEach((e5) => e5.destroy()), this._renderState.next = null), this._renderState.next = { geometry: /* @__PURE__ */ new Map(), metrics: null }, has("esri-2d-update-debug") && console.debug(this.key.id, "FeatureTile:_updateMesh - Creating new renderState")), this.requestRender(), this._patch(e4), e4.end && (has("esri-2d-update-debug") && console.debug(this.key.id, "FeatureTile:_updateMesh - Encountered end message"), this.ready(), this._swapRenderStates());
    }
  }
  _patch(e4) {
    he((t2) => {
      this._remove(t2, e4.remove), this._insert(t2, e4, false);
    });
  }
  _patchBuffer(e4) {
    he((t2) => {
      this._insert(t2, e4, true);
    });
  }
  _insert(e4, t2, i5) {
    var _a;
    try {
      const n6 = i(this._renderState.next, this._renderState.current), h2 = (_a = t2.addOrUpdate) == null ? void 0 : _a.data[e4], d2 = n6.geometry;
      if (t(h2))
        return;
      d2.has(e4) || (has("esri-2d-update-debug") && console.debug(this.key.id, `FeatureTile:_insert - Creating geometry buffer ${e4}`), d2.set(e4, new c(e4, this.stage))), has("esri-2d-update-debug") && console.debug(this.key.id, `FeatureTile:_insert - Inserting into ${e4}, version=${t2.addOrUpdate.version} stride=${h2.stride}`), d2.get(e4).insert(h2, t2.sort, i5), e4 === E2.LABEL && this._insertLabelMetrics(t2.type, h2.metrics, t2.clear);
    } catch (n6) {
    }
  }
  _insertLabelMetrics(e4, t2, i5) {
    const a6 = i(this._renderState.next, this._renderState.current);
    if (t(t2))
      return;
    const n6 = o4.from(t2);
    if (t(a6.metrics))
      a6.metrics = n6;
    else {
      if ("update" === e4) {
        const e5 = n6.getCursor();
        for (; e5.next(); )
          a6.metrics.delete(e5.id);
      }
      a6.metrics.link(n6);
    }
  }
  _remove(e4, t2) {
    const s3 = i(this._renderState.next, this._renderState.current).geometry.get(e4);
    t2 && t2.length && s3 && (s3.remove(t2), this._removeLabelMetrics(t2));
  }
  _removeLabelMetrics(e4) {
    const { metrics: t2 } = i(this._renderState.next, this._renderState.current);
    if (!t(t2) && e4.length)
      for (const r4 of e4)
        for (; t2.delete(r4); )
          ;
  }
  _dropPatches() {
    const e4 = new Array();
    let t2 = false;
    for (; this._patches.size; ) {
      const r4 = this._patches.dequeue();
      if (t(r4))
        break;
      if (r4.clear) {
        if (t2)
          break;
        t2 = true;
      }
      e4.push(r4);
    }
    this._patches.clear(), e4.forEach((e5) => this._patches.enqueue(e5));
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/tileRenderers/support/WGLFeatureView.js
var r3 = has("featurelayer-order-by-server-enabled");
var a5 = class extends o2 {
  constructor(e4, t2, s3, i5) {
    super(e4), this._hitTestsRequests = [], this._layer = s3, this._layerView = t2, this._onUpdate = i5;
  }
  renderChildren(e4) {
    if (this.attributeView.update(), this.hasAnimation) {
      e4.painter.effects.integrate.draw(e4, e4.attributeView);
    }
    super.renderChildren(e4);
  }
  hasEmptyAttributeView() {
    return this.attributeView.isEmpty();
  }
  isUpdating() {
    return this.attributeView.isUpdating();
  }
  hitTest(t2) {
    let s3 = this._hitTestsRequests.find(({ x: e4, y: s4 }) => e4 === t2.x && s4 === t2.y);
    const i5 = D();
    return s3 ? s3.resolvers.push(i5) : (s3 = { x: t2.x, y: t2.y, resolvers: [i5] }, this._hitTestsRequests.push(s3)), this.requestRender(), i5.promise;
  }
  onTileData(e4, t2) {
    const s3 = r3 && "orderBy" in this._layer && this._layer.orderBy, i5 = (s3 == null ? void 0 : s3.length) && !s3[0].valueExpression && s3[0].field, a6 = s3 && this._layerView.orderByFields === i5;
    e4.patch(t2, a6), this.contains(e4) || this.addChild(e4), this.requestRender();
  }
  onTileError(e4) {
    this.contains(e4) || this.addChild(e4);
  }
  updateTransitionProperties(e4, t2) {
    super.updateTransitionProperties(e4, t2), this._layerView.featureEffectView.transitionStep(e4, t2), this._layerView.featureEffectView.transitioning && this.requestRender();
  }
  doRender(e4) {
    const { minScale: t2, maxScale: s3 } = this._layer, i5 = e4.state.scale;
    i5 <= (t2 || 1 / 0) && i5 >= s3 && super.doRender(e4);
  }
  afterRender(e4) {
    super.afterRender(e4), this._hitTestsRequests.length && this.requestRender();
  }
  onAttributeStoreUpdate() {
    this.hasLabels && this._layerView.view.labelManager.requestUpdate(), this._onUpdate();
  }
  get hasAnimation() {
    return this.hasLabels;
  }
  setStencilReference(e4) {
    const { rendererSchema: t2 } = e4.rendererInfo;
    if ("dot-density" === (t2 == null ? void 0 : t2.type) && (t2 == null ? void 0 : t2.dotSize) > 1 || "heatmap" === (t2 == null ? void 0 : t2.type)) {
      const e5 = 1;
      for (const t3 of this.children)
        t3.stencilRef = t3.key.level + e5;
    } else
      super.setStencilReference(e4);
  }
  get hasLabels() {
    if ("sublayers" in this._layer)
      return this._layer.sublayers.some((e5) => e5.labelingInfo && e5.labelingInfo.length && e5.labelsVisible);
    const e4 = this._layer.featureReduction, t2 = e4 && "labelingInfo" in e4 && e4.labelsVisible && e4.labelingInfo && e4.labelingInfo.length;
    return this._layer.labelingInfo && this._layer.labelingInfo.length && this._layer.labelsVisible || !!t2;
  }
  prepareRenderPasses(e4) {
    const s3 = e4.registerRenderPass({ name: "label", brushes: [n3.label], target: () => this.hasLabels ? this.children : null, drawPhase: I.LABEL | I.LABEL_ALPHA }), r4 = e4.registerRenderPass({ name: "geometry", brushes: [n3.fill, n3.dotDensity, n3.line, n3.marker, n3.heatmap, n3.pieChart, n3.text], target: () => this.children, enableDefaultDraw: () => !this._layerView.featureEffectView.hasEffects, effects: [{ apply: e4.effects.outsideEffect, enable: () => this._layerView.featureEffectView.hasEffects, args: () => this._layerView.featureEffectView.excludedEffects }, { apply: e4.effects.insideEffect, enable: () => this._layerView.featureEffectView.hasEffects, args: () => this._layerView.featureEffectView.includedEffects }, { apply: e4.effects.hittest, enable: () => !!this._hitTestsRequests.length, args: () => this._hitTestsRequests }] }), a6 = e4.registerRenderPass({ name: "highlight", brushes: [n3.fill, n3.dotDensity, n3.line, n3.marker, n3.pieChart, n3.text], target: () => this.children, drawPhase: I.HIGHLIGHT, enableDefaultDraw: () => false, effects: [{ apply: e4.effects.highlight, enable: () => !!this._layerView.hasHighlight() }] });
    return [...super.prepareRenderPasses(e4), r4, a6, s3];
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/tileRenderers/SymbolTileRenderer.js
var u5 = class extends o3 {
  constructor() {
    super(...arguments), this.type = "symbol";
  }
  install(e4) {
    const t2 = () => this.notifyChange("updating"), i5 = new a5(this.tileInfoView, this.layerView, this.layer, t2);
    this.featuresView = i5, e4.addChild(i5);
  }
  uninstall(e4) {
    e4.removeChild(this.featuresView), this.featuresView.destroy(), this.featuresView = null;
  }
  fetchResource(e4, i5) {
    const { url: s3 } = e4, r4 = this.featuresView.stage;
    try {
      return r4.resourceManager.fetchResource(s3, { signal: i5.signal });
    } catch (a6) {
      return j(a6) ? Promise.resolve({ width: 0, height: 0 }) : Promise.reject(a6);
    }
  }
  isUpdating() {
    var _a;
    const e4 = super.isUpdating(), t2 = !this.featuresView || this.featuresView.isUpdating(), i5 = (_a = this.featuresView) == null ? void 0 : _a.hasEmptyAttributeView(), s3 = e4 || t2 || e4 && i5;
    return has("esri-2d-log-updating") && console.log(`Updating SymbolTileRenderer ${s3}
  -> updatingTiles ${e4}
  -> hasFeaturesView ${!!this.featuresView}
  -> updatingFeaturesView ${t2}`), s3;
  }
  hitTest(e4) {
    return this.featuresView.hitTest(e4);
  }
  supportsRenderer(e4) {
    return null != e4 && ["simple", "class-breaks", "unique-value", "dot-density", "dictionary", "heatmap", "pie-chart"].includes(e4.type);
  }
  onConfigUpdate(e4) {
    let t2 = null;
    if (e4 && "visualVariables" in e4) {
      const i5 = (n4(e4).visualVariables || []).map((e5) => {
        const t3 = e5.clone();
        return "normalizationField" in e5 && (t3.normalizationField = null), e5.valueExpression && "$view.scale" !== e5.valueExpression && (t3.valueExpression = null, t3.field = "nop"), t3;
      });
      t2 = f2(i5);
    }
    this.featuresView.setRendererInfo(e4, t2, this.layerView.featureEffect);
  }
  onTileData(e4) {
    const t2 = this.tiles.get(e4.tileKey);
    t2 && e4.data && this.featuresView.onTileData(t2, e4.data), this.layerView.view.labelManager.requestUpdate();
  }
  onTileError(e4) {
    const t2 = this.tiles.get(e4.tileKey);
    t2 && this.featuresView.onTileError(t2);
  }
  forceAttributeTextureUpload() {
    this.featuresView.attributeView.forceTextureUpload();
  }
  lockGPUUploads() {
    this.featuresView.attributeView.lockTextureUpload(), this.tiles.forEach((e4) => e4.lock());
  }
  unlockGPUUploads() {
    this.featuresView.attributeView.unlockTextureUpload(), this.tiles.forEach((e4) => e4.unlock());
  }
  async getMaterialItems(e4) {
    return this.featuresView.getMaterialItems(e4);
  }
  invalidateLabels() {
    this.featuresView.hasLabels && this.layerView.view.labelManager.requestUpdate();
  }
  createTile(e4) {
    const t2 = this.tileInfoView.getTileBounds(u(), e4), i5 = () => this.layerView.view.labelManager.requestUpdate(), a6 = this.tileInfoView.getTileResolution(e4.level), o5 = this.featuresView.attributeView;
    return new l(e4, a6, t2[0], t2[3], o5, i5);
  }
  disposeTile(e4) {
    this.featuresView.removeChild(e4), e4.destroy(), this.layerView.view.labelManager.requestUpdate();
  }
};
u5 = e([n("esri.views.2d.layers.features.tileRenderers.SymbolTileRenderer")], u5);
var p2 = u5;
export {
  p2 as default
};
//# sourceMappingURL=SymbolTileRenderer-A2WGFREO.js.map
