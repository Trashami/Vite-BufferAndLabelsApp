import {
  v
} from "./chunk-NCXAKZRR.js";
import "./chunk-DUCSW4OU.js";
import "./chunk-WVDA5Z37.js";
import {
  n
} from "./chunk-I4RYNNL6.js";
import {
  d,
  o
} from "./chunk-4HXPP4EA.js";
import {
  g
} from "./chunk-J6LQZWZI.js";
import "./chunk-OD3FDQCI.js";
import "./chunk-J2PJNRU7.js";
import "./chunk-56SPM3WK.js";
import "./chunk-XMZAPOBR.js";
import "./chunk-BLJKKR5D.js";
import "./chunk-ZGNCYHMZ.js";
import "./chunk-X2S4RQJ4.js";
import "./chunk-FUPLN7UM.js";
import "./chunk-376OPXM4.js";
import "./chunk-DER356EU.js";
import "./chunk-MZIWIEIR.js";
import "./chunk-TQEOEDAZ.js";
import "./chunk-SHFHZMHO.js";
import "./chunk-NRP45AHD.js";
import "./chunk-IWQ7452U.js";
import "./chunk-NAN5J6QS.js";
import "./chunk-B4DKBAM3.js";
import "./chunk-6M2AHKYV.js";
import "./chunk-SZIJNKCV.js";
import "./chunk-6O43OEU5.js";
import "./chunk-J2K7ZDSV.js";
import "./chunk-2UML3WQZ.js";
import "./chunk-KXVMEIWT.js";
import {
  j
} from "./chunk-UDND2Z3V.js";
import "./chunk-23Y3DIC6.js";
import "./chunk-JUVQV3R3.js";
import "./chunk-RAX2HD42.js";
import "./chunk-ZYRIJWLX.js";
import "./chunk-C5H57NTD.js";
import "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import "./chunk-YWAQYJRC.js";
import "./chunk-B356PXLT.js";
import "./chunk-EHPBHJYZ.js";
import "./chunk-3MNMDUQZ.js";
import "./chunk-UWG37XSU.js";
import "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import "./chunk-HLM6QCL2.js";
import "./chunk-RXYULINL.js";
import "./chunk-THVR7IAM.js";
import "./chunk-ZWJJTUFL.js";
import "./chunk-XQN7F674.js";
import "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import {
  nt
} from "./chunk-KAN4HXCG.js";
import "./chunk-4FEGON7M.js";
import "./chunk-VWYWOOPX.js";
import "./chunk-M5VHU5LK.js";
import "./chunk-CXFRNDG4.js";
import "./chunk-7QMMKGW4.js";
import "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import "./chunk-MJXQTGI2.js";
import {
  s
} from "./chunk-LIZHLHNA.js";
import "./chunk-BTUHYGXO.js";
import "./chunk-UA3YPL2R.js";
import {
  y
} from "./chunk-HVKDYDPP.js";
import "./chunk-6QC7MLLS.js";
import {
  r,
  t
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/layers/support/infoFor3D.js
var _;
!function(_2) {
  _2.GLTF_BINARY = "3D_glb", _2.GLTF_JSON = "3D_gltf";
}(_ || (_ = {}));

// node_modules/@arcgis/core/layers/graphics/editingSupport.js
function c(e) {
  return e && null != e.applyEdits;
}
async function h(e, t2, a, s2 = {}) {
  var _a;
  let i, o2;
  const d2 = { edits: a, result: new Promise((e2, t3) => {
    i = e2, o2 = t3;
  }) };
  e.emit("apply-edits", d2);
  try {
    const { results: o3, edits: d3 } = await m(e, t2, a, s2), n2 = (e2) => e2.filter((e3) => !e3.error).map(y), p = { edits: d3, addedFeatures: n2(o3.addFeatureResults), updatedFeatures: n2(o3.updateFeatureResults), deletedFeatures: n2(o3.deleteFeatureResults), addedAttachments: n2(o3.addAttachmentResults), updatedAttachments: n2(o3.updateAttachmentResults), deletedAttachments: n2(o3.deleteAttachmentResults) };
    return ((_a = o3.editedFeatureResults) == null ? void 0 : _a.length) && (p.editedFeatures = o3.editedFeatureResults), (p.addedFeatures.length || p.updatedFeatures.length || p.deletedFeatures.length || p.addedAttachments.length || p.updatedAttachments.length || p.deletedAttachments.length) && (e.emit("edits", p), o(e) && d.emit("edits", { layer: e, event: p })), i(p), o3;
  } catch (n2) {
    throw o2(n2), n2;
  }
}
async function m(e, t2, r2, s2) {
  if (await e.load(), !c(t2))
    throw new s(`${e.type}-layer:no-editing-support`, "Layer source does not support applyEdits capability", { layer: e });
  if (!e.editingEnabled)
    throw new s(`${e.type}-layer:editing-disabled`, "Editing is disabled for layer", { layer: e });
  const { edits: i, options: o2 } = await y2(e, r2, s2);
  return i.addFeatures.length || i.updateFeatures.length || i.deleteFeatures.length || i.addAttachments.length || i.updateAttachments.length || i.deleteAttachments.length ? { edits: i, results: await t2.applyEdits(i, o2) } : { edits: i, results: { addFeatureResults: [], updateFeatureResults: [], deleteFeatureResults: [], addAttachmentResults: [], updateAttachmentResults: [], deleteAttachmentResults: [] } };
}
async function y2(e, r2, i) {
  const o2 = r2 && (r2.addFeatures || r2.updateFeatures || r2.deleteFeatures), d2 = r2 && (r2.addAttachments || r2.updateAttachments || r2.deleteAttachments), n2 = r(e.infoFor3D);
  if (!r2 || !o2 && !d2)
    throw new s(`${e.type}-layer:missing-parameters`, "'addFeatures', 'updateFeatures', 'deleteFeatures', 'addAttachments', 'updateAttachments' or 'deleteAttachments' parameter is required");
  if (!e.capabilities.data.isVersioned && i && i.gdbVersion)
    throw new s(`${e.type}-layer:invalid-parameter`, "'gdbVersion' is applicable only if the layer supports versioned data. See: 'capabilities.data.isVersioned'");
  if (!e.capabilities.editing.supportsRollbackOnFailure && i && i.rollbackOnFailureEnabled)
    throw new s(`${e.type}-layer:invalid-parameter`, "This layer does not support 'rollbackOnFailureEnabled' parameter. See: 'capabilities.editing.supportsRollbackOnFailure'");
  if (!e.capabilities.editing.supportsGlobalId && i && i.globalIdUsed)
    throw new s(`${e.type}-layer:invalid-parameter`, "This layer does not support 'globalIdUsed' parameter. See: 'capabilities.editing.supportsGlobalId'");
  if (!e.capabilities.editing.supportsGlobalId && d2)
    throw new s(`${e.type}-layer:invalid-parameter`, "'addAttachments', 'updateAttachments' and 'deleteAttachments' are applicable only if the layer supports global ids. See: 'capabilities.editing.supportsGlobalId'");
  if ((!i || !i.globalIdUsed) && d2)
    throw new s(`${e.type}-layer:invalid-parameter`, "When 'addAttachments', 'updateAttachments' or 'deleteAttachments' is specified, globalIdUsed should be set to true");
  const l = { ...i };
  if (null != l.rollbackOnFailureEnabled || e.capabilities.editing.supportsRollbackOnFailure || (l.rollbackOnFailureEnabled = true), false === l.rollbackOnFailureEnabled && "original-and-current-features" === l.returnServiceEditsOption)
    throw new s(`${e.type}-layer:invalid-parameter`, "'original-and-current-features' is valid for 'returnServiceEditsOption' only when 'rollBackOnFailure' is true.");
  if (!e.capabilities.editing.supportsReturnServiceEditsInSourceSpatialReference && l.returnServiceEditsInSourceSR)
    throw new s(`${e.type}-layer:invalid-parameter`, "This layer does not support 'returnServiceEditsInSourceSR' parameter. See: 'capabilities.editing.supportsReturnServiceEditsInSourceSpatialReference'");
  if (l.returnServiceEditsInSourceSR && "original-and-current-features" !== l.returnServiceEditsOption)
    throw new s(`${e.type}-layer:invalid-parameter`, "'returnServiceEditsOption' is valid only when 'returnServiceEditsOption' is set to 'original-and-current-features'");
  const u = { ...r2 };
  if (u.addFeatures = r2 && j.isCollection(r2.addFeatures) ? r2.addFeatures.toArray() : u.addFeatures || [], u.updateFeatures = r2 && j.isCollection(r2.updateFeatures) ? r2.updateFeatures.toArray() : u.updateFeatures || [], u.deleteFeatures = r2 && j.isCollection(r2.deleteFeatures) ? r2.deleteFeatures.toArray() : u.deleteFeatures || [], u.addFeatures.length && !e.capabilities.operations.supportsAdd)
    throw new s(`${e.type}-layer:unsupported-operation`, "Layer does not support adding features.");
  if (u.updateFeatures.length && !e.capabilities.operations.supportsUpdate)
    throw new s(`${e.type}-layer:unsupported-operation`, "Layer does not support updating features.");
  if (u.deleteFeatures.length && !e.capabilities.operations.supportsDelete)
    throw new s(`${e.type}-layer:unsupported-operation`, "Layer does not support deleting features.");
  u.addAttachments = u.addAttachments || [], u.updateAttachments = u.updateAttachments || [], u.deleteAttachments = u.deleteAttachments || [], u.addFeatures = u.addFeatures.map(v2), u.updateFeatures = u.updateFeatures.map(v2), u.addAssets = [];
  const p = i && i.globalIdUsed || n2;
  u.addFeatures.forEach((t2) => g2(t2, e, p)), u.updateFeatures.forEach((t2) => F(t2, e, p)), u.deleteFeatures.forEach((t2) => b(t2, e, p)), u.addAttachments.forEach((t2) => w(t2, e)), u.updateAttachments.forEach((t2) => w(t2, e)), n2 && await I(u, e);
  return { edits: await A(u), options: l };
}
function f(e, t2, r2) {
  if (r2) {
    if ("attributes" in e && !e.attributes[t2.globalIdField])
      throw new s(`${t2.type}-layer:invalid-parameter`, "Feature should have 'globalId' when 'globalIdUsed' is true");
    if (!("attributes" in e) && !e.globalId)
      throw new s(`${t2.type}-layer:invalid-parameter`, "'globalId' of the feature should be passed when 'globalIdUsed' is true");
  }
  if ("geometry" in e && r(e.geometry)) {
    if (e.geometry.hasZ && false === t2.capabilities.data.supportsZ)
      throw new s(`${t2.type}-layer:z-unsupported`, "Layer does not support z values while feature has z values.");
    if (e.geometry.hasM && false === t2.capabilities.data.supportsM)
      throw new s(`${t2.type}-layer:m-unsupported`, "Layer does not support m values while feature has m values.");
  }
}
function g2(e, t2, a) {
  f(e, t2, a);
}
function b(e, t2, a) {
  f(e, t2, a);
}
function F(e, t2, r2) {
  if (f(e, t2, r2), "geometry" in e && r(e.geometry) && !t2.capabilities.editing.supportsGeometryUpdate)
    throw new s(`${t2.type}-layer:unsupported-operation`, "Layer does not support geometry updates.");
}
function w(e, t2) {
  const { feature: r2, attachment: s2 } = e;
  if (!r2 || "attributes" in r2 && !r2.attributes[t2.globalIdField])
    throw new s(`${t2.type}-layer:invalid-parameter`, "Attachment should have reference to a feature with 'globalId'");
  if (!("attributes" in r2) && !r2.globalId)
    throw new s(`${t2.type}-layer:invalid-parameter`, "Attachment should have reference to 'globalId' of the parent feature");
  if (!s2.globalId)
    throw new s(`${t2.type}-layer:invalid-parameter`, "Attachment should have 'globalId'");
  if (!s2.data && !s2.uploadId)
    throw new s(`${t2.type}-layer:invalid-parameter`, "Attachment should have 'data' or 'uploadId'");
  if (!(s2.data instanceof File && !!s2.data.name) && !s2.name)
    throw new s(`${t2.type}-layer:invalid-parameter`, "'name' is required when attachment is specified as Base64 encoded string using 'data'");
  if (!t2.capabilities.editing.supportsUploadWithItemId && s2.uploadId)
    throw new s(`${t2.type}-layer:invalid-parameter`, "This layer does not support 'uploadId' parameter. See: 'capabilities.editing.supportsUploadWithItemId'");
  if ("string" == typeof s2.data) {
    const e2 = nt(s2.data);
    if (e2 && !e2.isBase64)
      throw new s(`${t2.type}-layer:invalid-parameter`, "Attachment 'data' should be a Blob, File or Base64 encoded string");
  }
}
async function A(e) {
  const t2 = e.addFeatures, a = e.updateFeatures, r2 = t2.concat(a).map((e2) => e2.geometry), s2 = await v(r2), i = t2.length, o2 = a.length;
  return s2.slice(0, i).forEach((t3, a2) => e.addFeatures[a2].geometry = t3), s2.slice(i, i + o2).forEach((t3, a2) => e.updateFeatures[a2].geometry = t3), e;
}
function v2(t2) {
  const a = new g();
  return t2.attributes || (t2.attributes = {}), a.geometry = t2.geometry, a.attributes = t2.attributes, a;
}
async function I(e, t2) {
  if (t(t2.infoFor3D))
    return;
  const { infoFor3D: a } = t2;
  let r2 = false;
  for (const i of a.editFormats)
    if (i === _.GLTF_BINARY) {
      r2 = true;
      break;
    }
  const s2 = [];
  for (const i of e.addFeatures)
    s2.push(E(i, e, t2, r2));
  for (const i of e.updateFeatures)
    s2.push(E(i, e, t2, r2));
  const o2 = await Promise.allSettled(s2);
  for (const i of o2)
    if ("rejected" === i.status)
      throw i.reason;
}
async function E(e, t2, r2, o2) {
  if (t(e.geometry) || "mesh" !== e.geometry.type)
    return;
  const n2 = e.geometry, l = r2.globalIdField;
  if (r(r2.parsedUrl) && r(n2.external) && Array.isArray(n2.external.source) && 1 === n2.external.source.length && "source" in n2.external.source[0] && "string" == typeof n2.external.source[0].source && n2.external.source[0].source.startsWith(r2.parsedUrl.path))
    return;
  if (!o2)
    throw new s(`${r2.type}-layer:binary-gltf-asset-not-supported`, "3DObjectFeatureLayer requires binary glTF (.glb) support for updating mesh geometry.");
  const u = await n2.toBinaryGLTF(), c2 = await u.buffer(), h2 = `{${n()}}`, m2 = `${h2}.glb`;
  t2.addAssets.push({ featureGlobalId: e.getAttribute(l), assetMapGlobalId: h2, assetName: m2, flags: 0, data: c2.data, mimeType: c2.type, assetType: _.GLTF_BINARY, feature: e });
}
export {
  h as applyEdits
};
//# sourceMappingURL=editingSupport-6MAA475O.js.map
