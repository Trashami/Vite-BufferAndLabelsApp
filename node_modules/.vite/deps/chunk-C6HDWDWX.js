import {
  s2 as s
} from "./chunk-UA3YPL2R.js";

// node_modules/@arcgis/core/geometry/support/buffer/math/common.js
var e = s.getLogger("esri.views.3d.support.buffer.math");

// node_modules/@arcgis/core/chunks/vec32.js
function t(t3, r2, f3) {
  if (t3.count !== r2.count)
    return void e.error("source and destination buffers need to have the same number of elements");
  const o2 = t3.count, n2 = f3[0], u2 = f3[1], d = f3[2], s2 = f3[4], c = f3[5], i = f3[6], a = f3[8], p = f3[9], y = f3[10], B = f3[12], m = f3[13], l = f3[14], S = t3.typedBuffer, h = t3.typedBufferStride, b = r2.typedBuffer, M = r2.typedBufferStride;
  for (let e3 = 0; e3 < o2; e3++) {
    const t4 = e3 * h, r3 = e3 * M, f4 = b[r3], o3 = b[r3 + 1], v = b[r3 + 2];
    S[t4] = n2 * f4 + s2 * o3 + a * v + B, S[t4 + 1] = u2 * f4 + c * o3 + p * v + m, S[t4 + 2] = d * f4 + i * o3 + y * v + l;
  }
}
function r(t3, r2, f3) {
  if (t3.count !== r2.count)
    return void e.error("source and destination buffers need to have the same number of elements");
  const o2 = t3.count, n2 = f3[0], u2 = f3[1], d = f3[2], s2 = f3[3], c = f3[4], i = f3[5], a = f3[6], p = f3[7], y = f3[8], B = t3.typedBuffer, m = t3.typedBufferStride, l = r2.typedBuffer, S = r2.typedBufferStride;
  for (let e3 = 0; e3 < o2; e3++) {
    const t4 = e3 * m, r3 = e3 * S, f4 = l[r3], o3 = l[r3 + 1], h = l[r3 + 2];
    B[t4] = n2 * f4 + s2 * o3 + a * h, B[t4 + 1] = u2 * f4 + c * o3 + p * h, B[t4 + 2] = d * f4 + i * o3 + y * h;
  }
}
function f(e3, t3, r2) {
  const f3 = Math.min(e3.count, t3.count), o2 = e3.typedBuffer, n2 = e3.typedBufferStride, u2 = t3.typedBuffer, d = t3.typedBufferStride;
  for (let s2 = 0; s2 < f3; s2++) {
    const e4 = s2 * n2, t4 = s2 * d;
    o2[e4] = r2 * u2[t4], o2[e4 + 1] = r2 * u2[t4 + 1], o2[e4 + 2] = r2 * u2[t4 + 2];
  }
}
function o(e3, t3) {
  const r2 = Math.min(e3.count, t3.count), f3 = e3.typedBuffer, o2 = e3.typedBufferStride, n2 = t3.typedBuffer, u2 = t3.typedBufferStride;
  for (let d = 0; d < r2; d++) {
    const e4 = d * o2, t4 = d * u2, r3 = n2[t4], s2 = n2[t4 + 1], c = n2[t4 + 2], i = r3 * r3 + s2 * s2 + c * c;
    if (i > 0) {
      const t5 = 1 / Math.sqrt(i);
      f3[e4] = t5 * r3, f3[e4 + 1] = t5 * s2, f3[e4 + 2] = t5 * c;
    }
  }
}
function n(e3, t3, r2) {
  const f3 = Math.min(e3.count, t3.count), o2 = e3.typedBuffer, n2 = e3.typedBufferStride, u2 = t3.typedBuffer, d = t3.typedBufferStride;
  for (let s2 = 0; s2 < f3; s2++) {
    const e4 = s2 * n2, t4 = s2 * d;
    o2[e4] = u2[t4] >> r2, o2[e4 + 1] = u2[t4 + 1] >> r2, o2[e4 + 2] = u2[t4 + 2] >> r2;
  }
}
var u = Object.freeze(Object.defineProperty({ __proto__: null, transformMat4: t, transformMat3: r, scale: f, normalize: o, shiftRight: n }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/vec33.js
function e2(e3, t3, f3) {
  const d = e3.typedBuffer, n2 = e3.typedBufferStride, o2 = t3.typedBuffer, r2 = t3.typedBufferStride, c = f3 ? f3.count : t3.count;
  let u2 = (f3 && f3.dstIndex ? f3.dstIndex : 0) * n2, l = (f3 && f3.srcIndex ? f3.srcIndex : 0) * r2;
  for (let s2 = 0; s2 < c; ++s2)
    d[u2] = o2[l], d[u2 + 1] = o2[l + 1], d[u2 + 2] = o2[l + 2], u2 += n2, l += r2;
}
function t2(e3, t3, f3, d, n2) {
  var _a, _b;
  const o2 = e3.typedBuffer, r2 = e3.typedBufferStride, c = (_a = n2 == null ? void 0 : n2.count) != null ? _a : e3.count;
  let u2 = ((_b = n2 == null ? void 0 : n2.dstIndex) != null ? _b : 0) * r2;
  for (let l = 0; l < c; ++l)
    o2[u2] = t3, o2[u2 + 1] = f3, o2[u2 + 2] = d, u2 += r2;
}
var f2 = Object.freeze(Object.defineProperty({ __proto__: null, copy: e2, fill: t2 }, Symbol.toStringTag, { value: "Module" }));

export {
  e,
  t,
  r,
  f,
  o,
  n,
  e2,
  t2
};
//# sourceMappingURL=chunk-C6HDWDWX.js.map
