import {
  s
} from "./chunk-LIZHLHNA.js";
import "./chunk-UA3YPL2R.js";
import "./chunk-HVKDYDPP.js";
import "./chunk-6QC7MLLS.js";
import {
  e
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/core/workers/request.js
var r;
function s2(s3, a) {
  let n = a.responseType;
  n ? "array-buffer" !== n && "blob" !== n && "json" !== n && "native" !== n && "native-request-init" !== n && "text" !== n && (n = "text") : n = "json", a.responseType = n;
  const o = e(a.signal);
  return delete a.signal, globalThis.invokeStaticMessage("request", { url: s3, options: a }, { signal: o }).then(async (t) => {
    let i, l, u, c, b;
    if (t.data)
      if (t.data instanceof ArrayBuffer) {
        if (!("json" !== n && "text" !== n && "blob" !== n || (i = new Blob([t.data]), "json" !== n && "text" !== n || (r || (r = new FileReaderSync()), c = r.readAsText(i), "json" !== n)))) {
          try {
            l = JSON.parse(c || null);
          } catch (f) {
            const t2 = { ...f, url: s3, requestOptions: a };
            throw new s("request:server", f.message, t2);
          }
          if (l.error) {
            const t2 = { ...l.error, url: s3, requestOptions: a };
            throw new s("request:server", l.error.message, t2);
          }
        }
      } else
        "native" === n && (t.data.signal = o, u = await fetch(t.data.url, t.data));
    switch (n) {
      case "blob":
        b = i;
        break;
      case "json":
        b = l;
        break;
      case "native":
        b = u;
        break;
      case "text":
        b = c;
        break;
      default:
        b = t.data;
    }
    return { data: b, requestOptions: a, ssl: t.ssl, url: s3 };
  });
}
export {
  s2 as execute
};
//# sourceMappingURL=request-MBAKQFXA.js.map
