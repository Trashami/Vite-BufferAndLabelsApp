import {
  a2 as a,
  c,
  d,
  o as o3,
  u2 as u,
  x as x2
} from "./chunk-6VAE3YKY.js";
import {
  c as c2,
  g,
  h,
  i,
  k,
  o as o2,
  r as r4,
  w as w3,
  x,
  y as y3
} from "./chunk-OAXPH6DL.js";
import {
  m,
  p
} from "./chunk-W62B63EU.js";
import {
  r as r3
} from "./chunk-NAN5J6QS.js";
import {
  w,
  w2
} from "./chunk-UWG37XSU.js";
import {
  r as r2
} from "./chunk-HLM6QCL2.js";
import {
  o
} from "./chunk-RXYULINL.js";
import {
  s as s2
} from "./chunk-VWYWOOPX.js";
import {
  s as s3
} from "./chunk-M5VHU5LK.js";
import {
  l
} from "./chunk-7QMMKGW4.js";
import {
  e as e2,
  n2 as n,
  y as y2
} from "./chunk-OOLCFNXJ.js";
import {
  s
} from "./chunk-LIZHLHNA.js";
import {
  y
} from "./chunk-HVKDYDPP.js";
import {
  e,
  r,
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/layers/support/rasterFunctions/BaseFunctionArguments.js
var e3 = class extends l {
  constructor() {
    super(...arguments), this.raster = void 0;
  }
};
e2([y2({ json: { write: true } })], e3.prototype, "raster", void 0), e3 = e2([n("esri.layers.support.rasterFunctions.AspectFunctionArguments")], e3);
var p2 = e3;

// node_modules/@arcgis/core/layers/support/rasterFunctions/AspectFunctionArguments.js
var e4;
var t2 = e4 = class extends p2 {
  clone() {
    return new e4({ raster: this.raster });
  }
};
t2 = e4 = e2([n("esri.layers.support.rasterFunctions.AspectFunctionArguments")], t2);
var c3 = t2;

// node_modules/@arcgis/core/layers/support/rasterFunctions/BaseRasterFunction.js
var n2 = class extends l {
  constructor() {
    super(...arguments), this.functionArguments = null, this.readingBufferSize = 0;
  }
  bind(r8, t7 = false) {
    const s7 = this._getRasterValues();
    for (let e9 = 0; e9 < s7.length; e9++) {
      const o8 = s7[e9];
      if (o8 && "object" == typeof o8 && "bind" in o8 && (!o8.rasterInfo || t7)) {
        const s8 = o8.bind(r8, t7);
        if (!s8.success)
          return s8;
      }
    }
    return !this.rasterInfo || t7 ? (this.sourceRasterInfos = this._getSourceRasterInfos(r8), this._bindSourceRasters()) : { success: true };
  }
  process(r8) {
    const t7 = this._getRasterValues().map((t8) => this._readRasterValue(t8, r8));
    return this._processPixels({ ...r8, pixelBlocks: t7 });
  }
  getPrimaryRasters() {
    const r8 = [], t7 = [];
    return this._getPrimaryRasters(this, r8, t7), { rasters: r8, rasterIds: t7 };
  }
  _getOutputPixelType(r8) {
    var _a;
    return "unknown" === this.outputPixelType ? r8 : (_a = this.outputPixelType) != null ? _a : r8;
  }
  _getRasterValues() {
    const { rasterArgumentNames: r8 } = this;
    return "rasters" === r8[0] && Array.isArray(this.functionArguments.rasters) ? this.functionArguments.rasters : r8.map((r9) => this.functionArguments[r9]);
  }
  _getSourceRasterInfos(r8) {
    const t7 = this._getRasterValues(), { rasterInfos: s7, rasterIds: e9 } = r8;
    return t7.map((r9) => r9 && "object" == typeof r9 && "bind" in r9 && r9.rasterInfo ? r9.rasterInfo : "string" == typeof r9 && e9.includes(r9) ? s7[e9.indexOf(r9)] : s7[0]);
  }
  _getPrimaryRasterId(r8) {
    return r8 == null ? void 0 : r8.url;
  }
  _getPrimaryRasters(r8, t7 = [], s7 = []) {
    for (let e9 = 0; e9 < r8.sourceRasters.length; e9++) {
      const o8 = r8.sourceRasters[e9];
      if ("number" != typeof o8)
        if ("bind" in o8)
          this._getPrimaryRasters(o8, t7, s7);
        else {
          const r9 = o8, e10 = this._getPrimaryRasterId(r9);
          if (null == e10)
            continue;
          s7.includes(e10) || (this.mainPrimaryRasterId === e10 ? (t7.unshift(r9), s7.unshift(e10)) : (t7.push(r9), s7.push(e10)));
        }
    }
  }
  _readRasterValue(r8, t7) {
    const { primaryPixelBlocks: e9 } = t7;
    if (t(r8) || "$$" === r8) {
      const r9 = e9[0];
      return t(r9) ? null : r9.clone();
    }
    if ("string" == typeof r8) {
      const s7 = t7.primaryRasterIds.indexOf(r8);
      return -1 === s7 ? null : e9[s7];
    }
    if ("number" == typeof r8) {
      const t8 = e9[0];
      if (t(t8))
        return null;
      const o8 = new Float32Array(t8.width * t8.height);
      o8.fill(r8);
      const i16 = t8.clone();
      return i16.pixels = i16.pixels.map(() => o8), i16;
    }
    return r8.process(t7);
  }
};
e2([y2({ json: { write: true } })], n2.prototype, "functionName", void 0), e2([y2({ json: { write: true } })], n2.prototype, "functionArguments", void 0), e2([y2()], n2.prototype, "rasterArgumentNames", void 0), e2([y2({ json: { write: true } }), s2((r8) => r8 == null ? void 0 : r8.toLowerCase())], n2.prototype, "outputPixelType", void 0), e2([y2({ json: { write: true } })], n2.prototype, "mainPrimaryRasterId", void 0), e2([y2()], n2.prototype, "sourceRasters", void 0), e2([y2({ json: { write: true } })], n2.prototype, "sourceRasterInfos", void 0), e2([y2({ json: { write: true } })], n2.prototype, "rasterInfo", void 0), e2([y2({ json: { write: true } })], n2.prototype, "readingBufferSize", void 0), n2 = e2([n("esri.layers.support.rasterFunctions.BaseRasterFunction")], n2);
var a2 = n2;

// node_modules/@arcgis/core/layers/support/rasterFunctions/AspectFunction.js
var c4 = class extends a2 {
  constructor() {
    super(...arguments), this.functionName = "Aspect", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isGCS = false;
  }
  _bindSourceRasters() {
    const t7 = this.sourceRasterInfos[0];
    this.isGCS = t7.spatialReference.isGeographic, this.outputPixelType = this._getOutputPixelType("f32");
    const s7 = t7.clone();
    return s7.pixelType = this.outputPixelType, s7.statistics = null, s7.histograms = null, this.rasterInfo = s7, { success: true };
  }
  _processPixels(t7) {
    var _a;
    const e9 = (_a = t7.pixelBlocks) == null ? void 0 : _a[0];
    if (t(e9))
      return null;
    const { extent: r8 } = t7, o8 = r8 ? { x: r8.width / e9.width, y: r8.height / e9.height } : { x: 1, y: 1 };
    return o3(e9, { resolution: o8 });
  }
};
e2([y2({ json: { write: true, name: "rasterFunction" } })], c4.prototype, "functionName", void 0), e2([y2({ type: c3, json: { write: true, name: "rasterFunctionArguments" } })], c4.prototype, "functionArguments", void 0), e2([y2()], c4.prototype, "rasterArgumentNames", void 0), e2([y2({ json: { write: true } })], c4.prototype, "isGCS", void 0), c4 = e2([n("esri.layers.support.rasterFunctions.AspectFunction")], c4);
var p3 = c4;

// node_modules/@arcgis/core/layers/support/rasterFunctions/customBandIndexUtils.js
var e5 = /* @__PURE__ */ new Set(["+", "-", "*", "/", "(", ")"]);
function t3(t7, n12) {
  (t7 = t7.replace(/ /g, "")).startsWith("-") && (t7 = "0" + t7), t7.startsWith("+") && (t7 = t7.slice(1, t7.length));
  const r8 = t7.split(""), l13 = [], o8 = [];
  let s7 = "";
  for (let a19 = 0; a19 < r8.length; a19++) {
    const t8 = r8[a19];
    if (e5.has(t8))
      "" !== s7 && o8.push(parseFloat(s7)), l13.push(t8), s7 = "";
    else {
      if ("b" === t8.toLowerCase()) {
        a19++, s7 = t8.concat(r8[a19]), o8.push(n12[parseInt(s7[1], 10) - 1]), s7 = "";
        continue;
      }
      s7 = s7.concat(t8), a19 === r8.length - 1 && o8.push(parseFloat(s7));
    }
  }
  return { ops: l13, nums: o8 };
}
function n3(e9, t7, n12, r8) {
  if ("number" == typeof n12 && "number" == typeof r8)
    return n12 + r8;
  let l13;
  if ("number" == typeof n12) {
    l13 = r8.length;
    const e10 = n12;
    (n12 = new Float32Array(l13)).fill(e10);
  } else if (l13 = n12.length, r8.constructor === Number) {
    const e10 = r8;
    (r8 = new Float32Array(l13)).fill(e10);
  }
  const o8 = new Float32Array(l13);
  switch (t7) {
    case "+":
      for (let t8 = 0; t8 < l13; t8++)
        (null == e9 || e9[t8]) && (o8[t8] = n12[t8] + r8[t8]);
      break;
    case "-":
      for (let t8 = 0; t8 < l13; t8++)
        (null == e9 || e9[t8]) && (o8[t8] = n12[t8] - r8[t8]);
      break;
    case "*":
      for (let t8 = 0; t8 < l13; t8++)
        (null == e9 || e9[t8]) && (o8[t8] = n12[t8] * r8[t8]);
      break;
    case "/":
      for (let t8 = 0; t8 < l13; t8++)
        (null == e9 || e9[t8]) && r8[t8] && (o8[t8] = n12[t8] / r8[t8]);
      break;
    case "(":
    case ")":
      throw "encountered error with custom band index equation";
  }
  return o8;
}
function r5(e9, t7) {
  e9.splice(t7, 1);
  let n12 = 0, r8 = 0;
  do {
    n12 = 0, r8 = 0;
    for (let t8 = 0; t8 < e9.length; t8++)
      if ("(" === e9[t8])
        n12 = t8;
      else if (")" === e9[t8]) {
        r8 = t8;
        break;
      }
    r8 === n12 + 1 && e9.splice(n12, 2);
  } while (r8 === n12 + 1);
  return e9;
}
function l2(e9) {
  if (1 === e9.length)
    return { opIndex: 0, numIndex: 0 };
  let t7 = 0, n12 = 0;
  for (let s7 = 0; s7 < e9.length; s7++)
    if ("(" === e9[s7])
      t7 = s7;
    else if (")" === e9[s7]) {
      n12 = s7;
      break;
    }
  const r8 = 0 === n12 ? e9 : e9.slice(t7 + 1, n12);
  let l13 = -1;
  for (let s7 = 0; s7 < r8.length; s7++)
    if ("*" === r8[s7] || "/" === r8[s7]) {
      l13 = s7;
      break;
    }
  if (l13 > -1)
    n12 > 0 && (l13 += t7 + 1);
  else {
    for (let e10 = 0; e10 < r8.length; e10++)
      if ("+" === r8[e10] || "-" === r8[e10]) {
        l13 = e10;
        break;
      }
    n12 > 0 && (l13 += t7 + 1);
  }
  let o8 = 0;
  for (let s7 = 0; s7 < l13; s7++)
    "(" === e9[s7] && o8++;
  return { opIndex: l13, numIndex: l13 - o8 };
}
function o4(e9, o8, s7) {
  let a19, { ops: f4, nums: i16 } = t3(s7, o8);
  if (0 === f4.length) {
    const e10 = 1 === i16.length ? i16[0] : o8[0];
    if (e10 instanceof Float32Array)
      return [e10];
    const t7 = new Float32Array(o8[0].length);
    return "number" == typeof e10 ? t7.fill(e10) : t7.set(e10), [t7];
  }
  for (; f4.length > 0; ) {
    const { numIndex: t7, opIndex: o9 } = l2(f4);
    if (a19 = n3(e9, f4[o9], i16[t7], i16[t7 + 1]), 1 === f4.length)
      break;
    f4 = r5(f4, o9), i16.splice(t7, 2, a19);
  }
  return [a19];
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/bandIndexUtils.js
var a3 = new s3({ 0: "custom", 1: "ndvi", 2: "savi", 3: "tsavi", 4: "msavi", 5: "gemi", 6: "pvi", 7: "gvitm", 8: "sultan", 9: "vari", 10: "gndvi", 11: "sr", 12: "ndvi-re", 13: "sr-re", 14: "mtvi2", 15: "rtvi-core", 16: "ci-re", 17: "ci-g", 18: "ndwi", 19: "evi", 20: "iron-oxide", 21: "ferrous-minerals", 22: "clay-minerals", 23: "wndwi", 24: "bai", 25: "nbr", 26: "ndbi", 27: "ndmi", 28: "ndsi", 29: "mndwi" }, { useNumericKeys: true });
function s4(n12, a19) {
  var _a;
  if (!r4(n12))
    return n12;
  const { equation: s7, method: i16 } = a19, x4 = a19.bandIndexes.map((n13) => n13 - 1), { pixels: j2, mask: q2 } = n12;
  let M2;
  switch (i16) {
    case "gndvi":
    case "nbr":
    case "ndbi":
    case "ndvi":
    case "ndvi-re":
    case "ndsi":
    case "ndmi":
    case "mndwi":
      M2 = l3(q2, j2[x4[0]], j2[x4[1]]);
      break;
    case "ndwi":
      M2 = l3(q2, j2[x4[1]], j2[x4[0]]);
      break;
    case "sr":
    case "sr-re":
    case "iron-oxide":
    case "ferrous-minerals":
    case "clay-minerals":
      M2 = c5(q2, j2[x4[0]], j2[x4[1]]);
      break;
    case "ci-g":
    case "ci-re":
      M2 = u2(q2, j2[x4[0]], j2[x4[1]]);
      break;
    case "savi":
      M2 = f(q2, j2[x4[0]], j2[x4[1]], x4[2] + 1);
      break;
    case "tsavi":
      M2 = m2(q2, j2[x4[0]], j2[x4[1]], x4[2] + 1, x4[3] + 1, x4[4] + 1);
      break;
    case "msavi":
      M2 = w4(q2, j2[x4[0]], j2[x4[1]]);
      break;
    case "gemi":
      M2 = h2(q2, j2[x4[0]], j2[x4[1]]);
      break;
    case "pvi":
      M2 = d2(q2, j2[x4[0]], j2[x4[1]], x4[2] + 1, x4[3] + 1);
      break;
    case "gvitm":
      M2 = g2(q2, [j2[x4[0]], j2[x4[1]], j2[x4[2]], j2[x4[3]], j2[x4[4]], j2[x4[5]]]);
      break;
    case "sultan":
      M2 = y4(q2, [j2[x4[0]], j2[x4[1]], j2[x4[2]], j2[x4[3]], j2[x4[4]], j2[x4[5]]]);
      break;
    case "vari":
      M2 = b(q2, [j2[x4[0]], j2[x4[1]], j2[x4[2]]]);
      break;
    case "mtvi2":
      M2 = v(q2, [j2[x4[0]], j2[x4[1]], j2[x4[2]]]);
      break;
    case "rtvi-core":
      M2 = k2(q2, [j2[x4[0]], j2[x4[1]], j2[x4[2]]]);
      break;
    case "evi":
      M2 = p4(q2, [j2[x4[0]], j2[x4[1]], j2[x4[2]]]);
      break;
    case "wndwi":
      M2 = A(q2, [j2[x4[0]], j2[x4[1]], j2[x4[2]]], (_a = x4[3]) != null ? _a : 0.5);
      break;
    case "bai":
      M2 = F(q2, j2[x4[0]], j2[x4[1]]);
      break;
    case "custom":
      M2 = o4(q2, j2, s7);
      break;
    default:
      return n12;
  }
  const U2 = r(q2) ? new Uint8Array(q2.length) : null;
  r(q2) && r(U2) && U2.set(q2);
  const B2 = new g({ width: n12.width, height: n12.height, pixelType: "f32", pixels: M2, mask: U2 });
  return B2.updateStatistics(), B2;
}
function i2(n12, t7, r8, o8) {
  const { mask: a19, pixels: s7, width: i16, height: l13 } = n12, c23 = s7[r8], u11 = s7[t7], f4 = u11.length, m5 = o8 ? new Uint8Array(f4) : new Float32Array(f4), w6 = o8 ? 100 : 1, h6 = o8 ? 100 : 0;
  for (let e9 = 0; e9 < f4; e9++)
    if (null == a19 || a19[e9]) {
      const n13 = c23[e9], t8 = u11[e9], r9 = n13 + t8;
      r9 && (m5[e9] = (n13 - t8) / r9 * w6 + h6);
    }
  const d5 = new g({ width: i16, height: l13, mask: a19, pixelType: o8 ? "u8" : "f32", pixels: [m5] });
  return d5.updateStatistics(), d5;
}
function l3(n12, t7, e9) {
  const r8 = e9.length, o8 = new Float32Array(r8);
  for (let a19 = 0; a19 < r8; a19++)
    if (null == n12 || n12[a19]) {
      const n13 = t7[a19], r9 = e9[a19], s7 = n13 + r9;
      s7 && (o8[a19] = (n13 - r9) / s7);
    }
  return [o8];
}
function c5(n12, t7, e9) {
  const r8 = e9.length, o8 = new Float32Array(r8);
  for (let a19 = 0; a19 < r8; a19++)
    if (null == n12 || n12[a19]) {
      const n13 = t7[a19], r9 = e9[a19];
      r9 && (o8[a19] = n13 / r9);
    }
  return [o8];
}
function u2(n12, t7, e9) {
  const r8 = t7.length, o8 = new Float32Array(r8);
  for (let a19 = 0; a19 < r8; a19++)
    if (null == n12 || n12[a19]) {
      const n13 = t7[a19], r9 = e9[a19];
      r9 && (o8[a19] = n13 / r9 - 1);
    }
  return [o8];
}
function f(n12, t7, e9, r8) {
  const o8 = e9.length, a19 = new Float32Array(o8);
  for (let s7 = 0; s7 < o8; s7++)
    if (null == n12 || n12[s7]) {
      const n13 = e9[s7], o9 = t7[s7], i16 = o9 + n13 + r8;
      i16 && (a19[s7] = (o9 - n13) / i16 * (1 + r8));
    }
  return [a19];
}
function m2(n12, t7, e9, r8, o8, a19) {
  const s7 = e9.length, i16 = new Float32Array(s7), l13 = -o8 * r8 + a19 * (1 + r8 * r8);
  for (let c23 = 0; c23 < s7; c23++)
    if (null == n12 || n12[c23]) {
      const n13 = e9[c23], a20 = t7[c23], s8 = o8 * a20 + n13 + l13;
      s8 && (i16[c23] = r8 * (a20 - r8 * n13 - o8) / s8);
    }
  return [i16];
}
function w4(n12, t7, e9) {
  const r8 = e9.length, o8 = new Float32Array(r8);
  for (let a19 = 0; a19 < r8; a19++)
    if (null == n12 || n12[a19]) {
      const n13 = e9[a19], r9 = t7[a19];
      o8[a19] = 0.5 * (2 * (r9 + 1) - Math.sqrt((2 * r9 + 1) ** 2 - 8 * (r9 - n13)));
    }
  return [o8];
}
function h2(n12, t7, e9) {
  const r8 = e9.length, o8 = new Float32Array(r8);
  for (let a19 = 0; a19 < r8; a19++)
    if (null == n12 || n12[a19]) {
      const n13 = e9[a19], r9 = t7[a19];
      if (1 !== n13) {
        const t8 = (2 * (r9 * r9 - n13 * n13) + 1.5 * r9 + 0.5 * n13) / (r9 + n13 + 0.5);
        o8[a19] = t8 * (1 - 0.25 * t8) - (n13 - 0.125) / (1 - n13);
      }
    }
  return [o8];
}
function d2(n12, t7, e9, r8, o8) {
  const a19 = e9.length, s7 = new Float32Array(a19), i16 = Math.sqrt(1 + r8 * r8);
  for (let l13 = 0; l13 < a19; l13++)
    if (null == n12 || n12[l13]) {
      const n13 = e9[l13], a20 = t7[l13];
      s7[l13] = (a20 - r8 * n13 - o8) / i16;
    }
  return [s7];
}
function g2(n12, t7) {
  const [e9, r8, o8, a19, s7, i16] = t7, l13 = e9.length, c23 = new Float32Array(l13);
  for (let u11 = 0; u11 < l13; u11++)
    (null == n12 || n12[u11]) && (c23[u11] = -0.2848 * e9[u11] - 0.2435 * r8[u11] - 0.5436 * o8[u11] + 0.7243 * a19[u11] + 0.084 * s7[u11] - 1.18 * i16[u11]);
  return [c23];
}
function y4(n12, t7) {
  const [e9, , r8, o8, a19, s7] = t7, i16 = e9.length, l13 = new Float32Array(i16), c23 = new Float32Array(i16), u11 = new Float32Array(i16);
  for (let f4 = 0; f4 < i16; f4++)
    (null == n12 || n12[f4]) && (l13[f4] = s7[f4] ? a19[f4] / s7[f4] * 100 : 0, c23[f4] = e9[f4] ? a19[f4] / e9[f4] * 100 : 0, u11[f4] = o8[f4] ? r8[f4] / o8[f4] * (a19[f4] / o8[f4]) * 100 : 0);
  return [l13, c23, u11];
}
function b(n12, t7) {
  const [e9, r8, o8] = t7, a19 = e9.length, s7 = new Float32Array(a19);
  for (let i16 = 0; i16 < a19; i16++)
    if (null == n12 || n12[i16])
      for (i16 = 0; i16 < a19; i16++) {
        const n13 = e9[i16], t8 = r8[i16], a20 = t8 + n13 - o8[i16];
        a20 && (s7[i16] = (t8 - n13) / a20);
      }
  return [s7];
}
function v(n12, t7) {
  const [e9, r8, o8] = t7, a19 = e9.length, s7 = new Float32Array(a19);
  for (let i16 = 0; i16 < a19; i16++)
    if (null == n12 || n12[i16])
      for (i16 = 0; i16 < a19; i16++) {
        const n13 = e9[i16], t8 = r8[i16], a20 = o8[i16], l13 = Math.sqrt((2 * n13 + 1) ** 2 - 6 * n13 - 5 * Math.sqrt(t8) - 0.5);
        s7[i16] = 1.5 * (1.2 * (n13 - a20) - 2.5 * (t8 - a20)) * l13;
      }
  return [s7];
}
function k2(n12, t7) {
  const [e9, r8, o8] = t7, a19 = e9.length, s7 = new Float32Array(a19);
  for (let i16 = 0; i16 < a19; i16++)
    if (null == n12 || n12[i16])
      for (i16 = 0; i16 < a19; i16++) {
        const n13 = e9[i16], t8 = r8[i16], a20 = o8[i16];
        s7[i16] = 100 * (n13 - t8) - 10 * (n13 - a20);
      }
  return [s7];
}
function p4(n12, t7) {
  const [e9, r8, o8] = t7, a19 = e9.length, s7 = new Float32Array(a19);
  for (let i16 = 0; i16 < a19; i16++)
    if (null == n12 || n12[i16])
      for (i16 = 0; i16 < a19; i16++) {
        const n13 = e9[i16], t8 = r8[i16], a20 = n13 + 6 * t8 - 7.5 * o8[i16] + 1;
        a20 && (s7[i16] = 2.5 * (n13 - t8) / a20);
      }
  return [s7];
}
function A(n12, t7, e9 = 0.5) {
  const [r8, o8, a19] = t7, s7 = o8.length, i16 = new Float32Array(s7);
  for (let l13 = 0; l13 < s7; l13++)
    if (null == n12 || n12[l13])
      for (l13 = 0; l13 < s7; l13++) {
        const n13 = r8[l13], t8 = o8[l13], s8 = a19[l13], c23 = n13 + e9 * t8 + (1 - e9) * s8;
        c23 && (i16[l13] = (n13 - e9 * t8 - (1 - e9) * s8) / c23);
      }
  return [i16];
}
function F(n12, t7, e9) {
  const r8 = e9.length, o8 = new Float32Array(r8);
  for (let a19 = 0; a19 < r8; a19++)
    if (null == n12 || n12[a19])
      for (a19 = 0; a19 < r8; a19++) {
        const n13 = (0.1 - t7[a19]) ** 2 + (0.06 - e9[a19]) ** 2;
        n13 && (o8[a19] = 1 / n13);
      }
  return [o8];
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/BandArithmeticFunctionArguments.js
var p5;
var a4 = p5 = class extends p2 {
  constructor() {
    super(...arguments), this.method = "custom";
  }
  clone() {
    return new p5({ method: this.method, bandIndexes: this.bandIndexes, raster: y(this.raster) });
  }
};
e2([y2({ json: { type: String, write: true } })], a4.prototype, "bandIndexes", void 0), e2([r3(a3)], a4.prototype, "method", void 0), a4 = p5 = e2([n("esri.layers.support.rasterFunctions.BandArithmeticFunctionArguments")], a4);
var i3 = a4;

// node_modules/@arcgis/core/layers/support/rasterFunctions/BandArithmeticFunction.js
var u3 = class extends a2 {
  constructor() {
    super(...arguments), this.functionName = "BandArithmetic", this.functionArguments = null, this.rasterArgumentNames = ["raster"];
  }
  _bindSourceRasters() {
    this.outputPixelType = this._getOutputPixelType("f32");
    const t7 = this.sourceRasterInfos[0], s7 = t7.clone();
    return s7.pixelType = this.outputPixelType, s7.statistics = null, s7.histograms = null, s7.bandCount = "sultan" === this.functionArguments.method ? t7.bandCount : 1, this.rasterInfo = s7, { success: true };
  }
  _processPixels(t7) {
    var _a;
    const e9 = (_a = t7.pixelBlocks) == null ? void 0 : _a[0];
    if (t(e9))
      return e9;
    const { method: r8, bandIndexes: o8 } = this.functionArguments, i16 = o8.split(" ").map((t8) => parseFloat(t8));
    return s4(e9, { method: r8, bandIndexes: i16, equation: o8 });
  }
};
e2([y2({ json: { write: true, name: "rasterFunction" } })], u3.prototype, "functionName", void 0), e2([y2({ type: i3, json: { write: true, name: "rasterFunctionArguments" } })], u3.prototype, "functionArguments", void 0), e2([y2()], u3.prototype, "rasterArgumentNames", void 0), u3 = e2([n("esri.layers.support.rasterFunctions.BandArithmeticFunction")], u3);
var a5 = u3;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ColormapFunctionArguments.js
var c6;
var l4 = c6 = class extends p2 {
  readColorRamp(o8) {
    return p(o8);
  }
  clone() {
    var _a;
    return new c6({ colormap: y(this.colormap), colormapName: this.colormapName, colorRamp: (_a = this.colorRamp) == null ? void 0 : _a.clone(), colorRampName: this.colorRampName });
  }
};
e2([y2({ type: [[Number]], json: { write: true } })], l4.prototype, "colormap", void 0), e2([y2({ type: String, json: { write: true } })], l4.prototype, "colormapName", void 0), e2([y2({ types: m, json: { write: true } })], l4.prototype, "colorRamp", void 0), e2([o("colorRamp")], l4.prototype, "readColorRamp", null), e2([y2({ type: String, json: { write: true } })], l4.prototype, "colorRampName", void 0), l4 = c6 = e2([n("esri.layers.support.rasterFunctions.ColormapFunctionArguments")], l4);
var i4 = l4;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ColormapFunction.js
var i5 = class extends a2 {
  constructor() {
    super(...arguments), this.functionName = "Colormap", this.functionArguments = null, this.rasterArgumentNames = ["raster"];
  }
  _bindSourceRasters() {
    const r8 = this.sourceRasterInfos[0];
    if (r8.bandCount > 1)
      return { success: false, error: "colormap-function: source data must be single band" };
    let { colormap: o8, colorRamp: t7 } = this.functionArguments;
    if ((o8 == null ? void 0 : o8.length) || t7 && (o8 = c(t7, 256, true)), !(o8 == null ? void 0 : o8.length))
      return { success: false, error: "colormap-function: missing colormap argument" };
    this.outputPixelType = this._getOutputPixelType("u8");
    const s7 = r8.clone();
    return s7.pixelType = this.outputPixelType, s7.colormap = o8, this.rasterInfo = s7, { success: true };
  }
  _processPixels(r8) {
    var _a;
    return (_a = r8.pixelBlocks) == null ? void 0 : _a[0];
  }
};
e2([y2({ json: { write: true, name: "rasterFunction" } })], i5.prototype, "functionName", void 0), e2([y2({ type: i4, json: { write: true, name: "rasterFunctionArguments" } })], i5.prototype, "functionArguments", void 0), e2([y2()], i5.prototype, "rasterArgumentNames", void 0), e2([y2({ json: { write: true } })], i5.prototype, "indexedColormap", void 0), i5 = e2([n("esri.layers.support.rasterFunctions.ColormapFunction")], i5);
var p6 = i5;

// node_modules/@arcgis/core/layers/support/rasterFunctions/CompositeBandFunctionArguments.js
var a6;
var c7 = a6 = class extends p2 {
  writeRasters(r8, s7) {
    s7.rasters = r8.map((r9) => "number" == typeof r9 || "string" == typeof r9 ? r9 : r9.toJSON());
  }
  clone() {
    return new a6({ rasters: y(this.rasters) });
  }
};
e2([y2({ json: { write: true } })], c7.prototype, "rasters", void 0), e2([r2("rasters")], c7.prototype, "writeRasters", null), c7 = a6 = e2([n("esri.layers.support.rasterFunctions.CompositeBandFunctionArguments")], c7);
var n4 = c7;

// node_modules/@arcgis/core/layers/support/rasterFunctions/CompositeBandFunction.js
var p7 = class extends a2 {
  constructor() {
    super(...arguments), this.functionName = "CompositeBand", this.functionArguments = null, this.rasterArgumentNames = ["rasters"];
  }
  _bindSourceRasters() {
    const { sourceRasterInfos: t7 } = this, r8 = t7[0];
    this.outputPixelType = this._getOutputPixelType(r8.pixelType);
    const e9 = r8.clone();
    if (e9.attributeTable = null, e9.colormap = null, e9.pixelType = this.outputPixelType, e9.bandCount = t7.map(({ bandCount: t8 }) => t8).reduce((t8, s7) => t8 + s7), t7.every(({ statistics: t8 }) => r(t8) && t8.length)) {
      const r9 = [];
      t7.forEach(({ statistics: t8 }) => r(t8) && r9.push(...t8)), e9.statistics = r9;
    }
    if (t7.every(({ histograms: t8 }) => r(t8) && t8.length)) {
      const r9 = [];
      t7.forEach(({ histograms: t8 }) => r(t8) && r9.push(...t8)), e9.histograms = r9;
    }
    return this.rasterInfo = e9, { success: true };
  }
  _processPixels(t7) {
    const { pixelBlocks: s7 } = t7;
    if (!s7)
      return null;
    const e9 = s7 == null ? void 0 : s7[0];
    return t(e9) ? null : h(s7);
  }
};
e2([y2({ json: { write: true, name: "rasterFunction" } })], p7.prototype, "functionName", void 0), e2([y2({ type: n4, json: { write: true, name: "rasterFunctionArguments" } })], p7.prototype, "functionArguments", void 0), e2([y2()], p7.prototype, "rasterArgumentNames", void 0), p7 = e2([n("esri.layers.support.rasterFunctions.CompositeBandFunction")], p7);
var u4 = p7;

// node_modules/@arcgis/core/layers/support/rasterFunctions/convolutionUtils.js
var t4;
!function(e9) {
  e9[e9.UserDefined = -1] = "UserDefined", e9[e9.LineDetectionHorizontal = 0] = "LineDetectionHorizontal", e9[e9.LineDetectionVertical = 1] = "LineDetectionVertical", e9[e9.LineDetectionLeftDiagonal = 2] = "LineDetectionLeftDiagonal", e9[e9.LineDetectionRightDiagonal = 3] = "LineDetectionRightDiagonal", e9[e9.GradientNorth = 4] = "GradientNorth", e9[e9.GradientWest = 5] = "GradientWest", e9[e9.GradientEast = 6] = "GradientEast", e9[e9.GradientSouth = 7] = "GradientSouth", e9[e9.GradientNorthEast = 8] = "GradientNorthEast", e9[e9.GradientNorthWest = 9] = "GradientNorthWest", e9[e9.SmoothArithmeticMean = 10] = "SmoothArithmeticMean", e9[e9.Smoothing3x3 = 11] = "Smoothing3x3", e9[e9.Smoothing5x5 = 12] = "Smoothing5x5", e9[e9.Sharpening3x3 = 13] = "Sharpening3x3", e9[e9.Sharpening5x5 = 14] = "Sharpening5x5", e9[e9.Laplacian3x3 = 15] = "Laplacian3x3", e9[e9.Laplacian5x5 = 16] = "Laplacian5x5", e9[e9.SobelHorizontal = 17] = "SobelHorizontal", e9[e9.SobelVertical = 18] = "SobelVertical", e9[e9.Sharpen = 19] = "Sharpen", e9[e9.Sharpen2 = 20] = "Sharpen2", e9[e9.PointSpread = 21] = "PointSpread", e9[e9.None = 255] = "None";
}(t4 || (t4 = {}));
var n5 = /* @__PURE__ */ new Map();
function o5(e9) {
  const t7 = Math.sqrt(e9.length), n12 = e9.slice(0, t7), o8 = [1];
  for (let i16 = 1; i16 < t7; i16++) {
    let n13 = null;
    for (let o9 = 0; o9 < t7; o9++) {
      const r8 = e9[o9 + i16 * t7], a19 = e9[o9];
      if (null == n13)
        if (0 === a19) {
          if (r8)
            return { separable: false, row: null, col: null };
        } else
          n13 = r8 / a19;
      else if (r8 / a19 !== n13)
        return { separable: false, row: null, col: null };
    }
    if (null == n13)
      return { separable: false, row: null, col: null };
    o8.push(n13);
  }
  return { separable: true, row: n12, col: o8 };
}
function i6(e9, t7, n12, o8, i16, r8, a19) {
  const l13 = new Float32Array(t7 * n12), s7 = r8.length, h6 = a19 ? 0 : o8, c23 = a19 ? o8 : 0, p14 = a19 ? 1 : t7;
  for (let f4 = h6; f4 < n12 - h6; f4++) {
    const n13 = f4 * t7;
    for (let a20 = c23; a20 < t7 - c23; a20++) {
      if (i16 && !i16[n13 + a20])
        continue;
      let t8 = 0;
      for (let i17 = 0; i17 < s7; i17++)
        t8 += e9[n13 + a20 + (i17 - o8) * p14] * r8[i17];
      l13[n13 + a20] = t8;
    }
  }
  return l13;
}
function r6(e9, t7, n12, o8, i16, r8, a19) {
  const l13 = new Float32Array(t7 * n12), s7 = Math.floor(o8 / 2), h6 = Math.floor(i16 / 2);
  for (let c23 = s7; c23 < n12 - s7; c23++) {
    const n13 = c23 * t7;
    for (let c24 = h6; c24 < t7 - h6; c24++) {
      if (r8 && !r8[n13 + c24])
        continue;
      let p14 = 0;
      for (let r9 = 0; r9 < o8; r9++)
        for (let o9 = 0; o9 < i16; o9++)
          p14 += e9[n13 + c24 + (r9 - s7) * t7 + o9 - h6] * a19[r9 * i16 + o9];
      l13[n13 + c24] = p14;
    }
  }
  return l13;
}
function a7(t7, n12, o8 = true) {
  const { pixels: i16, width: a19, height: s7, pixelType: h6, mask: c23 } = t7, p14 = i16.length, f4 = [], { kernel: u11, rows: S2, cols: g4 } = n12;
  for (let e9 = 0; e9 < p14; e9++) {
    const t8 = r6(i16[e9], a19, s7, S2, g4, c23, u11);
    o8 && l5(t8, a19, s7, S2, g4), f4.push(t8);
  }
  return new g({ width: a19, height: s7, pixelType: h6, pixels: f4, mask: c23 });
}
function l5(e9, t7, n12, o8, i16) {
  const r8 = Math.floor(o8 / 2);
  for (let l13 = 0; l13 < r8; l13++)
    for (let o9 = 0; o9 < t7; o9++)
      e9[l13 * t7 + o9] = e9[(i16 - 1 - l13) * t7 + o9], e9[(n12 - 1 - l13) * t7 + o9] = e9[(n12 - i16 + l13) * t7 + o9];
  const a19 = Math.floor(i16 / 2);
  for (let l13 = 0; l13 < n12; l13++) {
    const n13 = l13 * t7;
    for (let o9 = 0; o9 < a19; o9++)
      e9[n13 + o9] = e9[n13 + i16 - 1 - o9], e9[n13 + t7 - o9 - 1] = e9[n13 + t7 + o9 - i16];
  }
}
function s5(t7, n12, o8, r8 = true) {
  const { pixels: a19, width: s7, height: h6, pixelType: c23, mask: p14 } = t7, f4 = a19.length, u11 = [], S2 = n12.length, g4 = o8.length, x4 = Math.floor(S2 / 2), d5 = Math.floor(g4 / 2);
  for (let e9 = 0; e9 < f4; e9++) {
    let t8 = i6(a19[e9], s7, h6, x4, p14, n12, true);
    t8 = i6(t8, s7, h6, d5, p14, o8, false), r8 && l5(t8, s7, h6, S2, g4), u11.push(t8);
  }
  return new g({ width: s7, height: h6, pixelType: c23, pixels: u11, mask: p14 });
}
function h3(e9, t7) {
  const n12 = o5(t7.kernel), i16 = false !== t7.mirrorEdges, r8 = n12.separable ? s5(e9, n12.row, n12.col, i16) : a7(e9, t7, i16), { outputPixelType: l13 } = t7;
  return l13 && r8.clamp(l13), r8;
}
n5.set(t4.None, [0, 0, 0, 0, 1, 0, 0, 0, 0]), n5.set(t4.LineDetectionHorizontal, [-1, -1, -1, 2, 2, 2, -1, -1, -1]), n5.set(t4.LineDetectionVertical, [-1, 2, -1, -1, 2, -1, -1, 2, -1]), n5.set(t4.LineDetectionLeftDiagonal, [2, -1, -1, -1, 2, -1, -1, -1, 2]), n5.set(t4.LineDetectionRightDiagonal, [-1, -1, 2, -1, 2, -1, 2, -1, -1]), n5.set(t4.GradientNorth, [-1, -2, -1, 0, 0, 0, 1, 2, 1]), n5.set(t4.GradientWest, [-1, 0, 1, -2, 0, 2, -1, 0, 1]), n5.set(t4.GradientEast, [1, 0, -1, 2, 0, -2, 1, 0, -1]), n5.set(t4.GradientSouth, [1, 2, 1, 0, 0, 0, -1, -2, -1]), n5.set(t4.GradientNorthEast, [0, -1, -2, 1, 0, -1, 2, 1, 0]), n5.set(t4.GradientNorthWest, [-2, -1, 0, -1, 0, 1, 0, 1, 2]), n5.set(t4.SmoothArithmeticMean, [0.111111111111, 0.111111111111, 0.111111111111, 0.111111111111, 0.111111111111, 0.111111111111, 0.111111111111, 0.111111111111, 0.111111111111]), n5.set(t4.Smoothing3x3, [0.0625, 0.125, 0.0625, 0.125, 0.25, 0.125, 0.0625, 0.125, 0.0625]), n5.set(t4.Smoothing5x5, [1, 1, 1, 1, 1, 1, 4, 4, 4, 1, 1, 4, 12, 4, 1, 1, 4, 4, 4, 1, 1, 1, 1, 1, 1]), n5.set(t4.Sharpening3x3, [-1, -1, -1, -1, 9, -1, -1, -1, -1]), n5.set(t4.Sharpening5x5, [-1, -3, -4, -3, -1, -3, 0, 6, 0, -3, -4, 6, 21, 6, -4, -3, 0, 6, 0, -3, -1, -3, -4, -3, -1]), n5.set(t4.Laplacian3x3, [0, -1, 0, -1, 4, -1, 0, -1, 0]), n5.set(t4.Laplacian5x5, [0, 0, -1, 0, 0, 0, -1, -2, -1, 0, -1, -2, 17, -2, -1, 0, -1, -2, -1, 0, 0, 0, -1, 0, 0]), n5.set(t4.SobelHorizontal, [-1, -2, -1, 0, 0, 0, 1, 2, 1]), n5.set(t4.SobelVertical, [-1, 0, 1, -2, 0, 2, -1, 0, 1]), n5.set(t4.Sharpen, [0, -0.25, 0, -0.25, 2, -0.25, 0, -0.25, 0]), n5.set(t4.Sharpen2, [-0.25, -0.25, -0.25, -0.25, 3, -0.25, -0.25, -0.25, -0.25]), n5.set(t4.PointSpread, [-0.627, 0.352, -0.627, 0.352, 2.923, 0.352, -0.627, 0.352, -0.627]);

// node_modules/@arcgis/core/layers/support/rasterFunctions/ConvolutionFunctionArguments.js
var i7;
var c8 = i7 = class extends p2 {
  constructor() {
    super(...arguments), this.rows = 3, this.cols = 3, this.kernel = [0, 0, 0, 0, 1, 0, 0, 0, 0];
  }
  set kernelType(e9) {
    this._set("kernelType", e9);
    const r8 = n5.get(e9);
    if (!r8 || e9 === t4.UserDefined || e9 === t4.None)
      return;
    const s7 = Math.sqrt(r8.length);
    this._set("kernel", r8), this._set("cols", s7), this._set("rows", s7);
  }
  clone() {
    return new i7({ cols: this.cols, rows: this.rows, kernel: [...this.kernel], kernelType: this.kernelType, raster: y(this.raster) });
  }
};
e2([y2({ json: { type: Number, write: true } })], c8.prototype, "rows", void 0), e2([y2({ json: { type: Number, write: true } })], c8.prototype, "cols", void 0), e2([y2({ json: { name: "type", type: Number, write: true } })], c8.prototype, "kernelType", null), e2([y2({ json: { type: [Number], write: true } })], c8.prototype, "kernel", void 0), c8 = i7 = e2([n("esri.layers.support.rasterFunctions.ConvolutionFunctionArguments")], c8);
var l6 = c8;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ConvolutionFunction.js
var p8 = class extends a2 {
  constructor() {
    super(...arguments), this.functionName = "Convolution", this.rasterArgumentNames = ["raster"];
  }
  _bindSourceRasters() {
    const { kernelType: e9, rows: t7, cols: o8, kernel: s7 } = this.functionArguments;
    if (!n5.has(e9))
      return { success: false, error: `convolution-function: the specified kernel type is not supported ${e9}` };
    if (e9 !== t4.None && t7 * o8 !== s7.length)
      return { success: false, error: "convolution-function: the specified rows and cols do not match the length of the kernel" };
    const r8 = this.sourceRasterInfos[0];
    this.outputPixelType = this._getOutputPixelType(r8.pixelType);
    const n12 = r8.clone();
    n12.pixelType = this.outputPixelType;
    const c23 = [t4.None, t4.Sharpen, t4.Sharpen2, t4.Sharpening3x3, t4.Sharpening5x5];
    return "u8" === this.outputPixelType || c23.includes(e9) || (n12.statistics = null, n12.histograms = null), this.rasterInfo = n12, { success: true };
  }
  _processPixels(e9) {
    var _a;
    const o8 = (_a = e9.pixelBlocks) == null ? void 0 : _a[0];
    if (t(o8) || this.functionArguments.kernelType === t4.None)
      return o8;
    let { kernel: s7, rows: r8, cols: n12 } = this.functionArguments;
    const i16 = s7.reduce((e10, t7) => e10 + t7);
    return 0 !== i16 && 1 !== i16 && (s7 = s7.map((e10) => e10 / i16)), h3(o8, { kernel: s7, rows: r8, cols: n12, outputPixelType: this.outputPixelType });
  }
};
e2([y2({ json: { write: true, name: "rasterFunction" } })], p8.prototype, "functionName", void 0), e2([y2({ type: l6, json: { write: true, name: "rasterFunctionArguments" } })], p8.prototype, "functionArguments", void 0), e2([y2()], p8.prototype, "rasterArgumentNames", void 0), p8 = e2([n("esri.layers.support.rasterFunctions.ConvolutionFunction")], p8);
var l7 = p8;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ExtractBandFunctionArguments.js
var i8;
var n6 = i8 = class extends p2 {
  constructor() {
    super(...arguments), this.bandIDs = [], this.missingBandAction = o2.bestMatch;
  }
  clone() {
    return new i8({ bandIDs: [...this.bandIDs], missingBandAction: this.missingBandAction });
  }
};
e2([y2({ json: { write: true } })], n6.prototype, "bandIDs", void 0), e2([y2({ json: { write: true } })], n6.prototype, "missingBandAction", void 0), n6 = i8 = e2([n("esri.layers.support.rasterFunctions.ExtractBandFunctionArguments")], n6);
var c9 = n6;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ExtractBandFunction.js
var c10 = class extends a2 {
  constructor() {
    super(...arguments), this.functionName = "ExtractBand", this.functionArguments = null, this.rasterArgumentNames = ["raster"];
  }
  _bindSourceRasters() {
    const { sourceRasterInfos: t7 } = this, r8 = t7[0], { bandCount: e9 } = r8, { bandIDs: o8, missingBandAction: n12 } = this.functionArguments;
    if (n12 === o2.fail && o8.some((t8) => t8 < 0 || t8 >= e9))
      return { success: false, error: "extract-band-function: invalid bandIDs" };
    this.outputPixelType = this._getOutputPixelType("f32");
    const i16 = r8.clone();
    i16.pixelType = this.outputPixelType;
    const { statistics: c23, histograms: u11 } = i16;
    return r(c23) && c23.length && (i16.statistics = o8.map((t8) => c23[t8] || c23[c23.length - 1])), r(u11) && u11.length && (i16.histograms = o8.map((t8) => u11[t8] || u11[u11.length - 1])), this.rasterInfo = i16, { success: true };
  }
  _processPixels(t7) {
    var _a;
    const s7 = (_a = t7.pixelBlocks) == null ? void 0 : _a[0];
    if (t(s7))
      return null;
    const e9 = s7.pixels.length, o8 = this.functionArguments.bandIDs.map((t8) => t8 >= e9 ? e9 - 1 : t8);
    return s7.extractBands(o8);
  }
};
e2([y2({ json: { write: true, name: "rasterFunction" } })], c10.prototype, "functionName", void 0), e2([y2({ type: c9, json: { write: true, name: "rasterFunctionArguments" } })], c10.prototype, "functionArguments", void 0), e2([y2()], c10.prototype, "rasterArgumentNames", void 0), c10 = e2([n("esri.layers.support.rasterFunctions.ExtractBandFunction")], c10);
var u5 = c10;

// node_modules/@arcgis/core/layers/support/rasterFunctions/LocalFunctionArguments.js
var a8;
var i9 = a8 = class extends p2 {
  constructor() {
    super(...arguments), this.rasters = [], this.processAsMultiband = false;
  }
  writeRasters(r8, s7) {
    s7.rasters = r8.map((r9) => "number" == typeof r9 || "string" == typeof r9 ? r9 : r9.toJSON());
  }
  clone() {
    return new a8({ method: this.operation, processAsMultiband: this.processAsMultiband, rasters: y(this.rasters) });
  }
};
e2([y2({ json: { write: true } })], i9.prototype, "operation", void 0), e2([y2({ json: { write: true } })], i9.prototype, "rasters", void 0), e2([r2("rasters")], i9.prototype, "writeRasters", null), e2([y2({ json: { write: true } })], i9.prototype, "processAsMultiband", void 0), i9 = a8 = e2([n("esri.layers.support.rasterFunctions.LocalFunctionArguments")], i9);
var c11 = i9;

// node_modules/@arcgis/core/layers/support/rasterFunctions/localUtils.js
var o6;
!function(t7) {
  t7[t7.Plus = 1] = "Plus", t7[t7.Minus = 2] = "Minus", t7[t7.Times = 3] = "Times", t7[t7.SquareRoot = 4] = "SquareRoot", t7[t7.Power = 5] = "Power", t7[t7.ACos = 6] = "ACos", t7[t7.ASin = 7] = "ASin", t7[t7.ATan = 8] = "ATan", t7[t7.ATanH = 9] = "ATanH", t7[t7.Abs = 10] = "Abs", t7[t7.BitwiseAnd = 11] = "BitwiseAnd", t7[t7.BitwiseLeftShift = 12] = "BitwiseLeftShift", t7[t7.BitwiseNot = 13] = "BitwiseNot", t7[t7.BitwiseOr = 14] = "BitwiseOr", t7[t7.BitwiseRightShift = 15] = "BitwiseRightShift", t7[t7.BitwiseXOr = 16] = "BitwiseXOr", t7[t7.BooleanAnd = 17] = "BooleanAnd", t7[t7.BooleanNot = 18] = "BooleanNot", t7[t7.BooleanOr = 19] = "BooleanOr", t7[t7.BooleanXOr = 20] = "BooleanXOr", t7[t7.Cos = 21] = "Cos", t7[t7.CosH = 22] = "CosH", t7[t7.Divide = 23] = "Divide", t7[t7.EqualTo = 24] = "EqualTo", t7[t7.Exp = 25] = "Exp", t7[t7.Exp10 = 26] = "Exp10", t7[t7.Exp2 = 27] = "Exp2", t7[t7.GreaterThan = 28] = "GreaterThan", t7[t7.GreaterThanEqual = 29] = "GreaterThanEqual", t7[t7.Int = 30] = "Int", t7[t7.IsNull = 31] = "IsNull", t7[t7.Float = 32] = "Float", t7[t7.LessThan = 33] = "LessThan", t7[t7.LessThanEqual = 34] = "LessThanEqual", t7[t7.Ln = 35] = "Ln", t7[t7.Log10 = 36] = "Log10", t7[t7.Log2 = 37] = "Log2", t7[t7.Majority = 38] = "Majority", t7[t7.Max = 39] = "Max", t7[t7.Mean = 40] = "Mean", t7[t7.Med = 41] = "Med", t7[t7.Min = 42] = "Min", t7[t7.Minority = 43] = "Minority", t7[t7.Mod = 44] = "Mod", t7[t7.Negate = 45] = "Negate", t7[t7.NotEqual = 46] = "NotEqual", t7[t7.Range = 47] = "Range", t7[t7.RoundDown = 48] = "RoundDown", t7[t7.RoundUp = 49] = "RoundUp", t7[t7.SetNull = 50] = "SetNull", t7[t7.Sin = 51] = "Sin", t7[t7.SinH = 52] = "SinH", t7[t7.Square = 53] = "Square", t7[t7.Std = 54] = "Std", t7[t7.Sum = 55] = "Sum", t7[t7.Tan = 56] = "Tan", t7[t7.TanH = 57] = "TanH", t7[t7.Variety = 58] = "Variety", t7[t7.ACosH = 59] = "ACosH", t7[t7.ASinH = 60] = "ASinH", t7[t7.ATan2 = 61] = "ATan2", t7[t7.FloatDivide = 64] = "FloatDivide", t7[t7.FloorDivide = 65] = "FloorDivide", t7[t7.MajorityIgnoreNoData = 66] = "MajorityIgnoreNoData", t7[t7.MaxIgnoreNoData = 67] = "MaxIgnoreNoData", t7[t7.MeanIgnoreNoData = 68] = "MeanIgnoreNoData", t7[t7.MedIgnoreNoData = 69] = "MedIgnoreNoData", t7[t7.MinIgnoreNoData = 70] = "MinIgnoreNoData", t7[t7.MinorityIgnoreNoData = 71] = "MinorityIgnoreNoData", t7[t7.RangeIgnoreNoData = 72] = "RangeIgnoreNoData", t7[t7.StdIgnoreNoData = 73] = "StdIgnoreNoData", t7[t7.SumIgnoreNoData = 74] = "SumIgnoreNoData", t7[t7.VarietyIgnoreNoData = 75] = "VarietyIgnoreNoData", t7[t7.Con = 76] = "Con";
}(o6 || (o6 = {}));
function a9(t7) {
  const n12 = t7.map((t8) => t8.mask).filter((t8) => r(t8));
  if (0 === n12.length)
    return null;
  const o8 = n12[0].length, r8 = new Uint8Array(o8);
  if (1 === n12.length)
    return r8.set(n12[0]), r8;
  let a19, s7 = n12[0];
  for (let e9 = 1; e9 < n12.length; e9++) {
    a19 = n12[e9];
    for (let t8 = 0; t8 < o8; t8++)
      r8[t8] = s7[t8] | a19[t8];
    s7 = a19;
  }
  return r8;
}
function s6(t7, e9, o8) {
  const [r8, a19] = t7, s7 = r8.length, l13 = g.createEmptyBand(o8, s7);
  for (let n12 = 0; n12 < s7; n12++)
    e9 && !e9[n12] || (l13[n12] = r8[n12] + a19[n12]);
  return l13;
}
function l8(t7, e9, o8) {
  const [r8] = t7, a19 = r8.length, s7 = g.createEmptyBand("f32", a19);
  return s7.set(r8), s7;
}
function i10(t7, e9, o8) {
  const [r8, a19] = t7, s7 = r8.length, l13 = g.createEmptyBand(o8, s7);
  for (let n12 = 0; n12 < s7; n12++)
    e9 && !e9[n12] || (l13[n12] = r8[n12] - a19[n12]);
  return l13;
}
function c12(t7, e9, o8) {
  const [r8, a19] = t7, s7 = r8.length, l13 = g.createEmptyBand(o8, s7);
  for (let n12 = 0; n12 < s7; n12++)
    e9 && !e9[n12] || (l13[n12] = r8[n12] * a19[n12]);
  return l13;
}
function u6(t7, e9, o8) {
  const [r8, a19] = t7, s7 = r8.length, l13 = g.createEmptyBand(o8, s7);
  for (let n12 = 0; n12 < s7; n12++)
    e9 && !e9[n12] || (l13[n12] = 0 === a19[n12] ? 0 : r8[n12] / a19[n12]);
  return l13;
}
function f2(t7, e9, n12) {
  return u6(t7, e9, "f32");
}
function h4(t7, e9, o8) {
  const [r8, a19] = t7, s7 = r8.length, l13 = g.createEmptyBand(o8, s7);
  for (let n12 = 0; n12 < s7; n12++)
    e9 && !e9[n12] || (l13[n12] = 0 === a19[n12] ? 0 : Math.floor(r8[n12] / a19[n12]));
  return l13;
}
function g3(t7, e9, o8, r8) {
  const [a19] = t7, s7 = a19.length, l13 = g.createEmptyBand(o8, s7);
  for (let n12 = 0; n12 < s7; n12++)
    e9 && !e9[n12] || (l13[n12] = r8(a19[n12]));
  return l13;
}
function d3(t7, e9, o8, r8) {
  const [a19, s7] = t7, l13 = a19.length, i16 = g.createEmptyBand(o8, l13);
  for (let n12 = 0; n12 < l13; n12++)
    e9 && !e9[n12] || (i16[n12] = r8(a19[n12], s7[n12]));
  return i16;
}
function p9(t7, e9, o8) {
  const [r8, a19] = t7, s7 = r8.length, l13 = g.createEmptyBand(o8, s7);
  for (let n12 = 0; n12 < s7; n12++)
    e9 && !e9[n12] || (l13[n12] = r8[n12] & a19[n12]);
  return l13;
}
function y5(t7, e9, o8) {
  const [r8, a19] = t7, s7 = r8.length, l13 = g.createEmptyBand(o8, s7);
  for (let n12 = 0; n12 < s7; n12++)
    e9 && !e9[n12] || (l13[n12] = r8[n12] << a19[n12]);
  return l13;
}
function B(t7, e9, o8) {
  const [r8] = t7, a19 = r8.length, s7 = g.createEmptyBand(o8, a19);
  for (let n12 = 0; n12 < a19; n12++)
    e9 && !e9[n12] || (s7[n12] = ~r8[n12]);
  return s7;
}
function M(t7, e9, o8) {
  const [r8, a19] = t7, s7 = r8.length, l13 = g.createEmptyBand(o8, s7);
  for (let n12 = 0; n12 < s7; n12++)
    e9 && !e9[n12] || (l13[n12] = r8[n12] | a19[n12]);
  return l13;
}
function m3(t7, e9, o8) {
  const [r8, a19] = t7, s7 = r8.length, l13 = g.createEmptyBand(o8, s7);
  for (let n12 = 0; n12 < s7; n12++)
    e9 && !e9[n12] || (l13[n12] = r8[n12] >> a19[n12]);
  return l13;
}
function E(t7, e9, o8) {
  const [r8, a19] = t7, s7 = r8.length, l13 = g.createEmptyBand(o8, s7);
  for (let n12 = 0; n12 < s7; n12++)
    e9 && !e9[n12] || (l13[n12] = r8[n12] ^ a19[n12]);
  return l13;
}
function N(t7, e9, o8) {
  const [r8, a19] = t7, s7 = r8.length, l13 = g.createEmptyBand(o8, s7);
  for (let n12 = 0; n12 < s7; n12++)
    e9 && !e9[n12] || (l13[n12] = r8[n12] && a19[n12] ? 1 : 0);
  return l13;
}
function w5(t7, e9, o8) {
  const [r8] = t7, a19 = r8.length, s7 = g.createEmptyBand(o8, a19);
  for (let n12 = 0; n12 < a19; n12++)
    e9 && !e9[n12] || (s7[n12] = r8[n12] ? 0 : 1);
  return s7;
}
function D(t7, e9, o8) {
  const [r8, a19] = t7, s7 = r8.length, l13 = g.createEmptyBand(o8, s7);
  for (let n12 = 0; n12 < s7; n12++)
    e9 && !e9[n12] || (l13[n12] = r8[n12] || a19[n12] ? 1 : 0);
  return l13;
}
function S(t7, e9, o8) {
  const [r8, a19] = t7, s7 = r8.length, l13 = g.createEmptyBand(o8, s7);
  for (let n12 = 0; n12 < s7; n12++)
    e9 && !e9[n12] || (l13[n12] = (r8[n12] ? 1 : 0) ^ (a19[n12] ? 1 : 0));
  return l13;
}
function A2(t7, e9, o8) {
  const [r8, a19] = t7, s7 = r8.length, l13 = g.createEmptyBand(o8, s7);
  for (let n12 = 0; n12 < s7; n12++)
    e9 && !e9[n12] || (l13[n12] = r8[n12] === a19[n12] ? 1 : 0);
  return l13;
}
function I(t7, e9, o8, r8) {
  const [a19] = t7, s7 = a19.length, l13 = g.createEmptyBand(o8, s7);
  for (let n12 = 0; n12 < s7; n12++)
    e9 && !e9[n12] || (l13[n12] = r8 ** a19[n12]);
  return l13;
}
function T(t7, e9, n12) {
  return I(t7, e9, n12, 10);
}
function x3(t7, e9, n12) {
  return I(t7, e9, n12, 2);
}
function q(t7, e9, o8) {
  const [r8, a19] = t7, s7 = r8.length, l13 = g.createEmptyBand(o8, s7);
  for (let n12 = 0; n12 < s7; n12++)
    e9 && !e9[n12] || (l13[n12] = r8[n12] > a19[n12] ? 1 : 0);
  return l13;
}
function H(t7, e9, o8) {
  const [r8, a19] = t7, s7 = r8.length, l13 = g.createEmptyBand(o8, s7);
  for (let n12 = 0; n12 < s7; n12++)
    e9 && !e9[n12] || (l13[n12] = r8[n12] >= a19[n12] ? 1 : 0);
  return l13;
}
function L(t7, e9, o8) {
  const [r8, a19] = t7, s7 = r8.length, l13 = g.createEmptyBand(o8, s7);
  for (let n12 = 0; n12 < s7; n12++)
    e9 && !e9[n12] || (l13[n12] = r8[n12] < a19[n12] ? 1 : 0);
  return l13;
}
function R(t7, e9, o8) {
  const [r8, a19] = t7, s7 = r8.length, l13 = g.createEmptyBand(o8, s7);
  for (let n12 = 0; n12 < s7; n12++)
    e9 && !e9[n12] || (l13[n12] = r8[n12] <= a19[n12] ? 1 : 0);
  return l13;
}
function C(t7, e9, o8) {
  const [r8] = t7, a19 = r8.length, s7 = g.createEmptyBand(o8, a19);
  if (!e9)
    return s7;
  for (let n12 = 0; n12 < a19; n12++)
    s7[n12] = e9[n12] ? 0 : 1;
  return s7;
}
function F2(t7, e9, o8) {
  const [r8, a19] = t7, s7 = r8.length, l13 = g.createEmptyBand(o8, s7);
  for (let n12 = 0; n12 < s7; n12++)
    e9 && !e9[n12] || (l13[n12] = r8[n12] % a19[n12]);
  return l13;
}
function O(t7, e9, o8) {
  const [r8] = t7, a19 = r8.length, s7 = g.createEmptyBand(o8, a19);
  for (let n12 = 0; n12 < a19; n12++)
    e9 && !e9[n12] || (s7[n12] = -r8[n12]);
  return s7;
}
function b2(t7, e9, o8) {
  const [r8, a19] = t7, s7 = r8.length, l13 = g.createEmptyBand(o8, s7);
  for (let n12 = 0; n12 < s7; n12++)
    e9 && !e9[n12] || (l13[n12] = r8[n12] === a19[n12] ? 0 : 1);
  return l13;
}
function k3(t7, e9, o8) {
  const [r8, a19] = t7, s7 = r8.length, l13 = g.createEmptyBand(o8, s7), i16 = new Uint8Array(s7);
  for (let n12 = 0; n12 < s7; n12++)
    null != e9 && !e9[n12] || 0 !== r8[n12] || (l13[n12] = a19[n12], i16[n12] = 255);
  return { band: l13, mask: i16 };
}
function v2(t7, e9, o8) {
  const [r8, a19, s7] = t7, l13 = r8.length, i16 = g.createEmptyBand(o8, l13);
  for (let n12 = 0; n12 < l13; n12++)
    e9 && !e9[n12] || (i16[n12] = r8[n12] ? a19[n12] : s7[n12]);
  return i16;
}
function j(t7, e9, o8) {
  const r8 = t7.length;
  if (r8 < 2)
    return t7[0];
  const [a19] = t7, s7 = a19.length, l13 = g.createEmptyBand(o8, s7);
  l13.set(a19);
  for (let n12 = 0; n12 < s7; n12++)
    if (!e9 || e9[n12])
      for (let e10 = 1; e10 < r8; e10++) {
        const o9 = t7[e10];
        l13[n12] < o9[n12] && (l13[n12] = o9[n12]);
      }
  return l13;
}
function P(t7, e9, o8) {
  const r8 = t7.length;
  if (r8 < 2)
    return t7[0];
  const [a19] = t7, s7 = a19.length, l13 = g.createEmptyBand(o8, s7);
  l13.set(a19);
  for (let n12 = 0; n12 < s7; n12++)
    if (!e9 || e9[n12])
      for (let e10 = 1; e10 < r8; e10++) {
        const o9 = t7[e10];
        l13[n12] > o9[n12] && (l13[n12] = o9[n12]);
      }
  return l13;
}
function G(t7, e9, o8) {
  const r8 = t7.length;
  if (r8 < 2)
    return t7[0];
  const [a19] = t7, s7 = a19.length, l13 = g.createEmptyBand(o8, s7);
  l13.set(a19);
  for (let n12 = 0; n12 < s7; n12++)
    if (!e9 || e9[n12]) {
      let e10 = l13[n12];
      for (let o9 = 1; o9 < r8; o9++) {
        const r9 = t7[o9];
        l13[n12] < r9[n12] && (l13[n12] = r9[n12]), e10 > r9[n12] && (e10 = r9[n12]);
      }
      l13[n12] -= e10;
    }
  return l13;
}
function U(t7, e9, o8) {
  const r8 = t7.length;
  if (r8 < 2)
    return t7[0];
  const [a19] = t7, s7 = a19.length, l13 = g.createEmptyBand(o8, s7);
  l13.set(a19);
  for (let n12 = 0; n12 < s7; n12++)
    if (!e9 || e9[n12]) {
      for (let e10 = 1; e10 < r8; e10++) {
        const o9 = t7[e10];
        l13[n12] += o9[n12];
      }
      l13[n12] /= r8;
    }
  return l13;
}
function V(t7, e9, o8) {
  const r8 = t7.length;
  if (r8 < 2)
    return t7[0];
  const [a19] = t7, s7 = a19.length, l13 = g.createEmptyBand(o8, s7);
  l13.set(a19);
  for (let n12 = 0; n12 < s7; n12++)
    if (!e9 || e9[n12])
      for (let e10 = 1; e10 < r8; e10++) {
        const o9 = t7[e10];
        l13[n12] += o9[n12];
      }
  return l13;
}
function X(t7, e9, o8) {
  const r8 = t7.length;
  if (r8 < 2)
    return t7[0];
  const [a19] = t7, s7 = a19.length, l13 = g.createEmptyBand(o8, s7);
  for (let n12 = 0; n12 < s7; n12++)
    if (!e9 || e9[n12]) {
      const e10 = new Float32Array(r8);
      let o9 = 0;
      for (let s8 = 0; s8 < r8; s8++) {
        const r9 = t7[s8];
        o9 += r9[n12], e10[s8] = r9[n12];
      }
      o9 /= r8;
      let a20 = 0;
      for (let t8 = 0; t8 < r8; t8++)
        a20 += (e10[t8] - o9) * e10[t8] - o9;
      l13[n12] = Math.sqrt(a20 / r8 - 1);
    }
  return l13;
}
function z(t7, e9, o8) {
  const r8 = t7.length;
  if (r8 < 2)
    return t7[0];
  const a19 = Math.floor(r8 / 2), [s7] = t7, l13 = s7.length, i16 = g.createEmptyBand(o8, l13), c23 = new Float32Array(r8);
  for (let n12 = 0; n12 < l13; n12++)
    if (!e9 || e9[n12]) {
      for (let e10 = 0; e10 < r8; e10++)
        c23[e10] = t7[e10][n12];
      c23.sort(), i16[n12] = c23[a19];
    }
  return i16;
}
function J(t7, e9, o8) {
  const r8 = t7.length;
  if (r8 < 2)
    return t7[0];
  const [a19] = t7, s7 = a19.length, l13 = g.createEmptyBand(o8, s7), i16 = /* @__PURE__ */ new Map();
  for (let n12 = 0; n12 < s7; n12++)
    if (!e9 || e9[n12]) {
      let e10;
      i16.clear();
      for (let s8 = 0; s8 < r8; s8++)
        e10 = t7[s8][n12], i16.set(e10, i16.has(e10) ? i16.get(e10) + 1 : 1);
      let o9 = 0, a20 = 0;
      for (const t8 of i16.keys())
        o9 = i16.get(t8), o9 > a20 && (a20 = o9, e10 = t8);
      l13[n12] = e10;
    }
  return l13;
}
function K(t7, e9, o8) {
  const r8 = t7.length;
  if (r8 < 2)
    return t7[0];
  const [a19] = t7, s7 = a19.length, l13 = g.createEmptyBand(o8, s7), i16 = /* @__PURE__ */ new Map();
  for (let n12 = 0; n12 < s7; n12++)
    if (!e9 || e9[n12]) {
      let e10;
      i16.clear();
      for (let s8 = 0; s8 < r8; s8++)
        e10 = t7[s8][n12], i16.set(e10, i16.has(e10) ? i16.get(e10) + 1 : 1);
      let o9 = 0, a20 = t7.length;
      for (const t8 of i16.keys())
        o9 = i16.get(t8), o9 < a20 && (a20 = o9, e10 = t8);
      l13[n12] = e10;
    }
  return l13;
}
function Q(t7, e9, o8) {
  const r8 = t7.length;
  if (r8 < 2)
    return t7[0];
  const [a19] = t7, s7 = a19.length, l13 = g.createEmptyBand(o8, s7), i16 = /* @__PURE__ */ new Set();
  for (let n12 = 0; n12 < s7; n12++)
    if (!e9 || e9[n12]) {
      let e10;
      i16.clear();
      for (let o9 = 0; o9 < r8; o9++)
        e10 = t7[o9][n12], i16.add(e10);
      l13[n12] = i16.size;
    }
  return l13;
}
function W(t7, e9, n12) {
  return J(t7, null, n12);
}
function Y(t7, e9, n12) {
  return K(t7, null, n12);
}
function Z(t7, e9, n12) {
  return Q(t7, null, n12);
}
function $(t7, e9, n12) {
  return j(t7, null, n12);
}
function _(t7, e9, n12) {
  return P(t7, null, n12);
}
function tt(t7, e9, n12) {
  return X(t7, null, n12);
}
function et(t7, e9, n12) {
  return V(t7, null, n12);
}
function nt(t7, e9, n12) {
  return U(t7, null, n12);
}
function ot(t7, e9, n12) {
  return z(t7, null, n12);
}
function rt(t7, e9, n12) {
  return G(t7, null, n12);
}
var at = /* @__PURE__ */ new Map();
var st = /* @__PURE__ */ new Map();
var lt = /* @__PURE__ */ new Map();
function it() {
  at.size || (at.set(4, Math.sqrt), at.set(6, Math.acos), at.set(7, Math.asin), at.set(8, Math.atan), at.set(9, Math.atanh), at.set(10, Math.abs), at.set(21, Math.cos), at.set(22, Math.cosh), at.set(25, Math.exp), at.set(30, Math.floor), at.set(35, Math.log), at.set(36, Math.log10), at.set(37, Math.log2), at.set(48, Math.floor), at.set(49, Math.ceil), at.set(51, Math.sin), at.set(52, Math.sinh), at.set(56, Math.tan), at.set(57, Math.tanh), at.set(59, Math.acosh), at.set(60, Math.asinh), at.set(65, Math.floor), st.set(5, Math.pow), st.set(61, Math.atan2), lt.set(1, s6), lt.set(2, i10), lt.set(3, c12), lt.set(11, p9), lt.set(12, y5), lt.set(12, y5), lt.set(13, B), lt.set(14, M), lt.set(15, m3), lt.set(16, E), lt.set(17, N), lt.set(18, w5), lt.set(19, D), lt.set(20, S), lt.set(23, u6), lt.set(24, A2), lt.set(26, T), lt.set(27, x3), lt.set(28, q), lt.set(29, H), lt.set(31, C), lt.set(32, l8), lt.set(33, L), lt.set(34, R), lt.set(44, F2), lt.set(45, O), lt.set(46, b2), lt.set(64, f2), lt.set(65, h4), lt.set(76, v2), lt.set(38, J), lt.set(39, j), lt.set(40, U), lt.set(41, z), lt.set(42, P), lt.set(43, K), lt.set(47, G), lt.set(54, X), lt.set(55, V), lt.set(58, Q), lt.set(66, W), lt.set(67, $), lt.set(68, nt), lt.set(69, ot), lt.set(70, _), lt.set(71, Y), lt.set(72, rt), lt.set(73, tt), lt.set(74, et), lt.set(75, Z));
}
function ct(e9, r8, s7 = {}) {
  it();
  const l13 = e(a9(e9)), { processAsMultiband: i16, outputPixelType: c23 = "f32" } = s7, u11 = i16 ? e9[0].pixels.length : 1, f4 = [];
  let h6;
  for (let t7 = 0; t7 < u11; t7++) {
    const n12 = e9.map((e10) => e10.pixels[t7]);
    let a19;
    if (r8 === o6.SetNull) {
      const t8 = k3(n12, l13, c23);
      a19 = t8.band, h6 = t8.mask;
    } else if (lt.has(r8)) {
      a19 = lt.get(r8)(n12, l13, c23);
    } else
      at.has(r8) ? a19 = g3(n12, l13, c23, at.get(r8)) : st.has(r8) && (a19 = d3(n12, l13, c23, st.get(r8)));
    if (null == a19)
      return null;
    f4.push(a19);
  }
  h6 || r8 === o6.IsNull || (h6 = l13);
  const p14 = e9[0];
  return new g({ width: p14.width, height: p14.height, pixelType: c23, mask: h6, pixels: f4 });
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/LocalFunction.js
var u7 = class extends a2 {
  constructor() {
    super(...arguments), this.functionName = "Local", this.functionArguments = null, this.rasterArgumentNames = ["rasters"];
  }
  _bindSourceRasters() {
    const { sourceRasterInfos: t7 } = this, s7 = t7[0], { bandCount: o8 } = s7, { processAsMultiband: r8 } = this.functionArguments;
    if (r8 && t7.some((t8) => t8.bandCount !== o8))
      return { success: false, error: "local-function: input rasters do not have same band count" };
    this.outputPixelType = this._getOutputPixelType("f32");
    const e9 = s7.clone();
    return e9.pixelType = this.outputPixelType, e9.statistics = null, e9.histograms = null, r8 || (e9.bandCount = 1), this.rasterInfo = e9, { success: true };
  }
  _processPixels(t7) {
    var _a;
    const { pixelBlocks: o8 } = t7;
    return t(o8) || o8.some((t8) => t(t8)) ? null : ct(o8, this.functionArguments.operation, { processAsMultiband: this.functionArguments.processAsMultiband, outputPixelType: (_a = this.outputPixelType) != null ? _a : void 0 });
  }
};
e2([y2({ json: { write: true, name: "rasterFunction" } })], u7.prototype, "functionName", void 0), e2([y2({ type: c11, json: { write: true, name: "rasterFunctionArguments" } })], u7.prototype, "functionArguments", void 0), e2([y2()], u7.prototype, "rasterArgumentNames", void 0), u7 = e2([n("esri.layers.support.rasterFunctions.LocalFunction")], u7);
var c13 = u7;

// node_modules/@arcgis/core/layers/support/rasterFunctions/MaskFunctionArguments.js
var a10;
var n7 = a10 = class extends p2 {
  constructor() {
    super(...arguments), this.includedRanges = null, this.noDataValues = null, this.noDataInterpretation = i.matchAny;
  }
  clone() {
    var _a, _b, _c, _d;
    return new a10({ includedRanges: (_b = (_a = this.includedRanges) == null ? void 0 : _a.slice()) != null ? _b : [], noDataValues: (_d = (_c = this.noDataValues) == null ? void 0 : _c.slice()) != null ? _d : [], noDataInterpretation: this.noDataInterpretation });
  }
};
e2([y2({ json: { write: true } })], n7.prototype, "includedRanges", void 0), e2([y2({ json: { write: true } })], n7.prototype, "noDataValues", void 0), e2([y2({ json: { write: true } })], n7.prototype, "noDataInterpretation", void 0), n7 = a10 = e2([n("esri.layers.support.rasterFunctions.MaskFunctionArguments")], n7);
var i11 = n7;

// node_modules/@arcgis/core/layers/support/rasterFunctions/MaskFunction.js
var p10 = class extends a2 {
  constructor() {
    super(...arguments), this.functionName = "Mask", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.lookup = null;
  }
  _bindSourceRasters() {
    const t7 = this.sourceRasterInfos[0].clone(), { pixelType: s7 } = t7;
    this.outputPixelType = this._getOutputPixelType(s7), t7.pixelType = this.outputPixelType, this.rasterInfo = t7;
    const { includedRanges: e9, noDataValues: o8 } = this.functionArguments;
    return (e9 == null ? void 0 : e9.length) || (o8 == null ? void 0 : o8.length) ? (this.lookup = k(s7, this.functionArguments.includedRanges, this.functionArguments.noDataValues), { success: true }) : { success: false, error: "missing includedRanges or noDataValues argument" };
  }
  _processPixels(t7) {
    var _a;
    const e9 = (_a = t7.pixelBlocks) == null ? void 0 : _a[0];
    if (t(e9))
      return null;
    const { outputPixelType: o8, lookup: r8 } = this, { includedRanges: n12, noDataValues: u11, noDataInterpretation: p14 } = this.functionArguments, c23 = p14 === i.matchAll;
    return y3(e9, { includedRanges: n12, noDataValues: u11, outputPixelType: o8, matchAll: c23, lookup: r8 });
  }
};
e2([y2({ json: { write: true, name: "rasterFunction" } })], p10.prototype, "functionName", void 0), e2([y2({ type: i11, json: { write: true, name: "rasterFunctionArguments" } })], p10.prototype, "functionArguments", void 0), e2([y2()], p10.prototype, "rasterArgumentNames", void 0), e2([y2({ json: { write: true } })], p10.prototype, "lookup", void 0), p10 = e2([n("esri.layers.support.rasterFunctions.MaskFunction")], p10);
var c14 = p10;

// node_modules/@arcgis/core/layers/support/rasterFunctions/NDVIFunctionArguments.js
var t5;
var i12 = t5 = class extends p2 {
  constructor() {
    super(...arguments), this.visibleBandID = 0, this.infraredBandID = 1, this.scaled = true;
  }
  clone() {
    const { visibleBandID: r8, infraredBandID: s7, scaled: e9 } = this;
    return new t5({ visibleBandID: r8, infraredBandID: s7, scaled: e9 });
  }
};
e2([y2({ json: { write: true } })], i12.prototype, "visibleBandID", void 0), e2([y2({ json: { write: true } })], i12.prototype, "infraredBandID", void 0), e2([y2({ json: { write: true } })], i12.prototype, "scaled", void 0), i12 = t5 = e2([n("esri.layers.support.rasterFunctions.NDVIFunctionArguments")], i12);
var a11 = i12;

// node_modules/@arcgis/core/layers/support/rasterFunctions/NDVIFunction.js
var c15 = class extends a2 {
  constructor() {
    super(...arguments), this.functionName = "NDVI", this.functionArguments = null, this.rasterArgumentNames = ["raster"];
  }
  _bindSourceRasters() {
    const { scaled: t7 } = this.functionArguments;
    this.outputPixelType = this._getOutputPixelType(t7 ? "u8" : "f32");
    const s7 = this.sourceRasterInfos[0].clone();
    s7.pixelType = this.outputPixelType, s7.colormap = null, s7.histograms = null;
    const [r8, e9, o8, n12] = t7 ? [0, 200, 100, 10] : [-1, 1, 0, 0.1];
    return s7.statistics = [{ min: r8, max: e9, avg: o8, stddev: n12 }], this.rasterInfo = s7, { success: true };
  }
  _processPixels(t7) {
    var _a;
    const r8 = (_a = t7.pixelBlocks) == null ? void 0 : _a[0];
    if (t(r8))
      return null;
    const { visibleBandID: e9, infraredBandID: n12, scaled: i16 } = this.functionArguments;
    return i2(r8, e9, n12, i16);
  }
};
e2([y2({ json: { write: true, name: "rasterFunction" } })], c15.prototype, "functionName", void 0), e2([y2({ type: a11, json: { write: true, name: "rasterFunctionArguments" } })], c15.prototype, "functionArguments", void 0), e2([y2()], c15.prototype, "rasterArgumentNames", void 0), c15 = e2([n("esri.layers.support.rasterFunctions.NDVIFunction")], c15);
var u8 = c15;

// node_modules/@arcgis/core/layers/support/rasterFunctions/RemapFunctionArguments.js
var r7;
var a12 = r7 = class extends p2 {
  constructor() {
    super(...arguments), this.inputRanges = null, this.outputValues = null, this.noDataRanges = null, this.allowUnmatched = false;
  }
  clone() {
    return new r7({ inputRanges: [...this.inputRanges], outputValues: [...this.outputValues], noDataRanges: [...this.noDataRanges], allowUnmatched: this.allowUnmatched });
  }
};
e2([y2({ json: { write: true } })], a12.prototype, "inputRanges", void 0), e2([y2({ json: { write: true } })], a12.prototype, "outputValues", void 0), e2([y2({ json: { write: true } })], a12.prototype, "noDataRanges", void 0), e2([y2({ json: { write: true } })], a12.prototype, "allowUnmatched", void 0), a12 = r7 = e2([n("esri.layers.support.rasterFunctions.RemapFunctionArguments")], a12);
var n8 = a12;

// node_modules/@arcgis/core/layers/support/rasterFunctions/RemapFunction.js
var l9 = class extends a2 {
  constructor() {
    super(...arguments), this.functionName = "Remap", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.lookup = null;
  }
  _bindSourceRasters() {
    const t7 = this.sourceRasterInfos[0].clone(), { pixelType: o8 } = t7;
    this.outputPixelType = this._getOutputPixelType(o8), t7.pixelType = this.outputPixelType, t7.colormap = null, t7.histograms = null;
    const { statistics: s7 } = t7, { allowUnmatched: r8, outputValues: n12 } = this.functionArguments;
    if (r(s7) && s7.length && !r8) {
      let t8 = n12[0], e9 = t8;
      for (let o9 = 0; o9 < n12.length; o9++)
        t8 = t8 > n12[o9] ? n12[o9] : t8, e9 = e9 > n12[o9] ? e9 : n12[o9];
      for (let o9 = 0; o9 < s7.length; o9++)
        s7[o9] = { ...s7[o9], min: t8, max: e9 };
    }
    return this.rasterInfo = t7, this.lookup = r8 ? null : w3(o8, this.functionArguments.inputRanges, n12), { success: true };
  }
  _processPixels(t7) {
    var _a;
    const e9 = (_a = t7.pixelBlocks) == null ? void 0 : _a[0];
    if (t(e9))
      return null;
    const { lookup: s7, outputPixelType: r8 } = this;
    if (s7)
      return c2(e9, { lut: [s7.lut], offset: s7.offset, outputPixelType: r8 });
    const { inputRanges: n12, outputValues: u11, noDataRanges: a19, allowUnmatched: l13 } = this.functionArguments;
    return x(e9, { inputRanges: n12, outputValues: u11, noDataRanges: a19, allowUnmatched: l13, outputPixelType: r8 });
  }
};
e2([y2({ json: { write: true, name: "rasterFunction" } })], l9.prototype, "functionName", void 0), e2([y2({ type: n8, json: { write: true, name: "rasterFunctionArguments" } })], l9.prototype, "functionArguments", void 0), e2([y2()], l9.prototype, "rasterArgumentNames", void 0), e2([y2({ json: { write: true } })], l9.prototype, "lookup", void 0), l9 = e2([n("esri.layers.support.rasterFunctions.RemapFunction")], l9);
var c16 = l9;

// node_modules/@arcgis/core/layers/support/rasterFunctions/SlopeFunctionArguments.js
var i13;
var c17 = new s3({ 0: "degree", 1: "percent-rise", 2: "adjusted" }, { useNumericKeys: true });
var a13 = i13 = class extends p2 {
  constructor() {
    super(...arguments), this.slopeType = "degree", this.zFactor = 1, this.pixelSizePower = 0.664, this.pixelSizeFactor = 0.024;
  }
  clone() {
    return new i13({ slopeType: this.slopeType, zFactor: this.zFactor, pixelSizePower: this.pixelSizePower, pixelSizeFactor: this.pixelSizeFactor, raster: this.raster });
  }
};
e2([r3(c17)], a13.prototype, "slopeType", void 0), e2([y2({ type: Number, json: { write: true } })], a13.prototype, "zFactor", void 0), e2([y2({ type: Number, json: { name: "psPower", write: true } })], a13.prototype, "pixelSizePower", void 0), e2([y2({ type: Number, json: { name: "psFactor", write: true } })], a13.prototype, "pixelSizeFactor", void 0), a13 = i13 = e2([n("esri.layers.support.rasterFunctions.SlopeFunctionArguments")], a13);
var n9 = a13;

// node_modules/@arcgis/core/layers/support/rasterFunctions/SlopeFunction.js
var p11 = class extends a2 {
  constructor() {
    super(...arguments), this.functionName = "Slope", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isGCS = false;
  }
  _bindSourceRasters() {
    this.outputPixelType = this._getOutputPixelType("f32");
    const t7 = this.sourceRasterInfos[0].clone();
    return t7.pixelType = this.outputPixelType, t7.statistics = null, t7.histograms = null, this.rasterInfo = t7, this.isGCS = t7.spatialReference.isGeographic, { success: true };
  }
  _processPixels(t7) {
    var _a;
    const s7 = (_a = t7.pixelBlocks) == null ? void 0 : _a[0];
    if (t(s7))
      return null;
    const { zFactor: r8, slopeType: o8, pixelSizePower: i16, pixelSizeFactor: p14 } = this.functionArguments, { isGCS: c23 } = this, { extent: u11 } = t7, a19 = u11 ? { x: u11.width / s7.width, y: u11.height / s7.height } : { x: 1, y: 1 };
    return a(s7, { zFactor: r8, slopeType: o8, pixelSizePower: i16, pixelSizeFactor: p14, isGCS: c23, resolution: a19 });
  }
};
e2([y2({ json: { write: true, name: "rasterFunction" } })], p11.prototype, "functionName", void 0), e2([y2({ type: n9, json: { write: true, name: "rasterFunctionArguments" } })], p11.prototype, "functionArguments", void 0), e2([y2()], p11.prototype, "rasterArgumentNames", void 0), e2([y2({ json: { write: true } })], p11.prototype, "isGCS", void 0), p11 = e2([n("esri.layers.support.rasterFunctions.SlopeFunction")], p11);
var c18 = p11;

// node_modules/@arcgis/core/layers/support/rasterFunctions/StatisticsHistogramsFunctionArguments.js
var e6;
var c19 = e6 = class extends p2 {
  constructor() {
    super(...arguments), this.statistics = null, this.histograms = null;
  }
  clone() {
    return new e6({ statistics: y(this.statistics), histograms: y(this.histograms) });
  }
};
e2([y2({ json: { write: true } })], c19.prototype, "statistics", void 0), e2([y2({ json: { write: true } })], c19.prototype, "histograms", void 0), c19 = e6 = e2([n("esri.layers.support.rasterFunctions.StatisticsHistogramsFunctionArguments")], c19);
var a14 = c19;

// node_modules/@arcgis/core/layers/support/rasterFunctions/StatisticsHistogramsFunction.js
var i14 = class extends a2 {
  constructor() {
    super(...arguments), this.functionName = "StatisticsHistograms", this.functionArguments = null, this.rasterArgumentNames = ["raster"];
  }
  _bindSourceRasters() {
    const t7 = this.sourceRasterInfos[0];
    this.outputPixelType = this._getOutputPixelType("u8");
    const s7 = t7.clone(), { statistics: r8, histograms: o8 } = this.functionArguments;
    return s7.histograms = o8, r8 && (s7.statistics = r8.map(([t8, s8, r9, o9]) => ({ min: t8, max: s8, avg: r9, stddev: o9 }))), this.rasterInfo = s7, { success: true };
  }
  _processPixels(t7) {
    var _a;
    return (_a = t7.pixelBlocks) == null ? void 0 : _a[0];
  }
};
e2([y2({ json: { write: true, name: "rasterFunction" } })], i14.prototype, "functionName", void 0), e2([y2({ type: a14, json: { write: true, name: "rasterFunctionArguments" } })], i14.prototype, "functionArguments", void 0), e2([y2()], i14.prototype, "rasterArgumentNames", void 0), e2([y2({ json: { write: true } })], i14.prototype, "indexedColormap", void 0), i14 = e2([n("esri.layers.support.rasterFunctions.StatisticsHistogramsFunction")], i14);
var n10 = i14;

// node_modules/@arcgis/core/layers/support/rasterFunctions/StretchFunctionArguments.js
var n11;
var p12 = new s3({ 0: "none", 3: "standard-deviation", 4: "histogram-equalization", 5: "min-max", 6: "percent-clip", 7: "sigmoid" }, { useNumericKeys: true });
var c20 = n11 = class extends p2 {
  constructor() {
    super(...arguments), this.computeGamma = false, this.dynamicRangeAdjustment = false, this.gamma = [], this.histograms = null, this.statistics = null, this.stretchType = "none", this.useGamma = false;
  }
  writeStatistics(t7, e9, o8) {
    (t7 == null ? void 0 : t7.length) && (Array.isArray(t7[0]) || (t7 = t7.map((t8) => [t8.min, t8.max, t8.avg, t8.stddev])), e9[o8] = t7);
  }
  clone() {
    return new n11({ stretchType: this.stretchType, outputMin: this.outputMin, outputMax: this.outputMax, useGamma: this.useGamma, computeGamma: this.computeGamma, statistics: y(this.statistics), gamma: y(this.gamma), sigmoidStrengthLevel: this.sigmoidStrengthLevel, numberOfStandardDeviations: this.numberOfStandardDeviations, minPercent: this.minPercent, maxPercent: this.maxPercent, histograms: y(this.histograms), dynamicRangeAdjustment: this.dynamicRangeAdjustment, raster: this.raster });
  }
};
e2([y2({ type: Boolean, json: { write: true } })], c20.prototype, "computeGamma", void 0), e2([y2({ type: Boolean, json: { name: "dra", write: true } })], c20.prototype, "dynamicRangeAdjustment", void 0), e2([y2({ type: [Number], json: { write: true } })], c20.prototype, "gamma", void 0), e2([y2()], c20.prototype, "histograms", void 0), e2([y2({ type: Number, json: { write: true } })], c20.prototype, "maxPercent", void 0), e2([y2({ type: Number, json: { write: true } })], c20.prototype, "minPercent", void 0), e2([y2({ type: Number, json: { write: true } })], c20.prototype, "numberOfStandardDeviations", void 0), e2([y2({ type: Number, json: { name: "max", write: true } })], c20.prototype, "outputMax", void 0), e2([y2({ type: Number, json: { name: "min", write: true } })], c20.prototype, "outputMin", void 0), e2([y2({ type: Number, json: { write: true } })], c20.prototype, "sigmoidStrengthLevel", void 0), e2([y2({ json: { type: [[Number]], write: true } })], c20.prototype, "statistics", void 0), e2([r2("statistics")], c20.prototype, "writeStatistics", null), e2([r3(p12)], c20.prototype, "stretchType", void 0), e2([y2({ type: Boolean, json: { write: true } })], c20.prototype, "useGamma", void 0), c20 = n11 = e2([n("esri.layers.support.rasterFunctions.StretchFunctionArguments")], c20);
var u9 = c20;

// node_modules/@arcgis/core/layers/support/rasterFunctions/StretchFunction.js
var a15 = class extends a2 {
  constructor() {
    super(...arguments), this.functionName = "Stretch", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.lookup = null, this.cutOffs = null;
  }
  _bindSourceRasters() {
    this.lookup = null, this.cutOffs = null;
    const t7 = this.sourceRasterInfos[0], { pixelType: s7 } = t7, { functionArguments: e9 } = this, { dynamicRangeAdjustment: o8, gamma: r8, useGamma: i16 } = e9;
    if (!o8 && ["u8", "u16", "s8", "s16"].includes(s7)) {
      const o9 = x2(e9.toJSON(), { rasterInfo: t7 });
      this.lookup = u({ pixelType: s7, ...o9, gamma: i16 ? r8 : null });
    } else
      o8 && (this.cutOffs = x2(e9.toJSON(), { rasterInfo: t7 }));
    this.outputPixelType = this._getOutputPixelType(s7);
    const u11 = t7.clone();
    return u11.pixelType = this.outputPixelType, u11.statistics = null, u11.histograms = null, "u8" === this.outputPixelType && (u11.keyProperties.DataType = "processed"), this.rasterInfo = u11, { success: true };
  }
  _processPixels(t7) {
    var _a;
    const e9 = (_a = t7.pixelBlocks) == null ? void 0 : _a[0];
    if (t(e9))
      return e9;
    const { lookup: o8 } = this;
    if (o8)
      return c2(e9, { ...o8, outputPixelType: this.rasterInfo.pixelType });
    const { functionArguments: r8 } = this, u11 = this.cutOffs || x2(r8.toJSON(), { rasterInfo: this.sourceRasterInfos[0], pixelBlock: e9 }), p14 = r8.useGamma ? r8.gamma : null;
    return d(e9, { ...u11, gamma: p14, outputPixelType: this.outputPixelType });
  }
};
e2([y2({ json: { write: true, name: "rasterFunction" } })], a15.prototype, "functionName", void 0), e2([y2({ type: u9, json: { write: true, name: "rasterFunctionArguments" } })], a15.prototype, "functionArguments", void 0), e2([y2()], a15.prototype, "rasterArgumentNames", void 0), e2([y2({ json: { write: true } })], a15.prototype, "lookup", void 0), e2([y2({ json: { write: true } })], a15.prototype, "cutOffs", void 0), a15 = e2([n("esri.layers.support.rasterFunctions.StretchFunction")], a15);
var l10 = a15;

// node_modules/@arcgis/core/layers/support/rasterFunctions/rasterFunctionHelper.js
var d4 = /* @__PURE__ */ new Map();
function l11(r8, e9) {
  if ("rasterFunction" in r8)
    return h5(r8, e9 != null ? e9 : {});
  throw new s("raster-function-helper", "unsupported raster function json.");
}
function N2(t7, r8) {
  return "rasters" === r8[0] && Array.isArray(t7.rasters) ? t7.rasters : r8.map((r9) => t7[r9]);
}
function h5(r8, e9) {
  var _a, _b;
  const { rasterFunction: s7, rasterFunctionArguments: n12 } = r8, o8 = (_a = r8.outputPixelType) == null ? void 0 : _a.toLowerCase();
  if (null == s7 || !d4.has(s7))
    throw new s("raster-function-helper", `unsupported raster function: ${s7}`);
  const a19 = d4.get(s7), c23 = ("function" == typeof a19.ctor ? a19.ctor : a19.ctor.default).fromJSON({ ...r8, outputPixelType: o8 }), { rasterArgumentNames: i16 } = c23, u11 = [], m5 = N2(n12, i16), p14 = "rasters" === i16[0], f4 = [];
  for (let t7 = 0; t7 < m5.length; t7++) {
    const r9 = m5[t7];
    let s8;
    null == r9 || "string" == typeof r9 && r9.startsWith("$") ? u11.push(e9 == null ? void 0 : e9.raster) : "string" == typeof r9 ? e9[r9] && u11.push(e9[r9]) : "number" != typeof r9 && "rasterFunction" in r9 && (s8 = h5(r9, e9), p14 || (c23.functionArguments[i16[t7]] = s8), u11.push(s8)), p14 && f4.push(s8 != null ? s8 : r9);
  }
  if (p14 && (c23.functionArguments.rasters = f4), e9) {
    c23.sourceRasters = u11;
    const t7 = (_b = e9.raster) == null ? void 0 : _b.url;
    t7 && (c23.mainPrimaryRasterId = t7);
  }
  return c23;
}
d4.set("Aspect", { desc: "Aspect Function", ctor: p3, rasterArgumentNames: ["raster"] }), d4.set("BandArithmetic", { desc: "Band Arithmetic Function", ctor: a5, rasterArgumentNames: ["raster"] }), d4.set("Colormap", { desc: "Colormap Function", ctor: p6, rasterArgumentNames: ["raster"] }), d4.set("CompositeBand", { desc: "CompositeBand Function", ctor: u4, rasterArgumentNames: ["rasters"] }), d4.set("Convolution", { desc: "Convolution Function", ctor: l7, rasterArgumentNames: ["raster"] }), d4.set("ExtractBand", { desc: "ExtractBand Function", ctor: u5, rasterArgumentNames: ["raster"] }), d4.set("Local", { desc: "Local Function", ctor: c13, rasterArgumentNames: ["rasters"] }), d4.set("Mask", { desc: "Mask Function", ctor: c14, rasterArgumentNames: ["raster"] }), d4.set("NDVI", { desc: "NDVI Function", ctor: u8, rasterArgumentNames: ["raster"] }), d4.set("Remap", { desc: "Remap Function", ctor: c16, rasterArgumentNames: ["raster"] }), d4.set("Slope", { desc: "Slope Function", ctor: c18, rasterArgumentNames: ["raster"] }), d4.set("StatisticsHistograms", { desc: "Statistics Histograms Function", ctor: n10, rasterArgumentNames: ["raster"] }), d4.set("Stretch", { desc: "Stretch Function", ctor: l10, rasterArgumentNames: ["raster"] });

// node_modules/@arcgis/core/layers/support/rasterTransforms/BaseRasterTransform.js
var t6 = class extends l {
  get affectsPixelSize() {
    return false;
  }
  forwardTransform(r8) {
    return r8;
  }
  inverseTransform(r8) {
    return r8;
  }
};
e2([y2()], t6.prototype, "affectsPixelSize", null), e2([y2({ json: { write: true } })], t6.prototype, "spatialReference", void 0), t6 = e2([n("esri.layers.support.rasterTransforms.BaseRasterTransform")], t6);
var a16 = t6;

// node_modules/@arcgis/core/layers/support/rasterTransforms/GCSShiftTransform.js
var a17 = class extends a16 {
  constructor() {
    super(...arguments), this.type = "gcs-shift", this.tolerance = 1e-8;
  }
  forwardTransform(r8) {
    return "point" === (r8 = r8.clone()).type ? (r8.x > 180 + this.tolerance && (r8.x -= 360), r8) : (r8.xmin >= 180 - this.tolerance ? (r8.xmax -= 360, r8.xmin -= 360) : r8.xmax > 180 + this.tolerance && (r8.xmin = -180, r8.xmax = 180), r8);
  }
  inverseTransform(r8) {
    return "point" === (r8 = r8.clone()).type ? (r8.x < -this.tolerance && (r8.x += 360), r8) : (r8.xmin < -this.tolerance && (r8.xmin += 360, r8.xmax += 360), r8);
  }
};
e2([r3({ GCSShiftXform: "gcs-shift" })], a17.prototype, "type", void 0), e2([y2()], a17.prototype, "tolerance", void 0), a17 = e2([n("esri.layers.support.rasterTransforms.GCSShiftTransform")], a17);
var c21 = a17;

// node_modules/@arcgis/core/layers/support/rasterTransforms/IdentityTransform.js
var e7 = class extends a16 {
  constructor() {
    super(...arguments), this.type = "identity";
  }
};
e2([r3({ IdentityXform: "identity" })], e7.prototype, "type", void 0), e7 = e2([n("esri.layers.support.rasterTransforms.IdentityTransform")], e7);
var p13 = e7;

// node_modules/@arcgis/core/layers/support/rasterTransforms/PolynomialTransform.js
function l12(e9, r8, o8) {
  const { x: t7, y: s7 } = r8;
  if (o8 < 2) {
    return { x: e9[0] + t7 * e9[2] + s7 * e9[4], y: e9[1] + t7 * e9[3] + s7 * e9[5] };
  }
  if (2 === o8) {
    const r9 = t7 * t7, o9 = s7 * s7, n13 = t7 * s7;
    return { x: e9[0] + t7 * e9[2] + s7 * e9[4] + r9 * e9[6] + n13 * e9[8] + o9 * e9[10], y: e9[1] + t7 * e9[3] + s7 * e9[5] + r9 * e9[7] + n13 * e9[9] + o9 * e9[11] };
  }
  const n12 = t7 * t7, i16 = s7 * s7, f4 = t7 * s7, p14 = n12 * t7, l13 = n12 * s7, a19 = t7 * i16, c23 = s7 * i16;
  return { x: e9[0] + t7 * e9[2] + s7 * e9[4] + n12 * e9[6] + f4 * e9[8] + i16 * e9[10] + p14 * e9[12] + l13 * e9[14] + a19 * e9[16] + c23 * e9[18], y: e9[1] + t7 * e9[3] + s7 * e9[5] + n12 * e9[7] + f4 * e9[9] + i16 * e9[11] + p14 * e9[13] + l13 * e9[15] + a19 * e9[17] + c23 * e9[19] };
}
function a18(e9, r8, o8) {
  const { xmin: t7, ymin: s7, xmax: n12, ymax: i16, spatialReference: f4 } = r8;
  let a19 = [];
  if (o8 < 2)
    a19.push({ x: t7, y: i16 }), a19.push({ x: n12, y: i16 }), a19.push({ x: t7, y: s7 }), a19.push({ x: n12, y: s7 });
  else {
    let e10 = 10;
    for (let r9 = 0; r9 < e10; r9++)
      a19.push({ x: t7, y: s7 + (i16 - s7) * r9 / (e10 - 1) }), a19.push({ x: n12, y: s7 + (i16 - s7) * r9 / (e10 - 1) });
    e10 = 8;
    for (let r9 = 1; r9 <= e10; r9++)
      a19.push({ x: t7 + (n12 - t7) * r9 / e10, y: s7 }), a19.push({ x: t7 + (n12 - t7) * r9 / e10, y: i16 });
  }
  a19 = a19.map((r9) => l12(e9, r9, o8));
  const c23 = a19.map((e10) => e10.x), u11 = a19.map((e10) => e10.y);
  return new w2({ xmin: Math.min.apply(null, c23), xmax: Math.max.apply(null, c23), ymin: Math.min.apply(null, u11), ymax: Math.max.apply(null, u11), spatialReference: f4 });
}
function c22(e9) {
  const [r8, o8, t7, s7, n12, i16] = e9, f4 = t7 * i16 - n12 * s7, p14 = n12 * s7 - t7 * i16;
  return [(n12 * o8 - r8 * i16) / f4, (t7 * o8 - r8 * s7) / p14, i16 / f4, s7 / p14, -n12 / f4, -t7 / p14];
}
var u10 = class extends a16 {
  constructor() {
    super(...arguments), this.polynomialOrder = 1, this.type = "polynomial";
  }
  readForwardCoefficients(e9, r8) {
    const { coeffX: o8, coeffY: t7 } = r8;
    if (!(o8 == null ? void 0 : o8.length) || !(t7 == null ? void 0 : t7.length) || o8.length !== t7.length)
      return null;
    const s7 = [];
    for (let n12 = 0; n12 < o8.length; n12++)
      s7.push(o8[n12]), s7.push(t7[n12]);
    return s7;
  }
  writeForwardCoefficients(e9, r8, o8) {
    const t7 = [], s7 = [];
    for (let n12 = 0; n12 < (e9 == null ? void 0 : e9.length); n12++)
      n12 % 2 == 0 ? t7.push(e9[n12]) : s7.push(e9[n12]);
    r8.coeffX = t7, r8.coeffY = s7;
  }
  get inverseCoefficients() {
    let e9 = this._get("inverseCoefficients");
    const r8 = this._get("forwardCoefficients");
    return !e9 && r8 && this.polynomialOrder < 2 && (e9 = c22(r8)), e9;
  }
  set inverseCoefficients(e9) {
    this._set("inverseCoefficients", e9);
  }
  readInverseCoefficients(e9, r8) {
    const { inverseCoeffX: o8, inverseCoeffY: t7 } = r8;
    if (!(o8 == null ? void 0 : o8.length) || !(t7 == null ? void 0 : t7.length) || o8.length !== t7.length)
      return null;
    const s7 = [];
    for (let n12 = 0; n12 < o8.length; n12++)
      s7.push(o8[n12]), s7.push(t7[n12]);
    return s7;
  }
  writeInverseCoefficients(e9, r8, o8) {
    const t7 = [], s7 = [];
    for (let n12 = 0; n12 < (e9 == null ? void 0 : e9.length); n12++)
      n12 % 2 == 0 ? t7.push(e9[n12]) : s7.push(e9[n12]);
    r8.inverseCoeffX = t7, r8.inverseCoeffY = s7;
  }
  get affectsPixelSize() {
    return this.polynomialOrder > 0;
  }
  forwardTransform(e9) {
    if ("point" === e9.type) {
      const r8 = l12(this.forwardCoefficients, e9, this.polynomialOrder);
      return new w({ x: r8.x, y: r8.y, spatialReference: e9.spatialReference });
    }
    return a18(this.forwardCoefficients, e9, this.polynomialOrder);
  }
  inverseTransform(e9) {
    if ("point" === e9.type) {
      const r8 = l12(this.inverseCoefficients, e9, this.polynomialOrder);
      return new w({ x: r8.x, y: r8.y, spatialReference: e9.spatialReference });
    }
    return a18(this.inverseCoefficients, e9, this.polynomialOrder);
  }
};
e2([y2({ json: { write: true } })], u10.prototype, "polynomialOrder", void 0), e2([y2()], u10.prototype, "forwardCoefficients", void 0), e2([o("forwardCoefficients", ["coeffX", "coeffY"])], u10.prototype, "readForwardCoefficients", null), e2([r2("forwardCoefficients")], u10.prototype, "writeForwardCoefficients", null), e2([y2({ json: { write: true } })], u10.prototype, "inverseCoefficients", null), e2([o("inverseCoefficients", ["inverseCoeffX", "inverseCoeffY"])], u10.prototype, "readInverseCoefficients", null), e2([r2("inverseCoefficients")], u10.prototype, "writeInverseCoefficients", null), e2([y2()], u10.prototype, "affectsPixelSize", null), e2([r3({ PolynomialXform: "polynomial" })], u10.prototype, "type", void 0), u10 = e2([n("esri.layers.support.rasterTransforms.PolynomialTransform")], u10);
var m4 = u10;

// node_modules/@arcgis/core/layers/support/rasterTransforms/utils.js
var o7 = { GCSShiftXform: c21, IdentityXform: p13, PolynomialXform: m4 };
var e8 = Object.keys(o7);
function f3(r8) {
  const t7 = r8 == null ? void 0 : r8.type;
  return !r8 || e8.includes(t7);
}
function i15(r8) {
  const t7 = r8 == null ? void 0 : r8.type;
  if (!t7)
    return null;
  const n12 = o7[r8 == null ? void 0 : r8.type];
  if (n12) {
    const t8 = new n12();
    return t8.read(r8), t8;
  }
  return null;
}

export {
  l11 as l,
  c21 as c,
  m4 as m,
  f3 as f,
  i15 as i
};
//# sourceMappingURL=chunk-DL3FP7BG.js.map
