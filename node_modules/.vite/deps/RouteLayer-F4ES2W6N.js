import {
  A,
  D,
  D2,
  N,
  O as O2,
  R,
  S as S3,
  U as U2,
  a as a3,
  a2 as a4,
  b as b2,
  f as f3,
  f2 as f4,
  g as g2,
  h,
  h2,
  i as i5,
  l as l3,
  n as n3,
  n2 as n4,
  r as r4,
  s as s5,
  t as t4,
  w as w3,
  y as y3
} from "./chunk-RB36DWEN.js";
import {
  a as a5
} from "./chunk-MVBDOV5D.js";
import {
  t as t5
} from "./chunk-TFPMF7EJ.js";
import {
  v as v4
} from "./chunk-NCXAKZRR.js";
import {
  i as i4
} from "./chunk-LX2NI53X.js";
import "./chunk-IZUZZJS7.js";
import {
  f
} from "./chunk-BWNO4YZY.js";
import "./chunk-DUCSW4OU.js";
import {
  f as f2,
  i as i3
} from "./chunk-WVDA5Z37.js";
import {
  _n,
  rn
} from "./chunk-FFVIDMFN.js";
import {
  v as v3
} from "./chunk-G3HEFWHV.js";
import {
  c as c2
} from "./chunk-FX6IXM55.js";
import {
  O
} from "./chunk-QFFP6A5Q.js";
import {
  S
} from "./chunk-J5VTDQTQ.js";
import {
  o as o3
} from "./chunk-JP3KAUQB.js";
import "./chunk-INL7BDTP.js";
import "./chunk-PDEVQZ7U.js";
import "./chunk-7XXQ7762.js";
import "./chunk-DVGM5RQS.js";
import "./chunk-R6OA44DQ.js";
import "./chunk-QTYVDCOW.js";
import "./chunk-YGVY4EIZ.js";
import "./chunk-HSDU7DIL.js";
import "./chunk-FWRLW4G5.js";
import "./chunk-JNNRJ7GQ.js";
import "./chunk-E52E6T7N.js";
import {
  x as x2
} from "./chunk-UK3I5WXR.js";
import "./chunk-GLGOVVCK.js";
import "./chunk-BUVDI6S7.js";
import "./chunk-6Z6ZAVRA.js";
import "./chunk-PK4W65H4.js";
import "./chunk-W62B63EU.js";
import "./chunk-N43PI2UO.js";
import "./chunk-O6VYMEIX.js";
import "./chunk-NDQ5FHGV.js";
import "./chunk-HUQX7WZO.js";
import {
  x
} from "./chunk-BYSA56OH.js";
import "./chunk-ZWUEORSX.js";
import "./chunk-US2IWMHE.js";
import "./chunk-ZPYDYUP5.js";
import {
  n as n2
} from "./chunk-TDV3ZXCQ.js";
import {
  t as t3
} from "./chunk-XJCUKRCO.js";
import {
  b
} from "./chunk-SOEQPPQP.js";
import "./chunk-22F6X66Z.js";
import "./chunk-AIDV7EKX.js";
import "./chunk-FZQZIM7U.js";
import "./chunk-YM6PUX7G.js";
import "./chunk-QEYOWTXD.js";
import "./chunk-CZBRZ6SU.js";
import "./chunk-KDO6J2FO.js";
import "./chunk-RT3T2K4S.js";
import {
  E2 as E
} from "./chunk-WJCI2CGX.js";
import {
  a as a2
} from "./chunk-REIQNAQW.js";
import {
  g
} from "./chunk-J6LQZWZI.js";
import {
  j3 as j4,
  y as y2
} from "./chunk-OD3FDQCI.js";
import "./chunk-J2PJNRU7.js";
import "./chunk-56SPM3WK.js";
import "./chunk-XMZAPOBR.js";
import "./chunk-BLJKKR5D.js";
import "./chunk-ZGNCYHMZ.js";
import "./chunk-X2S4RQJ4.js";
import {
  k as k2
} from "./chunk-FUPLN7UM.js";
import "./chunk-376OPXM4.js";
import "./chunk-DER356EU.js";
import "./chunk-MZIWIEIR.js";
import {
  S as S2
} from "./chunk-TQEOEDAZ.js";
import {
  m as m2
} from "./chunk-SHFHZMHO.js";
import "./chunk-NRP45AHD.js";
import "./chunk-IWQ7452U.js";
import {
  r as r3
} from "./chunk-NAN5J6QS.js";
import "./chunk-B4DKBAM3.js";
import "./chunk-6M2AHKYV.js";
import {
  j as j5
} from "./chunk-SZIJNKCV.js";
import "./chunk-6O43OEU5.js";
import "./chunk-J2K7ZDSV.js";
import "./chunk-2UML3WQZ.js";
import {
  i as i2
} from "./chunk-KXVMEIWT.js";
import {
  j as j3
} from "./chunk-UDND2Z3V.js";
import "./chunk-23Y3DIC6.js";
import "./chunk-JUVQV3R3.js";
import "./chunk-RAX2HD42.js";
import "./chunk-ZYRIJWLX.js";
import "./chunk-C5H57NTD.js";
import "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import {
  i
} from "./chunk-YWAQYJRC.js";
import "./chunk-B356PXLT.js";
import {
  v as v2
} from "./chunk-EHPBHJYZ.js";
import {
  m2 as m,
  u
} from "./chunk-3MNMDUQZ.js";
import {
  w,
  w2
} from "./chunk-UWG37XSU.js";
import {
  c,
  k2 as k
} from "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import {
  r as r2
} from "./chunk-HLM6QCL2.js";
import {
  o as o2
} from "./chunk-RXYULINL.js";
import {
  a
} from "./chunk-5NXILPDI.js";
import "./chunk-THVR7IAM.js";
import "./chunk-ZWJJTUFL.js";
import "./chunk-XQN7F674.js";
import {
  U
} from "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import {
  Ct,
  j as j2
} from "./chunk-KAN4HXCG.js";
import "./chunk-4FEGON7M.js";
import "./chunk-VWYWOOPX.js";
import {
  s as s4
} from "./chunk-M5VHU5LK.js";
import "./chunk-CXFRNDG4.js";
import {
  l as l2
} from "./chunk-7QMMKGW4.js";
import {
  e as e2,
  n2 as n,
  y
} from "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import {
  j
} from "./chunk-MJXQTGI2.js";
import {
  s as s3
} from "./chunk-LIZHLHNA.js";
import {
  v
} from "./chunk-BTUHYGXO.js";
import {
  s,
  s2
} from "./chunk-UA3YPL2R.js";
import {
  o,
  t as t2
} from "./chunk-HVKDYDPP.js";
import "./chunk-6QC7MLLS.js";
import {
  e,
  l,
  r,
  t
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/layers/support/RouteStopSymbols.js
var p = class extends l2 {
  constructor(o4) {
    super(o4), this.break = new y2({ color: [255, 255, 255], size: 12, outline: { color: [0, 122, 194], width: 3 } }), this.first = new y2({ color: [0, 255, 0], size: 20, outline: { color: [255, 255, 255], width: 4 } }), this.unlocated = new y2({ color: [255, 0, 0], size: 12, outline: { color: [255, 255, 255], width: 3 } }), this.last = new y2({ color: [255, 0, 0], size: 20, outline: { color: [255, 255, 255], width: 4 } }), this.middle = new y2({ color: [51, 51, 51], size: 12, outline: { color: [0, 122, 194], width: 3 } }), this.waypoint = new y2({ color: [255, 255, 255], size: 12, outline: { color: [0, 122, 194], width: 3 } });
  }
};
e2([y({ types: j4 })], p.prototype, "break", void 0), e2([y({ types: j4 })], p.prototype, "first", void 0), e2([y({ types: j4 })], p.prototype, "unlocated", void 0), e2([y({ types: j4 })], p.prototype, "last", void 0), e2([y({ types: j4 })], p.prototype, "middle", void 0), e2([y({ types: j4 })], p.prototype, "waypoint", void 0), p = e2([n("esri.layers.support.RouteStopSymbols")], p);
var l4 = p;

// node_modules/@arcgis/core/layers/support/RouteSymbols.js
var n5 = class extends l2 {
  constructor(o4) {
    super(o4), this.directionLines = new m2({ color: [0, 122, 194], width: 6 }), this.directionPoints = new y2({ color: [255, 255, 255], size: 6, outline: { color: [0, 122, 194], width: 2 } }), this.pointBarriers = new y2({ style: "x", size: 10, outline: { color: [255, 0, 0], width: 3 } }), this.polygonBarriers = new S2({ color: [255, 170, 0, 0.6], outline: { width: 7.5, color: [255, 0, 0, 0.6] } }), this.polylineBarriers = new m2({ width: 7.5, color: [255, 85, 0, 0.7] }), this.routeInfo = new m2({ width: 8, color: [20, 89, 127] }), this.stops = new l4();
  }
};
e2([y({ types: j4 })], n5.prototype, "directionLines", void 0), e2([y({ types: j4 })], n5.prototype, "directionPoints", void 0), e2([y({ types: j4 })], n5.prototype, "pointBarriers", void 0), e2([y({ types: j4 })], n5.prototype, "polygonBarriers", void 0), e2([y({ types: j4 })], n5.prototype, "polylineBarriers", void 0), e2([y({ types: j4 })], n5.prototype, "routeInfo", void 0), e2([y({ type: l4 })], n5.prototype, "stops", void 0), n5 = e2([n("esri.layers.support.RouteSymbols")], n5);
var y4 = n5;

// node_modules/@arcgis/core/rest/support/NetworkAttribute.js
var n6 = class extends l2 {
  constructor(t6) {
    super(t6), this.dataType = null, this.name = null, this.parameterNames = null, this.restrictionUsageParameterName = null, this.timeNeutralAttributeName = null, this.trafficSupport = null, this.units = null, this.usageType = null;
  }
};
e2([y({ type: String })], n6.prototype, "dataType", void 0), e2([r3(y3, { ignoreUnknown: false })], n6.prototype, "name", void 0), e2([y({ type: [String] })], n6.prototype, "parameterNames", void 0), e2([y({ type: String })], n6.prototype, "restrictionUsageParameterName", void 0), e2([r3(N, { ignoreUnknown: false })], n6.prototype, "timeNeutralAttributeName", void 0), e2([y({ type: String })], n6.prototype, "trafficSupport", void 0), e2([y({ type: String })], n6.prototype, "units", void 0), e2([r3(U2)], n6.prototype, "usageType", void 0), n6 = e2([n("esri.rest.support.NetworkAttribute")], n6);
var u2 = n6;

// node_modules/@arcgis/core/rest/support/NetworkDataset.js
var p2 = class extends l2 {
  constructor(t6) {
    super(t6), this.buildTime = null, this.name = null, this.networkAttributes = null, this.networkSources = null, this.state = null;
  }
};
e2([y({ type: Number })], p2.prototype, "buildTime", void 0), e2([y({ type: String })], p2.prototype, "name", void 0), e2([y({ type: [u2] })], p2.prototype, "networkAttributes", void 0), e2([y()], p2.prototype, "networkSources", void 0), e2([y({ type: String })], p2.prototype, "state", void 0), p2 = e2([n("esri.rest.support.NetworkDataset")], p2);
var i6 = p2;

// node_modules/@arcgis/core/rest/support/NetworkServiceDescription.js
var d = class extends l2 {
  constructor(t6) {
    super(t6), this.accumulateAttributeNames = null, this.currentVersion = null, this.defaultTravelMode = null, this.directionsLanguage = null, this.directionsLengthUnits = null, this.directionsSupportedLanguages = null, this.directionsTimeAttribute = null, this.hasZ = null, this.impedance = null, this.networkDataset = null, this.supportedTravelModes = null;
  }
  readAccumulateAttributes(t6) {
    return t(t6) ? null : t6.map((t7) => y3.fromJSON(t7));
  }
  writeAccumulateAttributes(t6, e3, o4) {
    !t(t6) && t6.length && (e3[o4] = t6.map((t7) => y3.toJSON(t7)));
  }
};
e2([y()], d.prototype, "accumulateAttributeNames", void 0), e2([o2("accumulateAttributeNames")], d.prototype, "readAccumulateAttributes", null), e2([r2("accumulateAttributeNames")], d.prototype, "writeAccumulateAttributes", null), e2([y()], d.prototype, "currentVersion", void 0), e2([y()], d.prototype, "defaultTravelMode", void 0), e2([y()], d.prototype, "directionsLanguage", void 0), e2([r3(r4)], d.prototype, "directionsLengthUnits", void 0), e2([y()], d.prototype, "directionsSupportedLanguages", void 0), e2([r3(N, { ignoreUnknown: false })], d.prototype, "directionsTimeAttribute", void 0), e2([y()], d.prototype, "hasZ", void 0), e2([r3(y3, { ignoreUnknown: false })], d.prototype, "impedance", void 0), e2([y({ type: i6 })], d.prototype, "networkDataset", void 0), e2([y({ type: [A] })], d.prototype, "supportedTravelModes", void 0), d = e2([n("esri.rest.support.NetworkServiceDescription")], d);
var y5 = d;

// node_modules/@arcgis/core/rest/networkService.js
var d2 = s2.getLogger("esri.rest.networkService");
function u3(e3, r5, t6, o4) {
  o4[t6] = [r5.length, r5.length + e3.length], e3.forEach((e4) => {
    r5.push(e4.geometry);
  });
}
function f5(e3, r5) {
  for (let t6 = 0; t6 < r5.length; t6++) {
    const o4 = e3[r5[t6]];
    if (o4 && o4.length)
      for (const e4 of o4)
        e4.z = void 0;
  }
  d2.warnOnce("The remote Network Analysis service is powered by a network dataset which is not Z-aware.\nZ-coordinates of the input geometry are ignored.");
}
function c3(e3, r5) {
  for (let t6 = 0; t6 < r5.length; t6++) {
    const s7 = e3[r5[t6]];
    if (s7 && s7.length) {
      for (const e4 of s7)
        if (r(e4) && e4.hasZ)
          return true;
    }
  }
  return false;
}
async function p3(t6, o4, s7) {
  if (!t6)
    throw new s3("network-service:missing-url", "Url to Network service is missing");
  const a8 = i3({ f: "json", token: o4 }, s7), { data: l8 } = await U(t6, a8);
  l8.supportedTravelModes || (l8.supportedTravelModes = []);
  for (let e3 = 0; e3 < l8.supportedTravelModes.length; e3++)
    l8.supportedTravelModes[e3].id || (l8.supportedTravelModes[e3].id = l8.supportedTravelModes[e3].itemId);
  const d3 = l8.currentVersion >= 10.4 ? m3(t6, o4, s7) : v5(t6, s7), { defaultTravelMode: u8, supportedTravelModes: f7 } = await d3;
  return l8.defaultTravelMode = u8, l8.supportedTravelModes = f7, y5.fromJSON(l8);
}
async function v5(r5, t6) {
  var _a, _b, _c;
  const o4 = i3({ f: "json" }, t6), { data: i8 } = await U(r5.replace(/\/rest\/.*$/i, "/info"), o4);
  if (!i8 || !i8.owningSystemUrl)
    return { supportedTravelModes: [], defaultTravelMode: null };
  const { owningSystemUrl: d3 } = i8, u8 = Ct(d3) + "/sharing/rest/portals/self", { data: f7 } = await U(u8, o4), c11 = t2("helperServices.routingUtilities.url", f7);
  if (!c11)
    return { supportedTravelModes: [], defaultTravelMode: null };
  const p7 = f2(d3), v6 = /\/solve$/i.test(p7.path) ? "Route" : /\/solveclosestfacility$/i.test(p7.path) ? "ClosestFacility" : "ServiceAreas", m6 = i3({ f: "json", serviceName: v6 }, t6), T = Ct(c11) + "/GetTravelModes/execute", M = await U(T, m6), h3 = [];
  let g3 = null;
  if ((_b = (_a = M == null ? void 0 : M.data) == null ? void 0 : _a.results) == null ? void 0 : _b.length) {
    const e3 = M.data.results;
    for (const r6 of e3)
      if ("supportedTravelModes" === r6.paramName) {
        if ((_c = r6.value) == null ? void 0 : _c.features) {
          for (const { attributes: e4 } of r6.value.features)
            if (e4) {
              const r7 = JSON.parse(e4.TravelMode);
              h3.push(r7);
            }
        }
      } else
        "defaultTravelMode" === r6.paramName && (g3 = r6.value);
  }
  return { supportedTravelModes: h3, defaultTravelMode: g3 };
}
async function m3(t6, o4, s7) {
  try {
    const r5 = i3({ f: "json", token: o4 }, s7), l8 = Ct(t6) + "/retrieveTravelModes", { data: { supportedTravelModes: i8, defaultTravelMode: d3 } } = await U(l8, r5);
    return { supportedTravelModes: i8, defaultTravelMode: d3 };
  } catch (l8) {
    throw new s3("network-service:retrieveTravelModes", "Could not get to the NAServer's retrieveTravelModes.", { error: l8 });
  }
}

// node_modules/@arcgis/core/rest/support/NAMessage.js
var p4 = new s4({ 0: "informative", 1: "process-definition", 2: "process-start", 3: "process-stop", 50: "warning", 100: "error", 101: "empty", 200: "abort" });
var c4 = class extends a5 {
  constructor(r5) {
    super(r5), this.type = null;
  }
};
e2([y({ type: String, json: { read: p4.read, write: p4.write } })], c4.prototype, "type", void 0), c4 = e2([n("esri.rest.support.NAMessage")], c4);
var a6 = c4;

// node_modules/@arcgis/core/rest/support/DirectionsString.js
var c5 = class extends l2 {
  constructor(r5) {
    super(r5);
  }
};
e2([y({ json: { read: { source: "string" } } })], c5.prototype, "text", void 0), e2([r3(R, { name: "stringType" })], c5.prototype, "type", void 0), c5 = e2([n("esri.rest.support.DirectionsString")], c5);
var i7 = c5;

// node_modules/@arcgis/core/rest/support/DirectionsEvent.js
var a7 = class extends l2 {
  constructor(r5) {
    super(r5), this.arriveTime = null, this.arriveTimeOffset = null, this.geometry = null, this.strings = null;
  }
  readArriveTimeOffset(r5, e3) {
    return a4(e3.ETA, e3.arriveTimeUTC);
  }
  readGeometry(r5, e3) {
    return w.fromJSON(e3.point);
  }
};
e2([y({ type: Date, json: { read: { source: "arriveTimeUTC" } } })], a7.prototype, "arriveTime", void 0), e2([y()], a7.prototype, "arriveTimeOffset", void 0), e2([o2("arriveTimeOffset", ["arriveTimeUTC", "ETA"])], a7.prototype, "readArriveTimeOffset", null), e2([y({ type: w })], a7.prototype, "geometry", void 0), e2([o2("geometry", ["point"])], a7.prototype, "readGeometry", null), e2([y({ type: [i7] })], a7.prototype, "strings", void 0), a7 = e2([n("esri.rest.support.DirectionsEvent")], a7);
var c6 = a7;

// node_modules/@arcgis/core/rest/support/DirectionsFeature.js
function m4(r5) {
  if (t(r5) || "" === r5)
    return null;
  let e3 = 0, t6 = 0, o4 = 0, p7 = 0;
  const n9 = [];
  let c11, i8, a8, m6, u8, l8, f7, y8, d3 = 0, h3 = 0, j6 = 0;
  if (u8 = r5.match(/((\+|\-)[^\+\-\|]+|\|)/g), u8 || (u8 = []), 0 === parseInt(u8[d3], 32)) {
    d3 = 2;
    const r6 = parseInt(u8[d3], 32);
    d3++, l8 = parseInt(u8[d3], 32), d3++, 1 & r6 && (h3 = u8.indexOf("|") + 1, f7 = parseInt(u8[h3], 32), h3++), 2 & r6 && (j6 = u8.indexOf("|", h3) + 1, y8 = parseInt(u8[j6], 32), j6++);
  } else
    l8 = parseInt(u8[d3], 32), d3++;
  for (; d3 < u8.length && "|" !== u8[d3]; ) {
    c11 = parseInt(u8[d3], 32) + e3, d3++, e3 = c11, i8 = parseInt(u8[d3], 32) + t6, d3++, t6 = i8;
    const r6 = [c11 / l8, i8 / l8];
    h3 && (m6 = parseInt(u8[h3], 32) + o4, h3++, o4 = m6, r6.push(m6 / f7)), j6 && (a8 = parseInt(u8[j6], 32) + p7, j6++, p7 = a8, r6.push(a8 / y8)), n9.push(r6);
  }
  return { paths: [n9], hasZ: h3 > 0, hasM: j6 > 0 };
}
var u4 = class extends g {
  constructor(r5) {
    super(r5), this.events = null, this.strings = null;
  }
  readGeometry(r5, e3) {
    const s7 = m4(e3.compressedGeometry);
    return r(s7) ? m.fromJSON(s7) : null;
  }
};
e2([y({ type: [c6] })], u4.prototype, "events", void 0), e2([o2("geometry", ["compressedGeometry"])], u4.prototype, "readGeometry", null), e2([y({ type: [i7] })], u4.prototype, "strings", void 0), u4 = e2([n("esri.rest.support.DirectionsFeature")], u4);
var l5 = u4;

// node_modules/@arcgis/core/rest/support/DirectionsFeatureSet.js
function u5(e3, t6) {
  if (0 === e3.length)
    return new m({ spatialReference: t6 });
  const r5 = [];
  for (const p7 of e3)
    for (const e4 of p7.paths)
      r5.push(...e4);
  const o4 = [];
  r5.forEach((e4, t7) => {
    0 !== t7 && e4[0] === r5[t7 - 1][0] && e4[1] === r5[t7 - 1][1] || o4.push(e4);
  });
  const { hasM: s7, hasZ: a8 } = e3[0];
  return new m({ hasM: s7, hasZ: a8, paths: [o4], spatialReference: t6 });
}
var c7 = class extends x2 {
  constructor(e3) {
    super(e3), this.extent = null, this.features = null, this.geometryType = "polyline", this.routeId = null, this.routeName = null, this.totalDriveTime = null, this.totalLength = null, this.totalTime = null;
  }
  readFeatures(e3, r5) {
    var _a;
    if (!e3)
      return [];
    const o4 = (_a = r5.summary.envelope.spatialReference) != null ? _a : r5.spatialReference, s7 = o4 && k.fromJSON(o4);
    return e3.map((e4) => {
      const r6 = l5.fromJSON(e4);
      if (r(r6.geometry) && (r6.geometry.spatialReference = s7), r(r6.events))
        for (const o5 of r6.events)
          r(o5.geometry) && (o5.geometry.spatialReference = s7);
      return r6;
    });
  }
  get mergedGeometry() {
    if (!this.features)
      return null;
    return u5(this.features.map(({ geometry: e3 }) => e(e3)), this.extent.spatialReference);
  }
  get strings() {
    return this.features.map(({ strings: e3 }) => e3).flat().filter(r);
  }
};
e2([y({ type: w2, json: { read: { source: "summary.envelope" } } })], c7.prototype, "extent", void 0), e2([y()], c7.prototype, "features", void 0), e2([o2("features")], c7.prototype, "readFeatures", null), e2([y()], c7.prototype, "geometryType", void 0), e2([y({ readOnly: true })], c7.prototype, "mergedGeometry", null), e2([y()], c7.prototype, "routeId", void 0), e2([y()], c7.prototype, "routeName", void 0), e2([y({ value: null, readOnly: true })], c7.prototype, "strings", null), e2([y({ json: { read: { source: "summary.totalDriveTime" } } })], c7.prototype, "totalDriveTime", void 0), e2([y({ json: { read: { source: "summary.totalLength" } } })], c7.prototype, "totalLength", void 0), e2([y({ json: { read: { source: "summary.totalTime" } } })], c7.prototype, "totalTime", void 0), c7 = e2([n("esri.rest.support.DirectionsFeatureSet")], c7);
var f6 = c7;

// node_modules/@arcgis/core/rest/support/RouteResult.js
var n7 = class extends l2 {
  constructor(t6) {
    super(t6), this.directionLines = null, this.directionPoints = null, this.directions = null, this.route = null, this.routeName = null, this.stops = null, this.traversedEdges = null, this.traversedJunctions = null, this.traversedTurns = null;
  }
};
e2([y({ type: x2, json: { write: true } })], n7.prototype, "directionLines", void 0), e2([y({ type: x2, json: { write: true } })], n7.prototype, "directionPoints", void 0), e2([y({ type: f6, json: { write: true } })], n7.prototype, "directions", void 0), e2([y({ type: g, json: { write: true } })], n7.prototype, "route", void 0), e2([y({ type: String, json: { write: true } })], n7.prototype, "routeName", void 0), e2([y({ type: [g], json: { write: true } })], n7.prototype, "stops", void 0), e2([y({ type: x2, json: { write: true } })], n7.prototype, "traversedEdges", void 0), e2([y({ type: x2, json: { write: true } })], n7.prototype, "traversedJunctions", void 0), e2([y({ type: x2, json: { write: true } })], n7.prototype, "traversedTurns", void 0), n7 = e2([n("esri.rest.support.RouteResult")], n7);
var u6 = n7;

// node_modules/@arcgis/core/rest/support/RouteSolveResult.js
function u7(r5) {
  return r5 && x2.fromJSON(r5).features.map((r6) => r6);
}
var n8 = class extends l2 {
  constructor(r5) {
    super(r5), this.messages = null, this.pointBarriers = null, this.polylineBarriers = null, this.polygonBarriers = null, this.routeResults = null;
  }
  readPointBarriers(r5, o4) {
    return u7(o4.barriers);
  }
  readPolylineBarriers(r5) {
    return u7(r5);
  }
  readPolygonBarriers(r5) {
    return u7(r5);
  }
};
e2([y({ type: [a6] })], n8.prototype, "messages", void 0), e2([y({ type: [g] })], n8.prototype, "pointBarriers", void 0), e2([o2("pointBarriers", ["barriers"])], n8.prototype, "readPointBarriers", null), e2([y({ type: [g] })], n8.prototype, "polylineBarriers", void 0), e2([o2("polylineBarriers")], n8.prototype, "readPolylineBarriers", null), e2([y({ type: [g] })], n8.prototype, "polygonBarriers", void 0), e2([o2("polygonBarriers")], n8.prototype, "readPolygonBarriers", null), e2([y({ type: [u6] })], n8.prototype, "routeResults", void 0), n8 = e2([n("esri.rest.support.RouteSolveResult")], n8);
var y6 = n8;

// node_modules/@arcgis/core/rest/route.js
function l6(e3) {
  return e3 instanceof x2;
}
async function m5(r5, t6, p7) {
  const c11 = [], m6 = [], d3 = {}, g3 = {}, h3 = f2(r5), { path: R3 } = h3;
  l6(t6.stops) && u3(t6.stops.features, m6, "stops.features", d3), l6(t6.pointBarriers) && u3(t6.pointBarriers.features, m6, "pointBarriers.features", d3), l6(t6.polylineBarriers) && u3(t6.polylineBarriers.features, m6, "polylineBarriers.features", d3), l6(t6.polygonBarriers) && u3(t6.polygonBarriers.features, m6, "polygonBarriers.features", d3);
  const v6 = await v4(m6);
  for (const e3 in d3) {
    const r6 = d3[e3];
    c11.push(e3), g3[e3] = v6.slice(r6[0], r6[1]);
  }
  if (c3(g3, c11)) {
    let e3 = null;
    try {
      e3 = await p3(R3, t6.apiKey, p7);
    } catch {
    }
    e3 && !e3.hasZ && f5(g3, c11);
  }
  for (const e3 in g3)
    g3[e3].forEach((r6, s7) => {
      t6.get(e3)[s7].geometry = r6;
    });
  const B = { ...p7, query: { ...h3.query, ...n4(t6), f: "json" } }, E2 = R3.endsWith("/solve") ? R3 : `${R3}/solve`, { data: T } = await U(E2, B);
  return y7(T);
}
function y7(e3) {
  var _a;
  const { barriers: s7, directionLines: o4, directionPoints: a8, directions: i8, messages: n9, polygonBarriers: u8, polylineBarriers: f7, routes: p7, stops: l8, traversedEdges: m6, traversedJunctions: y8, traversedTurns: d3 } = e3, g3 = (e4) => {
    const r5 = R3.find((r6) => r6.routeName === e4);
    if (r(r5))
      return r5;
    const s8 = { routeId: R3.length + 1, routeName: e4 };
    return R3.push(s8), s8;
  }, h3 = (e4) => {
    const r5 = R3.find((r6) => r6.routeId === e4);
    if (r(r5))
      return r5;
    const s8 = { routeId: e4, routeName: null };
    return R3.push(s8), s8;
  }, R3 = [];
  p7 == null ? void 0 : p7.features.forEach((e4, r5) => {
    e4.geometry.spatialReference = p7.spatialReference;
    const t6 = e4.attributes.Name, s8 = r5 + 1;
    R3.push({ routeId: s8, routeName: t6, route: e4 });
  }), i8 == null ? void 0 : i8.forEach((e4) => {
    const { routeName: r5 } = e4;
    g3(r5).directions = e4;
  });
  const v6 = ((_a = l8 == null ? void 0 : l8.features.every((e4) => t(e4.attributes.RouteName))) != null ? _a : false) && R3.length > 0 ? R3[0].routeName : null;
  return l8 == null ? void 0 : l8.features.forEach((e4) => {
    var _a2, _b;
    var r5;
    e4.geometry && ((_a2 = (r5 = e4.geometry).spatialReference) != null ? _a2 : r5.spatialReference = l8.spatialReference);
    const t6 = v6 != null ? v6 : e4.attributes.RouteName, s8 = g3(t6);
    (_b = s8.stops) != null ? _b : s8.stops = [], s8.stops.push(e4);
  }), o4 == null ? void 0 : o4.features.forEach((e4) => {
    var _a2;
    const r5 = e4.attributes.RouteID, t6 = h3(r5), { geometryType: s8, spatialReference: a9 } = o4;
    (_a2 = t6.directionLines) != null ? _a2 : t6.directionLines = { features: [], geometryType: s8, spatialReference: a9 }, t6.directionLines.features.push(e4);
  }), a8 == null ? void 0 : a8.features.forEach((e4) => {
    var _a2;
    const r5 = e4.attributes.RouteID, t6 = h3(r5), { geometryType: s8, spatialReference: o5 } = a8;
    (_a2 = t6.directionPoints) != null ? _a2 : t6.directionPoints = { features: [], geometryType: s8, spatialReference: o5 }, t6.directionPoints.features.push(e4);
  }), m6 == null ? void 0 : m6.features.forEach((e4) => {
    var _a2;
    const r5 = e4.attributes.RouteID, t6 = h3(r5), { geometryType: s8, spatialReference: o5 } = m6;
    (_a2 = t6.traversedEdges) != null ? _a2 : t6.traversedEdges = { features: [], geometryType: s8, spatialReference: o5 }, t6.traversedEdges.features.push(e4);
  }), y8 == null ? void 0 : y8.features.forEach((e4) => {
    var _a2;
    const r5 = e4.attributes.RouteID, t6 = h3(r5), { geometryType: s8, spatialReference: o5 } = y8;
    (_a2 = t6.traversedJunctions) != null ? _a2 : t6.traversedJunctions = { features: [], geometryType: s8, spatialReference: o5 }, t6.traversedJunctions.features.push(e4);
  }), d3 == null ? void 0 : d3.features.forEach((e4) => {
    var _a2;
    const r5 = e4.attributes.RouteID, t6 = h3(r5);
    (_a2 = t6.traversedTurns) != null ? _a2 : t6.traversedTurns = { features: [] }, t6.traversedTurns.features.push(e4);
  }), y6.fromJSON({ routeResults: R3, barriers: s7, polygonBarriers: u8, polylineBarriers: f7, messages: n9 });
}

// node_modules/@arcgis/core/rest/support/DataLayer.js
var l7 = class extends i2(l2) {
  constructor(o4) {
    super(o4), this.doNotLocateOnRestrictedElements = null, this.geometry = null, this.geometryType = null, this.name = null, this.spatialRelationship = null, this.type = "layer", this.where = null;
  }
};
e2([y({ type: Boolean, json: { write: true } })], l7.prototype, "doNotLocateOnRestrictedElements", void 0), e2([y({ types: i, json: { read: v2, write: true } })], l7.prototype, "geometry", void 0), e2([r3(w3)], l7.prototype, "geometryType", void 0), e2([y({ type: String, json: { name: "layerName", write: true } })], l7.prototype, "name", void 0), e2([r3(S3, { name: "spatialRel" })], l7.prototype, "spatialRelationship", void 0), e2([y({ type: String, json: { write: true } })], l7.prototype, "type", void 0), e2([y({ type: String, json: { write: true } })], l7.prototype, "where", void 0), l7 = e2([n("esri.rest.support.DataLayer")], l7);
var c8 = l7;

// node_modules/@arcgis/core/rest/support/NetworkFeatureSet.js
var s6;
var c9 = s6 = class extends x2 {
  constructor(e3) {
    super(e3), this.doNotLocateOnRestrictedElements = null;
  }
  clone() {
    return new s6({ doNotLocateOnRestrictedElements: this.doNotLocateOnRestrictedElements, ...this.cloneProperties() });
  }
};
e2([y({ type: Boolean, json: { write: true } })], c9.prototype, "doNotLocateOnRestrictedElements", void 0), c9 = s6 = e2([n("esri.rest.support.NetworkFeatureSet")], c9);
var p5 = c9;

// node_modules/@arcgis/core/rest/support/NetworkUrl.js
var p6 = class extends i2(l2) {
  constructor(o4) {
    super(o4), this.doNotLocateOnRestrictedElements = null, this.url = null;
  }
};
e2([y({ type: Boolean, json: { write: true } })], p6.prototype, "doNotLocateOnRestrictedElements", void 0), e2([y({ type: String, json: { write: true } })], p6.prototype, "url", void 0), p6 = e2([n("esri.rest.support.NetworkUrl")], p6);
var c10 = p6;

// node_modules/@arcgis/core/rest/support/RouteParameters.js
var O3;
function U3(t6) {
  return t6 && "type" in t6;
}
function J(t6) {
  return t6 && "features" in t6 && "doNotLocateOnRestrictedElements" in t6;
}
function L(t6) {
  return t6 && "url" in t6;
}
function R2(t6) {
  return t6 && "features" in t6;
}
function C(t6) {
  return U3(t6) ? c8.fromJSON(t6) : L(t6) ? c10.fromJSON(t6) : J(t6) ? p5.fromJSON(t6) : R2(t6) ? x2.fromJSON(t6) : null;
}
function D3(t6, e3, o4) {
  r(t6) && (e3[o4] = j3.isCollection(t6) ? { features: t6.toArray().map((t7) => t7.toJSON()) } : t6.toJSON());
}
var k3 = O3 = class extends i2(l2) {
  constructor(t6) {
    super(t6), this.accumulateAttributes = null, this.apiKey = null, this.attributeParameterValues = null, this.directionsLanguage = null, this.directionsLengthUnits = null, this.directionsOutputType = null, this.directionsStyleName = null, this.directionsTimeAttribute = null, this.findBestSequence = null, this.geometryPrecision = null, this.geometryPrecisionM = null, this.geometryPrecisionZ = null, this.ignoreInvalidLocations = null, this.impedanceAttribute = null, this.outputGeometryPrecision = null, this.outputGeometryPrecisionUnits = null, this.outputLines = "true-shape", this.outSpatialReference = null, this.overrides = null, this.pointBarriers = null, this.polygonBarriers = null, this.polylineBarriers = null, this.preserveFirstStop = null, this.preserveLastStop = null, this.preserveObjectID = null, this.restrictionAttributes = null, this.restrictUTurns = null, this.returnBarriers = false, this.returnDirections = false, this.returnPolygonBarriers = false, this.returnPolylineBarriers = false, this.returnRoutes = true, this.returnStops = false, this.returnTraversedEdges = null, this.returnTraversedJunctions = null, this.returnTraversedTurns = null, this.returnZ = true, this.startTime = null, this.startTimeIsUTC = true, this.stops = null, this.timeWindowsAreUTC = null, this.travelMode = null, this.useHierarchy = null, this.useTimeWindows = null;
  }
  static from(t6) {
    return v(O3, t6);
  }
  readAccumulateAttributes(t6) {
    return t(t6) ? null : t6.map((t7) => y3.fromJSON(t7));
  }
  writeAccumulateAttributes(t6, e3, r5) {
    !t(t6) && t6.length && (e3[r5] = t6.map((t7) => y3.toJSON(t7)));
  }
  writePointBarriers(t6, e3, r5) {
    D3(t6, e3, r5);
  }
  writePolygonBarrier(t6, e3, r5) {
    D3(t6, e3, r5);
  }
  writePolylineBarrier(t6, e3, r5) {
    D3(t6, e3, r5);
  }
  readRestrictionAttributes(t6) {
    return t(t6) ? null : t6.map((t7) => D.fromJSON(t7));
  }
  writeRestrictionAttributes(t6, e3, r5) {
    !t(t6) && t6.length && (e3[r5] = t6.map((t7) => D.toJSON(t7)));
  }
  readStartTime(t6, e3) {
    const { startTime: r5 } = e3;
    return t(r5) ? null : "now" === r5 ? "now" : new Date(r5);
  }
  writeStartTime(t6, e3) {
    t(t6) || (e3.startTime = "now" === t6 ? "now" : t6.getTime());
  }
  readStops(t6, e3) {
    return C(e3.stops);
  }
  writeStops(t6, e3, r5) {
    D3(t6, e3, r5);
  }
};
e2([y({ type: [String], json: { name: "accumulateAttributeNames", write: true } })], k3.prototype, "accumulateAttributes", void 0), e2([o2("accumulateAttributes")], k3.prototype, "readAccumulateAttributes", null), e2([r2("accumulateAttributes")], k3.prototype, "writeAccumulateAttributes", null), e2([y(t5)], k3.prototype, "apiKey", void 0), e2([y({ json: { write: true } })], k3.prototype, "attributeParameterValues", void 0), e2([y({ type: String, json: { write: true } })], k3.prototype, "directionsLanguage", void 0), e2([r3(r4)], k3.prototype, "directionsLengthUnits", void 0), e2([r3(s5)], k3.prototype, "directionsOutputType", void 0), e2([r3(f3)], k3.prototype, "directionsStyleName", void 0), e2([r3(N, { name: "directionsTimeAttributeName", ignoreUnknown: false })], k3.prototype, "directionsTimeAttribute", void 0), e2([y({ type: Boolean, json: { write: true } })], k3.prototype, "findBestSequence", void 0), e2([y({ type: Number, json: { write: true } })], k3.prototype, "geometryPrecision", void 0), e2([y({ type: Number, json: { write: true } })], k3.prototype, "geometryPrecisionM", void 0), e2([y({ type: Number, json: { write: true } })], k3.prototype, "geometryPrecisionZ", void 0), e2([y({ type: Boolean, json: { write: true } })], k3.prototype, "ignoreInvalidLocations", void 0), e2([r3(y3, { name: "impedanceAttributeName", ignoreUnknown: false })], k3.prototype, "impedanceAttribute", void 0), e2([y({ type: Number, json: { write: true } })], k3.prototype, "outputGeometryPrecision", void 0), e2([r3(i5)], k3.prototype, "outputGeometryPrecisionUnits", void 0), e2([r3(a3)], k3.prototype, "outputLines", void 0), e2([y({ type: k, json: { name: "outSR", write: true } })], k3.prototype, "outSpatialReference", void 0), e2([y({ json: { write: true } })], k3.prototype, "overrides", void 0), e2([y({ json: { name: "barriers", write: true } })], k3.prototype, "pointBarriers", void 0), e2([r2("pointBarriers")], k3.prototype, "writePointBarriers", null), e2([y({ json: { write: true } })], k3.prototype, "polygonBarriers", void 0), e2([r2("polygonBarriers")], k3.prototype, "writePolygonBarrier", null), e2([y({ json: { write: true } })], k3.prototype, "polylineBarriers", void 0), e2([r2("polylineBarriers")], k3.prototype, "writePolylineBarrier", null), e2([y({ type: Boolean, json: { write: true } })], k3.prototype, "preserveFirstStop", void 0), e2([y({ type: Boolean, json: { write: true } })], k3.prototype, "preserveLastStop", void 0), e2([y({ type: Boolean, json: { write: true } })], k3.prototype, "preserveObjectID", void 0), e2([y({ type: [String], json: { name: "restrictionAttributeNames", write: true } })], k3.prototype, "restrictionAttributes", void 0), e2([o2("restrictionAttributes")], k3.prototype, "readRestrictionAttributes", null), e2([r2("restrictionAttributes")], k3.prototype, "writeRestrictionAttributes", null), e2([r3(n3)], k3.prototype, "restrictUTurns", void 0), e2([y({ type: Boolean, json: { write: true } })], k3.prototype, "returnBarriers", void 0), e2([y({ type: Boolean, json: { write: true } })], k3.prototype, "returnDirections", void 0), e2([y({ type: Boolean, json: { write: true } })], k3.prototype, "returnPolygonBarriers", void 0), e2([y({ type: Boolean, json: { write: true } })], k3.prototype, "returnPolylineBarriers", void 0), e2([y({ type: Boolean, json: { write: true } })], k3.prototype, "returnRoutes", void 0), e2([y({ type: Boolean, json: { write: true } })], k3.prototype, "returnStops", void 0), e2([y({ type: Boolean, json: { write: true } })], k3.prototype, "returnTraversedEdges", void 0), e2([y({ type: Boolean, json: { write: true } })], k3.prototype, "returnTraversedJunctions", void 0), e2([y({ type: Boolean, json: { write: true } })], k3.prototype, "returnTraversedTurns", void 0), e2([y({ type: Boolean, json: { write: true } })], k3.prototype, "returnZ", void 0), e2([y({ type: Date, json: { type: Number, write: true } })], k3.prototype, "startTime", void 0), e2([o2("startTime")], k3.prototype, "readStartTime", null), e2([r2("startTime")], k3.prototype, "writeStartTime", null), e2([y({ type: Boolean, json: { write: true } })], k3.prototype, "startTimeIsUTC", void 0), e2([y({ json: { write: true } })], k3.prototype, "stops", void 0), e2([o2("stops")], k3.prototype, "readStops", null), e2([r2("stops")], k3.prototype, "writeStops", null), e2([y({ type: Boolean, json: { write: true } })], k3.prototype, "timeWindowsAreUTC", void 0), e2([y({ type: A, json: { write: true } })], k3.prototype, "travelMode", void 0), e2([y({ type: Boolean, json: { write: true } })], k3.prototype, "useHierarchy", void 0), e2([y({ type: Boolean, json: { write: true } })], k3.prototype, "useTimeWindows", void 0), k3 = O3 = e2([n("esri.rest.support.RouteParameters")], k3);
var I = k3;

// node_modules/@arcgis/core/layers/RouteLayer.js
function X(e3) {
  return e3.length ? e3 : null;
}
function ee(e3) {
  const { defaultTravelMode: t6, supportedTravelModes: r5 } = e3;
  return r5 == null ? void 0 : r5.find(({ id: e4 }) => e4 === t6);
}
function te(e3) {
  switch (e3) {
    case "esriGeometryPoint":
      return { type: "esriSMS", style: "esriSMSCircle", size: 12, color: [0, 0, 0, 0], outline: te("esriGeometryPolyline") };
    case "esriGeometryPolyline":
      return { type: "esriSLS", style: "esriSLSSolid", width: 1, color: [0, 0, 0, 0] };
    case "esriGeometryPolygon":
      return { type: "esriSFS", style: "esriSFSNull", outline: te("esriGeometryPolyline") };
  }
}
function re(e3) {
  return "layers" in e3;
}
function oe(e3) {
  return "esri.rest.support.FeatureSet" === e3.declaredClass;
}
function ie(e3) {
  return "esri.rest.support.NetworkFeatureSet" === e3.declaredClass;
}
function se(e3, t6, r5) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n2, _o, _p, _q, _r, _s, _t, _u, _v;
  const o4 = (_a = t6.networkDataset) == null ? void 0 : _a.networkAttributes, i8 = (_b = o4 == null ? void 0 : o4.filter((e4) => "cost" === e4.usageType)) != null ? _b : [], s7 = ee(t6), a8 = (_c = r5.travelMode) != null ? _c : s7;
  if (t(a8))
    return void we.warn("route-layer:missing-travel-mode", "The routing service must have a default travel mode or one must be specified in the route parameter.");
  const { timeAttributeName: l8, distanceAttributeName: c11 } = a8, y8 = i8.find((e4) => e4.name === l8), f7 = i8.find((e4) => e4.name === c11), d3 = (_f = (_e = (_d = e(r5.travelMode)) == null ? void 0 : _d.impedanceAttributeName) != null ? _e : e(r5.impedanceAttribute)) != null ? _f : t6.impedance, h3 = t4.fromJSON(y8 == null ? void 0 : y8.units), w4 = r4.fromJSON(f7 == null ? void 0 : f7.units);
  if (!h3 || !w4)
    throw new s3("routelayer:unknown-impedance-units", "the units of either the distance or time impedance are unknown");
  const S4 = (_g = r5.directionsLanguage) != null ? _g : t6.directionsLanguage, g3 = (_i = (_h = e(r5.accumulateAttributes)) != null ? _h : t6.accumulateAttributeNames) != null ? _i : [], b3 = new Set(i8.filter(({ name: e4 }) => e4 === l8 || e4 === c11 || e4 === d3 || null != e4 && g3.includes(e4)).map(({ name: e4 }) => e4)), v6 = (e4) => {
    for (const t7 in e4)
      b3.has(t7) || delete e4[t7];
  };
  for (const n9 of e3.pointBarriers)
    r(n9.costs) && (n9.addedCost = (_j = n9.costs[d3]) != null ? _j : 0, v6(n9.costs));
  for (const n9 of e3.polygonBarriers)
    r(n9.costs) && (n9.scaleFactor = (_k = n9.costs[d3]) != null ? _k : 1, v6(n9.costs));
  for (const n9 of e3.polylineBarriers)
    r(n9.costs) && (n9.scaleFactor = (_l = n9.costs[d3]) != null ? _l : 1, v6(n9.costs));
  const { routeInfo: B } = e3, { findBestSequence: P, preserveFirstStop: j6, preserveLastStop: I2, startTimeIsUTC: N2, timeWindowsAreUTC: _ } = r5;
  B.analysisSettings = new l3({ accumulateAttributes: g3, directionsLanguage: S4, findBestSequence: P, preserveFirstStop: j6, preserveLastStop: I2, startTimeIsUTC: N2, timeWindowsAreUTC: _, travelMode: a8 }), B.totalDuration = ae((_m = B.totalCosts[l8]) != null ? _m : 0, h3), B.totalDistance = le((_n2 = B.totalCosts[c11]) != null ? _n2 : 0, w4), B.totalLateDuration = ae((_o = B.totalViolations[l8]) != null ? _o : 0, h3), B.totalWaitDuration = ae((_p = B.totalWait[l8]) != null ? _p : 0, h3), r(B.totalCosts) && v6(B.totalCosts), r(B.totalViolations) && v6(B.totalViolations), r(B.totalWait) && v6(B.totalWait);
  for (const n9 of e3.stops)
    r(n9.serviceCosts) && (n9.serviceDuration = ae((_q = n9.serviceCosts[l8]) != null ? _q : 0, h3), n9.serviceDistance = le((_r = n9.serviceCosts[c11]) != null ? _r : 0, w4), v6(n9.serviceCosts)), r(n9.cumulativeCosts) && (n9.cumulativeDuration = ae((_s = n9.cumulativeCosts[l8]) != null ? _s : 0, h3), n9.cumulativeDistance = le((_t = n9.cumulativeCosts[c11]) != null ? _t : 0, w4), v6(n9.cumulativeCosts)), r(n9.violations) && (n9.lateDuration = ae((_u = n9.violations[l8]) != null ? _u : 0, h3), v6(n9.violations)), r(n9.wait) && (n9.waitDuration = ae((_v = n9.wait[l8]) != null ? _v : 0, h3), v6(n9.wait));
}
async function ne(e3) {
  const t6 = k.WGS84;
  return await _n(e3.spatialReference, t6), rn(e3, t6);
}
function ae(e3, t6) {
  switch (t6) {
    case "seconds":
      return e3 / 60;
    case "hours":
      return 60 * e3;
    case "days":
      return 60 * e3 * 24;
    default:
      return e3;
  }
}
function le(e3, t6) {
  return "decimal-degrees" === t6 || "points" === t6 || "unknown" === t6 ? e3 : E(e3, t6, "meters");
}
function pe(e3) {
  const { attributes: t6, geometry: r5, popupTemplate: o4, symbol: i8 } = e3.toGraphic().toJSON();
  return { attributes: t6, geometry: r5, popupInfo: o4, symbol: i8 };
}
var ue = j3.ofType(b2);
var me = j3.ofType(h);
var ce = j3.ofType(O2);
var ye = j3.ofType(g2);
var fe = j3.ofType(f4);
var de = j3.ofType(D2);
var he = "esri.layers.RouteLayer";
var we = s2.getLogger(he);
var Se = class extends n2(t3(c2(v3(O(a2(b)))))) {
  constructor(e3) {
    super(e3), this._cachedServiceDescription = null, this._featureCollection = null, this._type = "Feature Collection", this.defaultSymbols = new y4(), this.directionLines = null, this.directionPoints = null, this.featureCollectionType = "route", this.legendEnabled = false, this.maxScale = 0, this.minScale = 0, this.pointBarriers = new ce(), this.polygonBarriers = new ye(), this.polylineBarriers = new fe(), this.routeInfo = null, this.spatialReference = k.WGS84, this.stops = new de(), this.type = "route";
    const t6 = () => {
      this._setStopSymbol(this.stops);
    };
    this.addHandles(a(() => this.stops, "change", t6, { sync: true, onListenerAdd: t6 }));
  }
  writeFeatureCollectionWebmap(e3, t6, r5, o4) {
    const i8 = [this._writePolygonBarriers(), this._writePolylineBarriers(), this._writePointBarriers(), this._writeRouteInfo(), this._writeDirectionLines(), this._writeDirectionPoints(), this._writeStops()].filter((e4) => !!e4), s7 = i8.map((e4, t7) => t7), n9 = "web-map" === o4.origin ? "featureCollection.layers" : "layers";
    o(n9, i8, t6), t6.opacity = this.opacity, t6.visibility = this.visible, t6.visibleLayers = s7;
  }
  readDirectionLines(e3, t6) {
    return this._getNetworkFeatures(t6, "DirectionLines", (e4) => b2.fromGraphic(e4));
  }
  readDirectionPoints(e3, t6) {
    return this._getNetworkFeatures(t6, "DirectionPoints", (e4) => h.fromGraphic(e4));
  }
  get fullExtent() {
    var _a;
    const e3 = new w2({ xmin: -180, ymin: -90, xmax: 180, ymax: 90, spatialReference: k.WGS84 });
    if (r(this.routeInfo) && r(this.routeInfo.geometry))
      return (_a = this.routeInfo.geometry.extent) != null ? _a : e3;
    if (t(this.stops))
      return e3;
    const t6 = this.stops.filter((e4) => r(e4.geometry));
    if (t6.length < 2)
      return e3;
    const { spatialReference: r5 } = t6.getItemAt(0).geometry;
    if (t(r5))
      return e3;
    const o4 = t6.toArray().map((e4) => {
      const t7 = e4.geometry;
      return [t7.x, t7.y];
    });
    return new u({ points: o4, spatialReference: r5 }).extent;
  }
  readMaxScale(e3, t6) {
    var _a, _b;
    return (_b = (_a = (re(t6) ? t6.layers : t6.featureCollection.layers).find((e4) => r(e4.layerDefinition.maxScale))) == null ? void 0 : _a.layerDefinition.maxScale) != null ? _b : 0;
  }
  readMinScale(e3, t6) {
    var _a, _b;
    return (_b = (_a = (re(t6) ? t6.layers : t6.featureCollection.layers).find((e4) => r(e4.layerDefinition.minScale))) == null ? void 0 : _a.layerDefinition.minScale) != null ? _b : 0;
  }
  readPointBarriers(e3, t6) {
    return this._getNetworkFeatures(t6, "Barriers", (e4) => O2.fromGraphic(e4));
  }
  readPolygonBarriers(e3, t6) {
    return this._getNetworkFeatures(t6, "PolygonBarriers", (e4) => g2.fromGraphic(e4));
  }
  readPolylineBarriers(e3, t6) {
    return this._getNetworkFeatures(t6, "PolylineBarriers", (e4) => f4.fromGraphic(e4));
  }
  readRouteInfo(e3, t6) {
    const r5 = this._getNetworkFeatures(t6, "RouteInfo", (e4) => h2.fromGraphic(e4));
    return r5.length > 0 ? r5.getItemAt(0) : null;
  }
  readSpatialReference(e3, t6) {
    var _a, _b, _c, _d, _e;
    const r5 = re(t6) ? t6.layers : t6.featureCollection.layers;
    if (!r5.length)
      return k.WGS84;
    const { layerDefinition: o4, featureSet: i8 } = r5[0], s7 = i8.features[0], n9 = (_e = (_d = (_c = (_b = (_a = e(s7 == null ? void 0 : s7.geometry)) == null ? void 0 : _a.spatialReference) != null ? _b : i8.spatialReference) != null ? _c : o4.spatialReference) != null ? _d : o4.extent.spatialReference) != null ? _e : c;
    return k.fromJSON(n9);
  }
  readStops(e3, t6) {
    return this._getNetworkFeatures(t6, "Stops", (e4) => D2.fromGraphic(e4), (e4) => this._setStopSymbol(e4));
  }
  get title() {
    return r(this.routeInfo) && r(this.routeInfo.name) ? this.routeInfo.name : "Route";
  }
  set title(e3) {
    this._overrideIfSome("title", e3);
  }
  get url() {
    return s.routeServiceUrl;
  }
  set url(e3) {
    null != e3 ? this._set("url", S(e3, we)) : this._set("url", s.routeServiceUrl);
  }
  load(e3) {
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Feature Collection"] }, e3)), Promise.resolve(this);
  }
  removeAll() {
    this.removeResult(), this.pointBarriers.removeAll(), this.polygonBarriers.removeAll(), this.polylineBarriers.removeAll(), this.stops.removeAll();
  }
  removeResult() {
    r(this.directionLines) && (this.directionLines.removeAll(), this._set("directionLines", null)), r(this.directionPoints) && (this.directionPoints.removeAll(), this._set("directionPoints", null)), r(this.routeInfo) && this._set("routeInfo", null);
  }
  async save() {
    await this.load();
    const { fullExtent: e3, portalItem: t6 } = this;
    if (!t6)
      throw new s3("routelayer:portal-item-not-set", "save() requires to the layer to have a portal item");
    if (!t6.id)
      throw new s3("routelayer:portal-item-not-saved", "Please use saveAs() first to save the routelayer");
    if ("Feature Collection" !== t6.type)
      throw new s3("routelayer:portal-item-wrong-type", 'Portal item needs to have type "Feature Collection"');
    if (t(this.routeInfo))
      throw new s3("routelayer:route-unsolved", "save() requires a solved route");
    const { portal: r5 } = t6;
    await r5._signIn(), r5.user || await t6.reload();
    const { itemUrl: o4, itemControl: i8 } = t6;
    if ("admin" !== i8 && "update" !== i8)
      throw new s3("routelayer:insufficient-permissions", "To save this layer, you need to be the owner or an administrator of your organization");
    const s7 = { messages: [], origin: "portal-item", portal: r5, url: o4 && j2(o4), writtenProperties: [] }, a8 = this.write(null, s7);
    return t6.extent = await ne(e3), t6.title = this.title, await t6.update({ data: a8 }), t6;
  }
  async saveAs(e3, t6 = {}) {
    var _a, _b, _c;
    if (await this.load(), t(this.routeInfo))
      throw new s3("routelayer:route-unsolved", "saveAs() requires a solved route");
    const r5 = x.from(e3).clone();
    (_a = r5.extent) != null ? _a : r5.extent = await ne(this.fullExtent), r5.id = null, (_b = r5.portal) != null ? _b : r5.portal = j5.getDefault(), (_c = r5.title) != null ? _c : r5.title = this.title, r5.type = "Feature Collection", r5.typeKeywords = ["Data", "Feature Collection", f.MULTI_LAYER, "Route Layer"];
    const { portal: o4 } = r5, i8 = { messages: [], origin: "portal-item", portal: o4, url: null, writtenProperties: [] };
    await o4._signIn();
    const s7 = t6 == null ? void 0 : t6.folder, a8 = this.write(null, i8);
    return await o4.user.addItem({ item: r5, folder: s7, data: a8 }), this.portalItem = r5, i4(i8), i8.portalItem = r5, r5;
  }
  async solve(e3, t6) {
    var _a, _b, _c, _d, _e;
    const r5 = (_a = e3 == null ? void 0 : e3.stops) != null ? _a : this.stops, o4 = (_b = e3 == null ? void 0 : e3.pointBarriers) != null ? _b : X(this.pointBarriers), i8 = (_c = e3 == null ? void 0 : e3.polylineBarriers) != null ? _c : X(this.polylineBarriers), a8 = (_d = e3 == null ? void 0 : e3.polygonBarriers) != null ? _d : X(this.polygonBarriers);
    if (t(r5))
      throw new s3("routelayer:undefined-stops", "the route layer must have stops defined in the route parameters.");
    if ((oe(r5) || ie(r5)) && r5.features.length < 2 || j3.isCollection(r5) && r5.length < 2)
      throw new s3("routelayer:insufficent-stops", "the route layer must have two or more stops to solve a route.");
    if (j3.isCollection(r5))
      for (const s7 of r5)
        s7.routeName = null;
    const l8 = e3 == null ? void 0 : e3.apiKey, m6 = this.url, y8 = await this._getServiceDescription(m6, l8, t6), f7 = ee(y8), h3 = (_e = e3 == null ? void 0 : e3.travelMode) != null ? _e : f7, w4 = l(e3 == null ? void 0 : e3.accumulateAttributes, []);
    r(h3) && (w4.push(h3.distanceAttributeName), h3.timeAttributeName && w4.push(h3.timeAttributeName));
    const S4 = { startTime: new Date() }, g3 = { accumulateAttributes: w4, directionsOutputType: "featuresets", ignoreInvalidLocations: true, pointBarriers: o4, polylineBarriers: i8, polygonBarriers: a8, preserveFirstStop: true, preserveLastStop: true, returnBarriers: !!o4, returnDirections: true, returnPolygonBarriers: !!a8, returnPolylineBarriers: !!i8, returnRoutes: true, returnStops: true, stops: r5 }, b3 = e3 ? I.from(e3) : new I();
    for (const s7 in S4)
      null == b3[s7] && (b3[s7] = S4[s7]);
    let v6;
    b3.set(g3);
    try {
      v6 = await m5(m6, b3, t6);
    } catch (P) {
      throw j(P) ? P : new s3("routelayer:failed-route-request", "the routing request failed", { error: P });
    }
    const B = this._toRouteLayerSolution(v6);
    return this._isOverridden("title") || (this.title = l(B.routeInfo.name, "Route")), se(B, y8, b3), B;
  }
  update(e3) {
    const { stops: t6, directionLines: r5, directionPoints: o4, pointBarriers: i8, polylineBarriers: s7, polygonBarriers: n9, routeInfo: a8 } = e3;
    this.set({ stops: t6, pointBarriers: i8, polylineBarriers: s7, polygonBarriers: n9 }), this._set("directionLines", r5), this._set("directionPoints", o4), this._set("routeInfo", a8), r(a8.geometry) && (this.spatialReference = a8.geometry.spatialReference);
  }
  _getNetworkFeatures(e3, t6, n9, a8) {
    var _a, _b, _c;
    const l8 = (re(e3) ? e3.layers : e3.featureCollection.layers).find((e4) => e4.layerDefinition.name === t6);
    if (t(l8))
      return new j3();
    const { layerDefinition: m6, popupInfo: c11, featureSet: y8 } = l8, f7 = m6.drawingInfo.renderer, { features: d3 } = y8, h3 = (_c = (_b = (_a = y8.spatialReference) != null ? _a : m6.spatialReference) != null ? _b : m6.extent.spatialReference) != null ? _c : c, w4 = f7 && o3(f7), S4 = k.fromJSON(h3), g3 = d3.map((e4) => {
      var _a2, _b2, _c2;
      const i8 = g.fromJSON(e4);
      r(i8.geometry) && r(e4.geometry) && t(e4.geometry.spatialReference) && (i8.geometry.spatialReference = S4);
      const s7 = n9(i8);
      return (_b2 = s7.symbol) != null ? _b2 : s7.symbol = (_a2 = w4 == null ? void 0 : w4.getSymbol(i8)) != null ? _a2 : this._getNetworkSymbol(t6), (_c2 = s7.popupTemplate) != null ? _c2 : s7.popupTemplate = c11 && k2.fromJSON(c11), s7;
    });
    return a8 && g3.some((e4) => !e4.symbol) && a8(g3), new j3(g3);
  }
  _getNetworkSymbol(e3) {
    switch (e3) {
      case "Barriers":
        return this.defaultSymbols.pointBarriers;
      case "DirectionPoints":
        return this.defaultSymbols.directionPoints;
      case "DirectionLines":
        return this.defaultSymbols.directionLines;
      case "PolylineBarriers":
        return this.defaultSymbols.polylineBarriers;
      case "PolygonBarriers":
        return this.defaultSymbols.polygonBarriers;
      case "RouteInfo":
        return this.defaultSymbols.routeInfo;
      case "Stops":
        return null;
    }
  }
  async _getServiceDescription(e3, t6, r5) {
    if (r(this._cachedServiceDescription) && this._cachedServiceDescription.url === e3)
      return this._cachedServiceDescription.serviceDescription;
    const o4 = await p3(e3, t6, r5);
    return this._cachedServiceDescription = { serviceDescription: o4, url: e3 }, o4;
  }
  _setStopSymbol(e3) {
    if (!e3 || 0 === e3.length)
      return;
    if (t(this.defaultSymbols.stops))
      return;
    if (e3.every((e4) => r(e4.symbol)))
      return;
    const { first: t6, last: r5, middle: o4, unlocated: i8, waypoint: s7, break: n9 } = this.defaultSymbols.stops;
    if (t(this.routeInfo) || 1 === e3.length)
      return void e3.forEach((i9, s8) => {
        switch (s8) {
          case 0:
            i9.symbol = t6;
            break;
          case e3.length - 1:
            i9.symbol = r5;
            break;
          default:
            i9.symbol = o4;
        }
      });
    const a8 = e3.map((e4) => e4.sequence).filter((e4) => r(e4)), l8 = Math.min(...a8), m6 = Math.max(...a8);
    for (const p7 of e3)
      p7.sequence !== l8 ? p7.sequence !== m6 ? "ok" === p7.status || "not-located-on-closest" === p7.status ? "waypoint" !== p7.locationType ? "break" !== p7.locationType ? p7.symbol = o4 : p7.symbol = n9 : p7.symbol = s7 : p7.symbol = i8 : p7.symbol = r5 : p7.symbol = t6;
  }
  _toRouteLayerSolution(e3) {
    var _a, _b, _c, _d, _e;
    const t6 = e3.routeResults[0].stops.map((e4) => D2.fromJSON(e4.toJSON()));
    this._setStopSymbol(t6);
    const r5 = new de(t6), o4 = new ye((_a = e3.polygonBarriers) == null ? void 0 : _a.map((e4) => {
      const t7 = g2.fromJSON(e4.toJSON());
      return t7.symbol = this.defaultSymbols.polygonBarriers, t7;
    })), i8 = new fe((_b = e3.polylineBarriers) == null ? void 0 : _b.map((e4) => {
      const t7 = f4.fromJSON(e4.toJSON());
      return t7.symbol = this.defaultSymbols.polylineBarriers, t7;
    })), s7 = new ce((_c = e3.pointBarriers) == null ? void 0 : _c.map((e4) => {
      const t7 = O2.fromJSON(e4.toJSON());
      return t7.symbol = this.defaultSymbols.pointBarriers, t7;
    })), n9 = h2.fromJSON(e3.routeResults[0].route.toJSON());
    n9.symbol = this.defaultSymbols.routeInfo;
    const a8 = new me((_d = e3.routeResults[0].directionPoints) == null ? void 0 : _d.features.map((e4) => {
      const t7 = h.fromJSON(e4.toJSON());
      return t7.symbol = this.defaultSymbols.directionPoints, t7;
    }));
    return { directionLines: new ue((_e = e3.routeResults[0].directionLines) == null ? void 0 : _e.features.map((e4) => {
      const t7 = b2.fromJSON(e4.toJSON());
      return t7.symbol = this.defaultSymbols.directionLines, t7;
    })), directionPoints: a8, pointBarriers: s7, polygonBarriers: o4, polylineBarriers: i8, routeInfo: n9, stops: r5 };
  }
  _writeDirectionLines() {
    return this._writeNetworkFeatures(this.directionLines, this.defaultSymbols.directionLines, "esriGeometryPolyline", b2.fields, b2.popupInfo, "DirectionLines", "Direction Lines");
  }
  _writeDirectionPoints() {
    return this._writeNetworkFeatures(this.directionPoints, this.defaultSymbols.directionPoints, "esriGeometryPoint", h.fields, h.popupInfo, "DirectionPoints", "Direction Points");
  }
  _writeNetworkFeatures(e3, t6, r5, o4, i8, s7, n9) {
    if (t(e3) || !e3.length)
      return null;
    const a8 = this.spatialReference.toJSON(), { fullExtent: l8, maxScale: m6, minScale: c11 } = this;
    return { featureSet: { features: e3.toArray().map((e4) => pe(e4)), geometryType: r5, spatialReference: a8 }, layerDefinition: { capabilities: "Query,Update,Editing", drawingInfo: { renderer: { type: "simple", symbol: r(t6) ? t6.toJSON() : te(r5) } }, extent: l8.toJSON(), fields: o4, geometryType: r5, hasM: false, hasZ: false, maxScale: m6, minScale: c11, name: s7, objectIdField: "ObjectID", spatialReference: a8, title: n9, type: "Feature Layer", typeIdField: "" }, popupInfo: i8 };
  }
  _writePointBarriers() {
    return this._writeNetworkFeatures(this.pointBarriers, this.defaultSymbols.pointBarriers, "esriGeometryPoint", O2.fields, O2.popupInfo, "Barriers", "Point Barriers");
  }
  _writePolygonBarriers() {
    return this._writeNetworkFeatures(this.polygonBarriers, this.defaultSymbols.polygonBarriers, "esriGeometryPolygon", g2.fields, g2.popupInfo, "PolygonBarriers", "Polygon Barriers");
  }
  _writePolylineBarriers() {
    return this._writeNetworkFeatures(this.polylineBarriers, this.defaultSymbols.polylineBarriers, "esriGeometryPolyline", f4.fields, f4.popupInfo, "PolylineBarriers", "Line Barriers");
  }
  _writeRouteInfo() {
    return this._writeNetworkFeatures(r(this.routeInfo) ? new j3([this.routeInfo]) : null, this.defaultSymbols.routeInfo, "esriGeometryPolyline", h2.fields, h2.popupInfo, "RouteInfo", "Route Details");
  }
  _writeStops() {
    const e3 = this._writeNetworkFeatures(this.stops, null, "esriGeometryPoint", D2.fields, D2.popupInfo, "Stops", "Stops");
    if (t(e3))
      return null;
    const { stops: t6 } = this.defaultSymbols, r5 = r(t6) && r(t6.first) && t6.first.toJSON(), o4 = r(t6) && r(t6.middle) && t6.middle.toJSON(), i8 = r(t6) && r(t6.last) && t6.last.toJSON();
    return e3.layerDefinition.drawingInfo.renderer = { type: "uniqueValue", field1: "Sequence", defaultSymbol: o4, uniqueValueInfos: [{ value: "1", symbol: r5, label: "First Stop" }, { value: `${this.stops.length}`, symbol: i8, label: "Last Stop" }] }, e3;
  }
};
e2([y({ readOnly: true, json: { read: false, origins: { "portal-item": { write: { allowNull: true, ignoreOrigin: true } }, "web-map": { write: { overridePolicy() {
  return { allowNull: true, ignoreOrigin: null == this.portalItem };
} } } } } })], Se.prototype, "_featureCollection", void 0), e2([r2(["web-map", "portal-item"], "_featureCollection")], Se.prototype, "writeFeatureCollectionWebmap", null), e2([y({ readOnly: true, json: { read: false, origins: { "web-map": { write: { target: "type", overridePolicy() {
  return { ignoreOrigin: null != this.portalItem };
} } } } } })], Se.prototype, "_type", void 0), e2([y({ nonNullable: true, type: y4 })], Se.prototype, "defaultSymbols", void 0), e2([y({ readOnly: true })], Se.prototype, "directionLines", void 0), e2([o2(["web-map", "portal-item"], "directionLines", ["layers", "featureCollection.layers"])], Se.prototype, "readDirectionLines", null), e2([y({ readOnly: true })], Se.prototype, "directionPoints", void 0), e2([o2(["web-map", "portal-item"], "directionPoints", ["layers", "featureCollection.layers"])], Se.prototype, "readDirectionPoints", null), e2([y({ readOnly: true, json: { read: false, origins: { "web-map": { write: { ignoreOrigin: true } } } } })], Se.prototype, "featureCollectionType", void 0), e2([y({ readOnly: true })], Se.prototype, "fullExtent", null), e2([y({ json: { origins: { "web-map": { name: "featureCollection.showLegend" } }, write: true } })], Se.prototype, "legendEnabled", void 0), e2([y({ type: ["show", "hide"] })], Se.prototype, "listMode", void 0), e2([y({ type: Number, nonNullable: true, json: { write: false } })], Se.prototype, "maxScale", void 0), e2([o2(["web-map", "portal-item"], "maxScale", ["layers", "featureCollection.layers"])], Se.prototype, "readMaxScale", null), e2([y({ type: Number, nonNullable: true, json: { write: false } })], Se.prototype, "minScale", void 0), e2([o2(["web-map", "portal-item"], "minScale", ["layers", "featureCollection.layers"])], Se.prototype, "readMinScale", null), e2([y({ type: ["ArcGISFeatureLayer"], value: "ArcGISFeatureLayer" })], Se.prototype, "operationalLayerType", void 0), e2([y({ nonNullable: true, type: j3.ofType(O2) })], Se.prototype, "pointBarriers", void 0), e2([o2(["web-map", "portal-item"], "pointBarriers", ["layers", "featureCollection.layers"])], Se.prototype, "readPointBarriers", null), e2([y({ nonNullable: true, type: j3.ofType(g2) })], Se.prototype, "polygonBarriers", void 0), e2([o2(["web-map", "portal-item"], "polygonBarriers", ["layers", "featureCollection.layers"])], Se.prototype, "readPolygonBarriers", null), e2([y({ nonNullable: true, type: j3.ofType(f4) })], Se.prototype, "polylineBarriers", void 0), e2([o2(["web-map", "portal-item"], "polylineBarriers", ["layers", "featureCollection.layers"])], Se.prototype, "readPolylineBarriers", null), e2([y({ readOnly: true })], Se.prototype, "routeInfo", void 0), e2([o2(["web-map", "portal-item"], "routeInfo", ["layers", "featureCollection.layers"])], Se.prototype, "readRouteInfo", null), e2([y({ type: k })], Se.prototype, "spatialReference", void 0), e2([o2(["web-map", "portal-item"], "spatialReference", ["layers", "featureCollection.layers"])], Se.prototype, "readSpatialReference", null), e2([y({ nonNullable: true, type: j3.ofType(D2) })], Se.prototype, "stops", void 0), e2([o2(["web-map", "portal-item"], "stops", ["layers", "featureCollection.layers"])], Se.prototype, "readStops", null), e2([y()], Se.prototype, "title", null), e2([y({ readOnly: true, json: { read: false } })], Se.prototype, "type", void 0), e2([y()], Se.prototype, "url", null), Se = e2([n(he)], Se);
var ge = Se;
export {
  ge as default
};
//# sourceMappingURL=RouteLayer-F4ES2W6N.js.map
