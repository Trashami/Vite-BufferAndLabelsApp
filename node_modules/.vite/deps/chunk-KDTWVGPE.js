import {
  u
} from "./chunk-6M2AHKYV.js";
import {
  b
} from "./chunk-C5H57NTD.js";
import {
  h2 as h,
  r
} from "./chunk-3MNMDUQZ.js";

// node_modules/@arcgis/core/views/draw/support/drawUtils.js
function r2(t, n, e, r3) {
  if (null == r3 || t.hasZ || (r3 = void 0), "point" === t.type)
    return t.x += n, t.y += e, t.hasZ && null != r3 && (t.z += r3), t;
  if ("multipoint" === t.type) {
    const o = t.points;
    for (let t2 = 0; t2 < o.length; t2++)
      o[t2] = l(o[t2], n, e, r3);
    return t;
  }
  if ("extent" === t.type)
    return t.xmin += n, t.xmax += n, t.ymin += e, t.ymax += e, null != r3 && (t.zmin += r3, t.zmax += r3), t;
  const s2 = r(t), i2 = "polyline" === t.type ? t.paths : t.rings;
  for (let o = 0; o < s2.length; o++) {
    const t2 = s2[o];
    for (let o2 = 0; o2 < t2.length; o2++)
      t2[o2] = l(t2[o2], n, e, r3);
  }
  return "paths" in t ? t.paths = i2 : t.rings = i2, t;
}
function s(t, n, e, s2, i2) {
  const a2 = t.clone(), m2 = s2.resolution;
  if ("point" === a2.type) {
    if (i2)
      r2(a2, n * m2, -e * m2);
    else {
      const t2 = s2.state.transform, o = s2.state.inverseTransform, r3 = t2[0] * a2.x + t2[2] * a2.y + t2[4], i3 = t2[1] * a2.x + t2[3] * a2.y + t2[5];
      a2.x = o[0] * (r3 + n) + o[2] * (i3 + e) + o[4], a2.y = o[1] * (r3 + n) + o[3] * (i3 + e) + o[5];
    }
    return a2;
  }
  if ("multipoint" === a2.type) {
    if (i2)
      r2(a2, n * m2, -e * m2);
    else {
      const t2 = a2.points, o = s2.state.transform, r3 = s2.state.inverseTransform;
      for (let s3 = 0; s3 < t2.length; s3++) {
        const i3 = t2[s3], a3 = o[0] * i3[0] + o[2] * i3[1] + o[4], m3 = o[1] * i3[0] + o[3] * i3[1] + o[5], l2 = r3[0] * (a3 + n) + r3[2] * (m3 + e) + r3[4], p = r3[1] * (a3 + n) + r3[3] * (m3 + e) + r3[5];
        t2[s3] = x(i3, l2, p, void 0);
      }
    }
    return a2;
  }
  if ("extent" === a2.type) {
    if (i2)
      r2(a2, n * m2, -e * m2);
    else {
      const t2 = s2.state.transform, o = s2.state.inverseTransform, r3 = t2[0] * a2.xmin + t2[2] * a2.ymin + t2[4], i3 = t2[1] * a2.xmin + t2[3] * a2.ymin + t2[5], m3 = t2[0] * a2.xmax + t2[2] * a2.ymax + t2[4], l2 = t2[1] * a2.xmax + t2[3] * a2.ymax + t2[5];
      a2.xmin = o[0] * (r3 + n) + o[2] * (i3 + e) + o[4], a2.ymin = o[1] * (r3 + n) + o[3] * (i3 + e) + o[5], a2.xmax = o[0] * (m3 + n) + o[2] * (l2 + e) + o[4], a2.ymax = o[1] * (m3 + n) + o[3] * (l2 + e) + o[5];
    }
    return a2;
  }
  if (i2)
    r2(a2, n * m2, -e * m2);
  else {
    const t2 = r(a2), r3 = "polyline" === a2.type ? a2.paths : a2.rings, i3 = s2.state.transform, m3 = s2.state.inverseTransform;
    for (let o = 0; o < t2.length; o++) {
      const r4 = t2[o];
      for (let t3 = 0; t3 < r4.length; t3++) {
        const o2 = r4[t3], s3 = i3[0] * o2[0] + i3[2] * o2[1] + i3[4], a3 = i3[1] * o2[0] + i3[3] * o2[1] + i3[5], l2 = m3[0] * (s3 + n) + m3[2] * (a3 + e) + m3[4], p = m3[1] * (s3 + n) + m3[3] * (a3 + e) + m3[5];
        r4[t3] = x(o2, l2, p, void 0);
      }
    }
    "paths" in a2 ? a2.paths = r3 : a2.rings = r3;
  }
  return a2;
}
function i(t, r3, s2, i2) {
  if ("point" === t.type) {
    const { x: n, y: e } = t, o = i2 ? i2[0] : n, a3 = i2 ? i2[1] : e, m3 = t.clone(), l3 = (n - o) * r3 + o, x2 = (e - a3) * s2 + a3;
    return m3.x = l3, m3.y = x2, m3;
  }
  if ("multipoint" === t.type) {
    const a3 = r(t), m3 = u(), [l3, p2, y2, f2] = h(m3, [a3]), u3 = i2 ? i2[0] : (l3 + y2) / 2, c2 = i2 ? i2[1] : (f2 + p2) / 2, h3 = t.clone(), g2 = h3.points;
    for (let t2 = 0; t2 < g2.length; t2++) {
      const n = g2[t2], [e, o] = n, i3 = (e - u3) * r3 + u3, a4 = (o - c2) * s2 + c2;
      g2[t2] = x(n, i3, a4, void 0);
    }
    return h3;
  }
  if ("extent" === t.type) {
    const { xmin: n, xmax: e, ymin: o, ymax: a3 } = t, m3 = i2 ? i2[0] : (n + e) / 2, l3 = i2 ? i2[1] : (a3 + o) / 2, x2 = t.clone();
    if (x2.xmin = (n - m3) * r3 + m3, x2.ymax = (a3 - l3) * s2 + l3, x2.xmax = (e - m3) * r3 + m3, x2.ymin = (o - l3) * s2 + l3, x2.xmin > x2.xmax) {
      const t2 = x2.xmin, n2 = x2.xmax;
      x2.xmin = n2, x2.xmax = t2;
    }
    if (x2.ymin > x2.ymax) {
      const t2 = x2.ymin, n2 = x2.ymax;
      x2.ymin = n2, x2.ymax = t2;
    }
    return x2;
  }
  const a2 = r(t), m2 = u(), [l2, p, y, f] = h(m2, a2), u2 = i2 ? i2[0] : (l2 + y) / 2, c = i2 ? i2[1] : (f + p) / 2, h2 = t.clone(), g = "polyline" === h2.type ? h2.paths : h2.rings;
  for (let n = 0; n < a2.length; n++) {
    const t2 = a2[n];
    for (let e = 0; e < t2.length; e++) {
      const o = t2[e], [i3, a3] = o, m3 = (i3 - u2) * r3 + u2, l3 = (a3 - c) * s2 + c;
      g[n][e] = x(o, m3, l3, void 0);
    }
  }
  return "paths" in h2 ? h2.paths = g : h2.rings = g, h2;
}
function a(t, n, e, o, r3, s2) {
  const i2 = Math.sqrt((e - t) * (e - t) + (o - n) * (o - n));
  return Math.sqrt((r3 - t) * (r3 - t) + (s2 - n) * (s2 - n)) / i2;
}
function m(n, e, o) {
  const r3 = Math.atan2(e.y - o.y, e.x - o.x) - Math.atan2(n.y - o.y, n.x - o.x), s2 = Math.atan2(Math.sin(r3), Math.cos(r3));
  return b(s2);
}
function l(t, n, e, o) {
  return x(t, t[0] + n, t[1] + e, null != t[2] && null != o ? t[2] + o : void 0);
}
function x(t, n, e, o) {
  const r3 = [n, e];
  return t.length > 2 && r3.push(null != o ? o : t[2]), t.length > 3 && r3.push(t[3]), r3;
}

export {
  r2 as r,
  s,
  i,
  a,
  m
};
//# sourceMappingURL=chunk-KDTWVGPE.js.map
