import {
  I as I2,
  P,
  n,
  t as t3,
  v as v4
} from "./chunk-3XRZHFYO.js";
import {
  t as t2
} from "./chunk-OP2HNSVZ.js";
import {
  A,
  a as a2,
  c as c2,
  f as f3,
  l,
  o as o2,
  q
} from "./chunk-O5HVKKEP.js";
import {
  E as E2,
  F,
  v as v3,
  z
} from "./chunk-NWERINOI.js";
import {
  M,
  f as f2,
  g
} from "./chunk-OEFH2SLX.js";
import {
  nt
} from "./chunk-TJ2I6XQT.js";
import {
  v as v2
} from "./chunk-NCXAKZRR.js";
import {
  F as F2
} from "./chunk-LT5KLTS5.js";
import {
  r as r3
} from "./chunk-7Q5M7ANT.js";
import {
  h as h2,
  r as r2
} from "./chunk-N43PI2UO.js";
import {
  $
} from "./chunk-WJCI2CGX.js";
import {
  C,
  a,
  f,
  w
} from "./chunk-XMZAPOBR.js";
import {
  i
} from "./chunk-DER356EU.js";
import {
  o,
  u as u2
} from "./chunk-6M2AHKYV.js";
import {
  u,
  v,
  y as y2
} from "./chunk-EHPBHJYZ.js";
import {
  c2 as c
} from "./chunk-3MNMDUQZ.js";
import {
  E,
  I
} from "./chunk-LNZAOBFW.js";
import {
  s as s2
} from "./chunk-LIZHLHNA.js";
import {
  y
} from "./chunk-HVKDYDPP.js";
import {
  b,
  x
} from "./chunk-6QC7MLLS.js";
import {
  h,
  r,
  s,
  t
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/layers/graphics/data/QueryEngine.js
function V(e) {
  return e.every((e2) => "exceedslimit" !== e2.statisticType);
}
var W = "feature-store:unsupported-query";
var K = new h2(2e6);
var X = 0;
var Y = class {
  constructor(e) {
    this.capabilities = { query: t2 }, this.geometryType = e.geometryType, this.hasM = e.hasM, this.hasZ = e.hasZ, this.objectIdField = e.objectIdField, this.spatialReference = e.spatialReference, this.definitionExpression = e.definitionExpression, this.featureStore = e.featureStore, this.aggregateAdapter = e.aggregateAdapter, this._changeHandle = this.featureStore.events.on("changed", () => this.clearCache()), this.timeInfo = e.timeInfo, e.cacheSpatialQueries && (this._geometryQueryCache = new r2(X++ + "$$", K)), this.fieldsIndex = new r3(e.fields), e.scheduler && e.priority && (this._frameTask = e.scheduler.registerTask(e.priority));
  }
  destroy() {
    this._frameTask = h(this._frameTask), this.clearCache(), s(this._geometryQueryCache), this._changeHandle = h(this._changeHandle), s(this.fieldsIndex);
  }
  get featureAdapter() {
    return this.featureStore.featureAdapter;
  }
  get fullExtent() {
    const e = this.featureStore.fullBounds;
    return t(e) ? null : { xmin: e[0], ymin: e[1], xmax: e[2], ymax: e[3], spatialReference: E2(this.spatialReference) };
  }
  get timeExtent() {
    return this.timeInfo ? (this._timeExtent || (this._timeExtent = t3(this.timeInfo, this.featureStore)), this._timeExtent) : null;
  }
  clearCache() {
    var _a;
    (_a = this._geometryQueryCache) == null ? void 0 : _a.clear(), this._allItems = null, this._timeExtent = null;
  }
  async executeQuery(e, t4) {
    try {
      return (await this._executeQuery(e, {}, t4)).createQueryResponse();
    } catch (i2) {
      if (i2 !== F)
        throw i2;
      return new A([], e, this).createQueryResponse();
    }
  }
  async executeQueryForCount(e = {}, t4) {
    try {
      return (await this._executeQuery(e, { returnGeometry: false, returnCentroid: false, outSR: null }, t4)).createQueryResponseForCount();
    } catch (i2) {
      if (i2 !== F)
        throw i2;
      return 0;
    }
  }
  async executeQueryForExtent(e, t4) {
    const i2 = e.outSR;
    try {
      const s3 = await this._executeQuery(e, { returnGeometry: true, returnCentroid: false, outSR: null }, t4), r4 = s3.size;
      if (!r4)
        return { count: 0, extent: null };
      w(te, C), this.featureStore.forEachBounds(s3.items, (e2) => f(te, e2), ee);
      const a3 = { xmin: te[0], ymin: te[1], xmax: te[3], ymax: te[4], spatialReference: E2(this.spatialReference) };
      this.hasZ && isFinite(te[2]) && isFinite(te[5]) && (a3.zmin = te[2], a3.zmax = te[5]);
      const n2 = g(a3, s3.spatialReference, i2);
      if (n2.spatialReference = E2(i2 || this.spatialReference), n2.xmax - n2.xmin == 0) {
        const e2 = $(n2.spatialReference);
        n2.xmin -= e2, n2.xmax += e2;
      }
      if (n2.ymax - n2.ymin == 0) {
        const e2 = $(n2.spatialReference);
        n2.ymin -= e2, n2.ymax += e2;
      }
      if (this.hasZ && null != n2.zmin && null != n2.zmax && n2.zmax - n2.zmin == 0) {
        const e2 = $(n2.spatialReference);
        n2.zmin -= e2, n2.zmax += e2;
      }
      return { count: r4, extent: n2 };
    } catch (s3) {
      if (s3 === F)
        return { count: 0, extent: null };
      throw s3;
    }
  }
  async executeQueryForIds(e, t4) {
    return this.executeQueryForIdSet(e, t4).then((e2) => Array.from(e2));
  }
  async executeQueryForIdSet(e, t4) {
    try {
      const i2 = await this._executeQuery(e, { returnGeometry: true, returnCentroid: false, outSR: null }, t4), s3 = i2.items, r4 = /* @__PURE__ */ new Set();
      return await this._reschedule(() => {
        for (const e2 of s3)
          r4.add(i2.featureAdapter.getObjectId(e2));
      }, t4), r4;
    } catch (i2) {
      if (i2 === F)
        return /* @__PURE__ */ new Set();
      throw i2;
    }
  }
  async executeQueryForSnapping(e, t4) {
    const { point: i2, distance: s3, types: r4 } = e;
    if (r4 === q.NONE)
      return { candidates: [] };
    const a3 = await this._reschedule(() => this._checkQuerySupport(e.query), t4), o3 = !E(i2.spatialReference, this.spatialReference);
    o3 && await f2(i2.spatialReference, this.spatialReference);
    const u3 = "number" == typeof s3 ? s3 : s3.x, c3 = "number" == typeof s3 ? s3 : s3.y, h3 = { xmin: i2.x - u3, xmax: i2.x + u3, ymin: i2.y - c3, ymax: i2.y + c3, spatialReference: i2.spatialReference }, l2 = o3 ? g(h3, this.spatialReference) : h3;
    if (!l2)
      return { candidates: [] };
    const f4 = (await v2(v(i2), null, { signal: t4 }))[0], m = (await v2(v(l2), null, { signal: t4 }))[0];
    if (t(f4) || t(m))
      return { candidates: [] };
    const p = new A(this._searchFeatures(this._getQueryBBoxes(m.toJSON())), a3, this);
    await this._reschedule(() => this._executeObjectIdsQuery(p), t4), await this._reschedule(() => this._executeTimeQuery(p), t4), await this._reschedule(() => this._executeAttributesQuery(p), t4);
    const d = f4.toJSON(), y3 = o3 ? g(d, this.spatialReference) : d, g2 = o3 ? Math.max(l2.xmax - l2.xmin, l2.ymax - l2.ymin) / 2 : s3;
    return p.createSnappingResponse({ ...e, point: y3, distance: g2 }, i2.spatialReference);
  }
  async executeQueryForLatestObservations(e, t4) {
    if (!this.timeInfo || !this.timeInfo.trackIdField)
      throw new s2(W, "Missing timeInfo or timeInfo.trackIdField", { query: e, timeInfo: this.timeInfo });
    try {
      const i2 = await this._executeQuery(e, {}, t4);
      return await this._reschedule(() => this._filterLatest(i2), t4), i2.createQueryResponse();
    } catch (s3) {
      if (s3 !== F)
        throw s3;
      return new A([], e, this).createQueryResponse();
    }
  }
  async executeQueryForSummaryStatistics(e = {}, t4, i2) {
    const { field: s3, normalizationField: r4, valueExpression: a3 } = t4;
    return (await this._getQueryEngineResultForStats(e, { field: s3, normalizationField: r4, valueExpression: a3 }, i2)).createSummaryStatisticsResponse(t4);
  }
  async executeQueryForUniqueValues(e = {}, t4, i2) {
    const { field: s3, field2: r4, field3: a3, valueExpression: n2 } = t4;
    return (await this._getQueryEngineResultForStats(e, { field: s3, field2: r4, field3: a3, valueExpression: n2 }, i2)).createUniqueValuesResponse(t4);
  }
  async executeQueryForClassBreaks(e = {}, t4, i2) {
    const { field: s3, normalizationField: r4, valueExpression: a3 } = t4;
    return (await this._getQueryEngineResultForStats(e, { field: s3, normalizationField: r4, valueExpression: a3 }, i2)).createClassBreaksResponse(t4);
  }
  async executeQueryForHistogram(e = {}, t4, i2) {
    const { field: s3, normalizationField: r4, valueExpression: a3 } = t4;
    return (await this._getQueryEngineResultForStats(e, { field: s3, normalizationField: r4, valueExpression: a3 }, i2)).createHistogramResponse(t4);
  }
  async _schedule(e, t4) {
    return r(this._frameTask) ? this._frameTask.schedule(e, t4) : e(F2);
  }
  async _reschedule(e, t4) {
    return r(this._frameTask) ? this._frameTask.reschedule(e, t4) : e(F2);
  }
  _getAll(e) {
    return t(this._allItems) && (this._allItems = this.featureStore.toArray()), new A(this._allItems, e, this);
  }
  async _executeQuery(e, t4, i2) {
    e = y(e), e = await this._schedule(() => z(e, this.definitionExpression, this.spatialReference), i2), e = await this._reschedule(() => this._checkQuerySupport(e), i2), e = { ...e, ...t4 };
    const r4 = await this._reschedule(() => this._executeSceneFilterQuery(e, i2), i2), a3 = await this._reschedule(() => this._executeGeometryQuery(e, r4, i2), i2);
    return await this._reschedule(() => this._executeAggregateIdsQuery(a3), i2), await this._reschedule(() => this._executeObjectIdsQuery(a3), i2), await this._reschedule(() => this._executeTimeQuery(a3), i2), await this._reschedule(() => this._executeAttributesQuery(a3), i2), a3;
  }
  async _executeSceneFilterQuery(e, t4) {
    if (t(e.sceneFilter))
      return null;
    const { outSR: i2, returnGeometry: s3, returnCentroid: r4 } = e, a3 = this.featureStore.featureSpatialReference, o3 = e.sceneFilter.geometry, u3 = t(a3) || E(a3, o3.spatialReference) ? o3 : g(o3, a3);
    if (!u3)
      return null;
    const c3 = s3 || r4, h3 = I(i2) && !E(this.spatialReference, i2) && c3 ? async (e2) => this._project(e2, i2) : (e2) => e2, l2 = this.featureAdapter, f4 = this._searchFeatures(this._getQueryBBoxes(u3));
    if ("disjoint" === e.sceneFilter.spatialRelationship) {
      if (!f4.length)
        return null;
      const i3 = /* @__PURE__ */ new Set();
      for (const e2 of f4)
        i3.add(l2.getObjectId(e2));
      const s4 = await this._reschedule(() => this.featureStore.toArray(), t4), r5 = await this._reschedule(async () => {
        const r6 = await v4("esriSpatialRelDisjoint", u3, this.geometryType, this.hasZ, this.hasM), a4 = (e2) => !i3.has(l2.getObjectId(e2)) || r6(l2.getGeometry(e2)), n2 = await this._runSpatialFilter(s4, a4, t4);
        return new A(n2, e, this);
      }, t4);
      return h3(r5);
    }
    if (!f4.length)
      return new A([], e, this);
    if (this._canExecuteSinglePass(u3, e))
      return h3(new A(f4, e, this));
    const m = await v4("esriSpatialRelContains", u3, this.geometryType, this.hasZ, this.hasM), p = await this._runSpatialFilter(f4, (e2) => m(l2.getGeometry(e2)), t4);
    return h3(new A(p, e, this));
  }
  async _executeGeometryQuery(i2, s3, r4) {
    if (r(s3) && 0 === s3.items.length)
      return s3;
    i2 = r(s3) ? s3.query : i2;
    const { geometry: a3, outSR: u3, spatialRel: c3, returnGeometry: h3, returnCentroid: l2 } = i2, f4 = this.featureStore.featureSpatialReference, m = !a3 || t(f4) || E(f4, a3.spatialReference) ? a3 : g(a3, f4), p = h3 || l2, d = I(u3) && !E(this.spatialReference, u3), y3 = this._geometryQueryCache && t(s3) ? d && p ? JSON.stringify({ originalFilterGeometry: a3, spatialRelationship: c3, outSpatialReference: u3 }) : JSON.stringify({ originalFilterGeometry: a3, spatialRelationship: c3 }) : null, g2 = y3 ? this._geometryQueryCache.get(y3) : null;
    if (r(g2))
      return new A(g2, i2, this);
    const x2 = async (e) => (d && p && await this._project(e, u3), y3 && this._geometryQueryCache.put(y3, e.items, e.items.length + 1), e);
    if (!m)
      return x2(r(s3) ? s3 : this._getAll(i2));
    const _ = this.featureAdapter;
    let w2 = this._searchFeatures(this._getQueryBBoxes(a3));
    if ("esriSpatialRelDisjoint" === c3) {
      if (!w2.length)
        return x2(r(s3) ? s3 : this._getAll(i2));
      const e = /* @__PURE__ */ new Set();
      for (const i3 of w2)
        e.add(_.getObjectId(i3));
      const t4 = r(s3) ? s3.items : await this._reschedule(() => this.featureStore.toArray(), r4), a4 = await this._reschedule(async () => {
        const s4 = await v4(c3, m, this.geometryType, this.hasZ, this.hasM), a5 = (t5) => !e.has(_.getObjectId(t5)) || s4(_.getGeometry(t5)), n2 = await this._runSpatialFilter(t4, a5, r4);
        return new A(n2, i2, this);
      }, r4);
      return x2(a4);
    }
    if (r(s3)) {
      const i3 = new x();
      w2 = w2.filter((e) => b(s3.items, e, s3.items.length, i3) >= 0);
    }
    if (!w2.length) {
      const e = new A([], i2, this);
      return y3 && this._geometryQueryCache.put(y3, e.items, 1), e;
    }
    if (this._canExecuteSinglePass(m, i2))
      return x2(new A(w2, i2, this));
    const S = await v4(c3, m, this.geometryType, this.hasZ, this.hasM), Q = await this._runSpatialFilter(w2, (e) => S(_.getGeometry(e)), r4);
    return x2(new A(Q, i2, this));
  }
  _executeAggregateIdsQuery(e) {
    if (0 === e.items.length || !e.query.aggregateIds || !e.query.aggregateIds.length || t(this.aggregateAdapter))
      return;
    const t4 = /* @__PURE__ */ new Set();
    for (const s3 of e.query.aggregateIds) {
      this.aggregateAdapter.getFeatureObjectIds(s3).forEach((e2) => t4.add(e2));
    }
    const i2 = this.featureAdapter.getObjectId;
    e.items = e.items.filter((e2) => t4.has(i2(e2)));
  }
  _executeObjectIdsQuery(e) {
    if (0 === e.items.length || !e.query.objectIds || !e.query.objectIds.length)
      return;
    const t4 = new Set(e.query.objectIds), i2 = this.featureAdapter.getObjectId;
    e.items = e.items.filter((e2) => t4.has(i2(e2)));
  }
  _executeTimeQuery(e) {
    if (0 === e.items.length)
      return;
    const t4 = n(this.timeInfo, e.query.timeExtent, this.featureAdapter);
    t(t4) || (e.items = e.items.filter(t4));
  }
  _executeAttributesQuery(e) {
    if (0 === e.items.length)
      return;
    const t4 = l(e.query.where, this.fieldsIndex);
    if (t4) {
      if (!t4.isStandardized)
        throw new TypeError("Where clause is not standardized");
      e.items = e.items.filter((e2) => t4.testFeature(e2, this.featureAdapter));
    }
  }
  async _runSpatialFilter(e, t4, i2) {
    if (!t4)
      return e;
    if (t(this._frameTask))
      return e.filter((e2) => t4(e2));
    let s3 = 0;
    const r4 = new Array(), a3 = async (n2) => {
      for (; s3 < e.length; ) {
        const o3 = e[s3++];
        t4(o3) && (r4.push(o3), n2.madeProgress()), n2.done && await this._reschedule((e2) => a3(e2), i2);
      }
    };
    return this._reschedule((e2) => a3(e2), i2).then(() => r4);
  }
  _filterLatest(e) {
    const { trackIdField: t4, startTimeField: i2, endTimeField: s3 } = this.timeInfo, r4 = s3 || i2, a3 = /* @__PURE__ */ new Map(), n2 = this.featureAdapter.getAttribute;
    for (const o3 of e.items) {
      const e2 = n2(o3, t4), i3 = n2(o3, r4), s4 = a3.get(e2);
      (!s4 || i3 > n2(s4, r4)) && a3.set(e2, o3);
    }
    e.items = Array.from(a3.values());
  }
  _canExecuteSinglePass(e, t4) {
    const { spatialRel: i2 } = t4;
    return I2(e) && ("esriSpatialRelEnvelopeIntersects" === i2 || "esriGeometryPoint" === this.geometryType && ("esriSpatialRelIntersects" === i2 || "esriSpatialRelContains" === i2 || "esriSpatialRelWithin" === i2));
  }
  async _project(e, t4) {
    if (!t4 || E(this.spatialReference, t4))
      return e;
    const i2 = this.featureAdapter, s3 = await M(e.items.map((e2) => v3(this.geometryType, this.hasZ, this.hasM, i2.getGeometry(e2))), this.spatialReference, t4);
    return e.items = s3.map((t5, s4) => i2.cloneWithGeometry(e.items[s4], nt(t5, this.hasZ, this.hasM))), e;
  }
  _getQueryBBoxes(e) {
    if (I2(e)) {
      if (u(e))
        return [o(e.xmin, e.ymin, e.xmax, e.ymax)];
      if (y2(e))
        return e.rings.map((e2) => o(Math.min(e2[0][0], e2[2][0]), Math.min(e2[0][1], e2[2][1]), Math.max(e2[0][0], e2[2][0]), Math.max(e2[0][1], e2[2][1])));
    }
    return [c(u2(), e)];
  }
  _searchFeatures(e) {
    for (const i2 of e)
      this.featureStore.forEachInBounds(i2, (e2) => ie.add(e2));
    const t4 = Array.from(ie.values());
    return ie.clear(), t4;
  }
  async _checkStatisticsSupport(e, t4) {
    if (e.distance < 0 || null != e.geometryPrecision || e.multipatchOption || e.pixelSize || e.relationParam || e.text || e.outStatistics || e.groupByFieldsForStatistics || e.having || e.orderByFields)
      throw new s2(W, "Unsupported query options", { query: e });
    return this._checkAttributesQuerySupport(e), Promise.all([this._checkStatisticsParamsSupport(t4), P(e, this.geometryType, this.spatialReference), f2(this.spatialReference, e.outSR)]).then(() => e);
  }
  async _checkStatisticsParamsSupport(e) {
    let t4 = [];
    if (e.valueExpression) {
      const { arcadeUtils: i2 } = await i();
      t4 = i2.extractFieldNames(e.valueExpression);
    }
    if (e.field && t4.push(e.field), e.field2 && t4.push(e.field2), e.field3 && t4.push(e.field3), e.normalizationField && t4.push(e.normalizationField), !t4.length)
      throw new s2(W, "params should have at least a field or valueExpression", { params: e });
    c2(this.fieldsIndex, t4, "params contains missing fields");
  }
  async _checkQuerySupport(e) {
    if (e.distance < 0 || null != e.geometryPrecision || e.multipatchOption || e.pixelSize || e.relationParam || e.text)
      throw new s2(W, "Unsupported query options", { query: e });
    return this._checkAttributesQuerySupport(e), this._checkStatisticsQuerySupport(e), Promise.all([P(e, this.geometryType, this.spatialReference), f2(this.spatialReference, e.outSR)]).then(() => e);
  }
  _checkAttributesQuerySupport(e) {
    const { outFields: t4, orderByFields: s3, returnDistinctValues: r4, outStatistics: a3 } = e, n2 = a3 ? a3.map((e2) => e2.outStatisticFieldName && e2.outStatisticFieldName.toLowerCase()).filter(Boolean) : [];
    if (s3 && s3.length > 0) {
      const e2 = " asc", t5 = " desc", i2 = s3.map((i3) => {
        const s4 = i3.toLowerCase();
        return s4.includes(e2) ? s4.split(e2)[0] : s4.includes(t5) ? s4.split(t5)[0] : i3;
      }).filter((e3) => !n2.includes(e3));
      c2(this.fieldsIndex, i2, "orderByFields contains missing fields");
    }
    if (t4 && t4.length > 0)
      c2(this.fieldsIndex, t4, "outFields contains missing fields");
    else if (r4)
      throw new s2(W, "outFields should be specified for returnDistinctValues", { query: e });
    o2(this.fieldsIndex, e.where);
  }
  _checkStatisticsQuerySupport(e) {
    const { outStatistics: t4, groupByFieldsForStatistics: s3, having: r4 } = e, a3 = s3 && s3.length, n2 = t4 && t4.length;
    if (r4) {
      if (!a3 || !n2)
        throw new s2(W, "outStatistics and groupByFieldsForStatistics should be specified with having", { query: e });
      a2(this.fieldsIndex, r4, t4);
    }
    if (n2) {
      if (!V(t4))
        return;
      const r5 = t4.map((e2) => e2.onStatisticField).filter(Boolean);
      c2(this.fieldsIndex, r5, "onStatisticFields contains missing fields"), a3 && c2(this.fieldsIndex, s3, "groupByFieldsForStatistics contains missing fields");
      for (const s4 of t4) {
        const { onStatisticField: t5, statisticType: r6 } = s4;
        if (("percentile_disc" === r6 || "percentile_cont" === r6) && "statisticParameters" in s4) {
          const { statisticParameters: t6 } = s4;
          if (!t6)
            throw new s2(W, "statisticParamters should be set for percentile type", { definition: s4, query: e });
        } else if ("count" !== r6 && t5 && f3(t5, this.fieldsIndex))
          throw new s2(W, "outStatistics contains non-numeric fields", { definition: s4, query: e });
      }
    }
  }
  async _getQueryEngineResultForStats(e, t4, i2) {
    e = y(e);
    try {
      e = await this._schedule(() => z(e, this.definitionExpression, this.spatialReference), i2), e = await this._reschedule(() => this._checkStatisticsSupport(e, t4), i2);
      const s3 = await this._reschedule(() => this._executeSceneFilterQuery(e, i2), i2), r4 = await this._reschedule(() => this._executeGeometryQuery(e, s3, i2), i2);
      return await this._reschedule(() => this._executeAggregateIdsQuery(r4), i2), await this._reschedule(() => this._executeObjectIdsQuery(r4), i2), await this._reschedule(() => this._executeTimeQuery(r4), i2), await this._reschedule(() => this._executeAttributesQuery(r4), i2), r4;
    } catch (r4) {
      if (r4 !== F)
        throw r4;
      return new A([], e, this);
    }
  }
};
var ee = a();
var te = a();
var ie = /* @__PURE__ */ new Set();

export {
  Y
};
//# sourceMappingURL=chunk-EQTVTD33.js.map
