import {
  a as a2,
  f as f2,
  g as g2,
  m,
  w
} from "./chunk-NE5VVZO2.js";
import {
  u
} from "./chunk-UFNJIQA6.js";
import "./chunk-Z5PNFOTJ.js";
import {
  Y
} from "./chunk-EQTVTD33.js";
import "./chunk-3XRZHFYO.js";
import "./chunk-IOZMLQTF.js";
import "./chunk-P5Y67HOZ.js";
import {
  I,
  L,
  T
} from "./chunk-L6PG65Z3.js";
import {
  a,
  i as i2,
  o
} from "./chunk-WKJPACEU.js";
import "./chunk-OP2HNSVZ.js";
import "./chunk-O5HVKKEP.js";
import "./chunk-IPJF6OUC.js";
import "./chunk-NWERINOI.js";
import {
  f,
  g
} from "./chunk-OEFH2SLX.js";
import "./chunk-K3WMIXIE.js";
import "./chunk-I4YZGF7W.js";
import "./chunk-65ZBTSJX.js";
import "./chunk-FZSI6IGI.js";
import "./chunk-36RXM3AP.js";
import "./chunk-IIAN3QNN.js";
import {
  X,
  nt,
  ot,
  rt,
  tt
} from "./chunk-TJ2I6XQT.js";
import "./chunk-EDHROVWI.js";
import "./chunk-34YPGGJT.js";
import "./chunk-TWJNUVV2.js";
import "./chunk-NCXAKZRR.js";
import "./chunk-DUCSW4OU.js";
import "./chunk-WVDA5Z37.js";
import "./chunk-LT5KLTS5.js";
import "./chunk-SERWCSJG.js";
import "./chunk-RW4M3CI3.js";
import "./chunk-FFVIDMFN.js";
import {
  r as r2
} from "./chunk-7Q5M7ANT.js";
import "./chunk-A4HIS5ZJ.js";
import {
  i
} from "./chunk-BUVDI6S7.js";
import "./chunk-W62B63EU.js";
import "./chunk-N43PI2UO.js";
import {
  j as j2
} from "./chunk-HUQX7WZO.js";
import "./chunk-ZWUEORSX.js";
import "./chunk-ZPYDYUP5.js";
import "./chunk-CZBRZ6SU.js";
import "./chunk-RT3T2K4S.js";
import "./chunk-WJCI2CGX.js";
import "./chunk-XMZAPOBR.js";
import {
  M
} from "./chunk-376OPXM4.js";
import "./chunk-DER356EU.js";
import "./chunk-IWQ7452U.js";
import "./chunk-NAN5J6QS.js";
import "./chunk-6M2AHKYV.js";
import "./chunk-JUVQV3R3.js";
import "./chunk-RAX2HD42.js";
import "./chunk-ZYRIJWLX.js";
import "./chunk-C5H57NTD.js";
import "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import "./chunk-D4V6J5BT.js";
import "./chunk-OSHI574D.js";
import "./chunk-YWAQYJRC.js";
import "./chunk-B356PXLT.js";
import {
  c as c2
} from "./chunk-EHPBHJYZ.js";
import "./chunk-3MNMDUQZ.js";
import "./chunk-UWG37XSU.js";
import {
  E,
  c
} from "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import "./chunk-HLM6QCL2.js";
import "./chunk-RXYULINL.js";
import "./chunk-5NXILPDI.js";
import "./chunk-THVR7IAM.js";
import {
  U
} from "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import "./chunk-KAN4HXCG.js";
import "./chunk-VWYWOOPX.js";
import "./chunk-M5VHU5LK.js";
import "./chunk-7QMMKGW4.js";
import "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import {
  j
} from "./chunk-MJXQTGI2.js";
import {
  s as s2
} from "./chunk-LIZHLHNA.js";
import "./chunk-BTUHYGXO.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";
import "./chunk-HVKDYDPP.js";
import "./chunk-6QC7MLLS.js";
import {
  r
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/layers/graphics/sources/geojson/GeoJSONSourceWorker.js
var O = { hasAttachments: false, capabilities: "query, editing, create, delete, update", useStandardizedQueries: true, supportsCoordinatesQuantization: true, supportsReturningQueryGeometry: true, advancedQueryCapabilities: { supportsQueryAttachments: false, supportsStatistics: true, supportsPercentileStatistics: true, supportsReturningGeometryCentroid: true, supportsQueryWithDistance: true, supportsDistinct: true, supportsReturningQueryExtent: true, supportsReturningGeometryProperties: false, supportsHavingClause: true, supportsOrderBy: true, supportsPagination: true, supportsQueryWithResultType: false, supportsSqlExpression: true, supportsDisjointSpatialRel: true } };
var C = class {
  constructor() {
    this._queryEngine = null, this._snapshotFeatures = async (e) => {
      const t = await this._fetch(e);
      return this._createFeatures(t);
    };
  }
  destroy() {
    var _a;
    (_a = this._queryEngine) == null ? void 0 : _a.destroy(), this._queryEngine = this._fieldsIndex = this._createDefaultAttributes = null;
  }
  async load(e, t = {}) {
    this._loadOptions = { url: e.url, customParameters: e.customParameters };
    const i3 = [];
    await this._checkProjection(e.spatialReference);
    let r3 = null;
    e.url && (r3 = await this._fetch(t == null ? void 0 : t.signal));
    const n = L(r3, { geometryType: e.geometryType }), a3 = e.fields || n.fields || [], l = null != e.hasZ ? e.hasZ : n.hasZ, u2 = n.geometryType;
    let d = e.objectIdField || n.objectIdFieldName || "__OBJECTID";
    const p = e.spatialReference || c;
    let c3 = e.timeInfo;
    a3 === n.fields && n.unknownFields.length > 0 && i3.push({ name: "geojson-layer:unknown-field-types", message: "Some fields types couldn't be inferred from the features and were dropped", details: { unknownFields: n.unknownFields } });
    let y = new r2(a3).get(d);
    y ? ("esriFieldTypeString" !== y.type && (y.type = "esriFieldTypeOID"), y.editable = false, y.nullable = false, d = y.name) : (y = { alias: d, name: d, type: "string" === n.objectIdFieldType ? "esriFieldTypeString" : "esriFieldTypeOID", editable: false, nullable: false }, a3.unshift(y));
    const m2 = {};
    for (const o2 of a3) {
      if (null == o2.name && (o2.name = o2.alias), null == o2.alias && (o2.alias = o2.name), !o2.name)
        throw new s2("geojson-layer:invalid-field-name", "field name is missing", { field: o2 });
      if (!i.jsonValues.includes(o2.type))
        throw new s2("geojson-layer:invalid-field-type", `invalid type for field "${o2.name}"`, { field: o2 });
      if (o2.name !== y.name) {
        const e2 = M(o2);
        void 0 !== e2 && (m2[o2.name] = e2);
      }
    }
    this._fieldsIndex = new r2(a3);
    const f3 = this._fieldsIndex.requiredFields.indexOf(y);
    if (f3 > -1 && this._fieldsIndex.requiredFields.splice(f3, 1), c3) {
      if (c3.startTimeField) {
        const e2 = this._fieldsIndex.get(c3.startTimeField);
        e2 ? (c3.startTimeField = e2.name, e2.type = "esriFieldTypeDate") : c3.startTimeField = null;
      }
      if (c3.endTimeField) {
        const e2 = this._fieldsIndex.get(c3.endTimeField);
        e2 ? (c3.endTimeField = e2.name, e2.type = "esriFieldTypeDate") : c3.endTimeField = null;
      }
      if (c3.trackIdField) {
        const e2 = this._fieldsIndex.get(c3.trackIdField);
        e2 ? c3.trackIdField = e2.name : (c3.trackIdField = null, i3.push({ name: "geojson-layer:invalid-timeInfo-trackIdField", message: "trackIdField is missing", details: { timeInfo: c3 } }));
      }
      c3.startTimeField || c3.endTimeField || (i3.push({ name: "geojson-layer:invalid-timeInfo", message: "startTimeField and endTimeField are missing", details: { timeInfo: c3 } }), c3 = null);
    }
    const I2 = u2 ? o(u2) : null, j3 = { warnings: i3, featureErrors: [], layerDefinition: { ...O, drawingInfo: I2, templates: a(m2), extent: null, geometryType: u2, objectIdField: d, fields: a3, hasZ: !!l, timeInfo: c3 } };
    this._queryEngine = new Y({ fields: a3, geometryType: u2, hasM: false, hasZ: l, objectIdField: d, spatialReference: p, timeInfo: c3, featureStore: new u({ geometryType: u2, hasM: false, hasZ: l }), cacheSpatialQueries: true }), this._createDefaultAttributes = i2(m2, d);
    const w2 = await this._createFeatures(r3);
    this._objectIdGenerator = this._createObjectIdGenerator(this._queryEngine, w2);
    const T2 = this._normalizeFeatures(w2, j3.warnings, j3.featureErrors);
    if (this._queryEngine.featureStore.addMany(T2), j3.layerDefinition.extent = this._queryEngine.fullExtent, j3.layerDefinition.timeInfo) {
      const { start: e2, end: t2 } = this._queryEngine.timeExtent;
      j3.layerDefinition.timeInfo.timeExtent = [e2, t2];
    }
    return j3;
  }
  async applyEdits(e) {
    const { spatialReference: t, geometryType: s3 } = this._queryEngine;
    return await Promise.all([w(t, s3), f(e.adds, t), f(e.updates, t)]), await this._waitSnapshotComplete(), this._applyEdits(e);
  }
  async queryFeatures(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQuery(e, t.signal);
  }
  async queryFeatureCount(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForCount(e, t.signal);
  }
  async queryObjectIds(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForIds(e, t.signal);
  }
  async queryExtent(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForExtent(e, t.signal);
  }
  async querySnapping(e, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForSnapping(e, t.signal);
  }
  async refresh(e) {
    var _a;
    return this._loadOptions.customParameters = e, (_a = this._snapshotTask) == null ? void 0 : _a.abort(), this._snapshotTask = j2(this._snapshotFeatures), this._snapshotTask.promise.then((e2) => {
      this._queryEngine.featureStore.clear(), this._objectIdGenerator = this._createObjectIdGenerator(this._queryEngine, e2);
      const t = this._normalizeFeatures(e2);
      t && this._queryEngine.featureStore.addMany(t);
    }, (e2) => {
      this._queryEngine.featureStore.clear(), j(e2) || s.getLogger("esri.layers.GeoJSONLayer").error(new s2("geojson-layer:refresh", "An error occurred during refresh", { error: e2 }));
    }), await this._waitSnapshotComplete(), { extent: this._queryEngine.fullExtent, timeExtent: this._queryEngine.timeExtent };
  }
  async _createFeatures(e) {
    const { geometryType: t, hasZ: s3, objectIdField: i3 } = this._queryEngine, n = I(e, { geometryType: t, hasZ: s3, objectIdField: i3 });
    if (!E(this._queryEngine.spatialReference, c))
      for (const a3 of n)
        r(a3.geometry) && (a3.geometry = nt(g(rt(a3.geometry, this._queryEngine.geometryType, this._queryEngine.hasZ, false), c, this._queryEngine.spatialReference)));
    return n;
  }
  async _waitSnapshotComplete() {
    if (this._snapshotTask && !this._snapshotTask.finished) {
      try {
        await this._snapshotTask.promise;
      } catch {
      }
      return this._waitSnapshotComplete();
    }
  }
  async _fetch(t) {
    const { url: s3, customParameters: i3 } = this._loadOptions, r3 = (await U(s3, { responseType: "json", query: { ...i3 }, signal: t })).data;
    return await T(r3), r3;
  }
  _normalizeFeatures(e, t, s3) {
    const { objectIdField: i3 } = this._queryEngine, r3 = [];
    for (const n of e) {
      const e2 = this._createDefaultAttributes(), a3 = m(this._fieldsIndex, e2, n.attributes, true, t);
      a3 ? s3 == null ? void 0 : s3.push(a3) : (this._assignObjectId(e2, n.attributes, true), n.attributes = e2, n.objectId = e2[i3], r3.push(n));
    }
    return r3;
  }
  _applyEdits(e) {
    const { adds: t, updates: s3, deletes: i3 } = e, r3 = { addResults: [], deleteResults: [], updateResults: [], uidToObjectId: {} };
    if (t && t.length && this._applyAddEdits(r3, t), s3 && s3.length && this._applyUpdateEdits(r3, s3), i3 && i3.length) {
      for (const e2 of i3)
        r3.deleteResults.push(f2(e2));
      this._queryEngine.featureStore.removeManyById(i3);
    }
    return { extent: this._queryEngine.fullExtent, timeExtent: this._queryEngine.timeExtent, featureEditResults: r3 };
  }
  _applyAddEdits(e, t) {
    var _a;
    const { addResults: s3 } = e, { geometryType: i3, hasM: n, hasZ: o2, objectIdField: l, spatialReference: u2, featureStore: d } = this._queryEngine, c3 = [];
    for (const p of t) {
      if (p.geometry && i3 !== c2(p.geometry)) {
        s3.push(a2("Incorrect geometry type."));
        continue;
      }
      const t2 = this._createDefaultAttributes(), n2 = m(this._fieldsIndex, t2, p.attributes);
      if (n2)
        s3.push(n2);
      else {
        if (this._assignObjectId(t2, p.attributes), p.attributes = t2, null != p.uid) {
          const t3 = p.attributes[l];
          e.uidToObjectId[p.uid] = t3;
        }
        if (r(p.geometry)) {
          const e2 = (_a = p.geometry.spatialReference) != null ? _a : u2;
          p.geometry = g(g2(p.geometry, e2), e2, u2);
        }
        c3.push(p), s3.push(f2(p.attributes[l]));
      }
    }
    d.addMany(tt([], c3, i3, o2, n, l));
  }
  _applyUpdateEdits({ updateResults: e }, t) {
    var _a;
    const { geometryType: s3, hasM: i3, hasZ: n, objectIdField: o2, spatialReference: l, featureStore: u2 } = this._queryEngine;
    for (const d of t) {
      const { attributes: t2, geometry: p } = d, h = t2 && t2[o2];
      if (null == h) {
        e.push(a2(`Identifier field ${o2} missing`));
        continue;
      }
      if (!u2.has(h)) {
        e.push(a2(`Feature with object id ${h} missing`));
        continue;
      }
      const m2 = ot(u2.getFeature(h), s3, n, i3);
      if (r(p)) {
        if (s3 !== c2(p)) {
          e.push(a2("Incorrect geometry type."));
          continue;
        }
        const t3 = (_a = p.spatialReference) != null ? _a : l;
        m2.geometry = g(g2(p, t3), t3, l);
      }
      if (t2) {
        const s4 = m(this._fieldsIndex, m2.attributes, t2);
        if (s4) {
          e.push(s4);
          continue;
        }
      }
      u2.add(X(m2, s3, n, i3, o2)), e.push(f2(h));
    }
  }
  _createObjectIdGenerator(e, t) {
    const s3 = e.fieldsIndex.get(e.objectIdField);
    if ("esriFieldTypeString" === s3.type)
      return () => s3.name + "-" + Date.now().toString(16);
    let i3 = Number.NEGATIVE_INFINITY;
    for (const r3 of t)
      r3.objectId && (i3 = Math.max(i3, r3.objectId));
    return i3 = Math.max(0, i3) + 1, () => i3++;
  }
  _assignObjectId(e, t, s3 = false) {
    const i3 = this._queryEngine.objectIdField;
    e[i3] = s3 && i3 in t ? t[i3] : this._objectIdGenerator();
  }
  async _checkProjection(e) {
    try {
      await f(c, e);
    } catch {
      throw new s2("geojson-layer", "Projection not supported");
    }
  }
};
export {
  C as default
};
//# sourceMappingURL=GeoJSONSourceWorker-YOQOIOO4.js.map
