import {
  J
} from "./chunk-ZB4SIC65.js";
import {
  De,
  I,
  Z,
  _,
  e as e2,
  t,
  t2,
  te,
  w as w2,
  z
} from "./chunk-GDBM63TX.js";
import {
  rt
} from "./chunk-TJ2I6XQT.js";
import {
  v
} from "./chunk-EHPBHJYZ.js";
import {
  p,
  w
} from "./chunk-UWG37XSU.js";
import {
  e,
  r
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/arcade/Feature.js
var g = class {
  constructor() {
    this.arcadeDeclaredClass = "esri.arcade.Feature", this._optimizedGeomDefinition = null, this._geometry = null, this.attributes = null, this._layer = null, this._datesfixed = true, this.immutable = true, this._datefields = null, this.immutable = true;
  }
  static createFromGraphic(t4) {
    const e3 = new g();
    return e3._geometry = r(t4.geometry) ? t4.geometry : null, void 0 === t4.attributes || null === t4.attributes ? e3.attributes = {} : e3.attributes = t4.attributes, t4._sourceLayer ? (e3._layer = t4._sourceLayer, e3._datesfixed = false) : t4._layer ? (e3._layer = t4._layer, e3._datesfixed = false) : t4.layer && "fields" in t4.layer ? (e3._layer = t4.layer, e3._datesfixed = false) : t4.sourceLayer && "fields" in t4.sourceLayer && (e3._layer = t4.sourceLayer, e3._datesfixed = false), e3;
  }
  static createFromArcadeFeature(t4) {
    const e3 = new g();
    return e3._datesfixed = t4._datesfixed, e3.attributes = t4.attributes, e3._geometry = t4._geometry, e3._optimizedGeomDefinition = t4._optimizedGeomDefinition, t4._layer && (e3._layer = t4._layer), e3;
  }
  static createFromOptimisedFeature(t4, e3, i) {
    const s = new g();
    return s._geometry = t4.geometry ? { geometry: t4.geometry } : null, s._optimizedGeomDefinition = i, s.attributes = t4.attributes || {}, s._layer = e3, s._datesfixed = false, s;
  }
  static createFromArcadeDictionary(e3) {
    const i = new g();
    return i.attributes = e3.field("attributes"), null !== i.attributes && i.attributes instanceof J ? (i.attributes = i.attributes.attributes, null === i.attributes && (i.attributes = {})) : i.attributes = {}, i._geometry = e3.field("geometry"), null !== i._geometry && (i._geometry instanceof J ? i._geometry = g.parseGeometryFromDictionary(i._geometry) : i._geometry instanceof p || (i._geometry = null)), i;
  }
  static createFromGraphicLikeObject(t4, e3, i = null) {
    const s = new g();
    return null === e3 && (e3 = {}), s.attributes = e3, s._geometry = r(t4) ? t4 : null, s._layer = i, s._layer && (s._datesfixed = false), s;
  }
  repurposeFromGraphicLikeObject(t4, e3, i = null) {
    null === e3 && (e3 = {}), this.attributes = e3, this._geometry = t4 || null, this._layer = i, this._layer ? this._datesfixed = false : this._datesfixed = true;
  }
  castToText(t4 = false) {
    let o = "";
    false === this._datesfixed && this._fixDates();
    for (const n in this.attributes) {
      "" !== o && (o += ",");
      const l = this.attributes[n];
      null == l ? o += JSON.stringify(n) + ":null" : _(l) || Z(l) || w2(l) ? o += JSON.stringify(n) + ":" + JSON.stringify(l) : l instanceof p ? o += JSON.stringify(n) + ":" + te(l) : l instanceof t2 || l instanceof Array ? o += JSON.stringify(n) + ":" + te(l, null, t4) : l instanceof Date ? o += t4 ? JSON.stringify(n) + ":" + JSON.stringify(l.getTime()) : JSON.stringify(n) + ":" + JSON.stringify(l) : null !== l && "object" == typeof l && void 0 !== l.castToText && (o += JSON.stringify(n) + ":" + l.castToText(t4));
    }
    return '{"geometry":' + (null === this.geometry() ? "null" : te(this.geometry())) + ',"attributes":{' + o + "}}";
  }
  _fixDates() {
    if (null !== this._datefields)
      return this._datefields.length > 0 && this._fixDateFields(this._datefields), void (this._datesfixed = true);
    const t4 = [], e3 = this._layer.fields;
    for (let i = 0; i < e3.length; i++) {
      const s = e3[i], r2 = s.type;
      "date" !== r2 && "esriFieldTypeDate" !== r2 || t4.push(s.name);
    }
    this._datefields = t4, t4.length > 0 && this._fixDateFields(t4), this._datesfixed = true;
  }
  _fixDateFields(t4) {
    this.attributes = { ...this.attributes };
    for (let e3 = 0; e3 < t4.length; e3++) {
      let i = this.attributes[t4[e3]];
      if (null === i)
        ;
      else if (void 0 === i) {
        for (const s in this.attributes)
          if (s.toLowerCase() === t4[e3].toLowerCase()) {
            i = this.attributes[s], null !== i && (i instanceof Date || (this.attributes[s] = new Date(i)));
            break;
          }
      } else
        i instanceof Date || (this.attributes[t4[e3]] = new Date(i));
    }
  }
  geometry() {
    return null === this._geometry || this._geometry instanceof p || (this._optimizedGeomDefinition ? (this._geometry = e(v(rt(this._geometry, this._optimizedGeomDefinition.geometryType, this._optimizedGeomDefinition.hasZ, this._optimizedGeomDefinition.hasM))), this._geometry.spatialReference = this._optimizedGeomDefinition.spatialReference) : this._geometry = e(v(this._geometry))), this._geometry;
  }
  field(t4) {
    false === this._datesfixed && this._fixDates();
    const e3 = this.attributes[t4];
    if (void 0 !== e3)
      return e3;
    const i = t4.toLowerCase();
    for (const s in this.attributes)
      if (s.toLowerCase() === i)
        return this.attributes[s];
    if (this._hasFieldDefinition(i))
      return null;
    throw new t(null, e2.FieldNotFound, null, { key: t4 });
  }
  _hasFieldDefinition(t4) {
    if (null === this._layer)
      return false;
    for (let e3 = 0; e3 < this._layer.fields.length; e3++) {
      if (this._layer.fields[e3].name.toLowerCase() === t4)
        return true;
    }
    return false;
  }
  setField(t4, e3) {
    if (this.immutable)
      throw new t(null, e2.Immutable, null);
    if (false === I(e3))
      throw new t(null, e2.TypeNotAllowedInFeature, null);
    const i = t4.toLowerCase();
    if (void 0 === this.attributes[t4]) {
      for (const t5 in this.attributes)
        if (t5.toLowerCase() === i)
          return void (this.attributes[t5] = e3);
      this.attributes[t4] = e3;
    } else
      this.attributes[t4] = e3;
  }
  hasField(t4) {
    const e3 = t4.toLowerCase();
    if (void 0 !== this.attributes[t4])
      return true;
    for (const i in this.attributes)
      if (i.toLowerCase() === e3)
        return true;
    return !!this._hasFieldDefinition(e3);
  }
  keys() {
    let t4 = [];
    const e3 = {};
    for (const i in this.attributes)
      t4.push(i), e3[i.toLowerCase()] = 1;
    if (null !== this._layer)
      for (let i = 0; i < this._layer.fields.length; i++) {
        const s = this._layer.fields[i];
        1 !== e3[s.name.toLowerCase()] && t4.push(s.name);
      }
    return t4 = t4.sort(), t4;
  }
  static parseGeometryFromDictionary(t4) {
    const e3 = g._convertDictionaryToJson(t4, true);
    return void 0 !== e3.hasm && (e3.hasM = e3.hasm, delete e3.hasm), void 0 !== e3.hasz && (e3.hasZ = e3.hasz, delete e3.hasz), void 0 !== e3.spatialreference && (e3.spatialReference = e3.spatialreference, delete e3.spatialreference), void 0 !== e3.rings && (e3.rings = this._fixPathArrays(e3.rings, true === e3.hasZ, true === e3.hasZ)), void 0 !== e3.paths && (e3.paths = this._fixPathArrays(e3.paths, true === e3.hasZ, true === e3.hasM)), void 0 !== e3.points && (e3.points = this._fixPointArrays(e3.points, true === e3.hasZ, true === e3.hasM)), v(e3);
  }
  static _fixPathArrays(t4, i, s) {
    const r2 = [];
    if (t4 instanceof Array)
      for (let e3 = 0; e3 < t4.length; e3++)
        r2.push(this._fixPointArrays(t4[e3], i, s));
    else if (t4 instanceof t2)
      for (let e3 = 0; e3 < t4.length(); e3++)
        r2.push(this._fixPointArrays(t4.get(e3), i, s));
    return r2;
  }
  static _fixPointArrays(t4, i, s) {
    const r2 = [];
    if (t4 instanceof Array)
      for (let a = 0; a < t4.length; a++) {
        const o = t4[a];
        o instanceof w ? i && s ? r2.push([o.x, o.y, o.z, o.m]) : i ? r2.push([o.x, o.y, o.z]) : s ? r2.push([o.x, o.y, o.m]) : r2.push([o.x, o.y]) : o instanceof t2 ? r2.push(o.toArray()) : r2.push(o);
      }
    else if (t4 instanceof t2)
      for (let a = 0; a < t4.length(); a++) {
        const o = t4.get(a);
        o instanceof w ? i && s ? r2.push([o.x, o.y, o.z, o.m]) : i ? r2.push([o.x, o.y, o.z]) : s ? r2.push([o.x, o.y, o.m]) : r2.push([o.x, o.y]) : o instanceof t2 ? r2.push(o.toArray()) : r2.push(o);
      }
    return r2;
  }
  static _convertDictionaryToJson(e3, i = false) {
    const s = {};
    for (const r2 in e3.attributes) {
      let a = e3.attributes[r2];
      a instanceof J && (a = g._convertDictionaryToJson(a)), i ? s[r2.toLowerCase()] = a : s[r2] = a;
    }
    return s;
  }
  static parseAttributesFromDictionary(t4) {
    const e3 = {};
    for (const i in t4.attributes) {
      const s = t4.attributes[i];
      if (!I(s))
        throw new t(null, e2.InvalidParameter, null);
      e3[i] = s;
    }
    return e3;
  }
  static fromJson(t4) {
    let e3 = null;
    null !== t4.geometry && void 0 !== t4.geometry && (e3 = v(t4.geometry));
    const a = {};
    if (null !== t4.attributes && void 0 !== t4.attributes)
      for (const o in t4.attributes) {
        const e4 = t4.attributes[o];
        if (null === e4)
          a[o] = e4;
        else {
          if (!(w2(e4) || Z(e4) || _(e4) || z(e4)))
            throw new t(null, e2.InvalidParameter, null);
          a[o] = e4;
        }
      }
    return g.createFromGraphicLikeObject(e3, a, null);
  }
  fullSchema() {
    return this._layer;
  }
  gdbVersion() {
    if (null === this._layer)
      return "";
    const t4 = this._layer.gdbVersion;
    return void 0 === t4 ? "" : "" === t4 && this._layer.capabilities && this._layer.capabilities.isVersioned ? "SDE.DEFAULT" : t4;
  }
  castAsJson(t4) {
    const e3 = { attributes: {}, geometry: true === (t4 == null ? void 0 : t4.keepGeometryType) ? this.geometry() : this.geometry().toJSON() };
    for (const i in this.attributes) {
      const s = this.attributes[i];
      void 0 !== s && (e3.attributes[i] = De(s, t4));
    }
    return e3;
  }
  async castAsJsonAsync(t4 = null, e3) {
    return this.castAsJson(e3);
  }
};

// node_modules/@arcgis/core/arcade/ArcadePortal.js
var t3 = class extends J {
  constructor(s) {
    super(), this.declaredClass = "esri.arcade.Portal", this.immutable = false, this.setField("url", s), this.immutable = true;
  }
};

export {
  g,
  t3 as t
};
//# sourceMappingURL=chunk-AKA4FJNZ.js.map
