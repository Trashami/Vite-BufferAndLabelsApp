import {
  D,
  G,
  L,
  M,
  P,
  U,
  t,
  u
} from "./chunk-3OFVLRSL.js";
import {
  r as r2
} from "./chunk-4JNOVZUK.js";
import {
  c
} from "./chunk-C5H57NTD.js";
import {
  s as s2
} from "./chunk-LIZHLHNA.js";
import {
  s2 as s
} from "./chunk-UA3YPL2R.js";
import {
  has
} from "./chunk-HVKDYDPP.js";
import {
  e,
  r
} from "./chunk-MIHB3CIK.js";

// node_modules/@arcgis/core/views/webgl/checkWebGLError.js
var o = s.getLogger("esri.views.webgl.checkWebGLError");
function t2(e2, r3) {
  switch (r3) {
    case e2.INVALID_ENUM:
      return "Invalid Enum. An unacceptable value has been specified for an enumerated argument.";
    case e2.INVALID_VALUE:
      return "Invalid Value. A numeric argument is out of range.";
    case e2.INVALID_OPERATION:
      return "Invalid Operation. The specified command is not allowed for the current state.";
    case e2.INVALID_FRAMEBUFFER_OPERATION:
      return "Invalid Framebuffer operation. The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.";
    case e2.OUT_OF_MEMORY:
      return "Out of memory. Not enough memory is left to execute the command.";
    case e2.CONTEXT_LOST_WEBGL:
      return "WebGL context has been lost";
    default:
      return "Unknown error";
  }
}
var n = !!has("enable-feature:webgl-debug");
function a() {
  return n;
}
function c2() {
  return n;
}
function u2(r3) {
  if (a()) {
    const n3 = r3.getError();
    if (n3) {
      const a2 = t2(r3, n3), c4 = new Error().stack;
      o.error(new s2("webgl-error", "WebGL error occured", { message: a2, stack: c4 }));
    }
  }
}

// node_modules/@arcgis/core/views/webgl/capabilities/isWebGL2Context.js
function n2(n3) {
  return window.WebGL2RenderingContext && n3 instanceof window.WebGL2RenderingContext;
}

// node_modules/@arcgis/core/views/webgl/Texture.js
var u3 = { target: M.TEXTURE_2D, samplingMode: L.LINEAR, wrapMode: D.REPEAT, flipped: false, hasMipmap: false, isOpaque: false, unpackAlignment: 4, preMultiplyAlpha: false, isImmutable: false };
var c3 = 4;
var E = class {
  constructor(t3, e2, i = null) {
    this._context = t3, this.type = "texture", this._glName = null, this._samplingModeDirty = false, this._wrapModeDirty = false, this._wasImmutablyAllocated = false, t3.instanceCounter.increment(t.Texture, this), this._descriptor = { ...u3, ...e2 };
    for (const r3 in u3) {
      void 0 === this._descriptor[r3] && (this._descriptor[r3] = u3[r3]);
    }
    if (t3.type !== r2.WEBGL2 && (this._descriptor.isImmutable && (this._descriptor.isImmutable = false), A(this._descriptor.target)))
      throw new Error("3D and array textures are not supported in WebGL1");
    this._descriptor.target === M.TEXTURE_CUBE_MAP ? this._setDataCubeMap(i) : this.setData(i);
  }
  get glName() {
    return this._glName;
  }
  get descriptor() {
    return this._descriptor;
  }
  get isDirty() {
    return this._samplingModeDirty || this._wrapModeDirty;
  }
  dispose() {
    this._context.gl && this._glName && (this._context.unbindTexture(this), this._context.gl.deleteTexture(this._glName), this._glName = null, this._context.instanceCounter.decrement(t.Texture, this));
  }
  release() {
    this.dispose();
  }
  resize(t3, e2) {
    const i = this._descriptor;
    if (i.width !== t3 || i.height !== e2) {
      if (this._wasImmutablyAllocated)
        throw new Error("Immutable textures can't be resized!");
      i.width = t3, i.height = e2, this._descriptor.target === M.TEXTURE_CUBE_MAP ? this._setDataCubeMap(null) : this.setData(null);
    }
  }
  _setDataCubeMap(t3 = null) {
    for (let e2 = M.TEXTURE_CUBE_MAP_POSITIVE_X; e2 <= M.TEXTURE_CUBE_MAP_NEGATIVE_Z; e2++)
      this._setData(t3, e2);
  }
  setData(t3) {
    this._setData(t3);
  }
  _setData(t3, i) {
    var _a, _b;
    if (!this._context || !this._context.gl)
      return;
    const o2 = this._context.gl;
    this._glName || (this._glName = o2.createTexture()), void 0 === t3 && (t3 = null);
    const s3 = this._descriptor, a2 = i != null ? i : s3.target, n3 = A(a2);
    null === t3 && (s3.width = s3.width || c3, s3.height = s3.height || c3, n3 && (s3.depth = (_a = s3.depth) != null ? _a : 1));
    const l = this._context.bindTexture(this, E.TEXTURE_UNIT_FOR_UPDATES);
    this._context.setActiveTexture(E.TEXTURE_UNIT_FOR_UPDATES), E._validateTexture(this._context, s3), this._configurePixelStorage(), u2(o2);
    const h = s3.pixelFormat;
    let p = (_b = s3.internalFormat) != null ? _b : this._deriveInternalFormat(h, s3.dataType);
    if (f(t3)) {
      let e2 = t3.width, i2 = t3.height;
      const l2 = 1;
      t3 instanceof HTMLVideoElement && (e2 = t3.videoWidth, i2 = t3.videoHeight), s3.width && s3.height, n3 && s3.depth, s3.isImmutable && !this._wasImmutablyAllocated && this._texStorage(a2, p, s3.hasMipmap, e2, i2, l2), this._texImage(a2, 0, p, e2, i2, l2, t3), u2(o2), s3.hasMipmap && this.generateMipmap(), void 0 === s3.width && (s3.width = e2), void 0 === s3.height && (s3.height = i2), n3 && void 0 === s3.depth && (s3.depth = l2);
    } else {
      const { width: i2, height: l2, depth: h2 } = s3;
      if (null == i2 || null == l2)
        throw new Error("Width and height must be specified!");
      if (n3 && null == h2)
        throw new Error("Depth must be specified!");
      if (s3.isImmutable && !this._wasImmutablyAllocated && this._texStorage(a2, p, s3.hasMipmap, i2, l2, h2), o2.DEPTH24_STENCIL8 && p === o2.DEPTH_STENCIL && (p = o2.DEPTH24_STENCIL8), x(t3)) {
        const e2 = t3.levels, r3 = w(a2, i2, l2, h2), n4 = Math.min(r3 - 1, e2.length - 1);
        n2(o2) ? o2.texParameteri(s3.target, o2.TEXTURE_MAX_LEVEL, n4) : s3.hasMipmap = s3.hasMipmap && r3 === e2.length;
        const _ = p;
        if (!g(_))
          throw new Error("Attempting to use compressed data with an umcompressed format!");
        this._forEachMipmapLevel((t4, i3, r4, o3) => {
          const s4 = e2[Math.min(t4, e2.length - 1)];
          this._compressedTexImage(a2, t4, _, i3, r4, o3, s4);
        }, n4);
      } else
        r(t3) ? (this._texImage(a2, 0, p, i2, l2, h2, t3), u2(o2), s3.hasMipmap && this.generateMipmap()) : this._forEachMipmapLevel((t4, e2, i3, s4) => {
          this._texImage(a2, t4, p, e2, i3, s4, null), u2(o2);
        });
    }
    E._applySamplingMode(o2, this._descriptor), E._applyWrapMode(o2, this._descriptor), E._applyAnisotropicFilteringParameters(this._context, this._descriptor), u2(o2), this._context.bindTexture(l, E.TEXTURE_UNIT_FOR_UPDATES);
  }
  updateData(t3, e2, i, r3, o2, s3, a2 = 0) {
    var _a;
    s3 || console.error("An attempt to use uninitialized data!"), this._glName || console.error("An attempt to update uninitialized texture!");
    const n3 = this._context.gl, l = this._descriptor, { pixelFormat: h, dataType: p, target: _, isImmutable: m } = l, u4 = (_a = l.internalFormat) != null ? _a : this._deriveInternalFormat(h, p);
    if (m && !this._wasImmutablyAllocated)
      throw new Error("Cannot update immutable texture before allocation!");
    const c4 = this._context.bindTexture(this, E.TEXTURE_UNIT_FOR_UPDATES, true);
    if ((e2 < 0 || i < 0 || r3 > l.width || o2 > l.height || e2 + r3 > l.width || i + o2 > l.height) && console.error("An attempt to update out of bounds of the texture!"), this._configurePixelStorage(), a2) {
      if (!n2(n3))
        return void console.error("Webgl2 must be enabled to use dataRowOffset!");
      n3.pixelStorei(n3.UNPACK_SKIP_ROWS, a2);
    }
    if (f(s3) ? n2(n3) ? n3.texSubImage2D(_, t3, e2, i, r3, o2, h, p, s3) : n3.texSubImage2D(_, t3, e2, i, h, p, s3) : x(s3) ? n3.compressedTexSubImage2D(_, t3, e2, i, r3, o2, u4, s3.levels[t3]) : n3.texSubImage2D(_, t3, e2, i, r3, o2, h, p, s3), a2) {
      if (!n2(n3))
        return void console.error("Webgl2 must be enabled to use dataRowOffset!");
      n3.pixelStorei(n3.UNPACK_SKIP_ROWS, 0);
    }
    this._context.bindTexture(c4, E.TEXTURE_UNIT_FOR_UPDATES);
  }
  updateData3D(t3, e2, i, r3, o2, s3, a2, n3) {
    var _a;
    n3 || console.error("An attempt to use uninitialized data!"), this._glName || console.error("An attempt to update uninitialized texture!");
    const l = this._context.gl;
    if (!n2(l))
      throw new Error("3D textures are not supported in WebGL1");
    const h = this._descriptor, { pixelFormat: p, dataType: _, isImmutable: m, target: u4 } = h, c4 = (_a = h.internalFormat) != null ? _a : this._deriveInternalFormat(p, _);
    if (m && !this._wasImmutablyAllocated)
      throw new Error("Cannot update immutable texture before allocation!");
    A(u4) || console.warn("Attempting to set 3D texture data on a non-3D texture");
    const T2 = this._context.bindTexture(this, E.TEXTURE_UNIT_FOR_UPDATES);
    if (this._context.setActiveTexture(E.TEXTURE_UNIT_FOR_UPDATES), (e2 < 0 || i < 0 || r3 < 0 || o2 > h.width || s3 > h.height || a2 > h.depth || e2 + o2 > h.width || i + s3 > h.height || r3 + a2 > h.depth) && console.error("An attempt to update out of bounds of the texture!"), this._configurePixelStorage(), x(n3))
      n3 = n3.levels[t3], l.compressedTexSubImage3D(u4, t3, e2, i, r3, o2, s3, a2, c4, n3);
    else {
      const h2 = n3;
      l.texSubImage3D(u4, t3, e2, i, r3, o2, s3, a2, p, _, h2);
    }
    this._context.bindTexture(T2, E.TEXTURE_UNIT_FOR_UPDATES);
  }
  generateMipmap() {
    const t3 = this._descriptor;
    if (!t3.hasMipmap) {
      if (this._wasImmutablyAllocated)
        throw new Error("Cannot add mipmaps to immutable texture after allocation");
      t3.hasMipmap = true, this._samplingModeDirty = true, E._validateTexture(this._context, t3);
    }
    t3.samplingMode === L.LINEAR ? (this._samplingModeDirty = true, t3.samplingMode = L.LINEAR_MIPMAP_NEAREST) : t3.samplingMode === L.NEAREST && (this._samplingModeDirty = true, t3.samplingMode = L.NEAREST_MIPMAP_NEAREST);
    const e2 = this._context.bindTexture(this, E.TEXTURE_UNIT_FOR_UPDATES);
    this._context.setActiveTexture(E.TEXTURE_UNIT_FOR_UPDATES);
    this._context.gl.generateMipmap(t3.target), this._context.bindTexture(e2, E.TEXTURE_UNIT_FOR_UPDATES);
  }
  setSamplingMode(t3) {
    t3 !== this._descriptor.samplingMode && (this._descriptor.samplingMode = t3, this._samplingModeDirty = true);
  }
  setWrapMode(t3) {
    t3 !== this._descriptor.wrapMode && (this._descriptor.wrapMode = t3, E._validateTexture(this._context, this._descriptor), this._wrapModeDirty = true);
  }
  applyChanges() {
    const t3 = this._context.gl, e2 = this._descriptor;
    this._samplingModeDirty && (E._applySamplingMode(t3, e2), this._samplingModeDirty = false), this._wrapModeDirty && (E._applyWrapMode(t3, e2), this._wrapModeDirty = false);
  }
  _deriveInternalFormat(t3, e2) {
    if (this._context.type === r2.WEBGL1)
      return t3;
    switch (e2) {
      case G.FLOAT:
        switch (t3) {
          case P.RGBA:
            return U.RGBA32F;
          case P.RGB:
            return U.RGB32F;
          default:
            throw new Error("Unable to derive format");
        }
      case G.UNSIGNED_BYTE:
        switch (t3) {
          case P.RGBA:
            return U.RGBA8;
          case P.RGB:
            return U.RGB8;
        }
      default:
        return t3;
    }
  }
  _configurePixelStorage() {
    const t3 = this._context.gl, { unpackAlignment: e2, flipped: i, preMultiplyAlpha: r3 } = this._descriptor;
    t3.pixelStorei(t3.UNPACK_ALIGNMENT, e2), t3.pixelStorei(t3.UNPACK_FLIP_Y_WEBGL, i ? 1 : 0), t3.pixelStorei(t3.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r3 ? 1 : 0);
  }
  _texStorage(t3, e2, i, r3, o2, s3) {
    const a2 = this._context.gl;
    if (!n2(a2))
      throw new Error("Immutable textures are not supported in WebGL1");
    if (!T(e2))
      throw new Error("Immutable textures must have a sized internal format");
    if (!this._descriptor.isImmutable)
      return;
    const n3 = i ? w(t3, r3, o2, s3) : 1;
    if (A(t3)) {
      if (null == s3)
        throw new Error("Missing depth dimension for 3D texture upload");
      a2.texStorage3D(t3, n3, e2, r3, o2, s3);
    } else
      a2.texStorage2D(t3, n3, e2, r3, o2);
    this._wasImmutablyAllocated = true;
  }
  _texImage(t3, r3, s3, a2, n3, l, h) {
    const p = this._context.gl;
    let _ = null;
    const m = this._context.type === r2.WEBGL2, d = A(t3), { isImmutable: u4, pixelFormat: c4, dataType: E2 } = this._descriptor;
    if (m && (_ = p), m || !f(h))
      if (u4) {
        if (r(h)) {
          const e2 = h;
          if (d) {
            if (null == l)
              throw new Error("Missing depth dimension for 3D texture upload");
            _.texSubImage3D(t3, r3, 0, 0, 0, a2, n3, l, c4, E2, e2);
          } else
            p.texSubImage2D(t3, r3, 0, 0, a2, n3, c4, E2, e2);
        }
      } else {
        const e2 = e(h);
        if (d) {
          if (null == l)
            throw new Error("Missing depth dimension for 3D texture upload");
          _.texImage3D(t3, r3, s3, a2, n3, l, 0, c4, E2, e2);
        } else
          p.texImage2D(t3, r3, s3, a2, n3, 0, c4, E2, e2);
      }
    else
      p.texImage2D(t3, 0, s3, c4, E2, h);
  }
  _compressedTexImage(t3, i, r3, s3, a2, n3, l) {
    const h = this._context.gl;
    let p = null;
    const _ = A(t3), m = this._descriptor.isImmutable;
    if (_) {
      if (this._context.type !== r2.WEBGL2)
        throw new Error("3D textures are not supported in WebGL1");
      p = h;
    }
    if (m) {
      if (r(l))
        if (_) {
          if (null == n3)
            throw new Error("Missing depth dimension for 3D texture upload");
          p.compressedTexSubImage3D(t3, i, 0, 0, 0, s3, a2, n3, r3, l);
        } else
          h.compressedTexSubImage2D(t3, i, 0, 0, s3, a2, r3, l);
    } else if (_) {
      if (null == n3)
        throw new Error("Missing depth dimension for 3D texture upload");
      p.compressedTexImage3D(t3, i, r3, s3, a2, n3, 0, l);
    } else
      h.compressedTexImage2D(t3, i, r3, s3, a2, 0, l);
  }
  _forEachMipmapLevel(t3, e2 = 1 / 0) {
    let { width: i, height: r3, depth: o2, hasMipmap: a2, target: n3 } = this._descriptor;
    const l = n3 === M.TEXTURE_3D;
    if (null == i || null == r3 || l && null == o2)
      throw new Error("Missing texture dimensions for mipmap calculation");
    for (let s3 = 0; t3(s3, i, r3, o2), a2 && (1 !== i || 1 !== r3 || l && 1 !== o2) && !(s3 >= e2); ++s3)
      i = Math.max(1, i >> 1), r3 = Math.max(1, r3 >> 1), l && (o2 = Math.max(1, o2 >> 1));
  }
  static _validateTexture(e2, i) {
    (null != i.width && i.width < 0 || null != i.height && i.height < 0 || null != i.depth && i.depth < 0) && console.error("Negative dimension parameters are not allowed!");
    const r3 = n2(e2.gl), o2 = null != i.width && c(i.width) && null != i.height && c(i.height);
    r3 || !i.isImmutable && !A(i.target) || console.error("Immutable and 3D-like textures are not supported in WebGL1!"), r3 || o2 || ("number" == typeof i.wrapMode ? i.wrapMode !== D.CLAMP_TO_EDGE && console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!") : i.wrapMode.s === D.CLAMP_TO_EDGE && i.wrapMode.t === D.CLAMP_TO_EDGE || console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"), i.hasMipmap && console.error("Mipmapping requires power-of-two textures!"));
  }
  static _applySamplingMode(t3, e2) {
    let i = e2.samplingMode, r3 = e2.samplingMode;
    i === L.LINEAR_MIPMAP_NEAREST || i === L.LINEAR_MIPMAP_LINEAR ? (i = L.LINEAR, e2.hasMipmap || (r3 = L.LINEAR)) : i !== L.NEAREST_MIPMAP_NEAREST && i !== L.NEAREST_MIPMAP_LINEAR || (i = L.NEAREST, e2.hasMipmap || (r3 = L.NEAREST)), t3.texParameteri(e2.target, t3.TEXTURE_MAG_FILTER, i), t3.texParameteri(e2.target, t3.TEXTURE_MIN_FILTER, r3);
  }
  static _applyWrapMode(t3, e2) {
    "number" == typeof e2.wrapMode ? (t3.texParameteri(e2.target, t3.TEXTURE_WRAP_S, e2.wrapMode), t3.texParameteri(e2.target, t3.TEXTURE_WRAP_T, e2.wrapMode)) : (t3.texParameteri(e2.target, t3.TEXTURE_WRAP_S, e2.wrapMode.s), t3.texParameteri(e2.target, t3.TEXTURE_WRAP_T, e2.wrapMode.t));
  }
  static _applyAnisotropicFilteringParameters(t3, e2) {
    var _a;
    const i = t3.capabilities.textureFilterAnisotropic;
    if (!i)
      return;
    t3.gl.texParameterf(e2.target, i.TEXTURE_MAX_ANISOTROPY, (_a = e2.maxAnisotropy) != null ? _a : 1);
  }
};
function T(t3) {
  return t3 in U;
}
function g(t3) {
  return t3 in u;
}
function x(t3) {
  return r(t3) && "type" in t3 && "compressed" === t3.type;
}
function M2(t3) {
  return r(t3) && "byteLength" in t3;
}
function f(t3) {
  return r(t3) && !x(t3) && !M2(t3);
}
function A(t3) {
  return t3 === M.TEXTURE_3D || t3 === M.TEXTURE_2D_ARRAY;
}
function w(t3, e2, i, r3 = 1) {
  let o2 = Math.max(e2, i);
  return t3 === M.TEXTURE_3D && (o2 = Math.max(o2, r3)), Math.round(Math.log(o2) / Math.LN2) + 1;
}
E.TEXTURE_UNIT_FOR_UPDATES = 0;

export {
  a,
  c2 as c,
  u2 as u,
  n2 as n,
  E
};
//# sourceMappingURL=chunk-MATM5L52.js.map
