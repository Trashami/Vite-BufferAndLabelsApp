import {
  T as T2,
  o as o6,
  y as y3
} from "./chunk-D7GFA2UU.js";
import {
  i as i5
} from "./chunk-QTDVBI5T.js";
import {
  oe
} from "./chunk-L26SDFYA.js";
import "./chunk-6TQO4FJO.js";
import {
  n as n9
} from "./chunk-T5JB7HTP.js";
import "./chunk-BU5AMSMP.js";
import {
  n as n10
} from "./chunk-OFHPHLJU.js";
import "./chunk-DPGI5XTT.js";
import "./chunk-QXJIQKLY.js";
import {
  m as m3,
  n as n11,
  n2 as n12,
  n3 as n13,
  t as t7,
  t2 as t8
} from "./chunk-GRWIJKD6.js";
import "./chunk-WGK2FJEK.js";
import {
  e as e7,
  e2 as e8
} from "./chunk-CNTOSDAN.js";
import "./chunk-LL5ZGGZR.js";
import "./chunk-Q5IFLFM5.js";
import "./chunk-EWYYYS2T.js";
import {
  i as i4,
  r as r8
} from "./chunk-7N2Z7KNR.js";
import {
  c as c2,
  o as o5
} from "./chunk-GOHXATVD.js";
import "./chunk-YNUWEZ4E.js";
import "./chunk-DBT4KOKX.js";
import "./chunk-4Y3VLNR2.js";
import {
  e2 as e5
} from "./chunk-MU26VSON.js";
import "./chunk-5HIF32ZE.js";
import {
  e as e4,
  n as n8,
  o as o4
} from "./chunk-57QYUXCA.js";
import "./chunk-J42Y5N2P.js";
import {
  o as o3
} from "./chunk-DWAZ7HI7.js";
import {
  i as i3
} from "./chunk-POI555WS.js";
import "./chunk-JHLU6RPN.js";
import {
  P as P2
} from "./chunk-EPMXCACW.js";
import "./chunk-UCPKJYXN.js";
import {
  t as t5
} from "./chunk-KFLNKWNF.js";
import "./chunk-KUO7OCMN.js";
import "./chunk-KG5RWWIW.js";
import "./chunk-27YO3FKC.js";
import "./chunk-XNT3PUPA.js";
import "./chunk-JMGHYNUW.js";
import "./chunk-SFYX532J.js";
import "./chunk-XBFCIW4K.js";
import {
  Ae,
  Be,
  De,
  Ee,
  Ie,
  Me,
  Ne,
  Te,
  Ue,
  _e,
  ve,
  we
} from "./chunk-6TBB7UXB.js";
import "./chunk-UO3LS2M5.js";
import {
  E as E4,
  I as I3,
  O as O3,
  S
} from "./chunk-EQNT4A7P.js";
import {
  t as t6
} from "./chunk-ESF7LLEL.js";
import {
  s as s7
} from "./chunk-AAL2O6PB.js";
import "./chunk-IOZMLQTF.js";
import {
  T
} from "./chunk-L553EHL3.js";
import "./chunk-2GP5D74I.js";
import "./chunk-R24MO4IV.js";
import "./chunk-YQBYWPBD.js";
import {
  d as d3
} from "./chunk-QISOH77W.js";
import {
  B as B2,
  C as C2,
  I as I2,
  J,
  N,
  O as O2,
  U as U2,
  V as V2,
  Y as Y2,
  bt,
  et,
  wt,
  xt,
  y as y2,
  z
} from "./chunk-XO5VJRK4.js";
import "./chunk-5SEVEYDG.js";
import "./chunk-OAXPH6DL.js";
import {
  t as t3
} from "./chunk-XTFH7327.js";
import "./chunk-MOPTUDCV.js";
import "./chunk-6VLXCUNV.js";
import "./chunk-D2XA6Z6P.js";
import "./chunk-MYQCUAHK.js";
import {
  E2 as E3,
  a as a7,
  s as s6,
  x
} from "./chunk-O4DPVR3F.js";
import {
  E as E2
} from "./chunk-MATM5L52.js";
import {
  t as t4
} from "./chunk-4OM3EX6P.js";
import "./chunk-A22ACVMF.js";
import "./chunk-OS7L4DDX.js";
import {
  B,
  C,
  D as D2,
  E,
  F,
  G,
  I,
  L,
  M as M2,
  O,
  P,
  R,
  V,
  Y
} from "./chunk-3OFVLRSL.js";
import "./chunk-UWKVAZQ6.js";
import "./chunk-FV3CMB37.js";
import "./chunk-4HL6BBWO.js";
import "./chunk-OEFH2SLX.js";
import "./chunk-I4YZGF7W.js";
import "./chunk-FZSI6IGI.js";
import {
  e as e6,
  e2 as e9,
  m as m4
} from "./chunk-AE5K4SOQ.js";
import {
  $,
  Gt,
  Rt,
  St,
  bt as bt2,
  nt,
  pt
} from "./chunk-FVJU3I6I.js";
import "./chunk-VHXWATHW.js";
import "./chunk-7DLBSBVE.js";
import "./chunk-4XFEPZ26.js";
import "./chunk-FERTI5PU.js";
import "./chunk-VWCRJ6R6.js";
import {
  l as l3
} from "./chunk-MKNNZ33G.js";
import "./chunk-JQUWFKNU.js";
import "./chunk-UVQQJ3R6.js";
import "./chunk-QU433TMZ.js";
import "./chunk-IIAN3QNN.js";
import "./chunk-GX2FDWTU.js";
import "./chunk-TFHLTN6F.js";
import {
  n as n7
} from "./chunk-UDYHZLTE.js";
import {
  e as e3
} from "./chunk-IQBIGNPU.js";
import {
  o as o2,
  r as r7
} from "./chunk-4JNOVZUK.js";
import {
  e as e2
} from "./chunk-6FXLJAMI.js";
import {
  M,
  f as f3,
  h as h2,
  l as l2
} from "./chunk-ZNRXLY4R.js";
import {
  n as n5
} from "./chunk-5MBCFCGH.js";
import "./chunk-JEA4MMTV.js";
import "./chunk-RG3AHHRL.js";
import "./chunk-SQSR6K2M.js";
import {
  P as P3
} from "./chunk-757322TP.js";
import "./chunk-P3W4YLFD.js";
import {
  a as a6,
  r as r5,
  s as s5
} from "./chunk-75RMBUYZ.js";
import "./chunk-TJ2I6XQT.js";
import "./chunk-EDHROVWI.js";
import "./chunk-34YPGGJT.js";
import "./chunk-NCXAKZRR.js";
import "./chunk-DUCSW4OU.js";
import "./chunk-WVDA5Z37.js";
import "./chunk-RW4M3CI3.js";
import {
  n as n6,
  r as r6
} from "./chunk-ZEEU5HOK.js";
import "./chunk-FFVIDMFN.js";
import {
  u as u2
} from "./chunk-VQXS4XNR.js";
import "./chunk-ZN2ROKCE.js";
import "./chunk-XGEPEYGB.js";
import "./chunk-2T7LFOXQ.js";
import "./chunk-NCONZRBI.js";
import "./chunk-76CXRT5P.js";
import "./chunk-7Q5M7ANT.js";
import "./chunk-A4HIS5ZJ.js";
import "./chunk-OFQYIOO7.js";
import "./chunk-YF2CRSQX.js";
import "./chunk-INL7BDTP.js";
import "./chunk-7XXQ7762.js";
import "./chunk-DVGM5RQS.js";
import "./chunk-QTYVDCOW.js";
import "./chunk-HSDU7DIL.js";
import "./chunk-FWRLW4G5.js";
import "./chunk-E52E6T7N.js";
import "./chunk-6Z6ZAVRA.js";
import {
  i as i2
} from "./chunk-PK4W65H4.js";
import "./chunk-W62B63EU.js";
import "./chunk-N43PI2UO.js";
import "./chunk-O6VYMEIX.js";
import "./chunk-NDQ5FHGV.js";
import {
  j as j2
} from "./chunk-HUQX7WZO.js";
import "./chunk-ZWUEORSX.js";
import "./chunk-QWNKYSI4.js";
import "./chunk-ZPYDYUP5.js";
import "./chunk-AIDV7EKX.js";
import "./chunk-FZQZIM7U.js";
import "./chunk-CZBRZ6SU.js";
import {
  m as m2
} from "./chunk-KDO6J2FO.js";
import "./chunk-RT3T2K4S.js";
import "./chunk-WJCI2CGX.js";
import {
  a as a5
} from "./chunk-REIQNAQW.js";
import "./chunk-J6LQZWZI.js";
import "./chunk-OD3FDQCI.js";
import "./chunk-J2PJNRU7.js";
import "./chunk-56SPM3WK.js";
import "./chunk-XMZAPOBR.js";
import "./chunk-BLJKKR5D.js";
import "./chunk-ZGNCYHMZ.js";
import "./chunk-X2S4RQJ4.js";
import "./chunk-FUPLN7UM.js";
import "./chunk-376OPXM4.js";
import "./chunk-DER356EU.js";
import "./chunk-MZIWIEIR.js";
import "./chunk-TQEOEDAZ.js";
import "./chunk-SHFHZMHO.js";
import {
  c,
  i,
  u
} from "./chunk-NRP45AHD.js";
import "./chunk-IWQ7452U.js";
import "./chunk-NAN5J6QS.js";
import "./chunk-B4DKBAM3.js";
import "./chunk-6M2AHKYV.js";
import "./chunk-SZIJNKCV.js";
import "./chunk-6O43OEU5.js";
import "./chunk-J2K7ZDSV.js";
import "./chunk-2UML3WQZ.js";
import "./chunk-KXVMEIWT.js";
import "./chunk-UDND2Z3V.js";
import "./chunk-23Y3DIC6.js";
import "./chunk-JUVQV3R3.js";
import "./chunk-RAX2HD42.js";
import "./chunk-ZYRIJWLX.js";
import {
  a as a2
} from "./chunk-C5H57NTD.js";
import {
  g,
  o,
  s
} from "./chunk-3LR5O4WA.js";
import "./chunk-GDVNKPJ7.js";
import {
  n,
  r as r2
} from "./chunk-D4V6J5BT.js";
import {
  r as r3
} from "./chunk-OSHI574D.js";
import "./chunk-YWAQYJRC.js";
import "./chunk-B356PXLT.js";
import "./chunk-EHPBHJYZ.js";
import "./chunk-3MNMDUQZ.js";
import {
  w
} from "./chunk-UWG37XSU.js";
import "./chunk-LNZAOBFW.js";
import "./chunk-PF5I4XZQ.js";
import "./chunk-HLM6QCL2.js";
import "./chunk-RXYULINL.js";
import {
  f as f2,
  h,
  l
} from "./chunk-5NXILPDI.js";
import {
  n as n4
} from "./chunk-THVR7IAM.js";
import "./chunk-ZWJJTUFL.js";
import "./chunk-XQN7F674.js";
import {
  U
} from "./chunk-DMI7A7TC.js";
import "./chunk-ZHAW7FZS.js";
import {
  It
} from "./chunk-KAN4HXCG.js";
import "./chunk-4FEGON7M.js";
import "./chunk-VWYWOOPX.js";
import "./chunk-M5VHU5LK.js";
import "./chunk-CXFRNDG4.js";
import "./chunk-7QMMKGW4.js";
import {
  A,
  e,
  m,
  n2,
  n5 as n3,
  t5 as t2,
  y
} from "./chunk-OOLCFNXJ.js";
import "./chunk-6KZ2LTDA.js";
import "./chunk-U2XHEJM7.js";
import {
  D,
  a as a4,
  b,
  d as d2,
  f,
  j,
  r2 as r4,
  v
} from "./chunk-MJXQTGI2.js";
import {
  s as s4
} from "./chunk-LIZHLHNA.js";
import "./chunk-BTUHYGXO.js";
import {
  s as s2,
  s2 as s3
} from "./chunk-UA3YPL2R.js";
import {
  has
} from "./chunk-HVKDYDPP.js";
import {
  a as a3
} from "./chunk-6QC7MLLS.js";
import {
  a,
  d,
  r,
  t
} from "./chunk-MIHB3CIK.js";
import "./chunk-OL3AADLO.js";

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/sources/shaderRepository.js
var e10 = { background: { "background.frag": "#ifdef PATTERN\nuniform lowp float u_opacity;\nuniform lowp sampler2D u_texture;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#else\nuniform lowp vec4 u_color;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main() {\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = u_opacity * color;\n#else\ngl_FragColor = u_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}", "background.vert": "precision mediump float;\nattribute vec2 a_pos;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n#ifdef PATTERN\nuniform mediump mat3 u_pattern_matrix;\nvarying mediump vec2 v_tileTextureCoord;\nuniform mediump vec4 u_tlbr;\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\n#endif\nvoid main() {\ngl_Position = vec4((u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0)).xy, u_depth, 1.0);\n#ifdef PATTERN\nv_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\nv_tlbr             = u_tlbr / u_mosaicSize.xyxy;\n#endif\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n}" }, circle: { "circle.frag": "precision lowp float;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nmediump float dist = length(v_offset);\nmediump float alpha = smoothstep(0.0, -v_blur, dist - 1.0);\nlowp float color_mix_ratio = v_stroke_width < 0.01 ? 0.0 : smoothstep(-v_blur, 0.0, dist - v_radius / (v_radius + v_stroke_width));\ngl_FragColor = alpha * mix(v_color, v_stroke_color, color_mix_ratio);\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}", "circle.vert": "precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_circleTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_antialiasingWidth;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_stroke_color = stroke_color * stroke_opacity;\nv_stroke_width = stroke_width;\nv_radius = radius;\nv_blur = max(blur, u_antialiasingWidth / (radius + stroke_width));\nmediump vec2 offset = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\nv_offset = offset;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos * 0.5, 1.0) + u_displayMat3 * vec3((v_radius + v_stroke_width) * offset + u_circleTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}" }, fill: { "fill.frag": "precision lowp float;\n#ifdef PATTERN\nuniform lowp sampler2D u_texture;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = fract(v_tileTextureCoord);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = v_color[3] * color;\n#else\ngl_FragColor = v_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}", "fill.vert": "precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump float u_depth;\nuniform mediump vec2 u_fillTranslation;\n#ifdef PATTERN\n#include <util/util.glsl>\nuniform mediump vec2 u_mosaicSize;\nuniform mediump float u_patternFactor;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n#ifdef PATTERN\nfloat patternWidth = nextPOT(tlbr.z - tlbr.x);\nfloat patternHeight = nextPOT(tlbr.w - tlbr.y);\nfloat scaleX = 1.0 / (patternWidth * u_patternFactor);\nfloat scaleY = 1.0 / (patternHeight * u_patternFactor);\nmat3 patterMat = mat3(scaleX, 0.0,    0.0,\n0.0,    -scaleY, 0.0,\n0.0,    0.0,    1.0);\nv_tileTextureCoord = (patterMat * vec3(a_pos, 1.0)).xy;\nv_tlbr             = tlbr / u_mosaicSize.xyxy;\n#endif\nvec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}" }, icon: { "icon.frag": "precision mediump float;\nuniform lowp sampler2D u_texture;\n#ifdef SDF\nuniform lowp vec4 u_color;\nuniform lowp vec4 u_outlineColor;\n#endif\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump flaot v_halo_width;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\n#include <util/encoding.glsl>\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef SDF\nlowp vec4 fillPixelColor = v_color;\nfloat d = rgba2float(texture2D(u_texture, v_tex)) - 0.5;\nconst float softEdgeRatio = 0.248062016;\nfloat size = max(v_size.x, v_size.y);\nfloat dist = d * softEdgeRatio * size;\nfillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\nif (v_halo_width > 0.25) {\nlowp vec4 outlinePixelColor = u_outlineColor;\nconst float outlineLimitRatio = (16.0 / 86.0);\nfloat clampedOutlineSize = softEdgeRatio * min(v_halo_width, outlineLimitRatio * max(v_size.x, v_size.y));\noutlinePixelColor *= clamp(0.5 - (abs(dist) - clampedOutlineSize), 0.0, 1.0);\ngl_FragColor = v_opacity * mixColors(fillPixelColor, outlinePixelColor);\n}\nelse {\ngl_FragColor = v_opacity * fillPixelColor;\n}\n#else\nlowp vec4 texColor = texture2D(u_texture, v_tex);\ngl_FragColor = v_opacity * texColor;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}", "icon.vert": "attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump float v_halo_width;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_iconTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nconst float C_OFFSET_PRECISION = 1.0 / 8.0;\nconst float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float tileCoordRatio = 1.0 / 8.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nv_color = color;\nv_opacity = opacity;\n#ifdef SDF\nv_halo_width = halo_width;\n#endif\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_opacity *= interpolatedOpacity;\nmediump float a_angle         = a_levelInfo[1];\nmediump float a_minLevel      = a_levelInfo[2];\nmediump float a_maxLevel      = a_levelInfo[3];\nmediump vec2 a_tex            = a_texAngleRange.xy;\nmediump float delta_z = 0.0;\nmediump float rotated = mod(a_angle + u_mapRotation, 256.0);\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated));\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_opacity, 0.0);\nvec2 offset = C_OFFSET_PRECISION * a_vertexOffset;\nv_size = abs(offset);\n#ifdef SDF\noffset = (120.0 / 86.0) * offset;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayViewMat3 * vec3(size * offset, 0.0) + u_displayMat3 * vec3(u_iconTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_tex = a_tex.xy / u_mosaicSize;\n}" }, line: { "line.frag": "precision lowp float;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying mediump float v_blur;\n#if defined (PATTERN) || defined(SDF)\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\nuniform sampler2D u_texture;\nuniform mediump float u_antialiasing;\n#endif\n#ifdef SDF\n#include <util/encoding.glsl>\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nmediump float fragDist = length(v_normal) * v_lineHalfWidth;\nlowp float alpha = clamp((v_lineHalfWidth - fragDist) / v_blur, 0.0, 1.0);\n#ifdef PATTERN\nmediump float relativeTexX = fract(v_accumulatedDistance / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY = 0.5 + v_normal.y * v_lineHalfWidth / (v_patternSize.y * v_widthRatio);\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nlowp vec4 color = texture2D(u_texture, texCoord);\ngl_FragColor = alpha * v_color[3] * color;\n#elif defined(SDF)\nmediump float relativeTexX = fract((v_accumulatedDistance * 0.5) / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY =  0.5 + 0.25 * v_normal.y;\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nmediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\nfloat dist = d * (v_lineHalfWidth + u_antialiasing / 2.0);\ngl_FragColor = alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\n#else\ngl_FragColor = alpha * v_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}", "line.vert": "precision mediump float;\nattribute vec2 a_pos;\nattribute vec4 a_extrude_offset;\nattribute vec4 a_dir_normal;\nattribute vec2 a_accumulatedDistance;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump float u_zoomFactor;\nuniform mediump vec2 u_lineTranslation;\nuniform mediump float u_antialiasing;\nuniform mediump float u_depth;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nconst float scale = 1.0 / 31.0;\nconst mediump float tileCoordRatio = 8.0;\n#if defined (SDF)\nconst mediump float sdfPatternHalfWidth = 15.5;\n#endif\n#if defined (PATTERN) || defined(SDF)\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\n#endif\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvarying mediump float v_lineHalfWidth;\nvarying mediump float v_blur;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_blur = blur + u_antialiasing;\nv_normal = a_dir_normal.zw * scale;\n#if defined (PATTERN) || defined(SDF)\nv_tlbr          = tlbr / u_mosaicSize.xyxy;\nv_patternSize   = vec2(tlbr.z - tlbr.x, tlbr.y - tlbr.w);\n#if defined (PATTERN)\nv_widthRatio = width / v_patternSize.y;\n#else\nv_widthRatio = width / sdfPatternHalfWidth / 2.0;\n#endif\n#endif\nv_lineHalfWidth = (width + u_antialiasing) * 0.5;\nmediump vec2 dir = a_dir_normal.xy * scale;\nmediump vec2 offset_ = a_extrude_offset.zw * scale * offset;\nmediump vec2 dist = v_lineHalfWidth * scale * a_extrude_offset.xy;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos + offset_ * tileCoordRatio / u_zoomFactor, 1.0) + u_displayViewMat3 * vec3(dist, 0.0) + u_displayMat3 * vec3(u_lineTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n#if defined (PATTERN) || defined(SDF)\nv_accumulatedDistance = a_accumulatedDistance.x * u_zoomFactor / tileCoordRatio + dot(dir, dist + offset_);\n#endif\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n}" }, outline: { "outline.frag": "varying lowp vec4 v_color;\nvarying mediump vec2 v_normal;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nlowp float dist = abs(v_normal.y);\nlowp float alpha = smoothstep(1.0, 0.0, dist);\ngl_FragColor = alpha * v_color;\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}", "outline.vert": "attribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_xnormal;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_fillTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_outline_width;\nvarying lowp vec2 v_normal;\nconst float scale = 1.0 / 15.0;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_normal = a_xnormal;\nmediump vec2 dist = u_outline_width * scale * a_offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(dist + u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}" }, text: { "text.frag": "uniform lowp sampler2D u_texture;\nvarying lowp vec2 v_tex;\nvarying lowp vec4 v_color;\nvarying mediump float v_edgeWidth;\nvarying mediump float v_edgeDistance;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nlowp float dist = texture2D(u_texture, v_tex).a;\nmediump float alpha = smoothstep(v_edgeDistance - v_edgeWidth, v_edgeDistance + v_edgeWidth, dist);\ngl_FragColor = alpha * v_color;\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}", "text.vert": "attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_textTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying lowp vec2 v_tex;\nconst float offsetPrecision = 1.0 / 8.0;\nconst mediump float edgePos = 0.75;\nuniform mediump float u_antialiasingWidth;\nvarying mediump float v_edgeDistance;\nvarying mediump float v_edgeWidth;\nuniform lowp float u_halo;\nconst float sdfFontScale = 1.0 / 24.0;\nconst float sdfPixel = 3.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nif (u_halo > 0.5)\n{\nv_color = halo_color * opacity;\nhalo_width *= sdfPixel;\nhalo_blur *= sdfPixel;\n}\nelse\n{\nv_color = color * opacity;\nhalo_width = 0.0;\nhalo_blur = 0.0;\n}\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_color *= interpolatedOpacity;\nmediump float a_angle       = a_levelInfo[1];\nmediump float a_minLevel    = a_levelInfo[2];\nmediump float a_maxLevel    = a_levelInfo[3];\nmediump vec2 a_tex          = a_texAngleRange.xy;\nmediump float a_visMinAngle    = a_texAngleRange.z;\nmediump float a_visMaxAngle    = a_texAngleRange.w;\nmediump float delta_z = 0.0;\nmediump float angle = mod(a_angle + u_mapRotation, 256.0);\nif (a_visMinAngle < a_visMaxAngle)\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) + (1.0 - step(a_visMinAngle, angle)));\n}\nelse\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) * (1.0 - step(a_visMinAngle, angle)));\n}\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_color[3], 0.0);\nv_tex = a_tex.xy / u_mosaicSize;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_edgeDistance = edgePos - halo_width / size;\nv_edgeWidth = (u_antialiasingWidth + halo_blur) / size;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + sdfFontScale * u_displayViewMat3 * vec3(offsetPrecision * size * a_vertexOffset, 0.0) + u_displayMat3 * vec3(u_textTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n}" }, util: { "encoding.glsl": "const vec4 rgba2float_factors = vec4(\n255.0 / (256.0),\n255.0 / (256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n);\nfloat rgba2float(vec4 rgba) {\nreturn dot(rgba, rgba2float_factors);\n}", "util.glsl": "float nextPOT(in float x) {\nreturn pow(2.0, ceil(log2(abs(x))));\n}" } };

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/sources/resolver.js
function o7(e16) {
  let o17 = e10;
  return e16.split("/").forEach((r18) => {
    o17 && (o17 = o17[r18]);
  }), o17;
}
var t9 = new e7(o7);
function n14(r18) {
  return t9.resolveIncludes(r18);
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/Programs.js
var t10 = (e16) => n9({ ID: e16.id, PATTERN: e16.pattern });
var a8 = { shaders: (r18) => ({ vertexShader: t10(r18) + n14("background/background.vert"), fragmentShader: t10(r18) + n14("background/background.frag") }) };
var d4 = (e16) => n9({ ID: e16.id });
var i6 = { shaders: (r18) => ({ vertexShader: d4(r18) + n14("circle/circle.vert"), fragmentShader: d4(r18) + n14("circle/circle.frag") }) };
var n15 = (e16) => n9({ ID: e16.id, PATTERN: e16.pattern });
var l4 = { shaders: (r18) => ({ vertexShader: n15(r18) + n14("fill/fill.vert"), fragmentShader: n15(r18) + n14("fill/fill.frag") }) };
var s8 = (e16) => n9({ ID: e16.id });
var f4 = { shaders: (r18) => ({ vertexShader: s8(r18) + n14("outline/outline.vert"), fragmentShader: s8(r18) + n14("outline/outline.frag") }) };
var h3 = (e16) => n9({ ID: e16.id, SDF: e16.sdf });
var o8 = { shaders: (r18) => ({ vertexShader: h3(r18) + n14("icon/icon.vert"), fragmentShader: h3(r18) + n14("icon/icon.frag") }) };
var g2 = (e16) => n9({ ID: e16.id, PATTERN: e16.pattern, SDF: e16.sdf });
var c3 = { shaders: (r18) => ({ vertexShader: g2(r18) + n14("line/line.vert"), fragmentShader: g2(r18) + n14("line/line.frag") }) };
var S2 = (e16) => n9({ ID: e16.id });
var v2 = { shaders: (r18) => ({ vertexShader: S2(r18) + n14("text/text.vert"), fragmentShader: S2(r18) + n14("text/text.frag") }) };

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/VTLMaterialManager.js
var o9 = class {
  constructor() {
    this._programByKey = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._programByKey.forEach((e16) => e16.dispose()), this._programByKey.clear();
  }
  getMaterialProgram(e16, r18, t18) {
    const a18 = r18.key << 3 | this._getMaterialOptionsValue(r18.type, t18);
    if (this._programByKey.has(a18))
      return this._programByKey.get(a18);
    const s16 = this._getProgramTemplate(r18.type), { shaders: n23 } = s16, { vertexShader: c13, fragmentShader: i16 } = n23(t18), o17 = r18.getShaderHeader(), u10 = r18.getShaderMain(), p6 = c13.replace("#pragma header", o17).replace("#pragma main", u10), g8 = e16.programCache.acquire(p6, i16, r18.getAttributeLocations());
    return this._programByKey.set(a18, g8), g8;
  }
  _getMaterialOptionsValue(r18, t18) {
    switch (r18) {
      case T.BACKGROUND: {
        const e16 = t18;
        return (e16.pattern ? 1 : 0) << 1 | (e16.id ? 1 : 0);
      }
      case T.FILL: {
        const e16 = t18;
        return (e16.pattern ? 1 : 0) << 1 | (e16.id ? 1 : 0);
      }
      case T.OUTLINE:
        return t18.id ? 1 : 0;
      case T.LINE: {
        const e16 = t18;
        return (e16.sdf ? 1 : 0) << 2 | (e16.pattern ? 1 : 0) << 1 | (e16.id ? 1 : 0);
      }
      case T.ICON: {
        const e16 = t18;
        return (e16.sdf ? 1 : 0) << 1 | (e16.id ? 1 : 0);
      }
      case T.CIRCLE:
        return t18.id ? 1 : 0;
      case T.TEXT:
        return t18.id ? 1 : 0;
      default:
        return 0;
    }
  }
  _getProgramTemplate(o17) {
    switch (o17) {
      case T.BACKGROUND:
        return a8;
      case T.CIRCLE:
        return i6;
      case T.FILL:
        return l4;
      case T.ICON:
        return o8;
      case T.LINE:
        return c3;
      case T.OUTLINE:
        return f4;
      case T.TEXT:
        return v2;
      default:
        return null;
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/BitBlitPrograms.js
var e11 = { shaders: { vertexShader: n12("bitBlit/bitBlit.vert"), fragmentShader: n12("bitBlit/bitBlit.frag") }, attributes: /* @__PURE__ */ new Map([["a_pos", 0], ["a_tex", 1]]) };

// node_modules/@arcgis/core/views/2d/engine/webgl/BitBlitRenderer.js
var _ = class {
  constructor() {
    this._initialized = false;
  }
  dispose() {
    this._program = a(this._program), this._vertexArrayObject = a(this._vertexArrayObject);
  }
  render(r18, t18, e16, i16) {
    r18 && (this._initialized || this._initialize(r18), r18.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA), r18.bindVAO(this._vertexArrayObject), r18.useProgram(this._program), t18.setSamplingMode(e16), r18.bindTexture(t18, 0), this._program.setUniform1i("u_tex", 0), this._program.setUniform1f("u_opacity", i16), r18.drawArrays(E.TRIANGLE_STRIP, 0, 4), r18.bindTexture(null, 0), r18.bindVAO());
  }
  _initialize(r18) {
    if (this._initialized)
      return true;
    const s16 = e8(r18, e11);
    if (!s16)
      return false;
    const o17 = new Int8Array(16);
    o17[0] = -1, o17[1] = -1, o17[2] = 0, o17[3] = 0, o17[4] = 1, o17[5] = -1, o17[6] = 1, o17[7] = 0, o17[8] = -1, o17[9] = 1, o17[10] = 0, o17[11] = 1, o17[12] = 1, o17[13] = 1, o17[14] = 1, o17[15] = 1;
    const _9 = e11.attributes, p6 = new a7(r18, _9, t8, { geometry: E3.createVertex(r18, F.STATIC_DRAW, o17) });
    return this._program = s16, this._vertexArrayObject = p6, this._initialized = true, true;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/MaterialManager.js
var a9 = (r18) => r18 === I3.HITTEST || r18 === I3.LABEL_ALPHA;
var s9 = (r18) => (a9(r18) ? 1 : 0) | (r18 === I3.HIGHLIGHT ? 2 : 0);
var o10 = ({ rendererInfo: e16, drawPhase: t18 }, a18, o17, i16) => `${a18.getVariationHash()}-${i16.join(".")}-${s9(t18)}-${e16.getVariationHash()}-${r(o17) && o17.join(".")}`;
var i7 = (t18, s16, o17, i16) => {
  const h9 = i16.reduce((r18, e16) => ({ ...r18, [e16]: t18.context.driverTest[e16] }), {}), n23 = { ...s16.getVariation(), ...t18.rendererInfo.getVariation(), highlight: t18.drawPhase === I3.HIGHLIGHT, id: a9(t18.drawPhase), ...h9 };
  if (r(o17))
    for (const r18 of o17)
      n23[r18] = true;
  return n23;
};
var h4 = class {
  constructor(r18) {
    this._rctx = r18, this._programByKey = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._programByKey.forEach((r18) => r18.dispose()), this._programByKey.clear();
  }
  getProgram(r18, e16 = [], a18 = []) {
    const s16 = r18.vsPath + "." + r18.fsPath + JSON.stringify(e16) + a18.join(".");
    if (this._programByKey.has(s16))
      return this._programByKey.get(s16);
    const o17 = a18.reduce((r19, e17) => ({ ...r19, [e17]: this._rctx.driverTest[e17] }), {}), i16 = { ...e16.map((r19) => "string" == typeof r19 ? { name: r19, value: true } : r19).reduce((r19, e17) => ({ ...r19, [e17.name]: e17.value }), {}), ...o17 }, { vsPath: h9, fsPath: n23, attributes: g8 } = r18, m10 = o6(h9, n23, g8, i16), c13 = this._rctx.programCache.acquire(m10.shaders.vertexShader, m10.shaders.fragmentShader, m10.attributes);
    if (!c13)
      throw new Error("Unable to get program for key: ${key}");
    return this._programByKey.set(s16, c13), c13;
  }
  getMaterialProgram(r18, e16, a18, s16, h9, n23 = ["ignoresSamplerPrecision"]) {
    const g8 = o10(r18, e16, h9, n23);
    if (this._programByKey.has(g8))
      return this._programByKey.get(g8);
    const m10 = i7(r18, e16, h9, n23), c13 = o6(a18, a18, s16, m10), y5 = this._rctx.programCache.acquire(c13.shaders.vertexShader, c13.shaders.fragmentShader, c13.attributes);
    if (!y5)
      throw new Error("Unable to get program for key: ${key}");
    return this._programByKey.set(g8, y5), y5;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/RectangleBinPack.js
var t11 = class {
  constructor(t18, e16) {
    this._width = 0, this._height = 0, this._free = [], this._width = t18, this._height = e16, this._free.push(new t5(0, 0, t18, e16));
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  allocate(t18, e16) {
    if (t18 > this._width || e16 > this._height)
      return new t5();
    let i16 = null, s16 = -1;
    for (let h9 = 0; h9 < this._free.length; ++h9) {
      const r18 = this._free[h9];
      t18 <= r18.width && e16 <= r18.height && (null === i16 || r18.y <= i16.y && r18.x <= i16.x) && (i16 = r18, s16 = h9);
    }
    return null === i16 ? new t5() : (this._free.splice(s16, 1), i16.width < i16.height ? (i16.width > t18 && this._free.push(new t5(i16.x + t18, i16.y, i16.width - t18, e16)), i16.height > e16 && this._free.push(new t5(i16.x, i16.y + e16, i16.width, i16.height - e16))) : (i16.width > t18 && this._free.push(new t5(i16.x + t18, i16.y, i16.width - t18, i16.height)), i16.height > e16 && this._free.push(new t5(i16.x, i16.y + e16, t18, i16.height - e16))), new t5(i16.x, i16.y, t18, e16));
  }
  release(h9) {
    for (let t18 = 0; t18 < this._free.length; ++t18) {
      const e16 = this._free[t18];
      if (e16.y === h9.y && e16.height === h9.height && e16.x + e16.width === h9.x)
        e16.width += h9.width;
      else if (e16.x === h9.x && e16.width === h9.width && e16.y + e16.height === h9.y)
        e16.height += h9.height;
      else if (h9.y === e16.y && h9.height === e16.height && h9.x + h9.width === e16.x)
        e16.x = h9.x, e16.width += h9.width;
      else {
        if (h9.x !== e16.x || h9.width !== e16.width || h9.y + h9.height !== e16.y)
          continue;
        e16.y = h9.y, e16.height += h9.height;
      }
      this._free.splice(t18, 1), this.release(h9);
    }
    this._free.push(h9);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/GlyphMosaic.js
var a10 = 256;
var n16 = (t18) => Math.floor(t18 / 256);
function c4(t18) {
  const e16 = /* @__PURE__ */ new Set();
  for (const i16 of t18)
    e16.add(n16(i16));
  return e16;
}
function o11(e16, i16, h9) {
  return e16.has(i16) || e16.set(i16, h9().then(() => {
    e16.delete(i16);
  }).catch((h10) => {
    e16.delete(i16), b(h10);
  })), e16.get(i16);
}
var l5 = (t18) => ({ rect: new t5(0, 0, 0, 0), page: 0, metrics: { left: 0, width: 0, height: 0, advance: 0, top: 0 }, code: t18, sdf: true });
var g3 = class {
  constructor(t18, e16, h9) {
    this.width = 0, this.height = 0, this._dirties = [], this._glyphData = [], this._currentPage = 0, this._glyphCache = {}, this._textures = [], this._rangePromises = /* @__PURE__ */ new Map(), this.width = t18, this.height = e16, this._glyphSource = h9, this._binPack = new t11(t18 - 4, e16 - 4), this._glyphData.push(new Uint8Array(t18 * e16)), this._dirties.push(true), this._textures.push(null), this._initDecorationGlyph();
  }
  dispose() {
    this._binPack = null;
    for (const t18 of this._textures)
      t18 && t18.dispose();
    this._textures.length = 0, this._glyphData.length = 0;
  }
  _initDecorationGlyph() {
    const t18 = [117, 149, 181, 207, 207, 181, 149, 117], e16 = [];
    for (let h9 = 0; h9 < t18.length; h9++) {
      const i17 = t18[h9];
      for (let t19 = 0; t19 < 11; t19++)
        e16.push(i17);
    }
    const i16 = { metrics: { width: 5, height: 2, left: 0, top: 0, advance: 0 }, bitmap: new Uint8Array(e16) };
    this._recordGlyph(i16);
  }
  async getGlyphItems(t18, e16, i16) {
    const h9 = this._getGlyphCache(t18);
    return await this._fetchRanges(t18, e16, i16), e16.map((e17) => this._getMosaicItem(h9, t18, e17));
  }
  bind(t18, e16, i16, h9) {
    const s16 = this._getTexture(t18, i16);
    s16.setSamplingMode(e16), this._dirties[i16] && (s16.setData(this._glyphData[i16]), this._dirties[i16] = false), t18.bindTexture(s16, h9);
  }
  _getGlyphCache(t18) {
    return this._glyphCache[t18] || (this._glyphCache[t18] = {}), this._glyphCache[t18];
  }
  _getTexture(t18, e16) {
    return this._textures[e16] || (this._textures[e16] = new E2(t18, { pixelFormat: P.ALPHA, dataType: G.UNSIGNED_BYTE, width: this.width, height: this.height }, new Uint8Array(this.width * this.height))), this._textures[e16];
  }
  _invalidate() {
    this._dirties[this._currentPage] = true;
  }
  async _fetchRanges(t18, e16, i16) {
    const h9 = c4(e16), s16 = [];
    h9.forEach((e17) => {
      s16.push(this._fetchRange(t18, e17, i16));
    }), await Promise.all(s16);
  }
  async _fetchRange(t18, e16, i16) {
    if (e16 > a10)
      return null;
    const h9 = t18 + e16;
    return o11(this._rangePromises, h9, () => this._glyphSource.getRange(t18, e16, i16));
  }
  _getMosaicItem(t18, e16, i16) {
    if (!t18[i16]) {
      const h9 = this._glyphSource.getGlyph(e16, i16);
      if (!h9 || !h9.metrics)
        return l5(i16);
      const s16 = this._recordGlyph(h9), r18 = this._currentPage, a18 = h9.metrics;
      t18[i16] = { rect: s16, page: r18, metrics: a18, code: i16, sdf: true }, this._invalidate();
    }
    return t18[i16];
  }
  _recordGlyph(t18) {
    const h9 = t18.metrics;
    let s16;
    if (0 === h9.width)
      s16 = new t5(0, 0, 0, 0);
    else {
      const e16 = 3, r18 = h9.width + 2 * e16, a18 = h9.height + 2 * e16;
      s16 = this._binPack.allocate(r18, a18), s16.isEmpty && (this._dirties[this._currentPage] || (this._glyphData[this._currentPage] = null), this._currentPage = this._glyphData.length, this._glyphData.push(new Uint8Array(this.width * this.height)), this._dirties.push(true), this._textures.push(null), this._initDecorationGlyph(), this._binPack = new t11(this.width - 4, this.height - 4), s16 = this._binPack.allocate(r18, a18));
      const n23 = this._glyphData[this._currentPage], c13 = t18.bitmap;
      let o17, l17;
      if (c13)
        for (let t19 = 0; t19 < a18; t19++) {
          o17 = r18 * t19, l17 = this.width * (s16.y + t19) + s16.x;
          for (let t20 = 0; t20 < r18; t20++)
            n23[l17 + t20] = c13[o17 + t20];
        }
      has("esri-glyph-debug") && this._showDebugPage(n23);
    }
    return s16;
  }
  _showDebugPage(t18) {
    const e16 = document.createElement("canvas"), i16 = e16.getContext("2d"), h9 = new ImageData(this.width, this.height), s16 = h9.data;
    e16.width = this.width, e16.height = this.height, e16.style.border = "1px solid black";
    for (let r18 = 0; r18 < t18.length; ++r18)
      s16[4 * r18 + 0] = t18[r18], s16[4 * r18 + 1] = 0, s16[4 * r18 + 2] = 0, s16[4 * r18 + 3] = 255;
    i16.putImageData(h9, 0, 0), document.body.appendChild(e16);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/GlyphSource.js
var s10 = class {
  constructor(t18) {
    for (this._metrics = [], this._bitmaps = []; t18.next(); )
      switch (t18.tag()) {
        case 1: {
          const e16 = t18.getMessage();
          for (; e16.next(); )
            switch (e16.tag()) {
              case 3: {
                const t19 = e16.getMessage();
                let s16, a18, r18, n23, i16, c13, g8;
                for (; t19.next(); )
                  switch (t19.tag()) {
                    case 1:
                      s16 = t19.getUInt32();
                      break;
                    case 2:
                      a18 = t19.getBytes();
                      break;
                    case 3:
                      r18 = t19.getUInt32();
                      break;
                    case 4:
                      n23 = t19.getUInt32();
                      break;
                    case 5:
                      i16 = t19.getSInt32();
                      break;
                    case 6:
                      c13 = t19.getSInt32();
                      break;
                    case 7:
                      g8 = t19.getUInt32();
                      break;
                    default:
                      t19.skip();
                  }
                t19.release(), s16 && (this._metrics[s16] = { width: r18, height: n23, left: i16, top: c13, advance: g8 }, this._bitmaps[s16] = a18);
                break;
              }
              default:
                e16.skip();
            }
          e16.release();
          break;
        }
        default:
          t18.skip();
      }
  }
  getMetrics(t18) {
    return this._metrics[t18];
  }
  getBitmap(t18) {
    return this._bitmaps[t18];
  }
};
var a11 = class {
  constructor() {
    this._ranges = [];
  }
  getRange(t18) {
    return this._ranges[t18];
  }
  addRange(t18, e16) {
    this._ranges[t18] = e16;
  }
};
var r9 = class {
  constructor(t18) {
    this._glyphInfo = {}, this._baseURL = t18;
  }
  getRange(a18, r18, n23) {
    const i16 = this._getFontStack(a18);
    if (i16.getRange(r18))
      return Promise.resolve();
    const c13 = 256 * r18, g8 = c13 + 255, o17 = this._baseURL.replace("{fontstack}", a18).replace("{range}", c13 + "-" + g8);
    return U(o17, { responseType: "array-buffer", ...n23 }).then((t18) => {
      i16.addRange(r18, new s10(new n5(new Uint8Array(t18.data), new DataView(t18.data))));
    });
  }
  getGlyph(t18, e16) {
    const s16 = this._getFontStack(t18);
    if (!s16)
      return;
    const a18 = Math.floor(e16 / 256);
    if (a18 > 256)
      return;
    const r18 = s16.getRange(a18);
    return r18 ? { metrics: r18.getMetrics(e16), bitmap: r18.getBitmap(e16) } : void 0;
  }
  _getFontStack(t18) {
    let e16 = this._glyphInfo[t18];
    return e16 || (e16 = this._glyphInfo[t18] = new a11()), e16;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/SDFConverter.js
var i8 = 1e20;
var r10 = class {
  constructor(t18) {
    this._svg = null, this.size = t18;
    const e16 = document.createElement("canvas");
    e16.width = e16.height = t18, this._context = e16.getContext("2d"), this._gridOuter = new Float64Array(t18 * t18), this._gridInner = new Float64Array(t18 * t18), this._f = new Float64Array(t18), this._d = new Float64Array(t18), this._z = new Float64Array(t18 + 1), this._v = new Int16Array(t18);
  }
  dispose() {
    this._context = this._gridOuter = this._gridInner = this._f = this._d = this._z = this._v = null, this._svg && (document.body.removeChild(this._svg), this._svg = null);
  }
  draw(r18, h9, n23 = 31) {
    this._initSVG();
    const o17 = this.createSVGString(r18);
    return new Promise((r19, a18) => {
      const d15 = new Image();
      d15.src = "data:image/svg+xml; charset=utf8, " + encodeURIComponent(o17), d15.onload = () => {
        d15.onload = null, this._context.clearRect(0, 0, this.size, this.size), this._context.drawImage(d15, 0, 0, this.size, this.size);
        const e16 = this._context.getImageData(0, 0, this.size, this.size), s16 = new Uint8Array(this.size * this.size * 4);
        for (let t18 = 0; t18 < this.size * this.size; t18++) {
          const s17 = e16.data[4 * t18 + 3] / 255;
          this._gridOuter[t18] = 1 === s17 ? 0 : 0 === s17 ? i8 : Math.max(0, 0.5 - s17) ** 2, this._gridInner[t18] = 1 === s17 ? i8 : 0 === s17 ? 0 : Math.max(0, s17 - 0.5) ** 2;
        }
        this._edt(this._gridOuter, this.size, this.size), this._edt(this._gridInner, this.size, this.size);
        for (let i16 = 0; i16 < this.size * this.size; i16++) {
          const e17 = this._gridOuter[i16] - this._gridInner[i16];
          o3(0.5 - e17 / (2 * n23), s16, 4 * i16);
        }
        r19(s16);
      };
      const l17 = h9 && h9.signal;
      l17 && v(l17, () => a18(a4()));
    });
  }
  _initSVG() {
    if (!this._svg) {
      const t18 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      t18.setAttribute("style", "position: absolute;"), t18.setAttribute("width", "0"), t18.setAttribute("height", "0"), t18.setAttribute("aria-hidden", "true"), t18.setAttribute("role", "presentation"), document.body.appendChild(t18), this._svg = t18;
    }
    return this._svg;
  }
  createSVGString(t18) {
    const e16 = this._initSVG(), s16 = document.createElementNS("http://www.w3.org/2000/svg", "path");
    s16.setAttribute("d", t18), e16.appendChild(s16);
    const i16 = s16.getBBox(), r18 = i16.width / i16.height, h9 = this.size / 2;
    let n23, o17, a18, d15;
    if (r18 > 1) {
      o17 = n23 = h9 / i16.width;
      const t19 = h9 * (1 / r18);
      a18 = this.size / 4, d15 = h9 - t19 / 2;
    } else {
      n23 = o17 = h9 / i16.height;
      a18 = h9 - h9 * r18 / 2, d15 = this.size / 4;
    }
    const l17 = -i16.x * n23 + a18, _9 = -i16.y * o17 + d15;
    s16.setAttribute("style", `transform: matrix(${n23}, 0, 0, ${o17}, ${l17}, ${_9})`);
    const g8 = `<svg style="fill:red;" height="${this.size}" width="${this.size}" xmlns="http://www.w3.org/2000/svg">${e16.innerHTML}</svg>`;
    return e16.removeChild(s16), g8;
  }
  _edt(t18, e16, s16) {
    const i16 = this._f, r18 = this._d, h9 = this._v, n23 = this._z;
    for (let o17 = 0; o17 < e16; o17++) {
      for (let r19 = 0; r19 < s16; r19++)
        i16[r19] = t18[r19 * e16 + o17];
      this._edt1d(i16, r18, h9, n23, s16);
      for (let i17 = 0; i17 < s16; i17++)
        t18[i17 * e16 + o17] = r18[i17];
    }
    for (let o17 = 0; o17 < s16; o17++) {
      for (let s17 = 0; s17 < e16; s17++)
        i16[s17] = t18[o17 * e16 + s17];
      this._edt1d(i16, r18, h9, n23, e16);
      for (let s17 = 0; s17 < e16; s17++)
        t18[o17 * e16 + s17] = Math.sqrt(r18[s17]);
    }
  }
  _edt1d(t18, e16, s16, r18, h9) {
    s16[0] = 0, r18[0] = -i8, r18[1] = +i8;
    for (let n23 = 1, o17 = 0; n23 < h9; n23++) {
      let e17 = (t18[n23] + n23 * n23 - (t18[s16[o17]] + s16[o17] * s16[o17])) / (2 * n23 - 2 * s16[o17]);
      for (; e17 <= r18[o17]; )
        o17--, e17 = (t18[n23] + n23 * n23 - (t18[s16[o17]] + s16[o17] * s16[o17])) / (2 * n23 - 2 * s16[o17]);
      o17++, s16[o17] = n23, r18[o17] = e17, r18[o17 + 1] = +i8;
    }
    for (let i16 = 0, n23 = 0; i16 < h9; i16++) {
      for (; r18[n23 + 1] < i16; )
        n23++;
      e16[i16] = (i16 - s16[n23]) * (i16 - s16[n23]) + t18[s16[n23]];
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/SpriteMosaic.js
function g4(t18) {
  return t18 && "static" === t18.type;
}
var p = class {
  constructor(t18, e16, i16 = 0) {
    this._mosaicPages = [], this._maxItemSize = 0, this._currentPage = 0, this._pageWidth = 0, this._pageHeight = 0, this._mosaicRects = /* @__PURE__ */ new Map(), this._spriteCopyQueue = [], this.pixelRatio = 1, (t18 <= 0 || e16 <= 0) && console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"), this._pageWidth = t18, this._pageHeight = e16, i16 > 0 && (this._maxItemSize = i16), this.pixelRatio = window.devicePixelRatio || 1, this._binPack = new t11(this._pageWidth, this._pageHeight);
    const s16 = Math.floor(this._pageWidth), r18 = Math.floor(this._pageHeight);
    this._mosaicPages.push({ mosaicsData: { type: "static", data: new Uint32Array(s16 * r18) }, size: [this._pageWidth, this._pageHeight], dirty: true, texture: void 0 });
  }
  getWidth(t18) {
    return t18 >= this._mosaicPages.length ? -1 : this._mosaicPages[t18].size[0];
  }
  getHeight(t18) {
    return t18 >= this._mosaicPages.length ? -1 : this._mosaicPages[t18].size[1];
  }
  getPageTexture(t18) {
    return t18 < this._mosaicPages.length ? this._mosaicPages[t18].texture : null;
  }
  has(t18) {
    return this._mosaicRects.has(t18);
  }
  get itemCount() {
    return this._mosaicRects.size;
  }
  getSpriteItem(t18) {
    return this._mosaicRects.get(t18);
  }
  addSpriteItem(t18, i16, a18, r18, o17, h9, c13 = 1) {
    if (this._mosaicRects.has(t18))
      return this._mosaicRects.get(t18);
    let n23, p6, m10;
    if (g4(a18))
      [n23, p6, m10] = this._allocateImage(i16[0], i16[1]);
    else {
      n23 = new t5(0, 0, i16[0], i16[1]), p6 = this._mosaicPages.length;
      const t19 = void 0;
      this._mosaicPages.push({ mosaicsData: a18, size: [i16[0] + 2 * et, i16[1] + 2 * et], dirty: true, texture: t19 });
    }
    if (n23.width <= 0 || n23.height <= 0)
      return null;
    const _9 = { rect: n23, width: i16[0], height: i16[1], sdf: o17, simplePattern: h9, pixelRatio: c13, page: p6 };
    return this._mosaicRects.set(t18, _9), g4(a18) && this._copy({ rect: n23, spriteSize: i16, spriteData: a18.data, page: p6, pageSize: m10, repeat: r18, sdf: o17 }), _9;
  }
  hasItemsToProcess() {
    return 0 !== this._spriteCopyQueue.length;
  }
  processNextItem() {
    const t18 = this._spriteCopyQueue.pop();
    t18 && this._copy(t18);
  }
  getSpriteItems(t18) {
    const e16 = {};
    for (const i16 of t18)
      e16[i16] = this.getSpriteItem(i16);
    return e16;
  }
  getMosaicItemPosition(t18) {
    const i16 = this.getSpriteItem(t18), s16 = i16 && i16.rect;
    if (!s16)
      return null;
    s16.width = i16.width, s16.height = i16.height;
    const a18 = i16.width, r18 = i16.height, o17 = et, h9 = this._mosaicPages[i16.page];
    return { size: [i16.width, i16.height], tl: [(s16.x + o17) / h9[0], (s16.y + o17) / h9[1]], br: [(s16.x + o17 + a18) / h9[0], (s16.y + o17 + r18) / h9[1]], page: i16.page };
  }
  bind(t18, e16, i16 = 0, s16 = 0) {
    const a18 = this._mosaicPages[i16], r18 = a18.mosaicsData;
    let o17 = a18.texture;
    if (o17 || (o17 = m5(t18, r18, a18.size), a18.texture = o17), o17.setSamplingMode(e16), g4(r18))
      t18.bindTexture(o17, s16), a18.dirty && (o17.setData(new Uint8Array(r18.data.buffer)), o17.generateMipmap());
    else {
      r18.data.bindFrame(t18, o17, s16);
    }
    a18.dirty = false;
  }
  static _copyBits(t18, e16, i16, s16, a18, r18, o17, h9, c13, n23, g8) {
    let p6 = s16 * e16 + i16, m10 = h9 * r18 + o17;
    if (g8) {
      m10 -= r18;
      for (let o18 = -1; o18 <= n23; o18++, p6 = ((o18 + n23) % n23 + s16) * e16 + i16, m10 += r18)
        for (let e17 = -1; e17 <= c13; e17++)
          a18[m10 + e17] = t18[p6 + (e17 + c13) % c13];
    } else
      for (let _9 = 0; _9 < n23; _9++) {
        for (let e17 = 0; e17 < c13; e17++)
          a18[m10 + e17] = t18[p6 + e17];
        p6 += e16, m10 += r18;
      }
  }
  _copy(i16) {
    if (i16.page >= this._mosaicPages.length)
      return;
    const s16 = this._mosaicPages[i16.page], a18 = s16.mosaicsData;
    if (!g4(s16.mosaicsData))
      throw new s4("mapview-invalid-resource", "unsuitable data type!");
    const r18 = i16.spriteData, o17 = a18.data;
    o17 && r18 || console.error("Source or target images are uninitialized!"), p._copyBits(r18, i16.spriteSize[0], 0, 0, o17, i16.pageSize[0], i16.rect.x + et, i16.rect.y + et, i16.spriteSize[0], i16.spriteSize[1], i16.repeat), s16.dirty = true;
  }
  _allocateImage(t18, r18) {
    t18 += 2 * et, r18 += 2 * et;
    const o17 = Math.max(t18, r18);
    if (this._maxItemSize && this._maxItemSize < o17) {
      const e16 = 2 ** Math.ceil(P2(t18)), a18 = 2 ** Math.ceil(P2(r18)), o18 = new t5(0, 0, t18, r18);
      return this._mosaicPages.push({ mosaicsData: { type: "static", data: new Uint32Array(e16 * a18) }, size: [e16, a18], dirty: true, texture: void 0 }), [o18, this._mosaicPages.length - 1, [e16, a18]];
    }
    const h9 = this._binPack.allocate(t18, r18);
    if (h9.width <= 0) {
      const e16 = this._mosaicPages[this._currentPage];
      return !e16.dirty && g4(e16.mosaicsData) && (e16.mosaicsData.data = null), this._currentPage = this._mosaicPages.length, this._mosaicPages.push({ mosaicsData: { type: "static", data: new Uint32Array(this._pageWidth * this._pageHeight) }, size: [this._pageWidth, this._pageHeight], dirty: true, texture: void 0 }), this._binPack = new t11(this._pageWidth, this._pageHeight), this._allocateImage(t18, r18);
    }
    return [h9, this._currentPage, [this._pageWidth, this._pageHeight]];
  }
  dispose() {
    this._binPack = null;
    for (const t18 of this._mosaicPages) {
      const e16 = t18.texture;
      e16 && e16.dispose();
      const i16 = t18.mosaicsData;
      if (!g4(i16)) {
        i16.data.destroy();
      }
    }
    this._mosaicPages = null, this._mosaicRects.clear();
  }
};
function m5(t18, e16, i16) {
  return g4(e16) ? new E2(t18, { pixelFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, width: i16[0], height: i16[1] }, new Uint8Array(e16.data.buffer)) : new E2(t18, { pixelFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, samplingMode: L.LINEAR, wrapMode: D2.CLAMP_TO_EDGE, width: i16[0], height: i16[1] }, null);
}

// node_modules/@arcgis/core/views/2d/engine/webgl/animatedFormats/utils.js
function a12(e16) {
  return n3(e16.frameDurations.reduce((t18, e17) => t18 + e17, 0));
}
function n17(t18) {
  const { width: e16, height: r18 } = t18;
  return { frameDurations: t18.frameDurations.reverse(), getFrame: (e17) => {
    const r19 = t18.frameDurations.length - 1 - e17;
    return t18.getFrame(r19);
  }, width: e16, height: r18 };
}
function s11(e16, r18) {
  const { width: i16, height: n23, getFrame: s16 } = e16, o17 = r18 / a12(e16);
  return { frameDurations: e16.frameDurations.map((e17) => n3(e17 * o17)), getFrame: s16, width: i16, height: n23 };
}
function o12(e16, r18) {
  const { width: i16, height: a18, getFrame: n23 } = e16, s16 = e16.frameDurations.slice(), o17 = s16.shift();
  return s16.unshift(n3(o17 + r18)), { frameDurations: s16, getFrame: n23, width: i16, height: a18 };
}
function m6(e16, r18) {
  const { width: i16, height: a18, getFrame: n23 } = e16, s16 = e16.frameDurations.slice(), o17 = s16.pop();
  return s16.push(n3(o17 + r18)), { frameDurations: s16, getFrame: n23, width: i16, height: a18 };
}
var h5 = class {
  constructor(t18, e16, r18, i16) {
    this._animation = t18, this._repeatType = r18, this._onFrameData = i16, this._direction = 1, this._currentFrame = 0, this.timeToFrame = this._animation.frameDurations[this._currentFrame];
    let a18 = 0;
    for (; e16 > a18; )
      a18 += this.timeToFrame, this.nextFrame();
    const n23 = this._animation.getFrame(this._currentFrame);
    this._onFrameData(n23);
  }
  nextFrame() {
    if (this._currentFrame += this._direction, this._direction > 0) {
      if (this._currentFrame === this._animation.frameDurations.length)
        switch (this._repeatType) {
          case d3.None:
            this._currentFrame -= this._direction;
            break;
          case d3.Loop:
            this._currentFrame = 0;
            break;
          case d3.Oscillate:
            this._currentFrame -= this._direction, this._direction = -1;
        }
    } else if (-1 === this._currentFrame)
      switch (this._repeatType) {
        case d3.None:
          this._currentFrame -= this._direction;
          break;
        case d3.Loop:
          this._currentFrame = this._animation.frameDurations.length - 1;
          break;
        case d3.Oscillate:
          this._currentFrame -= this._direction, this._direction = 1;
      }
    this.timeToFrame = this._animation.frameDurations[this._currentFrame];
    const t18 = this._animation.getFrame(this._currentFrame);
    this._onFrameData(t18);
  }
};
function c5(c13, u10, f10, l17) {
  let _9, { repeatType: F3 } = u10;
  if (null == F3 && (F3 = d3.Loop), true === u10.reverseAnimation && (c13 = n17(c13)), null != u10.duration && (c13 = s11(c13, n3(1e3 * u10.duration))), null != u10.repeatDelay) {
    const r18 = 1e3 * u10.repeatDelay;
    F3 === d3.Loop ? c13 = m6(c13, n3(r18)) : F3 === d3.Oscillate && (c13 = o12(m6(c13, n3(r18 / 2)), n3(r18 / 2)));
  }
  if (null != u10.startTimeOffset)
    _9 = n3(1e3 * u10.startTimeOffset);
  else if (null != u10.randomizeStartTime) {
    const e16 = o4(f10), n23 = 82749913, s16 = null != u10.randomizeStartSeed ? u10.randomizeStartSeed : n23, o17 = e4(e16, s16);
    _9 = n3(o17 * a12(c13));
  } else
    _9 = n3(0);
  return new h5(c13, _9, F3, l17);
}
function u3(t18, e16, r18, i16) {
  const a18 = null == e16.playAnimation || e16.playAnimation, n23 = c5(t18, e16, r18, i16);
  let s16, o17 = n23.timeToFrame;
  function m10() {
    s16 = a18 && setTimeout(() => {
      n23.nextFrame(), o17 = n23.timeToFrame, m10();
    }, o17);
  }
  return m10(), { remove: () => {
    a18 && clearTimeout(s16);
  } };
}

// node_modules/@arcgis/core/views/2d/engine/webgl/animatedFormats/AnimatableTextureResource.js
var e12 = class {
  constructor(t18, a18, e16, s16) {
    this._animation = t18, this._frameData = null;
    const h9 = (t19) => {
      this._frameData = t19, a18.requestRender();
    };
    this.frameCount = this._animation.frameDurations.length, this.width = this._animation.width, this.height = this._animation.height, this._playHandle = u3(this._animation, e16, s16, h9);
  }
  destroy() {
    this._playHandle.remove();
  }
  bindFrame(i16, e16, s16) {
    i16.bindTexture(e16, s16), t(this._frameData) || (e16.updateData(0, et, et, this._frameData.width, this._frameData.height, this._frameData), this._frameData = null);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/symbolUtils.js
function e13(e16) {
  switch (e16.type) {
    case "esriSMS":
      return `${e16.style}.${e16.path}`;
    case "esriSLS":
      return `${e16.style}.${e16.cap}`;
    case "esriSFS":
      return `${e16.style}`;
    case "esriPFS":
    case "esriPMS":
      return e16.imageData ? `${e16.imageData}${e16.width}${e16.height}` : `${e16.url}${e16.width}${e16.height}`;
    default:
      return "mosaicHash" in e16 ? e16.mosaicHash : JSON.stringify(e16);
  }
}

// node_modules/@arcgis/core/views/2d/engine/webgl/TextureManager.js
var F2 = n7();
var $2 = "arial-unicode-ms-regular";
var N2 = 126;
var k = s3.getLogger("esri.views.2d.engine.webgl.TextureManager");
function H(e16, t18) {
  const i16 = Math.round(u(t18) * window.devicePixelRatio), s16 = i16 >= 128 ? 2 : 4;
  return Math.min(e16, i16 * s16);
}
var Q = (e16, t18, i16) => k.error(new s4(e16, t18, i16));
var O4 = class {
  constructor(e16, t18, i16) {
    this.mosaicType = e16, this.page = t18, this.sdf = i16;
  }
  static fromMosaic(e16, t18) {
    return new O4(e16, t18.page, t18.sdf);
  }
};
var V3 = class {
  constructor(i16, r18) {
    this._requestRender = i16, this.resourceManager = r18, this._invalidFontsMap = /* @__PURE__ */ new Map(), this._sdfConverter = new r10(N2), this._bindingInfos = new Array(), this._hashToBindingIndex = /* @__PURE__ */ new Map(), this._ongoingRasterizations = /* @__PURE__ */ new Map(), this._imageRequestQueue = new l3({ concurrency: 10, process: async (e16, i17) => {
      f(i17);
      try {
        return await U(e16, { responseType: "image", signal: i17 });
      } catch (r19) {
        if (!j(r19))
          throw new s4("mapview-invalid-resource", `Could not fetch requested resource at ${e16}`, r19);
        throw r19;
      }
    } }), this._spriteMosaic = new p(2048, 2048, 500), this._glyphSource = new r9(`${s2.fontsUrl}/{fontstack}/{range}.pbf`), this._glyphMosaic = new g3(1024, 1024, this._glyphSource), this._rasterizer = new c2(r18);
  }
  dispose() {
    this._spriteMosaic.dispose(), this._glyphMosaic.dispose(), this._rasterizer.dispose(), this._sdfConverter.dispose(), this._spriteMosaic = null, this._glyphMosaic = null, this._sdfConverter = null, this._hashToBindingIndex.clear(), this._hashToBindingIndex = null, this._bindingInfos = null, this._ongoingRasterizations.clear(), this._ongoingRasterizations = null, this._imageRequestQueue.clear(), this._imageRequestQueue = null;
  }
  get sprites() {
    return this._spriteMosaic;
  }
  get glyphs() {
    return this._glyphMosaic;
  }
  async rasterizeItem(e16, t18, i16, s16) {
    if (t(e16))
      return Q("mapview-null-resource", "Unable to rasterize null resource"), null;
    switch (e16.type) {
      case "text":
      case "esriTS": {
        const t19 = await this._rasterizeText(e16, i16, s16);
        return t19.forEach((e17) => this._setTextureBinding(O3.GLYPH, e17)), { glyphMosaicItems: t19 };
      }
      default: {
        if (Ne(e16))
          return Q("mapview-invalid-type", `MapView does not support symbol type: ${e16.type}`, e16), null;
        const i17 = await this._rasterizeSpriteSymbol(e16, t18, s16);
        return e5(i17) && i17 && this._setTextureBinding(O3.SPRITE, i17), { spriteMosaicItem: i17 };
      }
    }
  }
  bindTextures(e16, t18, i16, s16 = false) {
    if (0 === i16.textureBinding)
      return;
    const r18 = this._bindingInfos[i16.textureBinding - 1], n23 = r18.page, o17 = s16 ? L.LINEAR_MIPMAP_LINEAR : L.LINEAR;
    switch (r18.mosaicType) {
      case O3.SPRITE: {
        const i17 = this.sprites.getWidth(n23), s17 = this.sprites.getHeight(n23), r19 = r5(F2, i17, s17);
        return this._spriteMosaic.bind(e16, o17, n23, y2), t18.setUniform1i("u_texture", y2), void t18.setUniform2fv("u_mosaicSize", r19);
      }
      case O3.GLYPH: {
        const i17 = this.glyphs.width, s17 = this.glyphs.height, r19 = r5(F2, i17, s17);
        return this._glyphMosaic.bind(e16, o17, n23, z), t18.setUniform1i("u_texture", z), void t18.setUniform2fv("u_mosaicSize", r19);
      }
      default:
        k.error("mapview-texture-manager", `Cannot handle unknown type ${r18.mosaicType}`);
    }
  }
  _hashMosaic(e16, t18) {
    return 1 | e16 << 1 | (t18.sdf ? 1 : 0) << 2 | t18.page << 3;
  }
  _setTextureBinding(e16, t18) {
    const i16 = this._hashMosaic(e16, t18);
    if (!this._hashToBindingIndex.has(i16)) {
      const s16 = O4.fromMosaic(e16, t18), r18 = this._bindingInfos.length + 1;
      this._hashToBindingIndex.set(i16, r18), this._bindingInfos.push(s16);
    }
    t18.textureBinding = this._hashToBindingIndex.get(i16);
  }
  async _rasterizeText(e16, t18, s16) {
    let n23, o17;
    if ("cim" in e16) {
      const t19 = e16;
      n23 = t19.fontName, o17 = t19.text;
    } else {
      const t19 = e16;
      n23 = i3(t19.font), o17 = t19.text;
    }
    const a18 = this._invalidFontsMap.has(n23), h9 = t18 || ve(n8(o17)[0]);
    try {
      return await this._glyphMosaic.getGlyphItems(a18 ? $2 : n23, h9, s16);
    } catch (c13) {
      return Q("mapview-invalid-resource", `Couldn't find font ${n23}. Falling back to Arial Unicode MS Regular`), this._invalidFontsMap.set(n23, true), this._glyphMosaic.getGlyphItems($2, h9, s16);
    }
  }
  async _rasterizeSpriteSymbol(e16, t18, i16) {
    if (Me(e16))
      return null;
    const r18 = e13(e16);
    if (this._spriteMosaic.has(r18))
      return this._spriteMosaic.getSpriteItem(r18);
    if (Ie(e16) || Te(e16) && !Be(e16))
      return this._handleAsyncResource(r18, e16, i16);
    const n23 = bt, o17 = this._rasterizer.rasterizeJSONResource(e16, n23);
    if (o17) {
      const { size: t19, image: i17, sdf: s16, simplePattern: n24, rasterizationScale: a18 } = o17;
      return this._addItemToMosaic(r18, t19, { type: "static", data: i17 }, _e(e16), s16, n24, a18);
    }
    return new s4("TextureManager", "unrecognized or null rasterized image");
  }
  async _handleAsyncResource(e16, t18, i16) {
    if (this._ongoingRasterizations.has(e16))
      return this._ongoingRasterizations.get(e16);
    let s16;
    s16 = Ie(t18) ? this._handleSVG(t18, e16, i16) : this._handleImage(t18, e16, i16), this._ongoingRasterizations.set(e16, s16);
    try {
      await s16, this._ongoingRasterizations.delete(e16);
    } catch {
      this._ongoingRasterizations.delete(e16);
    }
    return s16;
  }
  async _handleSVG(e16, t18, i16) {
    const s16 = [N2, N2], r18 = await this._sdfConverter.draw(e16.path, i16);
    return this._addItemToMosaic(t18, s16, { type: "static", data: new Uint32Array(r18.buffer) }, false, true, true);
  }
  async _handleGIFOrPNG(e16, t18, i16) {
    const r18 = Ee(e16);
    await this.resourceManager.fetchResource(r18, i16);
    const n23 = this.resourceManager.getResource(r18);
    if (t(n23))
      return new s4("mapview-invalid-resource", `Could not fetch requested resource at ${r18}.`);
    if (n23 instanceof HTMLImageElement) {
      let i17 = n23.width, s16 = n23.height;
      "esriPMS" === e16.type && (i17 = Math.round(H(n23.width, Ue(e16))), s16 = Math.round(n23.height * (i17 / n23.width)));
      const r19 = "cim" in e16 ? e16.cim.colorSubstitutions : void 0, { size: o17, sdf: a19, image: h10 } = this._rasterizer.rasterizeImageResource(i17, s16, n23, r19);
      return this._addItemToMosaic(t18, o17, { type: "static", data: h10 }, _e(e16), a19, false);
    }
    const a18 = e16.animatedSymbolProperties || {}, h9 = e16.objectId, c13 = new e12(n23, this._requestRender, a18, h9);
    return this._addItemToMosaic(t18, [c13.width, c13.height], { type: "animated", data: c13 }, _e(e16), false, false);
  }
  async _handleImage(e16, t18, i16) {
    var _a;
    if (we(e16) || Ae(e16))
      return this._handleGIFOrPNG(e16, t18, i16);
    const r18 = Ee(e16);
    try {
      let s16;
      const n23 = this.resourceManager.getResource(r18);
      if (r(n23) && n23 instanceof HTMLImageElement)
        s16 = n23;
      else {
        const { data: e17 } = await this._imageRequestQueue.push(r18, { ...i16 });
        s16 = e17;
      }
      if (De(r18)) {
        if ("width" in e16 && "height" in e16)
          s16.width = u(e16.width), s16.height = u(e16.height);
        else if ("cim" in e16) {
          const t19 = e16.cim;
          s16.width = u((_a = t19.width) != null ? _a : t19.scaleX * t19.size), s16.height = u(t19.size);
        }
      }
      if (!s16.width || !s16.height)
        return null;
      let o17 = s16.width, h9 = s16.height;
      "esriPMS" === e16.type && (o17 = Math.round(H(s16.width, Ue(e16))), h9 = Math.round(s16.height * (o17 / s16.width)));
      const c13 = "cim" in e16 ? e16.cim.colorSubstitutions : void 0, { size: d15, sdf: m10, image: l17 } = this._rasterizer.rasterizeImageResource(o17, h9, s16, c13);
      return this._addItemToMosaic(t18, d15, { type: "static", data: l17 }, _e(e16), m10, false);
    } catch (n23) {
      if (!j(n23))
        return new s4("mapview-invalid-resource", `Could not fetch requested resource at ${r18}. ${n23.message}`);
    }
  }
  _addItemToMosaic(e16, t18, i16, s16, r18, n23, o17) {
    return this._spriteMosaic.addSpriteItem(e16, t18, i16, s16, r18, n23, o17);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/TextureUploadManager.js
var i9 = class {
  constructor(e16, t18) {
    this._queue = [], this._context = e16, this._refreshable = t18;
  }
  destroy() {
    this._queue = [];
  }
  enqueueTextureUpdate(e16, r18) {
    const i16 = D(), h9 = e16, a18 = wt, c13 = Math.ceil(h9.height / a18);
    if (f(r18), this._context.type === r7.WEBGL1)
      this._queue.push({ type: "no-chunk", request: e16, resolver: i16, options: r18 });
    else
      for (let t18 = 0; t18 < c13; t18++) {
        const s16 = t18 * a18, o17 = t18 === c13 - 1, u10 = o17 ? h9.height - a18 * t18 : a18;
        this._queue.push({ type: "chunk", request: e16, resolver: i16, chunk: t18, chunkOffset: s16, destHeight: u10, chunkIsLast: o17, options: r18 });
      }
    return d2(r18, (e17) => i16.reject(e17)), i16.promise;
  }
  upload() {
    let t18 = 0;
    for (; this._queue.length; ) {
      const s16 = performance.now(), o17 = this._queue.shift();
      if (o17) {
        if (r(o17.options.signal) && o17.options.signal.aborted)
          continue;
        switch (o17.type) {
          case "chunk":
            this._uploadChunk(o17);
            break;
          case "no-chunk":
            this._uploadNoChunk(o17);
        }
        const u10 = performance.now() - s16;
        if (t18 += u10, t18 + u10 >= xt)
          break;
      }
    }
    this._queue.length && this._refreshable.requestRender();
  }
  _uploadChunk(t18) {
    const { request: s16, resolver: o17, chunkOffset: r18, chunkIsLast: u10, destHeight: n23 } = t18, { data: i16, texture: h9, width: a18 } = s16;
    r(i16) && (h9.updateData(0, 0, r18, a18, n23, i16, r18), u10 && o17.resolve());
  }
  _uploadNoChunk(e16) {
    const { request: t18, resolver: s16 } = e16, { data: o17, texture: r18 } = t18;
    r18.setData(o17), s16.resolve();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/StencilPrograms.js
var r11 = { shaders: { vertexShader: n12("stencil/stencil.vert"), fragmentShader: n12("stencil/stencil.frag") }, attributes: /* @__PURE__ */ new Map([["a_pos", 0]]) };

// node_modules/@arcgis/core/views/2d/engine/webgl/WorldExtentClipRenderer.js
var u4 = r6(-0.5, -0.5);
var f5 = class {
  constructor() {
    this._centerNdc = n(), this._pxToNdc = n(), this._worldDimensionsPx = n(), this._mat3 = e3(), this._initialized = false;
  }
  dispose() {
    this._program = a(this._program), this._quad = a(this._quad);
  }
  render(t18, s16) {
    const { context: i16 } = t18;
    return !!this._updateGeometry(t18, s16) && (this._initialized || this._initialize(i16), i16.setDepthWriteEnabled(false), i16.setDepthTestEnabled(false), i16.setColorMask(false, false, false, false), i16.setBlendingEnabled(false), i16.setStencilOp(O.KEEP, O.KEEP, O.REPLACE), i16.setStencilFunction(I.ALWAYS, 1, 255), i16.setStencilTestEnabled(true), i16.useProgram(this._program), this._program.setUniformMatrix3fv("u_worldExtent", this._mat3), this._quad.draw(), this._quad.unbind(), true);
  }
  _initialize(t18) {
    if (this._initialized)
      return;
    const s16 = e8(t18, r11);
    s16 && (this._program = s16, this._quad = new n11(t18, [0, 0, 1, 0, 0, 1, 1, 1]), this._initialized = true);
  }
  _updateGeometry(t18, a18) {
    const { state: n23, pixelRatio: m10 } = t18, { size: c13, rotation: d15 } = n23, p6 = Math.round(c13[0] * m10), _9 = Math.round(c13[1] * m10);
    if (!n23.spatialReference.isWrappable)
      return false;
    const l17 = r3(d15), f10 = Math.abs(Math.cos(l17)), b4 = Math.abs(Math.sin(l17)), g8 = Math.round(p6 * f10 + _9 * b4), j6 = Math.round(n23.worldScreenWidth);
    if (g8 <= j6)
      return false;
    const x2 = p6 * b4 + _9 * f10, E5 = j6 * m10, M4 = (a18.left - a18.right) * m10 / p6, w3 = (a18.bottom - a18.top) * m10 / _9;
    o(this._worldDimensionsPx, E5, x2, 1), o(this._pxToNdc, 2 / p6, -2 / _9, 1), o(this._centerNdc, M4, w3, 1);
    const P5 = this._mat3;
    return l2(P5, this._centerNdc), f3(P5, P5, this._pxToNdc), 0 !== d15 && h2(P5, P5, l17), f3(P5, P5, this._worldDimensionsPx), M(P5, P5, u4), true;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/AnimationEffect.js
var o13 = class extends t7 {
  constructor() {
    super(...arguments), this.defines = [], this._desc = { vsPath: "fx/integrate", fsPath: "fx/integrate", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) };
  }
  dispose() {
    this._quad && this._quad.dispose();
  }
  bind() {
  }
  unbind() {
  }
  draw(r18, i16) {
    if (!i16.size)
      return;
    const { context: a18, renderingOptions: o17 } = r18;
    this._quad || (this._quad = new n11(a18, [0, 0, 1, 0, 0, 1, 1, 1]));
    const n23 = a18.getBoundFramebufferObject(), { x: u10, y: m10, width: d15, height: f10 } = a18.getViewport();
    i16.bindTextures(a18);
    const c13 = i16.getBlock(N);
    if (t(c13))
      return;
    const _9 = c13.getFBO(a18), l17 = c13.getFBO(a18, 1);
    a18.setViewport(0, 0, i16.size, i16.size), this._computeDelta(r18, l17, o17.labelsAnimationTime), this._updateAnimationState(r18, l17, _9), a18.bindFramebuffer(n23), a18.setViewport(u10, m10, d15, f10);
  }
  _computeDelta(e16, t18, s16) {
    const { context: a18, painter: o17, displayLevel: n23 } = e16, u10 = o17.materialManager.getProgram(this._desc, ["delta"]);
    a18.bindFramebuffer(t18), a18.setClearColor(0, 0, 0, 0), a18.clear(a18.gl.COLOR_BUFFER_BIT), a18.useProgram(u10), u10.setUniform1i("u_maskTexture", B2), u10.setUniform1i("u_sourceTexture", C2), u10.setUniform1f("u_timeDelta", e16.deltaTime), u10.setUniform1f("u_animationTime", s16), u10.setUniform1f("u_zoomLevel", Math.round(10 * n23)), this._quad.draw();
  }
  _updateAnimationState(e16, t18, r18) {
    const { context: i16, painter: s16 } = e16, a18 = s16.materialManager.getProgram(this._desc, ["update"]);
    i16.bindTexture(t18.colorTexture, 1), i16.useProgram(a18), a18.setUniform1i("u_sourceTexture", 1), i16.bindFramebuffer(r18), i16.setClearColor(0, 0, 0, 0), i16.clear(i16.gl.COLOR_BUFFER_BIT), this._quad.draw();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/BlendPrograms.js
var r12 = (e16) => e16.replace("-", "_").toUpperCase();
var t12 = (e16) => `#define ${r12(e16)}
`;
function n18(r18) {
  return { attributes: /* @__PURE__ */ new Map([["a_pos", 0], ["a_tex", 1]]), shaders: { vertexShader: t12(r18) + n12("blend/blend.vert"), fragmentShader: t12(r18) + n12("blend/blend.frag") } };
}

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/BlendEffect.js
var l6 = s3.getLogger("esri.views.2d.engine.webgl.effects.blendEffects.BlendEffect");
var _2 = class {
  constructor() {
    this._size = [0, 0];
  }
  dispose(e16) {
    this._backBufferTexture = a(this._backBufferTexture), this._quad = a(this._quad);
  }
  draw(r18, t18, s16, a18, d15) {
    const { context: u10, drawPhase: f10 } = r18;
    if (this._setupShader(u10), a18 && "normal" !== a18 && f10 !== I3.LABEL)
      return void this._drawBlended(r18, t18, s16, a18, d15);
    const c13 = n18("normal"), m10 = u10.programCache.acquire(c13.shaders.vertexShader, c13.shaders.fragmentShader, c13.attributes);
    if (!m10)
      return void l6.error(new s4("mapview-BlendEffect", 'Error creating shader program for blend mode "normal"'));
    u10.useProgram(m10), t18.setSamplingMode(s16), u10.bindTexture(t18, 0), m10.setUniform1i("u_layerTexture", 0), m10.setUniform1f("u_opacity", d15), u10.setBlendingEnabled(true), u10.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA);
    const h9 = this._quad;
    h9.draw(), h9.unbind(), m10.dispose();
  }
  _drawBlended(r18, t18, i16, a18, d15) {
    const { context: u10, state: f10, pixelRatio: c13, inFadeTransition: m10 } = r18, { size: h9 } = f10, _9 = u10.getBoundFramebufferObject();
    let p6, b4;
    if (r(_9)) {
      const e16 = _9.descriptor;
      p6 = e16.width, b4 = e16.height;
    } else
      p6 = Math.round(c13 * h9[0]), b4 = Math.round(c13 * h9[1]);
    this._createOrResizeTexture(r18, p6, b4);
    const g8 = this._backBufferTexture;
    _9.copyToTexture(0, 0, p6, b4, 0, 0, g8), u10.setStencilTestEnabled(false), u10.setStencilWriteMask(0), u10.setBlendingEnabled(true), u10.setDepthTestEnabled(false), u10.setDepthWriteEnabled(false);
    const x2 = n18(a18), E5 = u10.programCache.acquire(x2.shaders.vertexShader, x2.shaders.fragmentShader, x2.attributes);
    if (!E5)
      return void l6.error(new s4("mapview-BlendEffect", `Error creating shader program for blend mode ${a18}`));
    u10.useProgram(E5), g8.setSamplingMode(i16), u10.bindTexture(g8, 0), E5.setUniform1i("u_backbufferTexture", 0), t18.setSamplingMode(i16), u10.bindTexture(t18, 1), E5.setUniform1i("u_layerTexture", 1), E5.setUniform1f("u_opacity", d15), E5.setUniform1f("u_inFadeOpacity", m10 ? 1 : 0), u10.setBlendFunction(R.ONE, R.ZERO);
    const T4 = this._quad;
    T4.draw(), T4.unbind(), E5.dispose(), u10.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA);
  }
  _setupShader(e16) {
    this._quad || (this._quad = new n11(e16, [-1, -1, 1, -1, -1, 1, 1, 1]));
  }
  _createOrResizeTexture(e16, r18, t18) {
    const { context: s16 } = e16;
    null !== this._backBufferTexture && r18 === this._size[0] && t18 === this._size[1] || (this._backBufferTexture ? this._backBufferTexture.resize(r18, t18) : this._backBufferTexture = new E2(s16, { target: M2.TEXTURE_2D, pixelFormat: P.RGBA, internalFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, wrapMode: D2.CLAMP_TO_EDGE, samplingMode: L.LINEAR, flipped: false, width: r18, height: t18 }), this._size[0] = r18, this._size[1] = t18);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/FeatureEffect.js
var r13 = class extends t7 {
  constructor(e16) {
    super(), this.name = this.constructor.name, this.defines = [e16];
  }
  dispose() {
  }
  bind({ context: e16, painter: t18 }) {
    this._prev = e16.getBoundFramebufferObject();
    const { width: r18, height: s16 } = e16.getViewport(), o17 = t18.getFbos(r18, s16).effect0;
    e16.bindFramebuffer(o17), e16.setColorMask(true, true, true, true), e16.setClearColor(0, 0, 0, 0), e16.clear(e16.gl.COLOR_BUFFER_BIT);
  }
  unbind() {
  }
  draw(e16, r18) {
    const { context: s16, painter: o17 } = e16, n23 = o17.getPostProcessingEffects(r18), c13 = s16.getBoundFramebufferObject();
    for (const { postProcessingEffect: t18, effect: f10 } of n23)
      t18.draw(e16, c13, f10);
    s16.bindFramebuffer(this._prev), s16.setStencilTestEnabled(false), o17.blitTexture(s16, c13.colorTexture, L.NEAREST), s16.setStencilTestEnabled(true);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/highlight/parameters.js
var o14 = 1;
var t13 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1];
var i10 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
var n19 = 256;
var e14 = { outlineWidth: 1.3, outerHaloWidth: 0.4, innerHaloWidth: 0.4, outlinePosition: 0 };

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/highlight/HighlightGradient.js
var u5 = s3.getLogger("esri.views.2d.engine.webgl.painter.highlight.HighlightGradient");
function C3(o17, i16) {
  i16.fillColor[0] = o17.color.r / 255, i16.fillColor[1] = o17.color.g / 255, i16.fillColor[2] = o17.color.b / 255, i16.fillColor[3] = o17.color.a, o17.haloColor ? (i16.outlineColor[0] = o17.haloColor.r / 255, i16.outlineColor[1] = o17.haloColor.g / 255, i16.outlineColor[2] = o17.haloColor.b / 255, i16.outlineColor[3] = o17.haloColor.a) : (i16.outlineColor[0] = i16.fillColor[0], i16.outlineColor[1] = i16.fillColor[1], i16.outlineColor[2] = i16.fillColor[2], i16.outlineColor[3] = i16.fillColor[3]), i16.fillColor[3] *= o17.fillOpacity, i16.outlineColor[3] *= o17.haloOpacity, i16.fillColor[0] *= i16.fillColor[3], i16.fillColor[1] *= i16.fillColor[3], i16.fillColor[2] *= i16.fillColor[3], i16.outlineColor[0] *= i16.outlineColor[3], i16.outlineColor[1] *= i16.outlineColor[3], i16.outlineColor[2] *= i16.outlineColor[3], i16.outlineWidth = e14.outlineWidth, i16.outerHaloWidth = e14.outerHaloWidth, i16.innerHaloWidth = e14.innerHaloWidth, i16.outlinePosition = e14.outlinePosition;
}
var g5 = [0, 0, 0, 0];
var f6 = class {
  constructor() {
    this._convertedHighlightOptions = { fillColor: [0.2 * 0.75, 0.6 * 0.75, 0.675, 0.75], outlineColor: [0.2 * 0.9, 0.54, 0.81, 0.9], outlinePosition: e14.outlinePosition, outlineWidth: e14.outlineWidth, innerHaloWidth: e14.innerHaloWidth, outerHaloWidth: e14.outerHaloWidth }, this._shadeTexChanged = true, this._texelData = new Uint8Array(4 * n19), this._minMaxDistance = [0, 0];
  }
  setHighlightOptions(o17) {
    const i16 = this._convertedHighlightOptions;
    C3(o17, i16);
    const t18 = i16.outlinePosition - i16.outlineWidth / 2 - i16.outerHaloWidth, r18 = i16.outlinePosition - i16.outlineWidth / 2, n23 = i16.outlinePosition + i16.outlineWidth / 2, h9 = i16.outlinePosition + i16.outlineWidth / 2 + i16.innerHaloWidth, a18 = Math.sqrt(Math.PI / 2) * o14, s16 = Math.abs(t18) > a18 ? Math.round(10 * (Math.abs(t18) - a18)) / 10 : 0, d15 = Math.abs(h9) > a18 ? Math.round(10 * (Math.abs(h9) - a18)) / 10 : 0;
    let f10;
    s16 && !d15 ? u5.error("The outer rim of the highlight is " + s16 + "px away from the edge of the feature; consider reducing some width values or shifting the outline position towards positive values (inwards).") : !s16 && d15 ? u5.error("The inner rim of the highlight is " + d15 + "px away from the edge of the feature; consider reducing some width values or shifting the outline position towards negative values (outwards).") : s16 && d15 && u5.error("The highlight is " + Math.max(s16, d15) + "px away from the edge of the feature; consider reducing some width values.");
    const c13 = [void 0, void 0, void 0, void 0];
    function m10(o18, i17, t19) {
      c13[0] = (1 - t19) * o18[0] + t19 * i17[0], c13[1] = (1 - t19) * o18[1] + t19 * i17[1], c13[2] = (1 - t19) * o18[2] + t19 * i17[2], c13[3] = (1 - t19) * o18[3] + t19 * i17[3];
    }
    const { _texelData: p6 } = this;
    for (let l17 = 0; l17 < n19; ++l17)
      f10 = t18 + l17 / (n19 - 1) * (h9 - t18), f10 < t18 ? (c13[4 * l17 + 0] = 0, c13[4 * l17 + 1] = 0, c13[4 * l17 + 2] = 0, c13[4 * l17 + 3] = 0) : f10 < r18 ? m10(g5, i16.outlineColor, (f10 - t18) / (r18 - t18)) : f10 < n23 ? [c13[0], c13[1], c13[2], c13[3]] = i16.outlineColor : f10 < h9 ? m10(i16.outlineColor, i16.fillColor, (f10 - n23) / (h9 - n23)) : [c13[4 * l17 + 0], c13[4 * l17 + 1], c13[4 * l17 + 2], c13[4 * l17 + 3]] = i16.fillColor, p6[4 * l17 + 0] = 255 * c13[0], p6[4 * l17 + 1] = 255 * c13[1], p6[4 * l17 + 2] = 255 * c13[2], p6[4 * l17 + 3] = 255 * c13[3];
    this._minMaxDistance[0] = t18, this._minMaxDistance[1] = h9, this._shadeTexChanged = true;
  }
  applyHighlightOptions(o17, t18) {
    this._shadeTex || (this._shadeTex = new E2(o17, { target: M2.TEXTURE_2D, pixelFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, wrapMode: D2.CLAMP_TO_EDGE, width: n19, height: 1, samplingMode: L.LINEAR })), this._shadeTexChanged && (this._shadeTex.updateData(0, 0, 0, n19, 1, this._texelData), this._shadeTexChanged = false), o17.bindTexture(this._shadeTex, J), t18.setUniform2fv("u_minMaxDistance", this._minMaxDistance);
  }
  destroy() {
    this._shadeTex && (this._shadeTex.dispose(), this._shadeTex = null);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/HighlightPrograms.js
var t14 = { shaders: { vertexShader: n12("highlight/textured.vert"), fragmentShader: n12("highlight/highlight.frag") }, attributes: /* @__PURE__ */ new Map([["a_position", 0], ["a_texcoord", 1]]) };
var r14 = { shaders: { vertexShader: n12("highlight/textured.vert"), fragmentShader: n12("highlight/blur.frag") }, attributes: /* @__PURE__ */ new Map([["a_position", 0], ["a_texcoord", 1]]) };

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/highlight/HighlightRenderer.js
var c6 = class {
  constructor() {
    this._width = void 0, this._height = void 0, this._resources = null;
  }
  dispose() {
    this._resources && (this._resources.quadGeometry.dispose(), this._resources.quadVAO.dispose(), this._resources.highlightProgram.dispose(), this._resources.blurProgram.dispose(), this._resources = null);
  }
  preBlur(e16, i16) {
    e16.bindTexture(i16, I2), e16.useProgram(this._resources.blurProgram), this._resources.blurProgram.setUniform4fv("u_direction", [1, 0, 1 / this._width, 0]), this._resources.blurProgram.setUniformMatrix4fv("u_channelSelector", t13), e16.bindVAO(this._resources.quadVAO), e16.drawArrays(E.TRIANGLE_STRIP, 0, 4), e16.bindVAO();
  }
  finalBlur(e16, s16) {
    e16.bindTexture(s16, I2), e16.useProgram(this._resources.blurProgram), this._resources.blurProgram.setUniform4fv("u_direction", [0, 1, 0, 1 / this._height]), this._resources.blurProgram.setUniformMatrix4fv("u_channelSelector", i10), e16.bindVAO(this._resources.quadVAO), e16.drawArrays(E.TRIANGLE_STRIP, 0, 4), e16.bindVAO();
  }
  renderHighlight(e16, s16, i16) {
    e16.bindTexture(s16, I2), e16.useProgram(this._resources.highlightProgram), i16.applyHighlightOptions(e16, this._resources.highlightProgram), e16.bindVAO(this._resources.quadVAO), e16.setBlendingEnabled(true), e16.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), e16.drawArrays(E.TRIANGLE_STRIP, 0, 4), e16.bindVAO();
  }
  _initialize(s16, i16, a18) {
    this._width = i16, this._height = a18;
    const m10 = E3.createVertex(s16, F.STATIC_DRAW, new Int8Array([-1, -1, 0, 0, 1, -1, 1, 0, -1, 1, 0, 1, 1, 1, 1, 1]).buffer), c13 = new a7(s16, /* @__PURE__ */ new Map([["a_position", 0], ["a_texcoord", 1]]), { geometry: [new t4("a_position", 2, C.BYTE, 0, 4), new t4("a_texcoord", 2, C.UNSIGNED_BYTE, 2, 4)] }, { geometry: m10 }), f10 = e8(s16, t14), b4 = e8(s16, r14);
    s16.useProgram(f10), f10.setUniform1i("u_texture", I2), f10.setUniform1i("u_shade", J), f10.setUniform1f("u_sigma", o14), s16.useProgram(b4), b4.setUniform1i("u_texture", I2), b4.setUniform1f("u_sigma", o14), this._resources = { quadGeometry: m10, quadVAO: c13, highlightProgram: f10, blurProgram: b4 };
  }
  setup(r18, e16, s16) {
    this._resources ? (this._width = e16, this._height = s16) : this._initialize(r18, e16, s16);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/highlight/HighlightSurfaces.js
function l7(e16, l17, _9) {
  const c13 = new E2(e16, { target: M2.TEXTURE_2D, pixelFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, wrapMode: D2.CLAMP_TO_EDGE, width: l17, height: _9, samplingMode: L.LINEAR });
  return [c13, new x(e16, { colorTarget: Y.TEXTURE, depthStencilTarget: V.STENCIL_RENDER_BUFFER }, c13)];
}
var _3 = class {
  constructor() {
    this._width = void 0, this._height = void 0, this._resources = null;
  }
  dispose() {
    this._resources && (this._resources.sharedBlur1Tex.dispose(), this._resources.sharedBlur1Fbo.dispose(), this._resources.sharedBlur2Tex.dispose(), this._resources.sharedBlur2Fbo.dispose(), this._resources = d(this._resources));
  }
  _initialize(e16, s16, r18) {
    this._width = s16, this._height = r18;
    const [t18, i16] = l7(e16, s16, r18), [h9, o17] = l7(e16, s16, r18);
    this._resources = { sharedBlur1Tex: t18, sharedBlur1Fbo: i16, sharedBlur2Tex: h9, sharedBlur2Fbo: o17 };
  }
  setup(e16, s16, r18) {
    !this._resources || this._width === s16 && this._height === r18 || this.dispose(), this._resources || this._initialize(e16, s16, r18);
  }
  get sharedBlur1Tex() {
    return this._resources.sharedBlur1Tex;
  }
  get sharedBlur1Fbo() {
    return this._resources.sharedBlur1Fbo;
  }
  get sharedBlur2Tex() {
    return this._resources.sharedBlur2Tex;
  }
  get sharedBlur2Fbo() {
    return this._resources.sharedBlur2Fbo;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/HighlightEffect.js
var l8 = 4;
var d5 = 4 / l8;
var n20 = class extends t7 {
  constructor() {
    super(...arguments), this.defines = ["highlight"], this._hlRenderer = new c6(), this._hlGradient = new f6(), this._width = void 0, this._height = void 0, this._hlSurfaces = new _3(), this._adjustedWidth = void 0, this._adjustedHeight = void 0, this._blitRenderer = new _();
  }
  dispose() {
    this._hlSurfaces && this._hlSurfaces.dispose(), this._hlRenderer && this._hlRenderer.dispose(), this._hlGradient && this._hlGradient.destroy(), this._boundFBO = null;
  }
  bind(e16) {
    const { context: t18, painter: s16 } = e16, { width: i16, height: h9 } = t18.getViewport(), r18 = s16.getFbos(i16, h9).effect0;
    this.setup(e16, i16, h9), t18.bindFramebuffer(r18), t18.setColorMask(true, true, true, true), t18.setClearColor(0, 0, 0, 0), t18.clear(t18.gl.COLOR_BUFFER_BIT);
  }
  unbind() {
  }
  setup({ context: e16 }, t18, s16) {
    this._width = t18, this._height = s16;
    const i16 = t18 % l8, h9 = s16 % l8;
    t18 += i16 < l8 / 2 ? -i16 : l8 - i16, s16 += h9 < l8 / 2 ? -h9 : l8 - h9, this._adjustedWidth = t18, this._adjustedHeight = s16, this._boundFBO = e16.getBoundFramebufferObject();
    const r18 = Math.round(t18 * d5), n23 = Math.round(s16 * d5);
    this._hlRenderer.setup(e16, r18, n23), this._hlSurfaces.setup(e16, r18, n23);
  }
  draw({ context: e16 }) {
    const t18 = e16.getBoundFramebufferObject();
    e16.setViewport(0, 0, this._adjustedWidth * d5, this._adjustedHeight * d5), e16.bindFramebuffer(this._hlSurfaces.sharedBlur1Fbo), e16.setStencilTestEnabled(false), e16.setClearColor(0, 0, 0, 0), e16.clear(e16.gl.COLOR_BUFFER_BIT), this._blitRenderer.render(e16, t18.colorTexture, L.NEAREST, 1), e16.setStencilTestEnabled(false), e16.setBlendingEnabled(false), e16.setColorMask(false, false, false, true), e16.bindFramebuffer(this._hlSurfaces.sharedBlur2Fbo), e16.setClearColor(0, 0, 0, 0), e16.clear(e16.gl.COLOR_BUFFER_BIT), this._hlRenderer.preBlur(e16, this._hlSurfaces.sharedBlur1Tex), e16.bindFramebuffer(this._hlSurfaces.sharedBlur1Fbo), e16.setClearColor(0, 0, 0, 0), e16.clear(e16.gl.COLOR_BUFFER_BIT), this._hlRenderer.finalBlur(e16, this._hlSurfaces.sharedBlur2Tex), e16.bindFramebuffer(this._boundFBO), e16.setBlendingEnabled(true), e16.setColorMask(true, true, true, true), e16.setViewport(0, 0, this._width, this._height), this._hlRenderer.renderHighlight(e16, this._hlSurfaces.sharedBlur1Tex, this._hlGradient), this._boundFBO = null;
  }
  setHighlightOptions(e16) {
    this._hlGradient.setHighlightOptions(e16);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/HittestEffect.js
var c7 = class extends t7 {
  constructor() {
    super(...arguments), this.name = this.constructor.name, this.defines = ["hittest"];
  }
  dispose() {
    r(this._fbo) && this._fbo.dispose();
  }
  createOptions({ pixelRatio: t18 }, e16, s16 = Y2) {
    if (!e16.length)
      return null;
    const r18 = e16.shift(), o17 = r18.x, n23 = r18.y;
    return this._outstanding = r18, { type: "hittest", distance: s16 * t18, position: [o17, n23] };
  }
  bind(t18) {
    const { context: i16, attributeView: r18 } = t18;
    if (!r18.size)
      return;
    const o17 = r18.getBlock(O2);
    if (t(o17))
      return;
    const n23 = o17.getFBO(i16);
    i16.setViewport(0, 0, r18.size, r18.size), i16.bindFramebuffer(n23), i16.setColorMask(true, true, true, true), i16.setClearColor(0, 0, 0, 0), i16.clear(i16.gl.COLOR_BUFFER_BIT | i16.gl.DEPTH_BUFFER_BIT);
  }
  unbind(t18) {
  }
  draw(t18) {
    if (t(this._outstanding))
      return;
    const i16 = this._outstanding;
    this._outstanding = null, this._resolve(t18, i16.resolvers);
  }
  async _resolve(t18, i16) {
    const { context: r18, attributeView: c13 } = t18, a18 = c13.getBlock(O2);
    if (t(a18))
      return void i16.forEach((t19) => t19.resolve([]));
    const d15 = a18.getFBO(r18), h9 = new Uint8Array(d15.width * d15.height * 4);
    try {
      await d15.readPixelsAsync(0, 0, d15.width, d15.height, P.RGBA, G.UNSIGNED_BYTE, h9);
    } catch (u10) {
      return void i16.forEach((t19) => t19.resolve([]));
    }
    const l17 = [];
    for (let e16 = 0; e16 < h9.length; e16 += 4) {
      const t19 = h9[e16], i17 = h9[e16 + 3];
      t19 && l17.push({ id: e16 / 4, directHits: i17 });
    }
    l17.sort((t19, e16) => e16.directHits === t19.directHits ? e16.id - t19.id : e16.directHits - t19.directHits);
    const f10 = l17.map((t19) => t19.id);
    i16.forEach((t19) => t19.resolve(f10));
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/HittestEffectVTL.js
var i11 = class extends t7 {
  constructor() {
    super(...arguments), this.name = this.constructor.name, this.defines = ["id"], this._lastSize = 0;
  }
  dispose() {
    r(this._fbo) && this._fbo.dispose();
  }
  bind({ context: t18, painter: e16 }) {
    const { width: s16, height: o17 } = t18.getViewport();
    this._boundFBO = t18.getBoundFramebufferObject();
    const r18 = e16.getFbos(s16, o17).effect0;
    t18.bindFramebuffer(r18), t18.setColorMask(true, true, true, true), t18.setClearColor(0, 0, 0, 0), t18.clear(t18.gl.COLOR_BUFFER_BIT);
  }
  unbind({ context: t18 }) {
    t18.bindFramebuffer(this._boundFBO), this._boundFBO = null;
  }
  draw(t18, s16, o17 = 2 * Y2) {
    this._resolve(t18, s16, o17);
  }
  async _resolve({ context: t18, state: e16, pixelRatio: s16 }, i16, n23) {
    const f10 = t18.getBoundFramebufferObject(), a18 = e16.size[1] * s16, h9 = Math.round(n23 * s16), u10 = h9 / 2, b4 = h9 / 2;
    this._ensureBuffer(h9), i16.forEach(async (t19, e17) => {
      const n24 = /* @__PURE__ */ new Map(), c13 = Math.floor(e17.x * s16 - h9 / 2), l17 = Math.floor(a18 - e17.y * s16 - h9 / 2);
      await f10.readPixelsAsync(c13, l17, h9, h9, P.RGBA, G.UNSIGNED_BYTE, this._buf);
      for (let s17 = 0; s17 < this._buf32.length; s17++) {
        const t20 = this._buf32[s17];
        if (4294967295 !== t20 && 0 !== t20) {
          const e18 = s17 % h9, o17 = h9 - Math.floor(s17 / h9), r18 = (u10 - e18) * (u10 - e18) + (b4 - o17) * (b4 - o17), i17 = n24.has(t20) ? n24.get(t20) : 4294967295;
          n24.set(t20, Math.min(r18, i17));
        }
      }
      const _9 = Array.from(n24).sort((t20, e18) => t20[1] - e18[1]).map((t20) => t20[0]);
      t19.resolve(_9), i16.delete(e17);
    });
  }
  _ensureBuffer(t18) {
    this._lastSize !== t18 && (this._lastSize = t18, this._buf = new Uint8Array(4 * t18 * t18), this._buf32 = new Uint32Array(this._buf.buffer));
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/Bloom.js
var u6 = 5;
var p2 = [1, 0];
var _4 = [0, 1];
var m7 = [1, 0.8, 0.6, 0.4, 0.2];
var d6 = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var c8 = class {
  constructor() {
    this._intensityFBO = null, this._compositeFBO = null, this._mipsFBOs = new Array(u6), this._nMips = u6, this._kernelSizeArray = [3, 5, 7, 9, 11], this._size = [0, 0], this._programDesc = { luminosityHighPass: { vsPath: "post-processing/pp", fsPath: "post-processing/bloom/luminosityHighPass", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, gaussianBlur: { vsPath: "post-processing/pp", fsPath: "post-processing/bloom/gaussianBlur", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, composite: { vsPath: "post-processing/pp", fsPath: "post-processing/bloom/composite", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, blit: { vsPath: "post-processing/pp", fsPath: "post-processing/blit", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) } };
  }
  dispose() {
    if (this._quad && (this._quad.dispose(), this._quad = null), this._intensityFBO && (this._intensityFBO.dispose(), this._intensityFBO = null), this._compositeFBO && (this._compositeFBO.dispose(), this._compositeFBO = null), this._mipsFBOs) {
      for (let t18 = 0; t18 < this._nMips; t18++)
        this._mipsFBOs[t18] && (this._mipsFBOs[t18].horizontal.dispose(), this._mipsFBOs[t18].vertical.dispose());
      this._mipsFBOs = null;
    }
  }
  draw(i16, s16, r18) {
    const { width: o17, height: n23 } = s16, { context: a18, painter: l17 } = i16, { materialManager: h9 } = l17, c13 = a18.gl, T4 = this._programDesc, { strength: f10, radius: g8, threshold: B3 } = r18;
    this._quad || (this._quad = new n11(a18, [-1, -1, 1, -1, -1, 1, 1, 1])), this._createOrResizeResources(i16, o17, n23), a18.setStencilTestEnabled(false), a18.setBlendingEnabled(true), a18.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), a18.setStencilWriteMask(0);
    const O6 = this._quad;
    O6.bind(), a18.bindFramebuffer(this._intensityFBO);
    const F3 = h9.getProgram(T4.luminosityHighPass);
    a18.useProgram(F3), a18.bindTexture(s16.colorTexture, 0), F3.setUniform1i("u_texture", 0), F3.setUniform3fv("u_defaultColor", [0, 0, 0]), F3.setUniform1f("u_defaultOpacity", 0), F3.setUniform1f("u_luminosityThreshold", B3), F3.setUniform1f("u_smoothWidth", 0.01);
    const b4 = [Math.round(o17 / 2), Math.round(n23 / 2)];
    a18.setViewport(0, 0, b4[0], b4[1]), a18.setClearColor(0, 0, 0, 0), a18.clear(c13.COLOR_BUFFER_BIT), O6.draw(), a18.setBlendingEnabled(false);
    let E5 = this._intensityFBO.colorTexture;
    for (let t18 = 0; t18 < this._nMips; t18++) {
      const e16 = h9.getProgram(T4.gaussianBlur, [{ name: "radius", value: this._kernelSizeArray[t18] }]);
      a18.useProgram(e16), a18.bindTexture(E5, t18 + 1), e16.setUniform1i("u_colorTexture", t18 + 1), e16.setUniform2fv("u_texSize", b4), e16.setUniform2fv("u_direction", p2), a18.setViewport(0, 0, b4[0], b4[1]);
      const i17 = this._mipsFBOs[t18];
      a18.bindFramebuffer(i17.horizontal), O6.draw(), E5 = i17.horizontal.colorTexture, a18.bindFramebuffer(i17.vertical), a18.bindTexture(E5, t18 + 1), e16.setUniform2fv("u_direction", _4), O6.draw(), E5 = i17.vertical.colorTexture, b4[0] = Math.round(b4[0] / 2), b4[1] = Math.round(b4[1] / 2);
    }
    a18.setViewport(0, 0, o17, n23);
    const x2 = h9.getProgram(T4.composite, [{ name: "nummips", value: u6 }]);
    a18.bindFramebuffer(this._compositeFBO), a18.useProgram(x2), x2.setUniform1f("u_bloomStrength", f10), x2.setUniform1f("u_bloomRadius", g8), x2.setUniform1fv("u_bloomFactors", m7), x2.setUniform3fv("u_bloomTintColors", d6), a18.bindTexture(this._mipsFBOs[0].vertical.colorTexture, 1), x2.setUniform1i("u_blurTexture1", 1), a18.bindTexture(this._mipsFBOs[1].vertical.colorTexture, 2), x2.setUniform1i("u_blurTexture2", 2), a18.bindTexture(this._mipsFBOs[2].vertical.colorTexture, 3), x2.setUniform1i("u_blurTexture3", 3), a18.bindTexture(this._mipsFBOs[3].vertical.colorTexture, 4), x2.setUniform1i("u_blurTexture4", 4), a18.bindTexture(this._mipsFBOs[4].vertical.colorTexture, 5), x2.setUniform1i("u_blurTexture5", 5), O6.draw(), a18.bindFramebuffer(s16), a18.setBlendingEnabled(true);
    const w3 = h9.getProgram(T4.blit);
    a18.useProgram(w3), a18.bindTexture(this._compositeFBO.colorTexture, 6), w3.setUniform1i("u_texture", 6), a18.setBlendFunction(R.ONE, R.ONE), O6.draw(), O6.unbind(), a18.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), a18.setStencilTestEnabled(true);
  }
  _createOrResizeResources(t18, e16, u10) {
    const { context: p6 } = t18;
    if (this._compositeFBO && this._size[0] === e16 && this._size[1] === u10)
      return;
    this._size[0] = e16, this._size[1] = u10;
    const _9 = [Math.round(e16 / 2), Math.round(u10 / 2)];
    this._compositeFBO ? this._compositeFBO.resize(e16, u10) : this._compositeFBO = new x(p6, { colorTarget: Y.TEXTURE, depthStencilTarget: V.NONE, width: e16, height: u10 }), this._intensityFBO ? this._intensityFBO.resize(_9[0], _9[1]) : this._intensityFBO = new x(p6, { colorTarget: Y.TEXTURE, depthStencilTarget: V.NONE, width: _9[0], height: _9[1] }, { target: M2.TEXTURE_2D, pixelFormat: P.RGBA, internalFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, wrapMode: D2.CLAMP_TO_EDGE, samplingMode: L.LINEAR, flipped: false, width: _9[0], height: _9[1] });
    for (let m10 = 0; m10 < this._nMips; m10++)
      this._mipsFBOs[m10] ? (this._mipsFBOs[m10].horizontal.resize(_9[0], _9[1]), this._mipsFBOs[m10].vertical.resize(_9[0], _9[1])) : this._mipsFBOs[m10] = { horizontal: new x(p6, { colorTarget: Y.TEXTURE, depthStencilTarget: V.NONE, width: _9[0], height: _9[1] }, { target: M2.TEXTURE_2D, pixelFormat: P.RGBA, internalFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, wrapMode: D2.CLAMP_TO_EDGE, samplingMode: L.LINEAR, flipped: false, width: _9[0], height: _9[1] }), vertical: new x(p6, { colorTarget: Y.TEXTURE, depthStencilTarget: V.NONE, width: _9[0], height: _9[1] }, { target: M2.TEXTURE_2D, pixelFormat: P.RGBA, internalFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, wrapMode: D2.CLAMP_TO_EDGE, samplingMode: L.LINEAR, flipped: false, width: _9[0], height: _9[1] }) }, _9[0] = Math.round(_9[0] / 2), _9[1] = Math.round(_9[1] / 2);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/Blur.js
var d7 = [1, 0];
var _5 = [0, 1];
var b2 = class {
  constructor() {
    this._blurFBO = null, this._size = [0, 0], this._programDesc = { gaussianBlur: { vsPath: "post-processing/pp", fsPath: "post-processing/blur/gaussianBlur", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, radialBlur: { vsPath: "post-processing/pp", fsPath: "post-processing/blur/radial-blur", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, blit: { vsPath: "post-processing/pp", fsPath: "post-processing/blit", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) } };
  }
  dispose() {
    this._blurFBO && (this._blurFBO.dispose(), this._blurFBO = null);
  }
  draw(t18, r18, s16) {
    const { context: i16 } = t18, { type: a18, radius: n23 } = s16;
    if (0 === n23)
      return;
    this._createOrResizeResources(t18), this._quad || (this._quad = new n11(i16, [-1, -1, 1, -1, -1, 1, 1, 1]));
    const o17 = this._quad;
    o17.bind(), "blur" === a18 ? this._gaussianBlur(t18, r18, n23) : this._radialBlur(t18, r18), o17.unbind();
  }
  _gaussianBlur(e16, r18, s16) {
    const { context: i16, state: a18, painter: n23, pixelRatio: o17 } = e16, { size: u10 } = a18, { materialManager: l17 } = n23, b4 = this._programDesc, p6 = this._quad, c13 = [Math.round(o17 * u10[0]), Math.round(o17 * u10[1])], h9 = this._blurFBO, g8 = l17.getProgram(b4.gaussianBlur, [{ name: "radius", value: Math.ceil(s16) }]);
    i16.useProgram(g8), i16.setBlendingEnabled(false), i16.bindFramebuffer(h9), i16.bindTexture(r18.colorTexture, 4), g8.setUniform1i("u_colorTexture", 4), g8.setUniform2fv("u_texSize", c13), g8.setUniform2fv("u_direction", d7), g8.setUniform1f("u_sigma", s16), p6.draw(), i16.bindFramebuffer(r18), i16.setStencilWriteMask(0), i16.setStencilTestEnabled(false), i16.setDepthWriteEnabled(false), i16.setDepthTestEnabled(false), i16.bindTexture(h9.colorTexture, 5), g8.setUniform1i("u_colorTexture", 5), g8.setUniform2fv("u_direction", _5), p6.draw(), i16.setBlendingEnabled(true), i16.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), i16.setStencilTestEnabled(true);
  }
  _radialBlur(e16, r18) {
    const { context: s16, painter: i16 } = e16, { materialManager: a18 } = i16, n23 = this._programDesc, o17 = this._quad, u10 = this._blurFBO;
    s16.bindFramebuffer(u10);
    const l17 = a18.getProgram(n23.radialBlur);
    s16.useProgram(l17), s16.setBlendingEnabled(false), s16.bindTexture(r18.colorTexture, 4), l17.setUniform1i("u_colorTexture", 4), o17.draw(), s16.bindFramebuffer(r18), s16.setStencilWriteMask(0), s16.setStencilTestEnabled(false), s16.setDepthWriteEnabled(false), s16.setDepthTestEnabled(false), s16.setBlendingEnabled(true);
    const d15 = a18.getProgram(n23.blit);
    s16.useProgram(d15), s16.bindTexture(u10.colorTexture, 5), d15.setUniform1i("u_texture", 5), s16.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), o17.draw();
  }
  _createOrResizeResources(e16) {
    const { context: t18, state: d15, pixelRatio: _9 } = e16, { size: b4 } = d15, p6 = Math.round(_9 * b4[0]), c13 = Math.round(_9 * b4[1]);
    this._blurFBO && this._size[0] === p6 && this._size[1] === c13 || (this._size[0] = p6, this._size[1] = c13, this._blurFBO ? this._blurFBO.resize(p6, c13) : this._blurFBO = new x(t18, { colorTarget: Y.TEXTURE, depthStencilTarget: V.NONE, width: p6, height: c13 }, { target: M2.TEXTURE_2D, pixelFormat: P.RGBA, internalFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, wrapMode: D2.CLAMP_TO_EDGE, samplingMode: L.LINEAR, flipped: false, width: p6, height: c13 }));
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/Colorize.js
var l9 = class {
  constructor() {
    this._size = [0, 0], this._programDesc = { vsPath: "post-processing/pp", fsPath: "post-processing/filterEffect", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) };
  }
  dispose() {
    this._layerFBOTexture && (this._layerFBOTexture.dispose(), this._layerFBOTexture = null);
  }
  draw(e16, s16, r18) {
    const { width: i16, height: a18 } = s16;
    this._createOrResizeResources(e16, i16, a18);
    const { context: o17, painter: n23 } = e16, { materialManager: l17 } = n23, _9 = this._programDesc, c13 = this._quad, h9 = r18.colorMatrix;
    c13.bind();
    const u10 = this._layerFBOTexture;
    o17.bindFramebuffer(s16), s16.copyToTexture(0, 0, i16, a18, 0, 0, u10), o17.setBlendingEnabled(false), o17.setStencilTestEnabled(false);
    const d15 = l17.getProgram(_9);
    o17.useProgram(d15), o17.bindTexture(u10, 2), d15.setUniformMatrix4fv("u_coefficients", h9), d15.setUniform1i("u_colorTexture", 2), c13.draw(), o17.setBlendingEnabled(true), o17.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), o17.setStencilTestEnabled(true), c13.unbind();
  }
  _createOrResizeResources(t18, l17, _9) {
    const { context: c13 } = t18;
    this._layerFBOTexture && this._size[0] === l17 && this._size[1] === _9 || (this._size[0] = l17, this._size[1] = _9, this._layerFBOTexture ? this._layerFBOTexture.resize(l17, _9) : this._layerFBOTexture = new E2(c13, { target: M2.TEXTURE_2D, pixelFormat: P.RGBA, internalFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, wrapMode: D2.CLAMP_TO_EDGE, samplingMode: L.LINEAR, flipped: false, width: l17, height: _9 }), this._quad || (this._quad = new n11(c13, [-1, -1, 1, -1, -1, 1, 1, 1])));
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/DropShadow.js
var _6 = [1, 0];
var d8 = [0, 1];
var c9 = class {
  constructor() {
    this._horizontalBlurFBO = null, this._verticalBlurFBO = null, this._size = [0, 0], this._programDesc = { blur: { vsPath: "post-processing/pp", fsPath: "post-processing/blur/gaussianBlur", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, composite: { vsPath: "post-processing/pp", fsPath: "post-processing/drop-shadow/composite", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, blit: { vsPath: "post-processing/pp", fsPath: "post-processing/blit", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) } };
  }
  dispose() {
    this._layerFBOTexture && (this._layerFBOTexture.dispose(), this._layerFBOTexture = null), this._horizontalBlurFBO && (this._horizontalBlurFBO.dispose(), this._horizontalBlurFBO = null), this._verticalBlurFBO && (this._verticalBlurFBO.dispose(), this._verticalBlurFBO = null);
  }
  draw(i16, s16, o17) {
    const { context: a18, state: l17, painter: n23 } = i16, { materialManager: u10 } = n23, h9 = this._programDesc, p6 = s16.width, c13 = s16.height, B3 = [Math.round(p6), Math.round(c13)], { blurRadius: m10, offsetX: T4, offsetY: f10, color: g8 } = o17, F3 = [u(T4), u(f10)];
    this._createOrResizeResources(i16, p6, c13, B3);
    const O6 = this._horizontalBlurFBO, E5 = this._verticalBlurFBO;
    a18.setStencilWriteMask(0), a18.setStencilTestEnabled(false), a18.setDepthWriteEnabled(false), a18.setDepthTestEnabled(false);
    const b4 = this._layerFBOTexture;
    s16.copyToTexture(0, 0, p6, c13, 0, 0, b4), this._quad || (this._quad = new n11(a18, [-1, -1, 1, -1, -1, 1, 1, 1])), a18.setViewport(0, 0, B3[0], B3[1]);
    const w3 = this._quad;
    w3.bind(), a18.setBlendingEnabled(false);
    const x2 = u10.getProgram(h9.blur, [{ name: "radius", value: Math.ceil(m10) }]);
    a18.useProgram(x2), a18.bindFramebuffer(O6), a18.bindTexture(s16.colorTexture, 4), x2.setUniform1i("u_colorTexture", 4), x2.setUniform2fv("u_texSize", B3), x2.setUniform2fv("u_direction", _6), x2.setUniform1f("u_sigma", m10), w3.draw(), a18.bindFramebuffer(E5), a18.bindTexture(O6.colorTexture, 5), x2.setUniform1i("u_colorTexture", 5), x2.setUniform2fv("u_direction", d8), w3.draw(), a18.bindFramebuffer(s16), a18.setViewport(0, 0, p6, c13);
    const M4 = u10.getProgram(h9.composite);
    a18.useProgram(M4), a18.bindTexture(E5.colorTexture, 2), M4.setUniform1i("u_blurTexture", 2), a18.bindTexture(b4, 3), M4.setUniform1i("u_layerFBOTexture", 3), M4.setUniform4fv("u_shadowColor", [g8[3] * (g8[0] / 255), g8[3] * (g8[1] / 255), g8[3] * (g8[2] / 255), g8[3]]), M4.setUniformMatrix3fv("u_displayViewMat3", l17.displayMat3), M4.setUniform2fv("u_shadowOffset", F3), w3.draw(), a18.setBlendingEnabled(true), a18.setStencilTestEnabled(true), a18.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), w3.unbind();
  }
  _createOrResizeResources(e16, t18, r18, _9) {
    const { context: d15 } = e16;
    this._horizontalBlurFBO && this._size[0] === t18 && this._size[1] === r18 || (this._size[0] = t18, this._size[1] = r18, this._horizontalBlurFBO ? this._horizontalBlurFBO.resize(_9[0], _9[1]) : this._horizontalBlurFBO = new x(d15, { colorTarget: Y.TEXTURE, depthStencilTarget: V.NONE, width: _9[0], height: _9[1] }, { target: M2.TEXTURE_2D, pixelFormat: P.RGBA, internalFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, wrapMode: D2.CLAMP_TO_EDGE, samplingMode: L.LINEAR, flipped: false, width: _9[0], height: _9[1] }), this._verticalBlurFBO ? this._verticalBlurFBO.resize(_9[0], _9[1]) : this._verticalBlurFBO = new x(d15, { colorTarget: Y.TEXTURE, depthStencilTarget: V.NONE, width: _9[0], height: _9[1] }, { target: M2.TEXTURE_2D, pixelFormat: P.RGBA, internalFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, wrapMode: D2.CLAMP_TO_EDGE, samplingMode: L.LINEAR, flipped: false, width: _9[0], height: _9[1] }), this._layerFBOTexture ? this._layerFBOTexture.resize(t18, r18) : this._layerFBOTexture = new E2(d15, { target: M2.TEXTURE_2D, pixelFormat: P.RGBA, internalFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, wrapMode: D2.CLAMP_TO_EDGE, samplingMode: L.LINEAR, flipped: false, width: t18, height: r18 }));
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/Opacity.js
var l10 = class {
  constructor() {
    this._size = [0, 0];
  }
  dispose() {
    this._layerFBOTexture && (this._layerFBOTexture.dispose(), this._layerFBOTexture = null);
  }
  draw(t18, s16, r18) {
    const { width: i16, height: a18 } = s16;
    this._createOrResizeResources(t18, i16, a18);
    const { context: l17, painter: o17 } = t18, { amount: T4 } = r18, h9 = l17.gl, n23 = this._layerFBOTexture;
    l17.bindFramebuffer(s16), s16.copyToTexture(0, 0, i16, a18, 0, 0, n23), l17.setBlendingEnabled(true), l17.setStencilTestEnabled(false), l17.setDepthTestEnabled(false), l17.setClearColor(0, 0, 0, 0), l17.clear(h9.COLOR_BUFFER_BIT), o17.blitTexture(l17, n23, L.NEAREST, T4);
  }
  _createOrResizeResources(l17, o17, T4) {
    const { context: h9 } = l17;
    this._layerFBOTexture && this._size[0] === o17 && this._size[1] === T4 || (this._size[0] = o17, this._size[1] = T4, this._layerFBOTexture ? this._layerFBOTexture.resize(o17, T4) : this._layerFBOTexture = new E2(h9, { target: M2.TEXTURE_2D, pixelFormat: P.RGBA, internalFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, wrapMode: D2.CLAMP_TO_EDGE, samplingMode: L.NEAREST, flipped: false, width: o17, height: T4 }));
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/EffectManager.js
function c10(o17) {
  switch (o17) {
    case "bloom":
    case "blur":
    case "opacity":
    case "drop-shadow":
      return o17;
    default:
      return "colorize";
  }
}
var f7 = { colorize: () => new l9(), blur: () => new b2(), bloom: () => new c8(), opacity: () => new l10(), "drop-shadow": () => new c9() };
var i12 = class {
  constructor() {
    this._effectMap = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._effectMap.forEach((o17) => o17.dispose()), this._effectMap.clear();
  }
  getPostProcessingEffects(o17) {
    if (!o17 || 0 === o17.length)
      return [];
    const e16 = [];
    for (const t18 of o17) {
      const o18 = c10(t18.type);
      let s16 = this._effectMap.get(o18);
      s16 || (s16 = f7[o18](), this._effectMap.set(o18, s16)), e16.push({ postProcessingEffect: s16, effect: t18 });
    }
    return e16;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/painter/RenderPass.js
var a13 = class {
  constructor(e16, t18) {
    var _a2;
    this.brushes = e16, this.name = t18.name, this.drawPhase = t18.drawPhase || I3.MAP, this._targetFn = t18.target, this.effects = t18.effects || [], this.enableDefaultDraw = (_a2 = t18.enableDefaultDraw) != null ? _a2 : () => true;
  }
  render(e16) {
    const { context: t18, profiler: r18 } = e16, s16 = this._targetFn(), a18 = this.drawPhase & e16.drawPhase;
    if (r18.recordPassStart(this.name), a18) {
      this.enableDefaultDraw() && this._doRender(e16, s16), r18.recordPassEnd();
      for (const r19 of this.effects) {
        if (!r19.enable())
          continue;
        const a19 = r19.apply, n23 = r19.args && r19.args(), i16 = t18.getViewport(), o17 = t18.getBoundFramebufferObject(), f10 = e16.passOptions;
        this._bindEffect(e16, a19, n23), this._doRender(e16, s16, a19.defines), this._drawAndUnbindEffect(e16, a19, i16, o17, f10, n23);
      }
    }
  }
  _doRender(e16, s16, a18) {
    if (t(s16))
      return;
    const { profiler: n23, context: i16 } = e16;
    for (const t18 of this.brushes) {
      if (n23.recordBrushStart(t18.name), r(t18.brushEffect)) {
        const r18 = i16.getViewport(), n24 = i16.getBoundFramebufferObject(), o17 = e16.passOptions;
        this._bindEffect(e16, t18.brushEffect), this._drawWithBrush(t18, e16, s16, a18), this._drawAndUnbindEffect(e16, t18.brushEffect, r18, n24, o17);
      } else
        this._drawWithBrush(t18, e16, s16, a18);
      n23.recordBrushEnd();
    }
  }
  _drawWithBrush(t18, r18, s16, a18) {
    a3(s16) ? (t18.prepareState(r18, a18), t18.drawMany(r18, s16, a18)) : s16.visible && (t18.prepareState(r18, a18), t18.draw(r18, s16, a18));
  }
  _bindEffect(e16, t18, r18) {
    const { profiler: s16 } = e16;
    s16.recordPassStart(this.name + "." + t18.name), t18.bind(e16, r18);
    const a18 = t18.createOptions(e16, r18);
    e16.passOptions = a18;
  }
  _drawAndUnbindEffect(e16, t18, r18, s16, a18, n23) {
    const { profiler: i16, context: o17 } = e16;
    e16.passOptions = a18, i16.recordBrushStart(t18.name), t18.draw(e16, n23), t18.unbind(e16, n23), o17.bindFramebuffer(s16);
    const { x: f10, y: d15, width: h9, height: c13 } = r18;
    o17.setViewport(f10, d15, h9, c13), i16.recordBrushEnd(), i16.recordPassEnd();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/Painter.js
function D3(e16, t18) {
  switch (e16) {
    case E4.LINE:
      return n13.line;
    case E4.TEXT:
      return n13.text;
    case E4.LABEL:
      return n13.label;
    case E4.FILL:
      return t18 === S.DOT_DENSITY ? n13.dotDensity : n13.fill;
    case E4.MARKER:
      switch (t18) {
        case S.HEATMAP:
          return n13.heatmap;
        case S.PIE_CHART:
          return n13.pieChart;
        default:
          return n13.marker;
      }
  }
}
var I4 = class {
  constructor(e16, t18, s16) {
    this.context = e16, this._blitRenderer = new _(), this._worldExtentClipRenderer = new f5(), this._isClippedToWorldExtent = false, this._brushCache = /* @__PURE__ */ new Map(), this._vtlMaterialManager = new o9(), this._blendEffect = new _2(), this._fboPool = [], this.effects = { highlight: new n20(), hittest: new c7(), hittestVTL: new i11(), integrate: new o13(), insideEffect: new r13("inside"), outsideEffect: new r13("outside") }, this.materialManager = new h4(e16), this.textureManager = new V3(t18, s16), this.textureUploadManager = new i9(e16, t18), this._effectsManager = new i12();
  }
  get vectorTilesMaterialManager() {
    return this._vtlMaterialManager;
  }
  getRenderTarget() {
    return this._renderTarget;
  }
  setRenderTarget(e16) {
    this._renderTarget = e16;
  }
  getFbos(e16, t18) {
    if (e16 !== this._lastWidth || t18 !== this._lastHeight) {
      if (this._lastWidth = e16, this._lastHeight = t18, this._fbos) {
        for (const s17 in this._fbos)
          this._fbos[s17].resize(e16, t18);
        return this._fbos;
      }
      const s16 = { target: M2.TEXTURE_2D, pixelFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, samplingMode: L.NEAREST, wrapMode: D2.CLAMP_TO_EDGE, width: e16, height: t18 }, r18 = { colorTarget: Y.TEXTURE, depthStencilTarget: V.DEPTH_STENCIL_RENDER_BUFFER }, i16 = new s6(this.context, { width: e16, height: t18, internalFormat: B.DEPTH_STENCIL });
      this._stencilBuf = i16, this._fbos = { output: new x(this.context, r18, s16, i16), blend: new x(this.context, r18, s16, i16), effect0: new x(this.context, r18, s16, i16) };
    }
    return this._fbos;
  }
  acquireFbo(e16, t18) {
    let s16;
    s16 = this._fboPool.length > 0 ? this._fboPool.pop() : new x(this.context, { colorTarget: Y.TEXTURE, depthStencilTarget: V.DEPTH_STENCIL_RENDER_BUFFER }, { target: M2.TEXTURE_2D, pixelFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, samplingMode: L.NEAREST, wrapMode: D2.CLAMP_TO_EDGE, width: e16, height: t18 }, this._stencilBuf);
    const r18 = s16.descriptor;
    return r18.width === e16 && r18.height === t18 || s16.resize(e16, t18), s16;
  }
  releaseFbo(e16) {
    this._fboPool.push(e16);
  }
  getSharedStencilBuffer() {
    return this._stencilBuf;
  }
  beforeRenderLayers(t18, s16 = null) {
    const { width: r18, height: i16 } = t18.getViewport();
    this._prevFBO = t18.getBoundFramebufferObject();
    const n23 = this.getFbos(r18, i16);
    if (t18.bindFramebuffer(n23.output), t18.setColorMask(true, true, true, true), r(s16)) {
      const { r: e16, g: r19, b: i17, a: n24 } = s16.color;
      t18.setClearColor(n24 * e16 / 255, n24 * r19 / 255, n24 * i17 / 255, n24);
    } else
      t18.setClearColor(0, 0, 0, 0);
    t18.setDepthWriteEnabled(true), t18.setClearDepth(1), t18.clear(t18.gl.COLOR_BUFFER_BIT | t18.gl.DEPTH_BUFFER_BIT), t18.setDepthWriteEnabled(false);
  }
  beforeRenderLayer(e16, t18, s16) {
    const { context: r18, blendMode: i16, effects: n23, requireFBO: o17, drawPhase: a18 } = e16;
    if (o17 || j3(a18, i16, n23, s16))
      r18.bindFramebuffer(this._fbos.blend), r18.setColorMask(true, true, true, true), r18.setClearColor(0, 0, 0, 0), r18.setDepthWriteEnabled(true), r18.setClearDepth(1), r18.clear(r18.gl.COLOR_BUFFER_BIT | r18.gl.DEPTH_BUFFER_BIT), r18.setDepthWriteEnabled(false);
    else {
      const e17 = this._getOutputFBO();
      r18.bindFramebuffer(e17);
    }
    r18.setDepthWriteEnabled(false), r18.setDepthTestEnabled(false), r18.setStencilTestEnabled(true), r18.setClearStencil(t18), r18.setStencilWriteMask(255), r18.clear(r18.gl.STENCIL_BUFFER_BIT);
  }
  compositeLayer(s16, r18) {
    const { context: i16, blendMode: n23, effects: a18, requireFBO: h9, drawPhase: l17 } = s16;
    if (h9 || j3(l17, n23, a18, r18)) {
      r(a18) && a18.length > 0 && l17 === I3.MAP && this._applyEffects(s16, a18);
      const h10 = this._getOutputFBO();
      i16.bindFramebuffer(h10), i16.setStencilTestEnabled(false), i16.setStencilWriteMask(0), i16.setBlendingEnabled(true), i16.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA), i16.setColorMask(true, true, true, true);
      const f10 = t(n23) || l17 === I3.HIGHLIGHT ? "normal" : n23;
      this._blendEffect.draw(s16, this._fbos.blend.colorTexture, L.NEAREST, f10, r18);
    }
  }
  renderLayers(e16) {
    if (e16.bindFramebuffer(this._prevFBO), !this._fbos)
      return;
    const t18 = this._getOutputFBO();
    e16.setDepthTestEnabled(false), e16.setStencilWriteMask(0), this._isClippedToWorldExtent ? (e16.setStencilTestEnabled(true), e16.setStencilFunction(I.EQUAL, 1, 255)) : e16.setStencilTestEnabled(false), this.blitTexture(e16, t18.colorTexture, L.NEAREST);
  }
  prepareDisplay(t18, s16, r18) {
    const { context: i16 } = t18;
    if (i16.bindFramebuffer(this._prevFBO), i16.setColorMask(true, true, true, true), r(s16)) {
      const { r: e16, g: t19, b: r19, a: n23 } = s16.color;
      i16.setClearColor(n23 * e16 / 255, n23 * t19 / 255, n23 * r19 / 255, n23);
    } else
      i16.setClearColor(0, 0, 0, 0);
    i16.setStencilWriteMask(255), i16.setClearStencil(0), i16.clear(i16.gl.COLOR_BUFFER_BIT | i16.gl.STENCIL_BUFFER_BIT), this._isClippedToWorldExtent = this._worldExtentClipRenderer.render(t18, r18);
  }
  dispose() {
    if (this.materialManager.dispose(), this.textureManager.dispose(), this.textureUploadManager.destroy(), this._blitRenderer = a(this._blitRenderer), this._worldExtentClipRenderer = a(this._worldExtentClipRenderer), this._brushCache && (this._brushCache.forEach((e16) => e16.dispose()), this._brushCache.clear(), this._brushCache = null), this._fbos)
      for (const e16 in this._fbos)
        this._fbos[e16] && this._fbos[e16].dispose();
    for (const e16 of this._fboPool)
      e16.dispose();
    if (this._fboPool.length = 0, this.effects)
      for (const e16 in this.effects)
        this.effects[e16] && this.effects[e16].dispose();
    this._effectsManager.dispose(), this._vtlMaterialManager = a(this._vtlMaterialManager), this._prevFBO = null;
  }
  getBrush(e16, t18) {
    const s16 = D3(e16, t18);
    let r18 = this._brushCache.get(s16);
    return void 0 === r18 && (r18 = new s16(), this._brushCache.set(s16, r18)), this._brushCache.get(s16);
  }
  renderObject(e16, t18, s16, i16) {
    const n23 = n13[s16];
    if (!n23)
      return null;
    let o17 = this._brushCache.get(n23);
    void 0 === o17 && (o17 = new n23(), this._brushCache.set(n23, o17)), o17.prepareState(e16, i16), o17.draw(e16, t18, i16);
  }
  renderObjects(e16, t18, s16, i16) {
    const n23 = n13[s16];
    if (!n23)
      return null;
    let o17 = this._brushCache.get(n23);
    void 0 === o17 && (o17 = new n23(), this._brushCache.set(n23, o17)), o17.drawMany(e16, t18, i16);
  }
  registerRenderPass(e16) {
    const t18 = e16.brushes.map((e17) => (this._brushCache.has(e17) || this._brushCache.set(e17, new e17()), this._brushCache.get(e17)));
    return new a13(t18, e16);
  }
  setHighlightOptions(e16) {
    this.effects.highlight.setHighlightOptions(e16);
  }
  blitTexture(e16, t18, s16, r18 = 1) {
    e16.setBlendingEnabled(true), e16.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA), e16.setColorMask(true, true, true, true), this._blitRenderer.render(e16, t18, s16, r18);
  }
  getPostProcessingEffects(e16) {
    return this._effectsManager.getPostProcessingEffects(e16);
  }
  _getOutputFBO() {
    return null != this._renderTarget ? this._renderTarget : this._fbos.output;
  }
  _applyEffects(e16, t18) {
    const { context: s16 } = e16, r18 = this._effectsManager.getPostProcessingEffects(t18);
    for (const { postProcessingEffect: i16, effect: n23 } of r18)
      s16.bindFramebuffer(this._fbos.blend), i16.draw(e16, this._fbos.blend, n23);
  }
};
function j3(t18, s16, r18, i16) {
  return t18 !== I3.HIGHLIGHT && (1 !== i16 || r(s16) && "normal" !== s16 || r(r18) && r18.length > 0);
}

// node_modules/@arcgis/core/views/2d/engine/webgl/Profiler.js
var n21 = has("esri-2d-profiler");
var i13 = class {
  constructor(s16, i16) {
    if (this._events = new n4(), this._entries = /* @__PURE__ */ new Map(), this._timings = new s7(10), this._currentContainer = null, this._currentPass = null, this._currentBrush = null, this._currentSummary = null, !n21)
      return;
    this._ext = T2(s16.gl, {}), this._debugOutput = i16;
    const o17 = s16.gl;
    if (this.enableCommandLogging) {
      for (const e16 in o17)
        if ("function" == typeof o17[e16]) {
          const t18 = o17[e16], s17 = e16.includes("draw");
          o17[e16] = (...r18) => (this._events.emit("command", { container: this._currentContainer, pass: this._currentPass, brush: this._currentBrush, method: e16, args: r18, isDrawCommand: s17 }), this._currentSummary && (this._currentSummary.commands++, s17 && this._currentSummary.drawCommands++), t18.apply(o17, r18));
        }
    }
  }
  get enableCommandLogging() {
    return !("object" == typeof n21 && n21.disableCommands);
  }
  recordContainerStart(e16) {
    n21 && (this._currentContainer = e16);
  }
  recordContainerEnd() {
    n21 && (this._currentContainer = null);
  }
  recordPassStart(e16) {
    n21 && (this._currentPass = e16, this._initSummary());
  }
  recordPassEnd() {
    n21 && (this._currentPass = null, this._emitSummary());
  }
  recordBrushStart(e16) {
    n21 && (this._currentBrush = e16);
  }
  recordBrushEnd() {
    n21 && (this._currentBrush = null);
  }
  recordStart(e16) {
    if (n21 && r(this._ext)) {
      if (this._entries.has(e16)) {
        const t19 = this._entries.get(e16), r18 = this._ext.resultAvailable(t19.query), n23 = this._ext.disjoint();
        if (r18 && !n23) {
          const r19 = this._ext.getResult(t19.query) / 1e6;
          let n24 = 0;
          if (r(this._timings.enqueue(r19))) {
            const e17 = this._timings.entries, t20 = e17.length;
            let s16 = 0;
            for (const r20 of e17)
              s16 += r20;
            n24 = s16 / t20;
          }
          const i16 = r19.toFixed(2), o17 = n24 ? n24.toFixed(2) : "--";
          this.enableCommandLogging ? (console.groupCollapsed(`Frame report for ${e16}, ${i16} ms (${o17} last 10 avg)
${t19.commandsLen} Commands (${t19.drawCommands} draw)`), console.log("RenderPass breakdown: "), console.table(t19.summaries), console.log("Commands: ", t19.commands), console.groupEnd()) : console.log(`Frame report for ${e16}, ${i16} ms (${o17} last 10 avg)`), this._debugOutput.innerHTML = `${i16} (${o17})`;
        }
        for (const e17 of t19.handles)
          e17.remove();
        this._ext.deleteQuery(t19.query), this._entries.delete(e16);
      }
      const t18 = { name: e16, query: this._ext.createQuery(), commands: [], commandsLen: 0, drawCommands: 0, summaries: [], handles: [] };
      this.enableCommandLogging && (t18.handles.push(this._events.on("command", (e17) => {
        t18.commandsLen++, t18.commands.push(e17), e17.isDrawCommand && t18.drawCommands++;
      })), t18.handles.push(this._events.on("summary", (e17) => {
        t18.summaries.push(e17);
      }))), this._ext.beginTimeElapsed(t18.query), this._entries.set(e16, t18);
    }
  }
  recordEnd(e16) {
    n21 && r(this._ext) && this._entries.has(e16) && this._ext.endTimeElapsed();
  }
  _initSummary() {
    this.enableCommandLogging && (this._currentSummary = { container: this._currentContainer, pass: this._currentPass, drawCommands: 0, commands: 0 });
  }
  _emitSummary() {
    this.enableCommandLogging && this._currentSummary && this._events.emit("summary", this._currentSummary);
  }
};

// node_modules/@arcgis/core/views/2d/engine/Stage.js
var O5 = 2e3;
var P4 = class extends i4 {
  constructor(s16, i16) {
    super(), this._trash = /* @__PURE__ */ new Set(), this._renderRemainingTime = 0, this._lastFrameRenderTime = 0, this.renderRequested = false, this.stage = this, this._stationary = true;
    const { canvas: a18 = document.createElement("canvas"), alpha: h9 = true, stencil: l17 = true, contextOptions: m10 = {} } = i16;
    this._canvas = a18;
    const g8 = o2("2d", a18, { alpha: h9, antialias: false, depth: true, stencil: l17 });
    this.context = new y3(r(g8) ? g8 : null, m10), this.resourceManager = new o5(), this.painter = new I4(this.context, this, this.resourceManager), has("esri-2d-profiler") && (this._debugOutput = document.createElement("div"), this._debugOutput.setAttribute("style", "margin: 24px 64px; position: absolute; color: red;"), s16.appendChild(this._debugOutput)), this._renderParameters = { drawPhase: 0, state: this.state, pixelRatio: window.devicePixelRatio, stationary: false, globalOpacity: 1, blendMode: null, deltaTime: -1, time: 0, inFadeTransition: false, effects: null, context: this.context, painter: this.painter, timeline: i16.timeline || new e9(), renderingOptions: i16.renderingOptions, requestRender: () => this.requestRender(), allowDelayedRender: false, requireFBO: false, profiler: new i13(this.context, this._debugOutput), dataUploadCounter: 0 }, this._taskHandle = A({ render: (e16) => this.renderFrame(e16) }), this._taskHandle.pause(), this._lostWebGLContextHandle = r4(a18, "webglcontextlost", () => {
      this.emit("webgl-error", { error: new s4("webgl-context-lost") });
    }), this._bufferPool = new n10(), a18.setAttribute("style", "width: 100%; height:100%; display:block;"), s16.appendChild(a18);
  }
  destroy() {
    this.removeAllChildren(), this._emptyTrash(), this._taskHandle.remove(), this._taskHandle = null, this._lostWebGLContextHandle && (this._lostWebGLContextHandle.remove(), this._lostWebGLContextHandle = null), this._canvas.parentNode && this._canvas.parentNode.removeChild(this._canvas), this._debugOutput && this._debugOutput.parentNode && this._debugOutput.parentNode.removeChild(this._debugOutput), this._bufferPool.destroy(), this.highlightOptions = null, this.resourceManager.destroy(), this.painter.dispose(), this.context.dispose(), this._canvas = null;
  }
  get background() {
    return this._background;
  }
  set background(e16) {
    this._background = e16, this.requestRender();
  }
  get bufferPool() {
    return this._bufferPool;
  }
  get highlightOptions() {
    return this._highlightOptions;
  }
  set highlightOptions(e16) {
    this._highlightOptionsHandle && (this._highlightOptionsHandle.remove(), this._highlightOptionsHandle = null), this._highlightOptions = e16, this._highlightOptions && (this._highlightOptionsHandle = l(() => {
      var _a;
      return (_a = this._highlightOptions) == null ? void 0 : _a.version;
    }, () => {
      this.painter.setHighlightOptions(e16), this.requestRender();
    }, h));
  }
  get renderingOptions() {
    return this._renderingOptions;
  }
  set renderingOptions(e16) {
    this._renderingOptions = e16, this.requestRender();
  }
  get state() {
    return this._state;
  }
  set state(e16) {
    this._state = e16, this.requestRender();
  }
  get stationary() {
    return this._stationary;
  }
  set stationary(e16) {
    this._stationary !== e16 && (this._stationary = e16, this.requestRender());
  }
  trashDisplayObject(e16) {
    this._trash.add(e16), this.requestRender();
  }
  untrashDisplayObject(e16) {
    return this._trash.delete(e16);
  }
  requestRender() {
    this._renderRemainingTime = O5, this.renderRequested || (this.renderRequested = true, this.emit("will-render"), this._taskHandle.resume());
  }
  renderFrame(e16) {
    const t18 = this._lastFrameRenderTime ? e16.time - this._lastFrameRenderTime : 0;
    this._renderRemainingTime -= t18, this._renderRemainingTime <= 0 && this._taskHandle.pause(), this._lastFrameRenderTime = e16.time, this.renderRequested = false, this._renderParameters.state = this._state, this._renderParameters.stationary = this.stationary, this._renderParameters.pixelRatio = window.devicePixelRatio, this._renderParameters.globalOpacity = 1, this._renderParameters.time = e16.time, this._renderParameters.deltaTime = e16.deltaTime, this._renderParameters.effects = null, this.processRender(this._renderParameters), this._emptyTrash(), this.emit("post-render");
  }
  _createTransforms() {
    return { dvs: e3() };
  }
  renderChildren(e16) {
    for (const t18 of this.children)
      t18.beforeRender(e16);
    this._renderChildren(this.children, e16);
    for (const t18 of this.children)
      t18.afterRender(e16);
  }
  _renderChildren(e16, t18) {
    const r18 = this.context;
    this.painter.textureUploadManager.upload(), r18.resetInfo(), t18.profiler.recordStart("drawLayers"), t18.dataUploadCounter = 0, t18.drawPhase = I3.MAP, this.painter.beforeRenderLayers(r18, this.background);
    for (const s16 of e16)
      s16.processRender(t18);
    this.painter.prepareDisplay(t18, this.background, this.state.padding), this.painter.renderLayers(r18), t18.drawPhase = I3.HIGHLIGHT, this.painter.beforeRenderLayers(r18);
    for (const s16 of e16)
      s16.processRender(t18);
    this.painter.renderLayers(r18);
    if (this._isLabelDrawPhaseRequired(e16)) {
      t18.drawPhase = I3.LABEL, this.painter.beforeRenderLayers(r18);
      for (const r19 of e16)
        r19.processRender(t18);
      this.painter.renderLayers(r18);
    }
    if (has("esri-tiles-debug")) {
      t18.drawPhase = I3.DEBUG, this.painter.beforeRenderLayers(r18);
      for (const r19 of e16)
        r19.processRender(t18);
      this.painter.renderLayers(r18);
    }
    t18.profiler.recordEnd("drawLayers"), r18.logInfo();
  }
  doRender(e16) {
    const t18 = this.context, { state: r18, pixelRatio: s16 } = e16;
    this._resizeCanvas(e16), t18.setViewport(0, 0, s16 * r18.size[0], s16 * r18.size[1]), t18.setDepthWriteEnabled(true), t18.setStencilWriteMask(255), super.doRender(e16);
  }
  async takeScreenshot(e16) {
    const { framebufferWidth: t18, framebufferHeight: r18 } = { framebufferWidth: Math.round(this.state.size[0] * e16.resolutionScale), framebufferHeight: Math.round(this.state.size[1] * e16.resolutionScale) }, s16 = 1, i16 = this.context, n23 = this._state.clone();
    if (null != e16.rotation) {
      const t19 = n23.viewpoint;
      n23.viewpoint.rotation = e16.rotation, n23.viewpoint = t19;
    }
    const a18 = { ...this._renderParameters, drawPhase: null, globalOpacity: 1, stationary: true, state: n23, pixelRatio: s16, time: performance.now(), deltaTime: 0, blendMode: null, effects: null, inFadeTransition: false }, o17 = new x(i16, { colorTarget: Y.TEXTURE, depthStencilTarget: V.DEPTH_STENCIL_RENDER_BUFFER, width: t18, height: r18 }), h9 = i16.getBoundFramebufferObject(), d15 = i16.getViewport();
    i16.bindFramebuffer(o17), i16.setViewport(0, 0, t18, r18), this._renderChildren(e16.children, a18);
    const l17 = this._readbackScreenshot(o17, { ...e16.cropArea, y: r18 - (e16.cropArea.y + e16.cropArea.height) });
    i16.bindFramebuffer(h9), i16.setViewport(d15.x, d15.y, d15.width, d15.height), this.requestRender();
    const p6 = await l17;
    let u10;
    return 1 === e16.outputScale ? u10 = p6 : (u10 = new ImageData(Math.round(p6.width * e16.outputScale), Math.round(p6.height * e16.outputScale)), m4(p6, u10, true)), u10;
  }
  async _readbackScreenshot(e16, t18) {
    const r18 = e2(t18.width, t18.height, document.createElement("canvas"));
    return await e16.readPixelsAsync(t18.x, t18.y, t18.width, t18.height, P.RGBA, G.UNSIGNED_BYTE, new Uint8Array(r18.data.buffer)), r18;
  }
  _resizeCanvas(e16) {
    const t18 = this._canvas, r18 = t18.style, { state: { size: s16 }, pixelRatio: i16 } = e16, n23 = s16[0], a18 = s16[1], o17 = Math.round(n23 * i16), h9 = Math.round(a18 * i16);
    t18.width === o17 && t18.height === h9 || (t18.width = o17, t18.height = h9), r18.width = n23 + "px", r18.height = a18 + "px";
  }
  _emptyTrash() {
    for (; this._trash.size > 0; ) {
      const e16 = Array.from(this._trash);
      this._trash.clear();
      for (const t18 of e16)
        t18.processDetach();
    }
  }
  _isLabelDrawPhaseRequired(e16) {
    let t18 = false;
    for (const r18 of e16) {
      if (!(r18 instanceof i4)) {
        t18 = t18 || false;
        break;
      }
      if (r18.hasLabels)
        return true;
      t18 = t18 || this._isLabelDrawPhaseRequired(r18.children);
    }
    return t18;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/collisions/CollisionGrid.js
var e15 = 2;
var i14 = 1;
var o15 = 0;
var h6 = 1;
var r15 = 2;
var l11 = class {
  constructor(t18, e16, o17) {
    this._debugMap = /* @__PURE__ */ new Map(), this._width = t18 * o17, this._height = e16 * o17, this._pixelRatio = o17;
    const h9 = Math.ceil(this._width / i14), r18 = Math.ceil(this._height / i14);
    this._cols = h9, this._rows = r18, this._cells = t6.create(h9 * r18);
  }
  insertMetrics(t18) {
    const s16 = this._hasCollision(t18);
    return s16 === o15 && this._markMetrics(t18), s16;
  }
  getCellId(t18, s16) {
    return t18 + s16 * this._cols;
  }
  has(t18) {
    return this._cells.has(t18);
  }
  hasRange(t18, s16) {
    return this._cells.hasRange(t18, s16);
  }
  set(t18) {
    this._cells.set(t18);
  }
  setRange(t18, s16) {
    this._cells.setRange(t18, s16);
  }
  _collide(s16, e16, l17, n23) {
    const c13 = s16 - l17 / 2, a18 = e16 - n23 / 2, _9 = c13 + l17, d15 = a18 + n23;
    if (_9 < 0 || d15 < 0 || c13 > this._width || a18 > this._height)
      return h6;
    const u10 = a2(Math.floor(c13 / i14), 0, this._cols), p6 = a2(Math.floor(a18 / i14), 0, this._rows), M4 = a2(Math.ceil(_9 / i14), 0, this._cols), f10 = a2(Math.ceil(d15 / i14), 0, this._rows);
    for (let t18 = p6; t18 <= f10; t18++)
      for (let s17 = u10; s17 <= M4; s17++) {
        const e17 = this.getCellId(s17, t18);
        if (this.has(e17))
          return r15;
      }
    return o15;
  }
  _mark(s16, e16, o17, h9, r18) {
    const l17 = s16 - o17 / 2, n23 = e16 - h9 / 2, c13 = l17 + o17, a18 = n23 + h9, _9 = a2(Math.floor(l17 / i14), 0, this._cols), d15 = a2(Math.floor(n23 / i14), 0, this._rows), u10 = a2(Math.ceil(c13 / i14), 0, this._cols), p6 = a2(Math.ceil(a18 / i14), 0, this._rows);
    for (let t18 = d15; t18 <= p6; t18++)
      for (let s17 = _9; s17 <= u10; s17++) {
        const e17 = this.getCellId(s17, t18);
        this._debugMap.set(e17, r18), this.set(e17);
      }
    return false;
  }
  _hasCollision(t18) {
    const s16 = t18.id;
    let i16 = 0, l17 = 0;
    t18.save();
    do {
      const s17 = t18.boundsCount;
      i16 += s17;
      for (let i17 = 0; i17 < s17; i17++) {
        const s18 = t18.boundsComputedAnchorX(i17), o17 = t18.boundsComputedAnchorY(i17), n23 = (t18.boundsWidth(i17) + e15) * this._pixelRatio, c13 = (t18.boundsHeight(i17) + e15) * this._pixelRatio;
        switch (this._collide(s18, o17, n23, c13)) {
          case r15:
            return r15;
          case h6:
            l17++;
        }
      }
    } while (t18.peekId() === s16 && t18.next());
    return t18.restore(), i16 === l17 ? h6 : o15;
  }
  _markMetrics(t18) {
    const s16 = t18.id;
    t18.save();
    do {
      const s17 = t18.boundsCount;
      for (let i16 = 0; i16 < s17; i16++) {
        const s18 = t18.boundsComputedAnchorX(i16), o17 = t18.boundsComputedAnchorY(i16), h9 = (t18.boundsWidth(i16) + e15) * this._pixelRatio, r18 = (t18.boundsHeight(i16) + e15) * this._pixelRatio;
        this._mark(s18, o17, h9, r18, t18.id);
      }
    } while (t18.peekId() === s16 && t18.next());
    t18.restore();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/collisions/visualVariableSimpleUtils.js
var r16 = Math.PI;
function a14(e16, t18) {
  switch (t18.transformationType) {
    case i2.Additive:
      return s12(e16, t18);
    case i2.Constant:
      return u7(t18, e16);
    case i2.ClampedLinear:
      return o16(e16, t18);
    case i2.Proportional:
      return l12(e16, t18);
    case i2.Stops:
      return c11(e16, t18);
    case i2.RealWorldSize:
      return m8(e16, t18);
    case i2.Identity:
      return e16;
    case i2.Unknown:
      return null;
  }
}
function i15(e16, t18) {
  return "number" == typeof e16 ? e16 : a14(t18, e16);
}
function s12(e16, t18) {
  return e16 + (i15(t18.minSize, e16) || t18.minDataValue);
}
function u7(e16, t18) {
  const n23 = e16.stops;
  let r18 = n23 && n23.length && n23[0].size;
  return null == r18 && (r18 = e16.minSize), i15(r18, t18);
}
function o16(e16, t18) {
  const n23 = (e16 - t18.minDataValue) / (t18.maxDataValue - t18.minDataValue), r18 = i15(t18.minSize, e16), a18 = i15(t18.maxSize, e16);
  return e16 <= t18.minDataValue ? r18 : e16 >= t18.maxDataValue ? a18 : r18 + n23 * (a18 - r18);
}
function l12(t18, n23) {
  const r18 = t18 / n23.minDataValue, a18 = i15(n23.minSize, t18), s16 = i15(n23.maxSize, t18);
  let u10 = null;
  return u10 = r18 * a18, a2(u10, a18, s16);
}
function c11(e16, t18) {
  const [n23, r18, a18] = p3(e16, t18.cache.ipData);
  if (n23 === r18)
    return i15(t18.stops[n23].size, e16);
  {
    const s16 = i15(t18.stops[n23].size, e16);
    return s16 + (i15(t18.stops[r18].size, e16) - s16) * a18;
  }
}
function m8(n23, a18) {
  const s16 = m2[a18.valueUnit], u10 = i15(a18.minSize, n23), o17 = i15(a18.maxSize, n23), { valueRepresentation: l17 } = a18;
  let c13 = null;
  return c13 = "area" === l17 ? 2 * Math.sqrt(n23 / r16) / s16 : "radius" === l17 || "distance" === l17 ? 2 * n23 / s16 : n23 / s16, a2(c13, u10, o17);
}
function p3(e16, t18) {
  if (!t18)
    return;
  let n23 = 0, r18 = t18.length - 1;
  return t18.some((t19, a18) => e16 < t19 ? (r18 = a18, true) : (n23 = a18, false)), [n23, r18, (e16 - t18[n23]) / (t18[r18] - t18[n23])];
}

// node_modules/@arcgis/core/views/2d/engine/webgl/collisions/CollisionEngine.js
var d9 = 254;
var u8 = 255;
var f8 = 0;
function b3(e16, i16) {
  const o17 = [];
  e16.forEachTile((e17) => o17.push(e17)), o17.sort((e17, t18) => e17.instanceId - t18.instanceId), o17.forEach((e17) => {
    r(e17.labelMetrics) && e17.isReady && i16(e17, e17.labelMetrics.getCursor());
  });
}
function y4(e16) {
  return e16.layer && ("feature" === e16.layer.type || "csv" === e16.layer.type || "geojson" === e16.layer.type || "ogc-feature" === e16.layer.type || "stream" === e16.layer.type || "subtype-group" === e16.layer.type || "wfs" === e16.layer.type);
}
function p4(e16) {
  return (t18) => u(a14(t18, e16));
}
function m9(e16) {
  const t18 = "visualVariables" in e16 && e16.visualVariables;
  if (!t18)
    return null;
  for (const i16 of t18)
    if ("size" === i16.type)
      return p4(i16);
  return null;
}
function h7(e16) {
  for (const t18 of e16) {
    const e17 = "featureReduction" in t18 && t18.featureReduction && "labelingInfo" in t18.featureReduction && t18.featureReduction, i16 = [...t18.labelingInfo || [], ...(e17 == null ? void 0 : e17.labelingInfo) || []];
    if (!t18.labelsVisible || !i16.length)
      continue;
    if (i16.some((e18) => "none" === e18.deconflictionStrategy))
      return true;
  }
  return false;
}
function M3(t18, i16) {
  var _a;
  if (!y4(i16))
    return;
  const o17 = "subtype-group" === i16.layer.type ? i16.layer.sublayers.items : [i16.layer], r18 = i16.layer.geometryType, n23 = !h7(o17), s16 = {};
  if ("subtype-group" !== i16.layer.type) {
    if ("heatmap" === ((_a = i16.tileRenderer) == null ? void 0 : _a.type))
      return;
    const e16 = m9(i16.layer.renderer);
    s16[0] = e16;
  }
  const l17 = i16.tileRenderer;
  if (t(l17))
    return;
  const a18 = i16.layer.visible && !i16.suspended;
  t18.push({ tileRenderer: l17, vvEvaluators: s16, deconflictionEnabled: n23, geometryType: r18, visible: a18 });
}
var g6 = class {
  run(e16, t18, i16) {
    const o17 = [];
    for (let r18 = e16.length - 1; r18 >= 0; r18--) {
      M3(o17, e16[r18]);
    }
    this._transformMetrics(o17), this._runCollision(o17, t18, i16);
  }
  _runCollision(e16, t18, i16) {
    const [o17, r18] = t18.state.size, s16 = new l11(o17, r18, t18.pixelRatio);
    for (const { tileRenderer: n23, deconflictionEnabled: l17, visible: a18 } of e16) {
      const e17 = n23.featuresView.attributeView;
      l17 ? a18 ? (this._prepare(n23), this._collideVisible(s16, n23, i16), this._collideInvisible(s16, n23)) : b3(n23, (t19, i17) => {
        for (; i17.nextId(); )
          e17.setLabelMinZoom(i17.id, u8);
      }) : b3(n23, (t19, i17) => {
        for (; i17.nextId(); )
          e17.setLabelMinZoom(i17.id, f8), a18 && s16.insertMetrics(i17);
      });
    }
  }
  _isFiltered(t18, i16, n23) {
    const s16 = i16.getFilterFlags(t18), l17 = !n23.hasFilter || !!(s16 & U2), a18 = t(n23.featureEffect) || n23.featureEffect.excludedLabelsVisible || !!(s16 & V2);
    return !(l17 && a18);
  }
  _prepare(e16) {
    const t18 = e16.featuresView.attributeView, i16 = /* @__PURE__ */ new Set();
    b3(e16, (o17, r18) => {
      for (; r18.nextId(); ) {
        if (i16.has(r18.id))
          continue;
        if (i16.add(r18.id), this._isFiltered(r18.id, t18, e16.layerView)) {
          t18.setLabelMinZoom(r18.id, d9);
          continue;
        }
        t18.getLabelMinZoom(r18.id) !== f8 ? t18.setLabelMinZoom(r18.id, u8) : t18.setLabelMinZoom(r18.id, f8);
      }
    });
  }
  _collideVisible(e16, t18, i16) {
    const o17 = t18.featuresView.attributeView, r18 = /* @__PURE__ */ new Set();
    b3(t18, (t19, n23) => {
      for (; n23.nextId(); )
        if (!r18.has(n23.id))
          if (t19.key.level === i16) {
            if (0 === o17.getLabelMinZoom(n23.id)) {
              switch (e16.insertMetrics(n23)) {
                case h6:
                  break;
                case r15:
                  o17.setLabelMinZoom(n23.id, d9), r18.add(n23.id);
                  break;
                case o15:
                  o17.setLabelMinZoom(n23.id, f8), r18.add(n23.id);
              }
            }
          } else
            o17.setLabelMinZoom(n23.id, d9);
    });
  }
  _collideInvisible(e16, t18) {
    const i16 = t18.featuresView.attributeView, o17 = /* @__PURE__ */ new Set();
    b3(t18, (t19, r18) => {
      for (; r18.nextId(); )
        if (!o17.has(r18.id) && i16.getLabelMinZoom(r18.id) === u8) {
          switch (e16.insertMetrics(r18)) {
            case h6:
              break;
            case r15:
              i16.setLabelMinZoom(r18.id, u8), o17.add(r18.id);
              break;
            case o15:
              i16.setLabelMinZoom(r18.id, f8), o17.add(r18.id);
          }
        }
    });
  }
  _transformMetrics(e16) {
    for (const { tileRenderer: i16, geometryType: o17, vvEvaluators: r18 } of e16)
      b3(i16, (e17, n23) => {
        const s16 = i16.featuresView.attributeView, l17 = e17.transforms.labelMat2d;
        l17[4] = Math.round(l17[4]), l17[5] = Math.round(l17[5]);
        const a18 = "polyline" === o17;
        for (; n23.next(); ) {
          const e18 = n23.boundsCount, i17 = n23.anchorX, o18 = n23.anchorY;
          let c13 = n23.size;
          const d15 = r18[0];
          if (r(d15)) {
            const e19 = d15(s16.getVVSize(n23.id));
            c13 = isNaN(e19) || null == e19 || e19 === 1 / 0 ? c13 : e19;
          }
          const u10 = n23.directionX * (c13 / 2), f10 = n23.directionY * (c13 / 2);
          for (let t18 = 0; t18 < e18; t18++) {
            let e19 = i17, r19 = n23.anchorY;
            if (a18) {
              let i18 = e19 + n23.boundsX(t18) + u10, o19 = r19 + n23.boundsY(t18) + f10;
              i18 = l17[0] * i18 + l17[2] * o19 + l17[4], o19 = l17[1] * i18 + l17[3] * o19 + l17[5], n23.setBoundsComputedAnchorX(t18, Math.floor(i18)), n23.setBoundsComputedAnchorY(t18, Math.floor(o19));
            } else {
              e19 = l17[0] * i17 + l17[2] * o18 + l17[4], r19 = l17[1] * i17 + l17[3] * o18 + l17[5];
              const s17 = e19 + n23.boundsX(t18) + u10, a19 = r19 + n23.boundsY(t18) + f10;
              n23.setBoundsComputedAnchorX(t18, s17), n23.setBoundsComputedAnchorY(t18, a19);
            }
          }
        }
      });
  }
};

// node_modules/@arcgis/core/views/2d/LabelManager.js
var p5 = 32;
var l13 = class extends a5(m) {
  constructor(e16) {
    super(e16), this._applyVisibilityPassThrottled = e6(this._applyVisibilityPass, p5, this), this.lastUpdateId = -1, this.updateRequested = false, this.view = null;
  }
  initialize() {
    this.collisionEngine = new g6();
  }
  destroy() {
    this.collisionEngine = null, this._applyVisibilityPassThrottled.remove(), this._applyVisibilityPassThrottled = null;
  }
  get updating() {
    return has("esri-2d-log-updating") && console.log(`Updating LabelManager ${this.updateRequested}:
-> updateRequested: ${this.updateRequested}`), this.updateRequested;
  }
  update(e16) {
    this._applyVisibilityPassThrottled(e16);
  }
  viewChange() {
    this.requestUpdate();
  }
  requestUpdate() {
    this.updateRequested || (this.updateRequested = true, this.view.requestUpdate());
  }
  processUpdate(e16) {
    this._set("updateParameters", e16), this.updateRequested && (this.updateRequested = false, this.update(e16));
  }
  _applyVisibilityPass(e16) {
    try {
      const t18 = this.view.featuresTilingScheme.getClosestInfoForScale(e16.state.scale).level;
      this.collisionEngine.run(this.view.allLayerViews.items, e16, t18);
    } catch (t18) {
    }
  }
};
e([y()], l13.prototype, "updateRequested", void 0), e([y({ readOnly: true })], l13.prototype, "updateParameters", void 0), e([y()], l13.prototype, "updating", null), e([y()], l13.prototype, "view", void 0), l13 = e([n2("esri.views.2d.layers.labels.LabelManager")], l13);
var d10 = l13;

// node_modules/@arcgis/core/views/2d/navigation/ZoomBox.js
var a15 = { container: "esri-zoom-box__container", overlay: "esri-zoom-box__overlay", background: "esri-zoom-box__overlay-background", box: "esri-zoom-box__outline" };
var n22 = { zoom: "Shift", counter: "Ctrl" };
var h8 = class extends m {
  constructor(t18) {
    super(t18), this._container = null, this._overlay = null, this._backgroundShape = null, this._boxShape = null, this._box = { x: 0, y: 0, width: 0, height: 0 }, this._redraw = this._redraw.bind(this);
  }
  destroy() {
    this.view = null;
  }
  set view(t18) {
    this._handles && this._handles.forEach((t19) => {
      t19.remove();
    }), this._handles = null, this._destroyOverlay(), this._set("view", t18), t18 && (t18.on("drag", [n22.zoom], (t19) => this._handleDrag(t19, 1), P3.INTERNAL), t18.on("drag", [n22.zoom, n22.counter], (t19) => this._handleDrag(t19, -1), P3.INTERNAL));
  }
  _start() {
    this._createContainer(), this._createOverlay(), this.navigation.begin();
  }
  _update(t18, e16, i16, r18) {
    this._box.x = t18, this._box.y = e16, this._box.width = i16, this._box.height = r18, this._rafId || (this._rafId = requestAnimationFrame(this._redraw));
  }
  _end(t18, e16, r18, o17, s16) {
    const a18 = this.view, n23 = a18.toMap(c(t18 + 0.5 * r18, e16 + 0.5 * o17));
    let h9 = Math.max(r18 / a18.width, o17 / a18.height);
    -1 === s16 && (h9 = 1 / h9), this._destroyOverlay(), this.navigation.end(), a18.goTo({ center: n23, scale: a18.scale * h9 });
  }
  _updateBox(t18, e16, i16, r18) {
    const o17 = this._boxShape;
    o17.setAttributeNS(null, "x", "" + t18), o17.setAttributeNS(null, "y", "" + e16), o17.setAttributeNS(null, "width", "" + i16), o17.setAttributeNS(null, "height", "" + r18), o17.setAttributeNS(null, "class", a15.box);
  }
  _updateBackground(t18, e16, i16, r18) {
    this._backgroundShape.setAttributeNS(null, "d", this._toSVGPath(t18, e16, i16, r18, this.view.width, this.view.height));
  }
  _createContainer() {
    const t18 = document.createElement("div");
    t18.className = a15.container, this.view.root.appendChild(t18), this._container = t18;
  }
  _createOverlay() {
    const t18 = this.view.width, e16 = this.view.height, i16 = document.createElementNS("http://www.w3.org/2000/svg", "path");
    i16.setAttributeNS(null, "d", "M 0 0 L " + t18 + " 0 L " + t18 + " " + e16 + " L 0 " + e16 + " Z"), i16.setAttributeNS(null, "class", a15.background);
    const r18 = document.createElementNS("http://www.w3.org/2000/svg", "rect"), o17 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    o17.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink"), o17.setAttributeNS(null, "class", a15.overlay), o17.appendChild(i16), o17.appendChild(r18), this._container.appendChild(o17), this._backgroundShape = i16, this._boxShape = r18, this._overlay = o17;
  }
  _destroyOverlay() {
    this._container && this._container.parentNode && this._container.parentNode.removeChild(this._container), this._container = this._backgroundShape = this._boxShape = this._overlay = null;
  }
  _toSVGPath(t18, e16, i16, r18, o17, s16) {
    const a18 = t18 + i16, n23 = e16 + r18;
    return "M 0 0 L " + o17 + " 0 L " + o17 + " " + s16 + " L 0 " + s16 + " ZM " + t18 + " " + e16 + " L " + t18 + " " + n23 + " L " + a18 + " " + n23 + " L " + a18 + " " + e16 + " Z";
  }
  _handleDrag(t18, e16) {
    const i16 = t18.x, r18 = t18.y, o17 = t18.origin.x, s16 = t18.origin.y;
    let a18, n23, h9, l17;
    switch (i16 > o17 ? (a18 = o17, h9 = i16 - o17) : (a18 = i16, h9 = o17 - i16), r18 > s16 ? (n23 = s16, l17 = r18 - s16) : (n23 = r18, l17 = s16 - r18), t18.action) {
      case "start":
        this._start();
        break;
      case "update":
        this._update(a18, n23, h9, l17);
        break;
      case "end":
        this._end(a18, n23, h9, l17, e16);
    }
    t18.stopPropagation();
  }
  _redraw() {
    if (!this._rafId)
      return;
    if (this._rafId = null, !this._overlay)
      return;
    const { x: t18, y: e16, width: i16, height: r18 } = this._box;
    this._updateBox(t18, e16, i16, r18), this._updateBackground(t18, e16, i16, r18), this._rafId = requestAnimationFrame(this._redraw);
  }
};
e([y()], h8.prototype, "navigation", void 0), e([y()], h8.prototype, "view", null), h8 = e([n2("esri.views.2d.navigation.ZoomBox")], h8);
var l14 = h8;

// node_modules/@arcgis/core/views/navigation/FilteredFiniteDifference.js
var t15 = class {
  constructor(t18) {
    this._gain = t18, this.lastValue = void 0, this.filteredDelta = void 0;
  }
  update(t18) {
    if (this.hasLastValue()) {
      const e16 = this.computeDelta(t18);
      this._updateDelta(e16);
    }
    this.lastValue = t18;
  }
  reset() {
    this.lastValue = void 0, this.filteredDelta = void 0;
  }
  hasLastValue() {
    return void 0 !== this.lastValue;
  }
  hasFilteredDelta() {
    return void 0 !== this.filteredDelta;
  }
  computeDelta(t18) {
    return void 0 === this.lastValue ? NaN : t18 - this.lastValue;
  }
  _updateDelta(t18) {
    void 0 !== this.filteredDelta ? this.filteredDelta = (1 - this._gain) * this.filteredDelta + this._gain * t18 : this.filteredDelta = t18;
  }
};

// node_modules/@arcgis/core/views/navigation/Momentum.js
var t16 = class {
  constructor(t18, i16, o17) {
    this._initialVelocity = t18, this._stopVelocity = i16, this._friction = o17, this._duration = Math.abs(Math.log(Math.abs(this._initialVelocity) / this._stopVelocity) / Math.log(1 - this._friction));
  }
  get duration() {
    return this._duration;
  }
  isFinished(t18) {
    return t18 > this.duration;
  }
  get friction() {
    return this._friction;
  }
  value(t18) {
    return this.valueFromInitialVelocity(this._initialVelocity, t18);
  }
  valueDelta(t18, i16) {
    const o17 = this.value(t18);
    return this.value(t18 + i16) - o17;
  }
  valueFromInitialVelocity(t18, i16) {
    i16 = Math.min(i16, this.duration);
    const o17 = 1 - this.friction;
    return t18 * (o17 ** i16 - 1) / Math.log(o17);
  }
};

// node_modules/@arcgis/core/views/navigation/PanPlanarMomentumEstimator.js
var c12 = class extends t16 {
  constructor(e16, t18, i16, s16, n23) {
    super(e16, t18, i16), this._sceneVelocity = s16, this.direction = n23;
  }
  value(e16) {
    return super.valueFromInitialVelocity(this._sceneVelocity, e16);
  }
};
var l15 = class {
  constructor(e16 = 300, t18 = 12, i16 = 0.84) {
    this._minimumInitialVelocity = e16, this._stopVelocity = t18, this._friction = i16, this.enabled = true, this._time = new t15(0.6), this._screen = [new t15(0.4), new t15(0.4)], this._scene = [new t15(0.6), new t15(0.6), new t15(0.6)], this._tmpDirection = n();
  }
  add(e16, t18, i16) {
    if (this.enabled) {
      if (this._time.hasLastValue()) {
        if (this._time.computeDelta(i16) < 0.015)
          return;
      }
      this._screen[0].update(e16[0]), this._screen[1].update(e16[1]), this._scene[0].update(t18[0]), this._scene[1].update(t18[1]), this._scene[2].update(t18[2]), this._time.update(i16);
    }
  }
  reset() {
    this._screen[0].reset(), this._screen[1].reset(), this._scene[0].reset(), this._scene[1].reset(), this._scene[2].reset(), this._time.reset();
  }
  evaluateMomentum() {
    if (!this.enabled || !this._screen[0].hasFilteredDelta() || !this._time.hasFilteredDelta())
      return null;
    const e16 = this._screen[0].filteredDelta, t18 = this._screen[1].filteredDelta, i16 = null == e16 || null == t18 ? 0 : Math.sqrt(e16 * e16 + t18 * t18), s16 = this._time.filteredDelta, n23 = null == s16 || null == i16 ? 0 : i16 / s16;
    return Math.abs(n23) < this._minimumInitialVelocity ? null : this.createMomentum(n23, this._stopVelocity, this._friction);
  }
  createMomentum(s16, n23, r18) {
    var _a, _b, _c;
    o(this._tmpDirection, (_a = this._scene[0].filteredDelta) != null ? _a : 0, (_b = this._scene[1].filteredDelta) != null ? _b : 0, (_c = this._scene[2].filteredDelta) != null ? _c : 0);
    const l17 = s(this._tmpDirection);
    l17 > 0 && g(this._tmpDirection, this._tmpDirection, 1 / l17);
    const h9 = this._time.filteredDelta;
    return new c12(s16, n23, r18, null == h9 ? 0 : l17 / h9, this._tmpDirection);
  }
};

// node_modules/@arcgis/core/views/2d/navigation/actions/Pan.js
var d11 = class extends m {
  constructor(t18) {
    super(t18), this.animationTime = 0, this.momentumEstimator = new l15(500, 6, 0.92), this.momentum = null, this.tmpMomentum = n(), this.momentumFinished = false, this.viewpoint = new u2({ targetGeometry: new w(), scale: 0, rotation: 0 }), f2(() => this.momentumFinished, () => this.navigation.stop());
  }
  begin(t18, i16) {
    this.navigation.begin(), this.momentumEstimator.reset(), this.addToEstimator(i16), this._previousDrag = i16;
  }
  update(t18, i16) {
    this.addToEstimator(i16);
    let o17 = i16.center.x, m10 = i16.center.y;
    const s16 = this._previousDrag;
    o17 = s16 ? s16.center.x - o17 : -o17, m10 = s16 ? m10 - s16.center.y : m10, t18.viewpoint = St(this.viewpoint, t18.viewpoint, [o17 || 0, m10 || 0]), this._previousDrag = i16;
  }
  end(t18, i16) {
    this.addToEstimator(i16);
    const o17 = t18.navigation.momentumEnabled;
    this.momentum = o17 ? this.momentumEstimator.evaluateMomentum() : null, this.animationTime = 0, this.momentum && this.onAnimationUpdate(t18), this._previousDrag = null, this.navigation.end();
  }
  addToEstimator(t18) {
    const i16 = t18.center.x, o17 = t18.center.y, m10 = i(-i16, o17), e16 = r2(-i16, o17, 0);
    this.momentumEstimator.add(m10, e16, 1e-3 * t18.timestamp);
  }
  onAnimationUpdate(t18) {
    this.navigation.animationManager.animateContinous(t18.viewpoint, (i16, o17) => {
      this.momentumFinished = !this.momentum || this.momentum.isFinished(this.animationTime);
      const m10 = 1e-3 * o17;
      if (!this.momentumFinished) {
        const o18 = this.momentum.valueDelta(this.animationTime, m10);
        g(this.tmpMomentum, this.momentum.direction, o18), St(i16, i16, this.tmpMomentum), t18.constraints.constrainByGeometry(i16);
      }
      this.animationTime += m10;
    });
  }
  stopMomentumNavigation() {
    this.momentum && (this.momentumEstimator.reset(), this.momentum = null, this.navigation.stop());
  }
};
e([y()], d11.prototype, "momentumFinished", void 0), e([y()], d11.prototype, "viewpoint", void 0), e([y()], d11.prototype, "navigation", void 0), d11 = e([n2("esri.views.2d.navigation.actions.Pan")], d11);
var v3 = d11;

// node_modules/@arcgis/core/views/navigation/MomentumEstimator.js
var s13 = class {
  constructor(t18 = 2.5, i16 = 0.01, s16 = 0.95, l17 = 12) {
    this._minimumInitialVelocity = t18, this._stopVelocity = i16, this._friction = s16, this._maxVelocity = l17, this.enabled = true, this.value = new t15(0.8), this.time = new t15(0.3);
  }
  add(t18, e16) {
    if (this.enabled && null != e16) {
      if (this.time.hasLastValue()) {
        if (this.time.computeDelta(e16) < 0.01)
          return;
        if (this.value.hasFilteredDelta()) {
          const e17 = this.value.computeDelta(t18);
          this.value.filteredDelta * e17 < 0 && this.value.reset();
        }
      }
      this.time.update(e16), this.value.update(t18);
    }
  }
  reset() {
    this.value.reset(), this.time.reset();
  }
  evaluateMomentum() {
    if (!this.enabled || !this.value.hasFilteredDelta() || !this.time.hasFilteredDelta())
      return null;
    let e16 = this.value.filteredDelta / this.time.filteredDelta;
    return e16 = a2(e16, -this._maxVelocity, this._maxVelocity), Math.abs(e16) < this._minimumInitialVelocity ? null : this.createMomentum(e16, this._stopVelocity, this._friction);
  }
  createMomentum(t18, e16, s16) {
    return new t16(t18, e16, s16);
  }
};

// node_modules/@arcgis/core/views/navigation/RotationMomentumEstimator.js
var a16 = class extends s13 {
  constructor(t18 = 3, a18 = 0.01, s16 = 0.95, o17 = 12) {
    super(t18, a18, s16, o17);
  }
  add(t18, a18) {
    const s16 = this.value.lastValue;
    if (null != s16) {
      let a19 = t18 - s16;
      for (; a19 > Math.PI; )
        a19 -= 2 * Math.PI;
      for (; a19 < -Math.PI; )
        a19 += 2 * Math.PI;
      t18 = s16 + a19;
    }
    super.add(t18, a18);
  }
};

// node_modules/@arcgis/core/views/navigation/ZoomMomentumEstimator.js
var r17 = class extends t16 {
  constructor(e16, t18, r18) {
    super(e16, t18, r18);
  }
  value(e16) {
    const t18 = super.value(e16);
    return Math.exp(t18);
  }
  valueDelta(e16, t18) {
    const r18 = super.value(e16), s16 = super.value(e16 + t18) - r18;
    return Math.exp(s16);
  }
};
var s14 = class extends s13 {
  constructor(e16 = 2.5, t18 = 0.01, r18 = 0.95, s16 = 12) {
    super(e16, t18, r18, s16);
  }
  add(e16, t18) {
    super.add(Math.log(e16), t18);
  }
  createMomentum(e16, t18, s16) {
    return new r17(e16, t18, s16);
  }
};

// node_modules/@arcgis/core/views/2d/navigation/actions/Pinch.js
var _7 = class extends m {
  constructor(t18) {
    super(t18), this._animationTime = 0, this._momentumFinished = false, this._rotationMomentumEstimator = new a16(0.6, 0.15, 0.95), this._rotationDirection = 1, this._zoomDirection = 1, this._zoomMomentumEstimator = new s14(), this._zoomOnly = null, this.zoomMomentum = null, this.rotateMomentum = null, this.viewpoint = new u2({ targetGeometry: new w(), scale: 0, rotation: 0 }), this.addHandles(f2(() => this._momentumFinished, () => this.navigation.stop()));
  }
  begin(t18, o17) {
    this.navigation.begin(), this._rotationMomentumEstimator.reset(), this._zoomMomentumEstimator.reset(), this._zoomOnly = null, this._previousAngle = this._startAngle = o17.angle, this._previousRadius = this._startRadius = o17.radius, this._previousCenter = o17.center, this._updateTimestamp = null, t18.constraints.rotationEnabled && this.addToRotateEstimator(0, o17.timestamp), this.addToZoomEstimator(o17, 1);
  }
  update(t18, o17) {
    null === this._updateTimestamp && (this._updateTimestamp = o17.timestamp);
    const i16 = o17.angle, s16 = o17.radius, e16 = o17.center, n23 = Math.abs(180 * (i16 - this._startAngle) / Math.PI), m10 = Math.abs(s16 - this._startRadius), a18 = this._startRadius / s16;
    if (this._previousRadius) {
      const r18 = s16 / this._previousRadius;
      let h9 = 180 * (i16 - this._previousAngle) / Math.PI;
      this._rotationDirection = h9 >= 0 ? 1 : -1, this._zoomDirection = r18 >= 1 ? 1 : -1, t18.constraints.rotationEnabled ? (null === this._zoomOnly && o17.timestamp - this._updateTimestamp > 200 && (this._zoomOnly = m10 - n23 > 0), null === this._zoomOnly || this._zoomOnly ? h9 = 0 : this.addToRotateEstimator(i16 - this._startAngle, o17.timestamp)) : h9 = 0, this.addToZoomEstimator(o17, a18), this.navigation.setViewpoint([e16.x, e16.y], 1 / r18, h9, [this._previousCenter.x - e16.x, e16.y - this._previousCenter.y]);
    }
    this._previousAngle = i16, this._previousRadius = s16, this._previousCenter = e16;
  }
  end(t18) {
    this.rotateMomentum = this._rotationMomentumEstimator.evaluateMomentum(), this.zoomMomentum = this._zoomMomentumEstimator.evaluateMomentum(), this._animationTime = 0, (this.rotateMomentum || this.zoomMomentum) && this.onAnimationUpdate(t18), this.navigation.end();
  }
  addToRotateEstimator(t18, o17) {
    this._rotationMomentumEstimator.add(t18, 1e-3 * o17);
  }
  addToZoomEstimator(t18, o17) {
    this._zoomMomentumEstimator.add(o17, 1e-3 * t18.timestamp);
  }
  canZoomIn(t18) {
    const o17 = t18.scale, i16 = t18.constraints.effectiveMaxScale;
    return 0 === i16 || o17 > i16;
  }
  canZoomOut(t18) {
    const o17 = t18.scale, i16 = t18.constraints.effectiveMinScale;
    return 0 === i16 || o17 < i16;
  }
  onAnimationUpdate(t18) {
    this.navigation.animationManager.animateContinous(t18.viewpoint, (o17, i16) => {
      const s16 = !this.canZoomIn(t18) && this._zoomDirection > 1 || !this.canZoomOut(t18) && this._zoomDirection < 1, e16 = !this.rotateMomentum || this.rotateMomentum.isFinished(this._animationTime), n23 = s16 || !this.zoomMomentum || this.zoomMomentum.isFinished(this._animationTime), p6 = 1e-3 * i16;
      if (this._momentumFinished = e16 && n23, !this._momentumFinished) {
        const i17 = this.rotateMomentum ? Math.abs(this.rotateMomentum.valueDelta(this._animationTime, p6)) * this._rotationDirection * 180 / Math.PI : 0;
        let s17 = this.zoomMomentum ? Math.abs(this.zoomMomentum.valueDelta(this._animationTime, p6)) : 1;
        const e17 = n6(), n24 = n6();
        if (this._previousCenter) {
          r5(e17, this._previousCenter.x, this._previousCenter.y), nt(n24, t18.size, t18.padding), s5(e17, e17, n24);
          const { constraints: r18, scale: p7 } = t18, c13 = p7 * s17;
          s17 < 1 && !r18.canZoomInTo(c13) ? (s17 = p7 / r18.effectiveMaxScale, this.zoomMomentum = null, this.rotateMomentum = null) : s17 > 1 && !r18.canZoomOutTo(c13) && (s17 = p7 / r18.effectiveMinScale, this.zoomMomentum = null, this.rotateMomentum = null), Gt(o17, t18.viewpoint, s17, i17, e17, t18.size), t18.constraints.constrainByGeometry(o17);
        }
      }
      this._animationTime += p6;
    });
  }
  stopMomentumNavigation() {
    (this.rotateMomentum || this.zoomMomentum) && (this.rotateMomentum && (this._rotationMomentumEstimator.reset(), this.rotateMomentum = null), this.zoomMomentum && (this._zoomMomentumEstimator.reset(), this.zoomMomentum = null), this.navigation.stop());
  }
};
e([y()], _7.prototype, "_momentumFinished", void 0), e([y()], _7.prototype, "viewpoint", void 0), e([y()], _7.prototype, "navigation", void 0), _7 = e([n2("esri.views.2d.navigation.actions.Pinch")], _7);
var d12 = _7;

// node_modules/@arcgis/core/views/2d/navigation/actions/Rotate.js
var u9 = n6();
var d13 = n6();
var j4 = class extends m {
  constructor(t18) {
    super(t18), this._previousCenter = n6(), this.viewpoint = new u2({ targetGeometry: new w(), scale: 0, rotation: 0 });
  }
  begin(t18, e16) {
    this.navigation.begin(), r5(this._previousCenter, e16.center.x, e16.center.y);
  }
  update(t18, e16) {
    const { state: { size: o17, padding: r18 } } = t18;
    r5(u9, e16.center.x, e16.center.y), $(d13, o17, r18), t18.viewpoint = bt2(this.viewpoint, t18.state.paddedViewState.viewpoint, pt(d13, this._previousCenter, u9)), a6(this._previousCenter, u9);
  }
  end() {
    this.navigation.end();
  }
};
e([y()], j4.prototype, "viewpoint", void 0), e([y()], j4.prototype, "navigation", void 0), j4 = e([n2("esri.views.2d.actions.Rotate")], j4);
var f9 = j4;

// node_modules/@arcgis/core/views/2d/navigation/MapViewNavigation.js
var l16 = 10;
var w2 = 1;
var v4 = new u2({ targetGeometry: new w() });
var d14 = [0, 0];
var g7 = 250;
var _8 = class extends m {
  constructor(t18) {
    super(t18), this._endTimer = null, this.animationManager = null;
  }
  initialize() {
    this.pan = new v3({ navigation: this }), this.rotate = new f9({ navigation: this }), this.pinch = new d12({ navigation: this }), this.zoomBox = new l14({ view: this.view, navigation: this });
  }
  destroy() {
    this.pan.destroy(), this.rotate.destroy(), this.pinch.destroy(), this.zoomBox.destroy(), this.pan = this.rotate = this.pinch = this.zoomBox = this.animationManager = null;
  }
  begin() {
    this._set("interacting", true);
  }
  end() {
    this._lastEventTimestamp = performance.now(), this._startTimer(g7);
  }
  async zoom(t18, i16 = this._getDefaultAnchor()) {
    if (this.stop(), this.begin(), this.view.constraints.snapToZoom && this.view.constraints.effectiveLODs)
      return t18 < 1 ? this.zoomIn(i16) : this.zoomOut(i16);
    this.setViewpoint(i16, t18, 0, [0, 0]);
  }
  async zoomIn(t18) {
    const i16 = this.view, o17 = i16.constraints.snapToNextScale(i16.scale);
    return this._zoomToScale(o17, t18);
  }
  async zoomOut(t18) {
    const i16 = this.view, o17 = i16.constraints.snapToPreviousScale(i16.scale);
    return this._zoomToScale(o17, t18);
  }
  setViewpoint(t18, i16, o17, n23) {
    this.begin(), this.view.state.viewpoint = this._scaleRotateTranslateViewpoint(this.view.viewpoint, t18, i16, o17, n23), this.end();
  }
  setViewpointImmediate(t18, i16 = 0, o17 = [0, 0], n23 = this._getDefaultAnchor()) {
    this.view.state.viewpoint = this._scaleRotateTranslateViewpoint(this.view.viewpoint, n23, t18, i16, o17);
  }
  continousRotateClockwise() {
    const t18 = this.get("view.viewpoint");
    this.animationManager.animateContinous(t18, (t19) => {
      bt2(t19, t19, -w2);
    });
  }
  continousRotateCounterclockwise() {
    const t18 = this.get("view.viewpoint");
    this.animationManager.animateContinous(t18, (t19) => {
      bt2(t19, t19, w2);
    });
  }
  resetRotation() {
    this.view.rotation = 0;
  }
  continousPanLeft() {
    this._continuousPan([-l16, 0]);
  }
  continousPanRight() {
    this._continuousPan([l16, 0]);
  }
  continousPanUp() {
    this._continuousPan([0, l16]);
  }
  continousPanDown() {
    this._continuousPan([0, -l16]);
  }
  stop() {
    this.pan.stopMomentumNavigation(), this.animationManager.stop(), this.end(), null !== this._endTimer && (clearTimeout(this._endTimer), this._endTimer = null, this._set("interacting", false));
  }
  _continuousPan(t18) {
    const i16 = this.view.viewpoint;
    this.animationManager.animateContinous(i16, (i17) => {
      St(i17, i17, t18), this.view.constraints.constrainByGeometry(i17);
    });
  }
  _startTimer(t18) {
    return null !== this._endTimer || (this._endTimer = setTimeout(() => {
      this._endTimer = null;
      const t19 = performance.now() - this._lastEventTimestamp;
      t19 < g7 ? this._endTimer = this._startTimer(t19) : this._set("interacting", false);
    }, t18)), this._endTimer;
  }
  _getDefaultAnchor() {
    const { size: t18, padding: { left: i16, right: o17, top: n23, bottom: e16 } } = this.view;
    return d14[0] = 0.5 * (t18[0] - o17 + i16), d14[1] = 0.5 * (t18[1] - e16 + n23), d14;
  }
  async _zoomToScale(t18, i16 = this._getDefaultAnchor()) {
    const { view: o17 } = this, { constraints: n23, scale: e16, viewpoint: s16, size: a18, padding: r18 } = o17, h9 = n23.canZoomInTo(t18), m10 = n23.canZoomOutTo(t18);
    if (!(t18 < e16 && !h9 || t18 > e16 && !m10))
      return Rt(v4, s16, t18 / e16, 0, i16, a18, r18), n23.constrainByGeometry(v4), o17.goTo(v4, { animate: true });
  }
  _scaleRotateTranslateViewpoint(t18, i16, o17, n23, e16) {
    const { view: s16 } = this, { size: a18, padding: h9, constraints: m10, scale: p6, viewpoint: u10 } = s16, l17 = p6 * o17, w3 = m10.canZoomInTo(l17), v5 = m10.canZoomOutTo(l17);
    return (o17 < 1 && !w3 || o17 > 1 && !v5) && (o17 = 1), St(u10, u10, e16), Rt(t18, u10, o17, n23, i16, a18, h9), m10.constrainByGeometry(t18);
  }
};
e([y()], _8.prototype, "animationManager", void 0), e([y({ type: Boolean, readOnly: true })], _8.prototype, "interacting", void 0), e([y()], _8.prototype, "pan", void 0), e([y()], _8.prototype, "pinch", void 0), e([y()], _8.prototype, "rotate", void 0), e([y()], _8.prototype, "view", void 0), e([y()], _8.prototype, "zoomBox", void 0), _8 = e([n2("esri.views.2d.navigation.MapViewNavigation")], _8);
var T3 = _8;

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/MagnifierPrograms.js
var a17 = { shaders: { vertexShader: n12("magnifier/magnifier.vert"), fragmentShader: n12("magnifier/magnifier.frag") }, attributes: /* @__PURE__ */ new Map([["a_pos", 0]]) };
function t17(r18) {
  return e8(r18, a17);
}

// node_modules/@arcgis/core/views/magnifier/resources.js
async function s15(s16) {
  const r18 = import("./mask-svg-RRFZBBQZ.js"), i16 = import("./overlay-svg-SDK2O6Y6.js"), o17 = t3((await r18).default, { signal: s16 }), e16 = t3((await i16).default, { signal: s16 }), m10 = { mask: await o17, overlay: await e16 };
  return f(s16), m10;
}

// node_modules/@arcgis/core/views/2d/magnifier/MagnifierView2D.js
var j5 = class extends r8 {
  constructor() {
    super(), this._handles = new t2(), this._resourcePixelRatio = 1, this.visible = false;
  }
  destroy() {
    this._handles.destroy(), this._handles = null, this._disposeRenderResources(), this._resourcesTask && (this._resourcesTask.abort(), this._resourcesTask = null);
  }
  get background() {
    return this._background;
  }
  set background(e16) {
    this._background = e16, this.requestRender();
  }
  get magnifier() {
    return this._magnifier;
  }
  set magnifier(e16) {
    this._magnifier = e16, this._handles.removeAll(), this._handles.add([l(() => e16.version, () => {
      this.visible = e16.visible && r(e16.position) && e16.size > 0, this.requestRender();
    }, h), l(() => [e16.maskUrl, e16.overlayUrl], () => this._reloadResources()), l(() => e16.size, () => {
      this._disposeRenderResources(), this.requestRender();
    })]);
  }
  _createTransforms() {
    return { dvs: e3() };
  }
  doRender(e16) {
    var _a;
    const r18 = e16.context;
    if (!this._resourcesTask)
      return void this._reloadResources();
    if (e16.drawPhase !== I3.MAP || !this._canRender())
      return;
    this._updateResources(e16);
    const s16 = this._magnifier;
    if (t(s16.position))
      return;
    const a18 = e16.pixelRatio, o17 = s16.size * a18, n23 = 1 / s16.factor, l17 = Math.ceil(n23 * o17);
    this._readbackTexture.resize(l17, l17);
    const { size: h9 } = e16.state, m10 = a18 * h9[0], u10 = a18 * h9[1], c13 = 0.5 * l17, _9 = 0.5 * l17, p6 = a2(a18 * s16.position.x, c13, m10 - c13 - 1), f10 = a2(u10 - a18 * s16.position.y, _9, u10 - _9 - 1);
    r18.setBlendingEnabled(true);
    const g8 = p6 - c13, b4 = f10 - _9, x2 = this._readbackTexture;
    r18.bindTexture(x2, 0), r18.gl.copyTexImage2D(x2.descriptor.target, 0, x2.descriptor.pixelFormat, g8, b4, l17, l17, 0);
    const R2 = (_a = this.background) == null ? void 0 : _a.color, y5 = R2 ? [R2.a * R2.r / 255, R2.a * R2.g / 255, R2.a * R2.b / 255, R2.a] : [1, 1, 1, 1], k2 = (p6 + s16.offset.x * a18) / m10 * 2 - 1, A2 = (f10 - s16.offset.y * a18) / u10 * 2 - 1, v5 = o17 / m10 * 2, E5 = o17 / u10 * 2, j6 = this._program;
    r18.bindVAO(this._vertexArrayObject), r18.bindTexture(this._overlayTexture, 6), r18.bindTexture(this._maskTexture, 7), r18.useProgram(j6), j6.setUniform4fv("u_background", y5), j6.setUniform1i("u_readbackTexture", 0), j6.setUniform1i("u_overlayTexture", 6), j6.setUniform1i("u_maskTexture", 7), j6.setUniform4f("u_drawPos", k2, A2, v5, E5), j6.setUniform1i("u_maskEnabled", s16.maskEnabled ? 1 : 0), j6.setUniform1i("u_overlayEnabled", s16.overlayEnabled ? 1 : 0), r18.setStencilTestEnabled(false), r18.setColorMask(true, true, true, true), r18.drawArrays(E.TRIANGLE_STRIP, 0, 4), r18.bindVAO();
  }
  _canRender() {
    return this.mask && this.overlay && null != this._magnifier;
  }
  _reloadResources() {
    this._resourcesTask && this._resourcesTask.abort();
    const s16 = r(this._magnifier) ? this._magnifier.maskUrl : null, t18 = r(this._magnifier) ? this._magnifier.overlayUrl : null;
    this._resourcesTask = j2(async (r18) => {
      const o17 = t(s16) || t(t18) ? s15(r18) : null, n23 = r(s16) ? U(s16, { responseType: "image", signal: r18 }).then((e16) => e16.data) : o17.then((e16) => e16.mask), l17 = r(t18) ? U(t18, { responseType: "image", signal: r18 }).then((e16) => e16.data) : o17.then((e16) => e16.overlay), [h9, m10] = await Promise.all([n23, l17]);
      this.mask = h9, this.overlay = m10, this._disposeRenderResources(), this.requestRender();
    });
  }
  _disposeRenderResources() {
    this._readbackTexture = a(this._readbackTexture), this._overlayTexture = a(this._overlayTexture), this._maskTexture = a(this._maskTexture), this._vertexArrayObject = a(this._vertexArrayObject), this._program = a(this._program);
  }
  _updateResources(e16) {
    if (e16.pixelRatio !== this._resourcePixelRatio && this._disposeRenderResources(), this._readbackTexture)
      return;
    const r18 = e16.context;
    this._resourcePixelRatio = e16.pixelRatio;
    const s16 = Math.ceil(this._magnifier.size * e16.pixelRatio);
    this._program = t17(r18);
    const t18 = new Uint16Array([0, 1, 0, 0, 1, 1, 1, 0]), i16 = a17.attributes;
    this._vertexArrayObject = new a7(r18, i16, m3, { geometry: E3.createVertex(r18, F.STATIC_DRAW, t18) }), this.overlay.width = s16, this.overlay.height = s16, this._overlayTexture = new E2(r18, { target: M2.TEXTURE_2D, pixelFormat: P.RGBA, internalFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, wrapMode: D2.CLAMP_TO_EDGE, samplingMode: L.NEAREST, flipped: true, preMultiplyAlpha: !It(this.overlay.src) || !e16.context.driverTest.svgAlwaysPremultipliesAlpha }, this.overlay), this.mask.width = s16, this.mask.height = s16, this._maskTexture = new E2(r18, { target: M2.TEXTURE_2D, pixelFormat: P.ALPHA, internalFormat: P.ALPHA, dataType: G.UNSIGNED_BYTE, wrapMode: D2.CLAMP_TO_EDGE, samplingMode: L.NEAREST, flipped: true }, this.mask);
    const a18 = 1 / this._magnifier.factor;
    this._readbackTexture = new E2(r18, { target: M2.TEXTURE_2D, pixelFormat: P.RGBA, internalFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, wrapMode: D2.CLAMP_TO_EDGE, samplingMode: L.LINEAR, flipped: false, width: Math.ceil(a18 * s16), height: Math.ceil(a18 * s16) });
  }
};
export {
  i5 as GraphicContainer,
  oe as GraphicsView2D,
  d10 as LabelManager,
  j5 as MagnifierView2D,
  T3 as MapViewNavigation,
  P4 as Stage
};
//# sourceMappingURL=mapViewDeps-TWG2WSOS.js.map
